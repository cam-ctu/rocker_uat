
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[08:26:18.706] plan(): Setting new future strategy stack:
[08:26:18.706] List of future strategies:
[08:26:18.706] 1. sequential:
[08:26:18.706]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:18.706]    - tweaked: FALSE
[08:26:18.706]    - call: future::plan("sequential")
[08:26:18.721] plan(): nbrOfWorkers() = 1
> 
> 
> message("*** future_vapply() ...")
*** future_vapply() ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   x <- NULL
+   fun <- is.factor
+   fun_name <- "is.factor"
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_vapply(x, FUN = fun_name, FUN.VALUE = fun_value)
+   str(y2)
+   stopifnot(all.equal(y2, y0))
+   
+   x <- list()
+   fun <- is.numeric
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- integer()
+   fun <- identity
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   
+   df <- data.frame(x = 1:10, y = letters[1:10], stringsAsFactors=FALSE)
+   fun <- class
+   fun_value <- character(1L)
+   y0 <- vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- 1:10
+   fun <- function(x) double(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) integer(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- sqrt
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) c(x, x^2)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   ## Ditto with dimnames on FUN.VALUE
+   fun <- function(x) {
+     matrix(x, nrow = 2L, ncol = 2L, dimnames = list(c("a", "b"), c("A", "B")))
+   }
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   message("- From example(vapply) ...")
+   x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE, FALSE, FALSE, TRUE))
+   y0 <- vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   y1 <- future_vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   i39 <- sapply(3:9, seq)
+   ys0 <- sapply(i39, fivenum)
+   ys1 <- future_sapply(i39, fivenum)
+   stopifnot(all.equal(ys1, ys0))
+   
+   yv0 <- vapply(i39, fivenum,
+           c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   yv1 <- future_vapply(i39, fivenum,
+          c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   v <- structure(10*(5:8), names = LETTERS[1:4])
+   f <- function(x, y) outer(rep(x, length.out = 3L), y)
+   ys0 <- sapply(v, f, y = 2*(1:5), simplify = "array")
+   ys1 <- future_sapply(v, f, y = 2*(1:5), simplify = "array")
+   stopifnot(all.equal(ys1, ys0))
+   
+   fv <- outer(1:3, 1:5)
+   y <- 2*(1:5)
+   yv0 <- vapply(v, f, fv, y = y)
+   yv1 <- future_vapply(v, f, fv, y = y)
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   y0 <- vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   y1 <- future_vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_vapply(x, ...) where length(x) != length(as.list(x)) ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   as.list.Foo <- function(x, ...) c(x, c = 3)
+   y0 <- vapply(x, FUN = length, FUN.VALUE = -1L)
+   y1 <- future_vapply(x, FUN = length, FUN.VALUE = -1L)
+   stopifnot(identical(y1, y0))
+ 
+   message("- exceptions ...")
+   res <- tryCatch({
+     y0 <- vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   res <- tryCatch({
+     y1 <- future_vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[08:26:18.832] plan(): Setting new future strategy stack:
[08:26:18.832] List of future strategies:
[08:26:18.832] 1. sequential:
[08:26:18.832]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:18.832]    - tweaked: FALSE
[08:26:18.832]    - call: plan(strategy)
[08:26:18.845] plan(): nbrOfWorkers() = 1
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[08:26:18.850] future_lapply() ...
[08:26:18.856] Number of chunks: 1
[08:26:18.856] getGlobalsAndPackagesXApply() ...
[08:26:18.856]  - future.globals: TRUE
[08:26:18.856] getGlobalsAndPackages() ...
[08:26:18.857] Searching for globals...
[08:26:18.860] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[08:26:18.861] Searching for globals ... DONE
[08:26:18.861] Resolving globals: FALSE
[08:26:18.862] The total size of the 7 globals is 12.01 KiB (12294 bytes)
[08:26:18.863] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.02 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:18.863] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:18.863] - packages: [1] ‘future.apply’
[08:26:18.863] getGlobalsAndPackages() ... DONE
[08:26:18.863]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:18.863]  - needed namespaces: [n=1] ‘future.apply’
[08:26:18.863] Finding globals ... DONE
[08:26:18.863]  - use_args: TRUE
[08:26:18.863]  - Getting '...' globals ...
[08:26:18.864] resolve() on list ...
[08:26:18.864]  recursive: 0
[08:26:18.865]  length: 1
[08:26:18.865]  elements: ‘...’
[08:26:18.865]  length: 0 (resolved future 1)
[08:26:18.865] resolve() on list ... DONE
[08:26:18.865]    - '...' content: [n=0] 
[08:26:18.865] List of 1
[08:26:18.865]  $ ...: list()
[08:26:18.865]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:18.865]  - attr(*, "where")=List of 1
[08:26:18.865]   ..$ ...:<environment: 0x562ca58f7c50> 
[08:26:18.865]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:18.865]  - attr(*, "resolved")= logi TRUE
[08:26:18.865]  - attr(*, "total_size")= num NA
[08:26:18.867]  - Getting '...' globals ... DONE
[08:26:18.868] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:18.868] List of 8
[08:26:18.868]  $ ...future.FUN:function (x, ...)  
[08:26:18.868]  $ x_FUN        :function (x)  
[08:26:18.868]  $ times        : int 1
[08:26:18.868]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:18.868]  $ stop_if_not  :function (...)  
[08:26:18.868]  $ dim          : NULL
[08:26:18.868]  $ valid_types  : chr "character"
[08:26:18.868]  $ ...          : list()
[08:26:18.868]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:18.868]  - attr(*, "where")=List of 8
[08:26:18.868]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:18.868]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:18.868]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:18.868]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:18.868]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:18.868]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:18.868]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:18.868]   ..$ ...          :<environment: 0x562ca58f7c50> 
[08:26:18.868]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:18.868]  - attr(*, "resolved")= logi FALSE
[08:26:18.868]  - attr(*, "total_size")= num 22333
[08:26:18.873] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:18.873] getGlobalsAndPackagesXApply() ... DONE
[08:26:18.874] Number of futures (= number of chunks): 1
[08:26:18.874] Launching 1 futures (chunks) ...
[08:26:18.874] Chunk #1 of 1 ...
[08:26:18.874]  - Finding globals in 'X' for chunk #1 ...
[08:26:18.874] getGlobalsAndPackages() ...
[08:26:18.874] Searching for globals...
[08:26:18.877] 
[08:26:18.877] Searching for globals ... DONE
[08:26:18.877] - globals: [0] <none>
[08:26:18.877] getGlobalsAndPackages() ... DONE
[08:26:18.878]    + additional globals found: [n=0] 
[08:26:18.878]    + additional namespaces needed: [n=0] 
[08:26:18.878]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:18.878]  - seeds: <none>
[08:26:18.878]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:18.878] getGlobalsAndPackages() ...
[08:26:18.878] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:18.878] Resolving globals: FALSE
[08:26:18.878] Tweak future expression to call with '...' arguments ...
[08:26:18.879] {
[08:26:18.879]     do.call(function(...) {
[08:26:18.879]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:18.879]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:18.879]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:18.879]             on.exit(options(oopts), add = TRUE)
[08:26:18.879]         }
[08:26:18.879]         {
[08:26:18.879]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:18.879]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:18.879]                 ...future.FUN(...future.X_jj, ...)
[08:26:18.879]             })
[08:26:18.879]         }
[08:26:18.879]     }, args = future.call.arguments)
[08:26:18.879] }
[08:26:18.879] Tweak future expression to call with '...' arguments ... DONE
[08:26:18.879] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:18.879] - packages: [1] ‘future.apply’
[08:26:18.880] getGlobalsAndPackages() ... DONE
[08:26:18.880] run() for ‘Future’ ...
[08:26:18.880] - state: ‘created’
[08:26:18.881] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:26:18.881] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:18.881] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:18.881]   - Field: ‘label’
[08:26:18.881]   - Field: ‘local’
[08:26:18.881]   - Field: ‘owner’
[08:26:18.881]   - Field: ‘envir’
[08:26:18.882]   - Field: ‘packages’
[08:26:18.882]   - Field: ‘gc’
[08:26:18.882]   - Field: ‘conditions’
[08:26:18.882]   - Field: ‘expr’
[08:26:18.882]   - Field: ‘uuid’
[08:26:18.882]   - Field: ‘seed’
[08:26:18.882]   - Field: ‘version’
[08:26:18.882]   - Field: ‘result’
[08:26:18.882]   - Field: ‘asynchronous’
[08:26:18.882]   - Field: ‘calls’
[08:26:18.882]   - Field: ‘globals’
[08:26:18.882]   - Field: ‘stdout’
[08:26:18.883]   - Field: ‘earlySignal’
[08:26:18.883]   - Field: ‘lazy’
[08:26:18.883]   - Field: ‘state’
[08:26:18.883] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:18.883] - Launch lazy future ...
[08:26:18.884] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:18.884] Packages needed by future strategies (n = 0): <none>
[08:26:18.885] {
[08:26:18.885]     {
[08:26:18.885]         {
[08:26:18.885]             ...future.startTime <- base::Sys.time()
[08:26:18.885]             {
[08:26:18.885]                 {
[08:26:18.885]                   {
[08:26:18.885]                     {
[08:26:18.885]                       base::local({
[08:26:18.885]                         has_future <- base::requireNamespace("future", 
[08:26:18.885]                           quietly = TRUE)
[08:26:18.885]                         if (has_future) {
[08:26:18.885]                           ns <- base::getNamespace("future")
[08:26:18.885]                           version <- ns[[".package"]][["version"]]
[08:26:18.885]                           if (is.null(version)) 
[08:26:18.885]                             version <- utils::packageVersion("future")
[08:26:18.885]                         }
[08:26:18.885]                         else {
[08:26:18.885]                           version <- NULL
[08:26:18.885]                         }
[08:26:18.885]                         if (!has_future || version < "1.8.0") {
[08:26:18.885]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:18.885]                             "", base::R.version$version.string), 
[08:26:18.885]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:18.885]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:18.885]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:18.885]                               "release", "version")], collapse = " "), 
[08:26:18.885]                             hostname = base::Sys.info()[["nodename"]])
[08:26:18.885]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:18.885]                             info)
[08:26:18.885]                           info <- base::paste(info, collapse = "; ")
[08:26:18.885]                           if (!has_future) {
[08:26:18.885]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:18.885]                               info)
[08:26:18.885]                           }
[08:26:18.885]                           else {
[08:26:18.885]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:18.885]                               info, version)
[08:26:18.885]                           }
[08:26:18.885]                           base::stop(msg)
[08:26:18.885]                         }
[08:26:18.885]                       })
[08:26:18.885]                     }
[08:26:18.885]                     base::local({
[08:26:18.885]                       for (pkg in "future.apply") {
[08:26:18.885]                         base::loadNamespace(pkg)
[08:26:18.885]                         base::library(pkg, character.only = TRUE)
[08:26:18.885]                       }
[08:26:18.885]                     })
[08:26:18.885]                   }
[08:26:18.885]                   ...future.strategy.old <- future::plan("list")
[08:26:18.885]                   options(future.plan = NULL)
[08:26:18.885]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:18.885]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:18.885]                 }
[08:26:18.885]                 ...future.workdir <- getwd()
[08:26:18.885]             }
[08:26:18.885]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:18.885]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:18.885]         }
[08:26:18.885]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:18.885]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:18.885]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:18.885]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:18.885]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:18.885]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:18.885]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:18.885]             base::names(...future.oldOptions))
[08:26:18.885]     }
[08:26:18.885]     if (FALSE) {
[08:26:18.885]     }
[08:26:18.885]     else {
[08:26:18.885]         if (TRUE) {
[08:26:18.885]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:18.885]                 open = "w")
[08:26:18.885]         }
[08:26:18.885]         else {
[08:26:18.885]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:18.885]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:18.885]         }
[08:26:18.885]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:18.885]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:18.885]             base::sink(type = "output", split = FALSE)
[08:26:18.885]             base::close(...future.stdout)
[08:26:18.885]         }, add = TRUE)
[08:26:18.885]     }
[08:26:18.885]     ...future.frame <- base::sys.nframe()
[08:26:18.885]     ...future.conditions <- base::list()
[08:26:18.885]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:18.885]     if (FALSE) {
[08:26:18.885]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:18.885]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:18.885]     }
[08:26:18.885]     ...future.result <- base::tryCatch({
[08:26:18.885]         base::withCallingHandlers({
[08:26:18.885]             ...future.value <- base::withVisible(base::local({
[08:26:18.885]                 do.call(function(...) {
[08:26:18.885]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:18.885]                   if (!identical(...future.globals.maxSize.org, 
[08:26:18.885]                     ...future.globals.maxSize)) {
[08:26:18.885]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:18.885]                     on.exit(options(oopts), add = TRUE)
[08:26:18.885]                   }
[08:26:18.885]                   {
[08:26:18.885]                     lapply(seq_along(...future.elements_ii), 
[08:26:18.885]                       FUN = function(jj) {
[08:26:18.885]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:18.885]                         ...future.FUN(...future.X_jj, ...)
[08:26:18.885]                       })
[08:26:18.885]                   }
[08:26:18.885]                 }, args = future.call.arguments)
[08:26:18.885]             }))
[08:26:18.885]             future::FutureResult(value = ...future.value$value, 
[08:26:18.885]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:18.885]                   ...future.rng), globalenv = if (FALSE) 
[08:26:18.885]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:18.885]                     ...future.globalenv.names))
[08:26:18.885]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:18.885]         }, condition = base::local({
[08:26:18.885]             c <- base::c
[08:26:18.885]             inherits <- base::inherits
[08:26:18.885]             invokeRestart <- base::invokeRestart
[08:26:18.885]             length <- base::length
[08:26:18.885]             list <- base::list
[08:26:18.885]             seq.int <- base::seq.int
[08:26:18.885]             signalCondition <- base::signalCondition
[08:26:18.885]             sys.calls <- base::sys.calls
[08:26:18.885]             `[[` <- base::`[[`
[08:26:18.885]             `+` <- base::`+`
[08:26:18.885]             `<<-` <- base::`<<-`
[08:26:18.885]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:18.885]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:18.885]                   3L)]
[08:26:18.885]             }
[08:26:18.885]             function(cond) {
[08:26:18.885]                 is_error <- inherits(cond, "error")
[08:26:18.885]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:18.885]                   NULL)
[08:26:18.885]                 if (is_error) {
[08:26:18.885]                   sessionInformation <- function() {
[08:26:18.885]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:18.885]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:18.885]                       search = base::search(), system = base::Sys.info())
[08:26:18.885]                   }
[08:26:18.885]                   ...future.conditions[[length(...future.conditions) + 
[08:26:18.885]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:18.885]                     cond$call), session = sessionInformation(), 
[08:26:18.885]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:18.885]                   signalCondition(cond)
[08:26:18.885]                 }
[08:26:18.885]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:18.885]                 "immediateCondition"))) {
[08:26:18.885]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:18.885]                   ...future.conditions[[length(...future.conditions) + 
[08:26:18.885]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:18.885]                   if (TRUE && !signal) {
[08:26:18.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:18.885]                     {
[08:26:18.885]                       inherits <- base::inherits
[08:26:18.885]                       invokeRestart <- base::invokeRestart
[08:26:18.885]                       is.null <- base::is.null
[08:26:18.885]                       muffled <- FALSE
[08:26:18.885]                       if (inherits(cond, "message")) {
[08:26:18.885]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:18.885]                         if (muffled) 
[08:26:18.885]                           invokeRestart("muffleMessage")
[08:26:18.885]                       }
[08:26:18.885]                       else if (inherits(cond, "warning")) {
[08:26:18.885]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:18.885]                         if (muffled) 
[08:26:18.885]                           invokeRestart("muffleWarning")
[08:26:18.885]                       }
[08:26:18.885]                       else if (inherits(cond, "condition")) {
[08:26:18.885]                         if (!is.null(pattern)) {
[08:26:18.885]                           computeRestarts <- base::computeRestarts
[08:26:18.885]                           grepl <- base::grepl
[08:26:18.885]                           restarts <- computeRestarts(cond)
[08:26:18.885]                           for (restart in restarts) {
[08:26:18.885]                             name <- restart$name
[08:26:18.885]                             if (is.null(name)) 
[08:26:18.885]                               next
[08:26:18.885]                             if (!grepl(pattern, name)) 
[08:26:18.885]                               next
[08:26:18.885]                             invokeRestart(restart)
[08:26:18.885]                             muffled <- TRUE
[08:26:18.885]                             break
[08:26:18.885]                           }
[08:26:18.885]                         }
[08:26:18.885]                       }
[08:26:18.885]                       invisible(muffled)
[08:26:18.885]                     }
[08:26:18.885]                     muffleCondition(cond, pattern = "^muffle")
[08:26:18.885]                   }
[08:26:18.885]                 }
[08:26:18.885]                 else {
[08:26:18.885]                   if (TRUE) {
[08:26:18.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:18.885]                     {
[08:26:18.885]                       inherits <- base::inherits
[08:26:18.885]                       invokeRestart <- base::invokeRestart
[08:26:18.885]                       is.null <- base::is.null
[08:26:18.885]                       muffled <- FALSE
[08:26:18.885]                       if (inherits(cond, "message")) {
[08:26:18.885]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:18.885]                         if (muffled) 
[08:26:18.885]                           invokeRestart("muffleMessage")
[08:26:18.885]                       }
[08:26:18.885]                       else if (inherits(cond, "warning")) {
[08:26:18.885]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:18.885]                         if (muffled) 
[08:26:18.885]                           invokeRestart("muffleWarning")
[08:26:18.885]                       }
[08:26:18.885]                       else if (inherits(cond, "condition")) {
[08:26:18.885]                         if (!is.null(pattern)) {
[08:26:18.885]                           computeRestarts <- base::computeRestarts
[08:26:18.885]                           grepl <- base::grepl
[08:26:18.885]                           restarts <- computeRestarts(cond)
[08:26:18.885]                           for (restart in restarts) {
[08:26:18.885]                             name <- restart$name
[08:26:18.885]                             if (is.null(name)) 
[08:26:18.885]                               next
[08:26:18.885]                             if (!grepl(pattern, name)) 
[08:26:18.885]                               next
[08:26:18.885]                             invokeRestart(restart)
[08:26:18.885]                             muffled <- TRUE
[08:26:18.885]                             break
[08:26:18.885]                           }
[08:26:18.885]                         }
[08:26:18.885]                       }
[08:26:18.885]                       invisible(muffled)
[08:26:18.885]                     }
[08:26:18.885]                     muffleCondition(cond, pattern = "^muffle")
[08:26:18.885]                   }
[08:26:18.885]                 }
[08:26:18.885]             }
[08:26:18.885]         }))
[08:26:18.885]     }, error = function(ex) {
[08:26:18.885]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:18.885]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:18.885]                 ...future.rng), started = ...future.startTime, 
[08:26:18.885]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:18.885]             version = "1.8"), class = "FutureResult")
[08:26:18.885]     }, finally = {
[08:26:18.885]         if (!identical(...future.workdir, getwd())) 
[08:26:18.885]             setwd(...future.workdir)
[08:26:18.885]         {
[08:26:18.885]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:18.885]                 ...future.oldOptions$nwarnings <- NULL
[08:26:18.885]             }
[08:26:18.885]             base::options(...future.oldOptions)
[08:26:18.885]             if (.Platform$OS.type == "windows") {
[08:26:18.885]                 old_names <- names(...future.oldEnvVars)
[08:26:18.885]                 envs <- base::Sys.getenv()
[08:26:18.885]                 names <- names(envs)
[08:26:18.885]                 common <- intersect(names, old_names)
[08:26:18.885]                 added <- setdiff(names, old_names)
[08:26:18.885]                 removed <- setdiff(old_names, names)
[08:26:18.885]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:18.885]                   envs[common]]
[08:26:18.885]                 NAMES <- toupper(changed)
[08:26:18.885]                 args <- list()
[08:26:18.885]                 for (kk in seq_along(NAMES)) {
[08:26:18.885]                   name <- changed[[kk]]
[08:26:18.885]                   NAME <- NAMES[[kk]]
[08:26:18.885]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:18.885]                     next
[08:26:18.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:18.885]                 }
[08:26:18.885]                 NAMES <- toupper(added)
[08:26:18.885]                 for (kk in seq_along(NAMES)) {
[08:26:18.885]                   name <- added[[kk]]
[08:26:18.885]                   NAME <- NAMES[[kk]]
[08:26:18.885]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:18.885]                     next
[08:26:18.885]                   args[[name]] <- ""
[08:26:18.885]                 }
[08:26:18.885]                 NAMES <- toupper(removed)
[08:26:18.885]                 for (kk in seq_along(NAMES)) {
[08:26:18.885]                   name <- removed[[kk]]
[08:26:18.885]                   NAME <- NAMES[[kk]]
[08:26:18.885]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:18.885]                     next
[08:26:18.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:18.885]                 }
[08:26:18.885]                 if (length(args) > 0) 
[08:26:18.885]                   base::do.call(base::Sys.setenv, args = args)
[08:26:18.885]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:18.885]             }
[08:26:18.885]             else {
[08:26:18.885]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:18.885]             }
[08:26:18.885]             {
[08:26:18.885]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:18.885]                   0L) {
[08:26:18.885]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:18.885]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:18.885]                   base::options(opts)
[08:26:18.885]                 }
[08:26:18.885]                 {
[08:26:18.885]                   {
[08:26:18.885]                     NULL
[08:26:18.885]                     RNGkind("Mersenne-Twister")
[08:26:18.885]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:18.885]                       inherits = FALSE)
[08:26:18.885]                   }
[08:26:18.885]                   options(future.plan = NULL)
[08:26:18.885]                   if (is.na(NA_character_)) 
[08:26:18.885]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:18.885]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:18.885]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:18.885]                     .init = FALSE)
[08:26:18.885]                 }
[08:26:18.885]             }
[08:26:18.885]         }
[08:26:18.885]     })
[08:26:18.885]     if (TRUE) {
[08:26:18.885]         base::sink(type = "output", split = FALSE)
[08:26:18.885]         if (TRUE) {
[08:26:18.885]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:18.885]         }
[08:26:18.885]         else {
[08:26:18.885]             ...future.result["stdout"] <- base::list(NULL)
[08:26:18.885]         }
[08:26:18.885]         base::close(...future.stdout)
[08:26:18.885]         ...future.stdout <- NULL
[08:26:18.885]     }
[08:26:18.885]     ...future.result$conditions <- ...future.conditions
[08:26:18.885]     ...future.result$finished <- base::Sys.time()
[08:26:18.885]     ...future.result
[08:26:18.885] }
[08:26:18.886] assign_globals() ...
[08:26:18.887] List of 11
[08:26:18.887]  $ ...future.FUN            :function (x, ...)  
[08:26:18.887]  $ x_FUN                    :function (x)  
[08:26:18.887]  $ times                    : int 1
[08:26:18.887]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:18.887]  $ stop_if_not              :function (...)  
[08:26:18.887]  $ dim                      : NULL
[08:26:18.887]  $ valid_types              : chr "character"
[08:26:18.887]  $ future.call.arguments    : list()
[08:26:18.887]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:18.887]  $ ...future.elements_ii    :List of 2
[08:26:18.887]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[08:26:18.887]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[08:26:18.887]  $ ...future.seeds_ii       : NULL
[08:26:18.887]  $ ...future.globals.maxSize: NULL
[08:26:18.887]  - attr(*, "where")=List of 11
[08:26:18.887]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:18.887]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:18.887]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:18.887]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:18.887]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:18.887]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:18.887]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:18.887]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:18.887]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:18.887]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:18.887]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:18.887]  - attr(*, "resolved")= logi FALSE
[08:26:18.887]  - attr(*, "total_size")= num 22333
[08:26:18.887]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:18.887]  - attr(*, "already-done")= logi TRUE
[08:26:18.894] - copied ‘...future.FUN’ to environment
[08:26:18.894] - copied ‘x_FUN’ to environment
[08:26:18.894] - copied ‘times’ to environment
[08:26:18.894] - copied ‘stopf’ to environment
[08:26:18.895] - copied ‘stop_if_not’ to environment
[08:26:18.895] - copied ‘dim’ to environment
[08:26:18.895] - copied ‘valid_types’ to environment
[08:26:18.895] - copied ‘future.call.arguments’ to environment
[08:26:18.895] - copied ‘...future.elements_ii’ to environment
[08:26:18.895] - copied ‘...future.seeds_ii’ to environment
[08:26:18.895] - copied ‘...future.globals.maxSize’ to environment
[08:26:18.895] assign_globals() ... done
[08:26:18.896] plan(): Setting new future strategy stack:
[08:26:18.896] List of future strategies:
[08:26:18.896] 1. sequential:
[08:26:18.896]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:18.896]    - tweaked: FALSE
[08:26:18.896]    - call: NULL
[08:26:18.896] plan(): nbrOfWorkers() = 1
[08:26:18.897] plan(): Setting new future strategy stack:
[08:26:18.898] List of future strategies:
[08:26:18.898] 1. sequential:
[08:26:18.898]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:18.898]    - tweaked: FALSE
[08:26:18.898]    - call: plan(strategy)
[08:26:18.898] plan(): nbrOfWorkers() = 1
[08:26:18.898] SequentialFuture started (and completed)
[08:26:18.899] - Launch lazy future ... done
[08:26:18.899] run() for ‘SequentialFuture’ ... done
[08:26:18.899] Created future:
[08:26:18.899] SequentialFuture:
[08:26:18.899] Label: ‘future_vapply-1’
[08:26:18.899] Expression:
[08:26:18.899] {
[08:26:18.899]     do.call(function(...) {
[08:26:18.899]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:18.899]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:18.899]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:18.899]             on.exit(options(oopts), add = TRUE)
[08:26:18.899]         }
[08:26:18.899]         {
[08:26:18.899]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:18.899]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:18.899]                 ...future.FUN(...future.X_jj, ...)
[08:26:18.899]             })
[08:26:18.899]         }
[08:26:18.899]     }, args = future.call.arguments)
[08:26:18.899] }
[08:26:18.899] Lazy evaluation: FALSE
[08:26:18.899] Asynchronous evaluation: FALSE
[08:26:18.899] Local evaluation: TRUE
[08:26:18.899] Environment: R_GlobalEnv
[08:26:18.899] Capture standard output: TRUE
[08:26:18.899] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:18.899] Globals: 11 objects totaling 12.43 KiB (function ‘...future.FUN’ of 4.02 KiB, function ‘x_FUN’ of 36 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:18.899] Packages: 1 packages (‘future.apply’)
[08:26:18.899] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:18.899] Resolved: TRUE
[08:26:18.899] Value: 79 bytes of class ‘list’
[08:26:18.899] Early signaling: FALSE
[08:26:18.899] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:18.899] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:18.900] Chunk #1 of 1 ... DONE
[08:26:18.900] Launching 1 futures (chunks) ... DONE
[08:26:18.900] Resolving 1 futures (chunks) ...
[08:26:18.901] resolve() on list ...
[08:26:18.901]  recursive: 0
[08:26:18.901]  length: 1
[08:26:18.901] 
[08:26:18.901] resolved() for ‘SequentialFuture’ ...
[08:26:18.901] - state: ‘finished’
[08:26:18.901] - run: TRUE
[08:26:18.901] - result: ‘FutureResult’
[08:26:18.901] resolved() for ‘SequentialFuture’ ... done
[08:26:18.901] Future #1
[08:26:18.902] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:18.902] - nx: 1
[08:26:18.902] - relay: TRUE
[08:26:18.902] - stdout: TRUE
[08:26:18.902] - signal: TRUE
[08:26:18.902] - resignal: FALSE
[08:26:18.902] - force: TRUE
[08:26:18.902] - relayed: [n=1] FALSE
[08:26:18.902] - queued futures: [n=1] FALSE
[08:26:18.903]  - until=1
[08:26:18.903]  - relaying element #1
[08:26:18.903] - relayed: [n=1] TRUE
[08:26:18.903] - queued futures: [n=1] TRUE
[08:26:18.903] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:18.903]  length: 0 (resolved future 1)
[08:26:18.903] Relaying remaining futures
[08:26:18.903] signalConditionsASAP(NULL, pos=0) ...
[08:26:18.903] - nx: 1
[08:26:18.904] - relay: TRUE
[08:26:18.904] - stdout: TRUE
[08:26:18.904] - signal: TRUE
[08:26:18.904] - resignal: FALSE
[08:26:18.904] - force: TRUE
[08:26:18.904] - relayed: [n=1] TRUE
[08:26:18.906] - queued futures: [n=1] TRUE
 - flush all
[08:26:18.906] - relayed: [n=1] TRUE
[08:26:18.906] - queued futures: [n=1] TRUE
[08:26:18.906] signalConditionsASAP(NULL, pos=0) ... done
[08:26:18.906] resolve() on list ... DONE
[08:26:18.906]  - Number of value chunks collected: 1
[08:26:18.907] Resolving 1 futures (chunks) ... DONE
[08:26:18.907] Reducing values from 1 chunks ...
[08:26:18.907]  - Number of values collected after concatenation: 2
[08:26:18.907]  - Number of values expected: 2
[08:26:18.907] Reducing values from 1 chunks ... DONE
[08:26:18.907] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[08:26:18.908] future_lapply() ...
[08:26:18.910] Number of chunks: 1
[08:26:18.910] getGlobalsAndPackagesXApply() ...
[08:26:18.910]  - future.globals: TRUE
[08:26:18.910] getGlobalsAndPackages() ...
[08:26:18.910] Searching for globals...
[08:26:18.914] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[08:26:18.914] Searching for globals ... DONE
[08:26:18.914] Resolving globals: FALSE
[08:26:18.915] The total size of the 7 globals is 12.77 KiB (13081 bytes)
[08:26:18.915] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.77 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:18.915] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:18.915] - packages: [1] ‘future.apply’
[08:26:18.915] getGlobalsAndPackages() ... DONE
[08:26:18.915]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:18.916]  - needed namespaces: [n=1] ‘future.apply’
[08:26:18.916] Finding globals ... DONE
[08:26:18.916]  - use_args: TRUE
[08:26:18.916]  - Getting '...' globals ...
[08:26:18.916] resolve() on list ...
[08:26:18.916]  recursive: 0
[08:26:18.916]  length: 1
[08:26:18.916]  elements: ‘...’
[08:26:18.917]  length: 0 (resolved future 1)
[08:26:18.917] resolve() on list ... DONE
[08:26:18.917]    - '...' content: [n=0] 
[08:26:18.917] List of 1
[08:26:18.917]  $ ...: list()
[08:26:18.917]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:18.917]  - attr(*, "where")=List of 1
[08:26:18.917]   ..$ ...:<environment: 0x562ca6608920> 
[08:26:18.917]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:18.917]  - attr(*, "resolved")= logi TRUE
[08:26:18.917]  - attr(*, "total_size")= num NA
[08:26:18.919]  - Getting '...' globals ... DONE
[08:26:18.919] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:18.919] List of 8
[08:26:18.919]  $ ...future.FUN:function (x, ...)  
[08:26:18.919]  $ x_FUN        :function (x)  
[08:26:18.919]  $ times        : int 0
[08:26:18.919]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:18.919]  $ stop_if_not  :function (...)  
[08:26:18.919]  $ dim          : NULL
[08:26:18.919]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:18.919]  $ ...          : list()
[08:26:18.919]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:18.919]  - attr(*, "where")=List of 8
[08:26:18.919]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:18.919]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:18.919]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:18.919]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:18.919]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:18.919]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:18.919]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:18.919]   ..$ ...          :<environment: 0x562ca6608920> 
[08:26:18.919]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:18.919]  - attr(*, "resolved")= logi FALSE
[08:26:18.919]  - attr(*, "total_size")= num 23490
[08:26:18.925] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:18.925] getGlobalsAndPackagesXApply() ... DONE
[08:26:18.925] Number of futures (= number of chunks): 1
[08:26:18.925] Launching 1 futures (chunks) ...
[08:26:18.925] Chunk #1 of 1 ...
[08:26:18.925]  - Finding globals in 'X' for chunk #1 ...
[08:26:18.925] getGlobalsAndPackages() ...
[08:26:18.925] Searching for globals...
[08:26:18.926] 
[08:26:18.926] Searching for globals ... DONE
[08:26:18.926] - globals: [0] <none>
[08:26:18.926] getGlobalsAndPackages() ... DONE
[08:26:18.926]    + additional globals found: [n=0] 
[08:26:18.926]    + additional namespaces needed: [n=0] 
[08:26:18.926]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:18.926]  - seeds: <none>
[08:26:18.926]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:18.927] getGlobalsAndPackages() ...
[08:26:18.927] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:18.927] Resolving globals: FALSE
[08:26:18.927] Tweak future expression to call with '...' arguments ...
[08:26:18.927] {
[08:26:18.927]     do.call(function(...) {
[08:26:18.927]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:18.927]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:18.927]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:18.927]             on.exit(options(oopts), add = TRUE)
[08:26:18.927]         }
[08:26:18.927]         {
[08:26:18.927]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:18.927]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:18.927]                 ...future.FUN(...future.X_jj, ...)
[08:26:18.927]             })
[08:26:18.927]         }
[08:26:18.927]     }, args = future.call.arguments)
[08:26:18.927] }
[08:26:18.927] Tweak future expression to call with '...' arguments ... DONE
[08:26:18.929] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:18.929] - packages: [1] ‘future.apply’
[08:26:18.930] getGlobalsAndPackages() ... DONE
[08:26:18.930] run() for ‘Future’ ...
[08:26:18.930] - state: ‘created’
[08:26:18.930] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:26:18.930] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:18.930] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:18.931]   - Field: ‘label’
[08:26:18.931]   - Field: ‘local’
[08:26:18.931]   - Field: ‘owner’
[08:26:18.931]   - Field: ‘envir’
[08:26:18.931]   - Field: ‘packages’
[08:26:18.931]   - Field: ‘gc’
[08:26:18.931]   - Field: ‘conditions’
[08:26:18.931]   - Field: ‘expr’
[08:26:18.931]   - Field: ‘uuid’
[08:26:18.931]   - Field: ‘seed’
[08:26:18.931]   - Field: ‘version’
[08:26:18.932]   - Field: ‘result’
[08:26:18.932]   - Field: ‘asynchronous’
[08:26:18.932]   - Field: ‘calls’
[08:26:18.932]   - Field: ‘globals’
[08:26:18.932]   - Field: ‘stdout’
[08:26:18.932]   - Field: ‘earlySignal’
[08:26:18.932]   - Field: ‘lazy’
[08:26:18.932]   - Field: ‘state’
[08:26:18.932] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:18.932] - Launch lazy future ...
[08:26:18.933] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:18.933] Packages needed by future strategies (n = 0): <none>
[08:26:18.933] {
[08:26:18.933]     {
[08:26:18.933]         {
[08:26:18.933]             ...future.startTime <- base::Sys.time()
[08:26:18.933]             {
[08:26:18.933]                 {
[08:26:18.933]                   {
[08:26:18.933]                     {
[08:26:18.933]                       base::local({
[08:26:18.933]                         has_future <- base::requireNamespace("future", 
[08:26:18.933]                           quietly = TRUE)
[08:26:18.933]                         if (has_future) {
[08:26:18.933]                           ns <- base::getNamespace("future")
[08:26:18.933]                           version <- ns[[".package"]][["version"]]
[08:26:18.933]                           if (is.null(version)) 
[08:26:18.933]                             version <- utils::packageVersion("future")
[08:26:18.933]                         }
[08:26:18.933]                         else {
[08:26:18.933]                           version <- NULL
[08:26:18.933]                         }
[08:26:18.933]                         if (!has_future || version < "1.8.0") {
[08:26:18.933]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:18.933]                             "", base::R.version$version.string), 
[08:26:18.933]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:18.933]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:18.933]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:18.933]                               "release", "version")], collapse = " "), 
[08:26:18.933]                             hostname = base::Sys.info()[["nodename"]])
[08:26:18.933]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:18.933]                             info)
[08:26:18.933]                           info <- base::paste(info, collapse = "; ")
[08:26:18.933]                           if (!has_future) {
[08:26:18.933]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:18.933]                               info)
[08:26:18.933]                           }
[08:26:18.933]                           else {
[08:26:18.933]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:18.933]                               info, version)
[08:26:18.933]                           }
[08:26:18.933]                           base::stop(msg)
[08:26:18.933]                         }
[08:26:18.933]                       })
[08:26:18.933]                     }
[08:26:18.933]                     base::local({
[08:26:18.933]                       for (pkg in "future.apply") {
[08:26:18.933]                         base::loadNamespace(pkg)
[08:26:18.933]                         base::library(pkg, character.only = TRUE)
[08:26:18.933]                       }
[08:26:18.933]                     })
[08:26:18.933]                   }
[08:26:18.933]                   ...future.strategy.old <- future::plan("list")
[08:26:18.933]                   options(future.plan = NULL)
[08:26:18.933]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:18.933]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:18.933]                 }
[08:26:18.933]                 ...future.workdir <- getwd()
[08:26:18.933]             }
[08:26:18.933]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:18.933]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:18.933]         }
[08:26:18.933]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:18.933]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:18.933]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:18.933]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:18.933]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:18.933]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:18.933]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:18.933]             base::names(...future.oldOptions))
[08:26:18.933]     }
[08:26:18.933]     if (FALSE) {
[08:26:18.933]     }
[08:26:18.933]     else {
[08:26:18.933]         if (TRUE) {
[08:26:18.933]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:18.933]                 open = "w")
[08:26:18.933]         }
[08:26:18.933]         else {
[08:26:18.933]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:18.933]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:18.933]         }
[08:26:18.933]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:18.933]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:18.933]             base::sink(type = "output", split = FALSE)
[08:26:18.933]             base::close(...future.stdout)
[08:26:18.933]         }, add = TRUE)
[08:26:18.933]     }
[08:26:18.933]     ...future.frame <- base::sys.nframe()
[08:26:18.933]     ...future.conditions <- base::list()
[08:26:18.933]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:18.933]     if (FALSE) {
[08:26:18.933]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:18.933]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:18.933]     }
[08:26:18.933]     ...future.result <- base::tryCatch({
[08:26:18.933]         base::withCallingHandlers({
[08:26:18.933]             ...future.value <- base::withVisible(base::local({
[08:26:18.933]                 do.call(function(...) {
[08:26:18.933]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:18.933]                   if (!identical(...future.globals.maxSize.org, 
[08:26:18.933]                     ...future.globals.maxSize)) {
[08:26:18.933]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:18.933]                     on.exit(options(oopts), add = TRUE)
[08:26:18.933]                   }
[08:26:18.933]                   {
[08:26:18.933]                     lapply(seq_along(...future.elements_ii), 
[08:26:18.933]                       FUN = function(jj) {
[08:26:18.933]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:18.933]                         ...future.FUN(...future.X_jj, ...)
[08:26:18.933]                       })
[08:26:18.933]                   }
[08:26:18.933]                 }, args = future.call.arguments)
[08:26:18.933]             }))
[08:26:18.933]             future::FutureResult(value = ...future.value$value, 
[08:26:18.933]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:18.933]                   ...future.rng), globalenv = if (FALSE) 
[08:26:18.933]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:18.933]                     ...future.globalenv.names))
[08:26:18.933]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:18.933]         }, condition = base::local({
[08:26:18.933]             c <- base::c
[08:26:18.933]             inherits <- base::inherits
[08:26:18.933]             invokeRestart <- base::invokeRestart
[08:26:18.933]             length <- base::length
[08:26:18.933]             list <- base::list
[08:26:18.933]             seq.int <- base::seq.int
[08:26:18.933]             signalCondition <- base::signalCondition
[08:26:18.933]             sys.calls <- base::sys.calls
[08:26:18.933]             `[[` <- base::`[[`
[08:26:18.933]             `+` <- base::`+`
[08:26:18.933]             `<<-` <- base::`<<-`
[08:26:18.933]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:18.933]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:18.933]                   3L)]
[08:26:18.933]             }
[08:26:18.933]             function(cond) {
[08:26:18.933]                 is_error <- inherits(cond, "error")
[08:26:18.933]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:18.933]                   NULL)
[08:26:18.933]                 if (is_error) {
[08:26:18.933]                   sessionInformation <- function() {
[08:26:18.933]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:18.933]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:18.933]                       search = base::search(), system = base::Sys.info())
[08:26:18.933]                   }
[08:26:18.933]                   ...future.conditions[[length(...future.conditions) + 
[08:26:18.933]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:18.933]                     cond$call), session = sessionInformation(), 
[08:26:18.933]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:18.933]                   signalCondition(cond)
[08:26:18.933]                 }
[08:26:18.933]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:18.933]                 "immediateCondition"))) {
[08:26:18.933]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:18.933]                   ...future.conditions[[length(...future.conditions) + 
[08:26:18.933]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:18.933]                   if (TRUE && !signal) {
[08:26:18.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:18.933]                     {
[08:26:18.933]                       inherits <- base::inherits
[08:26:18.933]                       invokeRestart <- base::invokeRestart
[08:26:18.933]                       is.null <- base::is.null
[08:26:18.933]                       muffled <- FALSE
[08:26:18.933]                       if (inherits(cond, "message")) {
[08:26:18.933]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:18.933]                         if (muffled) 
[08:26:18.933]                           invokeRestart("muffleMessage")
[08:26:18.933]                       }
[08:26:18.933]                       else if (inherits(cond, "warning")) {
[08:26:18.933]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:18.933]                         if (muffled) 
[08:26:18.933]                           invokeRestart("muffleWarning")
[08:26:18.933]                       }
[08:26:18.933]                       else if (inherits(cond, "condition")) {
[08:26:18.933]                         if (!is.null(pattern)) {
[08:26:18.933]                           computeRestarts <- base::computeRestarts
[08:26:18.933]                           grepl <- base::grepl
[08:26:18.933]                           restarts <- computeRestarts(cond)
[08:26:18.933]                           for (restart in restarts) {
[08:26:18.933]                             name <- restart$name
[08:26:18.933]                             if (is.null(name)) 
[08:26:18.933]                               next
[08:26:18.933]                             if (!grepl(pattern, name)) 
[08:26:18.933]                               next
[08:26:18.933]                             invokeRestart(restart)
[08:26:18.933]                             muffled <- TRUE
[08:26:18.933]                             break
[08:26:18.933]                           }
[08:26:18.933]                         }
[08:26:18.933]                       }
[08:26:18.933]                       invisible(muffled)
[08:26:18.933]                     }
[08:26:18.933]                     muffleCondition(cond, pattern = "^muffle")
[08:26:18.933]                   }
[08:26:18.933]                 }
[08:26:18.933]                 else {
[08:26:18.933]                   if (TRUE) {
[08:26:18.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:18.933]                     {
[08:26:18.933]                       inherits <- base::inherits
[08:26:18.933]                       invokeRestart <- base::invokeRestart
[08:26:18.933]                       is.null <- base::is.null
[08:26:18.933]                       muffled <- FALSE
[08:26:18.933]                       if (inherits(cond, "message")) {
[08:26:18.933]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:18.933]                         if (muffled) 
[08:26:18.933]                           invokeRestart("muffleMessage")
[08:26:18.933]                       }
[08:26:18.933]                       else if (inherits(cond, "warning")) {
[08:26:18.933]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:18.933]                         if (muffled) 
[08:26:18.933]                           invokeRestart("muffleWarning")
[08:26:18.933]                       }
[08:26:18.933]                       else if (inherits(cond, "condition")) {
[08:26:18.933]                         if (!is.null(pattern)) {
[08:26:18.933]                           computeRestarts <- base::computeRestarts
[08:26:18.933]                           grepl <- base::grepl
[08:26:18.933]                           restarts <- computeRestarts(cond)
[08:26:18.933]                           for (restart in restarts) {
[08:26:18.933]                             name <- restart$name
[08:26:18.933]                             if (is.null(name)) 
[08:26:18.933]                               next
[08:26:18.933]                             if (!grepl(pattern, name)) 
[08:26:18.933]                               next
[08:26:18.933]                             invokeRestart(restart)
[08:26:18.933]                             muffled <- TRUE
[08:26:18.933]                             break
[08:26:18.933]                           }
[08:26:18.933]                         }
[08:26:18.933]                       }
[08:26:18.933]                       invisible(muffled)
[08:26:18.933]                     }
[08:26:18.933]                     muffleCondition(cond, pattern = "^muffle")
[08:26:18.933]                   }
[08:26:18.933]                 }
[08:26:18.933]             }
[08:26:18.933]         }))
[08:26:18.933]     }, error = function(ex) {
[08:26:18.933]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:18.933]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:18.933]                 ...future.rng), started = ...future.startTime, 
[08:26:18.933]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:18.933]             version = "1.8"), class = "FutureResult")
[08:26:18.933]     }, finally = {
[08:26:18.933]         if (!identical(...future.workdir, getwd())) 
[08:26:18.933]             setwd(...future.workdir)
[08:26:18.933]         {
[08:26:18.933]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:18.933]                 ...future.oldOptions$nwarnings <- NULL
[08:26:18.933]             }
[08:26:18.933]             base::options(...future.oldOptions)
[08:26:18.933]             if (.Platform$OS.type == "windows") {
[08:26:18.933]                 old_names <- names(...future.oldEnvVars)
[08:26:18.933]                 envs <- base::Sys.getenv()
[08:26:18.933]                 names <- names(envs)
[08:26:18.933]                 common <- intersect(names, old_names)
[08:26:18.933]                 added <- setdiff(names, old_names)
[08:26:18.933]                 removed <- setdiff(old_names, names)
[08:26:18.933]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:18.933]                   envs[common]]
[08:26:18.933]                 NAMES <- toupper(changed)
[08:26:18.933]                 args <- list()
[08:26:18.933]                 for (kk in seq_along(NAMES)) {
[08:26:18.933]                   name <- changed[[kk]]
[08:26:18.933]                   NAME <- NAMES[[kk]]
[08:26:18.933]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:18.933]                     next
[08:26:18.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:18.933]                 }
[08:26:18.933]                 NAMES <- toupper(added)
[08:26:18.933]                 for (kk in seq_along(NAMES)) {
[08:26:18.933]                   name <- added[[kk]]
[08:26:18.933]                   NAME <- NAMES[[kk]]
[08:26:18.933]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:18.933]                     next
[08:26:18.933]                   args[[name]] <- ""
[08:26:18.933]                 }
[08:26:18.933]                 NAMES <- toupper(removed)
[08:26:18.933]                 for (kk in seq_along(NAMES)) {
[08:26:18.933]                   name <- removed[[kk]]
[08:26:18.933]                   NAME <- NAMES[[kk]]
[08:26:18.933]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:18.933]                     next
[08:26:18.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:18.933]                 }
[08:26:18.933]                 if (length(args) > 0) 
[08:26:18.933]                   base::do.call(base::Sys.setenv, args = args)
[08:26:18.933]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:18.933]             }
[08:26:18.933]             else {
[08:26:18.933]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:18.933]             }
[08:26:18.933]             {
[08:26:18.933]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:18.933]                   0L) {
[08:26:18.933]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:18.933]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:18.933]                   base::options(opts)
[08:26:18.933]                 }
[08:26:18.933]                 {
[08:26:18.933]                   {
[08:26:18.933]                     NULL
[08:26:18.933]                     RNGkind("Mersenne-Twister")
[08:26:18.933]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:18.933]                       inherits = FALSE)
[08:26:18.933]                   }
[08:26:18.933]                   options(future.plan = NULL)
[08:26:18.933]                   if (is.na(NA_character_)) 
[08:26:18.933]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:18.933]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:18.933]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:18.933]                     .init = FALSE)
[08:26:18.933]                 }
[08:26:18.933]             }
[08:26:18.933]         }
[08:26:18.933]     })
[08:26:18.933]     if (TRUE) {
[08:26:18.933]         base::sink(type = "output", split = FALSE)
[08:26:18.933]         if (TRUE) {
[08:26:18.933]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:18.933]         }
[08:26:18.933]         else {
[08:26:18.933]             ...future.result["stdout"] <- base::list(NULL)
[08:26:18.933]         }
[08:26:18.933]         base::close(...future.stdout)
[08:26:18.933]         ...future.stdout <- NULL
[08:26:18.933]     }
[08:26:18.933]     ...future.result$conditions <- ...future.conditions
[08:26:18.933]     ...future.result$finished <- base::Sys.time()
[08:26:18.933]     ...future.result
[08:26:18.933] }
[08:26:18.935] assign_globals() ...
[08:26:18.935] List of 11
[08:26:18.935]  $ ...future.FUN            :function (x, ...)  
[08:26:18.935]  $ x_FUN                    :function (x)  
[08:26:18.935]  $ times                    : int 0
[08:26:18.935]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:18.935]  $ stop_if_not              :function (...)  
[08:26:18.935]  $ dim                      : NULL
[08:26:18.935]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:18.935]  $ future.call.arguments    : list()
[08:26:18.935]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:18.935]  $ ...future.elements_ii    :List of 10
[08:26:18.935]   ..$ : int 1
[08:26:18.935]   ..$ : int 2
[08:26:18.935]   ..$ : int 3
[08:26:18.935]   ..$ : int 4
[08:26:18.935]   ..$ : int 5
[08:26:18.935]   ..$ : int 6
[08:26:18.935]   ..$ : int 7
[08:26:18.935]   ..$ : int 8
[08:26:18.935]   ..$ : int 9
[08:26:18.935]   ..$ : int 10
[08:26:18.935]  $ ...future.seeds_ii       : NULL
[08:26:18.935]  $ ...future.globals.maxSize: NULL
[08:26:18.935]  - attr(*, "where")=List of 11
[08:26:18.935]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:18.935]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:18.935]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:18.935]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:18.935]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:18.935]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:18.935]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:18.935]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:18.935]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:18.935]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:18.935]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:18.935]  - attr(*, "resolved")= logi FALSE
[08:26:18.935]  - attr(*, "total_size")= num 23490
[08:26:18.935]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:18.935]  - attr(*, "already-done")= logi TRUE
[08:26:18.945] - copied ‘...future.FUN’ to environment
[08:26:18.945] - reassign environment for ‘x_FUN’
[08:26:18.945] - copied ‘x_FUN’ to environment
[08:26:18.945] - copied ‘times’ to environment
[08:26:18.945] - copied ‘stopf’ to environment
[08:26:18.945] - copied ‘stop_if_not’ to environment
[08:26:18.946] - copied ‘dim’ to environment
[08:26:18.946] - copied ‘valid_types’ to environment
[08:26:18.946] - copied ‘future.call.arguments’ to environment
[08:26:18.946] - copied ‘...future.elements_ii’ to environment
[08:26:18.946] - copied ‘...future.seeds_ii’ to environment
[08:26:18.946] - copied ‘...future.globals.maxSize’ to environment
[08:26:18.946] assign_globals() ... done
[08:26:18.947] plan(): Setting new future strategy stack:
[08:26:18.947] List of future strategies:
[08:26:18.947] 1. sequential:
[08:26:18.947]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:18.947]    - tweaked: FALSE
[08:26:18.947]    - call: NULL
[08:26:18.947] plan(): nbrOfWorkers() = 1
[08:26:18.948] plan(): Setting new future strategy stack:
[08:26:18.948] List of future strategies:
[08:26:18.948] 1. sequential:
[08:26:18.948]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:18.948]    - tweaked: FALSE
[08:26:18.948]    - call: plan(strategy)
[08:26:18.948] plan(): nbrOfWorkers() = 1
[08:26:18.949] SequentialFuture started (and completed)
[08:26:18.949] - Launch lazy future ... done
[08:26:18.949] run() for ‘SequentialFuture’ ... done
[08:26:18.949] Created future:
[08:26:18.949] SequentialFuture:
[08:26:18.949] Label: ‘future_vapply-1’
[08:26:18.949] Expression:
[08:26:18.949] {
[08:26:18.949]     do.call(function(...) {
[08:26:18.949]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:18.949]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:18.949]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:18.949]             on.exit(options(oopts), add = TRUE)
[08:26:18.949]         }
[08:26:18.949]         {
[08:26:18.949]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:18.949]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:18.949]                 ...future.FUN(...future.X_jj, ...)
[08:26:18.949]             })
[08:26:18.949]         }
[08:26:18.949]     }, args = future.call.arguments)
[08:26:18.949] }
[08:26:18.949] Lazy evaluation: FALSE
[08:26:18.949] Asynchronous evaluation: FALSE
[08:26:18.949] Local evaluation: TRUE
[08:26:18.949] Environment: R_GlobalEnv
[08:26:18.949] Capture standard output: TRUE
[08:26:18.949] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:18.949] Globals: 11 objects totaling 13.07 KiB (function ‘...future.FUN’ of 4.50 KiB, function ‘x_FUN’ of 295 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:18.949] Packages: 1 packages (‘future.apply’)
[08:26:18.949] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:18.949] Resolved: TRUE
[08:26:18.949] Value: 111 bytes of class ‘list’
[08:26:18.949] Early signaling: FALSE
[08:26:18.949] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:18.949] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:18.950] Chunk #1 of 1 ... DONE
[08:26:18.950] Launching 1 futures (chunks) ... DONE
[08:26:18.950] Resolving 1 futures (chunks) ...
[08:26:18.950] resolve() on list ...
[08:26:18.950]  recursive: 0
[08:26:18.951]  length: 1
[08:26:18.951] 
[08:26:18.951] resolved() for ‘SequentialFuture’ ...
[08:26:18.951] - state: ‘finished’
[08:26:18.951] - run: TRUE
[08:26:18.951] - result: ‘FutureResult’
[08:26:18.951] resolved() for ‘SequentialFuture’ ... done
[08:26:18.951] Future #1
[08:26:18.951] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:18.951] - nx: 1
[08:26:18.951] - relay: TRUE
[08:26:18.952] - stdout: TRUE
[08:26:18.952] - signal: TRUE
[08:26:18.952] - resignal: FALSE
[08:26:18.952] - force: TRUE
[08:26:18.952] - relayed: [n=1] FALSE
[08:26:18.952] - queued futures: [n=1] FALSE
[08:26:18.952]  - until=1
[08:26:18.952]  - relaying element #1
[08:26:18.952] - relayed: [n=1] TRUE
[08:26:18.954] - queued futures: [n=1] TRUE
[08:26:18.954] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:18.954]  length: 0 (resolved future 1)
[08:26:18.954] Relaying remaining futures
[08:26:18.954] signalConditionsASAP(NULL, pos=0) ...
[08:26:18.954] - nx: 1
[08:26:18.955] - relay: TRUE
[08:26:18.955] - stdout: TRUE
[08:26:18.955] - signal: TRUE
[08:26:18.955] - resignal: FALSE
[08:26:18.955] - force: TRUE
[08:26:18.955] - relayed: [n=1] TRUE
[08:26:18.955] - queued futures: [n=1] TRUE
 - flush all
[08:26:18.955] - relayed: [n=1] TRUE
[08:26:18.955] - queued futures: [n=1] TRUE
[08:26:18.955] signalConditionsASAP(NULL, pos=0) ... done
[08:26:18.955] resolve() on list ... DONE
[08:26:18.956]  - Number of value chunks collected: 1
[08:26:18.956] Resolving 1 futures (chunks) ... DONE
[08:26:18.956] Reducing values from 1 chunks ...
[08:26:18.956]  - Number of values collected after concatenation: 10
[08:26:18.956]  - Number of values expected: 10
[08:26:18.956] Reducing values from 1 chunks ... DONE
[08:26:18.956] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[08:26:18.957] future_lapply() ...
[08:26:18.959] Number of chunks: 1
[08:26:18.959] getGlobalsAndPackagesXApply() ...
[08:26:18.959]  - future.globals: TRUE
[08:26:18.959] getGlobalsAndPackages() ...
[08:26:18.959] Searching for globals...
[08:26:18.962] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[08:26:18.963] Searching for globals ... DONE
[08:26:18.963] Resolving globals: FALSE
[08:26:18.964] The total size of the 7 globals is 12.75 KiB (13056 bytes)
[08:26:18.964] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.50 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:18.964] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:18.964] - packages: [1] ‘future.apply’
[08:26:18.964] getGlobalsAndPackages() ... DONE
[08:26:18.964]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:18.965]  - needed namespaces: [n=1] ‘future.apply’
[08:26:18.965] Finding globals ... DONE
[08:26:18.965]  - use_args: TRUE
[08:26:18.965]  - Getting '...' globals ...
[08:26:18.965] resolve() on list ...
[08:26:18.965]  recursive: 0
[08:26:18.965]  length: 1
[08:26:18.965]  elements: ‘...’
[08:26:18.966]  length: 0 (resolved future 1)
[08:26:18.966] resolve() on list ... DONE
[08:26:18.966]    - '...' content: [n=0] 
[08:26:18.966] List of 1
[08:26:18.966]  $ ...: list()
[08:26:18.966]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:18.966]  - attr(*, "where")=List of 1
[08:26:18.966]   ..$ ...:<environment: 0x562ca618ea50> 
[08:26:18.966]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:18.966]  - attr(*, "resolved")= logi TRUE
[08:26:18.966]  - attr(*, "total_size")= num NA
[08:26:18.968]  - Getting '...' globals ... DONE
[08:26:18.968] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:18.968] List of 8
[08:26:18.968]  $ ...future.FUN:function (x, ...)  
[08:26:18.968]  $ x_FUN        :function (x)  
[08:26:18.968]  $ times        : int 0
[08:26:18.968]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:18.968]  $ stop_if_not  :function (...)  
[08:26:18.968]  $ dim          : NULL
[08:26:18.968]  $ valid_types  : chr [1:2] "logical" "integer"
[08:26:18.968]  $ ...          : list()
[08:26:18.968]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:18.968]  - attr(*, "where")=List of 8
[08:26:18.968]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:18.968]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:18.968]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:18.968]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:18.968]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:18.968]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:18.968]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:18.968]   ..$ ...          :<environment: 0x562ca618ea50> 
[08:26:18.968]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:18.968]  - attr(*, "resolved")= logi FALSE
[08:26:18.968]  - attr(*, "total_size")= num 23453
[08:26:18.974] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:18.974] getGlobalsAndPackagesXApply() ... DONE
[08:26:18.974] Number of futures (= number of chunks): 1
[08:26:18.974] Launching 1 futures (chunks) ...
[08:26:18.974] Chunk #1 of 1 ...
[08:26:18.974]  - Finding globals in 'X' for chunk #1 ...
[08:26:18.974] getGlobalsAndPackages() ...
[08:26:18.975] Searching for globals...
[08:26:18.975] 
[08:26:18.975] Searching for globals ... DONE
[08:26:18.975] - globals: [0] <none>
[08:26:18.975] getGlobalsAndPackages() ... DONE
[08:26:18.977]    + additional globals found: [n=0] 
[08:26:18.977]    + additional namespaces needed: [n=0] 
[08:26:18.977]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:18.977]  - seeds: <none>
[08:26:18.977]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:18.977] getGlobalsAndPackages() ...
[08:26:18.977] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:18.977] Resolving globals: FALSE
[08:26:18.978] Tweak future expression to call with '...' arguments ...
[08:26:18.978] {
[08:26:18.978]     do.call(function(...) {
[08:26:18.978]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:18.978]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:18.978]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:18.978]             on.exit(options(oopts), add = TRUE)
[08:26:18.978]         }
[08:26:18.978]         {
[08:26:18.978]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:18.978]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:18.978]                 ...future.FUN(...future.X_jj, ...)
[08:26:18.978]             })
[08:26:18.978]         }
[08:26:18.978]     }, args = future.call.arguments)
[08:26:18.978] }
[08:26:18.978] Tweak future expression to call with '...' arguments ... DONE
[08:26:18.978] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:18.979] - packages: [1] ‘future.apply’
[08:26:18.979] getGlobalsAndPackages() ... DONE
[08:26:18.979] run() for ‘Future’ ...
[08:26:18.979] - state: ‘created’
[08:26:18.979] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:26:18.979] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:18.980] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:18.980]   - Field: ‘label’
[08:26:18.980]   - Field: ‘local’
[08:26:18.980]   - Field: ‘owner’
[08:26:18.980]   - Field: ‘envir’
[08:26:18.980]   - Field: ‘packages’
[08:26:18.980]   - Field: ‘gc’
[08:26:18.980]   - Field: ‘conditions’
[08:26:18.980]   - Field: ‘expr’
[08:26:18.980]   - Field: ‘uuid’
[08:26:18.980]   - Field: ‘seed’
[08:26:18.981]   - Field: ‘version’
[08:26:18.981]   - Field: ‘result’
[08:26:18.981]   - Field: ‘asynchronous’
[08:26:18.981]   - Field: ‘calls’
[08:26:18.981]   - Field: ‘globals’
[08:26:18.981]   - Field: ‘stdout’
[08:26:18.981]   - Field: ‘earlySignal’
[08:26:18.981]   - Field: ‘lazy’
[08:26:18.981]   - Field: ‘state’
[08:26:18.981] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:18.981] - Launch lazy future ...
[08:26:18.982] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:18.982] Packages needed by future strategies (n = 0): <none>
[08:26:18.982] {
[08:26:18.982]     {
[08:26:18.982]         {
[08:26:18.982]             ...future.startTime <- base::Sys.time()
[08:26:18.982]             {
[08:26:18.982]                 {
[08:26:18.982]                   {
[08:26:18.982]                     {
[08:26:18.982]                       base::local({
[08:26:18.982]                         has_future <- base::requireNamespace("future", 
[08:26:18.982]                           quietly = TRUE)
[08:26:18.982]                         if (has_future) {
[08:26:18.982]                           ns <- base::getNamespace("future")
[08:26:18.982]                           version <- ns[[".package"]][["version"]]
[08:26:18.982]                           if (is.null(version)) 
[08:26:18.982]                             version <- utils::packageVersion("future")
[08:26:18.982]                         }
[08:26:18.982]                         else {
[08:26:18.982]                           version <- NULL
[08:26:18.982]                         }
[08:26:18.982]                         if (!has_future || version < "1.8.0") {
[08:26:18.982]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:18.982]                             "", base::R.version$version.string), 
[08:26:18.982]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:18.982]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:18.982]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:18.982]                               "release", "version")], collapse = " "), 
[08:26:18.982]                             hostname = base::Sys.info()[["nodename"]])
[08:26:18.982]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:18.982]                             info)
[08:26:18.982]                           info <- base::paste(info, collapse = "; ")
[08:26:18.982]                           if (!has_future) {
[08:26:18.982]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:18.982]                               info)
[08:26:18.982]                           }
[08:26:18.982]                           else {
[08:26:18.982]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:18.982]                               info, version)
[08:26:18.982]                           }
[08:26:18.982]                           base::stop(msg)
[08:26:18.982]                         }
[08:26:18.982]                       })
[08:26:18.982]                     }
[08:26:18.982]                     base::local({
[08:26:18.982]                       for (pkg in "future.apply") {
[08:26:18.982]                         base::loadNamespace(pkg)
[08:26:18.982]                         base::library(pkg, character.only = TRUE)
[08:26:18.982]                       }
[08:26:18.982]                     })
[08:26:18.982]                   }
[08:26:18.982]                   ...future.strategy.old <- future::plan("list")
[08:26:18.982]                   options(future.plan = NULL)
[08:26:18.982]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:18.982]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:18.982]                 }
[08:26:18.982]                 ...future.workdir <- getwd()
[08:26:18.982]             }
[08:26:18.982]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:18.982]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:18.982]         }
[08:26:18.982]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:18.982]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:18.982]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:18.982]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:18.982]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:18.982]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:18.982]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:18.982]             base::names(...future.oldOptions))
[08:26:18.982]     }
[08:26:18.982]     if (FALSE) {
[08:26:18.982]     }
[08:26:18.982]     else {
[08:26:18.982]         if (TRUE) {
[08:26:18.982]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:18.982]                 open = "w")
[08:26:18.982]         }
[08:26:18.982]         else {
[08:26:18.982]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:18.982]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:18.982]         }
[08:26:18.982]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:18.982]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:18.982]             base::sink(type = "output", split = FALSE)
[08:26:18.982]             base::close(...future.stdout)
[08:26:18.982]         }, add = TRUE)
[08:26:18.982]     }
[08:26:18.982]     ...future.frame <- base::sys.nframe()
[08:26:18.982]     ...future.conditions <- base::list()
[08:26:18.982]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:18.982]     if (FALSE) {
[08:26:18.982]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:18.982]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:18.982]     }
[08:26:18.982]     ...future.result <- base::tryCatch({
[08:26:18.982]         base::withCallingHandlers({
[08:26:18.982]             ...future.value <- base::withVisible(base::local({
[08:26:18.982]                 do.call(function(...) {
[08:26:18.982]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:18.982]                   if (!identical(...future.globals.maxSize.org, 
[08:26:18.982]                     ...future.globals.maxSize)) {
[08:26:18.982]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:18.982]                     on.exit(options(oopts), add = TRUE)
[08:26:18.982]                   }
[08:26:18.982]                   {
[08:26:18.982]                     lapply(seq_along(...future.elements_ii), 
[08:26:18.982]                       FUN = function(jj) {
[08:26:18.982]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:18.982]                         ...future.FUN(...future.X_jj, ...)
[08:26:18.982]                       })
[08:26:18.982]                   }
[08:26:18.982]                 }, args = future.call.arguments)
[08:26:18.982]             }))
[08:26:18.982]             future::FutureResult(value = ...future.value$value, 
[08:26:18.982]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:18.982]                   ...future.rng), globalenv = if (FALSE) 
[08:26:18.982]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:18.982]                     ...future.globalenv.names))
[08:26:18.982]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:18.982]         }, condition = base::local({
[08:26:18.982]             c <- base::c
[08:26:18.982]             inherits <- base::inherits
[08:26:18.982]             invokeRestart <- base::invokeRestart
[08:26:18.982]             length <- base::length
[08:26:18.982]             list <- base::list
[08:26:18.982]             seq.int <- base::seq.int
[08:26:18.982]             signalCondition <- base::signalCondition
[08:26:18.982]             sys.calls <- base::sys.calls
[08:26:18.982]             `[[` <- base::`[[`
[08:26:18.982]             `+` <- base::`+`
[08:26:18.982]             `<<-` <- base::`<<-`
[08:26:18.982]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:18.982]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:18.982]                   3L)]
[08:26:18.982]             }
[08:26:18.982]             function(cond) {
[08:26:18.982]                 is_error <- inherits(cond, "error")
[08:26:18.982]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:18.982]                   NULL)
[08:26:18.982]                 if (is_error) {
[08:26:18.982]                   sessionInformation <- function() {
[08:26:18.982]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:18.982]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:18.982]                       search = base::search(), system = base::Sys.info())
[08:26:18.982]                   }
[08:26:18.982]                   ...future.conditions[[length(...future.conditions) + 
[08:26:18.982]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:18.982]                     cond$call), session = sessionInformation(), 
[08:26:18.982]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:18.982]                   signalCondition(cond)
[08:26:18.982]                 }
[08:26:18.982]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:18.982]                 "immediateCondition"))) {
[08:26:18.982]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:18.982]                   ...future.conditions[[length(...future.conditions) + 
[08:26:18.982]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:18.982]                   if (TRUE && !signal) {
[08:26:18.982]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:18.982]                     {
[08:26:18.982]                       inherits <- base::inherits
[08:26:18.982]                       invokeRestart <- base::invokeRestart
[08:26:18.982]                       is.null <- base::is.null
[08:26:18.982]                       muffled <- FALSE
[08:26:18.982]                       if (inherits(cond, "message")) {
[08:26:18.982]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:18.982]                         if (muffled) 
[08:26:18.982]                           invokeRestart("muffleMessage")
[08:26:18.982]                       }
[08:26:18.982]                       else if (inherits(cond, "warning")) {
[08:26:18.982]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:18.982]                         if (muffled) 
[08:26:18.982]                           invokeRestart("muffleWarning")
[08:26:18.982]                       }
[08:26:18.982]                       else if (inherits(cond, "condition")) {
[08:26:18.982]                         if (!is.null(pattern)) {
[08:26:18.982]                           computeRestarts <- base::computeRestarts
[08:26:18.982]                           grepl <- base::grepl
[08:26:18.982]                           restarts <- computeRestarts(cond)
[08:26:18.982]                           for (restart in restarts) {
[08:26:18.982]                             name <- restart$name
[08:26:18.982]                             if (is.null(name)) 
[08:26:18.982]                               next
[08:26:18.982]                             if (!grepl(pattern, name)) 
[08:26:18.982]                               next
[08:26:18.982]                             invokeRestart(restart)
[08:26:18.982]                             muffled <- TRUE
[08:26:18.982]                             break
[08:26:18.982]                           }
[08:26:18.982]                         }
[08:26:18.982]                       }
[08:26:18.982]                       invisible(muffled)
[08:26:18.982]                     }
[08:26:18.982]                     muffleCondition(cond, pattern = "^muffle")
[08:26:18.982]                   }
[08:26:18.982]                 }
[08:26:18.982]                 else {
[08:26:18.982]                   if (TRUE) {
[08:26:18.982]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:18.982]                     {
[08:26:18.982]                       inherits <- base::inherits
[08:26:18.982]                       invokeRestart <- base::invokeRestart
[08:26:18.982]                       is.null <- base::is.null
[08:26:18.982]                       muffled <- FALSE
[08:26:18.982]                       if (inherits(cond, "message")) {
[08:26:18.982]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:18.982]                         if (muffled) 
[08:26:18.982]                           invokeRestart("muffleMessage")
[08:26:18.982]                       }
[08:26:18.982]                       else if (inherits(cond, "warning")) {
[08:26:18.982]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:18.982]                         if (muffled) 
[08:26:18.982]                           invokeRestart("muffleWarning")
[08:26:18.982]                       }
[08:26:18.982]                       else if (inherits(cond, "condition")) {
[08:26:18.982]                         if (!is.null(pattern)) {
[08:26:18.982]                           computeRestarts <- base::computeRestarts
[08:26:18.982]                           grepl <- base::grepl
[08:26:18.982]                           restarts <- computeRestarts(cond)
[08:26:18.982]                           for (restart in restarts) {
[08:26:18.982]                             name <- restart$name
[08:26:18.982]                             if (is.null(name)) 
[08:26:18.982]                               next
[08:26:18.982]                             if (!grepl(pattern, name)) 
[08:26:18.982]                               next
[08:26:18.982]                             invokeRestart(restart)
[08:26:18.982]                             muffled <- TRUE
[08:26:18.982]                             break
[08:26:18.982]                           }
[08:26:18.982]                         }
[08:26:18.982]                       }
[08:26:18.982]                       invisible(muffled)
[08:26:18.982]                     }
[08:26:18.982]                     muffleCondition(cond, pattern = "^muffle")
[08:26:18.982]                   }
[08:26:18.982]                 }
[08:26:18.982]             }
[08:26:18.982]         }))
[08:26:18.982]     }, error = function(ex) {
[08:26:18.982]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:18.982]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:18.982]                 ...future.rng), started = ...future.startTime, 
[08:26:18.982]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:18.982]             version = "1.8"), class = "FutureResult")
[08:26:18.982]     }, finally = {
[08:26:18.982]         if (!identical(...future.workdir, getwd())) 
[08:26:18.982]             setwd(...future.workdir)
[08:26:18.982]         {
[08:26:18.982]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:18.982]                 ...future.oldOptions$nwarnings <- NULL
[08:26:18.982]             }
[08:26:18.982]             base::options(...future.oldOptions)
[08:26:18.982]             if (.Platform$OS.type == "windows") {
[08:26:18.982]                 old_names <- names(...future.oldEnvVars)
[08:26:18.982]                 envs <- base::Sys.getenv()
[08:26:18.982]                 names <- names(envs)
[08:26:18.982]                 common <- intersect(names, old_names)
[08:26:18.982]                 added <- setdiff(names, old_names)
[08:26:18.982]                 removed <- setdiff(old_names, names)
[08:26:18.982]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:18.982]                   envs[common]]
[08:26:18.982]                 NAMES <- toupper(changed)
[08:26:18.982]                 args <- list()
[08:26:18.982]                 for (kk in seq_along(NAMES)) {
[08:26:18.982]                   name <- changed[[kk]]
[08:26:18.982]                   NAME <- NAMES[[kk]]
[08:26:18.982]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:18.982]                     next
[08:26:18.982]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:18.982]                 }
[08:26:18.982]                 NAMES <- toupper(added)
[08:26:18.982]                 for (kk in seq_along(NAMES)) {
[08:26:18.982]                   name <- added[[kk]]
[08:26:18.982]                   NAME <- NAMES[[kk]]
[08:26:18.982]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:18.982]                     next
[08:26:18.982]                   args[[name]] <- ""
[08:26:18.982]                 }
[08:26:18.982]                 NAMES <- toupper(removed)
[08:26:18.982]                 for (kk in seq_along(NAMES)) {
[08:26:18.982]                   name <- removed[[kk]]
[08:26:18.982]                   NAME <- NAMES[[kk]]
[08:26:18.982]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:18.982]                     next
[08:26:18.982]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:18.982]                 }
[08:26:18.982]                 if (length(args) > 0) 
[08:26:18.982]                   base::do.call(base::Sys.setenv, args = args)
[08:26:18.982]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:18.982]             }
[08:26:18.982]             else {
[08:26:18.982]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:18.982]             }
[08:26:18.982]             {
[08:26:18.982]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:18.982]                   0L) {
[08:26:18.982]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:18.982]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:18.982]                   base::options(opts)
[08:26:18.982]                 }
[08:26:18.982]                 {
[08:26:18.982]                   {
[08:26:18.982]                     NULL
[08:26:18.982]                     RNGkind("Mersenne-Twister")
[08:26:18.982]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:18.982]                       inherits = FALSE)
[08:26:18.982]                   }
[08:26:18.982]                   options(future.plan = NULL)
[08:26:18.982]                   if (is.na(NA_character_)) 
[08:26:18.982]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:18.982]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:18.982]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:18.982]                     .init = FALSE)
[08:26:18.982]                 }
[08:26:18.982]             }
[08:26:18.982]         }
[08:26:18.982]     })
[08:26:18.982]     if (TRUE) {
[08:26:18.982]         base::sink(type = "output", split = FALSE)
[08:26:18.982]         if (TRUE) {
[08:26:18.982]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:18.982]         }
[08:26:18.982]         else {
[08:26:18.982]             ...future.result["stdout"] <- base::list(NULL)
[08:26:18.982]         }
[08:26:18.982]         base::close(...future.stdout)
[08:26:18.982]         ...future.stdout <- NULL
[08:26:18.982]     }
[08:26:18.982]     ...future.result$conditions <- ...future.conditions
[08:26:18.982]     ...future.result$finished <- base::Sys.time()
[08:26:18.982]     ...future.result
[08:26:18.982] }
[08:26:18.984] assign_globals() ...
[08:26:18.984] List of 11
[08:26:18.984]  $ ...future.FUN            :function (x, ...)  
[08:26:18.984]  $ x_FUN                    :function (x)  
[08:26:18.984]  $ times                    : int 0
[08:26:18.984]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:18.984]  $ stop_if_not              :function (...)  
[08:26:18.984]  $ dim                      : NULL
[08:26:18.984]  $ valid_types              : chr [1:2] "logical" "integer"
[08:26:18.984]  $ future.call.arguments    : list()
[08:26:18.984]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:18.984]  $ ...future.elements_ii    :List of 10
[08:26:18.984]   ..$ : int 1
[08:26:18.984]   ..$ : int 2
[08:26:18.984]   ..$ : int 3
[08:26:18.984]   ..$ : int 4
[08:26:18.984]   ..$ : int 5
[08:26:18.984]   ..$ : int 6
[08:26:18.984]   ..$ : int 7
[08:26:18.984]   ..$ : int 8
[08:26:18.984]   ..$ : int 9
[08:26:18.984]   ..$ : int 10
[08:26:18.984]  $ ...future.seeds_ii       : NULL
[08:26:18.984]  $ ...future.globals.maxSize: NULL
[08:26:18.984]  - attr(*, "where")=List of 11
[08:26:18.984]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:18.984]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:18.984]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:18.984]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:18.984]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:18.984]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:18.984]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:18.984]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:18.984]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:18.984]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:18.984]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:18.984]  - attr(*, "resolved")= logi FALSE
[08:26:18.984]  - attr(*, "total_size")= num 23453
[08:26:18.984]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:18.984]  - attr(*, "already-done")= logi TRUE
[08:26:18.994] - copied ‘...future.FUN’ to environment
[08:26:18.994] - reassign environment for ‘x_FUN’
[08:26:18.994] - copied ‘x_FUN’ to environment
[08:26:18.994] - copied ‘times’ to environment
[08:26:18.994] - copied ‘stopf’ to environment
[08:26:18.995] - copied ‘stop_if_not’ to environment
[08:26:18.995] - copied ‘dim’ to environment
[08:26:18.995] - copied ‘valid_types’ to environment
[08:26:18.995] - copied ‘future.call.arguments’ to environment
[08:26:18.995] - copied ‘...future.elements_ii’ to environment
[08:26:18.995] - copied ‘...future.seeds_ii’ to environment
[08:26:18.995] - copied ‘...future.globals.maxSize’ to environment
[08:26:18.995] assign_globals() ... done
[08:26:18.996] plan(): Setting new future strategy stack:
[08:26:18.996] List of future strategies:
[08:26:18.996] 1. sequential:
[08:26:18.996]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:18.996]    - tweaked: FALSE
[08:26:18.996]    - call: NULL
[08:26:18.996] plan(): nbrOfWorkers() = 1
[08:26:18.997] plan(): Setting new future strategy stack:
[08:26:18.997] List of future strategies:
[08:26:18.997] 1. sequential:
[08:26:18.997]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:18.997]    - tweaked: FALSE
[08:26:18.997]    - call: plan(strategy)
[08:26:18.998] plan(): nbrOfWorkers() = 1
[08:26:18.998] SequentialFuture started (and completed)
[08:26:18.998] - Launch lazy future ... done
[08:26:18.998] run() for ‘SequentialFuture’ ... done
[08:26:18.998] Created future:
[08:26:18.998] SequentialFuture:
[08:26:18.998] Label: ‘future_vapply-1’
[08:26:18.998] Expression:
[08:26:18.998] {
[08:26:18.998]     do.call(function(...) {
[08:26:18.998]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:18.998]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:18.998]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:18.998]             on.exit(options(oopts), add = TRUE)
[08:26:18.998]         }
[08:26:18.998]         {
[08:26:18.998]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:18.998]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:18.998]                 ...future.FUN(...future.X_jj, ...)
[08:26:18.998]             })
[08:26:18.998]         }
[08:26:18.998]     }, args = future.call.arguments)
[08:26:18.998] }
[08:26:18.998] Lazy evaluation: FALSE
[08:26:18.998] Asynchronous evaluation: FALSE
[08:26:18.998] Local evaluation: TRUE
[08:26:18.998] Environment: R_GlobalEnv
[08:26:18.998] Capture standard output: TRUE
[08:26:18.998] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:18.998] Globals: 11 objects totaling 13.04 KiB (function ‘...future.FUN’ of 4.49 KiB, function ‘x_FUN’ of 296 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:18.998] Packages: 1 packages (‘future.apply’)
[08:26:18.998] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:18.998] Resolved: TRUE
[08:26:18.998] Value: 111 bytes of class ‘list’
[08:26:18.998] Early signaling: FALSE
[08:26:18.998] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:18.998] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:18.999] Chunk #1 of 1 ... DONE
[08:26:18.999] Launching 1 futures (chunks) ... DONE
[08:26:19.000] Resolving 1 futures (chunks) ...
[08:26:19.000] resolve() on list ...
[08:26:19.000]  recursive: 0
[08:26:19.000]  length: 1
[08:26:19.000] 
[08:26:19.000] resolved() for ‘SequentialFuture’ ...
[08:26:19.000] - state: ‘finished’
[08:26:19.000] - run: TRUE
[08:26:19.000] - result: ‘FutureResult’
[08:26:19.002] resolved() for ‘SequentialFuture’ ... done
[08:26:19.002] Future #1
[08:26:19.002] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:19.002] - nx: 1
[08:26:19.002] - relay: TRUE
[08:26:19.003] - stdout: TRUE
[08:26:19.003] - signal: TRUE
[08:26:19.003] - resignal: FALSE
[08:26:19.003] - force: TRUE
[08:26:19.003] - relayed: [n=1] FALSE
[08:26:19.003] - queued futures: [n=1] FALSE
[08:26:19.003]  - until=1
[08:26:19.003]  - relaying element #1
[08:26:19.003] - relayed: [n=1] TRUE
[08:26:19.003] - queued futures: [n=1] TRUE
[08:26:19.003] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:19.004]  length: 0 (resolved future 1)
[08:26:19.004] Relaying remaining futures
[08:26:19.004] signalConditionsASAP(NULL, pos=0) ...
[08:26:19.004] - nx: 1
[08:26:19.004] - relay: TRUE
[08:26:19.004] - stdout: TRUE
[08:26:19.004] - signal: TRUE
[08:26:19.004] - resignal: FALSE
[08:26:19.004] - force: TRUE
[08:26:19.004] - relayed: [n=1] TRUE
[08:26:19.004] - queued futures: [n=1] TRUE
 - flush all
[08:26:19.005] - relayed: [n=1] TRUE
[08:26:19.005] - queued futures: [n=1] TRUE
[08:26:19.005] signalConditionsASAP(NULL, pos=0) ... done
[08:26:19.005] resolve() on list ... DONE
[08:26:19.005]  - Number of value chunks collected: 1
[08:26:19.005] Resolving 1 futures (chunks) ... DONE
[08:26:19.005] Reducing values from 1 chunks ...
[08:26:19.005]  - Number of values collected after concatenation: 10
[08:26:19.005]  - Number of values expected: 10
[08:26:19.005] Reducing values from 1 chunks ... DONE
[08:26:19.005] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[08:26:19.006] future_lapply() ...
[08:26:19.008] Number of chunks: 1
[08:26:19.008] getGlobalsAndPackagesXApply() ...
[08:26:19.008]  - future.globals: TRUE
[08:26:19.008] getGlobalsAndPackages() ...
[08:26:19.009] Searching for globals...
[08:26:19.011] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[08:26:19.012] Searching for globals ... DONE
[08:26:19.012] Resolving globals: FALSE
[08:26:19.012] The total size of the 7 globals is 12.08 KiB (12367 bytes)
[08:26:19.013] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.07 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:19.013] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.013] - packages: [1] ‘future.apply’
[08:26:19.013] getGlobalsAndPackages() ... DONE
[08:26:19.013]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.013]  - needed namespaces: [n=1] ‘future.apply’
[08:26:19.014] Finding globals ... DONE
[08:26:19.014]  - use_args: TRUE
[08:26:19.014]  - Getting '...' globals ...
[08:26:19.014] resolve() on list ...
[08:26:19.014]  recursive: 0
[08:26:19.014]  length: 1
[08:26:19.014]  elements: ‘...’
[08:26:19.014]  length: 0 (resolved future 1)
[08:26:19.015] resolve() on list ... DONE
[08:26:19.015]    - '...' content: [n=0] 
[08:26:19.015] List of 1
[08:26:19.015]  $ ...: list()
[08:26:19.015]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.015]  - attr(*, "where")=List of 1
[08:26:19.015]   ..$ ...:<environment: 0x562ca577c1b8> 
[08:26:19.015]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.015]  - attr(*, "resolved")= logi TRUE
[08:26:19.015]  - attr(*, "total_size")= num NA
[08:26:19.017]  - Getting '...' globals ... DONE
[08:26:19.017] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:19.017] List of 8
[08:26:19.017]  $ ...future.FUN:function (x, ...)  
[08:26:19.017]  $ x_FUN        :function (x)  
[08:26:19.017]  $ times        : int 1
[08:26:19.017]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.017]  $ stop_if_not  :function (...)  
[08:26:19.017]  $ dim          : NULL
[08:26:19.017]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:19.017]  $ ...          : list()
[08:26:19.017]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.017]  - attr(*, "where")=List of 8
[08:26:19.017]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:19.017]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:19.017]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:19.017]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:19.017]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:19.017]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:19.017]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:19.017]   ..$ ...          :<environment: 0x562ca577c1b8> 
[08:26:19.017]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.017]  - attr(*, "resolved")= logi FALSE
[08:26:19.017]  - attr(*, "total_size")= num 22322
[08:26:19.023] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:19.023] getGlobalsAndPackagesXApply() ... DONE
[08:26:19.023] Number of futures (= number of chunks): 1
[08:26:19.025] Launching 1 futures (chunks) ...
[08:26:19.025] Chunk #1 of 1 ...
[08:26:19.025]  - Finding globals in 'X' for chunk #1 ...
[08:26:19.025] getGlobalsAndPackages() ...
[08:26:19.025] Searching for globals...
[08:26:19.025] 
[08:26:19.025] Searching for globals ... DONE
[08:26:19.025] - globals: [0] <none>
[08:26:19.026] getGlobalsAndPackages() ... DONE
[08:26:19.026]    + additional globals found: [n=0] 
[08:26:19.026]    + additional namespaces needed: [n=0] 
[08:26:19.026]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:19.026]  - seeds: <none>
[08:26:19.026]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.026] getGlobalsAndPackages() ...
[08:26:19.026] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.026] Resolving globals: FALSE
[08:26:19.026] Tweak future expression to call with '...' arguments ...
[08:26:19.027] {
[08:26:19.027]     do.call(function(...) {
[08:26:19.027]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.027]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.027]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.027]             on.exit(options(oopts), add = TRUE)
[08:26:19.027]         }
[08:26:19.027]         {
[08:26:19.027]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.027]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.027]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.027]             })
[08:26:19.027]         }
[08:26:19.027]     }, args = future.call.arguments)
[08:26:19.027] }
[08:26:19.027] Tweak future expression to call with '...' arguments ... DONE
[08:26:19.027] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.027] - packages: [1] ‘future.apply’
[08:26:19.028] getGlobalsAndPackages() ... DONE
[08:26:19.028] run() for ‘Future’ ...
[08:26:19.028] - state: ‘created’
[08:26:19.028] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:26:19.028] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.028] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:19.029]   - Field: ‘label’
[08:26:19.029]   - Field: ‘local’
[08:26:19.029]   - Field: ‘owner’
[08:26:19.029]   - Field: ‘envir’
[08:26:19.029]   - Field: ‘packages’
[08:26:19.029]   - Field: ‘gc’
[08:26:19.029]   - Field: ‘conditions’
[08:26:19.029]   - Field: ‘expr’
[08:26:19.029]   - Field: ‘uuid’
[08:26:19.029]   - Field: ‘seed’
[08:26:19.029]   - Field: ‘version’
[08:26:19.030]   - Field: ‘result’
[08:26:19.030]   - Field: ‘asynchronous’
[08:26:19.030]   - Field: ‘calls’
[08:26:19.030]   - Field: ‘globals’
[08:26:19.030]   - Field: ‘stdout’
[08:26:19.030]   - Field: ‘earlySignal’
[08:26:19.030]   - Field: ‘lazy’
[08:26:19.030]   - Field: ‘state’
[08:26:19.030] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:19.030] - Launch lazy future ...
[08:26:19.031] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:19.031] Packages needed by future strategies (n = 0): <none>
[08:26:19.031] {
[08:26:19.031]     {
[08:26:19.031]         {
[08:26:19.031]             ...future.startTime <- base::Sys.time()
[08:26:19.031]             {
[08:26:19.031]                 {
[08:26:19.031]                   {
[08:26:19.031]                     {
[08:26:19.031]                       base::local({
[08:26:19.031]                         has_future <- base::requireNamespace("future", 
[08:26:19.031]                           quietly = TRUE)
[08:26:19.031]                         if (has_future) {
[08:26:19.031]                           ns <- base::getNamespace("future")
[08:26:19.031]                           version <- ns[[".package"]][["version"]]
[08:26:19.031]                           if (is.null(version)) 
[08:26:19.031]                             version <- utils::packageVersion("future")
[08:26:19.031]                         }
[08:26:19.031]                         else {
[08:26:19.031]                           version <- NULL
[08:26:19.031]                         }
[08:26:19.031]                         if (!has_future || version < "1.8.0") {
[08:26:19.031]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:19.031]                             "", base::R.version$version.string), 
[08:26:19.031]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:19.031]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:19.031]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:19.031]                               "release", "version")], collapse = " "), 
[08:26:19.031]                             hostname = base::Sys.info()[["nodename"]])
[08:26:19.031]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:19.031]                             info)
[08:26:19.031]                           info <- base::paste(info, collapse = "; ")
[08:26:19.031]                           if (!has_future) {
[08:26:19.031]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:19.031]                               info)
[08:26:19.031]                           }
[08:26:19.031]                           else {
[08:26:19.031]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:19.031]                               info, version)
[08:26:19.031]                           }
[08:26:19.031]                           base::stop(msg)
[08:26:19.031]                         }
[08:26:19.031]                       })
[08:26:19.031]                     }
[08:26:19.031]                     base::local({
[08:26:19.031]                       for (pkg in "future.apply") {
[08:26:19.031]                         base::loadNamespace(pkg)
[08:26:19.031]                         base::library(pkg, character.only = TRUE)
[08:26:19.031]                       }
[08:26:19.031]                     })
[08:26:19.031]                   }
[08:26:19.031]                   ...future.strategy.old <- future::plan("list")
[08:26:19.031]                   options(future.plan = NULL)
[08:26:19.031]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.031]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:19.031]                 }
[08:26:19.031]                 ...future.workdir <- getwd()
[08:26:19.031]             }
[08:26:19.031]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:19.031]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:19.031]         }
[08:26:19.031]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:19.031]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:19.031]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:19.031]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:19.031]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:19.031]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:19.031]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:19.031]             base::names(...future.oldOptions))
[08:26:19.031]     }
[08:26:19.031]     if (FALSE) {
[08:26:19.031]     }
[08:26:19.031]     else {
[08:26:19.031]         if (TRUE) {
[08:26:19.031]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:19.031]                 open = "w")
[08:26:19.031]         }
[08:26:19.031]         else {
[08:26:19.031]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:19.031]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:19.031]         }
[08:26:19.031]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:19.031]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:19.031]             base::sink(type = "output", split = FALSE)
[08:26:19.031]             base::close(...future.stdout)
[08:26:19.031]         }, add = TRUE)
[08:26:19.031]     }
[08:26:19.031]     ...future.frame <- base::sys.nframe()
[08:26:19.031]     ...future.conditions <- base::list()
[08:26:19.031]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:19.031]     if (FALSE) {
[08:26:19.031]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:19.031]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:19.031]     }
[08:26:19.031]     ...future.result <- base::tryCatch({
[08:26:19.031]         base::withCallingHandlers({
[08:26:19.031]             ...future.value <- base::withVisible(base::local({
[08:26:19.031]                 do.call(function(...) {
[08:26:19.031]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.031]                   if (!identical(...future.globals.maxSize.org, 
[08:26:19.031]                     ...future.globals.maxSize)) {
[08:26:19.031]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.031]                     on.exit(options(oopts), add = TRUE)
[08:26:19.031]                   }
[08:26:19.031]                   {
[08:26:19.031]                     lapply(seq_along(...future.elements_ii), 
[08:26:19.031]                       FUN = function(jj) {
[08:26:19.031]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.031]                         ...future.FUN(...future.X_jj, ...)
[08:26:19.031]                       })
[08:26:19.031]                   }
[08:26:19.031]                 }, args = future.call.arguments)
[08:26:19.031]             }))
[08:26:19.031]             future::FutureResult(value = ...future.value$value, 
[08:26:19.031]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.031]                   ...future.rng), globalenv = if (FALSE) 
[08:26:19.031]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:19.031]                     ...future.globalenv.names))
[08:26:19.031]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:19.031]         }, condition = base::local({
[08:26:19.031]             c <- base::c
[08:26:19.031]             inherits <- base::inherits
[08:26:19.031]             invokeRestart <- base::invokeRestart
[08:26:19.031]             length <- base::length
[08:26:19.031]             list <- base::list
[08:26:19.031]             seq.int <- base::seq.int
[08:26:19.031]             signalCondition <- base::signalCondition
[08:26:19.031]             sys.calls <- base::sys.calls
[08:26:19.031]             `[[` <- base::`[[`
[08:26:19.031]             `+` <- base::`+`
[08:26:19.031]             `<<-` <- base::`<<-`
[08:26:19.031]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:19.031]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:19.031]                   3L)]
[08:26:19.031]             }
[08:26:19.031]             function(cond) {
[08:26:19.031]                 is_error <- inherits(cond, "error")
[08:26:19.031]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:19.031]                   NULL)
[08:26:19.031]                 if (is_error) {
[08:26:19.031]                   sessionInformation <- function() {
[08:26:19.031]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:19.031]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:19.031]                       search = base::search(), system = base::Sys.info())
[08:26:19.031]                   }
[08:26:19.031]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.031]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:19.031]                     cond$call), session = sessionInformation(), 
[08:26:19.031]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:19.031]                   signalCondition(cond)
[08:26:19.031]                 }
[08:26:19.031]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:19.031]                 "immediateCondition"))) {
[08:26:19.031]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:19.031]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.031]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:19.031]                   if (TRUE && !signal) {
[08:26:19.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.031]                     {
[08:26:19.031]                       inherits <- base::inherits
[08:26:19.031]                       invokeRestart <- base::invokeRestart
[08:26:19.031]                       is.null <- base::is.null
[08:26:19.031]                       muffled <- FALSE
[08:26:19.031]                       if (inherits(cond, "message")) {
[08:26:19.031]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.031]                         if (muffled) 
[08:26:19.031]                           invokeRestart("muffleMessage")
[08:26:19.031]                       }
[08:26:19.031]                       else if (inherits(cond, "warning")) {
[08:26:19.031]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.031]                         if (muffled) 
[08:26:19.031]                           invokeRestart("muffleWarning")
[08:26:19.031]                       }
[08:26:19.031]                       else if (inherits(cond, "condition")) {
[08:26:19.031]                         if (!is.null(pattern)) {
[08:26:19.031]                           computeRestarts <- base::computeRestarts
[08:26:19.031]                           grepl <- base::grepl
[08:26:19.031]                           restarts <- computeRestarts(cond)
[08:26:19.031]                           for (restart in restarts) {
[08:26:19.031]                             name <- restart$name
[08:26:19.031]                             if (is.null(name)) 
[08:26:19.031]                               next
[08:26:19.031]                             if (!grepl(pattern, name)) 
[08:26:19.031]                               next
[08:26:19.031]                             invokeRestart(restart)
[08:26:19.031]                             muffled <- TRUE
[08:26:19.031]                             break
[08:26:19.031]                           }
[08:26:19.031]                         }
[08:26:19.031]                       }
[08:26:19.031]                       invisible(muffled)
[08:26:19.031]                     }
[08:26:19.031]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.031]                   }
[08:26:19.031]                 }
[08:26:19.031]                 else {
[08:26:19.031]                   if (TRUE) {
[08:26:19.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.031]                     {
[08:26:19.031]                       inherits <- base::inherits
[08:26:19.031]                       invokeRestart <- base::invokeRestart
[08:26:19.031]                       is.null <- base::is.null
[08:26:19.031]                       muffled <- FALSE
[08:26:19.031]                       if (inherits(cond, "message")) {
[08:26:19.031]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.031]                         if (muffled) 
[08:26:19.031]                           invokeRestart("muffleMessage")
[08:26:19.031]                       }
[08:26:19.031]                       else if (inherits(cond, "warning")) {
[08:26:19.031]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.031]                         if (muffled) 
[08:26:19.031]                           invokeRestart("muffleWarning")
[08:26:19.031]                       }
[08:26:19.031]                       else if (inherits(cond, "condition")) {
[08:26:19.031]                         if (!is.null(pattern)) {
[08:26:19.031]                           computeRestarts <- base::computeRestarts
[08:26:19.031]                           grepl <- base::grepl
[08:26:19.031]                           restarts <- computeRestarts(cond)
[08:26:19.031]                           for (restart in restarts) {
[08:26:19.031]                             name <- restart$name
[08:26:19.031]                             if (is.null(name)) 
[08:26:19.031]                               next
[08:26:19.031]                             if (!grepl(pattern, name)) 
[08:26:19.031]                               next
[08:26:19.031]                             invokeRestart(restart)
[08:26:19.031]                             muffled <- TRUE
[08:26:19.031]                             break
[08:26:19.031]                           }
[08:26:19.031]                         }
[08:26:19.031]                       }
[08:26:19.031]                       invisible(muffled)
[08:26:19.031]                     }
[08:26:19.031]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.031]                   }
[08:26:19.031]                 }
[08:26:19.031]             }
[08:26:19.031]         }))
[08:26:19.031]     }, error = function(ex) {
[08:26:19.031]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:19.031]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.031]                 ...future.rng), started = ...future.startTime, 
[08:26:19.031]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:19.031]             version = "1.8"), class = "FutureResult")
[08:26:19.031]     }, finally = {
[08:26:19.031]         if (!identical(...future.workdir, getwd())) 
[08:26:19.031]             setwd(...future.workdir)
[08:26:19.031]         {
[08:26:19.031]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:19.031]                 ...future.oldOptions$nwarnings <- NULL
[08:26:19.031]             }
[08:26:19.031]             base::options(...future.oldOptions)
[08:26:19.031]             if (.Platform$OS.type == "windows") {
[08:26:19.031]                 old_names <- names(...future.oldEnvVars)
[08:26:19.031]                 envs <- base::Sys.getenv()
[08:26:19.031]                 names <- names(envs)
[08:26:19.031]                 common <- intersect(names, old_names)
[08:26:19.031]                 added <- setdiff(names, old_names)
[08:26:19.031]                 removed <- setdiff(old_names, names)
[08:26:19.031]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:19.031]                   envs[common]]
[08:26:19.031]                 NAMES <- toupper(changed)
[08:26:19.031]                 args <- list()
[08:26:19.031]                 for (kk in seq_along(NAMES)) {
[08:26:19.031]                   name <- changed[[kk]]
[08:26:19.031]                   NAME <- NAMES[[kk]]
[08:26:19.031]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.031]                     next
[08:26:19.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.031]                 }
[08:26:19.031]                 NAMES <- toupper(added)
[08:26:19.031]                 for (kk in seq_along(NAMES)) {
[08:26:19.031]                   name <- added[[kk]]
[08:26:19.031]                   NAME <- NAMES[[kk]]
[08:26:19.031]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.031]                     next
[08:26:19.031]                   args[[name]] <- ""
[08:26:19.031]                 }
[08:26:19.031]                 NAMES <- toupper(removed)
[08:26:19.031]                 for (kk in seq_along(NAMES)) {
[08:26:19.031]                   name <- removed[[kk]]
[08:26:19.031]                   NAME <- NAMES[[kk]]
[08:26:19.031]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.031]                     next
[08:26:19.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.031]                 }
[08:26:19.031]                 if (length(args) > 0) 
[08:26:19.031]                   base::do.call(base::Sys.setenv, args = args)
[08:26:19.031]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:19.031]             }
[08:26:19.031]             else {
[08:26:19.031]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:19.031]             }
[08:26:19.031]             {
[08:26:19.031]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:19.031]                   0L) {
[08:26:19.031]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:19.031]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:19.031]                   base::options(opts)
[08:26:19.031]                 }
[08:26:19.031]                 {
[08:26:19.031]                   {
[08:26:19.031]                     NULL
[08:26:19.031]                     RNGkind("Mersenne-Twister")
[08:26:19.031]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:19.031]                       inherits = FALSE)
[08:26:19.031]                   }
[08:26:19.031]                   options(future.plan = NULL)
[08:26:19.031]                   if (is.na(NA_character_)) 
[08:26:19.031]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.031]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:19.031]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:19.031]                     .init = FALSE)
[08:26:19.031]                 }
[08:26:19.031]             }
[08:26:19.031]         }
[08:26:19.031]     })
[08:26:19.031]     if (TRUE) {
[08:26:19.031]         base::sink(type = "output", split = FALSE)
[08:26:19.031]         if (TRUE) {
[08:26:19.031]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:19.031]         }
[08:26:19.031]         else {
[08:26:19.031]             ...future.result["stdout"] <- base::list(NULL)
[08:26:19.031]         }
[08:26:19.031]         base::close(...future.stdout)
[08:26:19.031]         ...future.stdout <- NULL
[08:26:19.031]     }
[08:26:19.031]     ...future.result$conditions <- ...future.conditions
[08:26:19.031]     ...future.result$finished <- base::Sys.time()
[08:26:19.031]     ...future.result
[08:26:19.031] }
[08:26:19.033] assign_globals() ...
[08:26:19.033] List of 11
[08:26:19.033]  $ ...future.FUN            :function (x, ...)  
[08:26:19.033]  $ x_FUN                    :function (x)  
[08:26:19.033]  $ times                    : int 1
[08:26:19.033]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.033]  $ stop_if_not              :function (...)  
[08:26:19.033]  $ dim                      : NULL
[08:26:19.033]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:19.033]  $ future.call.arguments    : list()
[08:26:19.033]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.033]  $ ...future.elements_ii    :List of 10
[08:26:19.033]   ..$ : int 1
[08:26:19.033]   ..$ : int 2
[08:26:19.033]   ..$ : int 3
[08:26:19.033]   ..$ : int 4
[08:26:19.033]   ..$ : int 5
[08:26:19.033]   ..$ : int 6
[08:26:19.033]   ..$ : int 7
[08:26:19.033]   ..$ : int 8
[08:26:19.033]   ..$ : int 9
[08:26:19.033]   ..$ : int 10
[08:26:19.033]  $ ...future.seeds_ii       : NULL
[08:26:19.033]  $ ...future.globals.maxSize: NULL
[08:26:19.033]  - attr(*, "where")=List of 11
[08:26:19.033]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:19.033]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:19.033]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:19.033]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:19.033]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:19.033]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:19.033]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:19.033]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:19.033]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:19.033]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:19.033]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:19.033]  - attr(*, "resolved")= logi FALSE
[08:26:19.033]  - attr(*, "total_size")= num 22322
[08:26:19.033]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.033]  - attr(*, "already-done")= logi TRUE
[08:26:19.043] - copied ‘...future.FUN’ to environment
[08:26:19.043] - copied ‘x_FUN’ to environment
[08:26:19.043] - copied ‘times’ to environment
[08:26:19.043] - copied ‘stopf’ to environment
[08:26:19.043] - copied ‘stop_if_not’ to environment
[08:26:19.043] - copied ‘dim’ to environment
[08:26:19.043] - copied ‘valid_types’ to environment
[08:26:19.043] - copied ‘future.call.arguments’ to environment
[08:26:19.043] - copied ‘...future.elements_ii’ to environment
[08:26:19.044] - copied ‘...future.seeds_ii’ to environment
[08:26:19.044] - copied ‘...future.globals.maxSize’ to environment
[08:26:19.044] assign_globals() ... done
[08:26:19.044] plan(): Setting new future strategy stack:
[08:26:19.044] List of future strategies:
[08:26:19.044] 1. sequential:
[08:26:19.044]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.044]    - tweaked: FALSE
[08:26:19.044]    - call: NULL
[08:26:19.045] plan(): nbrOfWorkers() = 1
[08:26:19.046] plan(): Setting new future strategy stack:
[08:26:19.046] List of future strategies:
[08:26:19.046] 1. sequential:
[08:26:19.046]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.046]    - tweaked: FALSE
[08:26:19.046]    - call: plan(strategy)
[08:26:19.046] plan(): nbrOfWorkers() = 1
[08:26:19.046] SequentialFuture started (and completed)
[08:26:19.046] - Launch lazy future ... done
[08:26:19.047] run() for ‘SequentialFuture’ ... done
[08:26:19.047] Created future:
[08:26:19.047] SequentialFuture:
[08:26:19.047] Label: ‘future_vapply-1’
[08:26:19.047] Expression:
[08:26:19.047] {
[08:26:19.047]     do.call(function(...) {
[08:26:19.047]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.047]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.047]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.047]             on.exit(options(oopts), add = TRUE)
[08:26:19.047]         }
[08:26:19.047]         {
[08:26:19.047]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.047]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.047]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.047]             })
[08:26:19.047]         }
[08:26:19.047]     }, args = future.call.arguments)
[08:26:19.047] }
[08:26:19.047] Lazy evaluation: FALSE
[08:26:19.047] Asynchronous evaluation: FALSE
[08:26:19.047] Local evaluation: TRUE
[08:26:19.047] Environment: R_GlobalEnv
[08:26:19.047] Capture standard output: TRUE
[08:26:19.047] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:19.047] Globals: 11 objects totaling 12.37 KiB (function ‘...future.FUN’ of 4.06 KiB, function ‘x_FUN’ of 35 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:19.047] Packages: 1 packages (‘future.apply’)
[08:26:19.047] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:19.047] Resolved: TRUE
[08:26:19.047] Value: 191 bytes of class ‘list’
[08:26:19.047] Early signaling: FALSE
[08:26:19.047] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:19.047] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.049] Chunk #1 of 1 ... DONE
[08:26:19.050] Launching 1 futures (chunks) ... DONE
[08:26:19.050] Resolving 1 futures (chunks) ...
[08:26:19.050] resolve() on list ...
[08:26:19.050]  recursive: 0
[08:26:19.050]  length: 1
[08:26:19.050] 
[08:26:19.050] resolved() for ‘SequentialFuture’ ...
[08:26:19.050] - state: ‘finished’
[08:26:19.050] - run: TRUE
[08:26:19.050] - result: ‘FutureResult’
[08:26:19.050] resolved() for ‘SequentialFuture’ ... done
[08:26:19.051] Future #1
[08:26:19.051] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:19.051] - nx: 1
[08:26:19.051] - relay: TRUE
[08:26:19.051] - stdout: TRUE
[08:26:19.051] - signal: TRUE
[08:26:19.051] - resignal: FALSE
[08:26:19.051] - force: TRUE
[08:26:19.051] - relayed: [n=1] FALSE
[08:26:19.051] - queued futures: [n=1] FALSE
[08:26:19.051]  - until=1
[08:26:19.052]  - relaying element #1
[08:26:19.052] - relayed: [n=1] TRUE
[08:26:19.052] - queued futures: [n=1] TRUE
[08:26:19.052] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:19.052]  length: 0 (resolved future 1)
[08:26:19.052] Relaying remaining futures
[08:26:19.052] signalConditionsASAP(NULL, pos=0) ...
[08:26:19.052] - nx: 1
[08:26:19.052] - relay: TRUE
[08:26:19.052] - stdout: TRUE
[08:26:19.053] - signal: TRUE
[08:26:19.053] - resignal: FALSE
[08:26:19.053] - force: TRUE
[08:26:19.053] - relayed: [n=1] TRUE
[08:26:19.053] - queued futures: [n=1] TRUE
 - flush all
[08:26:19.053] - relayed: [n=1] TRUE
[08:26:19.053] - queued futures: [n=1] TRUE
[08:26:19.053] signalConditionsASAP(NULL, pos=0) ... done
[08:26:19.053] resolve() on list ... DONE
[08:26:19.053]  - Number of value chunks collected: 1
[08:26:19.053] Resolving 1 futures (chunks) ... DONE
[08:26:19.054] Reducing values from 1 chunks ...
[08:26:19.054]  - Number of values collected after concatenation: 10
[08:26:19.054]  - Number of values expected: 10
[08:26:19.054] Reducing values from 1 chunks ... DONE
[08:26:19.054] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[08:26:19.055] future_lapply() ...
[08:26:19.056] Number of chunks: 1
[08:26:19.057] getGlobalsAndPackagesXApply() ...
[08:26:19.057]  - future.globals: TRUE
[08:26:19.057] getGlobalsAndPackages() ...
[08:26:19.057] Searching for globals...
[08:26:19.060] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[08:26:19.060] Searching for globals ... DONE
[08:26:19.061] Resolving globals: FALSE
[08:26:19.061] The total size of the 7 globals is 13.34 KiB (13657 bytes)
[08:26:19.062] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.89 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:19.062] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.062] - packages: [1] ‘future.apply’
[08:26:19.062] getGlobalsAndPackages() ... DONE
[08:26:19.062]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.062]  - needed namespaces: [n=1] ‘future.apply’
[08:26:19.062] Finding globals ... DONE
[08:26:19.063]  - use_args: TRUE
[08:26:19.063]  - Getting '...' globals ...
[08:26:19.063] resolve() on list ...
[08:26:19.063]  recursive: 0
[08:26:19.063]  length: 1
[08:26:19.063]  elements: ‘...’
[08:26:19.063]  length: 0 (resolved future 1)
[08:26:19.063] resolve() on list ... DONE
[08:26:19.064]    - '...' content: [n=0] 
[08:26:19.064] List of 1
[08:26:19.064]  $ ...: list()
[08:26:19.064]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.064]  - attr(*, "where")=List of 1
[08:26:19.064]   ..$ ...:<environment: 0x562ca5dc2148> 
[08:26:19.064]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.064]  - attr(*, "resolved")= logi TRUE
[08:26:19.064]  - attr(*, "total_size")= num NA
[08:26:19.066]  - Getting '...' globals ... DONE
[08:26:19.066] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:19.066] List of 8
[08:26:19.066]  $ ...future.FUN:function (x, ...)  
[08:26:19.066]  $ x_FUN        :function (x)  
[08:26:19.066]  $ times        : int 2
[08:26:19.066]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.066]  $ stop_if_not  :function (...)  
[08:26:19.066]  $ dim          : NULL
[08:26:19.066]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:19.066]  $ ...          : list()
[08:26:19.066]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.066]  - attr(*, "where")=List of 8
[08:26:19.066]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:19.066]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:19.066]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:19.066]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:19.066]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:19.066]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:19.066]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:19.066]   ..$ ...          :<environment: 0x562ca5dc2148> 
[08:26:19.066]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.066]  - attr(*, "resolved")= logi FALSE
[08:26:19.066]  - attr(*, "total_size")= num 24454
[08:26:19.073] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:19.073] getGlobalsAndPackagesXApply() ... DONE
[08:26:19.074] Number of futures (= number of chunks): 1
[08:26:19.074] Launching 1 futures (chunks) ...
[08:26:19.074] Chunk #1 of 1 ...
[08:26:19.074]  - Finding globals in 'X' for chunk #1 ...
[08:26:19.074] getGlobalsAndPackages() ...
[08:26:19.074] Searching for globals...
[08:26:19.074] 
[08:26:19.074] Searching for globals ... DONE
[08:26:19.075] - globals: [0] <none>
[08:26:19.075] getGlobalsAndPackages() ... DONE
[08:26:19.075]    + additional globals found: [n=0] 
[08:26:19.075]    + additional namespaces needed: [n=0] 
[08:26:19.075]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:19.075]  - seeds: <none>
[08:26:19.075]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.075] getGlobalsAndPackages() ...
[08:26:19.075] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.075] Resolving globals: FALSE
[08:26:19.075] Tweak future expression to call with '...' arguments ...
[08:26:19.076] {
[08:26:19.076]     do.call(function(...) {
[08:26:19.076]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.076]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.076]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.076]             on.exit(options(oopts), add = TRUE)
[08:26:19.076]         }
[08:26:19.076]         {
[08:26:19.076]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.076]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.076]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.076]             })
[08:26:19.076]         }
[08:26:19.076]     }, args = future.call.arguments)
[08:26:19.076] }
[08:26:19.076] Tweak future expression to call with '...' arguments ... DONE
[08:26:19.076] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.076] - packages: [1] ‘future.apply’
[08:26:19.077] getGlobalsAndPackages() ... DONE
[08:26:19.077] run() for ‘Future’ ...
[08:26:19.077] - state: ‘created’
[08:26:19.077] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:26:19.077] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.078] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:19.078]   - Field: ‘label’
[08:26:19.078]   - Field: ‘local’
[08:26:19.078]   - Field: ‘owner’
[08:26:19.078]   - Field: ‘envir’
[08:26:19.078]   - Field: ‘packages’
[08:26:19.078]   - Field: ‘gc’
[08:26:19.078]   - Field: ‘conditions’
[08:26:19.078]   - Field: ‘expr’
[08:26:19.078]   - Field: ‘uuid’
[08:26:19.078]   - Field: ‘seed’
[08:26:19.078]   - Field: ‘version’
[08:26:19.079]   - Field: ‘result’
[08:26:19.079]   - Field: ‘asynchronous’
[08:26:19.079]   - Field: ‘calls’
[08:26:19.079]   - Field: ‘globals’
[08:26:19.079]   - Field: ‘stdout’
[08:26:19.079]   - Field: ‘earlySignal’
[08:26:19.079]   - Field: ‘lazy’
[08:26:19.079]   - Field: ‘state’
[08:26:19.079] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:19.079] - Launch lazy future ...
[08:26:19.080] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:19.080] Packages needed by future strategies (n = 0): <none>
[08:26:19.080] {
[08:26:19.080]     {
[08:26:19.080]         {
[08:26:19.080]             ...future.startTime <- base::Sys.time()
[08:26:19.080]             {
[08:26:19.080]                 {
[08:26:19.080]                   {
[08:26:19.080]                     {
[08:26:19.080]                       base::local({
[08:26:19.080]                         has_future <- base::requireNamespace("future", 
[08:26:19.080]                           quietly = TRUE)
[08:26:19.080]                         if (has_future) {
[08:26:19.080]                           ns <- base::getNamespace("future")
[08:26:19.080]                           version <- ns[[".package"]][["version"]]
[08:26:19.080]                           if (is.null(version)) 
[08:26:19.080]                             version <- utils::packageVersion("future")
[08:26:19.080]                         }
[08:26:19.080]                         else {
[08:26:19.080]                           version <- NULL
[08:26:19.080]                         }
[08:26:19.080]                         if (!has_future || version < "1.8.0") {
[08:26:19.080]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:19.080]                             "", base::R.version$version.string), 
[08:26:19.080]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:19.080]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:19.080]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:19.080]                               "release", "version")], collapse = " "), 
[08:26:19.080]                             hostname = base::Sys.info()[["nodename"]])
[08:26:19.080]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:19.080]                             info)
[08:26:19.080]                           info <- base::paste(info, collapse = "; ")
[08:26:19.080]                           if (!has_future) {
[08:26:19.080]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:19.080]                               info)
[08:26:19.080]                           }
[08:26:19.080]                           else {
[08:26:19.080]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:19.080]                               info, version)
[08:26:19.080]                           }
[08:26:19.080]                           base::stop(msg)
[08:26:19.080]                         }
[08:26:19.080]                       })
[08:26:19.080]                     }
[08:26:19.080]                     base::local({
[08:26:19.080]                       for (pkg in "future.apply") {
[08:26:19.080]                         base::loadNamespace(pkg)
[08:26:19.080]                         base::library(pkg, character.only = TRUE)
[08:26:19.080]                       }
[08:26:19.080]                     })
[08:26:19.080]                   }
[08:26:19.080]                   ...future.strategy.old <- future::plan("list")
[08:26:19.080]                   options(future.plan = NULL)
[08:26:19.080]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.080]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:19.080]                 }
[08:26:19.080]                 ...future.workdir <- getwd()
[08:26:19.080]             }
[08:26:19.080]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:19.080]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:19.080]         }
[08:26:19.080]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:19.080]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:19.080]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:19.080]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:19.080]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:19.080]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:19.080]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:19.080]             base::names(...future.oldOptions))
[08:26:19.080]     }
[08:26:19.080]     if (FALSE) {
[08:26:19.080]     }
[08:26:19.080]     else {
[08:26:19.080]         if (TRUE) {
[08:26:19.080]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:19.080]                 open = "w")
[08:26:19.080]         }
[08:26:19.080]         else {
[08:26:19.080]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:19.080]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:19.080]         }
[08:26:19.080]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:19.080]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:19.080]             base::sink(type = "output", split = FALSE)
[08:26:19.080]             base::close(...future.stdout)
[08:26:19.080]         }, add = TRUE)
[08:26:19.080]     }
[08:26:19.080]     ...future.frame <- base::sys.nframe()
[08:26:19.080]     ...future.conditions <- base::list()
[08:26:19.080]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:19.080]     if (FALSE) {
[08:26:19.080]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:19.080]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:19.080]     }
[08:26:19.080]     ...future.result <- base::tryCatch({
[08:26:19.080]         base::withCallingHandlers({
[08:26:19.080]             ...future.value <- base::withVisible(base::local({
[08:26:19.080]                 do.call(function(...) {
[08:26:19.080]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.080]                   if (!identical(...future.globals.maxSize.org, 
[08:26:19.080]                     ...future.globals.maxSize)) {
[08:26:19.080]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.080]                     on.exit(options(oopts), add = TRUE)
[08:26:19.080]                   }
[08:26:19.080]                   {
[08:26:19.080]                     lapply(seq_along(...future.elements_ii), 
[08:26:19.080]                       FUN = function(jj) {
[08:26:19.080]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.080]                         ...future.FUN(...future.X_jj, ...)
[08:26:19.080]                       })
[08:26:19.080]                   }
[08:26:19.080]                 }, args = future.call.arguments)
[08:26:19.080]             }))
[08:26:19.080]             future::FutureResult(value = ...future.value$value, 
[08:26:19.080]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.080]                   ...future.rng), globalenv = if (FALSE) 
[08:26:19.080]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:19.080]                     ...future.globalenv.names))
[08:26:19.080]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:19.080]         }, condition = base::local({
[08:26:19.080]             c <- base::c
[08:26:19.080]             inherits <- base::inherits
[08:26:19.080]             invokeRestart <- base::invokeRestart
[08:26:19.080]             length <- base::length
[08:26:19.080]             list <- base::list
[08:26:19.080]             seq.int <- base::seq.int
[08:26:19.080]             signalCondition <- base::signalCondition
[08:26:19.080]             sys.calls <- base::sys.calls
[08:26:19.080]             `[[` <- base::`[[`
[08:26:19.080]             `+` <- base::`+`
[08:26:19.080]             `<<-` <- base::`<<-`
[08:26:19.080]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:19.080]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:19.080]                   3L)]
[08:26:19.080]             }
[08:26:19.080]             function(cond) {
[08:26:19.080]                 is_error <- inherits(cond, "error")
[08:26:19.080]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:19.080]                   NULL)
[08:26:19.080]                 if (is_error) {
[08:26:19.080]                   sessionInformation <- function() {
[08:26:19.080]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:19.080]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:19.080]                       search = base::search(), system = base::Sys.info())
[08:26:19.080]                   }
[08:26:19.080]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.080]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:19.080]                     cond$call), session = sessionInformation(), 
[08:26:19.080]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:19.080]                   signalCondition(cond)
[08:26:19.080]                 }
[08:26:19.080]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:19.080]                 "immediateCondition"))) {
[08:26:19.080]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:19.080]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.080]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:19.080]                   if (TRUE && !signal) {
[08:26:19.080]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.080]                     {
[08:26:19.080]                       inherits <- base::inherits
[08:26:19.080]                       invokeRestart <- base::invokeRestart
[08:26:19.080]                       is.null <- base::is.null
[08:26:19.080]                       muffled <- FALSE
[08:26:19.080]                       if (inherits(cond, "message")) {
[08:26:19.080]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.080]                         if (muffled) 
[08:26:19.080]                           invokeRestart("muffleMessage")
[08:26:19.080]                       }
[08:26:19.080]                       else if (inherits(cond, "warning")) {
[08:26:19.080]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.080]                         if (muffled) 
[08:26:19.080]                           invokeRestart("muffleWarning")
[08:26:19.080]                       }
[08:26:19.080]                       else if (inherits(cond, "condition")) {
[08:26:19.080]                         if (!is.null(pattern)) {
[08:26:19.080]                           computeRestarts <- base::computeRestarts
[08:26:19.080]                           grepl <- base::grepl
[08:26:19.080]                           restarts <- computeRestarts(cond)
[08:26:19.080]                           for (restart in restarts) {
[08:26:19.080]                             name <- restart$name
[08:26:19.080]                             if (is.null(name)) 
[08:26:19.080]                               next
[08:26:19.080]                             if (!grepl(pattern, name)) 
[08:26:19.080]                               next
[08:26:19.080]                             invokeRestart(restart)
[08:26:19.080]                             muffled <- TRUE
[08:26:19.080]                             break
[08:26:19.080]                           }
[08:26:19.080]                         }
[08:26:19.080]                       }
[08:26:19.080]                       invisible(muffled)
[08:26:19.080]                     }
[08:26:19.080]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.080]                   }
[08:26:19.080]                 }
[08:26:19.080]                 else {
[08:26:19.080]                   if (TRUE) {
[08:26:19.080]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.080]                     {
[08:26:19.080]                       inherits <- base::inherits
[08:26:19.080]                       invokeRestart <- base::invokeRestart
[08:26:19.080]                       is.null <- base::is.null
[08:26:19.080]                       muffled <- FALSE
[08:26:19.080]                       if (inherits(cond, "message")) {
[08:26:19.080]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.080]                         if (muffled) 
[08:26:19.080]                           invokeRestart("muffleMessage")
[08:26:19.080]                       }
[08:26:19.080]                       else if (inherits(cond, "warning")) {
[08:26:19.080]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.080]                         if (muffled) 
[08:26:19.080]                           invokeRestart("muffleWarning")
[08:26:19.080]                       }
[08:26:19.080]                       else if (inherits(cond, "condition")) {
[08:26:19.080]                         if (!is.null(pattern)) {
[08:26:19.080]                           computeRestarts <- base::computeRestarts
[08:26:19.080]                           grepl <- base::grepl
[08:26:19.080]                           restarts <- computeRestarts(cond)
[08:26:19.080]                           for (restart in restarts) {
[08:26:19.080]                             name <- restart$name
[08:26:19.080]                             if (is.null(name)) 
[08:26:19.080]                               next
[08:26:19.080]                             if (!grepl(pattern, name)) 
[08:26:19.080]                               next
[08:26:19.080]                             invokeRestart(restart)
[08:26:19.080]                             muffled <- TRUE
[08:26:19.080]                             break
[08:26:19.080]                           }
[08:26:19.080]                         }
[08:26:19.080]                       }
[08:26:19.080]                       invisible(muffled)
[08:26:19.080]                     }
[08:26:19.080]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.080]                   }
[08:26:19.080]                 }
[08:26:19.080]             }
[08:26:19.080]         }))
[08:26:19.080]     }, error = function(ex) {
[08:26:19.080]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:19.080]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.080]                 ...future.rng), started = ...future.startTime, 
[08:26:19.080]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:19.080]             version = "1.8"), class = "FutureResult")
[08:26:19.080]     }, finally = {
[08:26:19.080]         if (!identical(...future.workdir, getwd())) 
[08:26:19.080]             setwd(...future.workdir)
[08:26:19.080]         {
[08:26:19.080]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:19.080]                 ...future.oldOptions$nwarnings <- NULL
[08:26:19.080]             }
[08:26:19.080]             base::options(...future.oldOptions)
[08:26:19.080]             if (.Platform$OS.type == "windows") {
[08:26:19.080]                 old_names <- names(...future.oldEnvVars)
[08:26:19.080]                 envs <- base::Sys.getenv()
[08:26:19.080]                 names <- names(envs)
[08:26:19.080]                 common <- intersect(names, old_names)
[08:26:19.080]                 added <- setdiff(names, old_names)
[08:26:19.080]                 removed <- setdiff(old_names, names)
[08:26:19.080]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:19.080]                   envs[common]]
[08:26:19.080]                 NAMES <- toupper(changed)
[08:26:19.080]                 args <- list()
[08:26:19.080]                 for (kk in seq_along(NAMES)) {
[08:26:19.080]                   name <- changed[[kk]]
[08:26:19.080]                   NAME <- NAMES[[kk]]
[08:26:19.080]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.080]                     next
[08:26:19.080]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.080]                 }
[08:26:19.080]                 NAMES <- toupper(added)
[08:26:19.080]                 for (kk in seq_along(NAMES)) {
[08:26:19.080]                   name <- added[[kk]]
[08:26:19.080]                   NAME <- NAMES[[kk]]
[08:26:19.080]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.080]                     next
[08:26:19.080]                   args[[name]] <- ""
[08:26:19.080]                 }
[08:26:19.080]                 NAMES <- toupper(removed)
[08:26:19.080]                 for (kk in seq_along(NAMES)) {
[08:26:19.080]                   name <- removed[[kk]]
[08:26:19.080]                   NAME <- NAMES[[kk]]
[08:26:19.080]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.080]                     next
[08:26:19.080]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.080]                 }
[08:26:19.080]                 if (length(args) > 0) 
[08:26:19.080]                   base::do.call(base::Sys.setenv, args = args)
[08:26:19.080]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:19.080]             }
[08:26:19.080]             else {
[08:26:19.080]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:19.080]             }
[08:26:19.080]             {
[08:26:19.080]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:19.080]                   0L) {
[08:26:19.080]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:19.080]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:19.080]                   base::options(opts)
[08:26:19.080]                 }
[08:26:19.080]                 {
[08:26:19.080]                   {
[08:26:19.080]                     NULL
[08:26:19.080]                     RNGkind("Mersenne-Twister")
[08:26:19.080]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:19.080]                       inherits = FALSE)
[08:26:19.080]                   }
[08:26:19.080]                   options(future.plan = NULL)
[08:26:19.080]                   if (is.na(NA_character_)) 
[08:26:19.080]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.080]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:19.080]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:19.080]                     .init = FALSE)
[08:26:19.080]                 }
[08:26:19.080]             }
[08:26:19.080]         }
[08:26:19.080]     })
[08:26:19.080]     if (TRUE) {
[08:26:19.080]         base::sink(type = "output", split = FALSE)
[08:26:19.080]         if (TRUE) {
[08:26:19.080]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:19.080]         }
[08:26:19.080]         else {
[08:26:19.080]             ...future.result["stdout"] <- base::list(NULL)
[08:26:19.080]         }
[08:26:19.080]         base::close(...future.stdout)
[08:26:19.080]         ...future.stdout <- NULL
[08:26:19.080]     }
[08:26:19.080]     ...future.result$conditions <- ...future.conditions
[08:26:19.080]     ...future.result$finished <- base::Sys.time()
[08:26:19.080]     ...future.result
[08:26:19.080] }
[08:26:19.082] assign_globals() ...
[08:26:19.082] List of 11
[08:26:19.082]  $ ...future.FUN            :function (x, ...)  
[08:26:19.082]  $ x_FUN                    :function (x)  
[08:26:19.082]  $ times                    : int 2
[08:26:19.082]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.082]  $ stop_if_not              :function (...)  
[08:26:19.082]  $ dim                      : NULL
[08:26:19.082]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:19.082]  $ future.call.arguments    : list()
[08:26:19.082]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.082]  $ ...future.elements_ii    :List of 10
[08:26:19.082]   ..$ : int 1
[08:26:19.082]   ..$ : int 2
[08:26:19.082]   ..$ : int 3
[08:26:19.082]   ..$ : int 4
[08:26:19.082]   ..$ : int 5
[08:26:19.082]   ..$ : int 6
[08:26:19.082]   ..$ : int 7
[08:26:19.082]   ..$ : int 8
[08:26:19.082]   ..$ : int 9
[08:26:19.082]   ..$ : int 10
[08:26:19.082]  $ ...future.seeds_ii       : NULL
[08:26:19.082]  $ ...future.globals.maxSize: NULL
[08:26:19.082]  - attr(*, "where")=List of 11
[08:26:19.082]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:19.082]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:19.082]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:19.082]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:19.082]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:19.082]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:19.082]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:19.082]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:19.082]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:19.082]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:19.082]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:19.082]  - attr(*, "resolved")= logi FALSE
[08:26:19.082]  - attr(*, "total_size")= num 24454
[08:26:19.082]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.082]  - attr(*, "already-done")= logi TRUE
[08:26:19.092] - copied ‘...future.FUN’ to environment
[08:26:19.092] - reassign environment for ‘x_FUN’
[08:26:19.092] - copied ‘x_FUN’ to environment
[08:26:19.092] - copied ‘times’ to environment
[08:26:19.092] - copied ‘stopf’ to environment
[08:26:19.092] - copied ‘stop_if_not’ to environment
[08:26:19.092] - copied ‘dim’ to environment
[08:26:19.092] - copied ‘valid_types’ to environment
[08:26:19.092] - copied ‘future.call.arguments’ to environment
[08:26:19.093] - copied ‘...future.elements_ii’ to environment
[08:26:19.093] - copied ‘...future.seeds_ii’ to environment
[08:26:19.093] - copied ‘...future.globals.maxSize’ to environment
[08:26:19.093] assign_globals() ... done
[08:26:19.093] plan(): Setting new future strategy stack:
[08:26:19.093] List of future strategies:
[08:26:19.093] 1. sequential:
[08:26:19.093]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.093]    - tweaked: FALSE
[08:26:19.093]    - call: NULL
[08:26:19.096] plan(): nbrOfWorkers() = 1
[08:26:19.097] plan(): Setting new future strategy stack:
[08:26:19.097] List of future strategies:
[08:26:19.097] 1. sequential:
[08:26:19.097]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.097]    - tweaked: FALSE
[08:26:19.097]    - call: plan(strategy)
[08:26:19.097] plan(): nbrOfWorkers() = 1
[08:26:19.097] SequentialFuture started (and completed)
[08:26:19.097] - Launch lazy future ... done
[08:26:19.097] run() for ‘SequentialFuture’ ... done
[08:26:19.098] Created future:
[08:26:19.098] SequentialFuture:
[08:26:19.098] Label: ‘future_vapply-1’
[08:26:19.098] Expression:
[08:26:19.098] {
[08:26:19.098]     do.call(function(...) {
[08:26:19.098]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.098]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.098]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.098]             on.exit(options(oopts), add = TRUE)
[08:26:19.098]         }
[08:26:19.098]         {
[08:26:19.098]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.098]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.098]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.098]             })
[08:26:19.098]         }
[08:26:19.098]     }, args = future.call.arguments)
[08:26:19.098] }
[08:26:19.098] Lazy evaluation: FALSE
[08:26:19.098] Asynchronous evaluation: FALSE
[08:26:19.098] Local evaluation: TRUE
[08:26:19.098] Environment: R_GlobalEnv
[08:26:19.098] Capture standard output: TRUE
[08:26:19.098] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:19.098] Globals: 11 objects totaling 13.63 KiB (function ‘...future.FUN’ of 4.88 KiB, function ‘x_FUN’ of 483 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:19.098] Packages: 1 packages (‘future.apply’)
[08:26:19.098] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:19.098] Resolved: TRUE
[08:26:19.098] Value: 271 bytes of class ‘list’
[08:26:19.098] Early signaling: FALSE
[08:26:19.098] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:19.098] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.099] Chunk #1 of 1 ... DONE
[08:26:19.099] Launching 1 futures (chunks) ... DONE
[08:26:19.099] Resolving 1 futures (chunks) ...
[08:26:19.099] resolve() on list ...
[08:26:19.099]  recursive: 0
[08:26:19.099]  length: 1
[08:26:19.099] 
[08:26:19.099] resolved() for ‘SequentialFuture’ ...
[08:26:19.099] - state: ‘finished’
[08:26:19.100] - run: TRUE
[08:26:19.100] - result: ‘FutureResult’
[08:26:19.100] resolved() for ‘SequentialFuture’ ... done
[08:26:19.100] Future #1
[08:26:19.100] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:19.100] - nx: 1
[08:26:19.100] - relay: TRUE
[08:26:19.100] - stdout: TRUE
[08:26:19.100] - signal: TRUE
[08:26:19.100] - resignal: FALSE
[08:26:19.100] - force: TRUE
[08:26:19.101] - relayed: [n=1] FALSE
[08:26:19.101] - queued futures: [n=1] FALSE
[08:26:19.101]  - until=1
[08:26:19.101]  - relaying element #1
[08:26:19.101] - relayed: [n=1] TRUE
[08:26:19.101] - queued futures: [n=1] TRUE
[08:26:19.101] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:19.101]  length: 0 (resolved future 1)
[08:26:19.101] Relaying remaining futures
[08:26:19.101] signalConditionsASAP(NULL, pos=0) ...
[08:26:19.102] - nx: 1
[08:26:19.102] - relay: TRUE
[08:26:19.102] - stdout: TRUE
[08:26:19.102] - signal: TRUE
[08:26:19.102] - resignal: FALSE
[08:26:19.102] - force: TRUE
[08:26:19.102] - relayed: [n=1] TRUE
[08:26:19.102] - queued futures: [n=1] TRUE
 - flush all
[08:26:19.102] - relayed: [n=1] TRUE
[08:26:19.102] - queued futures: [n=1] TRUE
[08:26:19.102] signalConditionsASAP(NULL, pos=0) ... done
[08:26:19.103] resolve() on list ... DONE
[08:26:19.103]  - Number of value chunks collected: 1
[08:26:19.103] Resolving 1 futures (chunks) ... DONE
[08:26:19.103] Reducing values from 1 chunks ...
[08:26:19.103]  - Number of values collected after concatenation: 10
[08:26:19.103]  - Number of values expected: 10
[08:26:19.103] Reducing values from 1 chunks ... DONE
[08:26:19.103] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[08:26:19.104] future_lapply() ...
[08:26:19.106] Number of chunks: 1
[08:26:19.106] getGlobalsAndPackagesXApply() ...
[08:26:19.106]  - future.globals: TRUE
[08:26:19.106] getGlobalsAndPackages() ...
[08:26:19.106] Searching for globals...
[08:26:19.110] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[08:26:19.110] Searching for globals ... DONE
[08:26:19.110] Resolving globals: FALSE
[08:26:19.111] The total size of the 7 globals is 13.59 KiB (13914 bytes)
[08:26:19.111] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.59 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.06 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:19.111] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.111] - packages: [1] ‘future.apply’
[08:26:19.111] getGlobalsAndPackages() ... DONE
[08:26:19.111]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.112]  - needed namespaces: [n=1] ‘future.apply’
[08:26:19.112] Finding globals ... DONE
[08:26:19.112]  - use_args: TRUE
[08:26:19.112]  - Getting '...' globals ...
[08:26:19.112] resolve() on list ...
[08:26:19.112]  recursive: 0
[08:26:19.112]  length: 1
[08:26:19.112]  elements: ‘...’
[08:26:19.113]  length: 0 (resolved future 1)
[08:26:19.113] resolve() on list ... DONE
[08:26:19.113]    - '...' content: [n=0] 
[08:26:19.113] List of 1
[08:26:19.113]  $ ...: list()
[08:26:19.113]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.113]  - attr(*, "where")=List of 1
[08:26:19.113]   ..$ ...:<environment: 0x562ca73b0e18> 
[08:26:19.113]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.113]  - attr(*, "resolved")= logi TRUE
[08:26:19.113]  - attr(*, "total_size")= num NA
[08:26:19.115]  - Getting '...' globals ... DONE
[08:26:19.115] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:19.115] List of 8
[08:26:19.115]  $ ...future.FUN:function (x, ...)  
[08:26:19.115]  $ x_FUN        :function (x)  
[08:26:19.115]  $ times        : int 4
[08:26:19.115]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.115]  $ stop_if_not  :function (...)  
[08:26:19.115]  $ dim          : int [1:2] 2 2
[08:26:19.115]  $ valid_types  : chr [1:2] "logical" "integer"
[08:26:19.115]  $ ...          : list()
[08:26:19.115]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.115]  - attr(*, "where")=List of 8
[08:26:19.115]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:19.115]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:19.115]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:19.115]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:19.115]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:19.115]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:19.115]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:19.115]   ..$ ...          :<environment: 0x562ca73b0e18> 
[08:26:19.115]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.115]  - attr(*, "resolved")= logi FALSE
[08:26:19.115]  - attr(*, "total_size")= num 24886
[08:26:19.123] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:19.123] getGlobalsAndPackagesXApply() ... DONE
[08:26:19.123] Number of futures (= number of chunks): 1
[08:26:19.123] Launching 1 futures (chunks) ...
[08:26:19.123] Chunk #1 of 1 ...
[08:26:19.123]  - Finding globals in 'X' for chunk #1 ...
[08:26:19.123] getGlobalsAndPackages() ...
[08:26:19.123] Searching for globals...
[08:26:19.124] 
[08:26:19.124] Searching for globals ... DONE
[08:26:19.124] - globals: [0] <none>
[08:26:19.124] getGlobalsAndPackages() ... DONE
[08:26:19.124]    + additional globals found: [n=0] 
[08:26:19.124]    + additional namespaces needed: [n=0] 
[08:26:19.124]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:19.124]  - seeds: <none>
[08:26:19.124]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.124] getGlobalsAndPackages() ...
[08:26:19.125] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.125] Resolving globals: FALSE
[08:26:19.125] Tweak future expression to call with '...' arguments ...
[08:26:19.125] {
[08:26:19.125]     do.call(function(...) {
[08:26:19.125]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.125]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.125]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.125]             on.exit(options(oopts), add = TRUE)
[08:26:19.125]         }
[08:26:19.125]         {
[08:26:19.125]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.125]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.125]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.125]             })
[08:26:19.125]         }
[08:26:19.125]     }, args = future.call.arguments)
[08:26:19.125] }
[08:26:19.125] Tweak future expression to call with '...' arguments ... DONE
[08:26:19.126] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.126] - packages: [1] ‘future.apply’
[08:26:19.126] getGlobalsAndPackages() ... DONE
[08:26:19.126] run() for ‘Future’ ...
[08:26:19.126] - state: ‘created’
[08:26:19.126] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:26:19.127] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.127] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:19.127]   - Field: ‘label’
[08:26:19.127]   - Field: ‘local’
[08:26:19.127]   - Field: ‘owner’
[08:26:19.127]   - Field: ‘envir’
[08:26:19.127]   - Field: ‘packages’
[08:26:19.127]   - Field: ‘gc’
[08:26:19.127]   - Field: ‘conditions’
[08:26:19.127]   - Field: ‘expr’
[08:26:19.128]   - Field: ‘uuid’
[08:26:19.128]   - Field: ‘seed’
[08:26:19.128]   - Field: ‘version’
[08:26:19.128]   - Field: ‘result’
[08:26:19.128]   - Field: ‘asynchronous’
[08:26:19.128]   - Field: ‘calls’
[08:26:19.128]   - Field: ‘globals’
[08:26:19.128]   - Field: ‘stdout’
[08:26:19.128]   - Field: ‘earlySignal’
[08:26:19.128]   - Field: ‘lazy’
[08:26:19.128]   - Field: ‘state’
[08:26:19.129] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:19.129] - Launch lazy future ...
[08:26:19.129] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:19.129] Packages needed by future strategies (n = 0): <none>
[08:26:19.129] {
[08:26:19.129]     {
[08:26:19.129]         {
[08:26:19.129]             ...future.startTime <- base::Sys.time()
[08:26:19.129]             {
[08:26:19.129]                 {
[08:26:19.129]                   {
[08:26:19.129]                     {
[08:26:19.129]                       base::local({
[08:26:19.129]                         has_future <- base::requireNamespace("future", 
[08:26:19.129]                           quietly = TRUE)
[08:26:19.129]                         if (has_future) {
[08:26:19.129]                           ns <- base::getNamespace("future")
[08:26:19.129]                           version <- ns[[".package"]][["version"]]
[08:26:19.129]                           if (is.null(version)) 
[08:26:19.129]                             version <- utils::packageVersion("future")
[08:26:19.129]                         }
[08:26:19.129]                         else {
[08:26:19.129]                           version <- NULL
[08:26:19.129]                         }
[08:26:19.129]                         if (!has_future || version < "1.8.0") {
[08:26:19.129]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:19.129]                             "", base::R.version$version.string), 
[08:26:19.129]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:19.129]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:19.129]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:19.129]                               "release", "version")], collapse = " "), 
[08:26:19.129]                             hostname = base::Sys.info()[["nodename"]])
[08:26:19.129]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:19.129]                             info)
[08:26:19.129]                           info <- base::paste(info, collapse = "; ")
[08:26:19.129]                           if (!has_future) {
[08:26:19.129]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:19.129]                               info)
[08:26:19.129]                           }
[08:26:19.129]                           else {
[08:26:19.129]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:19.129]                               info, version)
[08:26:19.129]                           }
[08:26:19.129]                           base::stop(msg)
[08:26:19.129]                         }
[08:26:19.129]                       })
[08:26:19.129]                     }
[08:26:19.129]                     base::local({
[08:26:19.129]                       for (pkg in "future.apply") {
[08:26:19.129]                         base::loadNamespace(pkg)
[08:26:19.129]                         base::library(pkg, character.only = TRUE)
[08:26:19.129]                       }
[08:26:19.129]                     })
[08:26:19.129]                   }
[08:26:19.129]                   ...future.strategy.old <- future::plan("list")
[08:26:19.129]                   options(future.plan = NULL)
[08:26:19.129]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.129]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:19.129]                 }
[08:26:19.129]                 ...future.workdir <- getwd()
[08:26:19.129]             }
[08:26:19.129]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:19.129]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:19.129]         }
[08:26:19.129]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:19.129]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:19.129]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:19.129]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:19.129]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:19.129]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:19.129]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:19.129]             base::names(...future.oldOptions))
[08:26:19.129]     }
[08:26:19.129]     if (FALSE) {
[08:26:19.129]     }
[08:26:19.129]     else {
[08:26:19.129]         if (TRUE) {
[08:26:19.129]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:19.129]                 open = "w")
[08:26:19.129]         }
[08:26:19.129]         else {
[08:26:19.129]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:19.129]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:19.129]         }
[08:26:19.129]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:19.129]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:19.129]             base::sink(type = "output", split = FALSE)
[08:26:19.129]             base::close(...future.stdout)
[08:26:19.129]         }, add = TRUE)
[08:26:19.129]     }
[08:26:19.129]     ...future.frame <- base::sys.nframe()
[08:26:19.129]     ...future.conditions <- base::list()
[08:26:19.129]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:19.129]     if (FALSE) {
[08:26:19.129]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:19.129]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:19.129]     }
[08:26:19.129]     ...future.result <- base::tryCatch({
[08:26:19.129]         base::withCallingHandlers({
[08:26:19.129]             ...future.value <- base::withVisible(base::local({
[08:26:19.129]                 do.call(function(...) {
[08:26:19.129]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.129]                   if (!identical(...future.globals.maxSize.org, 
[08:26:19.129]                     ...future.globals.maxSize)) {
[08:26:19.129]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.129]                     on.exit(options(oopts), add = TRUE)
[08:26:19.129]                   }
[08:26:19.129]                   {
[08:26:19.129]                     lapply(seq_along(...future.elements_ii), 
[08:26:19.129]                       FUN = function(jj) {
[08:26:19.129]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.129]                         ...future.FUN(...future.X_jj, ...)
[08:26:19.129]                       })
[08:26:19.129]                   }
[08:26:19.129]                 }, args = future.call.arguments)
[08:26:19.129]             }))
[08:26:19.129]             future::FutureResult(value = ...future.value$value, 
[08:26:19.129]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.129]                   ...future.rng), globalenv = if (FALSE) 
[08:26:19.129]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:19.129]                     ...future.globalenv.names))
[08:26:19.129]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:19.129]         }, condition = base::local({
[08:26:19.129]             c <- base::c
[08:26:19.129]             inherits <- base::inherits
[08:26:19.129]             invokeRestart <- base::invokeRestart
[08:26:19.129]             length <- base::length
[08:26:19.129]             list <- base::list
[08:26:19.129]             seq.int <- base::seq.int
[08:26:19.129]             signalCondition <- base::signalCondition
[08:26:19.129]             sys.calls <- base::sys.calls
[08:26:19.129]             `[[` <- base::`[[`
[08:26:19.129]             `+` <- base::`+`
[08:26:19.129]             `<<-` <- base::`<<-`
[08:26:19.129]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:19.129]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:19.129]                   3L)]
[08:26:19.129]             }
[08:26:19.129]             function(cond) {
[08:26:19.129]                 is_error <- inherits(cond, "error")
[08:26:19.129]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:19.129]                   NULL)
[08:26:19.129]                 if (is_error) {
[08:26:19.129]                   sessionInformation <- function() {
[08:26:19.129]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:19.129]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:19.129]                       search = base::search(), system = base::Sys.info())
[08:26:19.129]                   }
[08:26:19.129]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.129]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:19.129]                     cond$call), session = sessionInformation(), 
[08:26:19.129]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:19.129]                   signalCondition(cond)
[08:26:19.129]                 }
[08:26:19.129]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:19.129]                 "immediateCondition"))) {
[08:26:19.129]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:19.129]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.129]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:19.129]                   if (TRUE && !signal) {
[08:26:19.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.129]                     {
[08:26:19.129]                       inherits <- base::inherits
[08:26:19.129]                       invokeRestart <- base::invokeRestart
[08:26:19.129]                       is.null <- base::is.null
[08:26:19.129]                       muffled <- FALSE
[08:26:19.129]                       if (inherits(cond, "message")) {
[08:26:19.129]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.129]                         if (muffled) 
[08:26:19.129]                           invokeRestart("muffleMessage")
[08:26:19.129]                       }
[08:26:19.129]                       else if (inherits(cond, "warning")) {
[08:26:19.129]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.129]                         if (muffled) 
[08:26:19.129]                           invokeRestart("muffleWarning")
[08:26:19.129]                       }
[08:26:19.129]                       else if (inherits(cond, "condition")) {
[08:26:19.129]                         if (!is.null(pattern)) {
[08:26:19.129]                           computeRestarts <- base::computeRestarts
[08:26:19.129]                           grepl <- base::grepl
[08:26:19.129]                           restarts <- computeRestarts(cond)
[08:26:19.129]                           for (restart in restarts) {
[08:26:19.129]                             name <- restart$name
[08:26:19.129]                             if (is.null(name)) 
[08:26:19.129]                               next
[08:26:19.129]                             if (!grepl(pattern, name)) 
[08:26:19.129]                               next
[08:26:19.129]                             invokeRestart(restart)
[08:26:19.129]                             muffled <- TRUE
[08:26:19.129]                             break
[08:26:19.129]                           }
[08:26:19.129]                         }
[08:26:19.129]                       }
[08:26:19.129]                       invisible(muffled)
[08:26:19.129]                     }
[08:26:19.129]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.129]                   }
[08:26:19.129]                 }
[08:26:19.129]                 else {
[08:26:19.129]                   if (TRUE) {
[08:26:19.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.129]                     {
[08:26:19.129]                       inherits <- base::inherits
[08:26:19.129]                       invokeRestart <- base::invokeRestart
[08:26:19.129]                       is.null <- base::is.null
[08:26:19.129]                       muffled <- FALSE
[08:26:19.129]                       if (inherits(cond, "message")) {
[08:26:19.129]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.129]                         if (muffled) 
[08:26:19.129]                           invokeRestart("muffleMessage")
[08:26:19.129]                       }
[08:26:19.129]                       else if (inherits(cond, "warning")) {
[08:26:19.129]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.129]                         if (muffled) 
[08:26:19.129]                           invokeRestart("muffleWarning")
[08:26:19.129]                       }
[08:26:19.129]                       else if (inherits(cond, "condition")) {
[08:26:19.129]                         if (!is.null(pattern)) {
[08:26:19.129]                           computeRestarts <- base::computeRestarts
[08:26:19.129]                           grepl <- base::grepl
[08:26:19.129]                           restarts <- computeRestarts(cond)
[08:26:19.129]                           for (restart in restarts) {
[08:26:19.129]                             name <- restart$name
[08:26:19.129]                             if (is.null(name)) 
[08:26:19.129]                               next
[08:26:19.129]                             if (!grepl(pattern, name)) 
[08:26:19.129]                               next
[08:26:19.129]                             invokeRestart(restart)
[08:26:19.129]                             muffled <- TRUE
[08:26:19.129]                             break
[08:26:19.129]                           }
[08:26:19.129]                         }
[08:26:19.129]                       }
[08:26:19.129]                       invisible(muffled)
[08:26:19.129]                     }
[08:26:19.129]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.129]                   }
[08:26:19.129]                 }
[08:26:19.129]             }
[08:26:19.129]         }))
[08:26:19.129]     }, error = function(ex) {
[08:26:19.129]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:19.129]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.129]                 ...future.rng), started = ...future.startTime, 
[08:26:19.129]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:19.129]             version = "1.8"), class = "FutureResult")
[08:26:19.129]     }, finally = {
[08:26:19.129]         if (!identical(...future.workdir, getwd())) 
[08:26:19.129]             setwd(...future.workdir)
[08:26:19.129]         {
[08:26:19.129]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:19.129]                 ...future.oldOptions$nwarnings <- NULL
[08:26:19.129]             }
[08:26:19.129]             base::options(...future.oldOptions)
[08:26:19.129]             if (.Platform$OS.type == "windows") {
[08:26:19.129]                 old_names <- names(...future.oldEnvVars)
[08:26:19.129]                 envs <- base::Sys.getenv()
[08:26:19.129]                 names <- names(envs)
[08:26:19.129]                 common <- intersect(names, old_names)
[08:26:19.129]                 added <- setdiff(names, old_names)
[08:26:19.129]                 removed <- setdiff(old_names, names)
[08:26:19.129]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:19.129]                   envs[common]]
[08:26:19.129]                 NAMES <- toupper(changed)
[08:26:19.129]                 args <- list()
[08:26:19.129]                 for (kk in seq_along(NAMES)) {
[08:26:19.129]                   name <- changed[[kk]]
[08:26:19.129]                   NAME <- NAMES[[kk]]
[08:26:19.129]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.129]                     next
[08:26:19.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.129]                 }
[08:26:19.129]                 NAMES <- toupper(added)
[08:26:19.129]                 for (kk in seq_along(NAMES)) {
[08:26:19.129]                   name <- added[[kk]]
[08:26:19.129]                   NAME <- NAMES[[kk]]
[08:26:19.129]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.129]                     next
[08:26:19.129]                   args[[name]] <- ""
[08:26:19.129]                 }
[08:26:19.129]                 NAMES <- toupper(removed)
[08:26:19.129]                 for (kk in seq_along(NAMES)) {
[08:26:19.129]                   name <- removed[[kk]]
[08:26:19.129]                   NAME <- NAMES[[kk]]
[08:26:19.129]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.129]                     next
[08:26:19.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.129]                 }
[08:26:19.129]                 if (length(args) > 0) 
[08:26:19.129]                   base::do.call(base::Sys.setenv, args = args)
[08:26:19.129]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:19.129]             }
[08:26:19.129]             else {
[08:26:19.129]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:19.129]             }
[08:26:19.129]             {
[08:26:19.129]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:19.129]                   0L) {
[08:26:19.129]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:19.129]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:19.129]                   base::options(opts)
[08:26:19.129]                 }
[08:26:19.129]                 {
[08:26:19.129]                   {
[08:26:19.129]                     NULL
[08:26:19.129]                     RNGkind("Mersenne-Twister")
[08:26:19.129]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:19.129]                       inherits = FALSE)
[08:26:19.129]                   }
[08:26:19.129]                   options(future.plan = NULL)
[08:26:19.129]                   if (is.na(NA_character_)) 
[08:26:19.129]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.129]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:19.129]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:19.129]                     .init = FALSE)
[08:26:19.129]                 }
[08:26:19.129]             }
[08:26:19.129]         }
[08:26:19.129]     })
[08:26:19.129]     if (TRUE) {
[08:26:19.129]         base::sink(type = "output", split = FALSE)
[08:26:19.129]         if (TRUE) {
[08:26:19.129]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:19.129]         }
[08:26:19.129]         else {
[08:26:19.129]             ...future.result["stdout"] <- base::list(NULL)
[08:26:19.129]         }
[08:26:19.129]         base::close(...future.stdout)
[08:26:19.129]         ...future.stdout <- NULL
[08:26:19.129]     }
[08:26:19.129]     ...future.result$conditions <- ...future.conditions
[08:26:19.129]     ...future.result$finished <- base::Sys.time()
[08:26:19.129]     ...future.result
[08:26:19.129] }
[08:26:19.131] assign_globals() ...
[08:26:19.131] List of 11
[08:26:19.131]  $ ...future.FUN            :function (x, ...)  
[08:26:19.131]  $ x_FUN                    :function (x)  
[08:26:19.131]  $ times                    : int 4
[08:26:19.131]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.131]  $ stop_if_not              :function (...)  
[08:26:19.131]  $ dim                      : int [1:2] 2 2
[08:26:19.131]  $ valid_types              : chr [1:2] "logical" "integer"
[08:26:19.131]  $ future.call.arguments    : list()
[08:26:19.131]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.131]  $ ...future.elements_ii    :List of 10
[08:26:19.131]   ..$ : int 1
[08:26:19.131]   ..$ : int 2
[08:26:19.131]   ..$ : int 3
[08:26:19.131]   ..$ : int 4
[08:26:19.131]   ..$ : int 5
[08:26:19.131]   ..$ : int 6
[08:26:19.131]   ..$ : int 7
[08:26:19.131]   ..$ : int 8
[08:26:19.131]   ..$ : int 9
[08:26:19.131]   ..$ : int 10
[08:26:19.131]  $ ...future.seeds_ii       : NULL
[08:26:19.131]  $ ...future.globals.maxSize: NULL
[08:26:19.131]  - attr(*, "where")=List of 11
[08:26:19.131]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:19.131]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:19.131]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:19.131]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:19.131]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:19.131]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:19.131]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:19.131]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:19.131]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:19.131]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:19.131]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:19.131]  - attr(*, "resolved")= logi FALSE
[08:26:19.131]  - attr(*, "total_size")= num 24886
[08:26:19.131]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.131]  - attr(*, "already-done")= logi TRUE
[08:26:19.143] - copied ‘...future.FUN’ to environment
[08:26:19.143] - reassign environment for ‘x_FUN’
[08:26:19.143] - copied ‘x_FUN’ to environment
[08:26:19.143] - copied ‘times’ to environment
[08:26:19.143] - copied ‘stopf’ to environment
[08:26:19.143] - copied ‘stop_if_not’ to environment
[08:26:19.144] - copied ‘dim’ to environment
[08:26:19.144] - copied ‘valid_types’ to environment
[08:26:19.144] - copied ‘future.call.arguments’ to environment
[08:26:19.144] - copied ‘...future.elements_ii’ to environment
[08:26:19.144] - copied ‘...future.seeds_ii’ to environment
[08:26:19.144] - copied ‘...future.globals.maxSize’ to environment
[08:26:19.144] assign_globals() ... done
[08:26:19.144] plan(): Setting new future strategy stack:
[08:26:19.145] List of future strategies:
[08:26:19.145] 1. sequential:
[08:26:19.145]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.145]    - tweaked: FALSE
[08:26:19.145]    - call: NULL
[08:26:19.145] plan(): nbrOfWorkers() = 1
[08:26:19.146] plan(): Setting new future strategy stack:
[08:26:19.146] List of future strategies:
[08:26:19.146] 1. sequential:
[08:26:19.146]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.146]    - tweaked: FALSE
[08:26:19.146]    - call: plan(strategy)
[08:26:19.146] plan(): nbrOfWorkers() = 1
[08:26:19.147] SequentialFuture started (and completed)
[08:26:19.147] - Launch lazy future ... done
[08:26:19.147] run() for ‘SequentialFuture’ ... done
[08:26:19.147] Created future:
[08:26:19.147] SequentialFuture:
[08:26:19.147] Label: ‘future_vapply-1’
[08:26:19.147] Expression:
[08:26:19.147] {
[08:26:19.147]     do.call(function(...) {
[08:26:19.147]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.147]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.147]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.147]             on.exit(options(oopts), add = TRUE)
[08:26:19.147]         }
[08:26:19.147]         {
[08:26:19.147]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.147]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.147]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.147]             })
[08:26:19.147]         }
[08:26:19.147]     }, args = future.call.arguments)
[08:26:19.147] }
[08:26:19.147] Lazy evaluation: FALSE
[08:26:19.147] Asynchronous evaluation: FALSE
[08:26:19.147] Local evaluation: TRUE
[08:26:19.147] Environment: R_GlobalEnv
[08:26:19.147] Capture standard output: TRUE
[08:26:19.147] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:19.147] Globals: 11 objects totaling 13.88 KiB (function ‘...future.FUN’ of 5.05 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:19.147] Packages: 1 packages (‘future.apply’)
[08:26:19.147] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:19.147] Resolved: TRUE
[08:26:19.147] Value: 562 bytes of class ‘list’
[08:26:19.147] Early signaling: FALSE
[08:26:19.147] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:19.147] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.148] Chunk #1 of 1 ... DONE
[08:26:19.148] Launching 1 futures (chunks) ... DONE
[08:26:19.148] Resolving 1 futures (chunks) ...
[08:26:19.148] resolve() on list ...
[08:26:19.148]  recursive: 0
[08:26:19.149]  length: 1
[08:26:19.149] 
[08:26:19.149] resolved() for ‘SequentialFuture’ ...
[08:26:19.149] - state: ‘finished’
[08:26:19.149] - run: TRUE
[08:26:19.149] - result: ‘FutureResult’
[08:26:19.149] resolved() for ‘SequentialFuture’ ... done
[08:26:19.149] Future #1
[08:26:19.149] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:19.149] - nx: 1
[08:26:19.150] - relay: TRUE
[08:26:19.150] - stdout: TRUE
[08:26:19.150] - signal: TRUE
[08:26:19.150] - resignal: FALSE
[08:26:19.150] - force: TRUE
[08:26:19.150] - relayed: [n=1] FALSE
[08:26:19.150] - queued futures: [n=1] FALSE
[08:26:19.150]  - until=1
[08:26:19.150]  - relaying element #1
[08:26:19.150] - relayed: [n=1] TRUE
[08:26:19.150] - queued futures: [n=1] TRUE
[08:26:19.151] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:19.151]  length: 0 (resolved future 1)
[08:26:19.151] Relaying remaining futures
[08:26:19.151] signalConditionsASAP(NULL, pos=0) ...
[08:26:19.151] - nx: 1
[08:26:19.151] - relay: TRUE
[08:26:19.151] - stdout: TRUE
[08:26:19.151] - signal: TRUE
[08:26:19.151] - resignal: FALSE
[08:26:19.151] - force: TRUE
[08:26:19.151] - relayed: [n=1] TRUE
[08:26:19.151] - queued futures: [n=1] TRUE
 - flush all
[08:26:19.152] - relayed: [n=1] TRUE
[08:26:19.152] - queued futures: [n=1] TRUE
[08:26:19.152] signalConditionsASAP(NULL, pos=0) ... done
[08:26:19.152] resolve() on list ... DONE
[08:26:19.152]  - Number of value chunks collected: 1
[08:26:19.152] Resolving 1 futures (chunks) ... DONE
[08:26:19.152] Reducing values from 1 chunks ...
[08:26:19.152]  - Number of values collected after concatenation: 10
[08:26:19.152]  - Number of values expected: 10
[08:26:19.152] Reducing values from 1 chunks ... DONE
[08:26:19.152] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[08:26:19.153] future_lapply() ...
[08:26:19.155] Number of chunks: 1
[08:26:19.155] getGlobalsAndPackagesXApply() ...
[08:26:19.155]  - future.globals: TRUE
[08:26:19.155] getGlobalsAndPackages() ...
[08:26:19.156] Searching for globals...
[08:26:19.159] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[08:26:19.159] Searching for globals ... DONE
[08:26:19.159] Resolving globals: FALSE
[08:26:19.160] The total size of the 7 globals is 13.63 KiB (13957 bytes)
[08:26:19.160] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.63 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.09 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:19.161] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.161] - packages: [1] ‘future.apply’
[08:26:19.161] getGlobalsAndPackages() ... DONE
[08:26:19.161]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.161]  - needed namespaces: [n=1] ‘future.apply’
[08:26:19.161] Finding globals ... DONE
[08:26:19.161]  - use_args: TRUE
[08:26:19.161]  - Getting '...' globals ...
[08:26:19.162] resolve() on list ...
[08:26:19.162]  recursive: 0
[08:26:19.162]  length: 1
[08:26:19.162]  elements: ‘...’
[08:26:19.162]  length: 0 (resolved future 1)
[08:26:19.162] resolve() on list ... DONE
[08:26:19.162]    - '...' content: [n=0] 
[08:26:19.162] List of 1
[08:26:19.162]  $ ...: list()
[08:26:19.162]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.162]  - attr(*, "where")=List of 1
[08:26:19.162]   ..$ ...:<environment: 0x562ca79e42b8> 
[08:26:19.162]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.162]  - attr(*, "resolved")= logi TRUE
[08:26:19.162]  - attr(*, "total_size")= num NA
[08:26:19.167]  - Getting '...' globals ... DONE
[08:26:19.167] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:19.167] List of 8
[08:26:19.167]  $ ...future.FUN:function (x, ...)  
[08:26:19.167]  $ x_FUN        :function (x)  
[08:26:19.167]  $ times        : int 4
[08:26:19.167]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.167]  $ stop_if_not  :function (...)  
[08:26:19.167]  $ dim          : int [1:2] 2 2
[08:26:19.167]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:19.167]  $ ...          : list()
[08:26:19.167]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.167]  - attr(*, "where")=List of 8
[08:26:19.167]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:19.167]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:19.167]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:19.167]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:19.167]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:19.167]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:19.167]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:19.167]   ..$ ...          :<environment: 0x562ca79e42b8> 
[08:26:19.167]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.167]  - attr(*, "resolved")= logi FALSE
[08:26:19.167]  - attr(*, "total_size")= num 24958
[08:26:19.172] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:19.173] getGlobalsAndPackagesXApply() ... DONE
[08:26:19.173] Number of futures (= number of chunks): 1
[08:26:19.173] Launching 1 futures (chunks) ...
[08:26:19.173] Chunk #1 of 1 ...
[08:26:19.173]  - Finding globals in 'X' for chunk #1 ...
[08:26:19.173] getGlobalsAndPackages() ...
[08:26:19.173] Searching for globals...
[08:26:19.173] 
[08:26:19.174] Searching for globals ... DONE
[08:26:19.174] - globals: [0] <none>
[08:26:19.174] getGlobalsAndPackages() ... DONE
[08:26:19.174]    + additional globals found: [n=0] 
[08:26:19.174]    + additional namespaces needed: [n=0] 
[08:26:19.174]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:19.174]  - seeds: <none>
[08:26:19.174]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.174] getGlobalsAndPackages() ...
[08:26:19.174] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.174] Resolving globals: FALSE
[08:26:19.175] Tweak future expression to call with '...' arguments ...
[08:26:19.175] {
[08:26:19.175]     do.call(function(...) {
[08:26:19.175]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.175]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.175]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.175]             on.exit(options(oopts), add = TRUE)
[08:26:19.175]         }
[08:26:19.175]         {
[08:26:19.175]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.175]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.175]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.175]             })
[08:26:19.175]         }
[08:26:19.175]     }, args = future.call.arguments)
[08:26:19.175] }
[08:26:19.175] Tweak future expression to call with '...' arguments ... DONE
[08:26:19.175] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.176] - packages: [1] ‘future.apply’
[08:26:19.176] getGlobalsAndPackages() ... DONE
[08:26:19.176] run() for ‘Future’ ...
[08:26:19.176] - state: ‘created’
[08:26:19.176] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:26:19.176] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.177] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:19.177]   - Field: ‘label’
[08:26:19.177]   - Field: ‘local’
[08:26:19.177]   - Field: ‘owner’
[08:26:19.177]   - Field: ‘envir’
[08:26:19.177]   - Field: ‘packages’
[08:26:19.177]   - Field: ‘gc’
[08:26:19.177]   - Field: ‘conditions’
[08:26:19.177]   - Field: ‘expr’
[08:26:19.177]   - Field: ‘uuid’
[08:26:19.177]   - Field: ‘seed’
[08:26:19.178]   - Field: ‘version’
[08:26:19.178]   - Field: ‘result’
[08:26:19.178]   - Field: ‘asynchronous’
[08:26:19.178]   - Field: ‘calls’
[08:26:19.178]   - Field: ‘globals’
[08:26:19.178]   - Field: ‘stdout’
[08:26:19.178]   - Field: ‘earlySignal’
[08:26:19.178]   - Field: ‘lazy’
[08:26:19.178]   - Field: ‘state’
[08:26:19.178] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:19.178] - Launch lazy future ...
[08:26:19.179] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:19.179] Packages needed by future strategies (n = 0): <none>
[08:26:19.179] {
[08:26:19.179]     {
[08:26:19.179]         {
[08:26:19.179]             ...future.startTime <- base::Sys.time()
[08:26:19.179]             {
[08:26:19.179]                 {
[08:26:19.179]                   {
[08:26:19.179]                     {
[08:26:19.179]                       base::local({
[08:26:19.179]                         has_future <- base::requireNamespace("future", 
[08:26:19.179]                           quietly = TRUE)
[08:26:19.179]                         if (has_future) {
[08:26:19.179]                           ns <- base::getNamespace("future")
[08:26:19.179]                           version <- ns[[".package"]][["version"]]
[08:26:19.179]                           if (is.null(version)) 
[08:26:19.179]                             version <- utils::packageVersion("future")
[08:26:19.179]                         }
[08:26:19.179]                         else {
[08:26:19.179]                           version <- NULL
[08:26:19.179]                         }
[08:26:19.179]                         if (!has_future || version < "1.8.0") {
[08:26:19.179]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:19.179]                             "", base::R.version$version.string), 
[08:26:19.179]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:19.179]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:19.179]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:19.179]                               "release", "version")], collapse = " "), 
[08:26:19.179]                             hostname = base::Sys.info()[["nodename"]])
[08:26:19.179]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:19.179]                             info)
[08:26:19.179]                           info <- base::paste(info, collapse = "; ")
[08:26:19.179]                           if (!has_future) {
[08:26:19.179]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:19.179]                               info)
[08:26:19.179]                           }
[08:26:19.179]                           else {
[08:26:19.179]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:19.179]                               info, version)
[08:26:19.179]                           }
[08:26:19.179]                           base::stop(msg)
[08:26:19.179]                         }
[08:26:19.179]                       })
[08:26:19.179]                     }
[08:26:19.179]                     base::local({
[08:26:19.179]                       for (pkg in "future.apply") {
[08:26:19.179]                         base::loadNamespace(pkg)
[08:26:19.179]                         base::library(pkg, character.only = TRUE)
[08:26:19.179]                       }
[08:26:19.179]                     })
[08:26:19.179]                   }
[08:26:19.179]                   ...future.strategy.old <- future::plan("list")
[08:26:19.179]                   options(future.plan = NULL)
[08:26:19.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:19.179]                 }
[08:26:19.179]                 ...future.workdir <- getwd()
[08:26:19.179]             }
[08:26:19.179]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:19.179]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:19.179]         }
[08:26:19.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:19.179]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:19.179]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:19.179]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:19.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:19.179]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:19.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:19.179]             base::names(...future.oldOptions))
[08:26:19.179]     }
[08:26:19.179]     if (FALSE) {
[08:26:19.179]     }
[08:26:19.179]     else {
[08:26:19.179]         if (TRUE) {
[08:26:19.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:19.179]                 open = "w")
[08:26:19.179]         }
[08:26:19.179]         else {
[08:26:19.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:19.179]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:19.179]         }
[08:26:19.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:19.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:19.179]             base::sink(type = "output", split = FALSE)
[08:26:19.179]             base::close(...future.stdout)
[08:26:19.179]         }, add = TRUE)
[08:26:19.179]     }
[08:26:19.179]     ...future.frame <- base::sys.nframe()
[08:26:19.179]     ...future.conditions <- base::list()
[08:26:19.179]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:19.179]     if (FALSE) {
[08:26:19.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:19.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:19.179]     }
[08:26:19.179]     ...future.result <- base::tryCatch({
[08:26:19.179]         base::withCallingHandlers({
[08:26:19.179]             ...future.value <- base::withVisible(base::local({
[08:26:19.179]                 do.call(function(...) {
[08:26:19.179]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.179]                   if (!identical(...future.globals.maxSize.org, 
[08:26:19.179]                     ...future.globals.maxSize)) {
[08:26:19.179]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.179]                     on.exit(options(oopts), add = TRUE)
[08:26:19.179]                   }
[08:26:19.179]                   {
[08:26:19.179]                     lapply(seq_along(...future.elements_ii), 
[08:26:19.179]                       FUN = function(jj) {
[08:26:19.179]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.179]                         ...future.FUN(...future.X_jj, ...)
[08:26:19.179]                       })
[08:26:19.179]                   }
[08:26:19.179]                 }, args = future.call.arguments)
[08:26:19.179]             }))
[08:26:19.179]             future::FutureResult(value = ...future.value$value, 
[08:26:19.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.179]                   ...future.rng), globalenv = if (FALSE) 
[08:26:19.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:19.179]                     ...future.globalenv.names))
[08:26:19.179]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:19.179]         }, condition = base::local({
[08:26:19.179]             c <- base::c
[08:26:19.179]             inherits <- base::inherits
[08:26:19.179]             invokeRestart <- base::invokeRestart
[08:26:19.179]             length <- base::length
[08:26:19.179]             list <- base::list
[08:26:19.179]             seq.int <- base::seq.int
[08:26:19.179]             signalCondition <- base::signalCondition
[08:26:19.179]             sys.calls <- base::sys.calls
[08:26:19.179]             `[[` <- base::`[[`
[08:26:19.179]             `+` <- base::`+`
[08:26:19.179]             `<<-` <- base::`<<-`
[08:26:19.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:19.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:19.179]                   3L)]
[08:26:19.179]             }
[08:26:19.179]             function(cond) {
[08:26:19.179]                 is_error <- inherits(cond, "error")
[08:26:19.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:19.179]                   NULL)
[08:26:19.179]                 if (is_error) {
[08:26:19.179]                   sessionInformation <- function() {
[08:26:19.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:19.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:19.179]                       search = base::search(), system = base::Sys.info())
[08:26:19.179]                   }
[08:26:19.179]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:19.179]                     cond$call), session = sessionInformation(), 
[08:26:19.179]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:19.179]                   signalCondition(cond)
[08:26:19.179]                 }
[08:26:19.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:19.179]                 "immediateCondition"))) {
[08:26:19.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:19.179]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:19.179]                   if (TRUE && !signal) {
[08:26:19.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.179]                     {
[08:26:19.179]                       inherits <- base::inherits
[08:26:19.179]                       invokeRestart <- base::invokeRestart
[08:26:19.179]                       is.null <- base::is.null
[08:26:19.179]                       muffled <- FALSE
[08:26:19.179]                       if (inherits(cond, "message")) {
[08:26:19.179]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.179]                         if (muffled) 
[08:26:19.179]                           invokeRestart("muffleMessage")
[08:26:19.179]                       }
[08:26:19.179]                       else if (inherits(cond, "warning")) {
[08:26:19.179]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.179]                         if (muffled) 
[08:26:19.179]                           invokeRestart("muffleWarning")
[08:26:19.179]                       }
[08:26:19.179]                       else if (inherits(cond, "condition")) {
[08:26:19.179]                         if (!is.null(pattern)) {
[08:26:19.179]                           computeRestarts <- base::computeRestarts
[08:26:19.179]                           grepl <- base::grepl
[08:26:19.179]                           restarts <- computeRestarts(cond)
[08:26:19.179]                           for (restart in restarts) {
[08:26:19.179]                             name <- restart$name
[08:26:19.179]                             if (is.null(name)) 
[08:26:19.179]                               next
[08:26:19.179]                             if (!grepl(pattern, name)) 
[08:26:19.179]                               next
[08:26:19.179]                             invokeRestart(restart)
[08:26:19.179]                             muffled <- TRUE
[08:26:19.179]                             break
[08:26:19.179]                           }
[08:26:19.179]                         }
[08:26:19.179]                       }
[08:26:19.179]                       invisible(muffled)
[08:26:19.179]                     }
[08:26:19.179]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.179]                   }
[08:26:19.179]                 }
[08:26:19.179]                 else {
[08:26:19.179]                   if (TRUE) {
[08:26:19.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.179]                     {
[08:26:19.179]                       inherits <- base::inherits
[08:26:19.179]                       invokeRestart <- base::invokeRestart
[08:26:19.179]                       is.null <- base::is.null
[08:26:19.179]                       muffled <- FALSE
[08:26:19.179]                       if (inherits(cond, "message")) {
[08:26:19.179]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.179]                         if (muffled) 
[08:26:19.179]                           invokeRestart("muffleMessage")
[08:26:19.179]                       }
[08:26:19.179]                       else if (inherits(cond, "warning")) {
[08:26:19.179]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.179]                         if (muffled) 
[08:26:19.179]                           invokeRestart("muffleWarning")
[08:26:19.179]                       }
[08:26:19.179]                       else if (inherits(cond, "condition")) {
[08:26:19.179]                         if (!is.null(pattern)) {
[08:26:19.179]                           computeRestarts <- base::computeRestarts
[08:26:19.179]                           grepl <- base::grepl
[08:26:19.179]                           restarts <- computeRestarts(cond)
[08:26:19.179]                           for (restart in restarts) {
[08:26:19.179]                             name <- restart$name
[08:26:19.179]                             if (is.null(name)) 
[08:26:19.179]                               next
[08:26:19.179]                             if (!grepl(pattern, name)) 
[08:26:19.179]                               next
[08:26:19.179]                             invokeRestart(restart)
[08:26:19.179]                             muffled <- TRUE
[08:26:19.179]                             break
[08:26:19.179]                           }
[08:26:19.179]                         }
[08:26:19.179]                       }
[08:26:19.179]                       invisible(muffled)
[08:26:19.179]                     }
[08:26:19.179]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.179]                   }
[08:26:19.179]                 }
[08:26:19.179]             }
[08:26:19.179]         }))
[08:26:19.179]     }, error = function(ex) {
[08:26:19.179]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:19.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.179]                 ...future.rng), started = ...future.startTime, 
[08:26:19.179]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:19.179]             version = "1.8"), class = "FutureResult")
[08:26:19.179]     }, finally = {
[08:26:19.179]         if (!identical(...future.workdir, getwd())) 
[08:26:19.179]             setwd(...future.workdir)
[08:26:19.179]         {
[08:26:19.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:19.179]                 ...future.oldOptions$nwarnings <- NULL
[08:26:19.179]             }
[08:26:19.179]             base::options(...future.oldOptions)
[08:26:19.179]             if (.Platform$OS.type == "windows") {
[08:26:19.179]                 old_names <- names(...future.oldEnvVars)
[08:26:19.179]                 envs <- base::Sys.getenv()
[08:26:19.179]                 names <- names(envs)
[08:26:19.179]                 common <- intersect(names, old_names)
[08:26:19.179]                 added <- setdiff(names, old_names)
[08:26:19.179]                 removed <- setdiff(old_names, names)
[08:26:19.179]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:19.179]                   envs[common]]
[08:26:19.179]                 NAMES <- toupper(changed)
[08:26:19.179]                 args <- list()
[08:26:19.179]                 for (kk in seq_along(NAMES)) {
[08:26:19.179]                   name <- changed[[kk]]
[08:26:19.179]                   NAME <- NAMES[[kk]]
[08:26:19.179]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.179]                     next
[08:26:19.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.179]                 }
[08:26:19.179]                 NAMES <- toupper(added)
[08:26:19.179]                 for (kk in seq_along(NAMES)) {
[08:26:19.179]                   name <- added[[kk]]
[08:26:19.179]                   NAME <- NAMES[[kk]]
[08:26:19.179]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.179]                     next
[08:26:19.179]                   args[[name]] <- ""
[08:26:19.179]                 }
[08:26:19.179]                 NAMES <- toupper(removed)
[08:26:19.179]                 for (kk in seq_along(NAMES)) {
[08:26:19.179]                   name <- removed[[kk]]
[08:26:19.179]                   NAME <- NAMES[[kk]]
[08:26:19.179]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.179]                     next
[08:26:19.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.179]                 }
[08:26:19.179]                 if (length(args) > 0) 
[08:26:19.179]                   base::do.call(base::Sys.setenv, args = args)
[08:26:19.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:19.179]             }
[08:26:19.179]             else {
[08:26:19.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:19.179]             }
[08:26:19.179]             {
[08:26:19.179]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:19.179]                   0L) {
[08:26:19.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:19.179]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:19.179]                   base::options(opts)
[08:26:19.179]                 }
[08:26:19.179]                 {
[08:26:19.179]                   {
[08:26:19.179]                     NULL
[08:26:19.179]                     RNGkind("Mersenne-Twister")
[08:26:19.179]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:19.179]                       inherits = FALSE)
[08:26:19.179]                   }
[08:26:19.179]                   options(future.plan = NULL)
[08:26:19.179]                   if (is.na(NA_character_)) 
[08:26:19.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:19.179]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:19.179]                     .init = FALSE)
[08:26:19.179]                 }
[08:26:19.179]             }
[08:26:19.179]         }
[08:26:19.179]     })
[08:26:19.179]     if (TRUE) {
[08:26:19.179]         base::sink(type = "output", split = FALSE)
[08:26:19.179]         if (TRUE) {
[08:26:19.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:19.179]         }
[08:26:19.179]         else {
[08:26:19.179]             ...future.result["stdout"] <- base::list(NULL)
[08:26:19.179]         }
[08:26:19.179]         base::close(...future.stdout)
[08:26:19.179]         ...future.stdout <- NULL
[08:26:19.179]     }
[08:26:19.179]     ...future.result$conditions <- ...future.conditions
[08:26:19.179]     ...future.result$finished <- base::Sys.time()
[08:26:19.179]     ...future.result
[08:26:19.179] }
[08:26:19.181] assign_globals() ...
[08:26:19.181] List of 11
[08:26:19.181]  $ ...future.FUN            :function (x, ...)  
[08:26:19.181]  $ x_FUN                    :function (x)  
[08:26:19.181]  $ times                    : int 4
[08:26:19.181]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.181]  $ stop_if_not              :function (...)  
[08:26:19.181]  $ dim                      : int [1:2] 2 2
[08:26:19.181]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:19.181]  $ future.call.arguments    : list()
[08:26:19.181]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.181]  $ ...future.elements_ii    :List of 10
[08:26:19.181]   ..$ : int 1
[08:26:19.181]   ..$ : int 2
[08:26:19.181]   ..$ : int 3
[08:26:19.181]   ..$ : int 4
[08:26:19.181]   ..$ : int 5
[08:26:19.181]   ..$ : int 6
[08:26:19.181]   ..$ : int 7
[08:26:19.181]   ..$ : int 8
[08:26:19.181]   ..$ : int 9
[08:26:19.181]   ..$ : int 10
[08:26:19.181]  $ ...future.seeds_ii       : NULL
[08:26:19.181]  $ ...future.globals.maxSize: NULL
[08:26:19.181]  - attr(*, "where")=List of 11
[08:26:19.181]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:19.181]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:19.181]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:19.181]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:19.181]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:19.181]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:19.181]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:19.181]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:19.181]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:19.181]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:19.181]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:19.181]  - attr(*, "resolved")= logi FALSE
[08:26:19.181]  - attr(*, "total_size")= num 24958
[08:26:19.181]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.181]  - attr(*, "already-done")= logi TRUE
[08:26:19.193] - copied ‘...future.FUN’ to environment
[08:26:19.193] - reassign environment for ‘x_FUN’
[08:26:19.193] - copied ‘x_FUN’ to environment
[08:26:19.193] - copied ‘times’ to environment
[08:26:19.193] - copied ‘stopf’ to environment
[08:26:19.193] - copied ‘stop_if_not’ to environment
[08:26:19.194] - copied ‘dim’ to environment
[08:26:19.194] - copied ‘valid_types’ to environment
[08:26:19.194] - copied ‘future.call.arguments’ to environment
[08:26:19.194] - copied ‘...future.elements_ii’ to environment
[08:26:19.194] - copied ‘...future.seeds_ii’ to environment
[08:26:19.194] - copied ‘...future.globals.maxSize’ to environment
[08:26:19.194] assign_globals() ... done
[08:26:19.194] plan(): Setting new future strategy stack:
[08:26:19.195] List of future strategies:
[08:26:19.195] 1. sequential:
[08:26:19.195]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.195]    - tweaked: FALSE
[08:26:19.195]    - call: NULL
[08:26:19.195] plan(): nbrOfWorkers() = 1
[08:26:19.196] plan(): Setting new future strategy stack:
[08:26:19.196] List of future strategies:
[08:26:19.196] 1. sequential:
[08:26:19.196]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.196]    - tweaked: FALSE
[08:26:19.196]    - call: plan(strategy)
[08:26:19.196] plan(): nbrOfWorkers() = 1
[08:26:19.197] SequentialFuture started (and completed)
[08:26:19.197] - Launch lazy future ... done
[08:26:19.197] run() for ‘SequentialFuture’ ... done
[08:26:19.197] Created future:
[08:26:19.197] SequentialFuture:
[08:26:19.197] Label: ‘future_vapply-1’
[08:26:19.197] Expression:
[08:26:19.197] {
[08:26:19.197]     do.call(function(...) {
[08:26:19.197]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.197]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.197]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.197]             on.exit(options(oopts), add = TRUE)
[08:26:19.197]         }
[08:26:19.197]         {
[08:26:19.197]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.197]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.197]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.197]             })
[08:26:19.197]         }
[08:26:19.197]     }, args = future.call.arguments)
[08:26:19.197] }
[08:26:19.197] Lazy evaluation: FALSE
[08:26:19.197] Asynchronous evaluation: FALSE
[08:26:19.197] Local evaluation: TRUE
[08:26:19.197] Environment: R_GlobalEnv
[08:26:19.197] Capture standard output: TRUE
[08:26:19.197] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:19.197] Globals: 11 objects totaling 13.92 KiB (function ‘...future.FUN’ of 5.08 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:19.197] Packages: 1 packages (‘future.apply’)
[08:26:19.197] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:19.197] Resolved: TRUE
[08:26:19.197] Value: 562 bytes of class ‘list’
[08:26:19.197] Early signaling: FALSE
[08:26:19.197] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:19.197] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.198] Chunk #1 of 1 ... DONE
[08:26:19.198] Launching 1 futures (chunks) ... DONE
[08:26:19.198] Resolving 1 futures (chunks) ...
[08:26:19.198] resolve() on list ...
[08:26:19.198]  recursive: 0
[08:26:19.198]  length: 1
[08:26:19.199] 
[08:26:19.199] resolved() for ‘SequentialFuture’ ...
[08:26:19.199] - state: ‘finished’
[08:26:19.199] - run: TRUE
[08:26:19.199] - result: ‘FutureResult’
[08:26:19.199] resolved() for ‘SequentialFuture’ ... done
[08:26:19.199] Future #1
[08:26:19.199] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:19.199] - nx: 1
[08:26:19.199] - relay: TRUE
[08:26:19.199] - stdout: TRUE
[08:26:19.200] - signal: TRUE
[08:26:19.200] - resignal: FALSE
[08:26:19.200] - force: TRUE
[08:26:19.200] - relayed: [n=1] FALSE
[08:26:19.200] - queued futures: [n=1] FALSE
[08:26:19.200]  - until=1
[08:26:19.200]  - relaying element #1
[08:26:19.200] - relayed: [n=1] TRUE
[08:26:19.200] - queued futures: [n=1] TRUE
[08:26:19.200] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:19.201]  length: 0 (resolved future 1)
[08:26:19.201] Relaying remaining futures
[08:26:19.201] signalConditionsASAP(NULL, pos=0) ...
[08:26:19.201] - nx: 1
[08:26:19.201] - relay: TRUE
[08:26:19.201] - stdout: TRUE
[08:26:19.201] - signal: TRUE
[08:26:19.201] - resignal: FALSE
[08:26:19.201] - force: TRUE
[08:26:19.201] - relayed: [n=1] TRUE
[08:26:19.201] - queued futures: [n=1] TRUE
 - flush all
[08:26:19.201] - relayed: [n=1] TRUE
[08:26:19.202] - queued futures: [n=1] TRUE
[08:26:19.202] signalConditionsASAP(NULL, pos=0) ... done
[08:26:19.202] resolve() on list ... DONE
[08:26:19.202]  - Number of value chunks collected: 1
[08:26:19.202] Resolving 1 futures (chunks) ... DONE
[08:26:19.202] Reducing values from 1 chunks ...
[08:26:19.202]  - Number of values collected after concatenation: 10
[08:26:19.202]  - Number of values expected: 10
[08:26:19.202] Reducing values from 1 chunks ... DONE
[08:26:19.202] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[08:26:19.204] future_lapply() ...
[08:26:19.206] Number of chunks: 1
[08:26:19.206] getGlobalsAndPackagesXApply() ...
[08:26:19.206]  - future.globals: TRUE
[08:26:19.206] getGlobalsAndPackages() ...
[08:26:19.206] Searching for globals...
[08:26:19.241] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[08:26:19.241] Searching for globals ... DONE
[08:26:19.241] Resolving globals: FALSE
[08:26:19.242] The total size of the 7 globals is 16.05 KiB (16436 bytes)
[08:26:19.242] The total size of the 7 globals exported for future expression (‘FUN()’) is 16.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (6.71 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:19.243] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.243] - packages: [1] ‘future.apply’
[08:26:19.243] getGlobalsAndPackages() ... DONE
[08:26:19.243]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.243]  - needed namespaces: [n=1] ‘future.apply’
[08:26:19.243] Finding globals ... DONE
[08:26:19.243]  - use_args: TRUE
[08:26:19.243]  - Getting '...' globals ...
[08:26:19.244] resolve() on list ...
[08:26:19.244]  recursive: 0
[08:26:19.244]  length: 1
[08:26:19.244]  elements: ‘...’
[08:26:19.244]  length: 0 (resolved future 1)
[08:26:19.244] resolve() on list ... DONE
[08:26:19.244]    - '...' content: [n=0] 
[08:26:19.244] List of 1
[08:26:19.244]  $ ...: list()
[08:26:19.244]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.244]  - attr(*, "where")=List of 1
[08:26:19.244]   ..$ ...:<environment: 0x562ca7cfe7a0> 
[08:26:19.244]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.244]  - attr(*, "resolved")= logi TRUE
[08:26:19.244]  - attr(*, "total_size")= num NA
[08:26:19.247]  - Getting '...' globals ... DONE
[08:26:19.247] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:19.247] List of 8
[08:26:19.247]  $ ...future.FUN:function (x, ...)  
[08:26:19.247]  $ x_FUN        :function (x)  
[08:26:19.247]  $ times        : int 4
[08:26:19.247]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.247]  $ stop_if_not  :function (...)  
[08:26:19.247]  $ dim          : int [1:2] 2 2
[08:26:19.247]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:19.247]  $ ...          : list()
[08:26:19.247]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.247]  - attr(*, "where")=List of 8
[08:26:19.247]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:19.247]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:19.247]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:19.247]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:19.247]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:19.247]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:19.247]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:19.247]   ..$ ...          :<environment: 0x562ca7cfe7a0> 
[08:26:19.247]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.247]  - attr(*, "resolved")= logi FALSE
[08:26:19.247]  - attr(*, "total_size")= num 29094
[08:26:19.252] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:19.252] getGlobalsAndPackagesXApply() ... DONE
[08:26:19.253] Number of futures (= number of chunks): 1
[08:26:19.253] Launching 1 futures (chunks) ...
[08:26:19.253] Chunk #1 of 1 ...
[08:26:19.253]  - Finding globals in 'X' for chunk #1 ...
[08:26:19.253] getGlobalsAndPackages() ...
[08:26:19.253] Searching for globals...
[08:26:19.253] 
[08:26:19.254] Searching for globals ... DONE
[08:26:19.254] - globals: [0] <none>
[08:26:19.254] getGlobalsAndPackages() ... DONE
[08:26:19.254]    + additional globals found: [n=0] 
[08:26:19.254]    + additional namespaces needed: [n=0] 
[08:26:19.254]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:19.254]  - seeds: <none>
[08:26:19.254]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.254] getGlobalsAndPackages() ...
[08:26:19.254] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.254] Resolving globals: FALSE
[08:26:19.255] Tweak future expression to call with '...' arguments ...
[08:26:19.255] {
[08:26:19.255]     do.call(function(...) {
[08:26:19.255]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.255]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.255]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.255]             on.exit(options(oopts), add = TRUE)
[08:26:19.255]         }
[08:26:19.255]         {
[08:26:19.255]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.255]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.255]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.255]             })
[08:26:19.255]         }
[08:26:19.255]     }, args = future.call.arguments)
[08:26:19.255] }
[08:26:19.255] Tweak future expression to call with '...' arguments ... DONE
[08:26:19.255] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.256] - packages: [1] ‘future.apply’
[08:26:19.256] getGlobalsAndPackages() ... DONE
[08:26:19.256] run() for ‘Future’ ...
[08:26:19.256] - state: ‘created’
[08:26:19.256] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:26:19.256] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.257] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:19.257]   - Field: ‘label’
[08:26:19.257]   - Field: ‘local’
[08:26:19.257]   - Field: ‘owner’
[08:26:19.257]   - Field: ‘envir’
[08:26:19.257]   - Field: ‘packages’
[08:26:19.257]   - Field: ‘gc’
[08:26:19.257]   - Field: ‘conditions’
[08:26:19.257]   - Field: ‘expr’
[08:26:19.257]   - Field: ‘uuid’
[08:26:19.257]   - Field: ‘seed’
[08:26:19.258]   - Field: ‘version’
[08:26:19.258]   - Field: ‘result’
[08:26:19.258]   - Field: ‘asynchronous’
[08:26:19.258]   - Field: ‘calls’
[08:26:19.258]   - Field: ‘globals’
[08:26:19.258]   - Field: ‘stdout’
[08:26:19.258]   - Field: ‘earlySignal’
[08:26:19.258]   - Field: ‘lazy’
[08:26:19.258]   - Field: ‘state’
[08:26:19.258] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:19.258] - Launch lazy future ...
[08:26:19.259] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:19.259] Packages needed by future strategies (n = 0): <none>
[08:26:19.259] {
[08:26:19.259]     {
[08:26:19.259]         {
[08:26:19.259]             ...future.startTime <- base::Sys.time()
[08:26:19.259]             {
[08:26:19.259]                 {
[08:26:19.259]                   {
[08:26:19.259]                     {
[08:26:19.259]                       base::local({
[08:26:19.259]                         has_future <- base::requireNamespace("future", 
[08:26:19.259]                           quietly = TRUE)
[08:26:19.259]                         if (has_future) {
[08:26:19.259]                           ns <- base::getNamespace("future")
[08:26:19.259]                           version <- ns[[".package"]][["version"]]
[08:26:19.259]                           if (is.null(version)) 
[08:26:19.259]                             version <- utils::packageVersion("future")
[08:26:19.259]                         }
[08:26:19.259]                         else {
[08:26:19.259]                           version <- NULL
[08:26:19.259]                         }
[08:26:19.259]                         if (!has_future || version < "1.8.0") {
[08:26:19.259]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:19.259]                             "", base::R.version$version.string), 
[08:26:19.259]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:19.259]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:19.259]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:19.259]                               "release", "version")], collapse = " "), 
[08:26:19.259]                             hostname = base::Sys.info()[["nodename"]])
[08:26:19.259]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:19.259]                             info)
[08:26:19.259]                           info <- base::paste(info, collapse = "; ")
[08:26:19.259]                           if (!has_future) {
[08:26:19.259]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:19.259]                               info)
[08:26:19.259]                           }
[08:26:19.259]                           else {
[08:26:19.259]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:19.259]                               info, version)
[08:26:19.259]                           }
[08:26:19.259]                           base::stop(msg)
[08:26:19.259]                         }
[08:26:19.259]                       })
[08:26:19.259]                     }
[08:26:19.259]                     base::local({
[08:26:19.259]                       for (pkg in "future.apply") {
[08:26:19.259]                         base::loadNamespace(pkg)
[08:26:19.259]                         base::library(pkg, character.only = TRUE)
[08:26:19.259]                       }
[08:26:19.259]                     })
[08:26:19.259]                   }
[08:26:19.259]                   ...future.strategy.old <- future::plan("list")
[08:26:19.259]                   options(future.plan = NULL)
[08:26:19.259]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.259]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:19.259]                 }
[08:26:19.259]                 ...future.workdir <- getwd()
[08:26:19.259]             }
[08:26:19.259]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:19.259]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:19.259]         }
[08:26:19.259]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:19.259]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:19.259]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:19.259]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:19.259]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:19.259]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:19.259]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:19.259]             base::names(...future.oldOptions))
[08:26:19.259]     }
[08:26:19.259]     if (FALSE) {
[08:26:19.259]     }
[08:26:19.259]     else {
[08:26:19.259]         if (TRUE) {
[08:26:19.259]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:19.259]                 open = "w")
[08:26:19.259]         }
[08:26:19.259]         else {
[08:26:19.259]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:19.259]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:19.259]         }
[08:26:19.259]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:19.259]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:19.259]             base::sink(type = "output", split = FALSE)
[08:26:19.259]             base::close(...future.stdout)
[08:26:19.259]         }, add = TRUE)
[08:26:19.259]     }
[08:26:19.259]     ...future.frame <- base::sys.nframe()
[08:26:19.259]     ...future.conditions <- base::list()
[08:26:19.259]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:19.259]     if (FALSE) {
[08:26:19.259]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:19.259]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:19.259]     }
[08:26:19.259]     ...future.result <- base::tryCatch({
[08:26:19.259]         base::withCallingHandlers({
[08:26:19.259]             ...future.value <- base::withVisible(base::local({
[08:26:19.259]                 do.call(function(...) {
[08:26:19.259]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.259]                   if (!identical(...future.globals.maxSize.org, 
[08:26:19.259]                     ...future.globals.maxSize)) {
[08:26:19.259]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.259]                     on.exit(options(oopts), add = TRUE)
[08:26:19.259]                   }
[08:26:19.259]                   {
[08:26:19.259]                     lapply(seq_along(...future.elements_ii), 
[08:26:19.259]                       FUN = function(jj) {
[08:26:19.259]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.259]                         ...future.FUN(...future.X_jj, ...)
[08:26:19.259]                       })
[08:26:19.259]                   }
[08:26:19.259]                 }, args = future.call.arguments)
[08:26:19.259]             }))
[08:26:19.259]             future::FutureResult(value = ...future.value$value, 
[08:26:19.259]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.259]                   ...future.rng), globalenv = if (FALSE) 
[08:26:19.259]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:19.259]                     ...future.globalenv.names))
[08:26:19.259]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:19.259]         }, condition = base::local({
[08:26:19.259]             c <- base::c
[08:26:19.259]             inherits <- base::inherits
[08:26:19.259]             invokeRestart <- base::invokeRestart
[08:26:19.259]             length <- base::length
[08:26:19.259]             list <- base::list
[08:26:19.259]             seq.int <- base::seq.int
[08:26:19.259]             signalCondition <- base::signalCondition
[08:26:19.259]             sys.calls <- base::sys.calls
[08:26:19.259]             `[[` <- base::`[[`
[08:26:19.259]             `+` <- base::`+`
[08:26:19.259]             `<<-` <- base::`<<-`
[08:26:19.259]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:19.259]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:19.259]                   3L)]
[08:26:19.259]             }
[08:26:19.259]             function(cond) {
[08:26:19.259]                 is_error <- inherits(cond, "error")
[08:26:19.259]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:19.259]                   NULL)
[08:26:19.259]                 if (is_error) {
[08:26:19.259]                   sessionInformation <- function() {
[08:26:19.259]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:19.259]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:19.259]                       search = base::search(), system = base::Sys.info())
[08:26:19.259]                   }
[08:26:19.259]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.259]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:19.259]                     cond$call), session = sessionInformation(), 
[08:26:19.259]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:19.259]                   signalCondition(cond)
[08:26:19.259]                 }
[08:26:19.259]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:19.259]                 "immediateCondition"))) {
[08:26:19.259]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:19.259]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.259]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:19.259]                   if (TRUE && !signal) {
[08:26:19.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.259]                     {
[08:26:19.259]                       inherits <- base::inherits
[08:26:19.259]                       invokeRestart <- base::invokeRestart
[08:26:19.259]                       is.null <- base::is.null
[08:26:19.259]                       muffled <- FALSE
[08:26:19.259]                       if (inherits(cond, "message")) {
[08:26:19.259]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.259]                         if (muffled) 
[08:26:19.259]                           invokeRestart("muffleMessage")
[08:26:19.259]                       }
[08:26:19.259]                       else if (inherits(cond, "warning")) {
[08:26:19.259]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.259]                         if (muffled) 
[08:26:19.259]                           invokeRestart("muffleWarning")
[08:26:19.259]                       }
[08:26:19.259]                       else if (inherits(cond, "condition")) {
[08:26:19.259]                         if (!is.null(pattern)) {
[08:26:19.259]                           computeRestarts <- base::computeRestarts
[08:26:19.259]                           grepl <- base::grepl
[08:26:19.259]                           restarts <- computeRestarts(cond)
[08:26:19.259]                           for (restart in restarts) {
[08:26:19.259]                             name <- restart$name
[08:26:19.259]                             if (is.null(name)) 
[08:26:19.259]                               next
[08:26:19.259]                             if (!grepl(pattern, name)) 
[08:26:19.259]                               next
[08:26:19.259]                             invokeRestart(restart)
[08:26:19.259]                             muffled <- TRUE
[08:26:19.259]                             break
[08:26:19.259]                           }
[08:26:19.259]                         }
[08:26:19.259]                       }
[08:26:19.259]                       invisible(muffled)
[08:26:19.259]                     }
[08:26:19.259]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.259]                   }
[08:26:19.259]                 }
[08:26:19.259]                 else {
[08:26:19.259]                   if (TRUE) {
[08:26:19.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.259]                     {
[08:26:19.259]                       inherits <- base::inherits
[08:26:19.259]                       invokeRestart <- base::invokeRestart
[08:26:19.259]                       is.null <- base::is.null
[08:26:19.259]                       muffled <- FALSE
[08:26:19.259]                       if (inherits(cond, "message")) {
[08:26:19.259]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.259]                         if (muffled) 
[08:26:19.259]                           invokeRestart("muffleMessage")
[08:26:19.259]                       }
[08:26:19.259]                       else if (inherits(cond, "warning")) {
[08:26:19.259]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.259]                         if (muffled) 
[08:26:19.259]                           invokeRestart("muffleWarning")
[08:26:19.259]                       }
[08:26:19.259]                       else if (inherits(cond, "condition")) {
[08:26:19.259]                         if (!is.null(pattern)) {
[08:26:19.259]                           computeRestarts <- base::computeRestarts
[08:26:19.259]                           grepl <- base::grepl
[08:26:19.259]                           restarts <- computeRestarts(cond)
[08:26:19.259]                           for (restart in restarts) {
[08:26:19.259]                             name <- restart$name
[08:26:19.259]                             if (is.null(name)) 
[08:26:19.259]                               next
[08:26:19.259]                             if (!grepl(pattern, name)) 
[08:26:19.259]                               next
[08:26:19.259]                             invokeRestart(restart)
[08:26:19.259]                             muffled <- TRUE
[08:26:19.259]                             break
[08:26:19.259]                           }
[08:26:19.259]                         }
[08:26:19.259]                       }
[08:26:19.259]                       invisible(muffled)
[08:26:19.259]                     }
[08:26:19.259]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.259]                   }
[08:26:19.259]                 }
[08:26:19.259]             }
[08:26:19.259]         }))
[08:26:19.259]     }, error = function(ex) {
[08:26:19.259]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:19.259]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.259]                 ...future.rng), started = ...future.startTime, 
[08:26:19.259]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:19.259]             version = "1.8"), class = "FutureResult")
[08:26:19.259]     }, finally = {
[08:26:19.259]         if (!identical(...future.workdir, getwd())) 
[08:26:19.259]             setwd(...future.workdir)
[08:26:19.259]         {
[08:26:19.259]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:19.259]                 ...future.oldOptions$nwarnings <- NULL
[08:26:19.259]             }
[08:26:19.259]             base::options(...future.oldOptions)
[08:26:19.259]             if (.Platform$OS.type == "windows") {
[08:26:19.259]                 old_names <- names(...future.oldEnvVars)
[08:26:19.259]                 envs <- base::Sys.getenv()
[08:26:19.259]                 names <- names(envs)
[08:26:19.259]                 common <- intersect(names, old_names)
[08:26:19.259]                 added <- setdiff(names, old_names)
[08:26:19.259]                 removed <- setdiff(old_names, names)
[08:26:19.259]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:19.259]                   envs[common]]
[08:26:19.259]                 NAMES <- toupper(changed)
[08:26:19.259]                 args <- list()
[08:26:19.259]                 for (kk in seq_along(NAMES)) {
[08:26:19.259]                   name <- changed[[kk]]
[08:26:19.259]                   NAME <- NAMES[[kk]]
[08:26:19.259]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.259]                     next
[08:26:19.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.259]                 }
[08:26:19.259]                 NAMES <- toupper(added)
[08:26:19.259]                 for (kk in seq_along(NAMES)) {
[08:26:19.259]                   name <- added[[kk]]
[08:26:19.259]                   NAME <- NAMES[[kk]]
[08:26:19.259]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.259]                     next
[08:26:19.259]                   args[[name]] <- ""
[08:26:19.259]                 }
[08:26:19.259]                 NAMES <- toupper(removed)
[08:26:19.259]                 for (kk in seq_along(NAMES)) {
[08:26:19.259]                   name <- removed[[kk]]
[08:26:19.259]                   NAME <- NAMES[[kk]]
[08:26:19.259]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.259]                     next
[08:26:19.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.259]                 }
[08:26:19.259]                 if (length(args) > 0) 
[08:26:19.259]                   base::do.call(base::Sys.setenv, args = args)
[08:26:19.259]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:19.259]             }
[08:26:19.259]             else {
[08:26:19.259]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:19.259]             }
[08:26:19.259]             {
[08:26:19.259]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:19.259]                   0L) {
[08:26:19.259]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:19.259]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:19.259]                   base::options(opts)
[08:26:19.259]                 }
[08:26:19.259]                 {
[08:26:19.259]                   {
[08:26:19.259]                     NULL
[08:26:19.259]                     RNGkind("Mersenne-Twister")
[08:26:19.259]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:19.259]                       inherits = FALSE)
[08:26:19.259]                   }
[08:26:19.259]                   options(future.plan = NULL)
[08:26:19.259]                   if (is.na(NA_character_)) 
[08:26:19.259]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.259]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:19.259]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:19.259]                     .init = FALSE)
[08:26:19.259]                 }
[08:26:19.259]             }
[08:26:19.259]         }
[08:26:19.259]     })
[08:26:19.259]     if (TRUE) {
[08:26:19.259]         base::sink(type = "output", split = FALSE)
[08:26:19.259]         if (TRUE) {
[08:26:19.259]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:19.259]         }
[08:26:19.259]         else {
[08:26:19.259]             ...future.result["stdout"] <- base::list(NULL)
[08:26:19.259]         }
[08:26:19.259]         base::close(...future.stdout)
[08:26:19.259]         ...future.stdout <- NULL
[08:26:19.259]     }
[08:26:19.259]     ...future.result$conditions <- ...future.conditions
[08:26:19.259]     ...future.result$finished <- base::Sys.time()
[08:26:19.259]     ...future.result
[08:26:19.259] }
[08:26:19.261] assign_globals() ...
[08:26:19.261] List of 11
[08:26:19.261]  $ ...future.FUN            :function (x, ...)  
[08:26:19.261]  $ x_FUN                    :function (x)  
[08:26:19.261]  $ times                    : int 4
[08:26:19.261]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.261]  $ stop_if_not              :function (...)  
[08:26:19.261]  $ dim                      : int [1:2] 2 2
[08:26:19.261]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:19.261]  $ future.call.arguments    : list()
[08:26:19.261]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.261]  $ ...future.elements_ii    :List of 10
[08:26:19.261]   ..$ : int 1
[08:26:19.261]   ..$ : int 2
[08:26:19.261]   ..$ : int 3
[08:26:19.261]   ..$ : int 4
[08:26:19.261]   ..$ : int 5
[08:26:19.261]   ..$ : int 6
[08:26:19.261]   ..$ : int 7
[08:26:19.261]   ..$ : int 8
[08:26:19.261]   ..$ : int 9
[08:26:19.261]   ..$ : int 10
[08:26:19.261]  $ ...future.seeds_ii       : NULL
[08:26:19.261]  $ ...future.globals.maxSize: NULL
[08:26:19.261]  - attr(*, "where")=List of 11
[08:26:19.261]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:19.261]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:19.261]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:19.261]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:19.261]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:19.261]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:19.261]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:19.261]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:19.261]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:19.261]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:19.261]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:19.261]  - attr(*, "resolved")= logi FALSE
[08:26:19.261]  - attr(*, "total_size")= num 29094
[08:26:19.261]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.261]  - attr(*, "already-done")= logi TRUE
[08:26:19.274] - copied ‘...future.FUN’ to environment
[08:26:19.274] - reassign environment for ‘x_FUN’
[08:26:19.274] - copied ‘x_FUN’ to environment
[08:26:19.274] - copied ‘times’ to environment
[08:26:19.274] - copied ‘stopf’ to environment
[08:26:19.274] - copied ‘stop_if_not’ to environment
[08:26:19.274] - copied ‘dim’ to environment
[08:26:19.274] - copied ‘valid_types’ to environment
[08:26:19.274] - copied ‘future.call.arguments’ to environment
[08:26:19.275] - copied ‘...future.elements_ii’ to environment
[08:26:19.275] - copied ‘...future.seeds_ii’ to environment
[08:26:19.275] - copied ‘...future.globals.maxSize’ to environment
[08:26:19.275] assign_globals() ... done
[08:26:19.275] plan(): Setting new future strategy stack:
[08:26:19.275] List of future strategies:
[08:26:19.275] 1. sequential:
[08:26:19.275]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.275]    - tweaked: FALSE
[08:26:19.275]    - call: NULL
[08:26:19.276] plan(): nbrOfWorkers() = 1
[08:26:19.277] plan(): Setting new future strategy stack:
[08:26:19.277] List of future strategies:
[08:26:19.277] 1. sequential:
[08:26:19.277]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.277]    - tweaked: FALSE
[08:26:19.277]    - call: plan(strategy)
[08:26:19.277] plan(): nbrOfWorkers() = 1
[08:26:19.278] SequentialFuture started (and completed)
[08:26:19.278] - Launch lazy future ... done
[08:26:19.278] run() for ‘SequentialFuture’ ... done
[08:26:19.278] Created future:
[08:26:19.278] SequentialFuture:
[08:26:19.278] Label: ‘future_vapply-1’
[08:26:19.278] Expression:
[08:26:19.278] {
[08:26:19.278]     do.call(function(...) {
[08:26:19.278]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.278]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.278]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.278]             on.exit(options(oopts), add = TRUE)
[08:26:19.278]         }
[08:26:19.278]         {
[08:26:19.278]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.278]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.278]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.278]             })
[08:26:19.278]         }
[08:26:19.278]     }, args = future.call.arguments)
[08:26:19.278] }
[08:26:19.278] Lazy evaluation: FALSE
[08:26:19.278] Asynchronous evaluation: FALSE
[08:26:19.278] Local evaluation: TRUE
[08:26:19.278] Environment: R_GlobalEnv
[08:26:19.278] Capture standard output: TRUE
[08:26:19.278] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:19.278] Globals: 11 objects totaling 16.34 KiB (function ‘...future.FUN’ of 6.70 KiB, function ‘x_FUN’ of 1.36 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:19.278] Packages: 1 packages (‘future.apply’)
[08:26:19.278] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:19.278] Resolved: TRUE
[08:26:19.278] Value: 1.23 KiB of class ‘list’
[08:26:19.278] Early signaling: FALSE
[08:26:19.278] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:19.278] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.279] Chunk #1 of 1 ... DONE
[08:26:19.279] Launching 1 futures (chunks) ... DONE
[08:26:19.279] Resolving 1 futures (chunks) ...
[08:26:19.279] resolve() on list ...
[08:26:19.279]  recursive: 0
[08:26:19.280]  length: 1
[08:26:19.280] 
[08:26:19.280] resolved() for ‘SequentialFuture’ ...
[08:26:19.280] - state: ‘finished’
[08:26:19.280] - run: TRUE
[08:26:19.280] - result: ‘FutureResult’
[08:26:19.280] resolved() for ‘SequentialFuture’ ... done
[08:26:19.280] Future #1
[08:26:19.280] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:19.280] - nx: 1
[08:26:19.281] - relay: TRUE
[08:26:19.281] - stdout: TRUE
[08:26:19.281] - signal: TRUE
[08:26:19.281] - resignal: FALSE
[08:26:19.281] - force: TRUE
[08:26:19.281] - relayed: [n=1] FALSE
[08:26:19.281] - queued futures: [n=1] FALSE
[08:26:19.281]  - until=1
[08:26:19.281]  - relaying element #1
[08:26:19.281] - relayed: [n=1] TRUE
[08:26:19.281] - queued futures: [n=1] TRUE
[08:26:19.282] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:19.282]  length: 0 (resolved future 1)
[08:26:19.282] Relaying remaining futures
[08:26:19.282] signalConditionsASAP(NULL, pos=0) ...
[08:26:19.282] - nx: 1
[08:26:19.282] - relay: TRUE
[08:26:19.282] - stdout: TRUE
[08:26:19.282] - signal: TRUE
[08:26:19.282] - resignal: FALSE
[08:26:19.282] - force: TRUE
[08:26:19.282] - relayed: [n=1] TRUE
[08:26:19.282] - queued futures: [n=1] TRUE
 - flush all
[08:26:19.283] - relayed: [n=1] TRUE
[08:26:19.283] - queued futures: [n=1] TRUE
[08:26:19.283] signalConditionsASAP(NULL, pos=0) ... done
[08:26:19.283] resolve() on list ... DONE
[08:26:19.283]  - Number of value chunks collected: 1
[08:26:19.283] Resolving 1 futures (chunks) ... DONE
[08:26:19.283] Reducing values from 1 chunks ...
[08:26:19.283]  - Number of values collected after concatenation: 10
[08:26:19.283]  - Number of values expected: 10
[08:26:19.283] Reducing values from 1 chunks ... DONE
[08:26:19.283] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[08:26:19.287] future_lapply() ...
[08:26:19.289] Number of chunks: 1
[08:26:19.289] getGlobalsAndPackagesXApply() ...
[08:26:19.289]  - future.globals: TRUE
[08:26:19.289] getGlobalsAndPackages() ...
[08:26:19.289] Searching for globals...
[08:26:19.294] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[08:26:19.295] Searching for globals ... DONE
[08:26:19.295] Resolving globals: FALSE
[08:26:19.296] The total size of the 7 globals is 13.03 KiB (13339 bytes)
[08:26:19.296] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.03 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.75 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:19.296] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.296] - packages: [2] ‘stats’, ‘future.apply’
[08:26:19.296] getGlobalsAndPackages() ... DONE
[08:26:19.296]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.297]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[08:26:19.297] Finding globals ... DONE
[08:26:19.297]  - use_args: TRUE
[08:26:19.297]  - Getting '...' globals ...
[08:26:19.297] resolve() on list ...
[08:26:19.297]  recursive: 0
[08:26:19.297]  length: 1
[08:26:19.297]  elements: ‘...’
[08:26:19.298]  length: 0 (resolved future 1)
[08:26:19.298] resolve() on list ... DONE
[08:26:19.298]    - '...' content: [n=0] 
[08:26:19.298] List of 1
[08:26:19.298]  $ ...: list()
[08:26:19.298]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.298]  - attr(*, "where")=List of 1
[08:26:19.298]   ..$ ...:<environment: 0x562ca7f2adc8> 
[08:26:19.298]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.298]  - attr(*, "resolved")= logi TRUE
[08:26:19.298]  - attr(*, "total_size")= num NA
[08:26:19.300]  - Getting '...' globals ... DONE
[08:26:19.300] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:19.300] List of 8
[08:26:19.300]  $ ...future.FUN:function (x, ...)  
[08:26:19.300]  $ x_FUN        :function (x, ...)  
[08:26:19.300]  $ times        : int 5
[08:26:19.300]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.300]  $ stop_if_not  :function (...)  
[08:26:19.300]  $ dim          : NULL
[08:26:19.300]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:19.300]  $ ...          : list()
[08:26:19.300]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.300]  - attr(*, "where")=List of 8
[08:26:19.300]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:19.300]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:19.300]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:19.300]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:19.300]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:19.300]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:19.300]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:19.300]   ..$ ...          :<environment: 0x562ca7f2adc8> 
[08:26:19.300]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.300]  - attr(*, "resolved")= logi FALSE
[08:26:19.300]  - attr(*, "total_size")= num 24127
[08:26:19.306] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[08:26:19.306] getGlobalsAndPackagesXApply() ... DONE
[08:26:19.306] Number of futures (= number of chunks): 1
[08:26:19.306] Launching 1 futures (chunks) ...
[08:26:19.306] Chunk #1 of 1 ...
[08:26:19.306]  - Finding globals in 'X' for chunk #1 ...
[08:26:19.306] getGlobalsAndPackages() ...
[08:26:19.307] Searching for globals...
[08:26:19.307] 
[08:26:19.307] Searching for globals ... DONE
[08:26:19.307] - globals: [0] <none>
[08:26:19.307] getGlobalsAndPackages() ... DONE
[08:26:19.307]    + additional globals found: [n=0] 
[08:26:19.307]    + additional namespaces needed: [n=0] 
[08:26:19.307]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:19.307]  - seeds: <none>
[08:26:19.307]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.308] getGlobalsAndPackages() ...
[08:26:19.308] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.308] Resolving globals: FALSE
[08:26:19.308] Tweak future expression to call with '...' arguments ...
[08:26:19.308] {
[08:26:19.308]     do.call(function(...) {
[08:26:19.308]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.308]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.308]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.308]             on.exit(options(oopts), add = TRUE)
[08:26:19.308]         }
[08:26:19.308]         {
[08:26:19.308]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.308]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.308]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.308]             })
[08:26:19.308]         }
[08:26:19.308]     }, args = future.call.arguments)
[08:26:19.308] }
[08:26:19.308] Tweak future expression to call with '...' arguments ... DONE
[08:26:19.309] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.309] - packages: [2] ‘stats’, ‘future.apply’
[08:26:19.309] getGlobalsAndPackages() ... DONE
[08:26:19.309] run() for ‘Future’ ...
[08:26:19.309] - state: ‘created’
[08:26:19.310] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:26:19.310] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.310] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:19.310]   - Field: ‘label’
[08:26:19.310]   - Field: ‘local’
[08:26:19.310]   - Field: ‘owner’
[08:26:19.310]   - Field: ‘envir’
[08:26:19.310]   - Field: ‘packages’
[08:26:19.310]   - Field: ‘gc’
[08:26:19.311]   - Field: ‘conditions’
[08:26:19.311]   - Field: ‘expr’
[08:26:19.311]   - Field: ‘uuid’
[08:26:19.311]   - Field: ‘seed’
[08:26:19.311]   - Field: ‘version’
[08:26:19.311]   - Field: ‘result’
[08:26:19.311]   - Field: ‘asynchronous’
[08:26:19.311]   - Field: ‘calls’
[08:26:19.311]   - Field: ‘globals’
[08:26:19.311]   - Field: ‘stdout’
[08:26:19.311]   - Field: ‘earlySignal’
[08:26:19.311]   - Field: ‘lazy’
[08:26:19.312]   - Field: ‘state’
[08:26:19.312] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:19.312] - Launch lazy future ...
[08:26:19.312] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[08:26:19.312] Packages needed by future strategies (n = 0): <none>
[08:26:19.313] {
[08:26:19.313]     {
[08:26:19.313]         {
[08:26:19.313]             ...future.startTime <- base::Sys.time()
[08:26:19.313]             {
[08:26:19.313]                 {
[08:26:19.313]                   {
[08:26:19.313]                     {
[08:26:19.313]                       base::local({
[08:26:19.313]                         has_future <- base::requireNamespace("future", 
[08:26:19.313]                           quietly = TRUE)
[08:26:19.313]                         if (has_future) {
[08:26:19.313]                           ns <- base::getNamespace("future")
[08:26:19.313]                           version <- ns[[".package"]][["version"]]
[08:26:19.313]                           if (is.null(version)) 
[08:26:19.313]                             version <- utils::packageVersion("future")
[08:26:19.313]                         }
[08:26:19.313]                         else {
[08:26:19.313]                           version <- NULL
[08:26:19.313]                         }
[08:26:19.313]                         if (!has_future || version < "1.8.0") {
[08:26:19.313]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:19.313]                             "", base::R.version$version.string), 
[08:26:19.313]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:19.313]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:19.313]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:19.313]                               "release", "version")], collapse = " "), 
[08:26:19.313]                             hostname = base::Sys.info()[["nodename"]])
[08:26:19.313]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:19.313]                             info)
[08:26:19.313]                           info <- base::paste(info, collapse = "; ")
[08:26:19.313]                           if (!has_future) {
[08:26:19.313]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:19.313]                               info)
[08:26:19.313]                           }
[08:26:19.313]                           else {
[08:26:19.313]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:19.313]                               info, version)
[08:26:19.313]                           }
[08:26:19.313]                           base::stop(msg)
[08:26:19.313]                         }
[08:26:19.313]                       })
[08:26:19.313]                     }
[08:26:19.313]                     base::local({
[08:26:19.313]                       for (pkg in c("stats", "future.apply")) {
[08:26:19.313]                         base::loadNamespace(pkg)
[08:26:19.313]                         base::library(pkg, character.only = TRUE)
[08:26:19.313]                       }
[08:26:19.313]                     })
[08:26:19.313]                   }
[08:26:19.313]                   ...future.strategy.old <- future::plan("list")
[08:26:19.313]                   options(future.plan = NULL)
[08:26:19.313]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.313]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:19.313]                 }
[08:26:19.313]                 ...future.workdir <- getwd()
[08:26:19.313]             }
[08:26:19.313]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:19.313]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:19.313]         }
[08:26:19.313]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:19.313]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:19.313]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:19.313]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:19.313]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:19.313]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:19.313]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:19.313]             base::names(...future.oldOptions))
[08:26:19.313]     }
[08:26:19.313]     if (FALSE) {
[08:26:19.313]     }
[08:26:19.313]     else {
[08:26:19.313]         if (TRUE) {
[08:26:19.313]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:19.313]                 open = "w")
[08:26:19.313]         }
[08:26:19.313]         else {
[08:26:19.313]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:19.313]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:19.313]         }
[08:26:19.313]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:19.313]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:19.313]             base::sink(type = "output", split = FALSE)
[08:26:19.313]             base::close(...future.stdout)
[08:26:19.313]         }, add = TRUE)
[08:26:19.313]     }
[08:26:19.313]     ...future.frame <- base::sys.nframe()
[08:26:19.313]     ...future.conditions <- base::list()
[08:26:19.313]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:19.313]     if (FALSE) {
[08:26:19.313]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:19.313]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:19.313]     }
[08:26:19.313]     ...future.result <- base::tryCatch({
[08:26:19.313]         base::withCallingHandlers({
[08:26:19.313]             ...future.value <- base::withVisible(base::local({
[08:26:19.313]                 do.call(function(...) {
[08:26:19.313]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.313]                   if (!identical(...future.globals.maxSize.org, 
[08:26:19.313]                     ...future.globals.maxSize)) {
[08:26:19.313]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.313]                     on.exit(options(oopts), add = TRUE)
[08:26:19.313]                   }
[08:26:19.313]                   {
[08:26:19.313]                     lapply(seq_along(...future.elements_ii), 
[08:26:19.313]                       FUN = function(jj) {
[08:26:19.313]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.313]                         ...future.FUN(...future.X_jj, ...)
[08:26:19.313]                       })
[08:26:19.313]                   }
[08:26:19.313]                 }, args = future.call.arguments)
[08:26:19.313]             }))
[08:26:19.313]             future::FutureResult(value = ...future.value$value, 
[08:26:19.313]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.313]                   ...future.rng), globalenv = if (FALSE) 
[08:26:19.313]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:19.313]                     ...future.globalenv.names))
[08:26:19.313]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:19.313]         }, condition = base::local({
[08:26:19.313]             c <- base::c
[08:26:19.313]             inherits <- base::inherits
[08:26:19.313]             invokeRestart <- base::invokeRestart
[08:26:19.313]             length <- base::length
[08:26:19.313]             list <- base::list
[08:26:19.313]             seq.int <- base::seq.int
[08:26:19.313]             signalCondition <- base::signalCondition
[08:26:19.313]             sys.calls <- base::sys.calls
[08:26:19.313]             `[[` <- base::`[[`
[08:26:19.313]             `+` <- base::`+`
[08:26:19.313]             `<<-` <- base::`<<-`
[08:26:19.313]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:19.313]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:19.313]                   3L)]
[08:26:19.313]             }
[08:26:19.313]             function(cond) {
[08:26:19.313]                 is_error <- inherits(cond, "error")
[08:26:19.313]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:19.313]                   NULL)
[08:26:19.313]                 if (is_error) {
[08:26:19.313]                   sessionInformation <- function() {
[08:26:19.313]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:19.313]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:19.313]                       search = base::search(), system = base::Sys.info())
[08:26:19.313]                   }
[08:26:19.313]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.313]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:19.313]                     cond$call), session = sessionInformation(), 
[08:26:19.313]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:19.313]                   signalCondition(cond)
[08:26:19.313]                 }
[08:26:19.313]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:19.313]                 "immediateCondition"))) {
[08:26:19.313]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:19.313]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.313]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:19.313]                   if (TRUE && !signal) {
[08:26:19.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.313]                     {
[08:26:19.313]                       inherits <- base::inherits
[08:26:19.313]                       invokeRestart <- base::invokeRestart
[08:26:19.313]                       is.null <- base::is.null
[08:26:19.313]                       muffled <- FALSE
[08:26:19.313]                       if (inherits(cond, "message")) {
[08:26:19.313]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.313]                         if (muffled) 
[08:26:19.313]                           invokeRestart("muffleMessage")
[08:26:19.313]                       }
[08:26:19.313]                       else if (inherits(cond, "warning")) {
[08:26:19.313]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.313]                         if (muffled) 
[08:26:19.313]                           invokeRestart("muffleWarning")
[08:26:19.313]                       }
[08:26:19.313]                       else if (inherits(cond, "condition")) {
[08:26:19.313]                         if (!is.null(pattern)) {
[08:26:19.313]                           computeRestarts <- base::computeRestarts
[08:26:19.313]                           grepl <- base::grepl
[08:26:19.313]                           restarts <- computeRestarts(cond)
[08:26:19.313]                           for (restart in restarts) {
[08:26:19.313]                             name <- restart$name
[08:26:19.313]                             if (is.null(name)) 
[08:26:19.313]                               next
[08:26:19.313]                             if (!grepl(pattern, name)) 
[08:26:19.313]                               next
[08:26:19.313]                             invokeRestart(restart)
[08:26:19.313]                             muffled <- TRUE
[08:26:19.313]                             break
[08:26:19.313]                           }
[08:26:19.313]                         }
[08:26:19.313]                       }
[08:26:19.313]                       invisible(muffled)
[08:26:19.313]                     }
[08:26:19.313]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.313]                   }
[08:26:19.313]                 }
[08:26:19.313]                 else {
[08:26:19.313]                   if (TRUE) {
[08:26:19.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.313]                     {
[08:26:19.313]                       inherits <- base::inherits
[08:26:19.313]                       invokeRestart <- base::invokeRestart
[08:26:19.313]                       is.null <- base::is.null
[08:26:19.313]                       muffled <- FALSE
[08:26:19.313]                       if (inherits(cond, "message")) {
[08:26:19.313]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.313]                         if (muffled) 
[08:26:19.313]                           invokeRestart("muffleMessage")
[08:26:19.313]                       }
[08:26:19.313]                       else if (inherits(cond, "warning")) {
[08:26:19.313]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.313]                         if (muffled) 
[08:26:19.313]                           invokeRestart("muffleWarning")
[08:26:19.313]                       }
[08:26:19.313]                       else if (inherits(cond, "condition")) {
[08:26:19.313]                         if (!is.null(pattern)) {
[08:26:19.313]                           computeRestarts <- base::computeRestarts
[08:26:19.313]                           grepl <- base::grepl
[08:26:19.313]                           restarts <- computeRestarts(cond)
[08:26:19.313]                           for (restart in restarts) {
[08:26:19.313]                             name <- restart$name
[08:26:19.313]                             if (is.null(name)) 
[08:26:19.313]                               next
[08:26:19.313]                             if (!grepl(pattern, name)) 
[08:26:19.313]                               next
[08:26:19.313]                             invokeRestart(restart)
[08:26:19.313]                             muffled <- TRUE
[08:26:19.313]                             break
[08:26:19.313]                           }
[08:26:19.313]                         }
[08:26:19.313]                       }
[08:26:19.313]                       invisible(muffled)
[08:26:19.313]                     }
[08:26:19.313]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.313]                   }
[08:26:19.313]                 }
[08:26:19.313]             }
[08:26:19.313]         }))
[08:26:19.313]     }, error = function(ex) {
[08:26:19.313]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:19.313]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.313]                 ...future.rng), started = ...future.startTime, 
[08:26:19.313]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:19.313]             version = "1.8"), class = "FutureResult")
[08:26:19.313]     }, finally = {
[08:26:19.313]         if (!identical(...future.workdir, getwd())) 
[08:26:19.313]             setwd(...future.workdir)
[08:26:19.313]         {
[08:26:19.313]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:19.313]                 ...future.oldOptions$nwarnings <- NULL
[08:26:19.313]             }
[08:26:19.313]             base::options(...future.oldOptions)
[08:26:19.313]             if (.Platform$OS.type == "windows") {
[08:26:19.313]                 old_names <- names(...future.oldEnvVars)
[08:26:19.313]                 envs <- base::Sys.getenv()
[08:26:19.313]                 names <- names(envs)
[08:26:19.313]                 common <- intersect(names, old_names)
[08:26:19.313]                 added <- setdiff(names, old_names)
[08:26:19.313]                 removed <- setdiff(old_names, names)
[08:26:19.313]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:19.313]                   envs[common]]
[08:26:19.313]                 NAMES <- toupper(changed)
[08:26:19.313]                 args <- list()
[08:26:19.313]                 for (kk in seq_along(NAMES)) {
[08:26:19.313]                   name <- changed[[kk]]
[08:26:19.313]                   NAME <- NAMES[[kk]]
[08:26:19.313]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.313]                     next
[08:26:19.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.313]                 }
[08:26:19.313]                 NAMES <- toupper(added)
[08:26:19.313]                 for (kk in seq_along(NAMES)) {
[08:26:19.313]                   name <- added[[kk]]
[08:26:19.313]                   NAME <- NAMES[[kk]]
[08:26:19.313]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.313]                     next
[08:26:19.313]                   args[[name]] <- ""
[08:26:19.313]                 }
[08:26:19.313]                 NAMES <- toupper(removed)
[08:26:19.313]                 for (kk in seq_along(NAMES)) {
[08:26:19.313]                   name <- removed[[kk]]
[08:26:19.313]                   NAME <- NAMES[[kk]]
[08:26:19.313]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.313]                     next
[08:26:19.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.313]                 }
[08:26:19.313]                 if (length(args) > 0) 
[08:26:19.313]                   base::do.call(base::Sys.setenv, args = args)
[08:26:19.313]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:19.313]             }
[08:26:19.313]             else {
[08:26:19.313]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:19.313]             }
[08:26:19.313]             {
[08:26:19.313]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:19.313]                   0L) {
[08:26:19.313]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:19.313]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:19.313]                   base::options(opts)
[08:26:19.313]                 }
[08:26:19.313]                 {
[08:26:19.313]                   {
[08:26:19.313]                     NULL
[08:26:19.313]                     RNGkind("Mersenne-Twister")
[08:26:19.313]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:19.313]                       inherits = FALSE)
[08:26:19.313]                   }
[08:26:19.313]                   options(future.plan = NULL)
[08:26:19.313]                   if (is.na(NA_character_)) 
[08:26:19.313]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.313]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:19.313]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:19.313]                     .init = FALSE)
[08:26:19.313]                 }
[08:26:19.313]             }
[08:26:19.313]         }
[08:26:19.313]     })
[08:26:19.313]     if (TRUE) {
[08:26:19.313]         base::sink(type = "output", split = FALSE)
[08:26:19.313]         if (TRUE) {
[08:26:19.313]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:19.313]         }
[08:26:19.313]         else {
[08:26:19.313]             ...future.result["stdout"] <- base::list(NULL)
[08:26:19.313]         }
[08:26:19.313]         base::close(...future.stdout)
[08:26:19.313]         ...future.stdout <- NULL
[08:26:19.313]     }
[08:26:19.313]     ...future.result$conditions <- ...future.conditions
[08:26:19.313]     ...future.result$finished <- base::Sys.time()
[08:26:19.313]     ...future.result
[08:26:19.313] }
[08:26:19.314] assign_globals() ...
[08:26:19.315] List of 11
[08:26:19.315]  $ ...future.FUN            :function (x, ...)  
[08:26:19.315]  $ x_FUN                    :function (x, ...)  
[08:26:19.315]  $ times                    : int 5
[08:26:19.315]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.315]  $ stop_if_not              :function (...)  
[08:26:19.315]  $ dim                      : NULL
[08:26:19.315]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:19.315]  $ future.call.arguments    : list()
[08:26:19.315]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.315]  $ ...future.elements_ii    :List of 3
[08:26:19.315]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[08:26:19.315]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[08:26:19.315]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[08:26:19.315]  $ ...future.seeds_ii       : NULL
[08:26:19.315]  $ ...future.globals.maxSize: NULL
[08:26:19.315]  - attr(*, "where")=List of 11
[08:26:19.315]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:19.315]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:19.315]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:19.315]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:19.315]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:19.315]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:19.315]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:19.315]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:19.315]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:19.315]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:19.315]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:19.315]  - attr(*, "resolved")= logi FALSE
[08:26:19.315]  - attr(*, "total_size")= num 24127
[08:26:19.315]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.315]  - attr(*, "already-done")= logi TRUE
[08:26:19.324] - copied ‘...future.FUN’ to environment
[08:26:19.324] - copied ‘x_FUN’ to environment
[08:26:19.324] - copied ‘times’ to environment
[08:26:19.324] - copied ‘stopf’ to environment
[08:26:19.325] - copied ‘stop_if_not’ to environment
[08:26:19.325] - copied ‘dim’ to environment
[08:26:19.325] - copied ‘valid_types’ to environment
[08:26:19.325] - copied ‘future.call.arguments’ to environment
[08:26:19.325] - copied ‘...future.elements_ii’ to environment
[08:26:19.325] - copied ‘...future.seeds_ii’ to environment
[08:26:19.325] - copied ‘...future.globals.maxSize’ to environment
[08:26:19.325] assign_globals() ... done
[08:26:19.326] plan(): Setting new future strategy stack:
[08:26:19.326] List of future strategies:
[08:26:19.326] 1. sequential:
[08:26:19.326]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.326]    - tweaked: FALSE
[08:26:19.326]    - call: NULL
[08:26:19.326] plan(): nbrOfWorkers() = 1
[08:26:19.328] plan(): Setting new future strategy stack:
[08:26:19.328] List of future strategies:
[08:26:19.328] 1. sequential:
[08:26:19.328]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.328]    - tweaked: FALSE
[08:26:19.328]    - call: plan(strategy)
[08:26:19.328] plan(): nbrOfWorkers() = 1
[08:26:19.328] SequentialFuture started (and completed)
[08:26:19.328] - Launch lazy future ... done
[08:26:19.328] run() for ‘SequentialFuture’ ... done
[08:26:19.329] Created future:
[08:26:19.329] SequentialFuture:
[08:26:19.329] Label: ‘future_vapply-1’
[08:26:19.329] Expression:
[08:26:19.329] {
[08:26:19.329]     do.call(function(...) {
[08:26:19.329]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.329]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.329]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.329]             on.exit(options(oopts), add = TRUE)
[08:26:19.329]         }
[08:26:19.329]         {
[08:26:19.329]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.329]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.329]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.329]             })
[08:26:19.329]         }
[08:26:19.329]     }, args = future.call.arguments)
[08:26:19.329] }
[08:26:19.329] Lazy evaluation: FALSE
[08:26:19.329] Asynchronous evaluation: FALSE
[08:26:19.329] Local evaluation: TRUE
[08:26:19.329] Environment: R_GlobalEnv
[08:26:19.329] Capture standard output: TRUE
[08:26:19.329] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:19.329] Globals: 11 objects totaling 13.46 KiB (function ‘...future.FUN’ of 4.74 KiB, function ‘x_FUN’ of 311 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:19.329] Packages: 2 packages (‘stats’, ‘future.apply’)
[08:26:19.329] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:19.329] Resolved: TRUE
[08:26:19.329] Value: 413 bytes of class ‘list’
[08:26:19.329] Early signaling: FALSE
[08:26:19.329] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:19.329] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.330] Chunk #1 of 1 ... DONE
[08:26:19.330] Launching 1 futures (chunks) ... DONE
[08:26:19.330] Resolving 1 futures (chunks) ...
[08:26:19.330] resolve() on list ...
[08:26:19.330]  recursive: 0
[08:26:19.330]  length: 1
[08:26:19.330] 
[08:26:19.330] resolved() for ‘SequentialFuture’ ...
[08:26:19.330] - state: ‘finished’
[08:26:19.330] - run: TRUE
[08:26:19.330] - result: ‘FutureResult’
[08:26:19.331] resolved() for ‘SequentialFuture’ ... done
[08:26:19.331] Future #1
[08:26:19.331] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:19.331] - nx: 1
[08:26:19.331] - relay: TRUE
[08:26:19.331] - stdout: TRUE
[08:26:19.331] - signal: TRUE
[08:26:19.331] - resignal: FALSE
[08:26:19.331] - force: TRUE
[08:26:19.331] - relayed: [n=1] FALSE
[08:26:19.331] - queued futures: [n=1] FALSE
[08:26:19.332]  - until=1
[08:26:19.332]  - relaying element #1
[08:26:19.332] - relayed: [n=1] TRUE
[08:26:19.332] - queued futures: [n=1] TRUE
[08:26:19.332] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:19.332]  length: 0 (resolved future 1)
[08:26:19.332] Relaying remaining futures
[08:26:19.332] signalConditionsASAP(NULL, pos=0) ...
[08:26:19.332] - nx: 1
[08:26:19.332] - relay: TRUE
[08:26:19.332] - stdout: TRUE
[08:26:19.333] - signal: TRUE
[08:26:19.333] - resignal: FALSE
[08:26:19.333] - force: TRUE
[08:26:19.333] - relayed: [n=1] TRUE
[08:26:19.333] - queued futures: [n=1] TRUE
 - flush all
[08:26:19.333] - relayed: [n=1] TRUE
[08:26:19.333] - queued futures: [n=1] TRUE
[08:26:19.333] signalConditionsASAP(NULL, pos=0) ... done
[08:26:19.333] resolve() on list ... DONE
[08:26:19.333]  - Number of value chunks collected: 1
[08:26:19.333] Resolving 1 futures (chunks) ... DONE
[08:26:19.334] Reducing values from 1 chunks ...
[08:26:19.334]  - Number of values collected after concatenation: 3
[08:26:19.334]  - Number of values expected: 3
[08:26:19.334] Reducing values from 1 chunks ... DONE
[08:26:19.334] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[08:26:19.336] future_lapply() ...
[08:26:19.341] Number of chunks: 1
[08:26:19.341] getGlobalsAndPackagesXApply() ...
[08:26:19.341]  - future.globals: TRUE
[08:26:19.341] getGlobalsAndPackages() ...
[08:26:19.341] Searching for globals...
[08:26:19.346] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[08:26:19.346] Searching for globals ... DONE
[08:26:19.346] Resolving globals: FALSE
[08:26:19.347] The total size of the 1 globals is 4.67 KiB (4777 bytes)
[08:26:19.347] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.67 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.67 KiB of class ‘function’)
[08:26:19.347] - globals: [1] ‘FUN’
[08:26:19.348] - packages: [1] ‘stats’
[08:26:19.348] getGlobalsAndPackages() ... DONE
[08:26:19.348]  - globals found/used: [n=1] ‘FUN’
[08:26:19.348]  - needed namespaces: [n=1] ‘stats’
[08:26:19.348] Finding globals ... DONE
[08:26:19.348]  - use_args: TRUE
[08:26:19.348]  - Getting '...' globals ...
[08:26:19.348] resolve() on list ...
[08:26:19.349]  recursive: 0
[08:26:19.349]  length: 1
[08:26:19.349]  elements: ‘...’
[08:26:19.349]  length: 0 (resolved future 1)
[08:26:19.349] resolve() on list ... DONE
[08:26:19.349]    - '...' content: [n=0] 
[08:26:19.349] List of 1
[08:26:19.349]  $ ...: list()
[08:26:19.349]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.349]  - attr(*, "where")=List of 1
[08:26:19.349]   ..$ ...:<environment: 0x562ca7f16280> 
[08:26:19.349]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.349]  - attr(*, "resolved")= logi TRUE
[08:26:19.349]  - attr(*, "total_size")= num NA
[08:26:19.351]  - Getting '...' globals ... DONE
[08:26:19.352] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:26:19.352] List of 2
[08:26:19.352]  $ ...future.FUN:function (x, na.rm = TRUE)  
[08:26:19.352]  $ ...          : list()
[08:26:19.352]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.352]  - attr(*, "where")=List of 2
[08:26:19.352]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:19.352]   ..$ ...          :<environment: 0x562ca7f16280> 
[08:26:19.352]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.352]  - attr(*, "resolved")= logi FALSE
[08:26:19.352]  - attr(*, "total_size")= num 18895
[08:26:19.354] Packages to be attached in all futures: [n=1] ‘stats’
[08:26:19.354] getGlobalsAndPackagesXApply() ... DONE
[08:26:19.355] Number of futures (= number of chunks): 1
[08:26:19.355] Launching 1 futures (chunks) ...
[08:26:19.355] Chunk #1 of 1 ...
[08:26:19.355]  - Finding globals in 'X' for chunk #1 ...
[08:26:19.355] getGlobalsAndPackages() ...
[08:26:19.355] Searching for globals...
[08:26:19.355] 
[08:26:19.355] Searching for globals ... DONE
[08:26:19.356] - globals: [0] <none>
[08:26:19.356] getGlobalsAndPackages() ... DONE
[08:26:19.356]    + additional globals found: [n=0] 
[08:26:19.356]    + additional namespaces needed: [n=0] 
[08:26:19.356]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:19.356]  - seeds: <none>
[08:26:19.356]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.356] getGlobalsAndPackages() ...
[08:26:19.356] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.356] Resolving globals: FALSE
[08:26:19.356] Tweak future expression to call with '...' arguments ...
[08:26:19.357] {
[08:26:19.357]     do.call(function(...) {
[08:26:19.357]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.357]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.357]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.357]             on.exit(options(oopts), add = TRUE)
[08:26:19.357]         }
[08:26:19.357]         {
[08:26:19.357]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.357]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.357]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.357]             })
[08:26:19.357]         }
[08:26:19.357]     }, args = future.call.arguments)
[08:26:19.357] }
[08:26:19.357] Tweak future expression to call with '...' arguments ... DONE
[08:26:19.357] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.357] - packages: [1] ‘stats’
[08:26:19.357] getGlobalsAndPackages() ... DONE
[08:26:19.358] run() for ‘Future’ ...
[08:26:19.358] - state: ‘created’
[08:26:19.358] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:26:19.358] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.358] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:19.358]   - Field: ‘label’
[08:26:19.358]   - Field: ‘local’
[08:26:19.359]   - Field: ‘owner’
[08:26:19.359]   - Field: ‘envir’
[08:26:19.359]   - Field: ‘packages’
[08:26:19.359]   - Field: ‘gc’
[08:26:19.359]   - Field: ‘conditions’
[08:26:19.359]   - Field: ‘expr’
[08:26:19.359]   - Field: ‘uuid’
[08:26:19.359]   - Field: ‘seed’
[08:26:19.359]   - Field: ‘version’
[08:26:19.359]   - Field: ‘result’
[08:26:19.359]   - Field: ‘asynchronous’
[08:26:19.359]   - Field: ‘calls’
[08:26:19.360]   - Field: ‘globals’
[08:26:19.360]   - Field: ‘stdout’
[08:26:19.360]   - Field: ‘earlySignal’
[08:26:19.361]   - Field: ‘lazy’
[08:26:19.361]   - Field: ‘state’
[08:26:19.361] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:19.362] - Launch lazy future ...
[08:26:19.362] Packages needed by the future expression (n = 1): ‘stats’
[08:26:19.362] Packages needed by future strategies (n = 0): <none>
[08:26:19.362] {
[08:26:19.362]     {
[08:26:19.362]         {
[08:26:19.362]             ...future.startTime <- base::Sys.time()
[08:26:19.362]             {
[08:26:19.362]                 {
[08:26:19.362]                   {
[08:26:19.362]                     {
[08:26:19.362]                       base::local({
[08:26:19.362]                         has_future <- base::requireNamespace("future", 
[08:26:19.362]                           quietly = TRUE)
[08:26:19.362]                         if (has_future) {
[08:26:19.362]                           ns <- base::getNamespace("future")
[08:26:19.362]                           version <- ns[[".package"]][["version"]]
[08:26:19.362]                           if (is.null(version)) 
[08:26:19.362]                             version <- utils::packageVersion("future")
[08:26:19.362]                         }
[08:26:19.362]                         else {
[08:26:19.362]                           version <- NULL
[08:26:19.362]                         }
[08:26:19.362]                         if (!has_future || version < "1.8.0") {
[08:26:19.362]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:19.362]                             "", base::R.version$version.string), 
[08:26:19.362]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:19.362]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:19.362]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:19.362]                               "release", "version")], collapse = " "), 
[08:26:19.362]                             hostname = base::Sys.info()[["nodename"]])
[08:26:19.362]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:19.362]                             info)
[08:26:19.362]                           info <- base::paste(info, collapse = "; ")
[08:26:19.362]                           if (!has_future) {
[08:26:19.362]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:19.362]                               info)
[08:26:19.362]                           }
[08:26:19.362]                           else {
[08:26:19.362]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:19.362]                               info, version)
[08:26:19.362]                           }
[08:26:19.362]                           base::stop(msg)
[08:26:19.362]                         }
[08:26:19.362]                       })
[08:26:19.362]                     }
[08:26:19.362]                     base::local({
[08:26:19.362]                       for (pkg in "stats") {
[08:26:19.362]                         base::loadNamespace(pkg)
[08:26:19.362]                         base::library(pkg, character.only = TRUE)
[08:26:19.362]                       }
[08:26:19.362]                     })
[08:26:19.362]                   }
[08:26:19.362]                   ...future.strategy.old <- future::plan("list")
[08:26:19.362]                   options(future.plan = NULL)
[08:26:19.362]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.362]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:19.362]                 }
[08:26:19.362]                 ...future.workdir <- getwd()
[08:26:19.362]             }
[08:26:19.362]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:19.362]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:19.362]         }
[08:26:19.362]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:19.362]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:19.362]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:19.362]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:19.362]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:19.362]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:19.362]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:19.362]             base::names(...future.oldOptions))
[08:26:19.362]     }
[08:26:19.362]     if (FALSE) {
[08:26:19.362]     }
[08:26:19.362]     else {
[08:26:19.362]         if (TRUE) {
[08:26:19.362]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:19.362]                 open = "w")
[08:26:19.362]         }
[08:26:19.362]         else {
[08:26:19.362]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:19.362]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:19.362]         }
[08:26:19.362]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:19.362]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:19.362]             base::sink(type = "output", split = FALSE)
[08:26:19.362]             base::close(...future.stdout)
[08:26:19.362]         }, add = TRUE)
[08:26:19.362]     }
[08:26:19.362]     ...future.frame <- base::sys.nframe()
[08:26:19.362]     ...future.conditions <- base::list()
[08:26:19.362]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:19.362]     if (FALSE) {
[08:26:19.362]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:19.362]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:19.362]     }
[08:26:19.362]     ...future.result <- base::tryCatch({
[08:26:19.362]         base::withCallingHandlers({
[08:26:19.362]             ...future.value <- base::withVisible(base::local({
[08:26:19.362]                 do.call(function(...) {
[08:26:19.362]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.362]                   if (!identical(...future.globals.maxSize.org, 
[08:26:19.362]                     ...future.globals.maxSize)) {
[08:26:19.362]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.362]                     on.exit(options(oopts), add = TRUE)
[08:26:19.362]                   }
[08:26:19.362]                   {
[08:26:19.362]                     lapply(seq_along(...future.elements_ii), 
[08:26:19.362]                       FUN = function(jj) {
[08:26:19.362]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.362]                         ...future.FUN(...future.X_jj, ...)
[08:26:19.362]                       })
[08:26:19.362]                   }
[08:26:19.362]                 }, args = future.call.arguments)
[08:26:19.362]             }))
[08:26:19.362]             future::FutureResult(value = ...future.value$value, 
[08:26:19.362]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.362]                   ...future.rng), globalenv = if (FALSE) 
[08:26:19.362]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:19.362]                     ...future.globalenv.names))
[08:26:19.362]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:19.362]         }, condition = base::local({
[08:26:19.362]             c <- base::c
[08:26:19.362]             inherits <- base::inherits
[08:26:19.362]             invokeRestart <- base::invokeRestart
[08:26:19.362]             length <- base::length
[08:26:19.362]             list <- base::list
[08:26:19.362]             seq.int <- base::seq.int
[08:26:19.362]             signalCondition <- base::signalCondition
[08:26:19.362]             sys.calls <- base::sys.calls
[08:26:19.362]             `[[` <- base::`[[`
[08:26:19.362]             `+` <- base::`+`
[08:26:19.362]             `<<-` <- base::`<<-`
[08:26:19.362]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:19.362]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:19.362]                   3L)]
[08:26:19.362]             }
[08:26:19.362]             function(cond) {
[08:26:19.362]                 is_error <- inherits(cond, "error")
[08:26:19.362]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:19.362]                   NULL)
[08:26:19.362]                 if (is_error) {
[08:26:19.362]                   sessionInformation <- function() {
[08:26:19.362]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:19.362]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:19.362]                       search = base::search(), system = base::Sys.info())
[08:26:19.362]                   }
[08:26:19.362]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.362]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:19.362]                     cond$call), session = sessionInformation(), 
[08:26:19.362]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:19.362]                   signalCondition(cond)
[08:26:19.362]                 }
[08:26:19.362]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:19.362]                 "immediateCondition"))) {
[08:26:19.362]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:19.362]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.362]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:19.362]                   if (TRUE && !signal) {
[08:26:19.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.362]                     {
[08:26:19.362]                       inherits <- base::inherits
[08:26:19.362]                       invokeRestart <- base::invokeRestart
[08:26:19.362]                       is.null <- base::is.null
[08:26:19.362]                       muffled <- FALSE
[08:26:19.362]                       if (inherits(cond, "message")) {
[08:26:19.362]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.362]                         if (muffled) 
[08:26:19.362]                           invokeRestart("muffleMessage")
[08:26:19.362]                       }
[08:26:19.362]                       else if (inherits(cond, "warning")) {
[08:26:19.362]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.362]                         if (muffled) 
[08:26:19.362]                           invokeRestart("muffleWarning")
[08:26:19.362]                       }
[08:26:19.362]                       else if (inherits(cond, "condition")) {
[08:26:19.362]                         if (!is.null(pattern)) {
[08:26:19.362]                           computeRestarts <- base::computeRestarts
[08:26:19.362]                           grepl <- base::grepl
[08:26:19.362]                           restarts <- computeRestarts(cond)
[08:26:19.362]                           for (restart in restarts) {
[08:26:19.362]                             name <- restart$name
[08:26:19.362]                             if (is.null(name)) 
[08:26:19.362]                               next
[08:26:19.362]                             if (!grepl(pattern, name)) 
[08:26:19.362]                               next
[08:26:19.362]                             invokeRestart(restart)
[08:26:19.362]                             muffled <- TRUE
[08:26:19.362]                             break
[08:26:19.362]                           }
[08:26:19.362]                         }
[08:26:19.362]                       }
[08:26:19.362]                       invisible(muffled)
[08:26:19.362]                     }
[08:26:19.362]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.362]                   }
[08:26:19.362]                 }
[08:26:19.362]                 else {
[08:26:19.362]                   if (TRUE) {
[08:26:19.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.362]                     {
[08:26:19.362]                       inherits <- base::inherits
[08:26:19.362]                       invokeRestart <- base::invokeRestart
[08:26:19.362]                       is.null <- base::is.null
[08:26:19.362]                       muffled <- FALSE
[08:26:19.362]                       if (inherits(cond, "message")) {
[08:26:19.362]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.362]                         if (muffled) 
[08:26:19.362]                           invokeRestart("muffleMessage")
[08:26:19.362]                       }
[08:26:19.362]                       else if (inherits(cond, "warning")) {
[08:26:19.362]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.362]                         if (muffled) 
[08:26:19.362]                           invokeRestart("muffleWarning")
[08:26:19.362]                       }
[08:26:19.362]                       else if (inherits(cond, "condition")) {
[08:26:19.362]                         if (!is.null(pattern)) {
[08:26:19.362]                           computeRestarts <- base::computeRestarts
[08:26:19.362]                           grepl <- base::grepl
[08:26:19.362]                           restarts <- computeRestarts(cond)
[08:26:19.362]                           for (restart in restarts) {
[08:26:19.362]                             name <- restart$name
[08:26:19.362]                             if (is.null(name)) 
[08:26:19.362]                               next
[08:26:19.362]                             if (!grepl(pattern, name)) 
[08:26:19.362]                               next
[08:26:19.362]                             invokeRestart(restart)
[08:26:19.362]                             muffled <- TRUE
[08:26:19.362]                             break
[08:26:19.362]                           }
[08:26:19.362]                         }
[08:26:19.362]                       }
[08:26:19.362]                       invisible(muffled)
[08:26:19.362]                     }
[08:26:19.362]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.362]                   }
[08:26:19.362]                 }
[08:26:19.362]             }
[08:26:19.362]         }))
[08:26:19.362]     }, error = function(ex) {
[08:26:19.362]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:19.362]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.362]                 ...future.rng), started = ...future.startTime, 
[08:26:19.362]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:19.362]             version = "1.8"), class = "FutureResult")
[08:26:19.362]     }, finally = {
[08:26:19.362]         if (!identical(...future.workdir, getwd())) 
[08:26:19.362]             setwd(...future.workdir)
[08:26:19.362]         {
[08:26:19.362]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:19.362]                 ...future.oldOptions$nwarnings <- NULL
[08:26:19.362]             }
[08:26:19.362]             base::options(...future.oldOptions)
[08:26:19.362]             if (.Platform$OS.type == "windows") {
[08:26:19.362]                 old_names <- names(...future.oldEnvVars)
[08:26:19.362]                 envs <- base::Sys.getenv()
[08:26:19.362]                 names <- names(envs)
[08:26:19.362]                 common <- intersect(names, old_names)
[08:26:19.362]                 added <- setdiff(names, old_names)
[08:26:19.362]                 removed <- setdiff(old_names, names)
[08:26:19.362]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:19.362]                   envs[common]]
[08:26:19.362]                 NAMES <- toupper(changed)
[08:26:19.362]                 args <- list()
[08:26:19.362]                 for (kk in seq_along(NAMES)) {
[08:26:19.362]                   name <- changed[[kk]]
[08:26:19.362]                   NAME <- NAMES[[kk]]
[08:26:19.362]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.362]                     next
[08:26:19.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.362]                 }
[08:26:19.362]                 NAMES <- toupper(added)
[08:26:19.362]                 for (kk in seq_along(NAMES)) {
[08:26:19.362]                   name <- added[[kk]]
[08:26:19.362]                   NAME <- NAMES[[kk]]
[08:26:19.362]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.362]                     next
[08:26:19.362]                   args[[name]] <- ""
[08:26:19.362]                 }
[08:26:19.362]                 NAMES <- toupper(removed)
[08:26:19.362]                 for (kk in seq_along(NAMES)) {
[08:26:19.362]                   name <- removed[[kk]]
[08:26:19.362]                   NAME <- NAMES[[kk]]
[08:26:19.362]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.362]                     next
[08:26:19.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.362]                 }
[08:26:19.362]                 if (length(args) > 0) 
[08:26:19.362]                   base::do.call(base::Sys.setenv, args = args)
[08:26:19.362]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:19.362]             }
[08:26:19.362]             else {
[08:26:19.362]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:19.362]             }
[08:26:19.362]             {
[08:26:19.362]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:19.362]                   0L) {
[08:26:19.362]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:19.362]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:19.362]                   base::options(opts)
[08:26:19.362]                 }
[08:26:19.362]                 {
[08:26:19.362]                   {
[08:26:19.362]                     NULL
[08:26:19.362]                     RNGkind("Mersenne-Twister")
[08:26:19.362]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:19.362]                       inherits = FALSE)
[08:26:19.362]                   }
[08:26:19.362]                   options(future.plan = NULL)
[08:26:19.362]                   if (is.na(NA_character_)) 
[08:26:19.362]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.362]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:19.362]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:19.362]                     .init = FALSE)
[08:26:19.362]                 }
[08:26:19.362]             }
[08:26:19.362]         }
[08:26:19.362]     })
[08:26:19.362]     if (TRUE) {
[08:26:19.362]         base::sink(type = "output", split = FALSE)
[08:26:19.362]         if (TRUE) {
[08:26:19.362]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:19.362]         }
[08:26:19.362]         else {
[08:26:19.362]             ...future.result["stdout"] <- base::list(NULL)
[08:26:19.362]         }
[08:26:19.362]         base::close(...future.stdout)
[08:26:19.362]         ...future.stdout <- NULL
[08:26:19.362]     }
[08:26:19.362]     ...future.result$conditions <- ...future.conditions
[08:26:19.362]     ...future.result$finished <- base::Sys.time()
[08:26:19.362]     ...future.result
[08:26:19.362] }
[08:26:19.364] assign_globals() ...
[08:26:19.364] List of 5
[08:26:19.364]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[08:26:19.364]  $ future.call.arguments    : list()
[08:26:19.364]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.364]  $ ...future.elements_ii    :List of 7
[08:26:19.364]   ..$ : int [1:3] 1 2 3
[08:26:19.364]   ..$ : int [1:4] 1 2 3 4
[08:26:19.364]   ..$ : int [1:5] 1 2 3 4 5
[08:26:19.364]   ..$ : int [1:6] 1 2 3 4 5 6
[08:26:19.364]   ..$ : int [1:7] 1 2 3 4 5 6 7
[08:26:19.364]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[08:26:19.364]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[08:26:19.364]  $ ...future.seeds_ii       : NULL
[08:26:19.364]  $ ...future.globals.maxSize: NULL
[08:26:19.364]  - attr(*, "where")=List of 5
[08:26:19.364]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:19.364]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:19.364]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:19.364]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:19.364]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:19.364]  - attr(*, "resolved")= logi FALSE
[08:26:19.364]  - attr(*, "total_size")= num 18895
[08:26:19.364]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.364]  - attr(*, "already-done")= logi TRUE
[08:26:19.371] - copied ‘...future.FUN’ to environment
[08:26:19.371] - copied ‘future.call.arguments’ to environment
[08:26:19.371] - copied ‘...future.elements_ii’ to environment
[08:26:19.371] - copied ‘...future.seeds_ii’ to environment
[08:26:19.371] - copied ‘...future.globals.maxSize’ to environment
[08:26:19.371] assign_globals() ... done
[08:26:19.372] plan(): Setting new future strategy stack:
[08:26:19.372] List of future strategies:
[08:26:19.372] 1. sequential:
[08:26:19.372]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.372]    - tweaked: FALSE
[08:26:19.372]    - call: NULL
[08:26:19.372] plan(): nbrOfWorkers() = 1
[08:26:19.373] plan(): Setting new future strategy stack:
[08:26:19.373] List of future strategies:
[08:26:19.373] 1. sequential:
[08:26:19.373]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.373]    - tweaked: FALSE
[08:26:19.373]    - call: plan(strategy)
[08:26:19.374] plan(): nbrOfWorkers() = 1
[08:26:19.374] SequentialFuture started (and completed)
[08:26:19.374] - Launch lazy future ... done
[08:26:19.374] run() for ‘SequentialFuture’ ... done
[08:26:19.374] Created future:
[08:26:19.374] SequentialFuture:
[08:26:19.374] Label: ‘future_sapply-1’
[08:26:19.374] Expression:
[08:26:19.374] {
[08:26:19.374]     do.call(function(...) {
[08:26:19.374]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.374]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.374]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.374]             on.exit(options(oopts), add = TRUE)
[08:26:19.374]         }
[08:26:19.374]         {
[08:26:19.374]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.374]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.374]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.374]             })
[08:26:19.374]         }
[08:26:19.374]     }, args = future.call.arguments)
[08:26:19.374] }
[08:26:19.374] Lazy evaluation: FALSE
[08:26:19.374] Asynchronous evaluation: FALSE
[08:26:19.374] Local evaluation: TRUE
[08:26:19.374] Environment: R_GlobalEnv
[08:26:19.374] Capture standard output: TRUE
[08:26:19.374] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:19.374] Globals: 5 objects totaling 5.40 KiB (function ‘...future.FUN’ of 4.67 KiB, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 597 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:19.374] Packages: 1 packages (‘stats’)
[08:26:19.374] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:19.374] Resolved: TRUE
[08:26:19.374] Value: 367 bytes of class ‘list’
[08:26:19.374] Early signaling: FALSE
[08:26:19.374] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:19.374] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.375] Chunk #1 of 1 ... DONE
[08:26:19.375] Launching 1 futures (chunks) ... DONE
[08:26:19.375] Resolving 1 futures (chunks) ...
[08:26:19.375] resolve() on list ...
[08:26:19.375]  recursive: 0
[08:26:19.375]  length: 1
[08:26:19.375] 
[08:26:19.376] resolved() for ‘SequentialFuture’ ...
[08:26:19.376] - state: ‘finished’
[08:26:19.376] - run: TRUE
[08:26:19.376] - result: ‘FutureResult’
[08:26:19.376] resolved() for ‘SequentialFuture’ ... done
[08:26:19.376] Future #1
[08:26:19.376] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:19.376] - nx: 1
[08:26:19.376] - relay: TRUE
[08:26:19.376] - stdout: TRUE
[08:26:19.377] - signal: TRUE
[08:26:19.377] - resignal: FALSE
[08:26:19.377] - force: TRUE
[08:26:19.377] - relayed: [n=1] FALSE
[08:26:19.377] - queued futures: [n=1] FALSE
[08:26:19.377]  - until=1
[08:26:19.377]  - relaying element #1
[08:26:19.377] - relayed: [n=1] TRUE
[08:26:19.377] - queued futures: [n=1] TRUE
[08:26:19.377] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:19.377]  length: 0 (resolved future 1)
[08:26:19.378] Relaying remaining futures
[08:26:19.378] signalConditionsASAP(NULL, pos=0) ...
[08:26:19.378] - nx: 1
[08:26:19.378] - relay: TRUE
[08:26:19.378] - stdout: TRUE
[08:26:19.378] - signal: TRUE
[08:26:19.378] - resignal: FALSE
[08:26:19.378] - force: TRUE
[08:26:19.378] - relayed: [n=1] TRUE
[08:26:19.378] - queued futures: [n=1] TRUE
 - flush all
[08:26:19.378] - relayed: [n=1] TRUE
[08:26:19.378] - queued futures: [n=1] TRUE
[08:26:19.379] signalConditionsASAP(NULL, pos=0) ... done
[08:26:19.379] resolve() on list ... DONE
[08:26:19.379]  - Number of value chunks collected: 1
[08:26:19.379] Resolving 1 futures (chunks) ... DONE
[08:26:19.379] Reducing values from 1 chunks ...
[08:26:19.379]  - Number of values collected after concatenation: 7
[08:26:19.379]  - Number of values expected: 7
[08:26:19.379] Reducing values from 1 chunks ... DONE
[08:26:19.379] future_lapply() ... DONE
[08:26:19.380] future_lapply() ...
[08:26:19.381] Number of chunks: 1
[08:26:19.381] getGlobalsAndPackagesXApply() ...
[08:26:19.382]  - future.globals: TRUE
[08:26:19.382] getGlobalsAndPackages() ...
[08:26:19.382] Searching for globals...
[08:26:19.390] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[08:26:19.391] Searching for globals ... DONE
[08:26:19.391] Resolving globals: FALSE
[08:26:19.392] The total size of the 7 globals is 26.71 KiB (27354 bytes)
[08:26:19.392] The total size of the 7 globals exported for future expression (‘FUN()’) is 26.71 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (14.07 KiB of class ‘function’), ‘x_FUN’ (4.67 KiB of class ‘function’) and ‘stop_if_not’ (4.51 KiB of class ‘function’)
[08:26:19.392] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.392] - packages: [2] ‘stats’, ‘future.apply’
[08:26:19.393] getGlobalsAndPackages() ... DONE
[08:26:19.393]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.393]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[08:26:19.393] Finding globals ... DONE
[08:26:19.393]  - use_args: TRUE
[08:26:19.393]  - Getting '...' globals ...
[08:26:19.393] resolve() on list ...
[08:26:19.393]  recursive: 0
[08:26:19.394]  length: 1
[08:26:19.394]  elements: ‘...’
[08:26:19.394]  length: 0 (resolved future 1)
[08:26:19.394] resolve() on list ... DONE
[08:26:19.394]    - '...' content: [n=0] 
[08:26:19.394] List of 1
[08:26:19.394]  $ ...: list()
[08:26:19.394]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.394]  - attr(*, "where")=List of 1
[08:26:19.394]   ..$ ...:<environment: 0x562ca7cb51f0> 
[08:26:19.394]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.394]  - attr(*, "resolved")= logi TRUE
[08:26:19.394]  - attr(*, "total_size")= num NA
[08:26:19.397]  - Getting '...' globals ... DONE
[08:26:19.397] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:19.397] List of 8
[08:26:19.397]  $ ...future.FUN:function (x, ...)  
[08:26:19.397]  $ x_FUN        :function (x, na.rm = TRUE)  
[08:26:19.397]  $ times        : int 5
[08:26:19.397]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.397]  $ stop_if_not  :function (...)  
[08:26:19.397]  $ dim          : NULL
[08:26:19.397]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:19.397]  $ ...          : list()
[08:26:19.397]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.397]  - attr(*, "where")=List of 8
[08:26:19.397]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:19.397]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:19.397]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:19.397]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:19.397]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:19.397]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:19.397]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:19.397]   ..$ ...          :<environment: 0x562ca7cb51f0> 
[08:26:19.397]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.397]  - attr(*, "resolved")= logi FALSE
[08:26:19.397]  - attr(*, "total_size")= num 48005
[08:26:19.402] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[08:26:19.402] getGlobalsAndPackagesXApply() ... DONE
[08:26:19.403] Number of futures (= number of chunks): 1
[08:26:19.403] Launching 1 futures (chunks) ...
[08:26:19.403] Chunk #1 of 1 ...
[08:26:19.403]  - Finding globals in 'X' for chunk #1 ...
[08:26:19.403] getGlobalsAndPackages() ...
[08:26:19.403] Searching for globals...
[08:26:19.403] 
[08:26:19.403] Searching for globals ... DONE
[08:26:19.404] - globals: [0] <none>
[08:26:19.404] getGlobalsAndPackages() ... DONE
[08:26:19.404]    + additional globals found: [n=0] 
[08:26:19.404]    + additional namespaces needed: [n=0] 
[08:26:19.404]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:19.404]  - seeds: <none>
[08:26:19.404]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.404] getGlobalsAndPackages() ...
[08:26:19.404] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.404] Resolving globals: FALSE
[08:26:19.405] Tweak future expression to call with '...' arguments ...
[08:26:19.405] {
[08:26:19.405]     do.call(function(...) {
[08:26:19.405]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.405]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.405]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.405]             on.exit(options(oopts), add = TRUE)
[08:26:19.405]         }
[08:26:19.405]         {
[08:26:19.405]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.405]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.405]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.405]             })
[08:26:19.405]         }
[08:26:19.405]     }, args = future.call.arguments)
[08:26:19.405] }
[08:26:19.405] Tweak future expression to call with '...' arguments ... DONE
[08:26:19.405] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.406] - packages: [2] ‘stats’, ‘future.apply’
[08:26:19.406] getGlobalsAndPackages() ... DONE
[08:26:19.406] run() for ‘Future’ ...
[08:26:19.406] - state: ‘created’
[08:26:19.406] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:26:19.408] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.408] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:19.408]   - Field: ‘label’
[08:26:19.408]   - Field: ‘local’
[08:26:19.408]   - Field: ‘owner’
[08:26:19.409]   - Field: ‘envir’
[08:26:19.409]   - Field: ‘packages’
[08:26:19.409]   - Field: ‘gc’
[08:26:19.409]   - Field: ‘conditions’
[08:26:19.409]   - Field: ‘expr’
[08:26:19.409]   - Field: ‘uuid’
[08:26:19.409]   - Field: ‘seed’
[08:26:19.409]   - Field: ‘version’
[08:26:19.409]   - Field: ‘result’
[08:26:19.410]   - Field: ‘asynchronous’
[08:26:19.410]   - Field: ‘calls’
[08:26:19.410]   - Field: ‘globals’
[08:26:19.410]   - Field: ‘stdout’
[08:26:19.410]   - Field: ‘earlySignal’
[08:26:19.410]   - Field: ‘lazy’
[08:26:19.410]   - Field: ‘state’
[08:26:19.410] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:19.410] - Launch lazy future ...
[08:26:19.410] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[08:26:19.411] Packages needed by future strategies (n = 0): <none>
[08:26:19.411] {
[08:26:19.411]     {
[08:26:19.411]         {
[08:26:19.411]             ...future.startTime <- base::Sys.time()
[08:26:19.411]             {
[08:26:19.411]                 {
[08:26:19.411]                   {
[08:26:19.411]                     {
[08:26:19.411]                       base::local({
[08:26:19.411]                         has_future <- base::requireNamespace("future", 
[08:26:19.411]                           quietly = TRUE)
[08:26:19.411]                         if (has_future) {
[08:26:19.411]                           ns <- base::getNamespace("future")
[08:26:19.411]                           version <- ns[[".package"]][["version"]]
[08:26:19.411]                           if (is.null(version)) 
[08:26:19.411]                             version <- utils::packageVersion("future")
[08:26:19.411]                         }
[08:26:19.411]                         else {
[08:26:19.411]                           version <- NULL
[08:26:19.411]                         }
[08:26:19.411]                         if (!has_future || version < "1.8.0") {
[08:26:19.411]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:19.411]                             "", base::R.version$version.string), 
[08:26:19.411]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:19.411]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:19.411]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:19.411]                               "release", "version")], collapse = " "), 
[08:26:19.411]                             hostname = base::Sys.info()[["nodename"]])
[08:26:19.411]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:19.411]                             info)
[08:26:19.411]                           info <- base::paste(info, collapse = "; ")
[08:26:19.411]                           if (!has_future) {
[08:26:19.411]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:19.411]                               info)
[08:26:19.411]                           }
[08:26:19.411]                           else {
[08:26:19.411]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:19.411]                               info, version)
[08:26:19.411]                           }
[08:26:19.411]                           base::stop(msg)
[08:26:19.411]                         }
[08:26:19.411]                       })
[08:26:19.411]                     }
[08:26:19.411]                     base::local({
[08:26:19.411]                       for (pkg in c("stats", "future.apply")) {
[08:26:19.411]                         base::loadNamespace(pkg)
[08:26:19.411]                         base::library(pkg, character.only = TRUE)
[08:26:19.411]                       }
[08:26:19.411]                     })
[08:26:19.411]                   }
[08:26:19.411]                   ...future.strategy.old <- future::plan("list")
[08:26:19.411]                   options(future.plan = NULL)
[08:26:19.411]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.411]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:19.411]                 }
[08:26:19.411]                 ...future.workdir <- getwd()
[08:26:19.411]             }
[08:26:19.411]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:19.411]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:19.411]         }
[08:26:19.411]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:19.411]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:19.411]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:19.411]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:19.411]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:19.411]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:19.411]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:19.411]             base::names(...future.oldOptions))
[08:26:19.411]     }
[08:26:19.411]     if (FALSE) {
[08:26:19.411]     }
[08:26:19.411]     else {
[08:26:19.411]         if (TRUE) {
[08:26:19.411]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:19.411]                 open = "w")
[08:26:19.411]         }
[08:26:19.411]         else {
[08:26:19.411]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:19.411]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:19.411]         }
[08:26:19.411]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:19.411]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:19.411]             base::sink(type = "output", split = FALSE)
[08:26:19.411]             base::close(...future.stdout)
[08:26:19.411]         }, add = TRUE)
[08:26:19.411]     }
[08:26:19.411]     ...future.frame <- base::sys.nframe()
[08:26:19.411]     ...future.conditions <- base::list()
[08:26:19.411]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:19.411]     if (FALSE) {
[08:26:19.411]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:19.411]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:19.411]     }
[08:26:19.411]     ...future.result <- base::tryCatch({
[08:26:19.411]         base::withCallingHandlers({
[08:26:19.411]             ...future.value <- base::withVisible(base::local({
[08:26:19.411]                 do.call(function(...) {
[08:26:19.411]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.411]                   if (!identical(...future.globals.maxSize.org, 
[08:26:19.411]                     ...future.globals.maxSize)) {
[08:26:19.411]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.411]                     on.exit(options(oopts), add = TRUE)
[08:26:19.411]                   }
[08:26:19.411]                   {
[08:26:19.411]                     lapply(seq_along(...future.elements_ii), 
[08:26:19.411]                       FUN = function(jj) {
[08:26:19.411]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.411]                         ...future.FUN(...future.X_jj, ...)
[08:26:19.411]                       })
[08:26:19.411]                   }
[08:26:19.411]                 }, args = future.call.arguments)
[08:26:19.411]             }))
[08:26:19.411]             future::FutureResult(value = ...future.value$value, 
[08:26:19.411]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.411]                   ...future.rng), globalenv = if (FALSE) 
[08:26:19.411]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:19.411]                     ...future.globalenv.names))
[08:26:19.411]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:19.411]         }, condition = base::local({
[08:26:19.411]             c <- base::c
[08:26:19.411]             inherits <- base::inherits
[08:26:19.411]             invokeRestart <- base::invokeRestart
[08:26:19.411]             length <- base::length
[08:26:19.411]             list <- base::list
[08:26:19.411]             seq.int <- base::seq.int
[08:26:19.411]             signalCondition <- base::signalCondition
[08:26:19.411]             sys.calls <- base::sys.calls
[08:26:19.411]             `[[` <- base::`[[`
[08:26:19.411]             `+` <- base::`+`
[08:26:19.411]             `<<-` <- base::`<<-`
[08:26:19.411]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:19.411]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:19.411]                   3L)]
[08:26:19.411]             }
[08:26:19.411]             function(cond) {
[08:26:19.411]                 is_error <- inherits(cond, "error")
[08:26:19.411]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:19.411]                   NULL)
[08:26:19.411]                 if (is_error) {
[08:26:19.411]                   sessionInformation <- function() {
[08:26:19.411]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:19.411]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:19.411]                       search = base::search(), system = base::Sys.info())
[08:26:19.411]                   }
[08:26:19.411]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.411]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:19.411]                     cond$call), session = sessionInformation(), 
[08:26:19.411]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:19.411]                   signalCondition(cond)
[08:26:19.411]                 }
[08:26:19.411]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:19.411]                 "immediateCondition"))) {
[08:26:19.411]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:19.411]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.411]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:19.411]                   if (TRUE && !signal) {
[08:26:19.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.411]                     {
[08:26:19.411]                       inherits <- base::inherits
[08:26:19.411]                       invokeRestart <- base::invokeRestart
[08:26:19.411]                       is.null <- base::is.null
[08:26:19.411]                       muffled <- FALSE
[08:26:19.411]                       if (inherits(cond, "message")) {
[08:26:19.411]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.411]                         if (muffled) 
[08:26:19.411]                           invokeRestart("muffleMessage")
[08:26:19.411]                       }
[08:26:19.411]                       else if (inherits(cond, "warning")) {
[08:26:19.411]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.411]                         if (muffled) 
[08:26:19.411]                           invokeRestart("muffleWarning")
[08:26:19.411]                       }
[08:26:19.411]                       else if (inherits(cond, "condition")) {
[08:26:19.411]                         if (!is.null(pattern)) {
[08:26:19.411]                           computeRestarts <- base::computeRestarts
[08:26:19.411]                           grepl <- base::grepl
[08:26:19.411]                           restarts <- computeRestarts(cond)
[08:26:19.411]                           for (restart in restarts) {
[08:26:19.411]                             name <- restart$name
[08:26:19.411]                             if (is.null(name)) 
[08:26:19.411]                               next
[08:26:19.411]                             if (!grepl(pattern, name)) 
[08:26:19.411]                               next
[08:26:19.411]                             invokeRestart(restart)
[08:26:19.411]                             muffled <- TRUE
[08:26:19.411]                             break
[08:26:19.411]                           }
[08:26:19.411]                         }
[08:26:19.411]                       }
[08:26:19.411]                       invisible(muffled)
[08:26:19.411]                     }
[08:26:19.411]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.411]                   }
[08:26:19.411]                 }
[08:26:19.411]                 else {
[08:26:19.411]                   if (TRUE) {
[08:26:19.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.411]                     {
[08:26:19.411]                       inherits <- base::inherits
[08:26:19.411]                       invokeRestart <- base::invokeRestart
[08:26:19.411]                       is.null <- base::is.null
[08:26:19.411]                       muffled <- FALSE
[08:26:19.411]                       if (inherits(cond, "message")) {
[08:26:19.411]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.411]                         if (muffled) 
[08:26:19.411]                           invokeRestart("muffleMessage")
[08:26:19.411]                       }
[08:26:19.411]                       else if (inherits(cond, "warning")) {
[08:26:19.411]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.411]                         if (muffled) 
[08:26:19.411]                           invokeRestart("muffleWarning")
[08:26:19.411]                       }
[08:26:19.411]                       else if (inherits(cond, "condition")) {
[08:26:19.411]                         if (!is.null(pattern)) {
[08:26:19.411]                           computeRestarts <- base::computeRestarts
[08:26:19.411]                           grepl <- base::grepl
[08:26:19.411]                           restarts <- computeRestarts(cond)
[08:26:19.411]                           for (restart in restarts) {
[08:26:19.411]                             name <- restart$name
[08:26:19.411]                             if (is.null(name)) 
[08:26:19.411]                               next
[08:26:19.411]                             if (!grepl(pattern, name)) 
[08:26:19.411]                               next
[08:26:19.411]                             invokeRestart(restart)
[08:26:19.411]                             muffled <- TRUE
[08:26:19.411]                             break
[08:26:19.411]                           }
[08:26:19.411]                         }
[08:26:19.411]                       }
[08:26:19.411]                       invisible(muffled)
[08:26:19.411]                     }
[08:26:19.411]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.411]                   }
[08:26:19.411]                 }
[08:26:19.411]             }
[08:26:19.411]         }))
[08:26:19.411]     }, error = function(ex) {
[08:26:19.411]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:19.411]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.411]                 ...future.rng), started = ...future.startTime, 
[08:26:19.411]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:19.411]             version = "1.8"), class = "FutureResult")
[08:26:19.411]     }, finally = {
[08:26:19.411]         if (!identical(...future.workdir, getwd())) 
[08:26:19.411]             setwd(...future.workdir)
[08:26:19.411]         {
[08:26:19.411]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:19.411]                 ...future.oldOptions$nwarnings <- NULL
[08:26:19.411]             }
[08:26:19.411]             base::options(...future.oldOptions)
[08:26:19.411]             if (.Platform$OS.type == "windows") {
[08:26:19.411]                 old_names <- names(...future.oldEnvVars)
[08:26:19.411]                 envs <- base::Sys.getenv()
[08:26:19.411]                 names <- names(envs)
[08:26:19.411]                 common <- intersect(names, old_names)
[08:26:19.411]                 added <- setdiff(names, old_names)
[08:26:19.411]                 removed <- setdiff(old_names, names)
[08:26:19.411]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:19.411]                   envs[common]]
[08:26:19.411]                 NAMES <- toupper(changed)
[08:26:19.411]                 args <- list()
[08:26:19.411]                 for (kk in seq_along(NAMES)) {
[08:26:19.411]                   name <- changed[[kk]]
[08:26:19.411]                   NAME <- NAMES[[kk]]
[08:26:19.411]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.411]                     next
[08:26:19.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.411]                 }
[08:26:19.411]                 NAMES <- toupper(added)
[08:26:19.411]                 for (kk in seq_along(NAMES)) {
[08:26:19.411]                   name <- added[[kk]]
[08:26:19.411]                   NAME <- NAMES[[kk]]
[08:26:19.411]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.411]                     next
[08:26:19.411]                   args[[name]] <- ""
[08:26:19.411]                 }
[08:26:19.411]                 NAMES <- toupper(removed)
[08:26:19.411]                 for (kk in seq_along(NAMES)) {
[08:26:19.411]                   name <- removed[[kk]]
[08:26:19.411]                   NAME <- NAMES[[kk]]
[08:26:19.411]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.411]                     next
[08:26:19.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.411]                 }
[08:26:19.411]                 if (length(args) > 0) 
[08:26:19.411]                   base::do.call(base::Sys.setenv, args = args)
[08:26:19.411]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:19.411]             }
[08:26:19.411]             else {
[08:26:19.411]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:19.411]             }
[08:26:19.411]             {
[08:26:19.411]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:19.411]                   0L) {
[08:26:19.411]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:19.411]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:19.411]                   base::options(opts)
[08:26:19.411]                 }
[08:26:19.411]                 {
[08:26:19.411]                   {
[08:26:19.411]                     NULL
[08:26:19.411]                     RNGkind("Mersenne-Twister")
[08:26:19.411]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:19.411]                       inherits = FALSE)
[08:26:19.411]                   }
[08:26:19.411]                   options(future.plan = NULL)
[08:26:19.411]                   if (is.na(NA_character_)) 
[08:26:19.411]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.411]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:19.411]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:19.411]                     .init = FALSE)
[08:26:19.411]                 }
[08:26:19.411]             }
[08:26:19.411]         }
[08:26:19.411]     })
[08:26:19.411]     if (TRUE) {
[08:26:19.411]         base::sink(type = "output", split = FALSE)
[08:26:19.411]         if (TRUE) {
[08:26:19.411]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:19.411]         }
[08:26:19.411]         else {
[08:26:19.411]             ...future.result["stdout"] <- base::list(NULL)
[08:26:19.411]         }
[08:26:19.411]         base::close(...future.stdout)
[08:26:19.411]         ...future.stdout <- NULL
[08:26:19.411]     }
[08:26:19.411]     ...future.result$conditions <- ...future.conditions
[08:26:19.411]     ...future.result$finished <- base::Sys.time()
[08:26:19.411]     ...future.result
[08:26:19.411] }
[08:26:19.413] assign_globals() ...
[08:26:19.413] List of 11
[08:26:19.413]  $ ...future.FUN            :function (x, ...)  
[08:26:19.413]  $ x_FUN                    :function (x, na.rm = TRUE)  
[08:26:19.413]  $ times                    : int 5
[08:26:19.413]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.413]  $ stop_if_not              :function (...)  
[08:26:19.413]  $ dim                      : NULL
[08:26:19.413]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:19.413]  $ future.call.arguments    : list()
[08:26:19.413]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.413]  $ ...future.elements_ii    :List of 7
[08:26:19.413]   ..$ : int [1:3] 1 2 3
[08:26:19.413]   ..$ : int [1:4] 1 2 3 4
[08:26:19.413]   ..$ : int [1:5] 1 2 3 4 5
[08:26:19.413]   ..$ : int [1:6] 1 2 3 4 5 6
[08:26:19.413]   ..$ : int [1:7] 1 2 3 4 5 6 7
[08:26:19.413]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[08:26:19.413]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[08:26:19.413]  $ ...future.seeds_ii       : NULL
[08:26:19.413]  $ ...future.globals.maxSize: NULL
[08:26:19.413]  - attr(*, "where")=List of 11
[08:26:19.413]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:19.413]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:19.413]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:19.413]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:19.413]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:19.413]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:19.413]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:19.413]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:19.413]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:19.413]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:19.413]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:19.413]  - attr(*, "resolved")= logi FALSE
[08:26:19.413]  - attr(*, "total_size")= num 48005
[08:26:19.413]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.413]  - attr(*, "already-done")= logi TRUE
[08:26:19.422] - copied ‘...future.FUN’ to environment
[08:26:19.422] - copied ‘x_FUN’ to environment
[08:26:19.422] - copied ‘times’ to environment
[08:26:19.422] - copied ‘stopf’ to environment
[08:26:19.422] - copied ‘stop_if_not’ to environment
[08:26:19.422] - copied ‘dim’ to environment
[08:26:19.423] - copied ‘valid_types’ to environment
[08:26:19.423] - copied ‘future.call.arguments’ to environment
[08:26:19.423] - copied ‘...future.elements_ii’ to environment
[08:26:19.423] - copied ‘...future.seeds_ii’ to environment
[08:26:19.423] - copied ‘...future.globals.maxSize’ to environment
[08:26:19.423] assign_globals() ... done
[08:26:19.423] plan(): Setting new future strategy stack:
[08:26:19.424] List of future strategies:
[08:26:19.424] 1. sequential:
[08:26:19.424]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.424]    - tweaked: FALSE
[08:26:19.424]    - call: NULL
[08:26:19.424] plan(): nbrOfWorkers() = 1
[08:26:19.425] plan(): Setting new future strategy stack:
[08:26:19.425] List of future strategies:
[08:26:19.425] 1. sequential:
[08:26:19.425]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.425]    - tweaked: FALSE
[08:26:19.425]    - call: plan(strategy)
[08:26:19.425] plan(): nbrOfWorkers() = 1
[08:26:19.426] SequentialFuture started (and completed)
[08:26:19.426] - Launch lazy future ... done
[08:26:19.426] run() for ‘SequentialFuture’ ... done
[08:26:19.426] Created future:
[08:26:19.426] SequentialFuture:
[08:26:19.426] Label: ‘future_vapply-1’
[08:26:19.426] Expression:
[08:26:19.426] {
[08:26:19.426]     do.call(function(...) {
[08:26:19.426]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.426]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.426]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.426]             on.exit(options(oopts), add = TRUE)
[08:26:19.426]         }
[08:26:19.426]         {
[08:26:19.426]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.426]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.426]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.426]             })
[08:26:19.426]         }
[08:26:19.426]     }, args = future.call.arguments)
[08:26:19.426] }
[08:26:19.426] Lazy evaluation: FALSE
[08:26:19.426] Asynchronous evaluation: FALSE
[08:26:19.426] Local evaluation: TRUE
[08:26:19.426] Environment: R_GlobalEnv
[08:26:19.426] Capture standard output: TRUE
[08:26:19.426] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:19.426] Globals: 11 objects totaling 27.44 KiB (function ‘...future.FUN’ of 14.07 KiB, function ‘x_FUN’ of 4.67 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:19.426] Packages: 2 packages (‘stats’, ‘future.apply’)
[08:26:19.426] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:19.426] Resolved: TRUE
[08:26:19.426] Value: 367 bytes of class ‘list’
[08:26:19.426] Early signaling: FALSE
[08:26:19.426] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:19.426] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.427] Chunk #1 of 1 ... DONE
[08:26:19.427] Launching 1 futures (chunks) ... DONE
[08:26:19.427] Resolving 1 futures (chunks) ...
[08:26:19.427] resolve() on list ...
[08:26:19.427]  recursive: 0
[08:26:19.428]  length: 1
[08:26:19.428] 
[08:26:19.428] resolved() for ‘SequentialFuture’ ...
[08:26:19.428] - state: ‘finished’
[08:26:19.428] - run: TRUE
[08:26:19.428] - result: ‘FutureResult’
[08:26:19.428] resolved() for ‘SequentialFuture’ ... done
[08:26:19.428] Future #1
[08:26:19.428] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:19.428] - nx: 1
[08:26:19.429] - relay: TRUE
[08:26:19.429] - stdout: TRUE
[08:26:19.429] - signal: TRUE
[08:26:19.429] - resignal: FALSE
[08:26:19.429] - force: TRUE
[08:26:19.429] - relayed: [n=1] FALSE
[08:26:19.429] - queued futures: [n=1] FALSE
[08:26:19.429]  - until=1
[08:26:19.429]  - relaying element #1
[08:26:19.429] - relayed: [n=1] TRUE
[08:26:19.429] - queued futures: [n=1] TRUE
[08:26:19.430] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:19.430]  length: 0 (resolved future 1)
[08:26:19.430] Relaying remaining futures
[08:26:19.430] signalConditionsASAP(NULL, pos=0) ...
[08:26:19.430] - nx: 1
[08:26:19.430] - relay: TRUE
[08:26:19.430] - stdout: TRUE
[08:26:19.430] - signal: TRUE
[08:26:19.430] - resignal: FALSE
[08:26:19.430] - force: TRUE
[08:26:19.430] - relayed: [n=1] TRUE
[08:26:19.430] - queued futures: [n=1] TRUE
 - flush all
[08:26:19.432] - relayed: [n=1] TRUE
[08:26:19.432] - queued futures: [n=1] TRUE
[08:26:19.432] signalConditionsASAP(NULL, pos=0) ... done
[08:26:19.432] resolve() on list ... DONE
[08:26:19.433]  - Number of value chunks collected: 1
[08:26:19.433] Resolving 1 futures (chunks) ... DONE
[08:26:19.433] Reducing values from 1 chunks ...
[08:26:19.433]  - Number of values collected after concatenation: 7
[08:26:19.433]  - Number of values expected: 7
[08:26:19.433] Reducing values from 1 chunks ... DONE
[08:26:19.433] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[08:26:19.435] future_lapply() ...
[08:26:19.436] Number of chunks: 1
[08:26:19.436] getGlobalsAndPackagesXApply() ...
[08:26:19.436]  - future.globals: TRUE
[08:26:19.436] getGlobalsAndPackages() ...
[08:26:19.436] Searching for globals...
[08:26:19.437] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[08:26:19.438] Searching for globals ... DONE
[08:26:19.438] Resolving globals: FALSE
[08:26:19.438] The total size of the 1 globals is 680 bytes (680 bytes)
[08:26:19.438] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 680 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (680 bytes of class ‘function’)
[08:26:19.438] - globals: [1] ‘FUN’
[08:26:19.439] 
[08:26:19.439] getGlobalsAndPackages() ... DONE
[08:26:19.439]  - globals found/used: [n=1] ‘FUN’
[08:26:19.439]  - needed namespaces: [n=0] 
[08:26:19.439] Finding globals ... DONE
[08:26:19.439]  - use_args: TRUE
[08:26:19.439]  - Getting '...' globals ...
[08:26:19.439] resolve() on list ...
[08:26:19.440]  recursive: 0
[08:26:19.440]  length: 1
[08:26:19.440]  elements: ‘...’
[08:26:19.440]  length: 0 (resolved future 1)
[08:26:19.440] resolve() on list ... DONE
[08:26:19.440]    - '...' content: [n=1] ‘y’
[08:26:19.440] List of 1
[08:26:19.440]  $ ...:List of 1
[08:26:19.440]   ..$ y: num [1:5] 2 4 6 8 10
[08:26:19.440]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.440]  - attr(*, "where")=List of 1
[08:26:19.440]   ..$ ...:<environment: 0x562ca6f78ce8> 
[08:26:19.440]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.440]  - attr(*, "resolved")= logi TRUE
[08:26:19.440]  - attr(*, "total_size")= num NA
[08:26:19.443]  - Getting '...' globals ... DONE
[08:26:19.443] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:26:19.443] List of 2
[08:26:19.443]  $ ...future.FUN:function (x, y)  
[08:26:19.443]  $ ...          :List of 1
[08:26:19.443]   ..$ y: num [1:5] 2 4 6 8 10
[08:26:19.443]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.443]  - attr(*, "where")=List of 2
[08:26:19.443]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:19.443]   ..$ ...          :<environment: 0x562ca6f78ce8> 
[08:26:19.443]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.443]  - attr(*, "resolved")= logi FALSE
[08:26:19.443]  - attr(*, "total_size")= num 7318
[08:26:19.446] Packages to be attached in all futures: [n=0] 
[08:26:19.446] getGlobalsAndPackagesXApply() ... DONE
[08:26:19.447] Number of futures (= number of chunks): 1
[08:26:19.447] Launching 1 futures (chunks) ...
[08:26:19.447] Chunk #1 of 1 ...
[08:26:19.447]  - Finding globals in 'X' for chunk #1 ...
[08:26:19.447] getGlobalsAndPackages() ...
[08:26:19.447] Searching for globals...
[08:26:19.447] 
[08:26:19.447] Searching for globals ... DONE
[08:26:19.448] - globals: [0] <none>
[08:26:19.448] getGlobalsAndPackages() ... DONE
[08:26:19.448]    + additional globals found: [n=0] 
[08:26:19.448]    + additional namespaces needed: [n=0] 
[08:26:19.448]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:19.448]  - seeds: <none>
[08:26:19.448]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.448] getGlobalsAndPackages() ...
[08:26:19.448] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.448] Resolving globals: FALSE
[08:26:19.448] Tweak future expression to call with '...' arguments ...
[08:26:19.449] {
[08:26:19.449]     do.call(function(...) {
[08:26:19.449]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.449]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.449]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.449]             on.exit(options(oopts), add = TRUE)
[08:26:19.449]         }
[08:26:19.449]         {
[08:26:19.449]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.449]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.449]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.449]             })
[08:26:19.449]         }
[08:26:19.449]     }, args = future.call.arguments)
[08:26:19.449] }
[08:26:19.449] Tweak future expression to call with '...' arguments ... DONE
[08:26:19.449] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.449] 
[08:26:19.449] getGlobalsAndPackages() ... DONE
[08:26:19.450] run() for ‘Future’ ...
[08:26:19.450] - state: ‘created’
[08:26:19.450] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:26:19.450] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.450] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:19.450]   - Field: ‘label’
[08:26:19.450]   - Field: ‘local’
[08:26:19.451]   - Field: ‘owner’
[08:26:19.451]   - Field: ‘envir’
[08:26:19.451]   - Field: ‘packages’
[08:26:19.451]   - Field: ‘gc’
[08:26:19.451]   - Field: ‘conditions’
[08:26:19.451]   - Field: ‘expr’
[08:26:19.451]   - Field: ‘uuid’
[08:26:19.451]   - Field: ‘seed’
[08:26:19.451]   - Field: ‘version’
[08:26:19.451]   - Field: ‘result’
[08:26:19.451]   - Field: ‘asynchronous’
[08:26:19.452]   - Field: ‘calls’
[08:26:19.452]   - Field: ‘globals’
[08:26:19.452]   - Field: ‘stdout’
[08:26:19.452]   - Field: ‘earlySignal’
[08:26:19.452]   - Field: ‘lazy’
[08:26:19.452]   - Field: ‘state’
[08:26:19.452] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:19.452] - Launch lazy future ...
[08:26:19.452] Packages needed by the future expression (n = 0): <none>
[08:26:19.452] Packages needed by future strategies (n = 0): <none>
[08:26:19.453] {
[08:26:19.453]     {
[08:26:19.453]         {
[08:26:19.453]             ...future.startTime <- base::Sys.time()
[08:26:19.453]             {
[08:26:19.453]                 {
[08:26:19.453]                   {
[08:26:19.453]                     base::local({
[08:26:19.453]                       has_future <- base::requireNamespace("future", 
[08:26:19.453]                         quietly = TRUE)
[08:26:19.453]                       if (has_future) {
[08:26:19.453]                         ns <- base::getNamespace("future")
[08:26:19.453]                         version <- ns[[".package"]][["version"]]
[08:26:19.453]                         if (is.null(version)) 
[08:26:19.453]                           version <- utils::packageVersion("future")
[08:26:19.453]                       }
[08:26:19.453]                       else {
[08:26:19.453]                         version <- NULL
[08:26:19.453]                       }
[08:26:19.453]                       if (!has_future || version < "1.8.0") {
[08:26:19.453]                         info <- base::c(r_version = base::gsub("R version ", 
[08:26:19.453]                           "", base::R.version$version.string), 
[08:26:19.453]                           platform = base::sprintf("%s (%s-bit)", 
[08:26:19.453]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:19.453]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:19.453]                             "release", "version")], collapse = " "), 
[08:26:19.453]                           hostname = base::Sys.info()[["nodename"]])
[08:26:19.453]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:26:19.453]                           info)
[08:26:19.453]                         info <- base::paste(info, collapse = "; ")
[08:26:19.453]                         if (!has_future) {
[08:26:19.453]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:19.453]                             info)
[08:26:19.453]                         }
[08:26:19.453]                         else {
[08:26:19.453]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:19.453]                             info, version)
[08:26:19.453]                         }
[08:26:19.453]                         base::stop(msg)
[08:26:19.453]                       }
[08:26:19.453]                     })
[08:26:19.453]                   }
[08:26:19.453]                   ...future.strategy.old <- future::plan("list")
[08:26:19.453]                   options(future.plan = NULL)
[08:26:19.453]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.453]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:19.453]                 }
[08:26:19.453]                 ...future.workdir <- getwd()
[08:26:19.453]             }
[08:26:19.453]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:19.453]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:19.453]         }
[08:26:19.453]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:19.453]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:19.453]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:19.453]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:19.453]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:19.453]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:19.453]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:19.453]             base::names(...future.oldOptions))
[08:26:19.453]     }
[08:26:19.453]     if (FALSE) {
[08:26:19.453]     }
[08:26:19.453]     else {
[08:26:19.453]         if (TRUE) {
[08:26:19.453]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:19.453]                 open = "w")
[08:26:19.453]         }
[08:26:19.453]         else {
[08:26:19.453]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:19.453]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:19.453]         }
[08:26:19.453]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:19.453]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:19.453]             base::sink(type = "output", split = FALSE)
[08:26:19.453]             base::close(...future.stdout)
[08:26:19.453]         }, add = TRUE)
[08:26:19.453]     }
[08:26:19.453]     ...future.frame <- base::sys.nframe()
[08:26:19.453]     ...future.conditions <- base::list()
[08:26:19.453]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:19.453]     if (FALSE) {
[08:26:19.453]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:19.453]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:19.453]     }
[08:26:19.453]     ...future.result <- base::tryCatch({
[08:26:19.453]         base::withCallingHandlers({
[08:26:19.453]             ...future.value <- base::withVisible(base::local({
[08:26:19.453]                 do.call(function(...) {
[08:26:19.453]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.453]                   if (!identical(...future.globals.maxSize.org, 
[08:26:19.453]                     ...future.globals.maxSize)) {
[08:26:19.453]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.453]                     on.exit(options(oopts), add = TRUE)
[08:26:19.453]                   }
[08:26:19.453]                   {
[08:26:19.453]                     lapply(seq_along(...future.elements_ii), 
[08:26:19.453]                       FUN = function(jj) {
[08:26:19.453]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.453]                         ...future.FUN(...future.X_jj, ...)
[08:26:19.453]                       })
[08:26:19.453]                   }
[08:26:19.453]                 }, args = future.call.arguments)
[08:26:19.453]             }))
[08:26:19.453]             future::FutureResult(value = ...future.value$value, 
[08:26:19.453]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.453]                   ...future.rng), globalenv = if (FALSE) 
[08:26:19.453]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:19.453]                     ...future.globalenv.names))
[08:26:19.453]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:19.453]         }, condition = base::local({
[08:26:19.453]             c <- base::c
[08:26:19.453]             inherits <- base::inherits
[08:26:19.453]             invokeRestart <- base::invokeRestart
[08:26:19.453]             length <- base::length
[08:26:19.453]             list <- base::list
[08:26:19.453]             seq.int <- base::seq.int
[08:26:19.453]             signalCondition <- base::signalCondition
[08:26:19.453]             sys.calls <- base::sys.calls
[08:26:19.453]             `[[` <- base::`[[`
[08:26:19.453]             `+` <- base::`+`
[08:26:19.453]             `<<-` <- base::`<<-`
[08:26:19.453]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:19.453]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:19.453]                   3L)]
[08:26:19.453]             }
[08:26:19.453]             function(cond) {
[08:26:19.453]                 is_error <- inherits(cond, "error")
[08:26:19.453]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:19.453]                   NULL)
[08:26:19.453]                 if (is_error) {
[08:26:19.453]                   sessionInformation <- function() {
[08:26:19.453]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:19.453]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:19.453]                       search = base::search(), system = base::Sys.info())
[08:26:19.453]                   }
[08:26:19.453]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.453]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:19.453]                     cond$call), session = sessionInformation(), 
[08:26:19.453]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:19.453]                   signalCondition(cond)
[08:26:19.453]                 }
[08:26:19.453]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:19.453]                 "immediateCondition"))) {
[08:26:19.453]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:19.453]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.453]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:19.453]                   if (TRUE && !signal) {
[08:26:19.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.453]                     {
[08:26:19.453]                       inherits <- base::inherits
[08:26:19.453]                       invokeRestart <- base::invokeRestart
[08:26:19.453]                       is.null <- base::is.null
[08:26:19.453]                       muffled <- FALSE
[08:26:19.453]                       if (inherits(cond, "message")) {
[08:26:19.453]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.453]                         if (muffled) 
[08:26:19.453]                           invokeRestart("muffleMessage")
[08:26:19.453]                       }
[08:26:19.453]                       else if (inherits(cond, "warning")) {
[08:26:19.453]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.453]                         if (muffled) 
[08:26:19.453]                           invokeRestart("muffleWarning")
[08:26:19.453]                       }
[08:26:19.453]                       else if (inherits(cond, "condition")) {
[08:26:19.453]                         if (!is.null(pattern)) {
[08:26:19.453]                           computeRestarts <- base::computeRestarts
[08:26:19.453]                           grepl <- base::grepl
[08:26:19.453]                           restarts <- computeRestarts(cond)
[08:26:19.453]                           for (restart in restarts) {
[08:26:19.453]                             name <- restart$name
[08:26:19.453]                             if (is.null(name)) 
[08:26:19.453]                               next
[08:26:19.453]                             if (!grepl(pattern, name)) 
[08:26:19.453]                               next
[08:26:19.453]                             invokeRestart(restart)
[08:26:19.453]                             muffled <- TRUE
[08:26:19.453]                             break
[08:26:19.453]                           }
[08:26:19.453]                         }
[08:26:19.453]                       }
[08:26:19.453]                       invisible(muffled)
[08:26:19.453]                     }
[08:26:19.453]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.453]                   }
[08:26:19.453]                 }
[08:26:19.453]                 else {
[08:26:19.453]                   if (TRUE) {
[08:26:19.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.453]                     {
[08:26:19.453]                       inherits <- base::inherits
[08:26:19.453]                       invokeRestart <- base::invokeRestart
[08:26:19.453]                       is.null <- base::is.null
[08:26:19.453]                       muffled <- FALSE
[08:26:19.453]                       if (inherits(cond, "message")) {
[08:26:19.453]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.453]                         if (muffled) 
[08:26:19.453]                           invokeRestart("muffleMessage")
[08:26:19.453]                       }
[08:26:19.453]                       else if (inherits(cond, "warning")) {
[08:26:19.453]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.453]                         if (muffled) 
[08:26:19.453]                           invokeRestart("muffleWarning")
[08:26:19.453]                       }
[08:26:19.453]                       else if (inherits(cond, "condition")) {
[08:26:19.453]                         if (!is.null(pattern)) {
[08:26:19.453]                           computeRestarts <- base::computeRestarts
[08:26:19.453]                           grepl <- base::grepl
[08:26:19.453]                           restarts <- computeRestarts(cond)
[08:26:19.453]                           for (restart in restarts) {
[08:26:19.453]                             name <- restart$name
[08:26:19.453]                             if (is.null(name)) 
[08:26:19.453]                               next
[08:26:19.453]                             if (!grepl(pattern, name)) 
[08:26:19.453]                               next
[08:26:19.453]                             invokeRestart(restart)
[08:26:19.453]                             muffled <- TRUE
[08:26:19.453]                             break
[08:26:19.453]                           }
[08:26:19.453]                         }
[08:26:19.453]                       }
[08:26:19.453]                       invisible(muffled)
[08:26:19.453]                     }
[08:26:19.453]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.453]                   }
[08:26:19.453]                 }
[08:26:19.453]             }
[08:26:19.453]         }))
[08:26:19.453]     }, error = function(ex) {
[08:26:19.453]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:19.453]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.453]                 ...future.rng), started = ...future.startTime, 
[08:26:19.453]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:19.453]             version = "1.8"), class = "FutureResult")
[08:26:19.453]     }, finally = {
[08:26:19.453]         if (!identical(...future.workdir, getwd())) 
[08:26:19.453]             setwd(...future.workdir)
[08:26:19.453]         {
[08:26:19.453]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:19.453]                 ...future.oldOptions$nwarnings <- NULL
[08:26:19.453]             }
[08:26:19.453]             base::options(...future.oldOptions)
[08:26:19.453]             if (.Platform$OS.type == "windows") {
[08:26:19.453]                 old_names <- names(...future.oldEnvVars)
[08:26:19.453]                 envs <- base::Sys.getenv()
[08:26:19.453]                 names <- names(envs)
[08:26:19.453]                 common <- intersect(names, old_names)
[08:26:19.453]                 added <- setdiff(names, old_names)
[08:26:19.453]                 removed <- setdiff(old_names, names)
[08:26:19.453]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:19.453]                   envs[common]]
[08:26:19.453]                 NAMES <- toupper(changed)
[08:26:19.453]                 args <- list()
[08:26:19.453]                 for (kk in seq_along(NAMES)) {
[08:26:19.453]                   name <- changed[[kk]]
[08:26:19.453]                   NAME <- NAMES[[kk]]
[08:26:19.453]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.453]                     next
[08:26:19.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.453]                 }
[08:26:19.453]                 NAMES <- toupper(added)
[08:26:19.453]                 for (kk in seq_along(NAMES)) {
[08:26:19.453]                   name <- added[[kk]]
[08:26:19.453]                   NAME <- NAMES[[kk]]
[08:26:19.453]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.453]                     next
[08:26:19.453]                   args[[name]] <- ""
[08:26:19.453]                 }
[08:26:19.453]                 NAMES <- toupper(removed)
[08:26:19.453]                 for (kk in seq_along(NAMES)) {
[08:26:19.453]                   name <- removed[[kk]]
[08:26:19.453]                   NAME <- NAMES[[kk]]
[08:26:19.453]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.453]                     next
[08:26:19.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.453]                 }
[08:26:19.453]                 if (length(args) > 0) 
[08:26:19.453]                   base::do.call(base::Sys.setenv, args = args)
[08:26:19.453]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:19.453]             }
[08:26:19.453]             else {
[08:26:19.453]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:19.453]             }
[08:26:19.453]             {
[08:26:19.453]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:19.453]                   0L) {
[08:26:19.453]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:19.453]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:19.453]                   base::options(opts)
[08:26:19.453]                 }
[08:26:19.453]                 {
[08:26:19.453]                   {
[08:26:19.453]                     NULL
[08:26:19.453]                     RNGkind("Mersenne-Twister")
[08:26:19.453]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:19.453]                       inherits = FALSE)
[08:26:19.453]                   }
[08:26:19.453]                   options(future.plan = NULL)
[08:26:19.453]                   if (is.na(NA_character_)) 
[08:26:19.453]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.453]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:19.453]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:19.453]                     .init = FALSE)
[08:26:19.453]                 }
[08:26:19.453]             }
[08:26:19.453]         }
[08:26:19.453]     })
[08:26:19.453]     if (TRUE) {
[08:26:19.453]         base::sink(type = "output", split = FALSE)
[08:26:19.453]         if (TRUE) {
[08:26:19.453]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:19.453]         }
[08:26:19.453]         else {
[08:26:19.453]             ...future.result["stdout"] <- base::list(NULL)
[08:26:19.453]         }
[08:26:19.453]         base::close(...future.stdout)
[08:26:19.453]         ...future.stdout <- NULL
[08:26:19.453]     }
[08:26:19.453]     ...future.result$conditions <- ...future.conditions
[08:26:19.453]     ...future.result$finished <- base::Sys.time()
[08:26:19.453]     ...future.result
[08:26:19.453] }
[08:26:19.455] assign_globals() ...
[08:26:19.455] List of 5
[08:26:19.455]  $ ...future.FUN            :function (x, y)  
[08:26:19.455]  $ future.call.arguments    :List of 1
[08:26:19.455]   ..$ y: num [1:5] 2 4 6 8 10
[08:26:19.455]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.455]  $ ...future.elements_ii    :List of 4
[08:26:19.455]   ..$ A: num 50
[08:26:19.455]   ..$ B: num 60
[08:26:19.455]   ..$ C: num 70
[08:26:19.455]   ..$ D: num 80
[08:26:19.455]  $ ...future.seeds_ii       : NULL
[08:26:19.455]  $ ...future.globals.maxSize: NULL
[08:26:19.455]  - attr(*, "where")=List of 5
[08:26:19.455]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:19.455]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:19.455]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:19.455]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:19.455]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:19.455]  - attr(*, "resolved")= logi FALSE
[08:26:19.455]  - attr(*, "total_size")= num 7318
[08:26:19.455]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.455]  - attr(*, "already-done")= logi TRUE
[08:26:19.463] - reassign environment for ‘...future.FUN’
[08:26:19.463] - copied ‘...future.FUN’ to environment
[08:26:19.463] - copied ‘future.call.arguments’ to environment
[08:26:19.463] - copied ‘...future.elements_ii’ to environment
[08:26:19.463] - copied ‘...future.seeds_ii’ to environment
[08:26:19.463] - copied ‘...future.globals.maxSize’ to environment
[08:26:19.464] assign_globals() ... done
[08:26:19.464] plan(): Setting new future strategy stack:
[08:26:19.464] List of future strategies:
[08:26:19.464] 1. sequential:
[08:26:19.464]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.464]    - tweaked: FALSE
[08:26:19.464]    - call: NULL
[08:26:19.464] plan(): nbrOfWorkers() = 1
[08:26:19.465] plan(): Setting new future strategy stack:
[08:26:19.465] List of future strategies:
[08:26:19.465] 1. sequential:
[08:26:19.465]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.465]    - tweaked: FALSE
[08:26:19.465]    - call: plan(strategy)
[08:26:19.466] plan(): nbrOfWorkers() = 1
[08:26:19.466] SequentialFuture started (and completed)
[08:26:19.466] - Launch lazy future ... done
[08:26:19.466] run() for ‘SequentialFuture’ ... done
[08:26:19.466] Created future:
[08:26:19.466] SequentialFuture:
[08:26:19.466] Label: ‘future_sapply-1’
[08:26:19.466] Expression:
[08:26:19.466] {
[08:26:19.466]     do.call(function(...) {
[08:26:19.466]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.466]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.466]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.466]             on.exit(options(oopts), add = TRUE)
[08:26:19.466]         }
[08:26:19.466]         {
[08:26:19.466]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.466]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.466]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.466]             })
[08:26:19.466]         }
[08:26:19.466]     }, args = future.call.arguments)
[08:26:19.466] }
[08:26:19.466] Lazy evaluation: FALSE
[08:26:19.466] Asynchronous evaluation: FALSE
[08:26:19.466] Local evaluation: TRUE
[08:26:19.466] Environment: R_GlobalEnv
[08:26:19.466] Capture standard output: TRUE
[08:26:19.466] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:19.466] Globals: 5 objects totaling 1.06 KiB (function ‘...future.FUN’ of 680 bytes, DotDotDotList ‘future.call.arguments’ of 183 bytes, list ‘...future.elements_ii’ of 164 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:19.466] Packages: <none>
[08:26:19.466] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:19.466] Resolved: TRUE
[08:26:19.466] Value: 666 bytes of class ‘list’
[08:26:19.466] Early signaling: FALSE
[08:26:19.466] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:19.466] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.467] Chunk #1 of 1 ... DONE
[08:26:19.467] Launching 1 futures (chunks) ... DONE
[08:26:19.467] Resolving 1 futures (chunks) ...
[08:26:19.467] resolve() on list ...
[08:26:19.468]  recursive: 0
[08:26:19.468]  length: 1
[08:26:19.468] 
[08:26:19.468] resolved() for ‘SequentialFuture’ ...
[08:26:19.468] - state: ‘finished’
[08:26:19.468] - run: TRUE
[08:26:19.468] - result: ‘FutureResult’
[08:26:19.468] resolved() for ‘SequentialFuture’ ... done
[08:26:19.468] Future #1
[08:26:19.468] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:19.469] - nx: 1
[08:26:19.469] - relay: TRUE
[08:26:19.469] - stdout: TRUE
[08:26:19.469] - signal: TRUE
[08:26:19.469] - resignal: FALSE
[08:26:19.469] - force: TRUE
[08:26:19.469] - relayed: [n=1] FALSE
[08:26:19.469] - queued futures: [n=1] FALSE
[08:26:19.469]  - until=1
[08:26:19.469]  - relaying element #1
[08:26:19.469] - relayed: [n=1] TRUE
[08:26:19.470] - queued futures: [n=1] TRUE
[08:26:19.470] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:19.470]  length: 0 (resolved future 1)
[08:26:19.470] Relaying remaining futures
[08:26:19.470] signalConditionsASAP(NULL, pos=0) ...
[08:26:19.470] - nx: 1
[08:26:19.470] - relay: TRUE
[08:26:19.470] - stdout: TRUE
[08:26:19.470] - signal: TRUE
[08:26:19.470] - resignal: FALSE
[08:26:19.470] - force: TRUE
[08:26:19.470] - relayed: [n=1] TRUE
[08:26:19.470] - queued futures: [n=1] TRUE
 - flush all
[08:26:19.471] - relayed: [n=1] TRUE
[08:26:19.471] - queued futures: [n=1] TRUE
[08:26:19.471] signalConditionsASAP(NULL, pos=0) ... done
[08:26:19.471] resolve() on list ... DONE
[08:26:19.471]  - Number of value chunks collected: 1
[08:26:19.471] Resolving 1 futures (chunks) ... DONE
[08:26:19.471] Reducing values from 1 chunks ...
[08:26:19.471]  - Number of values collected after concatenation: 4
[08:26:19.471]  - Number of values expected: 4
[08:26:19.471] Reducing values from 1 chunks ... DONE
[08:26:19.472] future_lapply() ... DONE
[08:26:19.472] future_lapply() ...
[08:26:19.474] Number of chunks: 1
[08:26:19.474] getGlobalsAndPackagesXApply() ...
[08:26:19.474]  - future.globals: TRUE
[08:26:19.474] getGlobalsAndPackages() ...
[08:26:19.474] Searching for globals...
[08:26:19.478] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[08:26:19.478] Searching for globals ... DONE
[08:26:19.478] Resolving globals: FALSE
[08:26:19.479] The total size of the 7 globals is 14.32 KiB (14666 bytes)
[08:26:19.479] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 14.32 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.67 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:19.481] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.481] - packages: [1] ‘future.apply’
[08:26:19.481] getGlobalsAndPackages() ... DONE
[08:26:19.481]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.481]  - needed namespaces: [n=1] ‘future.apply’
[08:26:19.481] Finding globals ... DONE
[08:26:19.481]  - use_args: TRUE
[08:26:19.482]  - Getting '...' globals ...
[08:26:19.482] resolve() on list ...
[08:26:19.482]  recursive: 0
[08:26:19.482]  length: 1
[08:26:19.482]  elements: ‘...’
[08:26:19.482]  length: 0 (resolved future 1)
[08:26:19.483] resolve() on list ... DONE
[08:26:19.483]    - '...' content: [n=1] ‘y’
[08:26:19.483] List of 1
[08:26:19.483]  $ ...:List of 1
[08:26:19.483]   ..$ y: num [1:5] 2 4 6 8 10
[08:26:19.483]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.483]  - attr(*, "where")=List of 1
[08:26:19.483]   ..$ ...:<environment: 0x562ca7a9c5b0> 
[08:26:19.483]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.483]  - attr(*, "resolved")= logi TRUE
[08:26:19.483]  - attr(*, "total_size")= num NA
[08:26:19.485]  - Getting '...' globals ... DONE
[08:26:19.486] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:19.486] List of 8
[08:26:19.486]  $ ...future.FUN:function (x, ...)  
[08:26:19.486]  $ x_FUN        :function (x, y)  
[08:26:19.486]  $ times        : int 15
[08:26:19.486]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.486]  $ stop_if_not  :function (...)  
[08:26:19.486]  $ dim          : int [1:2] 3 5
[08:26:19.486]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:19.486]  $ ...          :List of 1
[08:26:19.486]   ..$ y: num [1:5] 2 4 6 8 10
[08:26:19.486]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.486]  - attr(*, "where")=List of 8
[08:26:19.486]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:19.486]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:19.486]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:19.486]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:19.486]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:19.486]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:19.486]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:19.486]   ..$ ...          :<environment: 0x562ca7a9c5b0> 
[08:26:19.486]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.486]  - attr(*, "resolved")= logi FALSE
[08:26:19.486]  - attr(*, "total_size")= num 26659
[08:26:19.492] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:19.492] getGlobalsAndPackagesXApply() ... DONE
[08:26:19.492] Number of futures (= number of chunks): 1
[08:26:19.492] Launching 1 futures (chunks) ...
[08:26:19.492] Chunk #1 of 1 ...
[08:26:19.492]  - Finding globals in 'X' for chunk #1 ...
[08:26:19.492] getGlobalsAndPackages() ...
[08:26:19.492] Searching for globals...
[08:26:19.493] 
[08:26:19.493] Searching for globals ... DONE
[08:26:19.493] - globals: [0] <none>
[08:26:19.493] getGlobalsAndPackages() ... DONE
[08:26:19.493]    + additional globals found: [n=0] 
[08:26:19.493]    + additional namespaces needed: [n=0] 
[08:26:19.493]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:19.493]  - seeds: <none>
[08:26:19.493]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.494] getGlobalsAndPackages() ...
[08:26:19.494] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.494] Resolving globals: FALSE
[08:26:19.494] Tweak future expression to call with '...' arguments ...
[08:26:19.494] {
[08:26:19.494]     do.call(function(...) {
[08:26:19.494]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.494]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.494]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.494]             on.exit(options(oopts), add = TRUE)
[08:26:19.494]         }
[08:26:19.494]         {
[08:26:19.494]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.494]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.494]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.494]             })
[08:26:19.494]         }
[08:26:19.494]     }, args = future.call.arguments)
[08:26:19.494] }
[08:26:19.494] Tweak future expression to call with '...' arguments ... DONE
[08:26:19.495] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.495] - packages: [1] ‘future.apply’
[08:26:19.495] getGlobalsAndPackages() ... DONE
[08:26:19.495] run() for ‘Future’ ...
[08:26:19.495] - state: ‘created’
[08:26:19.495] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:26:19.496] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.496] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:19.496]   - Field: ‘label’
[08:26:19.496]   - Field: ‘local’
[08:26:19.496]   - Field: ‘owner’
[08:26:19.496]   - Field: ‘envir’
[08:26:19.496]   - Field: ‘packages’
[08:26:19.496]   - Field: ‘gc’
[08:26:19.496]   - Field: ‘conditions’
[08:26:19.496]   - Field: ‘expr’
[08:26:19.497]   - Field: ‘uuid’
[08:26:19.497]   - Field: ‘seed’
[08:26:19.497]   - Field: ‘version’
[08:26:19.497]   - Field: ‘result’
[08:26:19.497]   - Field: ‘asynchronous’
[08:26:19.497]   - Field: ‘calls’
[08:26:19.497]   - Field: ‘globals’
[08:26:19.497]   - Field: ‘stdout’
[08:26:19.497]   - Field: ‘earlySignal’
[08:26:19.497]   - Field: ‘lazy’
[08:26:19.497]   - Field: ‘state’
[08:26:19.497] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:19.498] - Launch lazy future ...
[08:26:19.498] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:19.498] Packages needed by future strategies (n = 0): <none>
[08:26:19.498] {
[08:26:19.498]     {
[08:26:19.498]         {
[08:26:19.498]             ...future.startTime <- base::Sys.time()
[08:26:19.498]             {
[08:26:19.498]                 {
[08:26:19.498]                   {
[08:26:19.498]                     {
[08:26:19.498]                       base::local({
[08:26:19.498]                         has_future <- base::requireNamespace("future", 
[08:26:19.498]                           quietly = TRUE)
[08:26:19.498]                         if (has_future) {
[08:26:19.498]                           ns <- base::getNamespace("future")
[08:26:19.498]                           version <- ns[[".package"]][["version"]]
[08:26:19.498]                           if (is.null(version)) 
[08:26:19.498]                             version <- utils::packageVersion("future")
[08:26:19.498]                         }
[08:26:19.498]                         else {
[08:26:19.498]                           version <- NULL
[08:26:19.498]                         }
[08:26:19.498]                         if (!has_future || version < "1.8.0") {
[08:26:19.498]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:19.498]                             "", base::R.version$version.string), 
[08:26:19.498]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:19.498]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:19.498]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:19.498]                               "release", "version")], collapse = " "), 
[08:26:19.498]                             hostname = base::Sys.info()[["nodename"]])
[08:26:19.498]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:19.498]                             info)
[08:26:19.498]                           info <- base::paste(info, collapse = "; ")
[08:26:19.498]                           if (!has_future) {
[08:26:19.498]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:19.498]                               info)
[08:26:19.498]                           }
[08:26:19.498]                           else {
[08:26:19.498]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:19.498]                               info, version)
[08:26:19.498]                           }
[08:26:19.498]                           base::stop(msg)
[08:26:19.498]                         }
[08:26:19.498]                       })
[08:26:19.498]                     }
[08:26:19.498]                     base::local({
[08:26:19.498]                       for (pkg in "future.apply") {
[08:26:19.498]                         base::loadNamespace(pkg)
[08:26:19.498]                         base::library(pkg, character.only = TRUE)
[08:26:19.498]                       }
[08:26:19.498]                     })
[08:26:19.498]                   }
[08:26:19.498]                   ...future.strategy.old <- future::plan("list")
[08:26:19.498]                   options(future.plan = NULL)
[08:26:19.498]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.498]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:19.498]                 }
[08:26:19.498]                 ...future.workdir <- getwd()
[08:26:19.498]             }
[08:26:19.498]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:19.498]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:19.498]         }
[08:26:19.498]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:19.498]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:19.498]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:19.498]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:19.498]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:19.498]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:19.498]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:19.498]             base::names(...future.oldOptions))
[08:26:19.498]     }
[08:26:19.498]     if (FALSE) {
[08:26:19.498]     }
[08:26:19.498]     else {
[08:26:19.498]         if (TRUE) {
[08:26:19.498]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:19.498]                 open = "w")
[08:26:19.498]         }
[08:26:19.498]         else {
[08:26:19.498]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:19.498]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:19.498]         }
[08:26:19.498]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:19.498]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:19.498]             base::sink(type = "output", split = FALSE)
[08:26:19.498]             base::close(...future.stdout)
[08:26:19.498]         }, add = TRUE)
[08:26:19.498]     }
[08:26:19.498]     ...future.frame <- base::sys.nframe()
[08:26:19.498]     ...future.conditions <- base::list()
[08:26:19.498]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:19.498]     if (FALSE) {
[08:26:19.498]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:19.498]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:19.498]     }
[08:26:19.498]     ...future.result <- base::tryCatch({
[08:26:19.498]         base::withCallingHandlers({
[08:26:19.498]             ...future.value <- base::withVisible(base::local({
[08:26:19.498]                 do.call(function(...) {
[08:26:19.498]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.498]                   if (!identical(...future.globals.maxSize.org, 
[08:26:19.498]                     ...future.globals.maxSize)) {
[08:26:19.498]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.498]                     on.exit(options(oopts), add = TRUE)
[08:26:19.498]                   }
[08:26:19.498]                   {
[08:26:19.498]                     lapply(seq_along(...future.elements_ii), 
[08:26:19.498]                       FUN = function(jj) {
[08:26:19.498]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.498]                         ...future.FUN(...future.X_jj, ...)
[08:26:19.498]                       })
[08:26:19.498]                   }
[08:26:19.498]                 }, args = future.call.arguments)
[08:26:19.498]             }))
[08:26:19.498]             future::FutureResult(value = ...future.value$value, 
[08:26:19.498]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.498]                   ...future.rng), globalenv = if (FALSE) 
[08:26:19.498]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:19.498]                     ...future.globalenv.names))
[08:26:19.498]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:19.498]         }, condition = base::local({
[08:26:19.498]             c <- base::c
[08:26:19.498]             inherits <- base::inherits
[08:26:19.498]             invokeRestart <- base::invokeRestart
[08:26:19.498]             length <- base::length
[08:26:19.498]             list <- base::list
[08:26:19.498]             seq.int <- base::seq.int
[08:26:19.498]             signalCondition <- base::signalCondition
[08:26:19.498]             sys.calls <- base::sys.calls
[08:26:19.498]             `[[` <- base::`[[`
[08:26:19.498]             `+` <- base::`+`
[08:26:19.498]             `<<-` <- base::`<<-`
[08:26:19.498]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:19.498]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:19.498]                   3L)]
[08:26:19.498]             }
[08:26:19.498]             function(cond) {
[08:26:19.498]                 is_error <- inherits(cond, "error")
[08:26:19.498]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:19.498]                   NULL)
[08:26:19.498]                 if (is_error) {
[08:26:19.498]                   sessionInformation <- function() {
[08:26:19.498]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:19.498]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:19.498]                       search = base::search(), system = base::Sys.info())
[08:26:19.498]                   }
[08:26:19.498]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.498]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:19.498]                     cond$call), session = sessionInformation(), 
[08:26:19.498]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:19.498]                   signalCondition(cond)
[08:26:19.498]                 }
[08:26:19.498]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:19.498]                 "immediateCondition"))) {
[08:26:19.498]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:19.498]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.498]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:19.498]                   if (TRUE && !signal) {
[08:26:19.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.498]                     {
[08:26:19.498]                       inherits <- base::inherits
[08:26:19.498]                       invokeRestart <- base::invokeRestart
[08:26:19.498]                       is.null <- base::is.null
[08:26:19.498]                       muffled <- FALSE
[08:26:19.498]                       if (inherits(cond, "message")) {
[08:26:19.498]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.498]                         if (muffled) 
[08:26:19.498]                           invokeRestart("muffleMessage")
[08:26:19.498]                       }
[08:26:19.498]                       else if (inherits(cond, "warning")) {
[08:26:19.498]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.498]                         if (muffled) 
[08:26:19.498]                           invokeRestart("muffleWarning")
[08:26:19.498]                       }
[08:26:19.498]                       else if (inherits(cond, "condition")) {
[08:26:19.498]                         if (!is.null(pattern)) {
[08:26:19.498]                           computeRestarts <- base::computeRestarts
[08:26:19.498]                           grepl <- base::grepl
[08:26:19.498]                           restarts <- computeRestarts(cond)
[08:26:19.498]                           for (restart in restarts) {
[08:26:19.498]                             name <- restart$name
[08:26:19.498]                             if (is.null(name)) 
[08:26:19.498]                               next
[08:26:19.498]                             if (!grepl(pattern, name)) 
[08:26:19.498]                               next
[08:26:19.498]                             invokeRestart(restart)
[08:26:19.498]                             muffled <- TRUE
[08:26:19.498]                             break
[08:26:19.498]                           }
[08:26:19.498]                         }
[08:26:19.498]                       }
[08:26:19.498]                       invisible(muffled)
[08:26:19.498]                     }
[08:26:19.498]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.498]                   }
[08:26:19.498]                 }
[08:26:19.498]                 else {
[08:26:19.498]                   if (TRUE) {
[08:26:19.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.498]                     {
[08:26:19.498]                       inherits <- base::inherits
[08:26:19.498]                       invokeRestart <- base::invokeRestart
[08:26:19.498]                       is.null <- base::is.null
[08:26:19.498]                       muffled <- FALSE
[08:26:19.498]                       if (inherits(cond, "message")) {
[08:26:19.498]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.498]                         if (muffled) 
[08:26:19.498]                           invokeRestart("muffleMessage")
[08:26:19.498]                       }
[08:26:19.498]                       else if (inherits(cond, "warning")) {
[08:26:19.498]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.498]                         if (muffled) 
[08:26:19.498]                           invokeRestart("muffleWarning")
[08:26:19.498]                       }
[08:26:19.498]                       else if (inherits(cond, "condition")) {
[08:26:19.498]                         if (!is.null(pattern)) {
[08:26:19.498]                           computeRestarts <- base::computeRestarts
[08:26:19.498]                           grepl <- base::grepl
[08:26:19.498]                           restarts <- computeRestarts(cond)
[08:26:19.498]                           for (restart in restarts) {
[08:26:19.498]                             name <- restart$name
[08:26:19.498]                             if (is.null(name)) 
[08:26:19.498]                               next
[08:26:19.498]                             if (!grepl(pattern, name)) 
[08:26:19.498]                               next
[08:26:19.498]                             invokeRestart(restart)
[08:26:19.498]                             muffled <- TRUE
[08:26:19.498]                             break
[08:26:19.498]                           }
[08:26:19.498]                         }
[08:26:19.498]                       }
[08:26:19.498]                       invisible(muffled)
[08:26:19.498]                     }
[08:26:19.498]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.498]                   }
[08:26:19.498]                 }
[08:26:19.498]             }
[08:26:19.498]         }))
[08:26:19.498]     }, error = function(ex) {
[08:26:19.498]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:19.498]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.498]                 ...future.rng), started = ...future.startTime, 
[08:26:19.498]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:19.498]             version = "1.8"), class = "FutureResult")
[08:26:19.498]     }, finally = {
[08:26:19.498]         if (!identical(...future.workdir, getwd())) 
[08:26:19.498]             setwd(...future.workdir)
[08:26:19.498]         {
[08:26:19.498]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:19.498]                 ...future.oldOptions$nwarnings <- NULL
[08:26:19.498]             }
[08:26:19.498]             base::options(...future.oldOptions)
[08:26:19.498]             if (.Platform$OS.type == "windows") {
[08:26:19.498]                 old_names <- names(...future.oldEnvVars)
[08:26:19.498]                 envs <- base::Sys.getenv()
[08:26:19.498]                 names <- names(envs)
[08:26:19.498]                 common <- intersect(names, old_names)
[08:26:19.498]                 added <- setdiff(names, old_names)
[08:26:19.498]                 removed <- setdiff(old_names, names)
[08:26:19.498]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:19.498]                   envs[common]]
[08:26:19.498]                 NAMES <- toupper(changed)
[08:26:19.498]                 args <- list()
[08:26:19.498]                 for (kk in seq_along(NAMES)) {
[08:26:19.498]                   name <- changed[[kk]]
[08:26:19.498]                   NAME <- NAMES[[kk]]
[08:26:19.498]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.498]                     next
[08:26:19.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.498]                 }
[08:26:19.498]                 NAMES <- toupper(added)
[08:26:19.498]                 for (kk in seq_along(NAMES)) {
[08:26:19.498]                   name <- added[[kk]]
[08:26:19.498]                   NAME <- NAMES[[kk]]
[08:26:19.498]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.498]                     next
[08:26:19.498]                   args[[name]] <- ""
[08:26:19.498]                 }
[08:26:19.498]                 NAMES <- toupper(removed)
[08:26:19.498]                 for (kk in seq_along(NAMES)) {
[08:26:19.498]                   name <- removed[[kk]]
[08:26:19.498]                   NAME <- NAMES[[kk]]
[08:26:19.498]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.498]                     next
[08:26:19.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.498]                 }
[08:26:19.498]                 if (length(args) > 0) 
[08:26:19.498]                   base::do.call(base::Sys.setenv, args = args)
[08:26:19.498]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:19.498]             }
[08:26:19.498]             else {
[08:26:19.498]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:19.498]             }
[08:26:19.498]             {
[08:26:19.498]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:19.498]                   0L) {
[08:26:19.498]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:19.498]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:19.498]                   base::options(opts)
[08:26:19.498]                 }
[08:26:19.498]                 {
[08:26:19.498]                   {
[08:26:19.498]                     NULL
[08:26:19.498]                     RNGkind("Mersenne-Twister")
[08:26:19.498]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:19.498]                       inherits = FALSE)
[08:26:19.498]                   }
[08:26:19.498]                   options(future.plan = NULL)
[08:26:19.498]                   if (is.na(NA_character_)) 
[08:26:19.498]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.498]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:19.498]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:19.498]                     .init = FALSE)
[08:26:19.498]                 }
[08:26:19.498]             }
[08:26:19.498]         }
[08:26:19.498]     })
[08:26:19.498]     if (TRUE) {
[08:26:19.498]         base::sink(type = "output", split = FALSE)
[08:26:19.498]         if (TRUE) {
[08:26:19.498]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:19.498]         }
[08:26:19.498]         else {
[08:26:19.498]             ...future.result["stdout"] <- base::list(NULL)
[08:26:19.498]         }
[08:26:19.498]         base::close(...future.stdout)
[08:26:19.498]         ...future.stdout <- NULL
[08:26:19.498]     }
[08:26:19.498]     ...future.result$conditions <- ...future.conditions
[08:26:19.498]     ...future.result$finished <- base::Sys.time()
[08:26:19.498]     ...future.result
[08:26:19.498] }
[08:26:19.500] assign_globals() ...
[08:26:19.500] List of 11
[08:26:19.500]  $ ...future.FUN            :function (x, ...)  
[08:26:19.500]  $ x_FUN                    :function (x, y)  
[08:26:19.500]  $ times                    : int 15
[08:26:19.500]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.500]  $ stop_if_not              :function (...)  
[08:26:19.500]  $ dim                      : int [1:2] 3 5
[08:26:19.500]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:19.500]  $ future.call.arguments    :List of 1
[08:26:19.500]   ..$ y: num [1:5] 2 4 6 8 10
[08:26:19.500]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.500]  $ ...future.elements_ii    :List of 4
[08:26:19.500]   ..$ A: num 50
[08:26:19.500]   ..$ B: num 60
[08:26:19.500]   ..$ C: num 70
[08:26:19.500]   ..$ D: num 80
[08:26:19.500]  $ ...future.seeds_ii       : NULL
[08:26:19.500]  $ ...future.globals.maxSize: NULL
[08:26:19.500]  - attr(*, "where")=List of 11
[08:26:19.500]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:19.500]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:19.500]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:19.500]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:19.500]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:19.500]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:19.500]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:19.500]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:19.500]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:19.500]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:19.500]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:19.500]  - attr(*, "resolved")= logi FALSE
[08:26:19.500]  - attr(*, "total_size")= num 26659
[08:26:19.500]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.500]  - attr(*, "already-done")= logi TRUE
[08:26:19.511] - copied ‘...future.FUN’ to environment
[08:26:19.511] - reassign environment for ‘x_FUN’
[08:26:19.511] - copied ‘x_FUN’ to environment
[08:26:19.511] - copied ‘times’ to environment
[08:26:19.511] - copied ‘stopf’ to environment
[08:26:19.511] - copied ‘stop_if_not’ to environment
[08:26:19.512] - copied ‘dim’ to environment
[08:26:19.512] - copied ‘valid_types’ to environment
[08:26:19.512] - copied ‘future.call.arguments’ to environment
[08:26:19.512] - copied ‘...future.elements_ii’ to environment
[08:26:19.512] - copied ‘...future.seeds_ii’ to environment
[08:26:19.512] - copied ‘...future.globals.maxSize’ to environment
[08:26:19.512] assign_globals() ... done
[08:26:19.512] plan(): Setting new future strategy stack:
[08:26:19.513] List of future strategies:
[08:26:19.513] 1. sequential:
[08:26:19.513]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.513]    - tweaked: FALSE
[08:26:19.513]    - call: NULL
[08:26:19.513] plan(): nbrOfWorkers() = 1
[08:26:19.514] plan(): Setting new future strategy stack:
[08:26:19.514] List of future strategies:
[08:26:19.514] 1. sequential:
[08:26:19.514]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.514]    - tweaked: FALSE
[08:26:19.514]    - call: plan(strategy)
[08:26:19.514] plan(): nbrOfWorkers() = 1
[08:26:19.515] SequentialFuture started (and completed)
[08:26:19.515] - Launch lazy future ... done
[08:26:19.515] run() for ‘SequentialFuture’ ... done
[08:26:19.515] Created future:
[08:26:19.515] SequentialFuture:
[08:26:19.515] Label: ‘future_vapply-1’
[08:26:19.515] Expression:
[08:26:19.515] {
[08:26:19.515]     do.call(function(...) {
[08:26:19.515]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.515]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.515]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.515]             on.exit(options(oopts), add = TRUE)
[08:26:19.515]         }
[08:26:19.515]         {
[08:26:19.515]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.515]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.515]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.515]             })
[08:26:19.515]         }
[08:26:19.515]     }, args = future.call.arguments)
[08:26:19.515] }
[08:26:19.515] Lazy evaluation: FALSE
[08:26:19.515] Asynchronous evaluation: FALSE
[08:26:19.515] Local evaluation: TRUE
[08:26:19.515] Environment: R_GlobalEnv
[08:26:19.515] Capture standard output: TRUE
[08:26:19.515] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:19.515] Globals: 11 objects totaling 14.71 KiB (function ‘...future.FUN’ of 5.67 KiB, function ‘x_FUN’ of 680 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:19.515] Packages: 1 packages (‘future.apply’)
[08:26:19.515] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:19.515] Resolved: TRUE
[08:26:19.515] Value: 666 bytes of class ‘list’
[08:26:19.515] Early signaling: FALSE
[08:26:19.515] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:19.515] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.516] Chunk #1 of 1 ... DONE
[08:26:19.516] Launching 1 futures (chunks) ... DONE
[08:26:19.516] Resolving 1 futures (chunks) ...
[08:26:19.516] resolve() on list ...
[08:26:19.516]  recursive: 0
[08:26:19.516]  length: 1
[08:26:19.516] 
[08:26:19.517] resolved() for ‘SequentialFuture’ ...
[08:26:19.517] - state: ‘finished’
[08:26:19.517] - run: TRUE
[08:26:19.517] - result: ‘FutureResult’
[08:26:19.517] resolved() for ‘SequentialFuture’ ... done
[08:26:19.517] Future #1
[08:26:19.517] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:19.517] - nx: 1
[08:26:19.517] - relay: TRUE
[08:26:19.517] - stdout: TRUE
[08:26:19.518] - signal: TRUE
[08:26:19.518] - resignal: FALSE
[08:26:19.518] - force: TRUE
[08:26:19.518] - relayed: [n=1] FALSE
[08:26:19.518] - queued futures: [n=1] FALSE
[08:26:19.518]  - until=1
[08:26:19.518]  - relaying element #1
[08:26:19.518] - relayed: [n=1] TRUE
[08:26:19.518] - queued futures: [n=1] TRUE
[08:26:19.518] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:19.518]  length: 0 (resolved future 1)
[08:26:19.519] Relaying remaining futures
[08:26:19.519] signalConditionsASAP(NULL, pos=0) ...
[08:26:19.519] - nx: 1
[08:26:19.519] - relay: TRUE
[08:26:19.519] - stdout: TRUE
[08:26:19.519] - signal: TRUE
[08:26:19.519] - resignal: FALSE
[08:26:19.519] - force: TRUE
[08:26:19.519] - relayed: [n=1] TRUE
[08:26:19.519] - queued futures: [n=1] TRUE
 - flush all
[08:26:19.519] - relayed: [n=1] TRUE
[08:26:19.519] - queued futures: [n=1] TRUE
[08:26:19.520] signalConditionsASAP(NULL, pos=0) ... done
[08:26:19.520] resolve() on list ... DONE
[08:26:19.520]  - Number of value chunks collected: 1
[08:26:19.520] Resolving 1 futures (chunks) ... DONE
[08:26:19.520] Reducing values from 1 chunks ...
[08:26:19.520]  - Number of values collected after concatenation: 4
[08:26:19.520]  - Number of values expected: 4
[08:26:19.520] Reducing values from 1 chunks ... DONE
[08:26:19.520] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[08:26:19.522] future_lapply() ...
[08:26:19.524] Number of chunks: 1
[08:26:19.524] getGlobalsAndPackagesXApply() ...
[08:26:19.524]  - future.globals: TRUE
[08:26:19.524] getGlobalsAndPackages() ...
[08:26:19.524] Searching for globals...
[08:26:19.529] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[08:26:19.529] Searching for globals ... DONE
[08:26:19.529] Resolving globals: FALSE
[08:26:19.530] The total size of the 7 globals is 14.73 KiB (15079 bytes)
[08:26:19.531] The total size of the 7 globals exported for future expression (‘FUN()’) is 14.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (6.74 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:19.531] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.531] - packages: [1] ‘future.apply’
[08:26:19.531] getGlobalsAndPackages() ... DONE
[08:26:19.531]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.531]  - needed namespaces: [n=1] ‘future.apply’
[08:26:19.531] Finding globals ... DONE
[08:26:19.531]  - use_args: TRUE
[08:26:19.531]  - Getting '...' globals ...
[08:26:19.532] resolve() on list ...
[08:26:19.532]  recursive: 0
[08:26:19.532]  length: 1
[08:26:19.532]  elements: ‘...’
[08:26:19.532]  length: 0 (resolved future 1)
[08:26:19.532] resolve() on list ... DONE
[08:26:19.532]    - '...' content: [n=0] 
[08:26:19.532] List of 1
[08:26:19.532]  $ ...: list()
[08:26:19.532]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.532]  - attr(*, "where")=List of 1
[08:26:19.532]   ..$ ...:<environment: 0x562ca7cf8848> 
[08:26:19.532]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.532]  - attr(*, "resolved")= logi TRUE
[08:26:19.532]  - attr(*, "total_size")= num NA
[08:26:19.535]  - Getting '...' globals ... DONE
[08:26:19.535] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:19.535] List of 8
[08:26:19.535]  $ ...future.FUN:function (x, ...)  
[08:26:19.535]  $ x_FUN        :function (x)  
[08:26:19.535]  $ times        : int 1
[08:26:19.535]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.535]  $ stop_if_not  :function (...)  
[08:26:19.535]  $ dim          : NULL
[08:26:19.535]  $ valid_types  : chr "logical"
[08:26:19.535]  $ ...          : list()
[08:26:19.535]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.535]  - attr(*, "where")=List of 8
[08:26:19.535]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:19.535]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:19.535]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:19.535]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:19.535]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:19.535]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:19.535]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:19.535]   ..$ ...          :<environment: 0x562ca7cf8848> 
[08:26:19.535]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.535]  - attr(*, "resolved")= logi FALSE
[08:26:19.535]  - attr(*, "total_size")= num 30734
[08:26:19.540] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:19.540] getGlobalsAndPackagesXApply() ... DONE
[08:26:19.540] Number of futures (= number of chunks): 1
[08:26:19.541] Launching 1 futures (chunks) ...
[08:26:19.541] Chunk #1 of 1 ...
[08:26:19.541]  - Finding globals in 'X' for chunk #1 ...
[08:26:19.541] getGlobalsAndPackages() ...
[08:26:19.541] Searching for globals...
[08:26:19.541] 
[08:26:19.541] Searching for globals ... DONE
[08:26:19.541] - globals: [0] <none>
[08:26:19.541] getGlobalsAndPackages() ... DONE
[08:26:19.542]    + additional globals found: [n=0] 
[08:26:19.542]    + additional namespaces needed: [n=0] 
[08:26:19.542]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:19.542]  - seeds: <none>
[08:26:19.542]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.542] getGlobalsAndPackages() ...
[08:26:19.542] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.542] Resolving globals: FALSE
[08:26:19.542] Tweak future expression to call with '...' arguments ...
[08:26:19.542] {
[08:26:19.542]     do.call(function(...) {
[08:26:19.542]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.542]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.542]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.542]             on.exit(options(oopts), add = TRUE)
[08:26:19.542]         }
[08:26:19.542]         {
[08:26:19.542]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.542]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.542]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.542]             })
[08:26:19.542]         }
[08:26:19.542]     }, args = future.call.arguments)
[08:26:19.542] }
[08:26:19.543] Tweak future expression to call with '...' arguments ... DONE
[08:26:19.543] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.543] - packages: [1] ‘future.apply’
[08:26:19.543] getGlobalsAndPackages() ... DONE
[08:26:19.544] run() for ‘Future’ ...
[08:26:19.544] - state: ‘created’
[08:26:19.544] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:26:19.544] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.544] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:19.544]   - Field: ‘label’
[08:26:19.544]   - Field: ‘local’
[08:26:19.545]   - Field: ‘owner’
[08:26:19.545]   - Field: ‘envir’
[08:26:19.545]   - Field: ‘packages’
[08:26:19.545]   - Field: ‘gc’
[08:26:19.545]   - Field: ‘conditions’
[08:26:19.545]   - Field: ‘expr’
[08:26:19.545]   - Field: ‘uuid’
[08:26:19.545]   - Field: ‘seed’
[08:26:19.545]   - Field: ‘version’
[08:26:19.545]   - Field: ‘result’
[08:26:19.545]   - Field: ‘asynchronous’
[08:26:19.545]   - Field: ‘calls’
[08:26:19.546]   - Field: ‘globals’
[08:26:19.546]   - Field: ‘stdout’
[08:26:19.546]   - Field: ‘earlySignal’
[08:26:19.546]   - Field: ‘lazy’
[08:26:19.546]   - Field: ‘state’
[08:26:19.546] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:19.546] - Launch lazy future ...
[08:26:19.546] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:19.546] Packages needed by future strategies (n = 0): <none>
[08:26:19.547] {
[08:26:19.547]     {
[08:26:19.547]         {
[08:26:19.547]             ...future.startTime <- base::Sys.time()
[08:26:19.547]             {
[08:26:19.547]                 {
[08:26:19.547]                   {
[08:26:19.547]                     {
[08:26:19.547]                       base::local({
[08:26:19.547]                         has_future <- base::requireNamespace("future", 
[08:26:19.547]                           quietly = TRUE)
[08:26:19.547]                         if (has_future) {
[08:26:19.547]                           ns <- base::getNamespace("future")
[08:26:19.547]                           version <- ns[[".package"]][["version"]]
[08:26:19.547]                           if (is.null(version)) 
[08:26:19.547]                             version <- utils::packageVersion("future")
[08:26:19.547]                         }
[08:26:19.547]                         else {
[08:26:19.547]                           version <- NULL
[08:26:19.547]                         }
[08:26:19.547]                         if (!has_future || version < "1.8.0") {
[08:26:19.547]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:19.547]                             "", base::R.version$version.string), 
[08:26:19.547]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:19.547]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:19.547]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:19.547]                               "release", "version")], collapse = " "), 
[08:26:19.547]                             hostname = base::Sys.info()[["nodename"]])
[08:26:19.547]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:19.547]                             info)
[08:26:19.547]                           info <- base::paste(info, collapse = "; ")
[08:26:19.547]                           if (!has_future) {
[08:26:19.547]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:19.547]                               info)
[08:26:19.547]                           }
[08:26:19.547]                           else {
[08:26:19.547]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:19.547]                               info, version)
[08:26:19.547]                           }
[08:26:19.547]                           base::stop(msg)
[08:26:19.547]                         }
[08:26:19.547]                       })
[08:26:19.547]                     }
[08:26:19.547]                     base::local({
[08:26:19.547]                       for (pkg in "future.apply") {
[08:26:19.547]                         base::loadNamespace(pkg)
[08:26:19.547]                         base::library(pkg, character.only = TRUE)
[08:26:19.547]                       }
[08:26:19.547]                     })
[08:26:19.547]                   }
[08:26:19.547]                   ...future.strategy.old <- future::plan("list")
[08:26:19.547]                   options(future.plan = NULL)
[08:26:19.547]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.547]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:19.547]                 }
[08:26:19.547]                 ...future.workdir <- getwd()
[08:26:19.547]             }
[08:26:19.547]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:19.547]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:19.547]         }
[08:26:19.547]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:19.547]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:19.547]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:19.547]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:19.547]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:19.547]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:19.547]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:19.547]             base::names(...future.oldOptions))
[08:26:19.547]     }
[08:26:19.547]     if (FALSE) {
[08:26:19.547]     }
[08:26:19.547]     else {
[08:26:19.547]         if (TRUE) {
[08:26:19.547]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:19.547]                 open = "w")
[08:26:19.547]         }
[08:26:19.547]         else {
[08:26:19.547]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:19.547]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:19.547]         }
[08:26:19.547]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:19.547]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:19.547]             base::sink(type = "output", split = FALSE)
[08:26:19.547]             base::close(...future.stdout)
[08:26:19.547]         }, add = TRUE)
[08:26:19.547]     }
[08:26:19.547]     ...future.frame <- base::sys.nframe()
[08:26:19.547]     ...future.conditions <- base::list()
[08:26:19.547]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:19.547]     if (FALSE) {
[08:26:19.547]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:19.547]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:19.547]     }
[08:26:19.547]     ...future.result <- base::tryCatch({
[08:26:19.547]         base::withCallingHandlers({
[08:26:19.547]             ...future.value <- base::withVisible(base::local({
[08:26:19.547]                 do.call(function(...) {
[08:26:19.547]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.547]                   if (!identical(...future.globals.maxSize.org, 
[08:26:19.547]                     ...future.globals.maxSize)) {
[08:26:19.547]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.547]                     on.exit(options(oopts), add = TRUE)
[08:26:19.547]                   }
[08:26:19.547]                   {
[08:26:19.547]                     lapply(seq_along(...future.elements_ii), 
[08:26:19.547]                       FUN = function(jj) {
[08:26:19.547]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.547]                         ...future.FUN(...future.X_jj, ...)
[08:26:19.547]                       })
[08:26:19.547]                   }
[08:26:19.547]                 }, args = future.call.arguments)
[08:26:19.547]             }))
[08:26:19.547]             future::FutureResult(value = ...future.value$value, 
[08:26:19.547]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.547]                   ...future.rng), globalenv = if (FALSE) 
[08:26:19.547]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:19.547]                     ...future.globalenv.names))
[08:26:19.547]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:19.547]         }, condition = base::local({
[08:26:19.547]             c <- base::c
[08:26:19.547]             inherits <- base::inherits
[08:26:19.547]             invokeRestart <- base::invokeRestart
[08:26:19.547]             length <- base::length
[08:26:19.547]             list <- base::list
[08:26:19.547]             seq.int <- base::seq.int
[08:26:19.547]             signalCondition <- base::signalCondition
[08:26:19.547]             sys.calls <- base::sys.calls
[08:26:19.547]             `[[` <- base::`[[`
[08:26:19.547]             `+` <- base::`+`
[08:26:19.547]             `<<-` <- base::`<<-`
[08:26:19.547]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:19.547]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:19.547]                   3L)]
[08:26:19.547]             }
[08:26:19.547]             function(cond) {
[08:26:19.547]                 is_error <- inherits(cond, "error")
[08:26:19.547]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:19.547]                   NULL)
[08:26:19.547]                 if (is_error) {
[08:26:19.547]                   sessionInformation <- function() {
[08:26:19.547]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:19.547]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:19.547]                       search = base::search(), system = base::Sys.info())
[08:26:19.547]                   }
[08:26:19.547]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.547]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:19.547]                     cond$call), session = sessionInformation(), 
[08:26:19.547]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:19.547]                   signalCondition(cond)
[08:26:19.547]                 }
[08:26:19.547]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:19.547]                 "immediateCondition"))) {
[08:26:19.547]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:19.547]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.547]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:19.547]                   if (TRUE && !signal) {
[08:26:19.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.547]                     {
[08:26:19.547]                       inherits <- base::inherits
[08:26:19.547]                       invokeRestart <- base::invokeRestart
[08:26:19.547]                       is.null <- base::is.null
[08:26:19.547]                       muffled <- FALSE
[08:26:19.547]                       if (inherits(cond, "message")) {
[08:26:19.547]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.547]                         if (muffled) 
[08:26:19.547]                           invokeRestart("muffleMessage")
[08:26:19.547]                       }
[08:26:19.547]                       else if (inherits(cond, "warning")) {
[08:26:19.547]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.547]                         if (muffled) 
[08:26:19.547]                           invokeRestart("muffleWarning")
[08:26:19.547]                       }
[08:26:19.547]                       else if (inherits(cond, "condition")) {
[08:26:19.547]                         if (!is.null(pattern)) {
[08:26:19.547]                           computeRestarts <- base::computeRestarts
[08:26:19.547]                           grepl <- base::grepl
[08:26:19.547]                           restarts <- computeRestarts(cond)
[08:26:19.547]                           for (restart in restarts) {
[08:26:19.547]                             name <- restart$name
[08:26:19.547]                             if (is.null(name)) 
[08:26:19.547]                               next
[08:26:19.547]                             if (!grepl(pattern, name)) 
[08:26:19.547]                               next
[08:26:19.547]                             invokeRestart(restart)
[08:26:19.547]                             muffled <- TRUE
[08:26:19.547]                             break
[08:26:19.547]                           }
[08:26:19.547]                         }
[08:26:19.547]                       }
[08:26:19.547]                       invisible(muffled)
[08:26:19.547]                     }
[08:26:19.547]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.547]                   }
[08:26:19.547]                 }
[08:26:19.547]                 else {
[08:26:19.547]                   if (TRUE) {
[08:26:19.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.547]                     {
[08:26:19.547]                       inherits <- base::inherits
[08:26:19.547]                       invokeRestart <- base::invokeRestart
[08:26:19.547]                       is.null <- base::is.null
[08:26:19.547]                       muffled <- FALSE
[08:26:19.547]                       if (inherits(cond, "message")) {
[08:26:19.547]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.547]                         if (muffled) 
[08:26:19.547]                           invokeRestart("muffleMessage")
[08:26:19.547]                       }
[08:26:19.547]                       else if (inherits(cond, "warning")) {
[08:26:19.547]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.547]                         if (muffled) 
[08:26:19.547]                           invokeRestart("muffleWarning")
[08:26:19.547]                       }
[08:26:19.547]                       else if (inherits(cond, "condition")) {
[08:26:19.547]                         if (!is.null(pattern)) {
[08:26:19.547]                           computeRestarts <- base::computeRestarts
[08:26:19.547]                           grepl <- base::grepl
[08:26:19.547]                           restarts <- computeRestarts(cond)
[08:26:19.547]                           for (restart in restarts) {
[08:26:19.547]                             name <- restart$name
[08:26:19.547]                             if (is.null(name)) 
[08:26:19.547]                               next
[08:26:19.547]                             if (!grepl(pattern, name)) 
[08:26:19.547]                               next
[08:26:19.547]                             invokeRestart(restart)
[08:26:19.547]                             muffled <- TRUE
[08:26:19.547]                             break
[08:26:19.547]                           }
[08:26:19.547]                         }
[08:26:19.547]                       }
[08:26:19.547]                       invisible(muffled)
[08:26:19.547]                     }
[08:26:19.547]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.547]                   }
[08:26:19.547]                 }
[08:26:19.547]             }
[08:26:19.547]         }))
[08:26:19.547]     }, error = function(ex) {
[08:26:19.547]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:19.547]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.547]                 ...future.rng), started = ...future.startTime, 
[08:26:19.547]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:19.547]             version = "1.8"), class = "FutureResult")
[08:26:19.547]     }, finally = {
[08:26:19.547]         if (!identical(...future.workdir, getwd())) 
[08:26:19.547]             setwd(...future.workdir)
[08:26:19.547]         {
[08:26:19.547]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:19.547]                 ...future.oldOptions$nwarnings <- NULL
[08:26:19.547]             }
[08:26:19.547]             base::options(...future.oldOptions)
[08:26:19.547]             if (.Platform$OS.type == "windows") {
[08:26:19.547]                 old_names <- names(...future.oldEnvVars)
[08:26:19.547]                 envs <- base::Sys.getenv()
[08:26:19.547]                 names <- names(envs)
[08:26:19.547]                 common <- intersect(names, old_names)
[08:26:19.547]                 added <- setdiff(names, old_names)
[08:26:19.547]                 removed <- setdiff(old_names, names)
[08:26:19.547]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:19.547]                   envs[common]]
[08:26:19.547]                 NAMES <- toupper(changed)
[08:26:19.547]                 args <- list()
[08:26:19.547]                 for (kk in seq_along(NAMES)) {
[08:26:19.547]                   name <- changed[[kk]]
[08:26:19.547]                   NAME <- NAMES[[kk]]
[08:26:19.547]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.547]                     next
[08:26:19.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.547]                 }
[08:26:19.547]                 NAMES <- toupper(added)
[08:26:19.547]                 for (kk in seq_along(NAMES)) {
[08:26:19.547]                   name <- added[[kk]]
[08:26:19.547]                   NAME <- NAMES[[kk]]
[08:26:19.547]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.547]                     next
[08:26:19.547]                   args[[name]] <- ""
[08:26:19.547]                 }
[08:26:19.547]                 NAMES <- toupper(removed)
[08:26:19.547]                 for (kk in seq_along(NAMES)) {
[08:26:19.547]                   name <- removed[[kk]]
[08:26:19.547]                   NAME <- NAMES[[kk]]
[08:26:19.547]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.547]                     next
[08:26:19.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.547]                 }
[08:26:19.547]                 if (length(args) > 0) 
[08:26:19.547]                   base::do.call(base::Sys.setenv, args = args)
[08:26:19.547]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:19.547]             }
[08:26:19.547]             else {
[08:26:19.547]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:19.547]             }
[08:26:19.547]             {
[08:26:19.547]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:19.547]                   0L) {
[08:26:19.547]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:19.547]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:19.547]                   base::options(opts)
[08:26:19.547]                 }
[08:26:19.547]                 {
[08:26:19.547]                   {
[08:26:19.547]                     NULL
[08:26:19.547]                     RNGkind("Mersenne-Twister")
[08:26:19.547]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:19.547]                       inherits = FALSE)
[08:26:19.547]                   }
[08:26:19.547]                   options(future.plan = NULL)
[08:26:19.547]                   if (is.na(NA_character_)) 
[08:26:19.547]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.547]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:19.547]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:19.547]                     .init = FALSE)
[08:26:19.547]                 }
[08:26:19.547]             }
[08:26:19.547]         }
[08:26:19.547]     })
[08:26:19.547]     if (TRUE) {
[08:26:19.547]         base::sink(type = "output", split = FALSE)
[08:26:19.547]         if (TRUE) {
[08:26:19.547]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:19.547]         }
[08:26:19.547]         else {
[08:26:19.547]             ...future.result["stdout"] <- base::list(NULL)
[08:26:19.547]         }
[08:26:19.547]         base::close(...future.stdout)
[08:26:19.547]         ...future.stdout <- NULL
[08:26:19.547]     }
[08:26:19.547]     ...future.result$conditions <- ...future.conditions
[08:26:19.547]     ...future.result$finished <- base::Sys.time()
[08:26:19.547]     ...future.result
[08:26:19.547] }
[08:26:19.549] assign_globals() ...
[08:26:19.549] List of 11
[08:26:19.549]  $ ...future.FUN            :function (x, ...)  
[08:26:19.549]  $ x_FUN                    :function (x)  
[08:26:19.549]  $ times                    : int 1
[08:26:19.549]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.549]  $ stop_if_not              :function (...)  
[08:26:19.549]  $ dim                      : NULL
[08:26:19.549]  $ valid_types              : chr "logical"
[08:26:19.549]  $ future.call.arguments    : list()
[08:26:19.549]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.549]  $ ...future.elements_ii    :List of 11
[08:26:19.549]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[08:26:19.549]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[08:26:19.549]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[08:26:19.549]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[08:26:19.549]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[08:26:19.549]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[08:26:19.549]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[08:26:19.549]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[08:26:19.549]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[08:26:19.549]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[08:26:19.549]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[08:26:19.549]  $ ...future.seeds_ii       : NULL
[08:26:19.549]  $ ...future.globals.maxSize: NULL
[08:26:19.549]  - attr(*, "where")=List of 11
[08:26:19.549]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:19.549]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:19.549]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:19.549]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:19.549]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:19.549]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:19.549]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:19.549]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:19.549]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:19.549]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:19.549]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:19.549]  - attr(*, "resolved")= logi FALSE
[08:26:19.549]  - attr(*, "total_size")= num 30734
[08:26:19.549]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.549]  - attr(*, "already-done")= logi TRUE
[08:26:19.561] - copied ‘...future.FUN’ to environment
[08:26:19.561] - copied ‘x_FUN’ to environment
[08:26:19.561] - copied ‘times’ to environment
[08:26:19.561] - copied ‘stopf’ to environment
[08:26:19.561] - copied ‘stop_if_not’ to environment
[08:26:19.561] - copied ‘dim’ to environment
[08:26:19.561] - copied ‘valid_types’ to environment
[08:26:19.561] - copied ‘future.call.arguments’ to environment
[08:26:19.562] - copied ‘...future.elements_ii’ to environment
[08:26:19.562] - copied ‘...future.seeds_ii’ to environment
[08:26:19.562] - copied ‘...future.globals.maxSize’ to environment
[08:26:19.562] assign_globals() ... done
[08:26:19.562] plan(): Setting new future strategy stack:
[08:26:19.562] List of future strategies:
[08:26:19.562] 1. sequential:
[08:26:19.562]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.562]    - tweaked: FALSE
[08:26:19.562]    - call: NULL
[08:26:19.563] plan(): nbrOfWorkers() = 1
[08:26:19.564] plan(): Setting new future strategy stack:
[08:26:19.564] List of future strategies:
[08:26:19.564] 1. sequential:
[08:26:19.564]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.564]    - tweaked: FALSE
[08:26:19.564]    - call: plan(strategy)
[08:26:19.564] plan(): nbrOfWorkers() = 1
[08:26:19.564] SequentialFuture started (and completed)
[08:26:19.564] - Launch lazy future ... done
[08:26:19.565] run() for ‘SequentialFuture’ ... done
[08:26:19.565] Created future:
[08:26:19.565] SequentialFuture:
[08:26:19.565] Label: ‘future_vapply-1’
[08:26:19.565] Expression:
[08:26:19.565] {
[08:26:19.565]     do.call(function(...) {
[08:26:19.565]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.565]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.565]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.565]             on.exit(options(oopts), add = TRUE)
[08:26:19.565]         }
[08:26:19.565]         {
[08:26:19.565]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.565]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.565]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.565]             })
[08:26:19.565]         }
[08:26:19.565]     }, args = future.call.arguments)
[08:26:19.565] }
[08:26:19.565] Lazy evaluation: FALSE
[08:26:19.565] Asynchronous evaluation: FALSE
[08:26:19.565] Local evaluation: TRUE
[08:26:19.565] Environment: R_GlobalEnv
[08:26:19.565] Capture standard output: TRUE
[08:26:19.565] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:19.565] Globals: 11 objects totaling 17.89 KiB (function ‘...future.FUN’ of 6.73 KiB, function ‘x_FUN’ of 41 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:19.565] Packages: 1 packages (‘future.apply’)
[08:26:19.565] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:19.565] Resolved: TRUE
[08:26:19.565] Value: 163 bytes of class ‘list’
[08:26:19.565] Early signaling: FALSE
[08:26:19.565] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:19.565] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.566] Chunk #1 of 1 ... DONE
[08:26:19.566] Launching 1 futures (chunks) ... DONE
[08:26:19.566] Resolving 1 futures (chunks) ...
[08:26:19.566] resolve() on list ...
[08:26:19.566]  recursive: 0
[08:26:19.566]  length: 1
[08:26:19.566] 
[08:26:19.566] resolved() for ‘SequentialFuture’ ...
[08:26:19.566] - state: ‘finished’
[08:26:19.566] - run: TRUE
[08:26:19.567] - result: ‘FutureResult’
[08:26:19.567] resolved() for ‘SequentialFuture’ ... done
[08:26:19.567] Future #1
[08:26:19.567] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:19.567] - nx: 1
[08:26:19.567] - relay: TRUE
[08:26:19.567] - stdout: TRUE
[08:26:19.567] - signal: TRUE
[08:26:19.567] - resignal: FALSE
[08:26:19.567] - force: TRUE
[08:26:19.567] - relayed: [n=1] FALSE
[08:26:19.568] - queued futures: [n=1] FALSE
[08:26:19.568]  - until=1
[08:26:19.568]  - relaying element #1
[08:26:19.568] - relayed: [n=1] TRUE
[08:26:19.568] - queued futures: [n=1] TRUE
[08:26:19.568] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:19.568]  length: 0 (resolved future 1)
[08:26:19.568] Relaying remaining futures
[08:26:19.568] signalConditionsASAP(NULL, pos=0) ...
[08:26:19.568] - nx: 1
[08:26:19.569] - relay: TRUE
[08:26:19.569] - stdout: TRUE
[08:26:19.569] - signal: TRUE
[08:26:19.569] - resignal: FALSE
[08:26:19.569] - force: TRUE
[08:26:19.569] - relayed: [n=1] TRUE
[08:26:19.569] - queued futures: [n=1] TRUE
 - flush all
[08:26:19.569] - relayed: [n=1] TRUE
[08:26:19.569] - queued futures: [n=1] TRUE
[08:26:19.569] signalConditionsASAP(NULL, pos=0) ... done
[08:26:19.569] resolve() on list ... DONE
[08:26:19.570]  - Number of value chunks collected: 1
[08:26:19.570] Resolving 1 futures (chunks) ... DONE
[08:26:19.570] Reducing values from 1 chunks ...
[08:26:19.570]  - Number of values collected after concatenation: 11
[08:26:19.570]  - Number of values expected: 11
[08:26:19.570] Reducing values from 1 chunks ... DONE
[08:26:19.570] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[08:26:19.572] future_lapply() ...
[08:26:19.574] Number of chunks: 1
[08:26:19.574] getGlobalsAndPackagesXApply() ...
[08:26:19.574]  - future.globals: TRUE
[08:26:19.574] getGlobalsAndPackages() ...
[08:26:19.574] Searching for globals...
[08:26:19.577] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[08:26:19.577] Searching for globals ... DONE
[08:26:19.578] Resolving globals: FALSE
[08:26:19.578] The total size of the 7 globals is 11.92 KiB (12201 bytes)
[08:26:19.579] The total size of the 7 globals exported for future expression (‘FUN()’) is 11.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (3.92 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:19.579] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.579] - packages: [1] ‘future.apply’
[08:26:19.579] getGlobalsAndPackages() ... DONE
[08:26:19.579]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.579]  - needed namespaces: [n=1] ‘future.apply’
[08:26:19.579] Finding globals ... DONE
[08:26:19.580]  - use_args: TRUE
[08:26:19.580]  - Getting '...' globals ...
[08:26:19.580] resolve() on list ...
[08:26:19.580]  recursive: 0
[08:26:19.580]  length: 1
[08:26:19.580]  elements: ‘...’
[08:26:19.580]  length: 0 (resolved future 1)
[08:26:19.580] resolve() on list ... DONE
[08:26:19.580]    - '...' content: [n=0] 
[08:26:19.581] List of 1
[08:26:19.581]  $ ...: list()
[08:26:19.581]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.581]  - attr(*, "where")=List of 1
[08:26:19.581]   ..$ ...:<environment: 0x562ca57661a8> 
[08:26:19.581]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.581]  - attr(*, "resolved")= logi TRUE
[08:26:19.581]  - attr(*, "total_size")= num NA
[08:26:19.583]  - Getting '...' globals ... DONE
[08:26:19.583] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:19.583] List of 8
[08:26:19.583]  $ ...future.FUN:function (x, ...)  
[08:26:19.583]  $ x_FUN        :function (x)  
[08:26:19.583]  $ times        : int 1
[08:26:19.583]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.583]  $ stop_if_not  :function (...)  
[08:26:19.583]  $ dim          : NULL
[08:26:19.583]  $ valid_types  : chr [1:2] "logical" "integer"
[08:26:19.583]  $ ...          : list()
[08:26:19.583]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.583]  - attr(*, "where")=List of 8
[08:26:19.583]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:19.583]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:19.583]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:19.583]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:19.583]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:19.583]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:19.583]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:19.583]   ..$ ...          :<environment: 0x562ca57661a8> 
[08:26:19.583]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.583]  - attr(*, "resolved")= logi FALSE
[08:26:19.583]  - attr(*, "total_size")= num 22016
[08:26:19.588] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:19.588] getGlobalsAndPackagesXApply() ... DONE
[08:26:19.589] Number of futures (= number of chunks): 1
[08:26:19.589] Launching 1 futures (chunks) ...
[08:26:19.589] Chunk #1 of 1 ...
[08:26:19.589]  - Finding globals in 'X' for chunk #1 ...
[08:26:19.589] getGlobalsAndPackages() ...
[08:26:19.589] Searching for globals...
[08:26:19.589] 
[08:26:19.589] Searching for globals ... DONE
[08:26:19.590] - globals: [0] <none>
[08:26:19.590] getGlobalsAndPackages() ... DONE
[08:26:19.590]    + additional globals found: [n=0] 
[08:26:19.590]    + additional namespaces needed: [n=0] 
[08:26:19.590]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:19.590]  - seeds: <none>
[08:26:19.590]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.590] getGlobalsAndPackages() ...
[08:26:19.590] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.590] Resolving globals: FALSE
[08:26:19.590] Tweak future expression to call with '...' arguments ...
[08:26:19.591] {
[08:26:19.591]     do.call(function(...) {
[08:26:19.591]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.591]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.591]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.591]             on.exit(options(oopts), add = TRUE)
[08:26:19.591]         }
[08:26:19.591]         {
[08:26:19.591]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.591]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.591]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.591]             })
[08:26:19.591]         }
[08:26:19.591]     }, args = future.call.arguments)
[08:26:19.591] }
[08:26:19.591] Tweak future expression to call with '...' arguments ... DONE
[08:26:19.591] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.591] - packages: [1] ‘future.apply’
[08:26:19.591] getGlobalsAndPackages() ... DONE
[08:26:19.592] run() for ‘Future’ ...
[08:26:19.593] - state: ‘created’
[08:26:19.593] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:26:19.594] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.594] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:19.594]   - Field: ‘label’
[08:26:19.594]   - Field: ‘local’
[08:26:19.594]   - Field: ‘owner’
[08:26:19.594]   - Field: ‘envir’
[08:26:19.594]   - Field: ‘packages’
[08:26:19.594]   - Field: ‘gc’
[08:26:19.595]   - Field: ‘conditions’
[08:26:19.595]   - Field: ‘expr’
[08:26:19.595]   - Field: ‘uuid’
[08:26:19.595]   - Field: ‘seed’
[08:26:19.595]   - Field: ‘version’
[08:26:19.595]   - Field: ‘result’
[08:26:19.595]   - Field: ‘asynchronous’
[08:26:19.595]   - Field: ‘calls’
[08:26:19.595]   - Field: ‘globals’
[08:26:19.595]   - Field: ‘stdout’
[08:26:19.595]   - Field: ‘earlySignal’
[08:26:19.596]   - Field: ‘lazy’
[08:26:19.596]   - Field: ‘state’
[08:26:19.596] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:19.596] - Launch lazy future ...
[08:26:19.596] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:19.596] Packages needed by future strategies (n = 0): <none>
[08:26:19.597] {
[08:26:19.597]     {
[08:26:19.597]         {
[08:26:19.597]             ...future.startTime <- base::Sys.time()
[08:26:19.597]             {
[08:26:19.597]                 {
[08:26:19.597]                   {
[08:26:19.597]                     {
[08:26:19.597]                       base::local({
[08:26:19.597]                         has_future <- base::requireNamespace("future", 
[08:26:19.597]                           quietly = TRUE)
[08:26:19.597]                         if (has_future) {
[08:26:19.597]                           ns <- base::getNamespace("future")
[08:26:19.597]                           version <- ns[[".package"]][["version"]]
[08:26:19.597]                           if (is.null(version)) 
[08:26:19.597]                             version <- utils::packageVersion("future")
[08:26:19.597]                         }
[08:26:19.597]                         else {
[08:26:19.597]                           version <- NULL
[08:26:19.597]                         }
[08:26:19.597]                         if (!has_future || version < "1.8.0") {
[08:26:19.597]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:19.597]                             "", base::R.version$version.string), 
[08:26:19.597]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:19.597]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:19.597]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:19.597]                               "release", "version")], collapse = " "), 
[08:26:19.597]                             hostname = base::Sys.info()[["nodename"]])
[08:26:19.597]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:19.597]                             info)
[08:26:19.597]                           info <- base::paste(info, collapse = "; ")
[08:26:19.597]                           if (!has_future) {
[08:26:19.597]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:19.597]                               info)
[08:26:19.597]                           }
[08:26:19.597]                           else {
[08:26:19.597]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:19.597]                               info, version)
[08:26:19.597]                           }
[08:26:19.597]                           base::stop(msg)
[08:26:19.597]                         }
[08:26:19.597]                       })
[08:26:19.597]                     }
[08:26:19.597]                     base::local({
[08:26:19.597]                       for (pkg in "future.apply") {
[08:26:19.597]                         base::loadNamespace(pkg)
[08:26:19.597]                         base::library(pkg, character.only = TRUE)
[08:26:19.597]                       }
[08:26:19.597]                     })
[08:26:19.597]                   }
[08:26:19.597]                   ...future.strategy.old <- future::plan("list")
[08:26:19.597]                   options(future.plan = NULL)
[08:26:19.597]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.597]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:19.597]                 }
[08:26:19.597]                 ...future.workdir <- getwd()
[08:26:19.597]             }
[08:26:19.597]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:19.597]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:19.597]         }
[08:26:19.597]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:19.597]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:19.597]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:19.597]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:19.597]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:19.597]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:19.597]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:19.597]             base::names(...future.oldOptions))
[08:26:19.597]     }
[08:26:19.597]     if (FALSE) {
[08:26:19.597]     }
[08:26:19.597]     else {
[08:26:19.597]         if (TRUE) {
[08:26:19.597]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:19.597]                 open = "w")
[08:26:19.597]         }
[08:26:19.597]         else {
[08:26:19.597]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:19.597]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:19.597]         }
[08:26:19.597]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:19.597]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:19.597]             base::sink(type = "output", split = FALSE)
[08:26:19.597]             base::close(...future.stdout)
[08:26:19.597]         }, add = TRUE)
[08:26:19.597]     }
[08:26:19.597]     ...future.frame <- base::sys.nframe()
[08:26:19.597]     ...future.conditions <- base::list()
[08:26:19.597]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:19.597]     if (FALSE) {
[08:26:19.597]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:19.597]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:19.597]     }
[08:26:19.597]     ...future.result <- base::tryCatch({
[08:26:19.597]         base::withCallingHandlers({
[08:26:19.597]             ...future.value <- base::withVisible(base::local({
[08:26:19.597]                 do.call(function(...) {
[08:26:19.597]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.597]                   if (!identical(...future.globals.maxSize.org, 
[08:26:19.597]                     ...future.globals.maxSize)) {
[08:26:19.597]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.597]                     on.exit(options(oopts), add = TRUE)
[08:26:19.597]                   }
[08:26:19.597]                   {
[08:26:19.597]                     lapply(seq_along(...future.elements_ii), 
[08:26:19.597]                       FUN = function(jj) {
[08:26:19.597]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.597]                         ...future.FUN(...future.X_jj, ...)
[08:26:19.597]                       })
[08:26:19.597]                   }
[08:26:19.597]                 }, args = future.call.arguments)
[08:26:19.597]             }))
[08:26:19.597]             future::FutureResult(value = ...future.value$value, 
[08:26:19.597]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.597]                   ...future.rng), globalenv = if (FALSE) 
[08:26:19.597]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:19.597]                     ...future.globalenv.names))
[08:26:19.597]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:19.597]         }, condition = base::local({
[08:26:19.597]             c <- base::c
[08:26:19.597]             inherits <- base::inherits
[08:26:19.597]             invokeRestart <- base::invokeRestart
[08:26:19.597]             length <- base::length
[08:26:19.597]             list <- base::list
[08:26:19.597]             seq.int <- base::seq.int
[08:26:19.597]             signalCondition <- base::signalCondition
[08:26:19.597]             sys.calls <- base::sys.calls
[08:26:19.597]             `[[` <- base::`[[`
[08:26:19.597]             `+` <- base::`+`
[08:26:19.597]             `<<-` <- base::`<<-`
[08:26:19.597]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:19.597]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:19.597]                   3L)]
[08:26:19.597]             }
[08:26:19.597]             function(cond) {
[08:26:19.597]                 is_error <- inherits(cond, "error")
[08:26:19.597]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:19.597]                   NULL)
[08:26:19.597]                 if (is_error) {
[08:26:19.597]                   sessionInformation <- function() {
[08:26:19.597]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:19.597]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:19.597]                       search = base::search(), system = base::Sys.info())
[08:26:19.597]                   }
[08:26:19.597]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.597]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:19.597]                     cond$call), session = sessionInformation(), 
[08:26:19.597]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:19.597]                   signalCondition(cond)
[08:26:19.597]                 }
[08:26:19.597]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:19.597]                 "immediateCondition"))) {
[08:26:19.597]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:19.597]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.597]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:19.597]                   if (TRUE && !signal) {
[08:26:19.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.597]                     {
[08:26:19.597]                       inherits <- base::inherits
[08:26:19.597]                       invokeRestart <- base::invokeRestart
[08:26:19.597]                       is.null <- base::is.null
[08:26:19.597]                       muffled <- FALSE
[08:26:19.597]                       if (inherits(cond, "message")) {
[08:26:19.597]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.597]                         if (muffled) 
[08:26:19.597]                           invokeRestart("muffleMessage")
[08:26:19.597]                       }
[08:26:19.597]                       else if (inherits(cond, "warning")) {
[08:26:19.597]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.597]                         if (muffled) 
[08:26:19.597]                           invokeRestart("muffleWarning")
[08:26:19.597]                       }
[08:26:19.597]                       else if (inherits(cond, "condition")) {
[08:26:19.597]                         if (!is.null(pattern)) {
[08:26:19.597]                           computeRestarts <- base::computeRestarts
[08:26:19.597]                           grepl <- base::grepl
[08:26:19.597]                           restarts <- computeRestarts(cond)
[08:26:19.597]                           for (restart in restarts) {
[08:26:19.597]                             name <- restart$name
[08:26:19.597]                             if (is.null(name)) 
[08:26:19.597]                               next
[08:26:19.597]                             if (!grepl(pattern, name)) 
[08:26:19.597]                               next
[08:26:19.597]                             invokeRestart(restart)
[08:26:19.597]                             muffled <- TRUE
[08:26:19.597]                             break
[08:26:19.597]                           }
[08:26:19.597]                         }
[08:26:19.597]                       }
[08:26:19.597]                       invisible(muffled)
[08:26:19.597]                     }
[08:26:19.597]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.597]                   }
[08:26:19.597]                 }
[08:26:19.597]                 else {
[08:26:19.597]                   if (TRUE) {
[08:26:19.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.597]                     {
[08:26:19.597]                       inherits <- base::inherits
[08:26:19.597]                       invokeRestart <- base::invokeRestart
[08:26:19.597]                       is.null <- base::is.null
[08:26:19.597]                       muffled <- FALSE
[08:26:19.597]                       if (inherits(cond, "message")) {
[08:26:19.597]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.597]                         if (muffled) 
[08:26:19.597]                           invokeRestart("muffleMessage")
[08:26:19.597]                       }
[08:26:19.597]                       else if (inherits(cond, "warning")) {
[08:26:19.597]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.597]                         if (muffled) 
[08:26:19.597]                           invokeRestart("muffleWarning")
[08:26:19.597]                       }
[08:26:19.597]                       else if (inherits(cond, "condition")) {
[08:26:19.597]                         if (!is.null(pattern)) {
[08:26:19.597]                           computeRestarts <- base::computeRestarts
[08:26:19.597]                           grepl <- base::grepl
[08:26:19.597]                           restarts <- computeRestarts(cond)
[08:26:19.597]                           for (restart in restarts) {
[08:26:19.597]                             name <- restart$name
[08:26:19.597]                             if (is.null(name)) 
[08:26:19.597]                               next
[08:26:19.597]                             if (!grepl(pattern, name)) 
[08:26:19.597]                               next
[08:26:19.597]                             invokeRestart(restart)
[08:26:19.597]                             muffled <- TRUE
[08:26:19.597]                             break
[08:26:19.597]                           }
[08:26:19.597]                         }
[08:26:19.597]                       }
[08:26:19.597]                       invisible(muffled)
[08:26:19.597]                     }
[08:26:19.597]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.597]                   }
[08:26:19.597]                 }
[08:26:19.597]             }
[08:26:19.597]         }))
[08:26:19.597]     }, error = function(ex) {
[08:26:19.597]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:19.597]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.597]                 ...future.rng), started = ...future.startTime, 
[08:26:19.597]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:19.597]             version = "1.8"), class = "FutureResult")
[08:26:19.597]     }, finally = {
[08:26:19.597]         if (!identical(...future.workdir, getwd())) 
[08:26:19.597]             setwd(...future.workdir)
[08:26:19.597]         {
[08:26:19.597]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:19.597]                 ...future.oldOptions$nwarnings <- NULL
[08:26:19.597]             }
[08:26:19.597]             base::options(...future.oldOptions)
[08:26:19.597]             if (.Platform$OS.type == "windows") {
[08:26:19.597]                 old_names <- names(...future.oldEnvVars)
[08:26:19.597]                 envs <- base::Sys.getenv()
[08:26:19.597]                 names <- names(envs)
[08:26:19.597]                 common <- intersect(names, old_names)
[08:26:19.597]                 added <- setdiff(names, old_names)
[08:26:19.597]                 removed <- setdiff(old_names, names)
[08:26:19.597]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:19.597]                   envs[common]]
[08:26:19.597]                 NAMES <- toupper(changed)
[08:26:19.597]                 args <- list()
[08:26:19.597]                 for (kk in seq_along(NAMES)) {
[08:26:19.597]                   name <- changed[[kk]]
[08:26:19.597]                   NAME <- NAMES[[kk]]
[08:26:19.597]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.597]                     next
[08:26:19.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.597]                 }
[08:26:19.597]                 NAMES <- toupper(added)
[08:26:19.597]                 for (kk in seq_along(NAMES)) {
[08:26:19.597]                   name <- added[[kk]]
[08:26:19.597]                   NAME <- NAMES[[kk]]
[08:26:19.597]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.597]                     next
[08:26:19.597]                   args[[name]] <- ""
[08:26:19.597]                 }
[08:26:19.597]                 NAMES <- toupper(removed)
[08:26:19.597]                 for (kk in seq_along(NAMES)) {
[08:26:19.597]                   name <- removed[[kk]]
[08:26:19.597]                   NAME <- NAMES[[kk]]
[08:26:19.597]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.597]                     next
[08:26:19.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.597]                 }
[08:26:19.597]                 if (length(args) > 0) 
[08:26:19.597]                   base::do.call(base::Sys.setenv, args = args)
[08:26:19.597]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:19.597]             }
[08:26:19.597]             else {
[08:26:19.597]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:19.597]             }
[08:26:19.597]             {
[08:26:19.597]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:19.597]                   0L) {
[08:26:19.597]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:19.597]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:19.597]                   base::options(opts)
[08:26:19.597]                 }
[08:26:19.597]                 {
[08:26:19.597]                   {
[08:26:19.597]                     NULL
[08:26:19.597]                     RNGkind("Mersenne-Twister")
[08:26:19.597]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:19.597]                       inherits = FALSE)
[08:26:19.597]                   }
[08:26:19.597]                   options(future.plan = NULL)
[08:26:19.597]                   if (is.na(NA_character_)) 
[08:26:19.597]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.597]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:19.597]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:19.597]                     .init = FALSE)
[08:26:19.597]                 }
[08:26:19.597]             }
[08:26:19.597]         }
[08:26:19.597]     })
[08:26:19.597]     if (TRUE) {
[08:26:19.597]         base::sink(type = "output", split = FALSE)
[08:26:19.597]         if (TRUE) {
[08:26:19.597]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:19.597]         }
[08:26:19.597]         else {
[08:26:19.597]             ...future.result["stdout"] <- base::list(NULL)
[08:26:19.597]         }
[08:26:19.597]         base::close(...future.stdout)
[08:26:19.597]         ...future.stdout <- NULL
[08:26:19.597]     }
[08:26:19.597]     ...future.result$conditions <- ...future.conditions
[08:26:19.597]     ...future.result$finished <- base::Sys.time()
[08:26:19.597]     ...future.result
[08:26:19.597] }
[08:26:19.598] assign_globals() ...
[08:26:19.598] List of 11
[08:26:19.598]  $ ...future.FUN            :function (x, ...)  
[08:26:19.598]  $ x_FUN                    :function (x)  
[08:26:19.598]  $ times                    : int 1
[08:26:19.598]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.598]  $ stop_if_not              :function (...)  
[08:26:19.598]  $ dim                      : NULL
[08:26:19.598]  $ valid_types              : chr [1:2] "logical" "integer"
[08:26:19.598]  $ future.call.arguments    : list()
[08:26:19.598]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.598]  $ ...future.elements_ii    :List of 3
[08:26:19.598]   ..$ a: num 1
[08:26:19.598]   ..$ b: num 2
[08:26:19.598]   ..$ c: num 3
[08:26:19.598]  $ ...future.seeds_ii       : NULL
[08:26:19.598]  $ ...future.globals.maxSize: NULL
[08:26:19.598]  - attr(*, "where")=List of 11
[08:26:19.598]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:19.598]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:19.598]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:19.598]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:19.598]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:19.598]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:19.598]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:19.598]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:19.598]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:19.598]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:19.598]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:19.598]  - attr(*, "resolved")= logi FALSE
[08:26:19.598]  - attr(*, "total_size")= num 22016
[08:26:19.598]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.598]  - attr(*, "already-done")= logi TRUE
[08:26:19.606] - copied ‘...future.FUN’ to environment
[08:26:19.606] - copied ‘x_FUN’ to environment
[08:26:19.606] - copied ‘times’ to environment
[08:26:19.606] - copied ‘stopf’ to environment
[08:26:19.606] - copied ‘stop_if_not’ to environment
[08:26:19.607] - copied ‘dim’ to environment
[08:26:19.607] - copied ‘valid_types’ to environment
[08:26:19.607] - copied ‘future.call.arguments’ to environment
[08:26:19.607] - copied ‘...future.elements_ii’ to environment
[08:26:19.607] - copied ‘...future.seeds_ii’ to environment
[08:26:19.607] - copied ‘...future.globals.maxSize’ to environment
[08:26:19.607] assign_globals() ... done
[08:26:19.607] plan(): Setting new future strategy stack:
[08:26:19.608] List of future strategies:
[08:26:19.608] 1. sequential:
[08:26:19.608]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.608]    - tweaked: FALSE
[08:26:19.608]    - call: NULL
[08:26:19.608] plan(): nbrOfWorkers() = 1
[08:26:19.609] plan(): Setting new future strategy stack:
[08:26:19.609] List of future strategies:
[08:26:19.609] 1. sequential:
[08:26:19.609]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.609]    - tweaked: FALSE
[08:26:19.609]    - call: plan(strategy)
[08:26:19.609] plan(): nbrOfWorkers() = 1
[08:26:19.609] SequentialFuture started (and completed)
[08:26:19.610] - Launch lazy future ... done
[08:26:19.610] run() for ‘SequentialFuture’ ... done
[08:26:19.610] Created future:
[08:26:19.610] SequentialFuture:
[08:26:19.610] Label: ‘future_vapply-1’
[08:26:19.610] Expression:
[08:26:19.610] {
[08:26:19.610]     do.call(function(...) {
[08:26:19.610]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.610]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.610]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.610]             on.exit(options(oopts), add = TRUE)
[08:26:19.610]         }
[08:26:19.610]         {
[08:26:19.610]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.610]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.610]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.610]             })
[08:26:19.610]         }
[08:26:19.610]     }, args = future.call.arguments)
[08:26:19.610] }
[08:26:19.610] Lazy evaluation: FALSE
[08:26:19.610] Asynchronous evaluation: FALSE
[08:26:19.610] Local evaluation: TRUE
[08:26:19.610] Environment: R_GlobalEnv
[08:26:19.610] Capture standard output: TRUE
[08:26:19.610] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:19.610] Globals: 11 objects totaling 12.19 KiB (function ‘...future.FUN’ of 3.91 KiB, function ‘x_FUN’ of 37 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:19.610] Packages: 1 packages (‘future.apply’)
[08:26:19.610] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:19.610] Resolved: TRUE
[08:26:19.610] Value: 67 bytes of class ‘list’
[08:26:19.610] Early signaling: FALSE
[08:26:19.610] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:19.610] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.611] Chunk #1 of 1 ... DONE
[08:26:19.611] Launching 1 futures (chunks) ... DONE
[08:26:19.611] Resolving 1 futures (chunks) ...
[08:26:19.611] resolve() on list ...
[08:26:19.611]  recursive: 0
[08:26:19.611]  length: 1
[08:26:19.611] 
[08:26:19.611] resolved() for ‘SequentialFuture’ ...
[08:26:19.612] - state: ‘finished’
[08:26:19.612] - run: TRUE
[08:26:19.612] - result: ‘FutureResult’
[08:26:19.612] resolved() for ‘SequentialFuture’ ... done
[08:26:19.612] Future #1
[08:26:19.612] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:19.612] - nx: 1
[08:26:19.612] - relay: TRUE
[08:26:19.612] - stdout: TRUE
[08:26:19.612] - signal: TRUE
[08:26:19.612] - resignal: FALSE
[08:26:19.613] - force: TRUE
[08:26:19.613] - relayed: [n=1] FALSE
[08:26:19.613] - queued futures: [n=1] FALSE
[08:26:19.613]  - until=1
[08:26:19.613]  - relaying element #1
[08:26:19.613] - relayed: [n=1] TRUE
[08:26:19.613] - queued futures: [n=1] TRUE
[08:26:19.613] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:19.613]  length: 0 (resolved future 1)
[08:26:19.613] Relaying remaining futures
[08:26:19.614] signalConditionsASAP(NULL, pos=0) ...
[08:26:19.614] - nx: 1
[08:26:19.614] - relay: TRUE
[08:26:19.614] - stdout: TRUE
[08:26:19.614] - signal: TRUE
[08:26:19.614] - resignal: FALSE
[08:26:19.614] - force: TRUE
[08:26:19.614] - relayed: [n=1] TRUE
[08:26:19.614] - queued futures: [n=1] TRUE
 - flush all
[08:26:19.614] - relayed: [n=1] TRUE
[08:26:19.614] - queued futures: [n=1] TRUE
[08:26:19.614] signalConditionsASAP(NULL, pos=0) ... done
[08:26:19.615] resolve() on list ... DONE
[08:26:19.616]  - Number of value chunks collected: 1
[08:26:19.616] Resolving 1 futures (chunks) ... DONE
[08:26:19.616] Reducing values from 1 chunks ...
[08:26:19.616]  - Number of values collected after concatenation: 3
[08:26:19.617]  - Number of values expected: 3
[08:26:19.617] Reducing values from 1 chunks ... DONE
[08:26:19.617] future_lapply() ... DONE
- exceptions ...
[08:26:19.617] future_lapply() ...
[08:26:19.619] Number of chunks: 1
[08:26:19.619] getGlobalsAndPackagesXApply() ...
[08:26:19.619]  - future.globals: TRUE
[08:26:19.619] getGlobalsAndPackages() ...
[08:26:19.619] Searching for globals...
[08:26:19.622] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[08:26:19.623] Searching for globals ... DONE
[08:26:19.623] Resolving globals: FALSE
[08:26:19.623] The total size of the 7 globals is 12.81 KiB (13119 bytes)
[08:26:19.624] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.65 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:19.624] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.624] - packages: [1] ‘future.apply’
[08:26:19.624] getGlobalsAndPackages() ... DONE
[08:26:19.624]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.624]  - needed namespaces: [n=1] ‘future.apply’
[08:26:19.625] Finding globals ... DONE
[08:26:19.625]  - use_args: TRUE
[08:26:19.625]  - Getting '...' globals ...
[08:26:19.625] resolve() on list ...
[08:26:19.625]  recursive: 0
[08:26:19.625]  length: 1
[08:26:19.625]  elements: ‘...’
[08:26:19.625]  length: 0 (resolved future 1)
[08:26:19.626] resolve() on list ... DONE
[08:26:19.626]    - '...' content: [n=0] 
[08:26:19.626] List of 1
[08:26:19.626]  $ ...: list()
[08:26:19.626]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.626]  - attr(*, "where")=List of 1
[08:26:19.626]   ..$ ...:<environment: 0x562ca618d390> 
[08:26:19.626]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.626]  - attr(*, "resolved")= logi TRUE
[08:26:19.626]  - attr(*, "total_size")= num NA
[08:26:19.628]  - Getting '...' globals ... DONE
[08:26:19.628] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:19.628] List of 8
[08:26:19.628]  $ ...future.FUN:function (x, ...)  
[08:26:19.628]  $ x_FUN        :function (x)  
[08:26:19.628]  $ times        : int 2
[08:26:19.628]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.628]  $ stop_if_not  :function (...)  
[08:26:19.628]  $ dim          : NULL
[08:26:19.628]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:19.628]  $ ...          : list()
[08:26:19.628]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.628]  - attr(*, "where")=List of 8
[08:26:19.628]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:19.628]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:19.628]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:19.628]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:19.628]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:19.628]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:19.628]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:19.628]   ..$ ...          :<environment: 0x562ca618d390> 
[08:26:19.628]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.628]  - attr(*, "resolved")= logi FALSE
[08:26:19.628]  - attr(*, "total_size")= num 23676
[08:26:19.633] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:19.634] getGlobalsAndPackagesXApply() ... DONE
[08:26:19.634] Number of futures (= number of chunks): 1
[08:26:19.634] Launching 1 futures (chunks) ...
[08:26:19.634] Chunk #1 of 1 ...
[08:26:19.634]  - Finding globals in 'X' for chunk #1 ...
[08:26:19.634] getGlobalsAndPackages() ...
[08:26:19.634] Searching for globals...
[08:26:19.634] 
[08:26:19.635] Searching for globals ... DONE
[08:26:19.635] - globals: [0] <none>
[08:26:19.635] getGlobalsAndPackages() ... DONE
[08:26:19.635]    + additional globals found: [n=0] 
[08:26:19.635]    + additional namespaces needed: [n=0] 
[08:26:19.635]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:19.635]  - seeds: <none>
[08:26:19.635]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.635] getGlobalsAndPackages() ...
[08:26:19.637] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.637] Resolving globals: FALSE
[08:26:19.637] Tweak future expression to call with '...' arguments ...
[08:26:19.637] {
[08:26:19.637]     do.call(function(...) {
[08:26:19.637]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.637]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.637]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.637]             on.exit(options(oopts), add = TRUE)
[08:26:19.637]         }
[08:26:19.637]         {
[08:26:19.637]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.637]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.637]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.637]             })
[08:26:19.637]         }
[08:26:19.637]     }, args = future.call.arguments)
[08:26:19.637] }
[08:26:19.637] Tweak future expression to call with '...' arguments ... DONE
[08:26:19.638] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.638] - packages: [1] ‘future.apply’
[08:26:19.638] getGlobalsAndPackages() ... DONE
[08:26:19.638] run() for ‘Future’ ...
[08:26:19.639] - state: ‘created’
[08:26:19.639] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:26:19.639] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.639] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:19.639]   - Field: ‘label’
[08:26:19.639]   - Field: ‘local’
[08:26:19.639]   - Field: ‘owner’
[08:26:19.639]   - Field: ‘envir’
[08:26:19.640]   - Field: ‘packages’
[08:26:19.640]   - Field: ‘gc’
[08:26:19.640]   - Field: ‘conditions’
[08:26:19.640]   - Field: ‘expr’
[08:26:19.640]   - Field: ‘uuid’
[08:26:19.640]   - Field: ‘seed’
[08:26:19.640]   - Field: ‘version’
[08:26:19.640]   - Field: ‘result’
[08:26:19.640]   - Field: ‘asynchronous’
[08:26:19.640]   - Field: ‘calls’
[08:26:19.640]   - Field: ‘globals’
[08:26:19.641]   - Field: ‘stdout’
[08:26:19.641]   - Field: ‘earlySignal’
[08:26:19.641]   - Field: ‘lazy’
[08:26:19.641]   - Field: ‘state’
[08:26:19.641] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:19.641] - Launch lazy future ...
[08:26:19.641] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:19.641] Packages needed by future strategies (n = 0): <none>
[08:26:19.642] {
[08:26:19.642]     {
[08:26:19.642]         {
[08:26:19.642]             ...future.startTime <- base::Sys.time()
[08:26:19.642]             {
[08:26:19.642]                 {
[08:26:19.642]                   {
[08:26:19.642]                     {
[08:26:19.642]                       base::local({
[08:26:19.642]                         has_future <- base::requireNamespace("future", 
[08:26:19.642]                           quietly = TRUE)
[08:26:19.642]                         if (has_future) {
[08:26:19.642]                           ns <- base::getNamespace("future")
[08:26:19.642]                           version <- ns[[".package"]][["version"]]
[08:26:19.642]                           if (is.null(version)) 
[08:26:19.642]                             version <- utils::packageVersion("future")
[08:26:19.642]                         }
[08:26:19.642]                         else {
[08:26:19.642]                           version <- NULL
[08:26:19.642]                         }
[08:26:19.642]                         if (!has_future || version < "1.8.0") {
[08:26:19.642]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:19.642]                             "", base::R.version$version.string), 
[08:26:19.642]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:19.642]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:19.642]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:19.642]                               "release", "version")], collapse = " "), 
[08:26:19.642]                             hostname = base::Sys.info()[["nodename"]])
[08:26:19.642]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:19.642]                             info)
[08:26:19.642]                           info <- base::paste(info, collapse = "; ")
[08:26:19.642]                           if (!has_future) {
[08:26:19.642]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:19.642]                               info)
[08:26:19.642]                           }
[08:26:19.642]                           else {
[08:26:19.642]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:19.642]                               info, version)
[08:26:19.642]                           }
[08:26:19.642]                           base::stop(msg)
[08:26:19.642]                         }
[08:26:19.642]                       })
[08:26:19.642]                     }
[08:26:19.642]                     base::local({
[08:26:19.642]                       for (pkg in "future.apply") {
[08:26:19.642]                         base::loadNamespace(pkg)
[08:26:19.642]                         base::library(pkg, character.only = TRUE)
[08:26:19.642]                       }
[08:26:19.642]                     })
[08:26:19.642]                   }
[08:26:19.642]                   ...future.strategy.old <- future::plan("list")
[08:26:19.642]                   options(future.plan = NULL)
[08:26:19.642]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.642]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:19.642]                 }
[08:26:19.642]                 ...future.workdir <- getwd()
[08:26:19.642]             }
[08:26:19.642]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:19.642]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:19.642]         }
[08:26:19.642]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:19.642]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:19.642]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:19.642]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:19.642]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:19.642]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:19.642]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:19.642]             base::names(...future.oldOptions))
[08:26:19.642]     }
[08:26:19.642]     if (FALSE) {
[08:26:19.642]     }
[08:26:19.642]     else {
[08:26:19.642]         if (TRUE) {
[08:26:19.642]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:19.642]                 open = "w")
[08:26:19.642]         }
[08:26:19.642]         else {
[08:26:19.642]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:19.642]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:19.642]         }
[08:26:19.642]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:19.642]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:19.642]             base::sink(type = "output", split = FALSE)
[08:26:19.642]             base::close(...future.stdout)
[08:26:19.642]         }, add = TRUE)
[08:26:19.642]     }
[08:26:19.642]     ...future.frame <- base::sys.nframe()
[08:26:19.642]     ...future.conditions <- base::list()
[08:26:19.642]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:19.642]     if (FALSE) {
[08:26:19.642]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:19.642]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:19.642]     }
[08:26:19.642]     ...future.result <- base::tryCatch({
[08:26:19.642]         base::withCallingHandlers({
[08:26:19.642]             ...future.value <- base::withVisible(base::local({
[08:26:19.642]                 do.call(function(...) {
[08:26:19.642]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.642]                   if (!identical(...future.globals.maxSize.org, 
[08:26:19.642]                     ...future.globals.maxSize)) {
[08:26:19.642]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.642]                     on.exit(options(oopts), add = TRUE)
[08:26:19.642]                   }
[08:26:19.642]                   {
[08:26:19.642]                     lapply(seq_along(...future.elements_ii), 
[08:26:19.642]                       FUN = function(jj) {
[08:26:19.642]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.642]                         ...future.FUN(...future.X_jj, ...)
[08:26:19.642]                       })
[08:26:19.642]                   }
[08:26:19.642]                 }, args = future.call.arguments)
[08:26:19.642]             }))
[08:26:19.642]             future::FutureResult(value = ...future.value$value, 
[08:26:19.642]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.642]                   ...future.rng), globalenv = if (FALSE) 
[08:26:19.642]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:19.642]                     ...future.globalenv.names))
[08:26:19.642]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:19.642]         }, condition = base::local({
[08:26:19.642]             c <- base::c
[08:26:19.642]             inherits <- base::inherits
[08:26:19.642]             invokeRestart <- base::invokeRestart
[08:26:19.642]             length <- base::length
[08:26:19.642]             list <- base::list
[08:26:19.642]             seq.int <- base::seq.int
[08:26:19.642]             signalCondition <- base::signalCondition
[08:26:19.642]             sys.calls <- base::sys.calls
[08:26:19.642]             `[[` <- base::`[[`
[08:26:19.642]             `+` <- base::`+`
[08:26:19.642]             `<<-` <- base::`<<-`
[08:26:19.642]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:19.642]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:19.642]                   3L)]
[08:26:19.642]             }
[08:26:19.642]             function(cond) {
[08:26:19.642]                 is_error <- inherits(cond, "error")
[08:26:19.642]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:19.642]                   NULL)
[08:26:19.642]                 if (is_error) {
[08:26:19.642]                   sessionInformation <- function() {
[08:26:19.642]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:19.642]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:19.642]                       search = base::search(), system = base::Sys.info())
[08:26:19.642]                   }
[08:26:19.642]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.642]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:19.642]                     cond$call), session = sessionInformation(), 
[08:26:19.642]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:19.642]                   signalCondition(cond)
[08:26:19.642]                 }
[08:26:19.642]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:19.642]                 "immediateCondition"))) {
[08:26:19.642]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:19.642]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.642]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:19.642]                   if (TRUE && !signal) {
[08:26:19.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.642]                     {
[08:26:19.642]                       inherits <- base::inherits
[08:26:19.642]                       invokeRestart <- base::invokeRestart
[08:26:19.642]                       is.null <- base::is.null
[08:26:19.642]                       muffled <- FALSE
[08:26:19.642]                       if (inherits(cond, "message")) {
[08:26:19.642]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.642]                         if (muffled) 
[08:26:19.642]                           invokeRestart("muffleMessage")
[08:26:19.642]                       }
[08:26:19.642]                       else if (inherits(cond, "warning")) {
[08:26:19.642]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.642]                         if (muffled) 
[08:26:19.642]                           invokeRestart("muffleWarning")
[08:26:19.642]                       }
[08:26:19.642]                       else if (inherits(cond, "condition")) {
[08:26:19.642]                         if (!is.null(pattern)) {
[08:26:19.642]                           computeRestarts <- base::computeRestarts
[08:26:19.642]                           grepl <- base::grepl
[08:26:19.642]                           restarts <- computeRestarts(cond)
[08:26:19.642]                           for (restart in restarts) {
[08:26:19.642]                             name <- restart$name
[08:26:19.642]                             if (is.null(name)) 
[08:26:19.642]                               next
[08:26:19.642]                             if (!grepl(pattern, name)) 
[08:26:19.642]                               next
[08:26:19.642]                             invokeRestart(restart)
[08:26:19.642]                             muffled <- TRUE
[08:26:19.642]                             break
[08:26:19.642]                           }
[08:26:19.642]                         }
[08:26:19.642]                       }
[08:26:19.642]                       invisible(muffled)
[08:26:19.642]                     }
[08:26:19.642]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.642]                   }
[08:26:19.642]                 }
[08:26:19.642]                 else {
[08:26:19.642]                   if (TRUE) {
[08:26:19.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.642]                     {
[08:26:19.642]                       inherits <- base::inherits
[08:26:19.642]                       invokeRestart <- base::invokeRestart
[08:26:19.642]                       is.null <- base::is.null
[08:26:19.642]                       muffled <- FALSE
[08:26:19.642]                       if (inherits(cond, "message")) {
[08:26:19.642]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.642]                         if (muffled) 
[08:26:19.642]                           invokeRestart("muffleMessage")
[08:26:19.642]                       }
[08:26:19.642]                       else if (inherits(cond, "warning")) {
[08:26:19.642]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.642]                         if (muffled) 
[08:26:19.642]                           invokeRestart("muffleWarning")
[08:26:19.642]                       }
[08:26:19.642]                       else if (inherits(cond, "condition")) {
[08:26:19.642]                         if (!is.null(pattern)) {
[08:26:19.642]                           computeRestarts <- base::computeRestarts
[08:26:19.642]                           grepl <- base::grepl
[08:26:19.642]                           restarts <- computeRestarts(cond)
[08:26:19.642]                           for (restart in restarts) {
[08:26:19.642]                             name <- restart$name
[08:26:19.642]                             if (is.null(name)) 
[08:26:19.642]                               next
[08:26:19.642]                             if (!grepl(pattern, name)) 
[08:26:19.642]                               next
[08:26:19.642]                             invokeRestart(restart)
[08:26:19.642]                             muffled <- TRUE
[08:26:19.642]                             break
[08:26:19.642]                           }
[08:26:19.642]                         }
[08:26:19.642]                       }
[08:26:19.642]                       invisible(muffled)
[08:26:19.642]                     }
[08:26:19.642]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.642]                   }
[08:26:19.642]                 }
[08:26:19.642]             }
[08:26:19.642]         }))
[08:26:19.642]     }, error = function(ex) {
[08:26:19.642]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:19.642]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.642]                 ...future.rng), started = ...future.startTime, 
[08:26:19.642]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:19.642]             version = "1.8"), class = "FutureResult")
[08:26:19.642]     }, finally = {
[08:26:19.642]         if (!identical(...future.workdir, getwd())) 
[08:26:19.642]             setwd(...future.workdir)
[08:26:19.642]         {
[08:26:19.642]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:19.642]                 ...future.oldOptions$nwarnings <- NULL
[08:26:19.642]             }
[08:26:19.642]             base::options(...future.oldOptions)
[08:26:19.642]             if (.Platform$OS.type == "windows") {
[08:26:19.642]                 old_names <- names(...future.oldEnvVars)
[08:26:19.642]                 envs <- base::Sys.getenv()
[08:26:19.642]                 names <- names(envs)
[08:26:19.642]                 common <- intersect(names, old_names)
[08:26:19.642]                 added <- setdiff(names, old_names)
[08:26:19.642]                 removed <- setdiff(old_names, names)
[08:26:19.642]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:19.642]                   envs[common]]
[08:26:19.642]                 NAMES <- toupper(changed)
[08:26:19.642]                 args <- list()
[08:26:19.642]                 for (kk in seq_along(NAMES)) {
[08:26:19.642]                   name <- changed[[kk]]
[08:26:19.642]                   NAME <- NAMES[[kk]]
[08:26:19.642]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.642]                     next
[08:26:19.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.642]                 }
[08:26:19.642]                 NAMES <- toupper(added)
[08:26:19.642]                 for (kk in seq_along(NAMES)) {
[08:26:19.642]                   name <- added[[kk]]
[08:26:19.642]                   NAME <- NAMES[[kk]]
[08:26:19.642]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.642]                     next
[08:26:19.642]                   args[[name]] <- ""
[08:26:19.642]                 }
[08:26:19.642]                 NAMES <- toupper(removed)
[08:26:19.642]                 for (kk in seq_along(NAMES)) {
[08:26:19.642]                   name <- removed[[kk]]
[08:26:19.642]                   NAME <- NAMES[[kk]]
[08:26:19.642]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.642]                     next
[08:26:19.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.642]                 }
[08:26:19.642]                 if (length(args) > 0) 
[08:26:19.642]                   base::do.call(base::Sys.setenv, args = args)
[08:26:19.642]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:19.642]             }
[08:26:19.642]             else {
[08:26:19.642]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:19.642]             }
[08:26:19.642]             {
[08:26:19.642]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:19.642]                   0L) {
[08:26:19.642]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:19.642]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:19.642]                   base::options(opts)
[08:26:19.642]                 }
[08:26:19.642]                 {
[08:26:19.642]                   {
[08:26:19.642]                     NULL
[08:26:19.642]                     RNGkind("Mersenne-Twister")
[08:26:19.642]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:19.642]                       inherits = FALSE)
[08:26:19.642]                   }
[08:26:19.642]                   options(future.plan = NULL)
[08:26:19.642]                   if (is.na(NA_character_)) 
[08:26:19.642]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.642]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:19.642]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:19.642]                     .init = FALSE)
[08:26:19.642]                 }
[08:26:19.642]             }
[08:26:19.642]         }
[08:26:19.642]     })
[08:26:19.642]     if (TRUE) {
[08:26:19.642]         base::sink(type = "output", split = FALSE)
[08:26:19.642]         if (TRUE) {
[08:26:19.642]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:19.642]         }
[08:26:19.642]         else {
[08:26:19.642]             ...future.result["stdout"] <- base::list(NULL)
[08:26:19.642]         }
[08:26:19.642]         base::close(...future.stdout)
[08:26:19.642]         ...future.stdout <- NULL
[08:26:19.642]     }
[08:26:19.642]     ...future.result$conditions <- ...future.conditions
[08:26:19.642]     ...future.result$finished <- base::Sys.time()
[08:26:19.642]     ...future.result
[08:26:19.642] }
[08:26:19.644] assign_globals() ...
[08:26:19.644] List of 11
[08:26:19.644]  $ ...future.FUN            :function (x, ...)  
[08:26:19.644]  $ x_FUN                    :function (x)  
[08:26:19.644]  $ times                    : int 2
[08:26:19.644]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.644]  $ stop_if_not              :function (...)  
[08:26:19.644]  $ dim                      : NULL
[08:26:19.644]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:19.644]  $ future.call.arguments    : list()
[08:26:19.644]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.644]  $ ...future.elements_ii    :List of 3
[08:26:19.644]   ..$ : int 1
[08:26:19.644]   ..$ : int 2
[08:26:19.644]   ..$ : int 3
[08:26:19.644]  $ ...future.seeds_ii       : NULL
[08:26:19.644]  $ ...future.globals.maxSize: NULL
[08:26:19.644]  - attr(*, "where")=List of 11
[08:26:19.644]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:19.644]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:19.644]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:19.644]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:19.644]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:19.644]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:19.644]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:19.644]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:19.644]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:19.644]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:19.644]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:19.644]  - attr(*, "resolved")= logi FALSE
[08:26:19.644]  - attr(*, "total_size")= num 23676
[08:26:19.644]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.644]  - attr(*, "already-done")= logi TRUE
[08:26:19.651] - copied ‘...future.FUN’ to environment
[08:26:19.651] - copied ‘x_FUN’ to environment
[08:26:19.651] - copied ‘times’ to environment
[08:26:19.651] - copied ‘stopf’ to environment
[08:26:19.651] - copied ‘stop_if_not’ to environment
[08:26:19.652] - copied ‘dim’ to environment
[08:26:19.652] - copied ‘valid_types’ to environment
[08:26:19.652] - copied ‘future.call.arguments’ to environment
[08:26:19.652] - copied ‘...future.elements_ii’ to environment
[08:26:19.652] - copied ‘...future.seeds_ii’ to environment
[08:26:19.652] - copied ‘...future.globals.maxSize’ to environment
[08:26:19.652] assign_globals() ... done
[08:26:19.652] plan(): Setting new future strategy stack:
[08:26:19.653] List of future strategies:
[08:26:19.653] 1. sequential:
[08:26:19.653]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.653]    - tweaked: FALSE
[08:26:19.653]    - call: NULL
[08:26:19.653] plan(): nbrOfWorkers() = 1
[08:26:19.654] plan(): Setting new future strategy stack:
[08:26:19.654] List of future strategies:
[08:26:19.654] 1. sequential:
[08:26:19.654]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.654]    - tweaked: FALSE
[08:26:19.654]    - call: plan(strategy)
[08:26:19.654] plan(): nbrOfWorkers() = 1
[08:26:19.655] SequentialFuture started (and completed)
[08:26:19.655] signalConditions() ...
[08:26:19.655]  - include = ‘immediateCondition’
[08:26:19.655]  - exclude = 
[08:26:19.655]  - resignal = FALSE
[08:26:19.655]  - Number of conditions: 1
[08:26:19.655] signalConditions() ... done
[08:26:19.655] - Launch lazy future ... done
[08:26:19.655] run() for ‘SequentialFuture’ ... done
[08:26:19.655] Created future:
[08:26:19.656] SequentialFuture:
[08:26:19.656] Label: ‘future_vapply-1’
[08:26:19.656] Expression:
[08:26:19.656] {
[08:26:19.656]     do.call(function(...) {
[08:26:19.656]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.656]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.656]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.656]             on.exit(options(oopts), add = TRUE)
[08:26:19.656]         }
[08:26:19.656]         {
[08:26:19.656]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.656]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.656]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.656]             })
[08:26:19.656]         }
[08:26:19.656]     }, args = future.call.arguments)
[08:26:19.656] }
[08:26:19.656] Lazy evaluation: FALSE
[08:26:19.656] Asynchronous evaluation: FALSE
[08:26:19.656] Local evaluation: TRUE
[08:26:19.656] Environment: R_GlobalEnv
[08:26:19.656] Capture standard output: TRUE
[08:26:19.656] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:19.656] Globals: 11 objects totaling 13.02 KiB (function ‘...future.FUN’ of 4.65 KiB, function ‘x_FUN’ of 185 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:19.656] Packages: 1 packages (‘future.apply’)
[08:26:19.656] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:19.656] Resolved: TRUE
[08:26:19.656] Value: 27 bytes of class ‘NULL’
[08:26:19.656] Conditions captured: [n=1] ‘simpleError’
[08:26:19.656] Early signaling: FALSE
[08:26:19.656] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:19.656] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:19.656] Chunk #1 of 1 ... DONE
[08:26:19.657] Launching 1 futures (chunks) ... DONE
[08:26:19.657] Resolving 1 futures (chunks) ...
[08:26:19.657] resolve() on list ...
[08:26:19.657]  recursive: 0
[08:26:19.657]  length: 1
[08:26:19.657] 
[08:26:19.657] resolved() for ‘SequentialFuture’ ...
[08:26:19.657] - state: ‘finished’
[08:26:19.657] - run: TRUE
[08:26:19.657] - result: ‘FutureResult’
[08:26:19.657] resolved() for ‘SequentialFuture’ ... done
[08:26:19.658] Future #1
[08:26:19.658] signalConditions() ...
[08:26:19.658]  - include = ‘immediateCondition’
[08:26:19.658]  - exclude = 
[08:26:19.658]  - resignal = FALSE
[08:26:19.658]  - Number of conditions: 1
[08:26:19.660] signalConditions() ... done
[08:26:19.660] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:19.660] - nx: 1
[08:26:19.660] - relay: TRUE
[08:26:19.660] - stdout: TRUE
[08:26:19.660] - signal: TRUE
[08:26:19.660] - resignal: FALSE
[08:26:19.660] - force: TRUE
[08:26:19.660] - relayed: [n=1] FALSE
[08:26:19.660] - queued futures: [n=1] FALSE
[08:26:19.661]  - until=1
[08:26:19.661]  - relaying element #1
[08:26:19.661] signalConditions() ...
[08:26:19.661]  - include = ‘immediateCondition’
[08:26:19.661]  - exclude = 
[08:26:19.661]  - resignal = FALSE
[08:26:19.661]  - Number of conditions: 1
[08:26:19.661] signalConditions() ... done
[08:26:19.661] signalConditions() ...
[08:26:19.662]  - include = ‘immediateCondition’
[08:26:19.662]  - exclude = 
[08:26:19.662]  - resignal = FALSE
[08:26:19.662]  - Number of conditions: 1
[08:26:19.662] signalConditions() ... done
[08:26:19.662] signalConditions() ...
[08:26:19.662]  - include = ‘condition’
[08:26:19.662]  - exclude = ‘immediateCondition’
[08:26:19.662]  - resignal = TRUE
[08:26:19.662]  - Number of conditions: 1
[08:26:19.662]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:26:19.663] signalConditions() ... done
[08:26:19.663] - relayed: [n=1] FALSE
[08:26:19.663] - queued futures: [n=1] TRUE
[08:26:19.663] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:19.663] plan(): Setting new future strategy stack:
[08:26:19.663] List of future strategies:
[08:26:19.663] 1. sequential:
[08:26:19.663]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.663]    - tweaked: FALSE
[08:26:19.663]    - call: plan(sequential)
[08:26:19.664] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[08:26:19.664] plan(): Setting new future strategy stack:
[08:26:19.664] List of future strategies:
[08:26:19.664] 1. multicore:
[08:26:19.664]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:19.664]    - tweaked: FALSE
[08:26:19.664]    - call: plan(strategy)
[08:26:19.666] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[08:26:19.668] future_lapply() ...
[08:26:19.672] Number of chunks: 2
[08:26:19.672] getGlobalsAndPackagesXApply() ...
[08:26:19.672]  - future.globals: TRUE
[08:26:19.672] getGlobalsAndPackages() ...
[08:26:19.672] Searching for globals...
[08:26:19.675] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[08:26:19.675] Searching for globals ... DONE
[08:26:19.675] Resolving globals: FALSE
[08:26:19.676] The total size of the 7 globals is 12.01 KiB (12294 bytes)
[08:26:19.676] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.02 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:19.676] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.677] - packages: [1] ‘future.apply’
[08:26:19.677] getGlobalsAndPackages() ... DONE
[08:26:19.677]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.677]  - needed namespaces: [n=1] ‘future.apply’
[08:26:19.677] Finding globals ... DONE
[08:26:19.677]  - use_args: TRUE
[08:26:19.677]  - Getting '...' globals ...
[08:26:19.677] resolve() on list ...
[08:26:19.678]  recursive: 0
[08:26:19.678]  length: 1
[08:26:19.678]  elements: ‘...’
[08:26:19.678]  length: 0 (resolved future 1)
[08:26:19.678] resolve() on list ... DONE
[08:26:19.678]    - '...' content: [n=0] 
[08:26:19.678] List of 1
[08:26:19.678]  $ ...: list()
[08:26:19.678]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.678]  - attr(*, "where")=List of 1
[08:26:19.678]   ..$ ...:<environment: 0x562ca5f57e78> 
[08:26:19.678]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.678]  - attr(*, "resolved")= logi TRUE
[08:26:19.678]  - attr(*, "total_size")= num NA
[08:26:19.680]  - Getting '...' globals ... DONE
[08:26:19.681] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:19.681] List of 8
[08:26:19.681]  $ ...future.FUN:function (x, ...)  
[08:26:19.681]  $ x_FUN        :function (x)  
[08:26:19.681]  $ times        : int 1
[08:26:19.681]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.681]  $ stop_if_not  :function (...)  
[08:26:19.681]  $ dim          : NULL
[08:26:19.681]  $ valid_types  : chr "character"
[08:26:19.681]  $ ...          : list()
[08:26:19.681]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.681]  - attr(*, "where")=List of 8
[08:26:19.681]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:19.681]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:19.681]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:19.681]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:19.681]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:19.681]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:19.681]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:19.681]   ..$ ...          :<environment: 0x562ca5f57e78> 
[08:26:19.681]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.681]  - attr(*, "resolved")= logi FALSE
[08:26:19.681]  - attr(*, "total_size")= num 22333
[08:26:19.688] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:19.688] getGlobalsAndPackagesXApply() ... DONE
[08:26:19.688] Number of futures (= number of chunks): 2
[08:26:19.688] Launching 2 futures (chunks) ...
[08:26:19.688] Chunk #1 of 2 ...
[08:26:19.688]  - Finding globals in 'X' for chunk #1 ...
[08:26:19.689] getGlobalsAndPackages() ...
[08:26:19.689] Searching for globals...
[08:26:19.689] 
[08:26:19.689] Searching for globals ... DONE
[08:26:19.689] - globals: [0] <none>
[08:26:19.689] getGlobalsAndPackages() ... DONE
[08:26:19.689]    + additional globals found: [n=0] 
[08:26:19.689]    + additional namespaces needed: [n=0] 
[08:26:19.689]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:19.690]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:19.690]  - seeds: <none>
[08:26:19.690]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.690] getGlobalsAndPackages() ...
[08:26:19.690] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.690] Resolving globals: FALSE
[08:26:19.690] Tweak future expression to call with '...' arguments ...
[08:26:19.690] {
[08:26:19.690]     do.call(function(...) {
[08:26:19.690]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.690]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.690]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.690]             on.exit(options(oopts), add = TRUE)
[08:26:19.690]         }
[08:26:19.690]         {
[08:26:19.690]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.690]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.690]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.690]             })
[08:26:19.690]         }
[08:26:19.690]     }, args = future.call.arguments)
[08:26:19.690] }
[08:26:19.691] Tweak future expression to call with '...' arguments ... DONE
[08:26:19.691] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.691] - packages: [1] ‘future.apply’
[08:26:19.691] getGlobalsAndPackages() ... DONE
[08:26:19.692] run() for ‘Future’ ...
[08:26:19.692] - state: ‘created’
[08:26:19.692] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:19.694] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:19.694] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:19.694]   - Field: ‘label’
[08:26:19.694]   - Field: ‘local’
[08:26:19.694]   - Field: ‘owner’
[08:26:19.694]   - Field: ‘envir’
[08:26:19.694]   - Field: ‘workers’
[08:26:19.694]   - Field: ‘packages’
[08:26:19.694]   - Field: ‘gc’
[08:26:19.694]   - Field: ‘job’
[08:26:19.695]   - Field: ‘conditions’
[08:26:19.695]   - Field: ‘expr’
[08:26:19.695]   - Field: ‘uuid’
[08:26:19.695]   - Field: ‘seed’
[08:26:19.695]   - Field: ‘version’
[08:26:19.695]   - Field: ‘result’
[08:26:19.695]   - Field: ‘asynchronous’
[08:26:19.695]   - Field: ‘calls’
[08:26:19.695]   - Field: ‘globals’
[08:26:19.695]   - Field: ‘stdout’
[08:26:19.695]   - Field: ‘earlySignal’
[08:26:19.695]   - Field: ‘lazy’
[08:26:19.696]   - Field: ‘state’
[08:26:19.696] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:19.696] - Launch lazy future ...
[08:26:19.697] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:19.697] Packages needed by future strategies (n = 0): <none>
[08:26:19.697] {
[08:26:19.697]     {
[08:26:19.697]         {
[08:26:19.697]             ...future.startTime <- base::Sys.time()
[08:26:19.697]             {
[08:26:19.697]                 {
[08:26:19.697]                   {
[08:26:19.697]                     {
[08:26:19.697]                       {
[08:26:19.697]                         base::local({
[08:26:19.697]                           has_future <- base::requireNamespace("future", 
[08:26:19.697]                             quietly = TRUE)
[08:26:19.697]                           if (has_future) {
[08:26:19.697]                             ns <- base::getNamespace("future")
[08:26:19.697]                             version <- ns[[".package"]][["version"]]
[08:26:19.697]                             if (is.null(version)) 
[08:26:19.697]                               version <- utils::packageVersion("future")
[08:26:19.697]                           }
[08:26:19.697]                           else {
[08:26:19.697]                             version <- NULL
[08:26:19.697]                           }
[08:26:19.697]                           if (!has_future || version < "1.8.0") {
[08:26:19.697]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:19.697]                               "", base::R.version$version.string), 
[08:26:19.697]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:19.697]                                 base::R.version$platform, 8 * 
[08:26:19.697]                                   base::.Machine$sizeof.pointer), 
[08:26:19.697]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:19.697]                                 "release", "version")], collapse = " "), 
[08:26:19.697]                               hostname = base::Sys.info()[["nodename"]])
[08:26:19.697]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:19.697]                               info)
[08:26:19.697]                             info <- base::paste(info, collapse = "; ")
[08:26:19.697]                             if (!has_future) {
[08:26:19.697]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:19.697]                                 info)
[08:26:19.697]                             }
[08:26:19.697]                             else {
[08:26:19.697]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:19.697]                                 info, version)
[08:26:19.697]                             }
[08:26:19.697]                             base::stop(msg)
[08:26:19.697]                           }
[08:26:19.697]                         })
[08:26:19.697]                       }
[08:26:19.697]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:19.697]                       base::options(mc.cores = 1L)
[08:26:19.697]                     }
[08:26:19.697]                     base::local({
[08:26:19.697]                       for (pkg in "future.apply") {
[08:26:19.697]                         base::loadNamespace(pkg)
[08:26:19.697]                         base::library(pkg, character.only = TRUE)
[08:26:19.697]                       }
[08:26:19.697]                     })
[08:26:19.697]                   }
[08:26:19.697]                   ...future.strategy.old <- future::plan("list")
[08:26:19.697]                   options(future.plan = NULL)
[08:26:19.697]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.697]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:19.697]                 }
[08:26:19.697]                 ...future.workdir <- getwd()
[08:26:19.697]             }
[08:26:19.697]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:19.697]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:19.697]         }
[08:26:19.697]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:19.697]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:19.697]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:19.697]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:19.697]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:19.697]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:19.697]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:19.697]             base::names(...future.oldOptions))
[08:26:19.697]     }
[08:26:19.697]     if (FALSE) {
[08:26:19.697]     }
[08:26:19.697]     else {
[08:26:19.697]         if (TRUE) {
[08:26:19.697]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:19.697]                 open = "w")
[08:26:19.697]         }
[08:26:19.697]         else {
[08:26:19.697]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:19.697]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:19.697]         }
[08:26:19.697]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:19.697]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:19.697]             base::sink(type = "output", split = FALSE)
[08:26:19.697]             base::close(...future.stdout)
[08:26:19.697]         }, add = TRUE)
[08:26:19.697]     }
[08:26:19.697]     ...future.frame <- base::sys.nframe()
[08:26:19.697]     ...future.conditions <- base::list()
[08:26:19.697]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:19.697]     if (FALSE) {
[08:26:19.697]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:19.697]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:19.697]     }
[08:26:19.697]     ...future.result <- base::tryCatch({
[08:26:19.697]         base::withCallingHandlers({
[08:26:19.697]             ...future.value <- base::withVisible(base::local({
[08:26:19.697]                 withCallingHandlers({
[08:26:19.697]                   {
[08:26:19.697]                     do.call(function(...) {
[08:26:19.697]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.697]                       if (!identical(...future.globals.maxSize.org, 
[08:26:19.697]                         ...future.globals.maxSize)) {
[08:26:19.697]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.697]                         on.exit(options(oopts), add = TRUE)
[08:26:19.697]                       }
[08:26:19.697]                       {
[08:26:19.697]                         lapply(seq_along(...future.elements_ii), 
[08:26:19.697]                           FUN = function(jj) {
[08:26:19.697]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.697]                             ...future.FUN(...future.X_jj, ...)
[08:26:19.697]                           })
[08:26:19.697]                       }
[08:26:19.697]                     }, args = future.call.arguments)
[08:26:19.697]                   }
[08:26:19.697]                 }, immediateCondition = function(cond) {
[08:26:19.697]                   save_rds <- function (object, pathname, ...) 
[08:26:19.697]                   {
[08:26:19.697]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:19.697]                     if (file_test("-f", pathname_tmp)) {
[08:26:19.697]                       fi_tmp <- file.info(pathname_tmp)
[08:26:19.697]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:19.697]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:19.697]                         fi_tmp[["mtime"]])
[08:26:19.697]                     }
[08:26:19.697]                     tryCatch({
[08:26:19.697]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:19.697]                     }, error = function(ex) {
[08:26:19.697]                       msg <- conditionMessage(ex)
[08:26:19.697]                       fi_tmp <- file.info(pathname_tmp)
[08:26:19.697]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:19.697]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:19.697]                         fi_tmp[["mtime"]], msg)
[08:26:19.697]                       ex$message <- msg
[08:26:19.697]                       stop(ex)
[08:26:19.697]                     })
[08:26:19.697]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:19.697]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:19.697]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:19.697]                       fi_tmp <- file.info(pathname_tmp)
[08:26:19.697]                       fi <- file.info(pathname)
[08:26:19.697]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:19.697]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:19.697]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:19.697]                         fi[["size"]], fi[["mtime"]])
[08:26:19.697]                       stop(msg)
[08:26:19.697]                     }
[08:26:19.697]                     invisible(pathname)
[08:26:19.697]                   }
[08:26:19.697]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:19.697]                     rootPath = tempdir()) 
[08:26:19.697]                   {
[08:26:19.697]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:19.697]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:19.697]                       tmpdir = path, fileext = ".rds")
[08:26:19.697]                     save_rds(obj, file)
[08:26:19.697]                   }
[08:26:19.697]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:19.697]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.697]                   {
[08:26:19.697]                     inherits <- base::inherits
[08:26:19.697]                     invokeRestart <- base::invokeRestart
[08:26:19.697]                     is.null <- base::is.null
[08:26:19.697]                     muffled <- FALSE
[08:26:19.697]                     if (inherits(cond, "message")) {
[08:26:19.697]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:19.697]                       if (muffled) 
[08:26:19.697]                         invokeRestart("muffleMessage")
[08:26:19.697]                     }
[08:26:19.697]                     else if (inherits(cond, "warning")) {
[08:26:19.697]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:19.697]                       if (muffled) 
[08:26:19.697]                         invokeRestart("muffleWarning")
[08:26:19.697]                     }
[08:26:19.697]                     else if (inherits(cond, "condition")) {
[08:26:19.697]                       if (!is.null(pattern)) {
[08:26:19.697]                         computeRestarts <- base::computeRestarts
[08:26:19.697]                         grepl <- base::grepl
[08:26:19.697]                         restarts <- computeRestarts(cond)
[08:26:19.697]                         for (restart in restarts) {
[08:26:19.697]                           name <- restart$name
[08:26:19.697]                           if (is.null(name)) 
[08:26:19.697]                             next
[08:26:19.697]                           if (!grepl(pattern, name)) 
[08:26:19.697]                             next
[08:26:19.697]                           invokeRestart(restart)
[08:26:19.697]                           muffled <- TRUE
[08:26:19.697]                           break
[08:26:19.697]                         }
[08:26:19.697]                       }
[08:26:19.697]                     }
[08:26:19.697]                     invisible(muffled)
[08:26:19.697]                   }
[08:26:19.697]                   muffleCondition(cond)
[08:26:19.697]                 })
[08:26:19.697]             }))
[08:26:19.697]             future::FutureResult(value = ...future.value$value, 
[08:26:19.697]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.697]                   ...future.rng), globalenv = if (FALSE) 
[08:26:19.697]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:19.697]                     ...future.globalenv.names))
[08:26:19.697]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:19.697]         }, condition = base::local({
[08:26:19.697]             c <- base::c
[08:26:19.697]             inherits <- base::inherits
[08:26:19.697]             invokeRestart <- base::invokeRestart
[08:26:19.697]             length <- base::length
[08:26:19.697]             list <- base::list
[08:26:19.697]             seq.int <- base::seq.int
[08:26:19.697]             signalCondition <- base::signalCondition
[08:26:19.697]             sys.calls <- base::sys.calls
[08:26:19.697]             `[[` <- base::`[[`
[08:26:19.697]             `+` <- base::`+`
[08:26:19.697]             `<<-` <- base::`<<-`
[08:26:19.697]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:19.697]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:19.697]                   3L)]
[08:26:19.697]             }
[08:26:19.697]             function(cond) {
[08:26:19.697]                 is_error <- inherits(cond, "error")
[08:26:19.697]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:19.697]                   NULL)
[08:26:19.697]                 if (is_error) {
[08:26:19.697]                   sessionInformation <- function() {
[08:26:19.697]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:19.697]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:19.697]                       search = base::search(), system = base::Sys.info())
[08:26:19.697]                   }
[08:26:19.697]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.697]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:19.697]                     cond$call), session = sessionInformation(), 
[08:26:19.697]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:19.697]                   signalCondition(cond)
[08:26:19.697]                 }
[08:26:19.697]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:19.697]                 "immediateCondition"))) {
[08:26:19.697]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:19.697]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.697]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:19.697]                   if (TRUE && !signal) {
[08:26:19.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.697]                     {
[08:26:19.697]                       inherits <- base::inherits
[08:26:19.697]                       invokeRestart <- base::invokeRestart
[08:26:19.697]                       is.null <- base::is.null
[08:26:19.697]                       muffled <- FALSE
[08:26:19.697]                       if (inherits(cond, "message")) {
[08:26:19.697]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.697]                         if (muffled) 
[08:26:19.697]                           invokeRestart("muffleMessage")
[08:26:19.697]                       }
[08:26:19.697]                       else if (inherits(cond, "warning")) {
[08:26:19.697]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.697]                         if (muffled) 
[08:26:19.697]                           invokeRestart("muffleWarning")
[08:26:19.697]                       }
[08:26:19.697]                       else if (inherits(cond, "condition")) {
[08:26:19.697]                         if (!is.null(pattern)) {
[08:26:19.697]                           computeRestarts <- base::computeRestarts
[08:26:19.697]                           grepl <- base::grepl
[08:26:19.697]                           restarts <- computeRestarts(cond)
[08:26:19.697]                           for (restart in restarts) {
[08:26:19.697]                             name <- restart$name
[08:26:19.697]                             if (is.null(name)) 
[08:26:19.697]                               next
[08:26:19.697]                             if (!grepl(pattern, name)) 
[08:26:19.697]                               next
[08:26:19.697]                             invokeRestart(restart)
[08:26:19.697]                             muffled <- TRUE
[08:26:19.697]                             break
[08:26:19.697]                           }
[08:26:19.697]                         }
[08:26:19.697]                       }
[08:26:19.697]                       invisible(muffled)
[08:26:19.697]                     }
[08:26:19.697]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.697]                   }
[08:26:19.697]                 }
[08:26:19.697]                 else {
[08:26:19.697]                   if (TRUE) {
[08:26:19.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.697]                     {
[08:26:19.697]                       inherits <- base::inherits
[08:26:19.697]                       invokeRestart <- base::invokeRestart
[08:26:19.697]                       is.null <- base::is.null
[08:26:19.697]                       muffled <- FALSE
[08:26:19.697]                       if (inherits(cond, "message")) {
[08:26:19.697]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.697]                         if (muffled) 
[08:26:19.697]                           invokeRestart("muffleMessage")
[08:26:19.697]                       }
[08:26:19.697]                       else if (inherits(cond, "warning")) {
[08:26:19.697]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.697]                         if (muffled) 
[08:26:19.697]                           invokeRestart("muffleWarning")
[08:26:19.697]                       }
[08:26:19.697]                       else if (inherits(cond, "condition")) {
[08:26:19.697]                         if (!is.null(pattern)) {
[08:26:19.697]                           computeRestarts <- base::computeRestarts
[08:26:19.697]                           grepl <- base::grepl
[08:26:19.697]                           restarts <- computeRestarts(cond)
[08:26:19.697]                           for (restart in restarts) {
[08:26:19.697]                             name <- restart$name
[08:26:19.697]                             if (is.null(name)) 
[08:26:19.697]                               next
[08:26:19.697]                             if (!grepl(pattern, name)) 
[08:26:19.697]                               next
[08:26:19.697]                             invokeRestart(restart)
[08:26:19.697]                             muffled <- TRUE
[08:26:19.697]                             break
[08:26:19.697]                           }
[08:26:19.697]                         }
[08:26:19.697]                       }
[08:26:19.697]                       invisible(muffled)
[08:26:19.697]                     }
[08:26:19.697]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.697]                   }
[08:26:19.697]                 }
[08:26:19.697]             }
[08:26:19.697]         }))
[08:26:19.697]     }, error = function(ex) {
[08:26:19.697]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:19.697]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.697]                 ...future.rng), started = ...future.startTime, 
[08:26:19.697]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:19.697]             version = "1.8"), class = "FutureResult")
[08:26:19.697]     }, finally = {
[08:26:19.697]         if (!identical(...future.workdir, getwd())) 
[08:26:19.697]             setwd(...future.workdir)
[08:26:19.697]         {
[08:26:19.697]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:19.697]                 ...future.oldOptions$nwarnings <- NULL
[08:26:19.697]             }
[08:26:19.697]             base::options(...future.oldOptions)
[08:26:19.697]             if (.Platform$OS.type == "windows") {
[08:26:19.697]                 old_names <- names(...future.oldEnvVars)
[08:26:19.697]                 envs <- base::Sys.getenv()
[08:26:19.697]                 names <- names(envs)
[08:26:19.697]                 common <- intersect(names, old_names)
[08:26:19.697]                 added <- setdiff(names, old_names)
[08:26:19.697]                 removed <- setdiff(old_names, names)
[08:26:19.697]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:19.697]                   envs[common]]
[08:26:19.697]                 NAMES <- toupper(changed)
[08:26:19.697]                 args <- list()
[08:26:19.697]                 for (kk in seq_along(NAMES)) {
[08:26:19.697]                   name <- changed[[kk]]
[08:26:19.697]                   NAME <- NAMES[[kk]]
[08:26:19.697]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.697]                     next
[08:26:19.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.697]                 }
[08:26:19.697]                 NAMES <- toupper(added)
[08:26:19.697]                 for (kk in seq_along(NAMES)) {
[08:26:19.697]                   name <- added[[kk]]
[08:26:19.697]                   NAME <- NAMES[[kk]]
[08:26:19.697]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.697]                     next
[08:26:19.697]                   args[[name]] <- ""
[08:26:19.697]                 }
[08:26:19.697]                 NAMES <- toupper(removed)
[08:26:19.697]                 for (kk in seq_along(NAMES)) {
[08:26:19.697]                   name <- removed[[kk]]
[08:26:19.697]                   NAME <- NAMES[[kk]]
[08:26:19.697]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.697]                     next
[08:26:19.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.697]                 }
[08:26:19.697]                 if (length(args) > 0) 
[08:26:19.697]                   base::do.call(base::Sys.setenv, args = args)
[08:26:19.697]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:19.697]             }
[08:26:19.697]             else {
[08:26:19.697]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:19.697]             }
[08:26:19.697]             {
[08:26:19.697]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:19.697]                   0L) {
[08:26:19.697]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:19.697]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:19.697]                   base::options(opts)
[08:26:19.697]                 }
[08:26:19.697]                 {
[08:26:19.697]                   {
[08:26:19.697]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:19.697]                     NULL
[08:26:19.697]                   }
[08:26:19.697]                   options(future.plan = NULL)
[08:26:19.697]                   if (is.na(NA_character_)) 
[08:26:19.697]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.697]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:19.697]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:19.697]                     .init = FALSE)
[08:26:19.697]                 }
[08:26:19.697]             }
[08:26:19.697]         }
[08:26:19.697]     })
[08:26:19.697]     if (TRUE) {
[08:26:19.697]         base::sink(type = "output", split = FALSE)
[08:26:19.697]         if (TRUE) {
[08:26:19.697]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:19.697]         }
[08:26:19.697]         else {
[08:26:19.697]             ...future.result["stdout"] <- base::list(NULL)
[08:26:19.697]         }
[08:26:19.697]         base::close(...future.stdout)
[08:26:19.697]         ...future.stdout <- NULL
[08:26:19.697]     }
[08:26:19.697]     ...future.result$conditions <- ...future.conditions
[08:26:19.697]     ...future.result$finished <- base::Sys.time()
[08:26:19.697]     ...future.result
[08:26:19.697] }
[08:26:19.700] assign_globals() ...
[08:26:19.700] List of 11
[08:26:19.700]  $ ...future.FUN            :function (x, ...)  
[08:26:19.700]  $ x_FUN                    :function (x)  
[08:26:19.700]  $ times                    : int 1
[08:26:19.700]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.700]  $ stop_if_not              :function (...)  
[08:26:19.700]  $ dim                      : NULL
[08:26:19.700]  $ valid_types              : chr "character"
[08:26:19.700]  $ future.call.arguments    : list()
[08:26:19.700]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.700]  $ ...future.elements_ii    :List of 1
[08:26:19.700]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[08:26:19.700]  $ ...future.seeds_ii       : NULL
[08:26:19.700]  $ ...future.globals.maxSize: NULL
[08:26:19.700]  - attr(*, "where")=List of 11
[08:26:19.700]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:19.700]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:19.700]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:19.700]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:19.700]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:19.700]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:19.700]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:19.700]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:19.700]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:19.700]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:19.700]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:19.700]  - attr(*, "resolved")= logi FALSE
[08:26:19.700]  - attr(*, "total_size")= num 22333
[08:26:19.700]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.700]  - attr(*, "already-done")= logi TRUE
[08:26:19.709] - copied ‘...future.FUN’ to environment
[08:26:19.709] - copied ‘x_FUN’ to environment
[08:26:19.710] - copied ‘times’ to environment
[08:26:19.710] - copied ‘stopf’ to environment
[08:26:19.710] - copied ‘stop_if_not’ to environment
[08:26:19.710] - copied ‘dim’ to environment
[08:26:19.710] - copied ‘valid_types’ to environment
[08:26:19.710] - copied ‘future.call.arguments’ to environment
[08:26:19.710] - copied ‘...future.elements_ii’ to environment
[08:26:19.710] - copied ‘...future.seeds_ii’ to environment
[08:26:19.710] - copied ‘...future.globals.maxSize’ to environment
[08:26:19.710] assign_globals() ... done
[08:26:19.711] requestCore(): workers = 2
[08:26:19.714] MulticoreFuture started
[08:26:19.714] - Launch lazy future ... done
[08:26:19.715] run() for ‘MulticoreFuture’ ... done
[08:26:19.715] Created future:
[08:26:19.715] plan(): Setting new future strategy stack:
[08:26:19.715] List of future strategies:
[08:26:19.715] 1. sequential:
[08:26:19.715]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.715]    - tweaked: FALSE
[08:26:19.715]    - call: NULL
[08:26:19.716] plan(): nbrOfWorkers() = 1
[08:26:19.719] plan(): Setting new future strategy stack:
[08:26:19.719] List of future strategies:
[08:26:19.719] 1. multicore:
[08:26:19.719]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:19.719]    - tweaked: FALSE
[08:26:19.719]    - call: plan(strategy)
[08:26:19.722] plan(): nbrOfWorkers() = 2
[08:26:19.715] MulticoreFuture:
[08:26:19.715] Label: ‘future_vapply-1’
[08:26:19.715] Expression:
[08:26:19.715] {
[08:26:19.715]     do.call(function(...) {
[08:26:19.715]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.715]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.715]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.715]             on.exit(options(oopts), add = TRUE)
[08:26:19.715]         }
[08:26:19.715]         {
[08:26:19.715]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.715]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.715]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.715]             })
[08:26:19.715]         }
[08:26:19.715]     }, args = future.call.arguments)
[08:26:19.715] }
[08:26:19.715] Lazy evaluation: FALSE
[08:26:19.715] Asynchronous evaluation: TRUE
[08:26:19.715] Local evaluation: TRUE
[08:26:19.715] Environment: R_GlobalEnv
[08:26:19.715] Capture standard output: TRUE
[08:26:19.715] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:19.715] Globals: 11 objects totaling 12.33 KiB (function ‘...future.FUN’ of 4.02 KiB, function ‘x_FUN’ of 36 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:19.715] Packages: 1 packages (‘future.apply’)
[08:26:19.715] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:19.715] Resolved: TRUE
[08:26:19.715] Value: <not collected>
[08:26:19.715] Conditions captured: <none>
[08:26:19.715] Early signaling: FALSE
[08:26:19.715] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:19.715] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:19.724] Chunk #1 of 2 ... DONE
[08:26:19.724] Chunk #2 of 2 ...
[08:26:19.724]  - Finding globals in 'X' for chunk #2 ...
[08:26:19.724] getGlobalsAndPackages() ...
[08:26:19.724] Searching for globals...
[08:26:19.725] 
[08:26:19.725] Searching for globals ... DONE
[08:26:19.725] - globals: [0] <none>
[08:26:19.725] getGlobalsAndPackages() ... DONE
[08:26:19.725]    + additional globals found: [n=0] 
[08:26:19.726]    + additional namespaces needed: [n=0] 
[08:26:19.726]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:19.726]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:19.726]  - seeds: <none>
[08:26:19.726]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.726] getGlobalsAndPackages() ...
[08:26:19.727] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.727] Resolving globals: FALSE
[08:26:19.727] Tweak future expression to call with '...' arguments ...
[08:26:19.727] {
[08:26:19.727]     do.call(function(...) {
[08:26:19.727]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.727]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.727]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.727]             on.exit(options(oopts), add = TRUE)
[08:26:19.727]         }
[08:26:19.727]         {
[08:26:19.727]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.727]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.727]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.727]             })
[08:26:19.727]         }
[08:26:19.727]     }, args = future.call.arguments)
[08:26:19.727] }
[08:26:19.727] Tweak future expression to call with '...' arguments ... DONE
[08:26:19.728] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.729] - packages: [1] ‘future.apply’
[08:26:19.729] getGlobalsAndPackages() ... DONE
[08:26:19.729] run() for ‘Future’ ...
[08:26:19.729] - state: ‘created’
[08:26:19.730] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:19.732] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:19.732] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:19.732]   - Field: ‘label’
[08:26:19.733]   - Field: ‘local’
[08:26:19.733]   - Field: ‘owner’
[08:26:19.733]   - Field: ‘envir’
[08:26:19.733]   - Field: ‘workers’
[08:26:19.733]   - Field: ‘packages’
[08:26:19.733]   - Field: ‘gc’
[08:26:19.734]   - Field: ‘job’
[08:26:19.734]   - Field: ‘conditions’
[08:26:19.734]   - Field: ‘expr’
[08:26:19.734]   - Field: ‘uuid’
[08:26:19.734]   - Field: ‘seed’
[08:26:19.734]   - Field: ‘version’
[08:26:19.734]   - Field: ‘result’
[08:26:19.735]   - Field: ‘asynchronous’
[08:26:19.735]   - Field: ‘calls’
[08:26:19.735]   - Field: ‘globals’
[08:26:19.735]   - Field: ‘stdout’
[08:26:19.735]   - Field: ‘earlySignal’
[08:26:19.735]   - Field: ‘lazy’
[08:26:19.735]   - Field: ‘state’
[08:26:19.736] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:19.736] - Launch lazy future ...
[08:26:19.736] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:19.736] Packages needed by future strategies (n = 0): <none>
[08:26:19.737] {
[08:26:19.737]     {
[08:26:19.737]         {
[08:26:19.737]             ...future.startTime <- base::Sys.time()
[08:26:19.737]             {
[08:26:19.737]                 {
[08:26:19.737]                   {
[08:26:19.737]                     {
[08:26:19.737]                       {
[08:26:19.737]                         base::local({
[08:26:19.737]                           has_future <- base::requireNamespace("future", 
[08:26:19.737]                             quietly = TRUE)
[08:26:19.737]                           if (has_future) {
[08:26:19.737]                             ns <- base::getNamespace("future")
[08:26:19.737]                             version <- ns[[".package"]][["version"]]
[08:26:19.737]                             if (is.null(version)) 
[08:26:19.737]                               version <- utils::packageVersion("future")
[08:26:19.737]                           }
[08:26:19.737]                           else {
[08:26:19.737]                             version <- NULL
[08:26:19.737]                           }
[08:26:19.737]                           if (!has_future || version < "1.8.0") {
[08:26:19.737]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:19.737]                               "", base::R.version$version.string), 
[08:26:19.737]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:19.737]                                 base::R.version$platform, 8 * 
[08:26:19.737]                                   base::.Machine$sizeof.pointer), 
[08:26:19.737]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:19.737]                                 "release", "version")], collapse = " "), 
[08:26:19.737]                               hostname = base::Sys.info()[["nodename"]])
[08:26:19.737]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:19.737]                               info)
[08:26:19.737]                             info <- base::paste(info, collapse = "; ")
[08:26:19.737]                             if (!has_future) {
[08:26:19.737]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:19.737]                                 info)
[08:26:19.737]                             }
[08:26:19.737]                             else {
[08:26:19.737]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:19.737]                                 info, version)
[08:26:19.737]                             }
[08:26:19.737]                             base::stop(msg)
[08:26:19.737]                           }
[08:26:19.737]                         })
[08:26:19.737]                       }
[08:26:19.737]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:19.737]                       base::options(mc.cores = 1L)
[08:26:19.737]                     }
[08:26:19.737]                     base::local({
[08:26:19.737]                       for (pkg in "future.apply") {
[08:26:19.737]                         base::loadNamespace(pkg)
[08:26:19.737]                         base::library(pkg, character.only = TRUE)
[08:26:19.737]                       }
[08:26:19.737]                     })
[08:26:19.737]                   }
[08:26:19.737]                   ...future.strategy.old <- future::plan("list")
[08:26:19.737]                   options(future.plan = NULL)
[08:26:19.737]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.737]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:19.737]                 }
[08:26:19.737]                 ...future.workdir <- getwd()
[08:26:19.737]             }
[08:26:19.737]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:19.737]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:19.737]         }
[08:26:19.737]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:19.737]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:19.737]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:19.737]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:19.737]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:19.737]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:19.737]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:19.737]             base::names(...future.oldOptions))
[08:26:19.737]     }
[08:26:19.737]     if (FALSE) {
[08:26:19.737]     }
[08:26:19.737]     else {
[08:26:19.737]         if (TRUE) {
[08:26:19.737]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:19.737]                 open = "w")
[08:26:19.737]         }
[08:26:19.737]         else {
[08:26:19.737]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:19.737]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:19.737]         }
[08:26:19.737]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:19.737]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:19.737]             base::sink(type = "output", split = FALSE)
[08:26:19.737]             base::close(...future.stdout)
[08:26:19.737]         }, add = TRUE)
[08:26:19.737]     }
[08:26:19.737]     ...future.frame <- base::sys.nframe()
[08:26:19.737]     ...future.conditions <- base::list()
[08:26:19.737]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:19.737]     if (FALSE) {
[08:26:19.737]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:19.737]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:19.737]     }
[08:26:19.737]     ...future.result <- base::tryCatch({
[08:26:19.737]         base::withCallingHandlers({
[08:26:19.737]             ...future.value <- base::withVisible(base::local({
[08:26:19.737]                 withCallingHandlers({
[08:26:19.737]                   {
[08:26:19.737]                     do.call(function(...) {
[08:26:19.737]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.737]                       if (!identical(...future.globals.maxSize.org, 
[08:26:19.737]                         ...future.globals.maxSize)) {
[08:26:19.737]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.737]                         on.exit(options(oopts), add = TRUE)
[08:26:19.737]                       }
[08:26:19.737]                       {
[08:26:19.737]                         lapply(seq_along(...future.elements_ii), 
[08:26:19.737]                           FUN = function(jj) {
[08:26:19.737]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.737]                             ...future.FUN(...future.X_jj, ...)
[08:26:19.737]                           })
[08:26:19.737]                       }
[08:26:19.737]                     }, args = future.call.arguments)
[08:26:19.737]                   }
[08:26:19.737]                 }, immediateCondition = function(cond) {
[08:26:19.737]                   save_rds <- function (object, pathname, ...) 
[08:26:19.737]                   {
[08:26:19.737]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:19.737]                     if (file_test("-f", pathname_tmp)) {
[08:26:19.737]                       fi_tmp <- file.info(pathname_tmp)
[08:26:19.737]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:19.737]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:19.737]                         fi_tmp[["mtime"]])
[08:26:19.737]                     }
[08:26:19.737]                     tryCatch({
[08:26:19.737]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:19.737]                     }, error = function(ex) {
[08:26:19.737]                       msg <- conditionMessage(ex)
[08:26:19.737]                       fi_tmp <- file.info(pathname_tmp)
[08:26:19.737]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:19.737]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:19.737]                         fi_tmp[["mtime"]], msg)
[08:26:19.737]                       ex$message <- msg
[08:26:19.737]                       stop(ex)
[08:26:19.737]                     })
[08:26:19.737]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:19.737]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:19.737]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:19.737]                       fi_tmp <- file.info(pathname_tmp)
[08:26:19.737]                       fi <- file.info(pathname)
[08:26:19.737]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:19.737]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:19.737]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:19.737]                         fi[["size"]], fi[["mtime"]])
[08:26:19.737]                       stop(msg)
[08:26:19.737]                     }
[08:26:19.737]                     invisible(pathname)
[08:26:19.737]                   }
[08:26:19.737]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:19.737]                     rootPath = tempdir()) 
[08:26:19.737]                   {
[08:26:19.737]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:19.737]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:19.737]                       tmpdir = path, fileext = ".rds")
[08:26:19.737]                     save_rds(obj, file)
[08:26:19.737]                   }
[08:26:19.737]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:19.737]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.737]                   {
[08:26:19.737]                     inherits <- base::inherits
[08:26:19.737]                     invokeRestart <- base::invokeRestart
[08:26:19.737]                     is.null <- base::is.null
[08:26:19.737]                     muffled <- FALSE
[08:26:19.737]                     if (inherits(cond, "message")) {
[08:26:19.737]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:19.737]                       if (muffled) 
[08:26:19.737]                         invokeRestart("muffleMessage")
[08:26:19.737]                     }
[08:26:19.737]                     else if (inherits(cond, "warning")) {
[08:26:19.737]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:19.737]                       if (muffled) 
[08:26:19.737]                         invokeRestart("muffleWarning")
[08:26:19.737]                     }
[08:26:19.737]                     else if (inherits(cond, "condition")) {
[08:26:19.737]                       if (!is.null(pattern)) {
[08:26:19.737]                         computeRestarts <- base::computeRestarts
[08:26:19.737]                         grepl <- base::grepl
[08:26:19.737]                         restarts <- computeRestarts(cond)
[08:26:19.737]                         for (restart in restarts) {
[08:26:19.737]                           name <- restart$name
[08:26:19.737]                           if (is.null(name)) 
[08:26:19.737]                             next
[08:26:19.737]                           if (!grepl(pattern, name)) 
[08:26:19.737]                             next
[08:26:19.737]                           invokeRestart(restart)
[08:26:19.737]                           muffled <- TRUE
[08:26:19.737]                           break
[08:26:19.737]                         }
[08:26:19.737]                       }
[08:26:19.737]                     }
[08:26:19.737]                     invisible(muffled)
[08:26:19.737]                   }
[08:26:19.737]                   muffleCondition(cond)
[08:26:19.737]                 })
[08:26:19.737]             }))
[08:26:19.737]             future::FutureResult(value = ...future.value$value, 
[08:26:19.737]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.737]                   ...future.rng), globalenv = if (FALSE) 
[08:26:19.737]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:19.737]                     ...future.globalenv.names))
[08:26:19.737]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:19.737]         }, condition = base::local({
[08:26:19.737]             c <- base::c
[08:26:19.737]             inherits <- base::inherits
[08:26:19.737]             invokeRestart <- base::invokeRestart
[08:26:19.737]             length <- base::length
[08:26:19.737]             list <- base::list
[08:26:19.737]             seq.int <- base::seq.int
[08:26:19.737]             signalCondition <- base::signalCondition
[08:26:19.737]             sys.calls <- base::sys.calls
[08:26:19.737]             `[[` <- base::`[[`
[08:26:19.737]             `+` <- base::`+`
[08:26:19.737]             `<<-` <- base::`<<-`
[08:26:19.737]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:19.737]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:19.737]                   3L)]
[08:26:19.737]             }
[08:26:19.737]             function(cond) {
[08:26:19.737]                 is_error <- inherits(cond, "error")
[08:26:19.737]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:19.737]                   NULL)
[08:26:19.737]                 if (is_error) {
[08:26:19.737]                   sessionInformation <- function() {
[08:26:19.737]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:19.737]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:19.737]                       search = base::search(), system = base::Sys.info())
[08:26:19.737]                   }
[08:26:19.737]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.737]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:19.737]                     cond$call), session = sessionInformation(), 
[08:26:19.737]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:19.737]                   signalCondition(cond)
[08:26:19.737]                 }
[08:26:19.737]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:19.737]                 "immediateCondition"))) {
[08:26:19.737]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:19.737]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.737]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:19.737]                   if (TRUE && !signal) {
[08:26:19.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.737]                     {
[08:26:19.737]                       inherits <- base::inherits
[08:26:19.737]                       invokeRestart <- base::invokeRestart
[08:26:19.737]                       is.null <- base::is.null
[08:26:19.737]                       muffled <- FALSE
[08:26:19.737]                       if (inherits(cond, "message")) {
[08:26:19.737]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.737]                         if (muffled) 
[08:26:19.737]                           invokeRestart("muffleMessage")
[08:26:19.737]                       }
[08:26:19.737]                       else if (inherits(cond, "warning")) {
[08:26:19.737]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.737]                         if (muffled) 
[08:26:19.737]                           invokeRestart("muffleWarning")
[08:26:19.737]                       }
[08:26:19.737]                       else if (inherits(cond, "condition")) {
[08:26:19.737]                         if (!is.null(pattern)) {
[08:26:19.737]                           computeRestarts <- base::computeRestarts
[08:26:19.737]                           grepl <- base::grepl
[08:26:19.737]                           restarts <- computeRestarts(cond)
[08:26:19.737]                           for (restart in restarts) {
[08:26:19.737]                             name <- restart$name
[08:26:19.737]                             if (is.null(name)) 
[08:26:19.737]                               next
[08:26:19.737]                             if (!grepl(pattern, name)) 
[08:26:19.737]                               next
[08:26:19.737]                             invokeRestart(restart)
[08:26:19.737]                             muffled <- TRUE
[08:26:19.737]                             break
[08:26:19.737]                           }
[08:26:19.737]                         }
[08:26:19.737]                       }
[08:26:19.737]                       invisible(muffled)
[08:26:19.737]                     }
[08:26:19.737]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.737]                   }
[08:26:19.737]                 }
[08:26:19.737]                 else {
[08:26:19.737]                   if (TRUE) {
[08:26:19.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.737]                     {
[08:26:19.737]                       inherits <- base::inherits
[08:26:19.737]                       invokeRestart <- base::invokeRestart
[08:26:19.737]                       is.null <- base::is.null
[08:26:19.737]                       muffled <- FALSE
[08:26:19.737]                       if (inherits(cond, "message")) {
[08:26:19.737]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.737]                         if (muffled) 
[08:26:19.737]                           invokeRestart("muffleMessage")
[08:26:19.737]                       }
[08:26:19.737]                       else if (inherits(cond, "warning")) {
[08:26:19.737]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.737]                         if (muffled) 
[08:26:19.737]                           invokeRestart("muffleWarning")
[08:26:19.737]                       }
[08:26:19.737]                       else if (inherits(cond, "condition")) {
[08:26:19.737]                         if (!is.null(pattern)) {
[08:26:19.737]                           computeRestarts <- base::computeRestarts
[08:26:19.737]                           grepl <- base::grepl
[08:26:19.737]                           restarts <- computeRestarts(cond)
[08:26:19.737]                           for (restart in restarts) {
[08:26:19.737]                             name <- restart$name
[08:26:19.737]                             if (is.null(name)) 
[08:26:19.737]                               next
[08:26:19.737]                             if (!grepl(pattern, name)) 
[08:26:19.737]                               next
[08:26:19.737]                             invokeRestart(restart)
[08:26:19.737]                             muffled <- TRUE
[08:26:19.737]                             break
[08:26:19.737]                           }
[08:26:19.737]                         }
[08:26:19.737]                       }
[08:26:19.737]                       invisible(muffled)
[08:26:19.737]                     }
[08:26:19.737]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.737]                   }
[08:26:19.737]                 }
[08:26:19.737]             }
[08:26:19.737]         }))
[08:26:19.737]     }, error = function(ex) {
[08:26:19.737]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:19.737]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.737]                 ...future.rng), started = ...future.startTime, 
[08:26:19.737]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:19.737]             version = "1.8"), class = "FutureResult")
[08:26:19.737]     }, finally = {
[08:26:19.737]         if (!identical(...future.workdir, getwd())) 
[08:26:19.737]             setwd(...future.workdir)
[08:26:19.737]         {
[08:26:19.737]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:19.737]                 ...future.oldOptions$nwarnings <- NULL
[08:26:19.737]             }
[08:26:19.737]             base::options(...future.oldOptions)
[08:26:19.737]             if (.Platform$OS.type == "windows") {
[08:26:19.737]                 old_names <- names(...future.oldEnvVars)
[08:26:19.737]                 envs <- base::Sys.getenv()
[08:26:19.737]                 names <- names(envs)
[08:26:19.737]                 common <- intersect(names, old_names)
[08:26:19.737]                 added <- setdiff(names, old_names)
[08:26:19.737]                 removed <- setdiff(old_names, names)
[08:26:19.737]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:19.737]                   envs[common]]
[08:26:19.737]                 NAMES <- toupper(changed)
[08:26:19.737]                 args <- list()
[08:26:19.737]                 for (kk in seq_along(NAMES)) {
[08:26:19.737]                   name <- changed[[kk]]
[08:26:19.737]                   NAME <- NAMES[[kk]]
[08:26:19.737]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.737]                     next
[08:26:19.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.737]                 }
[08:26:19.737]                 NAMES <- toupper(added)
[08:26:19.737]                 for (kk in seq_along(NAMES)) {
[08:26:19.737]                   name <- added[[kk]]
[08:26:19.737]                   NAME <- NAMES[[kk]]
[08:26:19.737]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.737]                     next
[08:26:19.737]                   args[[name]] <- ""
[08:26:19.737]                 }
[08:26:19.737]                 NAMES <- toupper(removed)
[08:26:19.737]                 for (kk in seq_along(NAMES)) {
[08:26:19.737]                   name <- removed[[kk]]
[08:26:19.737]                   NAME <- NAMES[[kk]]
[08:26:19.737]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.737]                     next
[08:26:19.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.737]                 }
[08:26:19.737]                 if (length(args) > 0) 
[08:26:19.737]                   base::do.call(base::Sys.setenv, args = args)
[08:26:19.737]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:19.737]             }
[08:26:19.737]             else {
[08:26:19.737]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:19.737]             }
[08:26:19.737]             {
[08:26:19.737]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:19.737]                   0L) {
[08:26:19.737]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:19.737]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:19.737]                   base::options(opts)
[08:26:19.737]                 }
[08:26:19.737]                 {
[08:26:19.737]                   {
[08:26:19.737]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:19.737]                     NULL
[08:26:19.737]                   }
[08:26:19.737]                   options(future.plan = NULL)
[08:26:19.737]                   if (is.na(NA_character_)) 
[08:26:19.737]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.737]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:19.737]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:19.737]                     .init = FALSE)
[08:26:19.737]                 }
[08:26:19.737]             }
[08:26:19.737]         }
[08:26:19.737]     })
[08:26:19.737]     if (TRUE) {
[08:26:19.737]         base::sink(type = "output", split = FALSE)
[08:26:19.737]         if (TRUE) {
[08:26:19.737]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:19.737]         }
[08:26:19.737]         else {
[08:26:19.737]             ...future.result["stdout"] <- base::list(NULL)
[08:26:19.737]         }
[08:26:19.737]         base::close(...future.stdout)
[08:26:19.737]         ...future.stdout <- NULL
[08:26:19.737]     }
[08:26:19.737]     ...future.result$conditions <- ...future.conditions
[08:26:19.737]     ...future.result$finished <- base::Sys.time()
[08:26:19.737]     ...future.result
[08:26:19.737] }
[08:26:19.741] assign_globals() ...
[08:26:19.741] List of 11
[08:26:19.741]  $ ...future.FUN            :function (x, ...)  
[08:26:19.741]  $ x_FUN                    :function (x)  
[08:26:19.741]  $ times                    : int 1
[08:26:19.741]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.741]  $ stop_if_not              :function (...)  
[08:26:19.741]  $ dim                      : NULL
[08:26:19.741]  $ valid_types              : chr "character"
[08:26:19.741]  $ future.call.arguments    : list()
[08:26:19.741]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.741]  $ ...future.elements_ii    :List of 1
[08:26:19.741]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[08:26:19.741]  $ ...future.seeds_ii       : NULL
[08:26:19.741]  $ ...future.globals.maxSize: NULL
[08:26:19.741]  - attr(*, "where")=List of 11
[08:26:19.741]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:19.741]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:19.741]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:19.741]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:19.741]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:19.741]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:19.741]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:19.741]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:19.741]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:19.741]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:19.741]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:19.741]  - attr(*, "resolved")= logi FALSE
[08:26:19.741]  - attr(*, "total_size")= num 22333
[08:26:19.741]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.741]  - attr(*, "already-done")= logi TRUE
[08:26:19.760] - copied ‘...future.FUN’ to environment
[08:26:19.760] - copied ‘x_FUN’ to environment
[08:26:19.760] - copied ‘times’ to environment
[08:26:19.760] - copied ‘stopf’ to environment
[08:26:19.760] - copied ‘stop_if_not’ to environment
[08:26:19.760] - copied ‘dim’ to environment
[08:26:19.761] - copied ‘valid_types’ to environment
[08:26:19.761] - copied ‘future.call.arguments’ to environment
[08:26:19.761] - copied ‘...future.elements_ii’ to environment
[08:26:19.761] - copied ‘...future.seeds_ii’ to environment
[08:26:19.761] - copied ‘...future.globals.maxSize’ to environment
[08:26:19.761] assign_globals() ... done
[08:26:19.761] requestCore(): workers = 2
[08:26:19.767] MulticoreFuture started
[08:26:19.767] - Launch lazy future ... done
[08:26:19.768] run() for ‘MulticoreFuture’ ... done
[08:26:19.768] Created future:
[08:26:19.768] plan(): Setting new future strategy stack:
[08:26:19.769] List of future strategies:
[08:26:19.769] 1. sequential:
[08:26:19.769]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.769]    - tweaked: FALSE
[08:26:19.769]    - call: NULL
[08:26:19.770] plan(): nbrOfWorkers() = 1
[08:26:19.772] plan(): Setting new future strategy stack:
[08:26:19.772] List of future strategies:
[08:26:19.772] 1. multicore:
[08:26:19.772]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:19.772]    - tweaked: FALSE
[08:26:19.772]    - call: plan(strategy)
[08:26:19.776] plan(): nbrOfWorkers() = 2
[08:26:19.768] MulticoreFuture:
[08:26:19.768] Label: ‘future_vapply-2’
[08:26:19.768] Expression:
[08:26:19.768] {
[08:26:19.768]     do.call(function(...) {
[08:26:19.768]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.768]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.768]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.768]             on.exit(options(oopts), add = TRUE)
[08:26:19.768]         }
[08:26:19.768]         {
[08:26:19.768]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.768]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.768]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.768]             })
[08:26:19.768]         }
[08:26:19.768]     }, args = future.call.arguments)
[08:26:19.768] }
[08:26:19.768] Lazy evaluation: FALSE
[08:26:19.768] Asynchronous evaluation: TRUE
[08:26:19.768] Local evaluation: TRUE
[08:26:19.768] Environment: R_GlobalEnv
[08:26:19.768] Capture standard output: TRUE
[08:26:19.768] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:19.768] Globals: 11 objects totaling 12.32 KiB (function ‘...future.FUN’ of 4.02 KiB, function ‘x_FUN’ of 36 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:19.768] Packages: 1 packages (‘future.apply’)
[08:26:19.768] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:19.768] Resolved: TRUE
[08:26:19.768] Value: <not collected>
[08:26:19.768] Conditions captured: <none>
[08:26:19.768] Early signaling: FALSE
[08:26:19.768] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:19.768] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:19.777] Chunk #2 of 2 ... DONE
[08:26:19.777] Launching 2 futures (chunks) ... DONE
[08:26:19.777] Resolving 2 futures (chunks) ...
[08:26:19.778] resolve() on list ...
[08:26:19.778]  recursive: 0
[08:26:19.778]  length: 2
[08:26:19.778] 
[08:26:19.779] Future #1
[08:26:19.779] result() for MulticoreFuture ...
[08:26:19.781] result() for MulticoreFuture ...
[08:26:19.781] result() for MulticoreFuture ... done
[08:26:19.781] result() for MulticoreFuture ... done
[08:26:19.782] result() for MulticoreFuture ...
[08:26:19.782] result() for MulticoreFuture ... done
[08:26:19.782] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:26:19.782] - nx: 2
[08:26:19.782] - relay: TRUE
[08:26:19.782] - stdout: TRUE
[08:26:19.783] - signal: TRUE
[08:26:19.783] - resignal: FALSE
[08:26:19.783] - force: TRUE
[08:26:19.783] - relayed: [n=2] FALSE, FALSE
[08:26:19.783] - queued futures: [n=2] FALSE, FALSE
[08:26:19.783]  - until=1
[08:26:19.783]  - relaying element #1
[08:26:19.784] result() for MulticoreFuture ...
[08:26:19.784] result() for MulticoreFuture ... done
[08:26:19.784] result() for MulticoreFuture ...
[08:26:19.784] result() for MulticoreFuture ... done
[08:26:19.784] result() for MulticoreFuture ...
[08:26:19.784] result() for MulticoreFuture ... done
[08:26:19.784] result() for MulticoreFuture ...
[08:26:19.785] result() for MulticoreFuture ... done
[08:26:19.785] - relayed: [n=2] TRUE, FALSE
[08:26:19.785] - queued futures: [n=2] TRUE, FALSE
[08:26:19.785] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:26:19.785]  length: 1 (resolved future 1)
[08:26:19.786] Future #2
[08:26:19.786] result() for MulticoreFuture ...
[08:26:19.787] result() for MulticoreFuture ...
[08:26:19.787] result() for MulticoreFuture ... done
[08:26:19.787] result() for MulticoreFuture ... done
[08:26:19.787] result() for MulticoreFuture ...
[08:26:19.787] result() for MulticoreFuture ... done
[08:26:19.787] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:26:19.787] - nx: 2
[08:26:19.788] - relay: TRUE
[08:26:19.788] - stdout: TRUE
[08:26:19.788] - signal: TRUE
[08:26:19.788] - resignal: FALSE
[08:26:19.788] - force: TRUE
[08:26:19.788] - relayed: [n=2] TRUE, FALSE
[08:26:19.788] - queued futures: [n=2] TRUE, FALSE
[08:26:19.788]  - until=2
[08:26:19.788]  - relaying element #2
[08:26:19.789] result() for MulticoreFuture ...
[08:26:19.789] result() for MulticoreFuture ... done
[08:26:19.789] result() for MulticoreFuture ...
[08:26:19.789] result() for MulticoreFuture ... done
[08:26:19.789] result() for MulticoreFuture ...
[08:26:19.789] result() for MulticoreFuture ... done
[08:26:19.789] result() for MulticoreFuture ...
[08:26:19.790] result() for MulticoreFuture ... done
[08:26:19.790] - relayed: [n=2] TRUE, TRUE
[08:26:19.790] - queued futures: [n=2] TRUE, TRUE
[08:26:19.790] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:26:19.790]  length: 0 (resolved future 2)
[08:26:19.790] Relaying remaining futures
[08:26:19.790] signalConditionsASAP(NULL, pos=0) ...
[08:26:19.790] - nx: 2
[08:26:19.790] - relay: TRUE
[08:26:19.790] - stdout: TRUE
[08:26:19.791] - signal: TRUE
[08:26:19.791] - resignal: FALSE
[08:26:19.791] - force: TRUE
[08:26:19.791] - relayed: [n=2] TRUE, TRUE
[08:26:19.791] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:19.791] - relayed: [n=2] TRUE, TRUE
[08:26:19.791] - queued futures: [n=2] TRUE, TRUE
[08:26:19.791] signalConditionsASAP(NULL, pos=0) ... done
[08:26:19.791] resolve() on list ... DONE
[08:26:19.792] result() for MulticoreFuture ...
[08:26:19.792] result() for MulticoreFuture ... done
[08:26:19.792] result() for MulticoreFuture ...
[08:26:19.792] result() for MulticoreFuture ... done
[08:26:19.792] result() for MulticoreFuture ...
[08:26:19.792] result() for MulticoreFuture ... done
[08:26:19.792] result() for MulticoreFuture ...
[08:26:19.792] result() for MulticoreFuture ... done
[08:26:19.792]  - Number of value chunks collected: 2
[08:26:19.793] Resolving 2 futures (chunks) ... DONE
[08:26:19.793] Reducing values from 2 chunks ...
[08:26:19.793]  - Number of values collected after concatenation: 2
[08:26:19.793]  - Number of values expected: 2
[08:26:19.793] Reducing values from 2 chunks ... DONE
[08:26:19.793] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[08:26:19.794] future_lapply() ...
[08:26:19.801] Number of chunks: 2
[08:26:19.802] getGlobalsAndPackagesXApply() ...
[08:26:19.802]  - future.globals: TRUE
[08:26:19.802] getGlobalsAndPackages() ...
[08:26:19.802] Searching for globals...
[08:26:19.807] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[08:26:19.807] Searching for globals ... DONE
[08:26:19.807] Resolving globals: FALSE
[08:26:19.808] The total size of the 7 globals is 12.77 KiB (13081 bytes)
[08:26:19.809] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.77 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:19.809] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.809] - packages: [1] ‘future.apply’
[08:26:19.809] getGlobalsAndPackages() ... DONE
[08:26:19.809]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.810]  - needed namespaces: [n=1] ‘future.apply’
[08:26:19.810] Finding globals ... DONE
[08:26:19.810]  - use_args: TRUE
[08:26:19.810]  - Getting '...' globals ...
[08:26:19.810] resolve() on list ...
[08:26:19.810]  recursive: 0
[08:26:19.810]  length: 1
[08:26:19.811]  elements: ‘...’
[08:26:19.811]  length: 0 (resolved future 1)
[08:26:19.811] resolve() on list ... DONE
[08:26:19.811]    - '...' content: [n=0] 
[08:26:19.811] List of 1
[08:26:19.811]  $ ...: list()
[08:26:19.811]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.811]  - attr(*, "where")=List of 1
[08:26:19.811]   ..$ ...:<environment: 0x562ca7d59958> 
[08:26:19.811]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.811]  - attr(*, "resolved")= logi TRUE
[08:26:19.811]  - attr(*, "total_size")= num NA
[08:26:19.813]  - Getting '...' globals ... DONE
[08:26:19.814] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:19.814] List of 8
[08:26:19.814]  $ ...future.FUN:function (x, ...)  
[08:26:19.814]  $ x_FUN        :function (x)  
[08:26:19.814]  $ times        : int 0
[08:26:19.814]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.814]  $ stop_if_not  :function (...)  
[08:26:19.814]  $ dim          : NULL
[08:26:19.814]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:19.814]  $ ...          : list()
[08:26:19.814]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.814]  - attr(*, "where")=List of 8
[08:26:19.814]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:19.814]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:19.814]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:19.814]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:19.814]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:19.814]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:19.814]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:19.814]   ..$ ...          :<environment: 0x562ca7d59958> 
[08:26:19.814]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.814]  - attr(*, "resolved")= logi FALSE
[08:26:19.814]  - attr(*, "total_size")= num 23490
[08:26:19.819] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:19.819] getGlobalsAndPackagesXApply() ... DONE
[08:26:19.820] Number of futures (= number of chunks): 2
[08:26:19.820] Launching 2 futures (chunks) ...
[08:26:19.820] Chunk #1 of 2 ...
[08:26:19.820]  - Finding globals in 'X' for chunk #1 ...
[08:26:19.820] getGlobalsAndPackages() ...
[08:26:19.820] Searching for globals...
[08:26:19.820] 
[08:26:19.820] Searching for globals ... DONE
[08:26:19.821] - globals: [0] <none>
[08:26:19.821] getGlobalsAndPackages() ... DONE
[08:26:19.821]    + additional globals found: [n=0] 
[08:26:19.821]    + additional namespaces needed: [n=0] 
[08:26:19.821]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:19.821]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:19.821]  - seeds: <none>
[08:26:19.821]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.821] getGlobalsAndPackages() ...
[08:26:19.821] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.822] Resolving globals: FALSE
[08:26:19.822] Tweak future expression to call with '...' arguments ...
[08:26:19.822] {
[08:26:19.822]     do.call(function(...) {
[08:26:19.822]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.822]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.822]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.822]             on.exit(options(oopts), add = TRUE)
[08:26:19.822]         }
[08:26:19.822]         {
[08:26:19.822]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.822]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.822]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.822]             })
[08:26:19.822]         }
[08:26:19.822]     }, args = future.call.arguments)
[08:26:19.822] }
[08:26:19.822] Tweak future expression to call with '...' arguments ... DONE
[08:26:19.823] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.823] - packages: [1] ‘future.apply’
[08:26:19.823] getGlobalsAndPackages() ... DONE
[08:26:19.823] run() for ‘Future’ ...
[08:26:19.823] - state: ‘created’
[08:26:19.823] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:19.827] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:19.827] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:19.827]   - Field: ‘label’
[08:26:19.828]   - Field: ‘local’
[08:26:19.828]   - Field: ‘owner’
[08:26:19.828]   - Field: ‘envir’
[08:26:19.828]   - Field: ‘workers’
[08:26:19.828]   - Field: ‘packages’
[08:26:19.828]   - Field: ‘gc’
[08:26:19.828]   - Field: ‘job’
[08:26:19.828]   - Field: ‘conditions’
[08:26:19.828]   - Field: ‘expr’
[08:26:19.829]   - Field: ‘uuid’
[08:26:19.829]   - Field: ‘seed’
[08:26:19.829]   - Field: ‘version’
[08:26:19.829]   - Field: ‘result’
[08:26:19.829]   - Field: ‘asynchronous’
[08:26:19.829]   - Field: ‘calls’
[08:26:19.829]   - Field: ‘globals’
[08:26:19.829]   - Field: ‘stdout’
[08:26:19.830]   - Field: ‘earlySignal’
[08:26:19.830]   - Field: ‘lazy’
[08:26:19.830]   - Field: ‘state’
[08:26:19.830] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:19.830] - Launch lazy future ...
[08:26:19.830] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:19.830] Packages needed by future strategies (n = 0): <none>
[08:26:19.831] {
[08:26:19.831]     {
[08:26:19.831]         {
[08:26:19.831]             ...future.startTime <- base::Sys.time()
[08:26:19.831]             {
[08:26:19.831]                 {
[08:26:19.831]                   {
[08:26:19.831]                     {
[08:26:19.831]                       {
[08:26:19.831]                         base::local({
[08:26:19.831]                           has_future <- base::requireNamespace("future", 
[08:26:19.831]                             quietly = TRUE)
[08:26:19.831]                           if (has_future) {
[08:26:19.831]                             ns <- base::getNamespace("future")
[08:26:19.831]                             version <- ns[[".package"]][["version"]]
[08:26:19.831]                             if (is.null(version)) 
[08:26:19.831]                               version <- utils::packageVersion("future")
[08:26:19.831]                           }
[08:26:19.831]                           else {
[08:26:19.831]                             version <- NULL
[08:26:19.831]                           }
[08:26:19.831]                           if (!has_future || version < "1.8.0") {
[08:26:19.831]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:19.831]                               "", base::R.version$version.string), 
[08:26:19.831]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:19.831]                                 base::R.version$platform, 8 * 
[08:26:19.831]                                   base::.Machine$sizeof.pointer), 
[08:26:19.831]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:19.831]                                 "release", "version")], collapse = " "), 
[08:26:19.831]                               hostname = base::Sys.info()[["nodename"]])
[08:26:19.831]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:19.831]                               info)
[08:26:19.831]                             info <- base::paste(info, collapse = "; ")
[08:26:19.831]                             if (!has_future) {
[08:26:19.831]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:19.831]                                 info)
[08:26:19.831]                             }
[08:26:19.831]                             else {
[08:26:19.831]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:19.831]                                 info, version)
[08:26:19.831]                             }
[08:26:19.831]                             base::stop(msg)
[08:26:19.831]                           }
[08:26:19.831]                         })
[08:26:19.831]                       }
[08:26:19.831]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:19.831]                       base::options(mc.cores = 1L)
[08:26:19.831]                     }
[08:26:19.831]                     base::local({
[08:26:19.831]                       for (pkg in "future.apply") {
[08:26:19.831]                         base::loadNamespace(pkg)
[08:26:19.831]                         base::library(pkg, character.only = TRUE)
[08:26:19.831]                       }
[08:26:19.831]                     })
[08:26:19.831]                   }
[08:26:19.831]                   ...future.strategy.old <- future::plan("list")
[08:26:19.831]                   options(future.plan = NULL)
[08:26:19.831]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.831]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:19.831]                 }
[08:26:19.831]                 ...future.workdir <- getwd()
[08:26:19.831]             }
[08:26:19.831]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:19.831]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:19.831]         }
[08:26:19.831]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:19.831]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:19.831]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:19.831]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:19.831]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:19.831]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:19.831]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:19.831]             base::names(...future.oldOptions))
[08:26:19.831]     }
[08:26:19.831]     if (FALSE) {
[08:26:19.831]     }
[08:26:19.831]     else {
[08:26:19.831]         if (TRUE) {
[08:26:19.831]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:19.831]                 open = "w")
[08:26:19.831]         }
[08:26:19.831]         else {
[08:26:19.831]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:19.831]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:19.831]         }
[08:26:19.831]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:19.831]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:19.831]             base::sink(type = "output", split = FALSE)
[08:26:19.831]             base::close(...future.stdout)
[08:26:19.831]         }, add = TRUE)
[08:26:19.831]     }
[08:26:19.831]     ...future.frame <- base::sys.nframe()
[08:26:19.831]     ...future.conditions <- base::list()
[08:26:19.831]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:19.831]     if (FALSE) {
[08:26:19.831]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:19.831]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:19.831]     }
[08:26:19.831]     ...future.result <- base::tryCatch({
[08:26:19.831]         base::withCallingHandlers({
[08:26:19.831]             ...future.value <- base::withVisible(base::local({
[08:26:19.831]                 withCallingHandlers({
[08:26:19.831]                   {
[08:26:19.831]                     do.call(function(...) {
[08:26:19.831]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.831]                       if (!identical(...future.globals.maxSize.org, 
[08:26:19.831]                         ...future.globals.maxSize)) {
[08:26:19.831]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.831]                         on.exit(options(oopts), add = TRUE)
[08:26:19.831]                       }
[08:26:19.831]                       {
[08:26:19.831]                         lapply(seq_along(...future.elements_ii), 
[08:26:19.831]                           FUN = function(jj) {
[08:26:19.831]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.831]                             ...future.FUN(...future.X_jj, ...)
[08:26:19.831]                           })
[08:26:19.831]                       }
[08:26:19.831]                     }, args = future.call.arguments)
[08:26:19.831]                   }
[08:26:19.831]                 }, immediateCondition = function(cond) {
[08:26:19.831]                   save_rds <- function (object, pathname, ...) 
[08:26:19.831]                   {
[08:26:19.831]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:19.831]                     if (file_test("-f", pathname_tmp)) {
[08:26:19.831]                       fi_tmp <- file.info(pathname_tmp)
[08:26:19.831]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:19.831]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:19.831]                         fi_tmp[["mtime"]])
[08:26:19.831]                     }
[08:26:19.831]                     tryCatch({
[08:26:19.831]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:19.831]                     }, error = function(ex) {
[08:26:19.831]                       msg <- conditionMessage(ex)
[08:26:19.831]                       fi_tmp <- file.info(pathname_tmp)
[08:26:19.831]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:19.831]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:19.831]                         fi_tmp[["mtime"]], msg)
[08:26:19.831]                       ex$message <- msg
[08:26:19.831]                       stop(ex)
[08:26:19.831]                     })
[08:26:19.831]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:19.831]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:19.831]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:19.831]                       fi_tmp <- file.info(pathname_tmp)
[08:26:19.831]                       fi <- file.info(pathname)
[08:26:19.831]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:19.831]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:19.831]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:19.831]                         fi[["size"]], fi[["mtime"]])
[08:26:19.831]                       stop(msg)
[08:26:19.831]                     }
[08:26:19.831]                     invisible(pathname)
[08:26:19.831]                   }
[08:26:19.831]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:19.831]                     rootPath = tempdir()) 
[08:26:19.831]                   {
[08:26:19.831]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:19.831]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:19.831]                       tmpdir = path, fileext = ".rds")
[08:26:19.831]                     save_rds(obj, file)
[08:26:19.831]                   }
[08:26:19.831]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:19.831]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.831]                   {
[08:26:19.831]                     inherits <- base::inherits
[08:26:19.831]                     invokeRestart <- base::invokeRestart
[08:26:19.831]                     is.null <- base::is.null
[08:26:19.831]                     muffled <- FALSE
[08:26:19.831]                     if (inherits(cond, "message")) {
[08:26:19.831]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:19.831]                       if (muffled) 
[08:26:19.831]                         invokeRestart("muffleMessage")
[08:26:19.831]                     }
[08:26:19.831]                     else if (inherits(cond, "warning")) {
[08:26:19.831]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:19.831]                       if (muffled) 
[08:26:19.831]                         invokeRestart("muffleWarning")
[08:26:19.831]                     }
[08:26:19.831]                     else if (inherits(cond, "condition")) {
[08:26:19.831]                       if (!is.null(pattern)) {
[08:26:19.831]                         computeRestarts <- base::computeRestarts
[08:26:19.831]                         grepl <- base::grepl
[08:26:19.831]                         restarts <- computeRestarts(cond)
[08:26:19.831]                         for (restart in restarts) {
[08:26:19.831]                           name <- restart$name
[08:26:19.831]                           if (is.null(name)) 
[08:26:19.831]                             next
[08:26:19.831]                           if (!grepl(pattern, name)) 
[08:26:19.831]                             next
[08:26:19.831]                           invokeRestart(restart)
[08:26:19.831]                           muffled <- TRUE
[08:26:19.831]                           break
[08:26:19.831]                         }
[08:26:19.831]                       }
[08:26:19.831]                     }
[08:26:19.831]                     invisible(muffled)
[08:26:19.831]                   }
[08:26:19.831]                   muffleCondition(cond)
[08:26:19.831]                 })
[08:26:19.831]             }))
[08:26:19.831]             future::FutureResult(value = ...future.value$value, 
[08:26:19.831]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.831]                   ...future.rng), globalenv = if (FALSE) 
[08:26:19.831]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:19.831]                     ...future.globalenv.names))
[08:26:19.831]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:19.831]         }, condition = base::local({
[08:26:19.831]             c <- base::c
[08:26:19.831]             inherits <- base::inherits
[08:26:19.831]             invokeRestart <- base::invokeRestart
[08:26:19.831]             length <- base::length
[08:26:19.831]             list <- base::list
[08:26:19.831]             seq.int <- base::seq.int
[08:26:19.831]             signalCondition <- base::signalCondition
[08:26:19.831]             sys.calls <- base::sys.calls
[08:26:19.831]             `[[` <- base::`[[`
[08:26:19.831]             `+` <- base::`+`
[08:26:19.831]             `<<-` <- base::`<<-`
[08:26:19.831]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:19.831]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:19.831]                   3L)]
[08:26:19.831]             }
[08:26:19.831]             function(cond) {
[08:26:19.831]                 is_error <- inherits(cond, "error")
[08:26:19.831]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:19.831]                   NULL)
[08:26:19.831]                 if (is_error) {
[08:26:19.831]                   sessionInformation <- function() {
[08:26:19.831]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:19.831]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:19.831]                       search = base::search(), system = base::Sys.info())
[08:26:19.831]                   }
[08:26:19.831]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.831]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:19.831]                     cond$call), session = sessionInformation(), 
[08:26:19.831]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:19.831]                   signalCondition(cond)
[08:26:19.831]                 }
[08:26:19.831]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:19.831]                 "immediateCondition"))) {
[08:26:19.831]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:19.831]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.831]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:19.831]                   if (TRUE && !signal) {
[08:26:19.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.831]                     {
[08:26:19.831]                       inherits <- base::inherits
[08:26:19.831]                       invokeRestart <- base::invokeRestart
[08:26:19.831]                       is.null <- base::is.null
[08:26:19.831]                       muffled <- FALSE
[08:26:19.831]                       if (inherits(cond, "message")) {
[08:26:19.831]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.831]                         if (muffled) 
[08:26:19.831]                           invokeRestart("muffleMessage")
[08:26:19.831]                       }
[08:26:19.831]                       else if (inherits(cond, "warning")) {
[08:26:19.831]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.831]                         if (muffled) 
[08:26:19.831]                           invokeRestart("muffleWarning")
[08:26:19.831]                       }
[08:26:19.831]                       else if (inherits(cond, "condition")) {
[08:26:19.831]                         if (!is.null(pattern)) {
[08:26:19.831]                           computeRestarts <- base::computeRestarts
[08:26:19.831]                           grepl <- base::grepl
[08:26:19.831]                           restarts <- computeRestarts(cond)
[08:26:19.831]                           for (restart in restarts) {
[08:26:19.831]                             name <- restart$name
[08:26:19.831]                             if (is.null(name)) 
[08:26:19.831]                               next
[08:26:19.831]                             if (!grepl(pattern, name)) 
[08:26:19.831]                               next
[08:26:19.831]                             invokeRestart(restart)
[08:26:19.831]                             muffled <- TRUE
[08:26:19.831]                             break
[08:26:19.831]                           }
[08:26:19.831]                         }
[08:26:19.831]                       }
[08:26:19.831]                       invisible(muffled)
[08:26:19.831]                     }
[08:26:19.831]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.831]                   }
[08:26:19.831]                 }
[08:26:19.831]                 else {
[08:26:19.831]                   if (TRUE) {
[08:26:19.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.831]                     {
[08:26:19.831]                       inherits <- base::inherits
[08:26:19.831]                       invokeRestart <- base::invokeRestart
[08:26:19.831]                       is.null <- base::is.null
[08:26:19.831]                       muffled <- FALSE
[08:26:19.831]                       if (inherits(cond, "message")) {
[08:26:19.831]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.831]                         if (muffled) 
[08:26:19.831]                           invokeRestart("muffleMessage")
[08:26:19.831]                       }
[08:26:19.831]                       else if (inherits(cond, "warning")) {
[08:26:19.831]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.831]                         if (muffled) 
[08:26:19.831]                           invokeRestart("muffleWarning")
[08:26:19.831]                       }
[08:26:19.831]                       else if (inherits(cond, "condition")) {
[08:26:19.831]                         if (!is.null(pattern)) {
[08:26:19.831]                           computeRestarts <- base::computeRestarts
[08:26:19.831]                           grepl <- base::grepl
[08:26:19.831]                           restarts <- computeRestarts(cond)
[08:26:19.831]                           for (restart in restarts) {
[08:26:19.831]                             name <- restart$name
[08:26:19.831]                             if (is.null(name)) 
[08:26:19.831]                               next
[08:26:19.831]                             if (!grepl(pattern, name)) 
[08:26:19.831]                               next
[08:26:19.831]                             invokeRestart(restart)
[08:26:19.831]                             muffled <- TRUE
[08:26:19.831]                             break
[08:26:19.831]                           }
[08:26:19.831]                         }
[08:26:19.831]                       }
[08:26:19.831]                       invisible(muffled)
[08:26:19.831]                     }
[08:26:19.831]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.831]                   }
[08:26:19.831]                 }
[08:26:19.831]             }
[08:26:19.831]         }))
[08:26:19.831]     }, error = function(ex) {
[08:26:19.831]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:19.831]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.831]                 ...future.rng), started = ...future.startTime, 
[08:26:19.831]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:19.831]             version = "1.8"), class = "FutureResult")
[08:26:19.831]     }, finally = {
[08:26:19.831]         if (!identical(...future.workdir, getwd())) 
[08:26:19.831]             setwd(...future.workdir)
[08:26:19.831]         {
[08:26:19.831]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:19.831]                 ...future.oldOptions$nwarnings <- NULL
[08:26:19.831]             }
[08:26:19.831]             base::options(...future.oldOptions)
[08:26:19.831]             if (.Platform$OS.type == "windows") {
[08:26:19.831]                 old_names <- names(...future.oldEnvVars)
[08:26:19.831]                 envs <- base::Sys.getenv()
[08:26:19.831]                 names <- names(envs)
[08:26:19.831]                 common <- intersect(names, old_names)
[08:26:19.831]                 added <- setdiff(names, old_names)
[08:26:19.831]                 removed <- setdiff(old_names, names)
[08:26:19.831]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:19.831]                   envs[common]]
[08:26:19.831]                 NAMES <- toupper(changed)
[08:26:19.831]                 args <- list()
[08:26:19.831]                 for (kk in seq_along(NAMES)) {
[08:26:19.831]                   name <- changed[[kk]]
[08:26:19.831]                   NAME <- NAMES[[kk]]
[08:26:19.831]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.831]                     next
[08:26:19.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.831]                 }
[08:26:19.831]                 NAMES <- toupper(added)
[08:26:19.831]                 for (kk in seq_along(NAMES)) {
[08:26:19.831]                   name <- added[[kk]]
[08:26:19.831]                   NAME <- NAMES[[kk]]
[08:26:19.831]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.831]                     next
[08:26:19.831]                   args[[name]] <- ""
[08:26:19.831]                 }
[08:26:19.831]                 NAMES <- toupper(removed)
[08:26:19.831]                 for (kk in seq_along(NAMES)) {
[08:26:19.831]                   name <- removed[[kk]]
[08:26:19.831]                   NAME <- NAMES[[kk]]
[08:26:19.831]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.831]                     next
[08:26:19.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.831]                 }
[08:26:19.831]                 if (length(args) > 0) 
[08:26:19.831]                   base::do.call(base::Sys.setenv, args = args)
[08:26:19.831]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:19.831]             }
[08:26:19.831]             else {
[08:26:19.831]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:19.831]             }
[08:26:19.831]             {
[08:26:19.831]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:19.831]                   0L) {
[08:26:19.831]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:19.831]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:19.831]                   base::options(opts)
[08:26:19.831]                 }
[08:26:19.831]                 {
[08:26:19.831]                   {
[08:26:19.831]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:19.831]                     NULL
[08:26:19.831]                   }
[08:26:19.831]                   options(future.plan = NULL)
[08:26:19.831]                   if (is.na(NA_character_)) 
[08:26:19.831]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.831]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:19.831]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:19.831]                     .init = FALSE)
[08:26:19.831]                 }
[08:26:19.831]             }
[08:26:19.831]         }
[08:26:19.831]     })
[08:26:19.831]     if (TRUE) {
[08:26:19.831]         base::sink(type = "output", split = FALSE)
[08:26:19.831]         if (TRUE) {
[08:26:19.831]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:19.831]         }
[08:26:19.831]         else {
[08:26:19.831]             ...future.result["stdout"] <- base::list(NULL)
[08:26:19.831]         }
[08:26:19.831]         base::close(...future.stdout)
[08:26:19.831]         ...future.stdout <- NULL
[08:26:19.831]     }
[08:26:19.831]     ...future.result$conditions <- ...future.conditions
[08:26:19.831]     ...future.result$finished <- base::Sys.time()
[08:26:19.831]     ...future.result
[08:26:19.831] }
[08:26:19.834] assign_globals() ...
[08:26:19.834] List of 11
[08:26:19.834]  $ ...future.FUN            :function (x, ...)  
[08:26:19.834]  $ x_FUN                    :function (x)  
[08:26:19.834]  $ times                    : int 0
[08:26:19.834]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.834]  $ stop_if_not              :function (...)  
[08:26:19.834]  $ dim                      : NULL
[08:26:19.834]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:19.834]  $ future.call.arguments    : list()
[08:26:19.834]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.834]  $ ...future.elements_ii    :List of 5
[08:26:19.834]   ..$ : int 1
[08:26:19.834]   ..$ : int 2
[08:26:19.834]   ..$ : int 3
[08:26:19.834]   ..$ : int 4
[08:26:19.834]   ..$ : int 5
[08:26:19.834]  $ ...future.seeds_ii       : NULL
[08:26:19.834]  $ ...future.globals.maxSize: NULL
[08:26:19.834]  - attr(*, "where")=List of 11
[08:26:19.834]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:19.834]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:19.834]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:19.834]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:19.834]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:19.834]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:19.834]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:19.834]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:19.834]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:19.834]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:19.834]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:19.834]  - attr(*, "resolved")= logi FALSE
[08:26:19.834]  - attr(*, "total_size")= num 23490
[08:26:19.834]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.834]  - attr(*, "already-done")= logi TRUE
[08:26:19.842] - copied ‘...future.FUN’ to environment
[08:26:19.842] - reassign environment for ‘x_FUN’
[08:26:19.842] - copied ‘x_FUN’ to environment
[08:26:19.842] - copied ‘times’ to environment
[08:26:19.843] - copied ‘stopf’ to environment
[08:26:19.843] - copied ‘stop_if_not’ to environment
[08:26:19.843] - copied ‘dim’ to environment
[08:26:19.843] - copied ‘valid_types’ to environment
[08:26:19.843] - copied ‘future.call.arguments’ to environment
[08:26:19.843] - copied ‘...future.elements_ii’ to environment
[08:26:19.843] - copied ‘...future.seeds_ii’ to environment
[08:26:19.843] - copied ‘...future.globals.maxSize’ to environment
[08:26:19.843] assign_globals() ... done
[08:26:19.843] requestCore(): workers = 2
[08:26:19.846] MulticoreFuture started
[08:26:19.846] - Launch lazy future ... done
[08:26:19.846] run() for ‘MulticoreFuture’ ... done
[08:26:19.847] Created future:
[08:26:19.847] plan(): Setting new future strategy stack:
[08:26:19.847] List of future strategies:
[08:26:19.847] 1. sequential:
[08:26:19.847]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.847]    - tweaked: FALSE
[08:26:19.847]    - call: NULL
[08:26:19.848] plan(): nbrOfWorkers() = 1
[08:26:19.851] plan(): Setting new future strategy stack:
[08:26:19.851] List of future strategies:
[08:26:19.851] 1. multicore:
[08:26:19.851]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:19.851]    - tweaked: FALSE
[08:26:19.851]    - call: plan(strategy)
[08:26:19.854] plan(): nbrOfWorkers() = 2
[08:26:19.847] MulticoreFuture:
[08:26:19.847] Label: ‘future_vapply-1’
[08:26:19.847] Expression:
[08:26:19.847] {
[08:26:19.847]     do.call(function(...) {
[08:26:19.847]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.847]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.847]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.847]             on.exit(options(oopts), add = TRUE)
[08:26:19.847]         }
[08:26:19.847]         {
[08:26:19.847]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.847]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.847]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.847]             })
[08:26:19.847]         }
[08:26:19.847]     }, args = future.call.arguments)
[08:26:19.847] }
[08:26:19.847] Lazy evaluation: FALSE
[08:26:19.847] Asynchronous evaluation: TRUE
[08:26:19.847] Local evaluation: TRUE
[08:26:19.847] Environment: R_GlobalEnv
[08:26:19.847] Capture standard output: TRUE
[08:26:19.847] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:19.847] Globals: 11 objects totaling 13.01 KiB (function ‘...future.FUN’ of 4.50 KiB, function ‘x_FUN’ of 295 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:19.847] Packages: 1 packages (‘future.apply’)
[08:26:19.847] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:19.847] Resolved: TRUE
[08:26:19.847] Value: <not collected>
[08:26:19.847] Conditions captured: <none>
[08:26:19.847] Early signaling: FALSE
[08:26:19.847] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:19.847] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:19.855] Chunk #1 of 2 ... DONE
[08:26:19.855] Chunk #2 of 2 ...
[08:26:19.855]  - Finding globals in 'X' for chunk #2 ...
[08:26:19.856] getGlobalsAndPackages() ...
[08:26:19.856] Searching for globals...
[08:26:19.856] 
[08:26:19.856] Searching for globals ... DONE
[08:26:19.856] - globals: [0] <none>
[08:26:19.856] getGlobalsAndPackages() ... DONE
[08:26:19.857]    + additional globals found: [n=0] 
[08:26:19.857]    + additional namespaces needed: [n=0] 
[08:26:19.857]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:19.857]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:19.857]  - seeds: <none>
[08:26:19.857]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.857] getGlobalsAndPackages() ...
[08:26:19.857] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.858] Resolving globals: FALSE
[08:26:19.858] Tweak future expression to call with '...' arguments ...
[08:26:19.858] {
[08:26:19.858]     do.call(function(...) {
[08:26:19.858]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.858]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.858]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.858]             on.exit(options(oopts), add = TRUE)
[08:26:19.858]         }
[08:26:19.858]         {
[08:26:19.858]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.858]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.858]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.858]             })
[08:26:19.858]         }
[08:26:19.858]     }, args = future.call.arguments)
[08:26:19.858] }
[08:26:19.858] Tweak future expression to call with '...' arguments ... DONE
[08:26:19.859] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.860] - packages: [1] ‘future.apply’
[08:26:19.860] getGlobalsAndPackages() ... DONE
[08:26:19.860] run() for ‘Future’ ...
[08:26:19.860] - state: ‘created’
[08:26:19.861] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:19.868] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:19.868] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:19.869]   - Field: ‘label’
[08:26:19.869]   - Field: ‘local’
[08:26:19.869]   - Field: ‘owner’
[08:26:19.869]   - Field: ‘envir’
[08:26:19.870]   - Field: ‘workers’
[08:26:19.870]   - Field: ‘packages’
[08:26:19.870]   - Field: ‘gc’
[08:26:19.871]   - Field: ‘job’
[08:26:19.871]   - Field: ‘conditions’
[08:26:19.871]   - Field: ‘expr’
[08:26:19.871]   - Field: ‘uuid’
[08:26:19.872]   - Field: ‘seed’
[08:26:19.872]   - Field: ‘version’
[08:26:19.872]   - Field: ‘result’
[08:26:19.872]   - Field: ‘asynchronous’
[08:26:19.873]   - Field: ‘calls’
[08:26:19.873]   - Field: ‘globals’
[08:26:19.873]   - Field: ‘stdout’
[08:26:19.873]   - Field: ‘earlySignal’
[08:26:19.873]   - Field: ‘lazy’
[08:26:19.874]   - Field: ‘state’
[08:26:19.874] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:19.874] - Launch lazy future ...
[08:26:19.875] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:19.875] Packages needed by future strategies (n = 0): <none>
[08:26:19.876] {
[08:26:19.876]     {
[08:26:19.876]         {
[08:26:19.876]             ...future.startTime <- base::Sys.time()
[08:26:19.876]             {
[08:26:19.876]                 {
[08:26:19.876]                   {
[08:26:19.876]                     {
[08:26:19.876]                       {
[08:26:19.876]                         base::local({
[08:26:19.876]                           has_future <- base::requireNamespace("future", 
[08:26:19.876]                             quietly = TRUE)
[08:26:19.876]                           if (has_future) {
[08:26:19.876]                             ns <- base::getNamespace("future")
[08:26:19.876]                             version <- ns[[".package"]][["version"]]
[08:26:19.876]                             if (is.null(version)) 
[08:26:19.876]                               version <- utils::packageVersion("future")
[08:26:19.876]                           }
[08:26:19.876]                           else {
[08:26:19.876]                             version <- NULL
[08:26:19.876]                           }
[08:26:19.876]                           if (!has_future || version < "1.8.0") {
[08:26:19.876]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:19.876]                               "", base::R.version$version.string), 
[08:26:19.876]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:19.876]                                 base::R.version$platform, 8 * 
[08:26:19.876]                                   base::.Machine$sizeof.pointer), 
[08:26:19.876]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:19.876]                                 "release", "version")], collapse = " "), 
[08:26:19.876]                               hostname = base::Sys.info()[["nodename"]])
[08:26:19.876]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:19.876]                               info)
[08:26:19.876]                             info <- base::paste(info, collapse = "; ")
[08:26:19.876]                             if (!has_future) {
[08:26:19.876]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:19.876]                                 info)
[08:26:19.876]                             }
[08:26:19.876]                             else {
[08:26:19.876]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:19.876]                                 info, version)
[08:26:19.876]                             }
[08:26:19.876]                             base::stop(msg)
[08:26:19.876]                           }
[08:26:19.876]                         })
[08:26:19.876]                       }
[08:26:19.876]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:19.876]                       base::options(mc.cores = 1L)
[08:26:19.876]                     }
[08:26:19.876]                     base::local({
[08:26:19.876]                       for (pkg in "future.apply") {
[08:26:19.876]                         base::loadNamespace(pkg)
[08:26:19.876]                         base::library(pkg, character.only = TRUE)
[08:26:19.876]                       }
[08:26:19.876]                     })
[08:26:19.876]                   }
[08:26:19.876]                   ...future.strategy.old <- future::plan("list")
[08:26:19.876]                   options(future.plan = NULL)
[08:26:19.876]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.876]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:19.876]                 }
[08:26:19.876]                 ...future.workdir <- getwd()
[08:26:19.876]             }
[08:26:19.876]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:19.876]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:19.876]         }
[08:26:19.876]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:19.876]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:19.876]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:19.876]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:19.876]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:19.876]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:19.876]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:19.876]             base::names(...future.oldOptions))
[08:26:19.876]     }
[08:26:19.876]     if (FALSE) {
[08:26:19.876]     }
[08:26:19.876]     else {
[08:26:19.876]         if (TRUE) {
[08:26:19.876]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:19.876]                 open = "w")
[08:26:19.876]         }
[08:26:19.876]         else {
[08:26:19.876]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:19.876]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:19.876]         }
[08:26:19.876]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:19.876]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:19.876]             base::sink(type = "output", split = FALSE)
[08:26:19.876]             base::close(...future.stdout)
[08:26:19.876]         }, add = TRUE)
[08:26:19.876]     }
[08:26:19.876]     ...future.frame <- base::sys.nframe()
[08:26:19.876]     ...future.conditions <- base::list()
[08:26:19.876]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:19.876]     if (FALSE) {
[08:26:19.876]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:19.876]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:19.876]     }
[08:26:19.876]     ...future.result <- base::tryCatch({
[08:26:19.876]         base::withCallingHandlers({
[08:26:19.876]             ...future.value <- base::withVisible(base::local({
[08:26:19.876]                 withCallingHandlers({
[08:26:19.876]                   {
[08:26:19.876]                     do.call(function(...) {
[08:26:19.876]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.876]                       if (!identical(...future.globals.maxSize.org, 
[08:26:19.876]                         ...future.globals.maxSize)) {
[08:26:19.876]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.876]                         on.exit(options(oopts), add = TRUE)
[08:26:19.876]                       }
[08:26:19.876]                       {
[08:26:19.876]                         lapply(seq_along(...future.elements_ii), 
[08:26:19.876]                           FUN = function(jj) {
[08:26:19.876]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.876]                             ...future.FUN(...future.X_jj, ...)
[08:26:19.876]                           })
[08:26:19.876]                       }
[08:26:19.876]                     }, args = future.call.arguments)
[08:26:19.876]                   }
[08:26:19.876]                 }, immediateCondition = function(cond) {
[08:26:19.876]                   save_rds <- function (object, pathname, ...) 
[08:26:19.876]                   {
[08:26:19.876]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:19.876]                     if (file_test("-f", pathname_tmp)) {
[08:26:19.876]                       fi_tmp <- file.info(pathname_tmp)
[08:26:19.876]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:19.876]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:19.876]                         fi_tmp[["mtime"]])
[08:26:19.876]                     }
[08:26:19.876]                     tryCatch({
[08:26:19.876]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:19.876]                     }, error = function(ex) {
[08:26:19.876]                       msg <- conditionMessage(ex)
[08:26:19.876]                       fi_tmp <- file.info(pathname_tmp)
[08:26:19.876]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:19.876]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:19.876]                         fi_tmp[["mtime"]], msg)
[08:26:19.876]                       ex$message <- msg
[08:26:19.876]                       stop(ex)
[08:26:19.876]                     })
[08:26:19.876]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:19.876]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:19.876]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:19.876]                       fi_tmp <- file.info(pathname_tmp)
[08:26:19.876]                       fi <- file.info(pathname)
[08:26:19.876]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:19.876]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:19.876]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:19.876]                         fi[["size"]], fi[["mtime"]])
[08:26:19.876]                       stop(msg)
[08:26:19.876]                     }
[08:26:19.876]                     invisible(pathname)
[08:26:19.876]                   }
[08:26:19.876]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:19.876]                     rootPath = tempdir()) 
[08:26:19.876]                   {
[08:26:19.876]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:19.876]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:19.876]                       tmpdir = path, fileext = ".rds")
[08:26:19.876]                     save_rds(obj, file)
[08:26:19.876]                   }
[08:26:19.876]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:19.876]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.876]                   {
[08:26:19.876]                     inherits <- base::inherits
[08:26:19.876]                     invokeRestart <- base::invokeRestart
[08:26:19.876]                     is.null <- base::is.null
[08:26:19.876]                     muffled <- FALSE
[08:26:19.876]                     if (inherits(cond, "message")) {
[08:26:19.876]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:19.876]                       if (muffled) 
[08:26:19.876]                         invokeRestart("muffleMessage")
[08:26:19.876]                     }
[08:26:19.876]                     else if (inherits(cond, "warning")) {
[08:26:19.876]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:19.876]                       if (muffled) 
[08:26:19.876]                         invokeRestart("muffleWarning")
[08:26:19.876]                     }
[08:26:19.876]                     else if (inherits(cond, "condition")) {
[08:26:19.876]                       if (!is.null(pattern)) {
[08:26:19.876]                         computeRestarts <- base::computeRestarts
[08:26:19.876]                         grepl <- base::grepl
[08:26:19.876]                         restarts <- computeRestarts(cond)
[08:26:19.876]                         for (restart in restarts) {
[08:26:19.876]                           name <- restart$name
[08:26:19.876]                           if (is.null(name)) 
[08:26:19.876]                             next
[08:26:19.876]                           if (!grepl(pattern, name)) 
[08:26:19.876]                             next
[08:26:19.876]                           invokeRestart(restart)
[08:26:19.876]                           muffled <- TRUE
[08:26:19.876]                           break
[08:26:19.876]                         }
[08:26:19.876]                       }
[08:26:19.876]                     }
[08:26:19.876]                     invisible(muffled)
[08:26:19.876]                   }
[08:26:19.876]                   muffleCondition(cond)
[08:26:19.876]                 })
[08:26:19.876]             }))
[08:26:19.876]             future::FutureResult(value = ...future.value$value, 
[08:26:19.876]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.876]                   ...future.rng), globalenv = if (FALSE) 
[08:26:19.876]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:19.876]                     ...future.globalenv.names))
[08:26:19.876]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:19.876]         }, condition = base::local({
[08:26:19.876]             c <- base::c
[08:26:19.876]             inherits <- base::inherits
[08:26:19.876]             invokeRestart <- base::invokeRestart
[08:26:19.876]             length <- base::length
[08:26:19.876]             list <- base::list
[08:26:19.876]             seq.int <- base::seq.int
[08:26:19.876]             signalCondition <- base::signalCondition
[08:26:19.876]             sys.calls <- base::sys.calls
[08:26:19.876]             `[[` <- base::`[[`
[08:26:19.876]             `+` <- base::`+`
[08:26:19.876]             `<<-` <- base::`<<-`
[08:26:19.876]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:19.876]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:19.876]                   3L)]
[08:26:19.876]             }
[08:26:19.876]             function(cond) {
[08:26:19.876]                 is_error <- inherits(cond, "error")
[08:26:19.876]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:19.876]                   NULL)
[08:26:19.876]                 if (is_error) {
[08:26:19.876]                   sessionInformation <- function() {
[08:26:19.876]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:19.876]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:19.876]                       search = base::search(), system = base::Sys.info())
[08:26:19.876]                   }
[08:26:19.876]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.876]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:19.876]                     cond$call), session = sessionInformation(), 
[08:26:19.876]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:19.876]                   signalCondition(cond)
[08:26:19.876]                 }
[08:26:19.876]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:19.876]                 "immediateCondition"))) {
[08:26:19.876]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:19.876]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.876]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:19.876]                   if (TRUE && !signal) {
[08:26:19.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.876]                     {
[08:26:19.876]                       inherits <- base::inherits
[08:26:19.876]                       invokeRestart <- base::invokeRestart
[08:26:19.876]                       is.null <- base::is.null
[08:26:19.876]                       muffled <- FALSE
[08:26:19.876]                       if (inherits(cond, "message")) {
[08:26:19.876]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.876]                         if (muffled) 
[08:26:19.876]                           invokeRestart("muffleMessage")
[08:26:19.876]                       }
[08:26:19.876]                       else if (inherits(cond, "warning")) {
[08:26:19.876]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.876]                         if (muffled) 
[08:26:19.876]                           invokeRestart("muffleWarning")
[08:26:19.876]                       }
[08:26:19.876]                       else if (inherits(cond, "condition")) {
[08:26:19.876]                         if (!is.null(pattern)) {
[08:26:19.876]                           computeRestarts <- base::computeRestarts
[08:26:19.876]                           grepl <- base::grepl
[08:26:19.876]                           restarts <- computeRestarts(cond)
[08:26:19.876]                           for (restart in restarts) {
[08:26:19.876]                             name <- restart$name
[08:26:19.876]                             if (is.null(name)) 
[08:26:19.876]                               next
[08:26:19.876]                             if (!grepl(pattern, name)) 
[08:26:19.876]                               next
[08:26:19.876]                             invokeRestart(restart)
[08:26:19.876]                             muffled <- TRUE
[08:26:19.876]                             break
[08:26:19.876]                           }
[08:26:19.876]                         }
[08:26:19.876]                       }
[08:26:19.876]                       invisible(muffled)
[08:26:19.876]                     }
[08:26:19.876]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.876]                   }
[08:26:19.876]                 }
[08:26:19.876]                 else {
[08:26:19.876]                   if (TRUE) {
[08:26:19.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.876]                     {
[08:26:19.876]                       inherits <- base::inherits
[08:26:19.876]                       invokeRestart <- base::invokeRestart
[08:26:19.876]                       is.null <- base::is.null
[08:26:19.876]                       muffled <- FALSE
[08:26:19.876]                       if (inherits(cond, "message")) {
[08:26:19.876]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.876]                         if (muffled) 
[08:26:19.876]                           invokeRestart("muffleMessage")
[08:26:19.876]                       }
[08:26:19.876]                       else if (inherits(cond, "warning")) {
[08:26:19.876]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.876]                         if (muffled) 
[08:26:19.876]                           invokeRestart("muffleWarning")
[08:26:19.876]                       }
[08:26:19.876]                       else if (inherits(cond, "condition")) {
[08:26:19.876]                         if (!is.null(pattern)) {
[08:26:19.876]                           computeRestarts <- base::computeRestarts
[08:26:19.876]                           grepl <- base::grepl
[08:26:19.876]                           restarts <- computeRestarts(cond)
[08:26:19.876]                           for (restart in restarts) {
[08:26:19.876]                             name <- restart$name
[08:26:19.876]                             if (is.null(name)) 
[08:26:19.876]                               next
[08:26:19.876]                             if (!grepl(pattern, name)) 
[08:26:19.876]                               next
[08:26:19.876]                             invokeRestart(restart)
[08:26:19.876]                             muffled <- TRUE
[08:26:19.876]                             break
[08:26:19.876]                           }
[08:26:19.876]                         }
[08:26:19.876]                       }
[08:26:19.876]                       invisible(muffled)
[08:26:19.876]                     }
[08:26:19.876]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.876]                   }
[08:26:19.876]                 }
[08:26:19.876]             }
[08:26:19.876]         }))
[08:26:19.876]     }, error = function(ex) {
[08:26:19.876]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:19.876]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.876]                 ...future.rng), started = ...future.startTime, 
[08:26:19.876]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:19.876]             version = "1.8"), class = "FutureResult")
[08:26:19.876]     }, finally = {
[08:26:19.876]         if (!identical(...future.workdir, getwd())) 
[08:26:19.876]             setwd(...future.workdir)
[08:26:19.876]         {
[08:26:19.876]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:19.876]                 ...future.oldOptions$nwarnings <- NULL
[08:26:19.876]             }
[08:26:19.876]             base::options(...future.oldOptions)
[08:26:19.876]             if (.Platform$OS.type == "windows") {
[08:26:19.876]                 old_names <- names(...future.oldEnvVars)
[08:26:19.876]                 envs <- base::Sys.getenv()
[08:26:19.876]                 names <- names(envs)
[08:26:19.876]                 common <- intersect(names, old_names)
[08:26:19.876]                 added <- setdiff(names, old_names)
[08:26:19.876]                 removed <- setdiff(old_names, names)
[08:26:19.876]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:19.876]                   envs[common]]
[08:26:19.876]                 NAMES <- toupper(changed)
[08:26:19.876]                 args <- list()
[08:26:19.876]                 for (kk in seq_along(NAMES)) {
[08:26:19.876]                   name <- changed[[kk]]
[08:26:19.876]                   NAME <- NAMES[[kk]]
[08:26:19.876]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.876]                     next
[08:26:19.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.876]                 }
[08:26:19.876]                 NAMES <- toupper(added)
[08:26:19.876]                 for (kk in seq_along(NAMES)) {
[08:26:19.876]                   name <- added[[kk]]
[08:26:19.876]                   NAME <- NAMES[[kk]]
[08:26:19.876]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.876]                     next
[08:26:19.876]                   args[[name]] <- ""
[08:26:19.876]                 }
[08:26:19.876]                 NAMES <- toupper(removed)
[08:26:19.876]                 for (kk in seq_along(NAMES)) {
[08:26:19.876]                   name <- removed[[kk]]
[08:26:19.876]                   NAME <- NAMES[[kk]]
[08:26:19.876]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.876]                     next
[08:26:19.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.876]                 }
[08:26:19.876]                 if (length(args) > 0) 
[08:26:19.876]                   base::do.call(base::Sys.setenv, args = args)
[08:26:19.876]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:19.876]             }
[08:26:19.876]             else {
[08:26:19.876]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:19.876]             }
[08:26:19.876]             {
[08:26:19.876]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:19.876]                   0L) {
[08:26:19.876]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:19.876]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:19.876]                   base::options(opts)
[08:26:19.876]                 }
[08:26:19.876]                 {
[08:26:19.876]                   {
[08:26:19.876]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:19.876]                     NULL
[08:26:19.876]                   }
[08:26:19.876]                   options(future.plan = NULL)
[08:26:19.876]                   if (is.na(NA_character_)) 
[08:26:19.876]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.876]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:19.876]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:19.876]                     .init = FALSE)
[08:26:19.876]                 }
[08:26:19.876]             }
[08:26:19.876]         }
[08:26:19.876]     })
[08:26:19.876]     if (TRUE) {
[08:26:19.876]         base::sink(type = "output", split = FALSE)
[08:26:19.876]         if (TRUE) {
[08:26:19.876]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:19.876]         }
[08:26:19.876]         else {
[08:26:19.876]             ...future.result["stdout"] <- base::list(NULL)
[08:26:19.876]         }
[08:26:19.876]         base::close(...future.stdout)
[08:26:19.876]         ...future.stdout <- NULL
[08:26:19.876]     }
[08:26:19.876]     ...future.result$conditions <- ...future.conditions
[08:26:19.876]     ...future.result$finished <- base::Sys.time()
[08:26:19.876]     ...future.result
[08:26:19.876] }
[08:26:19.879] assign_globals() ...
[08:26:19.879] List of 11
[08:26:19.879]  $ ...future.FUN            :function (x, ...)  
[08:26:19.879]  $ x_FUN                    :function (x)  
[08:26:19.879]  $ times                    : int 0
[08:26:19.879]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.879]  $ stop_if_not              :function (...)  
[08:26:19.879]  $ dim                      : NULL
[08:26:19.879]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:19.879]  $ future.call.arguments    : list()
[08:26:19.879]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.879]  $ ...future.elements_ii    :List of 5
[08:26:19.879]   ..$ : int 6
[08:26:19.879]   ..$ : int 7
[08:26:19.879]   ..$ : int 8
[08:26:19.879]   ..$ : int 9
[08:26:19.879]   ..$ : int 10
[08:26:19.879]  $ ...future.seeds_ii       : NULL
[08:26:19.879]  $ ...future.globals.maxSize: NULL
[08:26:19.879]  - attr(*, "where")=List of 11
[08:26:19.879]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:19.879]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:19.879]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:19.879]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:19.879]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:19.879]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:19.879]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:19.879]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:19.879]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:19.879]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:19.879]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:19.879]  - attr(*, "resolved")= logi FALSE
[08:26:19.879]  - attr(*, "total_size")= num 23490
[08:26:19.879]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.879]  - attr(*, "already-done")= logi TRUE
[08:26:19.890] - copied ‘...future.FUN’ to environment
[08:26:19.890] - reassign environment for ‘x_FUN’
[08:26:19.891] - copied ‘x_FUN’ to environment
[08:26:19.891] - copied ‘times’ to environment
[08:26:19.891] - copied ‘stopf’ to environment
[08:26:19.891] - copied ‘stop_if_not’ to environment
[08:26:19.891] - copied ‘dim’ to environment
[08:26:19.891] - copied ‘valid_types’ to environment
[08:26:19.891] - copied ‘future.call.arguments’ to environment
[08:26:19.891] - copied ‘...future.elements_ii’ to environment
[08:26:19.891] - copied ‘...future.seeds_ii’ to environment
[08:26:19.892] - copied ‘...future.globals.maxSize’ to environment
[08:26:19.892] assign_globals() ... done
[08:26:19.892] requestCore(): workers = 2
[08:26:19.894] MulticoreFuture started
[08:26:19.895] - Launch lazy future ... done
[08:26:19.895] run() for ‘MulticoreFuture’ ... done
[08:26:19.895] Created future:
[08:26:19.896] plan(): Setting new future strategy stack:
[08:26:19.896] List of future strategies:
[08:26:19.896] 1. sequential:
[08:26:19.896]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.896]    - tweaked: FALSE
[08:26:19.896]    - call: NULL
[08:26:19.897] plan(): nbrOfWorkers() = 1
[08:26:19.899] plan(): Setting new future strategy stack:
[08:26:19.899] List of future strategies:
[08:26:19.899] 1. multicore:
[08:26:19.899]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:19.899]    - tweaked: FALSE
[08:26:19.899]    - call: plan(strategy)
[08:26:19.902] plan(): nbrOfWorkers() = 2
[08:26:19.895] MulticoreFuture:
[08:26:19.895] Label: ‘future_vapply-2’
[08:26:19.895] Expression:
[08:26:19.895] {
[08:26:19.895]     do.call(function(...) {
[08:26:19.895]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.895]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.895]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.895]             on.exit(options(oopts), add = TRUE)
[08:26:19.895]         }
[08:26:19.895]         {
[08:26:19.895]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.895]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.895]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.895]             })
[08:26:19.895]         }
[08:26:19.895]     }, args = future.call.arguments)
[08:26:19.895] }
[08:26:19.895] Lazy evaluation: FALSE
[08:26:19.895] Asynchronous evaluation: TRUE
[08:26:19.895] Local evaluation: TRUE
[08:26:19.895] Environment: R_GlobalEnv
[08:26:19.895] Capture standard output: TRUE
[08:26:19.895] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:19.895] Globals: 11 objects totaling 13.01 KiB (function ‘...future.FUN’ of 4.50 KiB, function ‘x_FUN’ of 295 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:19.895] Packages: 1 packages (‘future.apply’)
[08:26:19.895] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:19.895] Resolved: TRUE
[08:26:19.895] Value: <not collected>
[08:26:19.895] Conditions captured: <none>
[08:26:19.895] Early signaling: FALSE
[08:26:19.895] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:19.895] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:19.904] Chunk #2 of 2 ... DONE
[08:26:19.904] Launching 2 futures (chunks) ... DONE
[08:26:19.904] Resolving 2 futures (chunks) ...
[08:26:19.904] resolve() on list ...
[08:26:19.904]  recursive: 0
[08:26:19.904]  length: 2
[08:26:19.904] 
[08:26:19.905] Future #1
[08:26:19.905] result() for MulticoreFuture ...
[08:26:19.906] result() for MulticoreFuture ...
[08:26:19.906] result() for MulticoreFuture ... done
[08:26:19.906] result() for MulticoreFuture ... done
[08:26:19.906] result() for MulticoreFuture ...
[08:26:19.906] result() for MulticoreFuture ... done
[08:26:19.906] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:26:19.907] - nx: 2
[08:26:19.907] - relay: TRUE
[08:26:19.907] - stdout: TRUE
[08:26:19.907] - signal: TRUE
[08:26:19.907] - resignal: FALSE
[08:26:19.907] - force: TRUE
[08:26:19.907] - relayed: [n=2] FALSE, FALSE
[08:26:19.907] - queued futures: [n=2] FALSE, FALSE
[08:26:19.908]  - until=1
[08:26:19.908]  - relaying element #1
[08:26:19.908] result() for MulticoreFuture ...
[08:26:19.908] result() for MulticoreFuture ... done
[08:26:19.908] result() for MulticoreFuture ...
[08:26:19.908] result() for MulticoreFuture ... done
[08:26:19.909] result() for MulticoreFuture ...
[08:26:19.909] result() for MulticoreFuture ... done
[08:26:19.909] result() for MulticoreFuture ...
[08:26:19.909] result() for MulticoreFuture ... done
[08:26:19.909] - relayed: [n=2] TRUE, FALSE
[08:26:19.909] - queued futures: [n=2] TRUE, FALSE
[08:26:19.909] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:26:19.910]  length: 1 (resolved future 1)
[08:26:19.910] Future #2
[08:26:19.913] result() for MulticoreFuture ...
[08:26:19.915] result() for MulticoreFuture ...
[08:26:19.915] result() for MulticoreFuture ... done
[08:26:19.916] result() for MulticoreFuture ... done
[08:26:19.916] result() for MulticoreFuture ...
[08:26:19.916] result() for MulticoreFuture ... done
[08:26:19.916] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:26:19.917] - nx: 2
[08:26:19.917] - relay: TRUE
[08:26:19.917] - stdout: TRUE
[08:26:19.917] - signal: TRUE
[08:26:19.917] - resignal: FALSE
[08:26:19.917] - force: TRUE
[08:26:19.918] - relayed: [n=2] TRUE, FALSE
[08:26:19.918] - queued futures: [n=2] TRUE, FALSE
[08:26:19.918]  - until=2
[08:26:19.918]  - relaying element #2
[08:26:19.918] result() for MulticoreFuture ...
[08:26:19.918] result() for MulticoreFuture ... done
[08:26:19.919] result() for MulticoreFuture ...
[08:26:19.919] result() for MulticoreFuture ... done
[08:26:19.919] result() for MulticoreFuture ...
[08:26:19.919] result() for MulticoreFuture ... done
[08:26:19.919] result() for MulticoreFuture ...
[08:26:19.920] result() for MulticoreFuture ... done
[08:26:19.920] - relayed: [n=2] TRUE, TRUE
[08:26:19.920] - queued futures: [n=2] TRUE, TRUE
[08:26:19.920] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:26:19.920]  length: 0 (resolved future 2)
[08:26:19.920] Relaying remaining futures
[08:26:19.920] signalConditionsASAP(NULL, pos=0) ...
[08:26:19.921] - nx: 2
[08:26:19.921] - relay: TRUE
[08:26:19.921] - stdout: TRUE
[08:26:19.921] - signal: TRUE
[08:26:19.921] - resignal: FALSE
[08:26:19.921] - force: TRUE
[08:26:19.921] - relayed: [n=2] TRUE, TRUE
[08:26:19.921] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:19.922] - relayed: [n=2] TRUE, TRUE
[08:26:19.922] - queued futures: [n=2] TRUE, TRUE
[08:26:19.922] signalConditionsASAP(NULL, pos=0) ... done
[08:26:19.922] resolve() on list ... DONE
[08:26:19.922] result() for MulticoreFuture ...
[08:26:19.922] result() for MulticoreFuture ... done
[08:26:19.922] result() for MulticoreFuture ...
[08:26:19.922] result() for MulticoreFuture ... done
[08:26:19.922] result() for MulticoreFuture ...
[08:26:19.922] result() for MulticoreFuture ... done
[08:26:19.923] result() for MulticoreFuture ...
[08:26:19.923] result() for MulticoreFuture ... done
[08:26:19.923]  - Number of value chunks collected: 2
[08:26:19.923] Resolving 2 futures (chunks) ... DONE
[08:26:19.923] Reducing values from 2 chunks ...
[08:26:19.923]  - Number of values collected after concatenation: 10
[08:26:19.923]  - Number of values expected: 10
[08:26:19.923] Reducing values from 2 chunks ... DONE
[08:26:19.924] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[08:26:19.925] future_lapply() ...
[08:26:19.929] Number of chunks: 2
[08:26:19.929] getGlobalsAndPackagesXApply() ...
[08:26:19.929]  - future.globals: TRUE
[08:26:19.929] getGlobalsAndPackages() ...
[08:26:19.929] Searching for globals...
[08:26:19.933] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[08:26:19.933] Searching for globals ... DONE
[08:26:19.934] Resolving globals: FALSE
[08:26:19.934] The total size of the 7 globals is 12.75 KiB (13056 bytes)
[08:26:19.935] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.50 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:19.935] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.935] - packages: [1] ‘future.apply’
[08:26:19.935] getGlobalsAndPackages() ... DONE
[08:26:19.935]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:19.935]  - needed namespaces: [n=1] ‘future.apply’
[08:26:19.936] Finding globals ... DONE
[08:26:19.936]  - use_args: TRUE
[08:26:19.936]  - Getting '...' globals ...
[08:26:19.936] resolve() on list ...
[08:26:19.936]  recursive: 0
[08:26:19.936]  length: 1
[08:26:19.936]  elements: ‘...’
[08:26:19.937]  length: 0 (resolved future 1)
[08:26:19.937] resolve() on list ... DONE
[08:26:19.937]    - '...' content: [n=0] 
[08:26:19.937] List of 1
[08:26:19.937]  $ ...: list()
[08:26:19.937]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.937]  - attr(*, "where")=List of 1
[08:26:19.937]   ..$ ...:<environment: 0x562ca58c8fb8> 
[08:26:19.937]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.937]  - attr(*, "resolved")= logi TRUE
[08:26:19.937]  - attr(*, "total_size")= num NA
[08:26:19.939]  - Getting '...' globals ... DONE
[08:26:19.939] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:19.940] List of 8
[08:26:19.940]  $ ...future.FUN:function (x, ...)  
[08:26:19.940]  $ x_FUN        :function (x)  
[08:26:19.940]  $ times        : int 0
[08:26:19.940]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.940]  $ stop_if_not  :function (...)  
[08:26:19.940]  $ dim          : NULL
[08:26:19.940]  $ valid_types  : chr [1:2] "logical" "integer"
[08:26:19.940]  $ ...          : list()
[08:26:19.940]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.940]  - attr(*, "where")=List of 8
[08:26:19.940]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:19.940]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:19.940]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:19.940]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:19.940]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:19.940]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:19.940]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:19.940]   ..$ ...          :<environment: 0x562ca58c8fb8> 
[08:26:19.940]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.940]  - attr(*, "resolved")= logi FALSE
[08:26:19.940]  - attr(*, "total_size")= num 23453
[08:26:19.947] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:19.948] getGlobalsAndPackagesXApply() ... DONE
[08:26:19.948] Number of futures (= number of chunks): 2
[08:26:19.948] Launching 2 futures (chunks) ...
[08:26:19.948] Chunk #1 of 2 ...
[08:26:19.948]  - Finding globals in 'X' for chunk #1 ...
[08:26:19.948] getGlobalsAndPackages() ...
[08:26:19.948] Searching for globals...
[08:26:19.949] 
[08:26:19.949] Searching for globals ... DONE
[08:26:19.949] - globals: [0] <none>
[08:26:19.949] getGlobalsAndPackages() ... DONE
[08:26:19.949]    + additional globals found: [n=0] 
[08:26:19.949]    + additional namespaces needed: [n=0] 
[08:26:19.949]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:19.949]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:19.949]  - seeds: <none>
[08:26:19.949]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.949] getGlobalsAndPackages() ...
[08:26:19.950] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.950] Resolving globals: FALSE
[08:26:19.950] Tweak future expression to call with '...' arguments ...
[08:26:19.950] {
[08:26:19.950]     do.call(function(...) {
[08:26:19.950]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.950]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.950]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.950]             on.exit(options(oopts), add = TRUE)
[08:26:19.950]         }
[08:26:19.950]         {
[08:26:19.950]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.950]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.950]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.950]             })
[08:26:19.950]         }
[08:26:19.950]     }, args = future.call.arguments)
[08:26:19.950] }
[08:26:19.950] Tweak future expression to call with '...' arguments ... DONE
[08:26:19.951] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.951] - packages: [1] ‘future.apply’
[08:26:19.951] getGlobalsAndPackages() ... DONE
[08:26:19.951] run() for ‘Future’ ...
[08:26:19.951] - state: ‘created’
[08:26:19.951] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:19.953] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:19.953] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:19.953]   - Field: ‘label’
[08:26:19.953]   - Field: ‘local’
[08:26:19.954]   - Field: ‘owner’
[08:26:19.954]   - Field: ‘envir’
[08:26:19.954]   - Field: ‘workers’
[08:26:19.954]   - Field: ‘packages’
[08:26:19.954]   - Field: ‘gc’
[08:26:19.954]   - Field: ‘job’
[08:26:19.954]   - Field: ‘conditions’
[08:26:19.954]   - Field: ‘expr’
[08:26:19.954]   - Field: ‘uuid’
[08:26:19.954]   - Field: ‘seed’
[08:26:19.954]   - Field: ‘version’
[08:26:19.955]   - Field: ‘result’
[08:26:19.955]   - Field: ‘asynchronous’
[08:26:19.955]   - Field: ‘calls’
[08:26:19.955]   - Field: ‘globals’
[08:26:19.955]   - Field: ‘stdout’
[08:26:19.955]   - Field: ‘earlySignal’
[08:26:19.955]   - Field: ‘lazy’
[08:26:19.955]   - Field: ‘state’
[08:26:19.955] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:19.955] - Launch lazy future ...
[08:26:19.956] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:19.956] Packages needed by future strategies (n = 0): <none>
[08:26:19.956] {
[08:26:19.956]     {
[08:26:19.956]         {
[08:26:19.956]             ...future.startTime <- base::Sys.time()
[08:26:19.956]             {
[08:26:19.956]                 {
[08:26:19.956]                   {
[08:26:19.956]                     {
[08:26:19.956]                       {
[08:26:19.956]                         base::local({
[08:26:19.956]                           has_future <- base::requireNamespace("future", 
[08:26:19.956]                             quietly = TRUE)
[08:26:19.956]                           if (has_future) {
[08:26:19.956]                             ns <- base::getNamespace("future")
[08:26:19.956]                             version <- ns[[".package"]][["version"]]
[08:26:19.956]                             if (is.null(version)) 
[08:26:19.956]                               version <- utils::packageVersion("future")
[08:26:19.956]                           }
[08:26:19.956]                           else {
[08:26:19.956]                             version <- NULL
[08:26:19.956]                           }
[08:26:19.956]                           if (!has_future || version < "1.8.0") {
[08:26:19.956]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:19.956]                               "", base::R.version$version.string), 
[08:26:19.956]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:19.956]                                 base::R.version$platform, 8 * 
[08:26:19.956]                                   base::.Machine$sizeof.pointer), 
[08:26:19.956]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:19.956]                                 "release", "version")], collapse = " "), 
[08:26:19.956]                               hostname = base::Sys.info()[["nodename"]])
[08:26:19.956]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:19.956]                               info)
[08:26:19.956]                             info <- base::paste(info, collapse = "; ")
[08:26:19.956]                             if (!has_future) {
[08:26:19.956]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:19.956]                                 info)
[08:26:19.956]                             }
[08:26:19.956]                             else {
[08:26:19.956]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:19.956]                                 info, version)
[08:26:19.956]                             }
[08:26:19.956]                             base::stop(msg)
[08:26:19.956]                           }
[08:26:19.956]                         })
[08:26:19.956]                       }
[08:26:19.956]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:19.956]                       base::options(mc.cores = 1L)
[08:26:19.956]                     }
[08:26:19.956]                     base::local({
[08:26:19.956]                       for (pkg in "future.apply") {
[08:26:19.956]                         base::loadNamespace(pkg)
[08:26:19.956]                         base::library(pkg, character.only = TRUE)
[08:26:19.956]                       }
[08:26:19.956]                     })
[08:26:19.956]                   }
[08:26:19.956]                   ...future.strategy.old <- future::plan("list")
[08:26:19.956]                   options(future.plan = NULL)
[08:26:19.956]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.956]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:19.956]                 }
[08:26:19.956]                 ...future.workdir <- getwd()
[08:26:19.956]             }
[08:26:19.956]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:19.956]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:19.956]         }
[08:26:19.956]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:19.956]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:19.956]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:19.956]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:19.956]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:19.956]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:19.956]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:19.956]             base::names(...future.oldOptions))
[08:26:19.956]     }
[08:26:19.956]     if (FALSE) {
[08:26:19.956]     }
[08:26:19.956]     else {
[08:26:19.956]         if (TRUE) {
[08:26:19.956]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:19.956]                 open = "w")
[08:26:19.956]         }
[08:26:19.956]         else {
[08:26:19.956]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:19.956]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:19.956]         }
[08:26:19.956]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:19.956]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:19.956]             base::sink(type = "output", split = FALSE)
[08:26:19.956]             base::close(...future.stdout)
[08:26:19.956]         }, add = TRUE)
[08:26:19.956]     }
[08:26:19.956]     ...future.frame <- base::sys.nframe()
[08:26:19.956]     ...future.conditions <- base::list()
[08:26:19.956]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:19.956]     if (FALSE) {
[08:26:19.956]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:19.956]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:19.956]     }
[08:26:19.956]     ...future.result <- base::tryCatch({
[08:26:19.956]         base::withCallingHandlers({
[08:26:19.956]             ...future.value <- base::withVisible(base::local({
[08:26:19.956]                 withCallingHandlers({
[08:26:19.956]                   {
[08:26:19.956]                     do.call(function(...) {
[08:26:19.956]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.956]                       if (!identical(...future.globals.maxSize.org, 
[08:26:19.956]                         ...future.globals.maxSize)) {
[08:26:19.956]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.956]                         on.exit(options(oopts), add = TRUE)
[08:26:19.956]                       }
[08:26:19.956]                       {
[08:26:19.956]                         lapply(seq_along(...future.elements_ii), 
[08:26:19.956]                           FUN = function(jj) {
[08:26:19.956]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.956]                             ...future.FUN(...future.X_jj, ...)
[08:26:19.956]                           })
[08:26:19.956]                       }
[08:26:19.956]                     }, args = future.call.arguments)
[08:26:19.956]                   }
[08:26:19.956]                 }, immediateCondition = function(cond) {
[08:26:19.956]                   save_rds <- function (object, pathname, ...) 
[08:26:19.956]                   {
[08:26:19.956]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:19.956]                     if (file_test("-f", pathname_tmp)) {
[08:26:19.956]                       fi_tmp <- file.info(pathname_tmp)
[08:26:19.956]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:19.956]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:19.956]                         fi_tmp[["mtime"]])
[08:26:19.956]                     }
[08:26:19.956]                     tryCatch({
[08:26:19.956]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:19.956]                     }, error = function(ex) {
[08:26:19.956]                       msg <- conditionMessage(ex)
[08:26:19.956]                       fi_tmp <- file.info(pathname_tmp)
[08:26:19.956]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:19.956]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:19.956]                         fi_tmp[["mtime"]], msg)
[08:26:19.956]                       ex$message <- msg
[08:26:19.956]                       stop(ex)
[08:26:19.956]                     })
[08:26:19.956]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:19.956]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:19.956]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:19.956]                       fi_tmp <- file.info(pathname_tmp)
[08:26:19.956]                       fi <- file.info(pathname)
[08:26:19.956]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:19.956]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:19.956]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:19.956]                         fi[["size"]], fi[["mtime"]])
[08:26:19.956]                       stop(msg)
[08:26:19.956]                     }
[08:26:19.956]                     invisible(pathname)
[08:26:19.956]                   }
[08:26:19.956]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:19.956]                     rootPath = tempdir()) 
[08:26:19.956]                   {
[08:26:19.956]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:19.956]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:19.956]                       tmpdir = path, fileext = ".rds")
[08:26:19.956]                     save_rds(obj, file)
[08:26:19.956]                   }
[08:26:19.956]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:19.956]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.956]                   {
[08:26:19.956]                     inherits <- base::inherits
[08:26:19.956]                     invokeRestart <- base::invokeRestart
[08:26:19.956]                     is.null <- base::is.null
[08:26:19.956]                     muffled <- FALSE
[08:26:19.956]                     if (inherits(cond, "message")) {
[08:26:19.956]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:19.956]                       if (muffled) 
[08:26:19.956]                         invokeRestart("muffleMessage")
[08:26:19.956]                     }
[08:26:19.956]                     else if (inherits(cond, "warning")) {
[08:26:19.956]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:19.956]                       if (muffled) 
[08:26:19.956]                         invokeRestart("muffleWarning")
[08:26:19.956]                     }
[08:26:19.956]                     else if (inherits(cond, "condition")) {
[08:26:19.956]                       if (!is.null(pattern)) {
[08:26:19.956]                         computeRestarts <- base::computeRestarts
[08:26:19.956]                         grepl <- base::grepl
[08:26:19.956]                         restarts <- computeRestarts(cond)
[08:26:19.956]                         for (restart in restarts) {
[08:26:19.956]                           name <- restart$name
[08:26:19.956]                           if (is.null(name)) 
[08:26:19.956]                             next
[08:26:19.956]                           if (!grepl(pattern, name)) 
[08:26:19.956]                             next
[08:26:19.956]                           invokeRestart(restart)
[08:26:19.956]                           muffled <- TRUE
[08:26:19.956]                           break
[08:26:19.956]                         }
[08:26:19.956]                       }
[08:26:19.956]                     }
[08:26:19.956]                     invisible(muffled)
[08:26:19.956]                   }
[08:26:19.956]                   muffleCondition(cond)
[08:26:19.956]                 })
[08:26:19.956]             }))
[08:26:19.956]             future::FutureResult(value = ...future.value$value, 
[08:26:19.956]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.956]                   ...future.rng), globalenv = if (FALSE) 
[08:26:19.956]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:19.956]                     ...future.globalenv.names))
[08:26:19.956]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:19.956]         }, condition = base::local({
[08:26:19.956]             c <- base::c
[08:26:19.956]             inherits <- base::inherits
[08:26:19.956]             invokeRestart <- base::invokeRestart
[08:26:19.956]             length <- base::length
[08:26:19.956]             list <- base::list
[08:26:19.956]             seq.int <- base::seq.int
[08:26:19.956]             signalCondition <- base::signalCondition
[08:26:19.956]             sys.calls <- base::sys.calls
[08:26:19.956]             `[[` <- base::`[[`
[08:26:19.956]             `+` <- base::`+`
[08:26:19.956]             `<<-` <- base::`<<-`
[08:26:19.956]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:19.956]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:19.956]                   3L)]
[08:26:19.956]             }
[08:26:19.956]             function(cond) {
[08:26:19.956]                 is_error <- inherits(cond, "error")
[08:26:19.956]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:19.956]                   NULL)
[08:26:19.956]                 if (is_error) {
[08:26:19.956]                   sessionInformation <- function() {
[08:26:19.956]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:19.956]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:19.956]                       search = base::search(), system = base::Sys.info())
[08:26:19.956]                   }
[08:26:19.956]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.956]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:19.956]                     cond$call), session = sessionInformation(), 
[08:26:19.956]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:19.956]                   signalCondition(cond)
[08:26:19.956]                 }
[08:26:19.956]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:19.956]                 "immediateCondition"))) {
[08:26:19.956]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:19.956]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.956]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:19.956]                   if (TRUE && !signal) {
[08:26:19.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.956]                     {
[08:26:19.956]                       inherits <- base::inherits
[08:26:19.956]                       invokeRestart <- base::invokeRestart
[08:26:19.956]                       is.null <- base::is.null
[08:26:19.956]                       muffled <- FALSE
[08:26:19.956]                       if (inherits(cond, "message")) {
[08:26:19.956]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.956]                         if (muffled) 
[08:26:19.956]                           invokeRestart("muffleMessage")
[08:26:19.956]                       }
[08:26:19.956]                       else if (inherits(cond, "warning")) {
[08:26:19.956]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.956]                         if (muffled) 
[08:26:19.956]                           invokeRestart("muffleWarning")
[08:26:19.956]                       }
[08:26:19.956]                       else if (inherits(cond, "condition")) {
[08:26:19.956]                         if (!is.null(pattern)) {
[08:26:19.956]                           computeRestarts <- base::computeRestarts
[08:26:19.956]                           grepl <- base::grepl
[08:26:19.956]                           restarts <- computeRestarts(cond)
[08:26:19.956]                           for (restart in restarts) {
[08:26:19.956]                             name <- restart$name
[08:26:19.956]                             if (is.null(name)) 
[08:26:19.956]                               next
[08:26:19.956]                             if (!grepl(pattern, name)) 
[08:26:19.956]                               next
[08:26:19.956]                             invokeRestart(restart)
[08:26:19.956]                             muffled <- TRUE
[08:26:19.956]                             break
[08:26:19.956]                           }
[08:26:19.956]                         }
[08:26:19.956]                       }
[08:26:19.956]                       invisible(muffled)
[08:26:19.956]                     }
[08:26:19.956]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.956]                   }
[08:26:19.956]                 }
[08:26:19.956]                 else {
[08:26:19.956]                   if (TRUE) {
[08:26:19.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.956]                     {
[08:26:19.956]                       inherits <- base::inherits
[08:26:19.956]                       invokeRestart <- base::invokeRestart
[08:26:19.956]                       is.null <- base::is.null
[08:26:19.956]                       muffled <- FALSE
[08:26:19.956]                       if (inherits(cond, "message")) {
[08:26:19.956]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.956]                         if (muffled) 
[08:26:19.956]                           invokeRestart("muffleMessage")
[08:26:19.956]                       }
[08:26:19.956]                       else if (inherits(cond, "warning")) {
[08:26:19.956]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.956]                         if (muffled) 
[08:26:19.956]                           invokeRestart("muffleWarning")
[08:26:19.956]                       }
[08:26:19.956]                       else if (inherits(cond, "condition")) {
[08:26:19.956]                         if (!is.null(pattern)) {
[08:26:19.956]                           computeRestarts <- base::computeRestarts
[08:26:19.956]                           grepl <- base::grepl
[08:26:19.956]                           restarts <- computeRestarts(cond)
[08:26:19.956]                           for (restart in restarts) {
[08:26:19.956]                             name <- restart$name
[08:26:19.956]                             if (is.null(name)) 
[08:26:19.956]                               next
[08:26:19.956]                             if (!grepl(pattern, name)) 
[08:26:19.956]                               next
[08:26:19.956]                             invokeRestart(restart)
[08:26:19.956]                             muffled <- TRUE
[08:26:19.956]                             break
[08:26:19.956]                           }
[08:26:19.956]                         }
[08:26:19.956]                       }
[08:26:19.956]                       invisible(muffled)
[08:26:19.956]                     }
[08:26:19.956]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.956]                   }
[08:26:19.956]                 }
[08:26:19.956]             }
[08:26:19.956]         }))
[08:26:19.956]     }, error = function(ex) {
[08:26:19.956]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:19.956]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.956]                 ...future.rng), started = ...future.startTime, 
[08:26:19.956]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:19.956]             version = "1.8"), class = "FutureResult")
[08:26:19.956]     }, finally = {
[08:26:19.956]         if (!identical(...future.workdir, getwd())) 
[08:26:19.956]             setwd(...future.workdir)
[08:26:19.956]         {
[08:26:19.956]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:19.956]                 ...future.oldOptions$nwarnings <- NULL
[08:26:19.956]             }
[08:26:19.956]             base::options(...future.oldOptions)
[08:26:19.956]             if (.Platform$OS.type == "windows") {
[08:26:19.956]                 old_names <- names(...future.oldEnvVars)
[08:26:19.956]                 envs <- base::Sys.getenv()
[08:26:19.956]                 names <- names(envs)
[08:26:19.956]                 common <- intersect(names, old_names)
[08:26:19.956]                 added <- setdiff(names, old_names)
[08:26:19.956]                 removed <- setdiff(old_names, names)
[08:26:19.956]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:19.956]                   envs[common]]
[08:26:19.956]                 NAMES <- toupper(changed)
[08:26:19.956]                 args <- list()
[08:26:19.956]                 for (kk in seq_along(NAMES)) {
[08:26:19.956]                   name <- changed[[kk]]
[08:26:19.956]                   NAME <- NAMES[[kk]]
[08:26:19.956]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.956]                     next
[08:26:19.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.956]                 }
[08:26:19.956]                 NAMES <- toupper(added)
[08:26:19.956]                 for (kk in seq_along(NAMES)) {
[08:26:19.956]                   name <- added[[kk]]
[08:26:19.956]                   NAME <- NAMES[[kk]]
[08:26:19.956]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.956]                     next
[08:26:19.956]                   args[[name]] <- ""
[08:26:19.956]                 }
[08:26:19.956]                 NAMES <- toupper(removed)
[08:26:19.956]                 for (kk in seq_along(NAMES)) {
[08:26:19.956]                   name <- removed[[kk]]
[08:26:19.956]                   NAME <- NAMES[[kk]]
[08:26:19.956]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.956]                     next
[08:26:19.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.956]                 }
[08:26:19.956]                 if (length(args) > 0) 
[08:26:19.956]                   base::do.call(base::Sys.setenv, args = args)
[08:26:19.956]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:19.956]             }
[08:26:19.956]             else {
[08:26:19.956]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:19.956]             }
[08:26:19.956]             {
[08:26:19.956]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:19.956]                   0L) {
[08:26:19.956]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:19.956]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:19.956]                   base::options(opts)
[08:26:19.956]                 }
[08:26:19.956]                 {
[08:26:19.956]                   {
[08:26:19.956]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:19.956]                     NULL
[08:26:19.956]                   }
[08:26:19.956]                   options(future.plan = NULL)
[08:26:19.956]                   if (is.na(NA_character_)) 
[08:26:19.956]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.956]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:19.956]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:19.956]                     .init = FALSE)
[08:26:19.956]                 }
[08:26:19.956]             }
[08:26:19.956]         }
[08:26:19.956]     })
[08:26:19.956]     if (TRUE) {
[08:26:19.956]         base::sink(type = "output", split = FALSE)
[08:26:19.956]         if (TRUE) {
[08:26:19.956]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:19.956]         }
[08:26:19.956]         else {
[08:26:19.956]             ...future.result["stdout"] <- base::list(NULL)
[08:26:19.956]         }
[08:26:19.956]         base::close(...future.stdout)
[08:26:19.956]         ...future.stdout <- NULL
[08:26:19.956]     }
[08:26:19.956]     ...future.result$conditions <- ...future.conditions
[08:26:19.956]     ...future.result$finished <- base::Sys.time()
[08:26:19.956]     ...future.result
[08:26:19.956] }
[08:26:19.959] assign_globals() ...
[08:26:19.959] List of 11
[08:26:19.959]  $ ...future.FUN            :function (x, ...)  
[08:26:19.959]  $ x_FUN                    :function (x)  
[08:26:19.959]  $ times                    : int 0
[08:26:19.959]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:19.959]  $ stop_if_not              :function (...)  
[08:26:19.959]  $ dim                      : NULL
[08:26:19.959]  $ valid_types              : chr [1:2] "logical" "integer"
[08:26:19.959]  $ future.call.arguments    : list()
[08:26:19.959]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:19.959]  $ ...future.elements_ii    :List of 5
[08:26:19.959]   ..$ : int 1
[08:26:19.959]   ..$ : int 2
[08:26:19.959]   ..$ : int 3
[08:26:19.959]   ..$ : int 4
[08:26:19.959]   ..$ : int 5
[08:26:19.959]  $ ...future.seeds_ii       : NULL
[08:26:19.959]  $ ...future.globals.maxSize: NULL
[08:26:19.959]  - attr(*, "where")=List of 11
[08:26:19.959]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:19.959]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:19.959]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:19.959]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:19.959]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:19.959]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:19.959]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:19.959]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:19.959]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:19.959]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:19.959]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:19.959]  - attr(*, "resolved")= logi FALSE
[08:26:19.959]  - attr(*, "total_size")= num 23453
[08:26:19.959]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:19.959]  - attr(*, "already-done")= logi TRUE
[08:26:19.969] - copied ‘...future.FUN’ to environment
[08:26:19.969] - reassign environment for ‘x_FUN’
[08:26:19.969] - copied ‘x_FUN’ to environment
[08:26:19.970] - copied ‘times’ to environment
[08:26:19.970] - copied ‘stopf’ to environment
[08:26:19.970] - copied ‘stop_if_not’ to environment
[08:26:19.970] - copied ‘dim’ to environment
[08:26:19.970] - copied ‘valid_types’ to environment
[08:26:19.970] - copied ‘future.call.arguments’ to environment
[08:26:19.970] - copied ‘...future.elements_ii’ to environment
[08:26:19.970] - copied ‘...future.seeds_ii’ to environment
[08:26:19.970] - copied ‘...future.globals.maxSize’ to environment
[08:26:19.970] assign_globals() ... done
[08:26:19.971] requestCore(): workers = 2
[08:26:19.973] MulticoreFuture started
[08:26:19.973] - Launch lazy future ... done
[08:26:19.974] run() for ‘MulticoreFuture’ ... done
[08:26:19.974] Created future:
[08:26:19.974] plan(): Setting new future strategy stack:
[08:26:19.975] List of future strategies:
[08:26:19.975] 1. sequential:
[08:26:19.975]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:19.975]    - tweaked: FALSE
[08:26:19.975]    - call: NULL
[08:26:19.976] plan(): nbrOfWorkers() = 1
[08:26:19.978] plan(): Setting new future strategy stack:
[08:26:19.979] List of future strategies:
[08:26:19.979] 1. multicore:
[08:26:19.979]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:19.979]    - tweaked: FALSE
[08:26:19.979]    - call: plan(strategy)
[08:26:19.982] plan(): nbrOfWorkers() = 2
[08:26:19.974] MulticoreFuture:
[08:26:19.974] Label: ‘future_vapply-1’
[08:26:19.974] Expression:
[08:26:19.974] {
[08:26:19.974]     do.call(function(...) {
[08:26:19.974]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.974]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.974]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.974]             on.exit(options(oopts), add = TRUE)
[08:26:19.974]         }
[08:26:19.974]         {
[08:26:19.974]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.974]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.974]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.974]             })
[08:26:19.974]         }
[08:26:19.974]     }, args = future.call.arguments)
[08:26:19.974] }
[08:26:19.974] Lazy evaluation: FALSE
[08:26:19.974] Asynchronous evaluation: TRUE
[08:26:19.974] Local evaluation: TRUE
[08:26:19.974] Environment: R_GlobalEnv
[08:26:19.974] Capture standard output: TRUE
[08:26:19.974] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:19.974] Globals: 11 objects totaling 12.98 KiB (function ‘...future.FUN’ of 4.49 KiB, function ‘x_FUN’ of 296 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:19.974] Packages: 1 packages (‘future.apply’)
[08:26:19.974] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:19.974] Resolved: TRUE
[08:26:19.974] Value: <not collected>
[08:26:19.974] Conditions captured: <none>
[08:26:19.974] Early signaling: FALSE
[08:26:19.974] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:19.974] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:19.983] Chunk #1 of 2 ... DONE
[08:26:19.983] Chunk #2 of 2 ...
[08:26:19.983]  - Finding globals in 'X' for chunk #2 ...
[08:26:19.984] getGlobalsAndPackages() ...
[08:26:19.984] Searching for globals...
[08:26:19.984] 
[08:26:19.984] Searching for globals ... DONE
[08:26:19.985] - globals: [0] <none>
[08:26:19.985] getGlobalsAndPackages() ... DONE
[08:26:19.985]    + additional globals found: [n=0] 
[08:26:19.985]    + additional namespaces needed: [n=0] 
[08:26:19.985]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:19.985]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:19.985]  - seeds: <none>
[08:26:19.985]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.986] getGlobalsAndPackages() ...
[08:26:19.986] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.986] Resolving globals: FALSE
[08:26:19.986] Tweak future expression to call with '...' arguments ...
[08:26:19.986] {
[08:26:19.986]     do.call(function(...) {
[08:26:19.986]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.986]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:19.986]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.986]             on.exit(options(oopts), add = TRUE)
[08:26:19.986]         }
[08:26:19.986]         {
[08:26:19.986]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:19.986]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.986]                 ...future.FUN(...future.X_jj, ...)
[08:26:19.986]             })
[08:26:19.986]         }
[08:26:19.986]     }, args = future.call.arguments)
[08:26:19.986] }
[08:26:19.987] Tweak future expression to call with '...' arguments ... DONE
[08:26:19.988] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:19.988] - packages: [1] ‘future.apply’
[08:26:19.988] getGlobalsAndPackages() ... DONE
[08:26:19.989] run() for ‘Future’ ...
[08:26:19.989] - state: ‘created’
[08:26:19.989] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:19.992] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:19.992] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:19.992]   - Field: ‘label’
[08:26:19.992]   - Field: ‘local’
[08:26:19.992]   - Field: ‘owner’
[08:26:19.992]   - Field: ‘envir’
[08:26:19.993]   - Field: ‘workers’
[08:26:19.993]   - Field: ‘packages’
[08:26:19.993]   - Field: ‘gc’
[08:26:19.993]   - Field: ‘job’
[08:26:19.993]   - Field: ‘conditions’
[08:26:19.993]   - Field: ‘expr’
[08:26:19.993]   - Field: ‘uuid’
[08:26:19.994]   - Field: ‘seed’
[08:26:19.994]   - Field: ‘version’
[08:26:19.994]   - Field: ‘result’
[08:26:19.994]   - Field: ‘asynchronous’
[08:26:19.994]   - Field: ‘calls’
[08:26:19.994]   - Field: ‘globals’
[08:26:19.994]   - Field: ‘stdout’
[08:26:19.994]   - Field: ‘earlySignal’
[08:26:19.995]   - Field: ‘lazy’
[08:26:19.995]   - Field: ‘state’
[08:26:19.995] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:19.995] - Launch lazy future ...
[08:26:19.995] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:19.996] Packages needed by future strategies (n = 0): <none>
[08:26:19.997] {
[08:26:19.997]     {
[08:26:19.997]         {
[08:26:19.997]             ...future.startTime <- base::Sys.time()
[08:26:19.997]             {
[08:26:19.997]                 {
[08:26:19.997]                   {
[08:26:19.997]                     {
[08:26:19.997]                       {
[08:26:19.997]                         base::local({
[08:26:19.997]                           has_future <- base::requireNamespace("future", 
[08:26:19.997]                             quietly = TRUE)
[08:26:19.997]                           if (has_future) {
[08:26:19.997]                             ns <- base::getNamespace("future")
[08:26:19.997]                             version <- ns[[".package"]][["version"]]
[08:26:19.997]                             if (is.null(version)) 
[08:26:19.997]                               version <- utils::packageVersion("future")
[08:26:19.997]                           }
[08:26:19.997]                           else {
[08:26:19.997]                             version <- NULL
[08:26:19.997]                           }
[08:26:19.997]                           if (!has_future || version < "1.8.0") {
[08:26:19.997]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:19.997]                               "", base::R.version$version.string), 
[08:26:19.997]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:19.997]                                 base::R.version$platform, 8 * 
[08:26:19.997]                                   base::.Machine$sizeof.pointer), 
[08:26:19.997]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:19.997]                                 "release", "version")], collapse = " "), 
[08:26:19.997]                               hostname = base::Sys.info()[["nodename"]])
[08:26:19.997]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:19.997]                               info)
[08:26:19.997]                             info <- base::paste(info, collapse = "; ")
[08:26:19.997]                             if (!has_future) {
[08:26:19.997]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:19.997]                                 info)
[08:26:19.997]                             }
[08:26:19.997]                             else {
[08:26:19.997]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:19.997]                                 info, version)
[08:26:19.997]                             }
[08:26:19.997]                             base::stop(msg)
[08:26:19.997]                           }
[08:26:19.997]                         })
[08:26:19.997]                       }
[08:26:19.997]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:19.997]                       base::options(mc.cores = 1L)
[08:26:19.997]                     }
[08:26:19.997]                     base::local({
[08:26:19.997]                       for (pkg in "future.apply") {
[08:26:19.997]                         base::loadNamespace(pkg)
[08:26:19.997]                         base::library(pkg, character.only = TRUE)
[08:26:19.997]                       }
[08:26:19.997]                     })
[08:26:19.997]                   }
[08:26:19.997]                   ...future.strategy.old <- future::plan("list")
[08:26:19.997]                   options(future.plan = NULL)
[08:26:19.997]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.997]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:19.997]                 }
[08:26:19.997]                 ...future.workdir <- getwd()
[08:26:19.997]             }
[08:26:19.997]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:19.997]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:19.997]         }
[08:26:19.997]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:19.997]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:19.997]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:19.997]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:19.997]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:19.997]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:19.997]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:19.997]             base::names(...future.oldOptions))
[08:26:19.997]     }
[08:26:19.997]     if (FALSE) {
[08:26:19.997]     }
[08:26:19.997]     else {
[08:26:19.997]         if (TRUE) {
[08:26:19.997]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:19.997]                 open = "w")
[08:26:19.997]         }
[08:26:19.997]         else {
[08:26:19.997]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:19.997]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:19.997]         }
[08:26:19.997]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:19.997]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:19.997]             base::sink(type = "output", split = FALSE)
[08:26:19.997]             base::close(...future.stdout)
[08:26:19.997]         }, add = TRUE)
[08:26:19.997]     }
[08:26:19.997]     ...future.frame <- base::sys.nframe()
[08:26:19.997]     ...future.conditions <- base::list()
[08:26:19.997]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:19.997]     if (FALSE) {
[08:26:19.997]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:19.997]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:19.997]     }
[08:26:19.997]     ...future.result <- base::tryCatch({
[08:26:19.997]         base::withCallingHandlers({
[08:26:19.997]             ...future.value <- base::withVisible(base::local({
[08:26:19.997]                 withCallingHandlers({
[08:26:19.997]                   {
[08:26:19.997]                     do.call(function(...) {
[08:26:19.997]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:19.997]                       if (!identical(...future.globals.maxSize.org, 
[08:26:19.997]                         ...future.globals.maxSize)) {
[08:26:19.997]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:19.997]                         on.exit(options(oopts), add = TRUE)
[08:26:19.997]                       }
[08:26:19.997]                       {
[08:26:19.997]                         lapply(seq_along(...future.elements_ii), 
[08:26:19.997]                           FUN = function(jj) {
[08:26:19.997]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:19.997]                             ...future.FUN(...future.X_jj, ...)
[08:26:19.997]                           })
[08:26:19.997]                       }
[08:26:19.997]                     }, args = future.call.arguments)
[08:26:19.997]                   }
[08:26:19.997]                 }, immediateCondition = function(cond) {
[08:26:19.997]                   save_rds <- function (object, pathname, ...) 
[08:26:19.997]                   {
[08:26:19.997]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:19.997]                     if (file_test("-f", pathname_tmp)) {
[08:26:19.997]                       fi_tmp <- file.info(pathname_tmp)
[08:26:19.997]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:19.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:19.997]                         fi_tmp[["mtime"]])
[08:26:19.997]                     }
[08:26:19.997]                     tryCatch({
[08:26:19.997]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:19.997]                     }, error = function(ex) {
[08:26:19.997]                       msg <- conditionMessage(ex)
[08:26:19.997]                       fi_tmp <- file.info(pathname_tmp)
[08:26:19.997]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:19.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:19.997]                         fi_tmp[["mtime"]], msg)
[08:26:19.997]                       ex$message <- msg
[08:26:19.997]                       stop(ex)
[08:26:19.997]                     })
[08:26:19.997]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:19.997]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:19.997]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:19.997]                       fi_tmp <- file.info(pathname_tmp)
[08:26:19.997]                       fi <- file.info(pathname)
[08:26:19.997]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:19.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:19.997]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:19.997]                         fi[["size"]], fi[["mtime"]])
[08:26:19.997]                       stop(msg)
[08:26:19.997]                     }
[08:26:19.997]                     invisible(pathname)
[08:26:19.997]                   }
[08:26:19.997]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:19.997]                     rootPath = tempdir()) 
[08:26:19.997]                   {
[08:26:19.997]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:19.997]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:19.997]                       tmpdir = path, fileext = ".rds")
[08:26:19.997]                     save_rds(obj, file)
[08:26:19.997]                   }
[08:26:19.997]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:19.997]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.997]                   {
[08:26:19.997]                     inherits <- base::inherits
[08:26:19.997]                     invokeRestart <- base::invokeRestart
[08:26:19.997]                     is.null <- base::is.null
[08:26:19.997]                     muffled <- FALSE
[08:26:19.997]                     if (inherits(cond, "message")) {
[08:26:19.997]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:19.997]                       if (muffled) 
[08:26:19.997]                         invokeRestart("muffleMessage")
[08:26:19.997]                     }
[08:26:19.997]                     else if (inherits(cond, "warning")) {
[08:26:19.997]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:19.997]                       if (muffled) 
[08:26:19.997]                         invokeRestart("muffleWarning")
[08:26:19.997]                     }
[08:26:19.997]                     else if (inherits(cond, "condition")) {
[08:26:19.997]                       if (!is.null(pattern)) {
[08:26:19.997]                         computeRestarts <- base::computeRestarts
[08:26:19.997]                         grepl <- base::grepl
[08:26:19.997]                         restarts <- computeRestarts(cond)
[08:26:19.997]                         for (restart in restarts) {
[08:26:19.997]                           name <- restart$name
[08:26:19.997]                           if (is.null(name)) 
[08:26:19.997]                             next
[08:26:19.997]                           if (!grepl(pattern, name)) 
[08:26:19.997]                             next
[08:26:19.997]                           invokeRestart(restart)
[08:26:19.997]                           muffled <- TRUE
[08:26:19.997]                           break
[08:26:19.997]                         }
[08:26:19.997]                       }
[08:26:19.997]                     }
[08:26:19.997]                     invisible(muffled)
[08:26:19.997]                   }
[08:26:19.997]                   muffleCondition(cond)
[08:26:19.997]                 })
[08:26:19.997]             }))
[08:26:19.997]             future::FutureResult(value = ...future.value$value, 
[08:26:19.997]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.997]                   ...future.rng), globalenv = if (FALSE) 
[08:26:19.997]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:19.997]                     ...future.globalenv.names))
[08:26:19.997]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:19.997]         }, condition = base::local({
[08:26:19.997]             c <- base::c
[08:26:19.997]             inherits <- base::inherits
[08:26:19.997]             invokeRestart <- base::invokeRestart
[08:26:19.997]             length <- base::length
[08:26:19.997]             list <- base::list
[08:26:19.997]             seq.int <- base::seq.int
[08:26:19.997]             signalCondition <- base::signalCondition
[08:26:19.997]             sys.calls <- base::sys.calls
[08:26:19.997]             `[[` <- base::`[[`
[08:26:19.997]             `+` <- base::`+`
[08:26:19.997]             `<<-` <- base::`<<-`
[08:26:19.997]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:19.997]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:19.997]                   3L)]
[08:26:19.997]             }
[08:26:19.997]             function(cond) {
[08:26:19.997]                 is_error <- inherits(cond, "error")
[08:26:19.997]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:19.997]                   NULL)
[08:26:19.997]                 if (is_error) {
[08:26:19.997]                   sessionInformation <- function() {
[08:26:19.997]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:19.997]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:19.997]                       search = base::search(), system = base::Sys.info())
[08:26:19.997]                   }
[08:26:19.997]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.997]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:19.997]                     cond$call), session = sessionInformation(), 
[08:26:19.997]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:19.997]                   signalCondition(cond)
[08:26:19.997]                 }
[08:26:19.997]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:19.997]                 "immediateCondition"))) {
[08:26:19.997]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:19.997]                   ...future.conditions[[length(...future.conditions) + 
[08:26:19.997]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:19.997]                   if (TRUE && !signal) {
[08:26:19.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.997]                     {
[08:26:19.997]                       inherits <- base::inherits
[08:26:19.997]                       invokeRestart <- base::invokeRestart
[08:26:19.997]                       is.null <- base::is.null
[08:26:19.997]                       muffled <- FALSE
[08:26:19.997]                       if (inherits(cond, "message")) {
[08:26:19.997]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.997]                         if (muffled) 
[08:26:19.997]                           invokeRestart("muffleMessage")
[08:26:19.997]                       }
[08:26:19.997]                       else if (inherits(cond, "warning")) {
[08:26:19.997]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.997]                         if (muffled) 
[08:26:19.997]                           invokeRestart("muffleWarning")
[08:26:19.997]                       }
[08:26:19.997]                       else if (inherits(cond, "condition")) {
[08:26:19.997]                         if (!is.null(pattern)) {
[08:26:19.997]                           computeRestarts <- base::computeRestarts
[08:26:19.997]                           grepl <- base::grepl
[08:26:19.997]                           restarts <- computeRestarts(cond)
[08:26:19.997]                           for (restart in restarts) {
[08:26:19.997]                             name <- restart$name
[08:26:19.997]                             if (is.null(name)) 
[08:26:19.997]                               next
[08:26:19.997]                             if (!grepl(pattern, name)) 
[08:26:19.997]                               next
[08:26:19.997]                             invokeRestart(restart)
[08:26:19.997]                             muffled <- TRUE
[08:26:19.997]                             break
[08:26:19.997]                           }
[08:26:19.997]                         }
[08:26:19.997]                       }
[08:26:19.997]                       invisible(muffled)
[08:26:19.997]                     }
[08:26:19.997]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.997]                   }
[08:26:19.997]                 }
[08:26:19.997]                 else {
[08:26:19.997]                   if (TRUE) {
[08:26:19.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:19.997]                     {
[08:26:19.997]                       inherits <- base::inherits
[08:26:19.997]                       invokeRestart <- base::invokeRestart
[08:26:19.997]                       is.null <- base::is.null
[08:26:19.997]                       muffled <- FALSE
[08:26:19.997]                       if (inherits(cond, "message")) {
[08:26:19.997]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:19.997]                         if (muffled) 
[08:26:19.997]                           invokeRestart("muffleMessage")
[08:26:19.997]                       }
[08:26:19.997]                       else if (inherits(cond, "warning")) {
[08:26:19.997]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:19.997]                         if (muffled) 
[08:26:19.997]                           invokeRestart("muffleWarning")
[08:26:19.997]                       }
[08:26:19.997]                       else if (inherits(cond, "condition")) {
[08:26:19.997]                         if (!is.null(pattern)) {
[08:26:19.997]                           computeRestarts <- base::computeRestarts
[08:26:19.997]                           grepl <- base::grepl
[08:26:19.997]                           restarts <- computeRestarts(cond)
[08:26:19.997]                           for (restart in restarts) {
[08:26:19.997]                             name <- restart$name
[08:26:19.997]                             if (is.null(name)) 
[08:26:19.997]                               next
[08:26:19.997]                             if (!grepl(pattern, name)) 
[08:26:19.997]                               next
[08:26:19.997]                             invokeRestart(restart)
[08:26:19.997]                             muffled <- TRUE
[08:26:19.997]                             break
[08:26:19.997]                           }
[08:26:19.997]                         }
[08:26:19.997]                       }
[08:26:19.997]                       invisible(muffled)
[08:26:19.997]                     }
[08:26:19.997]                     muffleCondition(cond, pattern = "^muffle")
[08:26:19.997]                   }
[08:26:19.997]                 }
[08:26:19.997]             }
[08:26:19.997]         }))
[08:26:19.997]     }, error = function(ex) {
[08:26:19.997]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:19.997]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:19.997]                 ...future.rng), started = ...future.startTime, 
[08:26:19.997]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:19.997]             version = "1.8"), class = "FutureResult")
[08:26:19.997]     }, finally = {
[08:26:19.997]         if (!identical(...future.workdir, getwd())) 
[08:26:19.997]             setwd(...future.workdir)
[08:26:19.997]         {
[08:26:19.997]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:19.997]                 ...future.oldOptions$nwarnings <- NULL
[08:26:19.997]             }
[08:26:19.997]             base::options(...future.oldOptions)
[08:26:19.997]             if (.Platform$OS.type == "windows") {
[08:26:19.997]                 old_names <- names(...future.oldEnvVars)
[08:26:19.997]                 envs <- base::Sys.getenv()
[08:26:19.997]                 names <- names(envs)
[08:26:19.997]                 common <- intersect(names, old_names)
[08:26:19.997]                 added <- setdiff(names, old_names)
[08:26:19.997]                 removed <- setdiff(old_names, names)
[08:26:19.997]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:19.997]                   envs[common]]
[08:26:19.997]                 NAMES <- toupper(changed)
[08:26:19.997]                 args <- list()
[08:26:19.997]                 for (kk in seq_along(NAMES)) {
[08:26:19.997]                   name <- changed[[kk]]
[08:26:19.997]                   NAME <- NAMES[[kk]]
[08:26:19.997]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.997]                     next
[08:26:19.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.997]                 }
[08:26:19.997]                 NAMES <- toupper(added)
[08:26:19.997]                 for (kk in seq_along(NAMES)) {
[08:26:19.997]                   name <- added[[kk]]
[08:26:19.997]                   NAME <- NAMES[[kk]]
[08:26:19.997]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.997]                     next
[08:26:19.997]                   args[[name]] <- ""
[08:26:19.997]                 }
[08:26:19.997]                 NAMES <- toupper(removed)
[08:26:19.997]                 for (kk in seq_along(NAMES)) {
[08:26:19.997]                   name <- removed[[kk]]
[08:26:19.997]                   NAME <- NAMES[[kk]]
[08:26:19.997]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:19.997]                     next
[08:26:19.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:19.997]                 }
[08:26:19.997]                 if (length(args) > 0) 
[08:26:19.997]                   base::do.call(base::Sys.setenv, args = args)
[08:26:19.997]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:19.997]             }
[08:26:19.997]             else {
[08:26:19.997]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:19.997]             }
[08:26:19.997]             {
[08:26:19.997]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:19.997]                   0L) {
[08:26:19.997]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:19.997]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:19.997]                   base::options(opts)
[08:26:19.997]                 }
[08:26:19.997]                 {
[08:26:19.997]                   {
[08:26:19.997]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:19.997]                     NULL
[08:26:19.997]                   }
[08:26:19.997]                   options(future.plan = NULL)
[08:26:19.997]                   if (is.na(NA_character_)) 
[08:26:19.997]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:19.997]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:19.997]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:19.997]                     .init = FALSE)
[08:26:19.997]                 }
[08:26:19.997]             }
[08:26:19.997]         }
[08:26:19.997]     })
[08:26:19.997]     if (TRUE) {
[08:26:19.997]         base::sink(type = "output", split = FALSE)
[08:26:19.997]         if (TRUE) {
[08:26:19.997]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:19.997]         }
[08:26:19.997]         else {
[08:26:19.997]             ...future.result["stdout"] <- base::list(NULL)
[08:26:19.997]         }
[08:26:19.997]         base::close(...future.stdout)
[08:26:19.997]         ...future.stdout <- NULL
[08:26:19.997]     }
[08:26:19.997]     ...future.result$conditions <- ...future.conditions
[08:26:19.997]     ...future.result$finished <- base::Sys.time()
[08:26:19.997]     ...future.result
[08:26:19.997] }
[08:26:20.000] assign_globals() ...
[08:26:20.000] List of 11
[08:26:20.000]  $ ...future.FUN            :function (x, ...)  
[08:26:20.000]  $ x_FUN                    :function (x)  
[08:26:20.000]  $ times                    : int 0
[08:26:20.000]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:20.000]  $ stop_if_not              :function (...)  
[08:26:20.000]  $ dim                      : NULL
[08:26:20.000]  $ valid_types              : chr [1:2] "logical" "integer"
[08:26:20.000]  $ future.call.arguments    : list()
[08:26:20.000]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.000]  $ ...future.elements_ii    :List of 5
[08:26:20.000]   ..$ : int 6
[08:26:20.000]   ..$ : int 7
[08:26:20.000]   ..$ : int 8
[08:26:20.000]   ..$ : int 9
[08:26:20.000]   ..$ : int 10
[08:26:20.000]  $ ...future.seeds_ii       : NULL
[08:26:20.000]  $ ...future.globals.maxSize: NULL
[08:26:20.000]  - attr(*, "where")=List of 11
[08:26:20.000]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:20.000]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:20.000]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:20.000]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:20.000]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:20.000]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:20.000]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:20.000]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:20.000]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:20.000]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:20.000]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:20.000]  - attr(*, "resolved")= logi FALSE
[08:26:20.000]  - attr(*, "total_size")= num 23453
[08:26:20.000]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.000]  - attr(*, "already-done")= logi TRUE
[08:26:20.017] - copied ‘...future.FUN’ to environment
[08:26:20.017] - reassign environment for ‘x_FUN’
[08:26:20.017] - copied ‘x_FUN’ to environment
[08:26:20.017] - copied ‘times’ to environment
[08:26:20.018] - copied ‘stopf’ to environment
[08:26:20.018] - copied ‘stop_if_not’ to environment
[08:26:20.018] - copied ‘dim’ to environment
[08:26:20.018] - copied ‘valid_types’ to environment
[08:26:20.018] - copied ‘future.call.arguments’ to environment
[08:26:20.018] - copied ‘...future.elements_ii’ to environment
[08:26:20.018] - copied ‘...future.seeds_ii’ to environment
[08:26:20.018] - copied ‘...future.globals.maxSize’ to environment
[08:26:20.019] assign_globals() ... done
[08:26:20.019] requestCore(): workers = 2
[08:26:20.021] MulticoreFuture started
[08:26:20.022] - Launch lazy future ... done
[08:26:20.022] run() for ‘MulticoreFuture’ ... done
[08:26:20.022] Created future:
[08:26:20.023] plan(): Setting new future strategy stack:
[08:26:20.023] List of future strategies:
[08:26:20.023] 1. sequential:
[08:26:20.023]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:20.023]    - tweaked: FALSE
[08:26:20.023]    - call: NULL
[08:26:20.024] plan(): nbrOfWorkers() = 1
[08:26:20.027] plan(): Setting new future strategy stack:
[08:26:20.027] List of future strategies:
[08:26:20.027] 1. multicore:
[08:26:20.027]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:20.027]    - tweaked: FALSE
[08:26:20.027]    - call: plan(strategy)
[08:26:20.030] plan(): nbrOfWorkers() = 2
[08:26:20.023] MulticoreFuture:
[08:26:20.023] Label: ‘future_vapply-2’
[08:26:20.023] Expression:
[08:26:20.023] {
[08:26:20.023]     do.call(function(...) {
[08:26:20.023]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.023]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.023]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.023]             on.exit(options(oopts), add = TRUE)
[08:26:20.023]         }
[08:26:20.023]         {
[08:26:20.023]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.023]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.023]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.023]             })
[08:26:20.023]         }
[08:26:20.023]     }, args = future.call.arguments)
[08:26:20.023] }
[08:26:20.023] Lazy evaluation: FALSE
[08:26:20.023] Asynchronous evaluation: TRUE
[08:26:20.023] Local evaluation: TRUE
[08:26:20.023] Environment: R_GlobalEnv
[08:26:20.023] Capture standard output: TRUE
[08:26:20.023] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:20.023] Globals: 11 objects totaling 12.98 KiB (function ‘...future.FUN’ of 4.49 KiB, function ‘x_FUN’ of 296 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:20.023] Packages: 1 packages (‘future.apply’)
[08:26:20.023] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:20.023] Resolved: TRUE
[08:26:20.023] Value: <not collected>
[08:26:20.023] Conditions captured: <none>
[08:26:20.023] Early signaling: FALSE
[08:26:20.023] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:20.023] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.032] Chunk #2 of 2 ... DONE
[08:26:20.032] Launching 2 futures (chunks) ... DONE
[08:26:20.032] Resolving 2 futures (chunks) ...
[08:26:20.032] resolve() on list ...
[08:26:20.032]  recursive: 0
[08:26:20.032]  length: 2
[08:26:20.032] 
[08:26:20.033] Future #1
[08:26:20.033] result() for MulticoreFuture ...
[08:26:20.034] result() for MulticoreFuture ...
[08:26:20.034] result() for MulticoreFuture ... done
[08:26:20.034] result() for MulticoreFuture ... done
[08:26:20.034] result() for MulticoreFuture ...
[08:26:20.034] result() for MulticoreFuture ... done
[08:26:20.035] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:26:20.035] - nx: 2
[08:26:20.035] - relay: TRUE
[08:26:20.035] - stdout: TRUE
[08:26:20.035] - signal: TRUE
[08:26:20.035] - resignal: FALSE
[08:26:20.036] - force: TRUE
[08:26:20.036] - relayed: [n=2] FALSE, FALSE
[08:26:20.036] - queued futures: [n=2] FALSE, FALSE
[08:26:20.036]  - until=1
[08:26:20.036]  - relaying element #1
[08:26:20.036] result() for MulticoreFuture ...
[08:26:20.036] result() for MulticoreFuture ... done
[08:26:20.037] result() for MulticoreFuture ...
[08:26:20.037] result() for MulticoreFuture ... done
[08:26:20.037] result() for MulticoreFuture ...
[08:26:20.037] result() for MulticoreFuture ... done
[08:26:20.037] result() for MulticoreFuture ...
[08:26:20.037] result() for MulticoreFuture ... done
[08:26:20.037] - relayed: [n=2] TRUE, FALSE
[08:26:20.038] - queued futures: [n=2] TRUE, FALSE
[08:26:20.038] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:26:20.038]  length: 1 (resolved future 1)
[08:26:20.038] Future #2
[08:26:20.039] result() for MulticoreFuture ...
[08:26:20.039] result() for MulticoreFuture ...
[08:26:20.039] result() for MulticoreFuture ... done
[08:26:20.039] result() for MulticoreFuture ... done
[08:26:20.040] result() for MulticoreFuture ...
[08:26:20.040] result() for MulticoreFuture ... done
[08:26:20.040] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:26:20.040] - nx: 2
[08:26:20.040] - relay: TRUE
[08:26:20.040] - stdout: TRUE
[08:26:20.040] - signal: TRUE
[08:26:20.041] - resignal: FALSE
[08:26:20.041] - force: TRUE
[08:26:20.041] - relayed: [n=2] TRUE, FALSE
[08:26:20.041] - queued futures: [n=2] TRUE, FALSE
[08:26:20.041]  - until=2
[08:26:20.041]  - relaying element #2
[08:26:20.041] result() for MulticoreFuture ...
[08:26:20.041] result() for MulticoreFuture ... done
[08:26:20.042] result() for MulticoreFuture ...
[08:26:20.042] result() for MulticoreFuture ... done
[08:26:20.042] result() for MulticoreFuture ...
[08:26:20.042] result() for MulticoreFuture ... done
[08:26:20.042] result() for MulticoreFuture ...
[08:26:20.042] result() for MulticoreFuture ... done
[08:26:20.042] - relayed: [n=2] TRUE, TRUE
[08:26:20.042] - queued futures: [n=2] TRUE, TRUE
[08:26:20.043] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:26:20.043]  length: 0 (resolved future 2)
[08:26:20.043] Relaying remaining futures
[08:26:20.043] signalConditionsASAP(NULL, pos=0) ...
[08:26:20.043] - nx: 2
[08:26:20.043] - relay: TRUE
[08:26:20.043] - stdout: TRUE
[08:26:20.043] - signal: TRUE
[08:26:20.043] - resignal: FALSE
[08:26:20.043] - force: TRUE
[08:26:20.044] - relayed: [n=2] TRUE, TRUE
[08:26:20.044] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:20.044] - relayed: [n=2] TRUE, TRUE
[08:26:20.044] - queued futures: [n=2] TRUE, TRUE
[08:26:20.044] signalConditionsASAP(NULL, pos=0) ... done
[08:26:20.044] resolve() on list ... DONE
[08:26:20.044] result() for MulticoreFuture ...
[08:26:20.044] result() for MulticoreFuture ... done
[08:26:20.045] result() for MulticoreFuture ...
[08:26:20.045] result() for MulticoreFuture ... done
[08:26:20.045] result() for MulticoreFuture ...
[08:26:20.045] result() for MulticoreFuture ... done
[08:26:20.045] result() for MulticoreFuture ...
[08:26:20.045] result() for MulticoreFuture ... done
[08:26:20.045]  - Number of value chunks collected: 2
[08:26:20.045] Resolving 2 futures (chunks) ... DONE
[08:26:20.045] Reducing values from 2 chunks ...
[08:26:20.046]  - Number of values collected after concatenation: 10
[08:26:20.046]  - Number of values expected: 10
[08:26:20.046] Reducing values from 2 chunks ... DONE
[08:26:20.046] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[08:26:20.047] future_lapply() ...
[08:26:20.051] Number of chunks: 2
[08:26:20.052] getGlobalsAndPackagesXApply() ...
[08:26:20.052]  - future.globals: TRUE
[08:26:20.052] getGlobalsAndPackages() ...
[08:26:20.052] Searching for globals...
[08:26:20.059] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[08:26:20.059] Searching for globals ... DONE
[08:26:20.059] Resolving globals: FALSE
[08:26:20.060] The total size of the 7 globals is 12.08 KiB (12367 bytes)
[08:26:20.061] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.07 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:20.061] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:20.061] - packages: [1] ‘future.apply’
[08:26:20.061] getGlobalsAndPackages() ... DONE
[08:26:20.061]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:20.061]  - needed namespaces: [n=1] ‘future.apply’
[08:26:20.061] Finding globals ... DONE
[08:26:20.062]  - use_args: TRUE
[08:26:20.062]  - Getting '...' globals ...
[08:26:20.062] resolve() on list ...
[08:26:20.062]  recursive: 0
[08:26:20.062]  length: 1
[08:26:20.062]  elements: ‘...’
[08:26:20.062]  length: 0 (resolved future 1)
[08:26:20.062] resolve() on list ... DONE
[08:26:20.063]    - '...' content: [n=0] 
[08:26:20.063] List of 1
[08:26:20.063]  $ ...: list()
[08:26:20.063]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.063]  - attr(*, "where")=List of 1
[08:26:20.063]   ..$ ...:<environment: 0x562ca7c5bad8> 
[08:26:20.063]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.063]  - attr(*, "resolved")= logi TRUE
[08:26:20.063]  - attr(*, "total_size")= num NA
[08:26:20.065]  - Getting '...' globals ... DONE
[08:26:20.065] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:20.066] List of 8
[08:26:20.066]  $ ...future.FUN:function (x, ...)  
[08:26:20.066]  $ x_FUN        :function (x)  
[08:26:20.066]  $ times        : int 1
[08:26:20.066]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:20.066]  $ stop_if_not  :function (...)  
[08:26:20.066]  $ dim          : NULL
[08:26:20.066]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:20.066]  $ ...          : list()
[08:26:20.066]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.066]  - attr(*, "where")=List of 8
[08:26:20.066]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:20.066]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:20.066]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:20.066]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:20.066]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:20.066]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:20.066]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:20.066]   ..$ ...          :<environment: 0x562ca7c5bad8> 
[08:26:20.066]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.066]  - attr(*, "resolved")= logi FALSE
[08:26:20.066]  - attr(*, "total_size")= num 22322
[08:26:20.071] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:20.071] getGlobalsAndPackagesXApply() ... DONE
[08:26:20.071] Number of futures (= number of chunks): 2
[08:26:20.071] Launching 2 futures (chunks) ...
[08:26:20.072] Chunk #1 of 2 ...
[08:26:20.072]  - Finding globals in 'X' for chunk #1 ...
[08:26:20.072] getGlobalsAndPackages() ...
[08:26:20.072] Searching for globals...
[08:26:20.072] 
[08:26:20.072] Searching for globals ... DONE
[08:26:20.072] - globals: [0] <none>
[08:26:20.072] getGlobalsAndPackages() ... DONE
[08:26:20.072]    + additional globals found: [n=0] 
[08:26:20.073]    + additional namespaces needed: [n=0] 
[08:26:20.073]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:20.073]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:20.073]  - seeds: <none>
[08:26:20.073]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.073] getGlobalsAndPackages() ...
[08:26:20.073] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.073] Resolving globals: FALSE
[08:26:20.073] Tweak future expression to call with '...' arguments ...
[08:26:20.073] {
[08:26:20.073]     do.call(function(...) {
[08:26:20.073]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.073]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.073]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.073]             on.exit(options(oopts), add = TRUE)
[08:26:20.073]         }
[08:26:20.073]         {
[08:26:20.073]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.073]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.073]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.073]             })
[08:26:20.073]         }
[08:26:20.073]     }, args = future.call.arguments)
[08:26:20.073] }
[08:26:20.074] Tweak future expression to call with '...' arguments ... DONE
[08:26:20.074] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.074] - packages: [1] ‘future.apply’
[08:26:20.074] getGlobalsAndPackages() ... DONE
[08:26:20.075] run() for ‘Future’ ...
[08:26:20.075] - state: ‘created’
[08:26:20.075] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:20.079] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.079] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:20.079]   - Field: ‘label’
[08:26:20.079]   - Field: ‘local’
[08:26:20.079]   - Field: ‘owner’
[08:26:20.079]   - Field: ‘envir’
[08:26:20.079]   - Field: ‘workers’
[08:26:20.080]   - Field: ‘packages’
[08:26:20.080]   - Field: ‘gc’
[08:26:20.080]   - Field: ‘job’
[08:26:20.080]   - Field: ‘conditions’
[08:26:20.080]   - Field: ‘expr’
[08:26:20.080]   - Field: ‘uuid’
[08:26:20.080]   - Field: ‘seed’
[08:26:20.080]   - Field: ‘version’
[08:26:20.080]   - Field: ‘result’
[08:26:20.080]   - Field: ‘asynchronous’
[08:26:20.081]   - Field: ‘calls’
[08:26:20.081]   - Field: ‘globals’
[08:26:20.081]   - Field: ‘stdout’
[08:26:20.081]   - Field: ‘earlySignal’
[08:26:20.081]   - Field: ‘lazy’
[08:26:20.081]   - Field: ‘state’
[08:26:20.081] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:20.081] - Launch lazy future ...
[08:26:20.082] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:20.082] Packages needed by future strategies (n = 0): <none>
[08:26:20.082] {
[08:26:20.082]     {
[08:26:20.082]         {
[08:26:20.082]             ...future.startTime <- base::Sys.time()
[08:26:20.082]             {
[08:26:20.082]                 {
[08:26:20.082]                   {
[08:26:20.082]                     {
[08:26:20.082]                       {
[08:26:20.082]                         base::local({
[08:26:20.082]                           has_future <- base::requireNamespace("future", 
[08:26:20.082]                             quietly = TRUE)
[08:26:20.082]                           if (has_future) {
[08:26:20.082]                             ns <- base::getNamespace("future")
[08:26:20.082]                             version <- ns[[".package"]][["version"]]
[08:26:20.082]                             if (is.null(version)) 
[08:26:20.082]                               version <- utils::packageVersion("future")
[08:26:20.082]                           }
[08:26:20.082]                           else {
[08:26:20.082]                             version <- NULL
[08:26:20.082]                           }
[08:26:20.082]                           if (!has_future || version < "1.8.0") {
[08:26:20.082]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:20.082]                               "", base::R.version$version.string), 
[08:26:20.082]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:20.082]                                 base::R.version$platform, 8 * 
[08:26:20.082]                                   base::.Machine$sizeof.pointer), 
[08:26:20.082]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:20.082]                                 "release", "version")], collapse = " "), 
[08:26:20.082]                               hostname = base::Sys.info()[["nodename"]])
[08:26:20.082]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:20.082]                               info)
[08:26:20.082]                             info <- base::paste(info, collapse = "; ")
[08:26:20.082]                             if (!has_future) {
[08:26:20.082]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:20.082]                                 info)
[08:26:20.082]                             }
[08:26:20.082]                             else {
[08:26:20.082]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:20.082]                                 info, version)
[08:26:20.082]                             }
[08:26:20.082]                             base::stop(msg)
[08:26:20.082]                           }
[08:26:20.082]                         })
[08:26:20.082]                       }
[08:26:20.082]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:20.082]                       base::options(mc.cores = 1L)
[08:26:20.082]                     }
[08:26:20.082]                     base::local({
[08:26:20.082]                       for (pkg in "future.apply") {
[08:26:20.082]                         base::loadNamespace(pkg)
[08:26:20.082]                         base::library(pkg, character.only = TRUE)
[08:26:20.082]                       }
[08:26:20.082]                     })
[08:26:20.082]                   }
[08:26:20.082]                   ...future.strategy.old <- future::plan("list")
[08:26:20.082]                   options(future.plan = NULL)
[08:26:20.082]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.082]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:20.082]                 }
[08:26:20.082]                 ...future.workdir <- getwd()
[08:26:20.082]             }
[08:26:20.082]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:20.082]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:20.082]         }
[08:26:20.082]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:20.082]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:20.082]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:20.082]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:20.082]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:20.082]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:20.082]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:20.082]             base::names(...future.oldOptions))
[08:26:20.082]     }
[08:26:20.082]     if (FALSE) {
[08:26:20.082]     }
[08:26:20.082]     else {
[08:26:20.082]         if (TRUE) {
[08:26:20.082]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:20.082]                 open = "w")
[08:26:20.082]         }
[08:26:20.082]         else {
[08:26:20.082]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:20.082]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:20.082]         }
[08:26:20.082]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:20.082]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:20.082]             base::sink(type = "output", split = FALSE)
[08:26:20.082]             base::close(...future.stdout)
[08:26:20.082]         }, add = TRUE)
[08:26:20.082]     }
[08:26:20.082]     ...future.frame <- base::sys.nframe()
[08:26:20.082]     ...future.conditions <- base::list()
[08:26:20.082]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:20.082]     if (FALSE) {
[08:26:20.082]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:20.082]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:20.082]     }
[08:26:20.082]     ...future.result <- base::tryCatch({
[08:26:20.082]         base::withCallingHandlers({
[08:26:20.082]             ...future.value <- base::withVisible(base::local({
[08:26:20.082]                 withCallingHandlers({
[08:26:20.082]                   {
[08:26:20.082]                     do.call(function(...) {
[08:26:20.082]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.082]                       if (!identical(...future.globals.maxSize.org, 
[08:26:20.082]                         ...future.globals.maxSize)) {
[08:26:20.082]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.082]                         on.exit(options(oopts), add = TRUE)
[08:26:20.082]                       }
[08:26:20.082]                       {
[08:26:20.082]                         lapply(seq_along(...future.elements_ii), 
[08:26:20.082]                           FUN = function(jj) {
[08:26:20.082]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.082]                             ...future.FUN(...future.X_jj, ...)
[08:26:20.082]                           })
[08:26:20.082]                       }
[08:26:20.082]                     }, args = future.call.arguments)
[08:26:20.082]                   }
[08:26:20.082]                 }, immediateCondition = function(cond) {
[08:26:20.082]                   save_rds <- function (object, pathname, ...) 
[08:26:20.082]                   {
[08:26:20.082]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:20.082]                     if (file_test("-f", pathname_tmp)) {
[08:26:20.082]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.082]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:20.082]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.082]                         fi_tmp[["mtime"]])
[08:26:20.082]                     }
[08:26:20.082]                     tryCatch({
[08:26:20.082]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:20.082]                     }, error = function(ex) {
[08:26:20.082]                       msg <- conditionMessage(ex)
[08:26:20.082]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.082]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:20.082]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.082]                         fi_tmp[["mtime"]], msg)
[08:26:20.082]                       ex$message <- msg
[08:26:20.082]                       stop(ex)
[08:26:20.082]                     })
[08:26:20.082]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:20.082]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:20.082]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:20.082]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.082]                       fi <- file.info(pathname)
[08:26:20.082]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:20.082]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.082]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:20.082]                         fi[["size"]], fi[["mtime"]])
[08:26:20.082]                       stop(msg)
[08:26:20.082]                     }
[08:26:20.082]                     invisible(pathname)
[08:26:20.082]                   }
[08:26:20.082]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:20.082]                     rootPath = tempdir()) 
[08:26:20.082]                   {
[08:26:20.082]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:20.082]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:20.082]                       tmpdir = path, fileext = ".rds")
[08:26:20.082]                     save_rds(obj, file)
[08:26:20.082]                   }
[08:26:20.082]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:20.082]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.082]                   {
[08:26:20.082]                     inherits <- base::inherits
[08:26:20.082]                     invokeRestart <- base::invokeRestart
[08:26:20.082]                     is.null <- base::is.null
[08:26:20.082]                     muffled <- FALSE
[08:26:20.082]                     if (inherits(cond, "message")) {
[08:26:20.082]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:20.082]                       if (muffled) 
[08:26:20.082]                         invokeRestart("muffleMessage")
[08:26:20.082]                     }
[08:26:20.082]                     else if (inherits(cond, "warning")) {
[08:26:20.082]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:20.082]                       if (muffled) 
[08:26:20.082]                         invokeRestart("muffleWarning")
[08:26:20.082]                     }
[08:26:20.082]                     else if (inherits(cond, "condition")) {
[08:26:20.082]                       if (!is.null(pattern)) {
[08:26:20.082]                         computeRestarts <- base::computeRestarts
[08:26:20.082]                         grepl <- base::grepl
[08:26:20.082]                         restarts <- computeRestarts(cond)
[08:26:20.082]                         for (restart in restarts) {
[08:26:20.082]                           name <- restart$name
[08:26:20.082]                           if (is.null(name)) 
[08:26:20.082]                             next
[08:26:20.082]                           if (!grepl(pattern, name)) 
[08:26:20.082]                             next
[08:26:20.082]                           invokeRestart(restart)
[08:26:20.082]                           muffled <- TRUE
[08:26:20.082]                           break
[08:26:20.082]                         }
[08:26:20.082]                       }
[08:26:20.082]                     }
[08:26:20.082]                     invisible(muffled)
[08:26:20.082]                   }
[08:26:20.082]                   muffleCondition(cond)
[08:26:20.082]                 })
[08:26:20.082]             }))
[08:26:20.082]             future::FutureResult(value = ...future.value$value, 
[08:26:20.082]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.082]                   ...future.rng), globalenv = if (FALSE) 
[08:26:20.082]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:20.082]                     ...future.globalenv.names))
[08:26:20.082]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:20.082]         }, condition = base::local({
[08:26:20.082]             c <- base::c
[08:26:20.082]             inherits <- base::inherits
[08:26:20.082]             invokeRestart <- base::invokeRestart
[08:26:20.082]             length <- base::length
[08:26:20.082]             list <- base::list
[08:26:20.082]             seq.int <- base::seq.int
[08:26:20.082]             signalCondition <- base::signalCondition
[08:26:20.082]             sys.calls <- base::sys.calls
[08:26:20.082]             `[[` <- base::`[[`
[08:26:20.082]             `+` <- base::`+`
[08:26:20.082]             `<<-` <- base::`<<-`
[08:26:20.082]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:20.082]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:20.082]                   3L)]
[08:26:20.082]             }
[08:26:20.082]             function(cond) {
[08:26:20.082]                 is_error <- inherits(cond, "error")
[08:26:20.082]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:20.082]                   NULL)
[08:26:20.082]                 if (is_error) {
[08:26:20.082]                   sessionInformation <- function() {
[08:26:20.082]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:20.082]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:20.082]                       search = base::search(), system = base::Sys.info())
[08:26:20.082]                   }
[08:26:20.082]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.082]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:20.082]                     cond$call), session = sessionInformation(), 
[08:26:20.082]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:20.082]                   signalCondition(cond)
[08:26:20.082]                 }
[08:26:20.082]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:20.082]                 "immediateCondition"))) {
[08:26:20.082]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:20.082]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.082]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:20.082]                   if (TRUE && !signal) {
[08:26:20.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.082]                     {
[08:26:20.082]                       inherits <- base::inherits
[08:26:20.082]                       invokeRestart <- base::invokeRestart
[08:26:20.082]                       is.null <- base::is.null
[08:26:20.082]                       muffled <- FALSE
[08:26:20.082]                       if (inherits(cond, "message")) {
[08:26:20.082]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.082]                         if (muffled) 
[08:26:20.082]                           invokeRestart("muffleMessage")
[08:26:20.082]                       }
[08:26:20.082]                       else if (inherits(cond, "warning")) {
[08:26:20.082]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.082]                         if (muffled) 
[08:26:20.082]                           invokeRestart("muffleWarning")
[08:26:20.082]                       }
[08:26:20.082]                       else if (inherits(cond, "condition")) {
[08:26:20.082]                         if (!is.null(pattern)) {
[08:26:20.082]                           computeRestarts <- base::computeRestarts
[08:26:20.082]                           grepl <- base::grepl
[08:26:20.082]                           restarts <- computeRestarts(cond)
[08:26:20.082]                           for (restart in restarts) {
[08:26:20.082]                             name <- restart$name
[08:26:20.082]                             if (is.null(name)) 
[08:26:20.082]                               next
[08:26:20.082]                             if (!grepl(pattern, name)) 
[08:26:20.082]                               next
[08:26:20.082]                             invokeRestart(restart)
[08:26:20.082]                             muffled <- TRUE
[08:26:20.082]                             break
[08:26:20.082]                           }
[08:26:20.082]                         }
[08:26:20.082]                       }
[08:26:20.082]                       invisible(muffled)
[08:26:20.082]                     }
[08:26:20.082]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.082]                   }
[08:26:20.082]                 }
[08:26:20.082]                 else {
[08:26:20.082]                   if (TRUE) {
[08:26:20.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.082]                     {
[08:26:20.082]                       inherits <- base::inherits
[08:26:20.082]                       invokeRestart <- base::invokeRestart
[08:26:20.082]                       is.null <- base::is.null
[08:26:20.082]                       muffled <- FALSE
[08:26:20.082]                       if (inherits(cond, "message")) {
[08:26:20.082]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.082]                         if (muffled) 
[08:26:20.082]                           invokeRestart("muffleMessage")
[08:26:20.082]                       }
[08:26:20.082]                       else if (inherits(cond, "warning")) {
[08:26:20.082]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.082]                         if (muffled) 
[08:26:20.082]                           invokeRestart("muffleWarning")
[08:26:20.082]                       }
[08:26:20.082]                       else if (inherits(cond, "condition")) {
[08:26:20.082]                         if (!is.null(pattern)) {
[08:26:20.082]                           computeRestarts <- base::computeRestarts
[08:26:20.082]                           grepl <- base::grepl
[08:26:20.082]                           restarts <- computeRestarts(cond)
[08:26:20.082]                           for (restart in restarts) {
[08:26:20.082]                             name <- restart$name
[08:26:20.082]                             if (is.null(name)) 
[08:26:20.082]                               next
[08:26:20.082]                             if (!grepl(pattern, name)) 
[08:26:20.082]                               next
[08:26:20.082]                             invokeRestart(restart)
[08:26:20.082]                             muffled <- TRUE
[08:26:20.082]                             break
[08:26:20.082]                           }
[08:26:20.082]                         }
[08:26:20.082]                       }
[08:26:20.082]                       invisible(muffled)
[08:26:20.082]                     }
[08:26:20.082]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.082]                   }
[08:26:20.082]                 }
[08:26:20.082]             }
[08:26:20.082]         }))
[08:26:20.082]     }, error = function(ex) {
[08:26:20.082]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:20.082]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.082]                 ...future.rng), started = ...future.startTime, 
[08:26:20.082]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:20.082]             version = "1.8"), class = "FutureResult")
[08:26:20.082]     }, finally = {
[08:26:20.082]         if (!identical(...future.workdir, getwd())) 
[08:26:20.082]             setwd(...future.workdir)
[08:26:20.082]         {
[08:26:20.082]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:20.082]                 ...future.oldOptions$nwarnings <- NULL
[08:26:20.082]             }
[08:26:20.082]             base::options(...future.oldOptions)
[08:26:20.082]             if (.Platform$OS.type == "windows") {
[08:26:20.082]                 old_names <- names(...future.oldEnvVars)
[08:26:20.082]                 envs <- base::Sys.getenv()
[08:26:20.082]                 names <- names(envs)
[08:26:20.082]                 common <- intersect(names, old_names)
[08:26:20.082]                 added <- setdiff(names, old_names)
[08:26:20.082]                 removed <- setdiff(old_names, names)
[08:26:20.082]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:20.082]                   envs[common]]
[08:26:20.082]                 NAMES <- toupper(changed)
[08:26:20.082]                 args <- list()
[08:26:20.082]                 for (kk in seq_along(NAMES)) {
[08:26:20.082]                   name <- changed[[kk]]
[08:26:20.082]                   NAME <- NAMES[[kk]]
[08:26:20.082]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.082]                     next
[08:26:20.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.082]                 }
[08:26:20.082]                 NAMES <- toupper(added)
[08:26:20.082]                 for (kk in seq_along(NAMES)) {
[08:26:20.082]                   name <- added[[kk]]
[08:26:20.082]                   NAME <- NAMES[[kk]]
[08:26:20.082]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.082]                     next
[08:26:20.082]                   args[[name]] <- ""
[08:26:20.082]                 }
[08:26:20.082]                 NAMES <- toupper(removed)
[08:26:20.082]                 for (kk in seq_along(NAMES)) {
[08:26:20.082]                   name <- removed[[kk]]
[08:26:20.082]                   NAME <- NAMES[[kk]]
[08:26:20.082]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.082]                     next
[08:26:20.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.082]                 }
[08:26:20.082]                 if (length(args) > 0) 
[08:26:20.082]                   base::do.call(base::Sys.setenv, args = args)
[08:26:20.082]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:20.082]             }
[08:26:20.082]             else {
[08:26:20.082]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:20.082]             }
[08:26:20.082]             {
[08:26:20.082]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:20.082]                   0L) {
[08:26:20.082]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:20.082]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:20.082]                   base::options(opts)
[08:26:20.082]                 }
[08:26:20.082]                 {
[08:26:20.082]                   {
[08:26:20.082]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:20.082]                     NULL
[08:26:20.082]                   }
[08:26:20.082]                   options(future.plan = NULL)
[08:26:20.082]                   if (is.na(NA_character_)) 
[08:26:20.082]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.082]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:20.082]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:20.082]                     .init = FALSE)
[08:26:20.082]                 }
[08:26:20.082]             }
[08:26:20.082]         }
[08:26:20.082]     })
[08:26:20.082]     if (TRUE) {
[08:26:20.082]         base::sink(type = "output", split = FALSE)
[08:26:20.082]         if (TRUE) {
[08:26:20.082]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:20.082]         }
[08:26:20.082]         else {
[08:26:20.082]             ...future.result["stdout"] <- base::list(NULL)
[08:26:20.082]         }
[08:26:20.082]         base::close(...future.stdout)
[08:26:20.082]         ...future.stdout <- NULL
[08:26:20.082]     }
[08:26:20.082]     ...future.result$conditions <- ...future.conditions
[08:26:20.082]     ...future.result$finished <- base::Sys.time()
[08:26:20.082]     ...future.result
[08:26:20.082] }
[08:26:20.085] assign_globals() ...
[08:26:20.085] List of 11
[08:26:20.085]  $ ...future.FUN            :function (x, ...)  
[08:26:20.085]  $ x_FUN                    :function (x)  
[08:26:20.085]  $ times                    : int 1
[08:26:20.085]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:20.085]  $ stop_if_not              :function (...)  
[08:26:20.085]  $ dim                      : NULL
[08:26:20.085]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:20.085]  $ future.call.arguments    : list()
[08:26:20.085]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.085]  $ ...future.elements_ii    :List of 5
[08:26:20.085]   ..$ : int 1
[08:26:20.085]   ..$ : int 2
[08:26:20.085]   ..$ : int 3
[08:26:20.085]   ..$ : int 4
[08:26:20.085]   ..$ : int 5
[08:26:20.085]  $ ...future.seeds_ii       : NULL
[08:26:20.085]  $ ...future.globals.maxSize: NULL
[08:26:20.085]  - attr(*, "where")=List of 11
[08:26:20.085]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:20.085]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:20.085]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:20.085]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:20.085]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:20.085]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:20.085]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:20.085]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:20.085]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:20.085]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:20.085]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:20.085]  - attr(*, "resolved")= logi FALSE
[08:26:20.085]  - attr(*, "total_size")= num 22322
[08:26:20.085]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.085]  - attr(*, "already-done")= logi TRUE
[08:26:20.093] - copied ‘...future.FUN’ to environment
[08:26:20.094] - copied ‘x_FUN’ to environment
[08:26:20.094] - copied ‘times’ to environment
[08:26:20.094] - copied ‘stopf’ to environment
[08:26:20.094] - copied ‘stop_if_not’ to environment
[08:26:20.094] - copied ‘dim’ to environment
[08:26:20.094] - copied ‘valid_types’ to environment
[08:26:20.094] - copied ‘future.call.arguments’ to environment
[08:26:20.094] - copied ‘...future.elements_ii’ to environment
[08:26:20.094] - copied ‘...future.seeds_ii’ to environment
[08:26:20.094] - copied ‘...future.globals.maxSize’ to environment
[08:26:20.095] assign_globals() ... done
[08:26:20.095] requestCore(): workers = 2
[08:26:20.097] MulticoreFuture started
[08:26:20.097] - Launch lazy future ... done
[08:26:20.098] run() for ‘MulticoreFuture’ ... done
[08:26:20.098] Created future:
[08:26:20.098] plan(): Setting new future strategy stack:
[08:26:20.099] List of future strategies:
[08:26:20.099] 1. sequential:
[08:26:20.099]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:20.099]    - tweaked: FALSE
[08:26:20.099]    - call: NULL
[08:26:20.100] plan(): nbrOfWorkers() = 1
[08:26:20.102] plan(): Setting new future strategy stack:
[08:26:20.102] List of future strategies:
[08:26:20.102] 1. multicore:
[08:26:20.102]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:20.102]    - tweaked: FALSE
[08:26:20.102]    - call: plan(strategy)
[08:26:20.105] plan(): nbrOfWorkers() = 2
[08:26:20.098] MulticoreFuture:
[08:26:20.098] Label: ‘future_vapply-1’
[08:26:20.098] Expression:
[08:26:20.098] {
[08:26:20.098]     do.call(function(...) {
[08:26:20.098]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.098]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.098]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.098]             on.exit(options(oopts), add = TRUE)
[08:26:20.098]         }
[08:26:20.098]         {
[08:26:20.098]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.098]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.098]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.098]             })
[08:26:20.098]         }
[08:26:20.098]     }, args = future.call.arguments)
[08:26:20.098] }
[08:26:20.098] Lazy evaluation: FALSE
[08:26:20.098] Asynchronous evaluation: TRUE
[08:26:20.098] Local evaluation: TRUE
[08:26:20.098] Environment: R_GlobalEnv
[08:26:20.098] Capture standard output: TRUE
[08:26:20.098] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:20.098] Globals: 11 objects totaling 12.31 KiB (function ‘...future.FUN’ of 4.06 KiB, function ‘x_FUN’ of 35 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:20.098] Packages: 1 packages (‘future.apply’)
[08:26:20.098] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:20.098] Resolved: TRUE
[08:26:20.098] Value: <not collected>
[08:26:20.098] Conditions captured: <none>
[08:26:20.098] Early signaling: FALSE
[08:26:20.098] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:20.098] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.106] Chunk #1 of 2 ... DONE
[08:26:20.106] Chunk #2 of 2 ...
[08:26:20.106]  - Finding globals in 'X' for chunk #2 ...
[08:26:20.107] getGlobalsAndPackages() ...
[08:26:20.107] Searching for globals...
[08:26:20.107] 
[08:26:20.107] Searching for globals ... DONE
[08:26:20.107] - globals: [0] <none>
[08:26:20.108] getGlobalsAndPackages() ... DONE
[08:26:20.108]    + additional globals found: [n=0] 
[08:26:20.108]    + additional namespaces needed: [n=0] 
[08:26:20.108]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:20.108]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:20.108]  - seeds: <none>
[08:26:20.108]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.108] getGlobalsAndPackages() ...
[08:26:20.109] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.109] Resolving globals: FALSE
[08:26:20.109] Tweak future expression to call with '...' arguments ...
[08:26:20.109] {
[08:26:20.109]     do.call(function(...) {
[08:26:20.109]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.109]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.109]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.109]             on.exit(options(oopts), add = TRUE)
[08:26:20.109]         }
[08:26:20.109]         {
[08:26:20.109]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.109]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.109]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.109]             })
[08:26:20.109]         }
[08:26:20.109]     }, args = future.call.arguments)
[08:26:20.109] }
[08:26:20.110] Tweak future expression to call with '...' arguments ... DONE
[08:26:20.111] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.111] - packages: [1] ‘future.apply’
[08:26:20.111] getGlobalsAndPackages() ... DONE
[08:26:20.111] run() for ‘Future’ ...
[08:26:20.112] - state: ‘created’
[08:26:20.112] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:20.120] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.120] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:20.120]   - Field: ‘label’
[08:26:20.121]   - Field: ‘local’
[08:26:20.121]   - Field: ‘owner’
[08:26:20.121]   - Field: ‘envir’
[08:26:20.121]   - Field: ‘workers’
[08:26:20.122]   - Field: ‘packages’
[08:26:20.122]   - Field: ‘gc’
[08:26:20.122]   - Field: ‘job’
[08:26:20.123]   - Field: ‘conditions’
[08:26:20.123]   - Field: ‘expr’
[08:26:20.123]   - Field: ‘uuid’
[08:26:20.123]   - Field: ‘seed’
[08:26:20.124]   - Field: ‘version’
[08:26:20.124]   - Field: ‘result’
[08:26:20.124]   - Field: ‘asynchronous’
[08:26:20.124]   - Field: ‘calls’
[08:26:20.124]   - Field: ‘globals’
[08:26:20.125]   - Field: ‘stdout’
[08:26:20.125]   - Field: ‘earlySignal’
[08:26:20.125]   - Field: ‘lazy’
[08:26:20.125]   - Field: ‘state’
[08:26:20.126] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:20.126] - Launch lazy future ...
[08:26:20.126] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:20.126] Packages needed by future strategies (n = 0): <none>
[08:26:20.127] {
[08:26:20.127]     {
[08:26:20.127]         {
[08:26:20.127]             ...future.startTime <- base::Sys.time()
[08:26:20.127]             {
[08:26:20.127]                 {
[08:26:20.127]                   {
[08:26:20.127]                     {
[08:26:20.127]                       {
[08:26:20.127]                         base::local({
[08:26:20.127]                           has_future <- base::requireNamespace("future", 
[08:26:20.127]                             quietly = TRUE)
[08:26:20.127]                           if (has_future) {
[08:26:20.127]                             ns <- base::getNamespace("future")
[08:26:20.127]                             version <- ns[[".package"]][["version"]]
[08:26:20.127]                             if (is.null(version)) 
[08:26:20.127]                               version <- utils::packageVersion("future")
[08:26:20.127]                           }
[08:26:20.127]                           else {
[08:26:20.127]                             version <- NULL
[08:26:20.127]                           }
[08:26:20.127]                           if (!has_future || version < "1.8.0") {
[08:26:20.127]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:20.127]                               "", base::R.version$version.string), 
[08:26:20.127]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:20.127]                                 base::R.version$platform, 8 * 
[08:26:20.127]                                   base::.Machine$sizeof.pointer), 
[08:26:20.127]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:20.127]                                 "release", "version")], collapse = " "), 
[08:26:20.127]                               hostname = base::Sys.info()[["nodename"]])
[08:26:20.127]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:20.127]                               info)
[08:26:20.127]                             info <- base::paste(info, collapse = "; ")
[08:26:20.127]                             if (!has_future) {
[08:26:20.127]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:20.127]                                 info)
[08:26:20.127]                             }
[08:26:20.127]                             else {
[08:26:20.127]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:20.127]                                 info, version)
[08:26:20.127]                             }
[08:26:20.127]                             base::stop(msg)
[08:26:20.127]                           }
[08:26:20.127]                         })
[08:26:20.127]                       }
[08:26:20.127]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:20.127]                       base::options(mc.cores = 1L)
[08:26:20.127]                     }
[08:26:20.127]                     base::local({
[08:26:20.127]                       for (pkg in "future.apply") {
[08:26:20.127]                         base::loadNamespace(pkg)
[08:26:20.127]                         base::library(pkg, character.only = TRUE)
[08:26:20.127]                       }
[08:26:20.127]                     })
[08:26:20.127]                   }
[08:26:20.127]                   ...future.strategy.old <- future::plan("list")
[08:26:20.127]                   options(future.plan = NULL)
[08:26:20.127]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.127]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:20.127]                 }
[08:26:20.127]                 ...future.workdir <- getwd()
[08:26:20.127]             }
[08:26:20.127]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:20.127]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:20.127]         }
[08:26:20.127]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:20.127]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:20.127]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:20.127]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:20.127]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:20.127]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:20.127]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:20.127]             base::names(...future.oldOptions))
[08:26:20.127]     }
[08:26:20.127]     if (FALSE) {
[08:26:20.127]     }
[08:26:20.127]     else {
[08:26:20.127]         if (TRUE) {
[08:26:20.127]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:20.127]                 open = "w")
[08:26:20.127]         }
[08:26:20.127]         else {
[08:26:20.127]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:20.127]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:20.127]         }
[08:26:20.127]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:20.127]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:20.127]             base::sink(type = "output", split = FALSE)
[08:26:20.127]             base::close(...future.stdout)
[08:26:20.127]         }, add = TRUE)
[08:26:20.127]     }
[08:26:20.127]     ...future.frame <- base::sys.nframe()
[08:26:20.127]     ...future.conditions <- base::list()
[08:26:20.127]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:20.127]     if (FALSE) {
[08:26:20.127]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:20.127]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:20.127]     }
[08:26:20.127]     ...future.result <- base::tryCatch({
[08:26:20.127]         base::withCallingHandlers({
[08:26:20.127]             ...future.value <- base::withVisible(base::local({
[08:26:20.127]                 withCallingHandlers({
[08:26:20.127]                   {
[08:26:20.127]                     do.call(function(...) {
[08:26:20.127]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.127]                       if (!identical(...future.globals.maxSize.org, 
[08:26:20.127]                         ...future.globals.maxSize)) {
[08:26:20.127]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.127]                         on.exit(options(oopts), add = TRUE)
[08:26:20.127]                       }
[08:26:20.127]                       {
[08:26:20.127]                         lapply(seq_along(...future.elements_ii), 
[08:26:20.127]                           FUN = function(jj) {
[08:26:20.127]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.127]                             ...future.FUN(...future.X_jj, ...)
[08:26:20.127]                           })
[08:26:20.127]                       }
[08:26:20.127]                     }, args = future.call.arguments)
[08:26:20.127]                   }
[08:26:20.127]                 }, immediateCondition = function(cond) {
[08:26:20.127]                   save_rds <- function (object, pathname, ...) 
[08:26:20.127]                   {
[08:26:20.127]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:20.127]                     if (file_test("-f", pathname_tmp)) {
[08:26:20.127]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.127]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:20.127]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.127]                         fi_tmp[["mtime"]])
[08:26:20.127]                     }
[08:26:20.127]                     tryCatch({
[08:26:20.127]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:20.127]                     }, error = function(ex) {
[08:26:20.127]                       msg <- conditionMessage(ex)
[08:26:20.127]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.127]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:20.127]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.127]                         fi_tmp[["mtime"]], msg)
[08:26:20.127]                       ex$message <- msg
[08:26:20.127]                       stop(ex)
[08:26:20.127]                     })
[08:26:20.127]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:20.127]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:20.127]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:20.127]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.127]                       fi <- file.info(pathname)
[08:26:20.127]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:20.127]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.127]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:20.127]                         fi[["size"]], fi[["mtime"]])
[08:26:20.127]                       stop(msg)
[08:26:20.127]                     }
[08:26:20.127]                     invisible(pathname)
[08:26:20.127]                   }
[08:26:20.127]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:20.127]                     rootPath = tempdir()) 
[08:26:20.127]                   {
[08:26:20.127]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:20.127]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:20.127]                       tmpdir = path, fileext = ".rds")
[08:26:20.127]                     save_rds(obj, file)
[08:26:20.127]                   }
[08:26:20.127]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:20.127]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.127]                   {
[08:26:20.127]                     inherits <- base::inherits
[08:26:20.127]                     invokeRestart <- base::invokeRestart
[08:26:20.127]                     is.null <- base::is.null
[08:26:20.127]                     muffled <- FALSE
[08:26:20.127]                     if (inherits(cond, "message")) {
[08:26:20.127]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:20.127]                       if (muffled) 
[08:26:20.127]                         invokeRestart("muffleMessage")
[08:26:20.127]                     }
[08:26:20.127]                     else if (inherits(cond, "warning")) {
[08:26:20.127]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:20.127]                       if (muffled) 
[08:26:20.127]                         invokeRestart("muffleWarning")
[08:26:20.127]                     }
[08:26:20.127]                     else if (inherits(cond, "condition")) {
[08:26:20.127]                       if (!is.null(pattern)) {
[08:26:20.127]                         computeRestarts <- base::computeRestarts
[08:26:20.127]                         grepl <- base::grepl
[08:26:20.127]                         restarts <- computeRestarts(cond)
[08:26:20.127]                         for (restart in restarts) {
[08:26:20.127]                           name <- restart$name
[08:26:20.127]                           if (is.null(name)) 
[08:26:20.127]                             next
[08:26:20.127]                           if (!grepl(pattern, name)) 
[08:26:20.127]                             next
[08:26:20.127]                           invokeRestart(restart)
[08:26:20.127]                           muffled <- TRUE
[08:26:20.127]                           break
[08:26:20.127]                         }
[08:26:20.127]                       }
[08:26:20.127]                     }
[08:26:20.127]                     invisible(muffled)
[08:26:20.127]                   }
[08:26:20.127]                   muffleCondition(cond)
[08:26:20.127]                 })
[08:26:20.127]             }))
[08:26:20.127]             future::FutureResult(value = ...future.value$value, 
[08:26:20.127]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.127]                   ...future.rng), globalenv = if (FALSE) 
[08:26:20.127]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:20.127]                     ...future.globalenv.names))
[08:26:20.127]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:20.127]         }, condition = base::local({
[08:26:20.127]             c <- base::c
[08:26:20.127]             inherits <- base::inherits
[08:26:20.127]             invokeRestart <- base::invokeRestart
[08:26:20.127]             length <- base::length
[08:26:20.127]             list <- base::list
[08:26:20.127]             seq.int <- base::seq.int
[08:26:20.127]             signalCondition <- base::signalCondition
[08:26:20.127]             sys.calls <- base::sys.calls
[08:26:20.127]             `[[` <- base::`[[`
[08:26:20.127]             `+` <- base::`+`
[08:26:20.127]             `<<-` <- base::`<<-`
[08:26:20.127]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:20.127]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:20.127]                   3L)]
[08:26:20.127]             }
[08:26:20.127]             function(cond) {
[08:26:20.127]                 is_error <- inherits(cond, "error")
[08:26:20.127]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:20.127]                   NULL)
[08:26:20.127]                 if (is_error) {
[08:26:20.127]                   sessionInformation <- function() {
[08:26:20.127]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:20.127]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:20.127]                       search = base::search(), system = base::Sys.info())
[08:26:20.127]                   }
[08:26:20.127]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.127]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:20.127]                     cond$call), session = sessionInformation(), 
[08:26:20.127]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:20.127]                   signalCondition(cond)
[08:26:20.127]                 }
[08:26:20.127]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:20.127]                 "immediateCondition"))) {
[08:26:20.127]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:20.127]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.127]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:20.127]                   if (TRUE && !signal) {
[08:26:20.127]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.127]                     {
[08:26:20.127]                       inherits <- base::inherits
[08:26:20.127]                       invokeRestart <- base::invokeRestart
[08:26:20.127]                       is.null <- base::is.null
[08:26:20.127]                       muffled <- FALSE
[08:26:20.127]                       if (inherits(cond, "message")) {
[08:26:20.127]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.127]                         if (muffled) 
[08:26:20.127]                           invokeRestart("muffleMessage")
[08:26:20.127]                       }
[08:26:20.127]                       else if (inherits(cond, "warning")) {
[08:26:20.127]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.127]                         if (muffled) 
[08:26:20.127]                           invokeRestart("muffleWarning")
[08:26:20.127]                       }
[08:26:20.127]                       else if (inherits(cond, "condition")) {
[08:26:20.127]                         if (!is.null(pattern)) {
[08:26:20.127]                           computeRestarts <- base::computeRestarts
[08:26:20.127]                           grepl <- base::grepl
[08:26:20.127]                           restarts <- computeRestarts(cond)
[08:26:20.127]                           for (restart in restarts) {
[08:26:20.127]                             name <- restart$name
[08:26:20.127]                             if (is.null(name)) 
[08:26:20.127]                               next
[08:26:20.127]                             if (!grepl(pattern, name)) 
[08:26:20.127]                               next
[08:26:20.127]                             invokeRestart(restart)
[08:26:20.127]                             muffled <- TRUE
[08:26:20.127]                             break
[08:26:20.127]                           }
[08:26:20.127]                         }
[08:26:20.127]                       }
[08:26:20.127]                       invisible(muffled)
[08:26:20.127]                     }
[08:26:20.127]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.127]                   }
[08:26:20.127]                 }
[08:26:20.127]                 else {
[08:26:20.127]                   if (TRUE) {
[08:26:20.127]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.127]                     {
[08:26:20.127]                       inherits <- base::inherits
[08:26:20.127]                       invokeRestart <- base::invokeRestart
[08:26:20.127]                       is.null <- base::is.null
[08:26:20.127]                       muffled <- FALSE
[08:26:20.127]                       if (inherits(cond, "message")) {
[08:26:20.127]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.127]                         if (muffled) 
[08:26:20.127]                           invokeRestart("muffleMessage")
[08:26:20.127]                       }
[08:26:20.127]                       else if (inherits(cond, "warning")) {
[08:26:20.127]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.127]                         if (muffled) 
[08:26:20.127]                           invokeRestart("muffleWarning")
[08:26:20.127]                       }
[08:26:20.127]                       else if (inherits(cond, "condition")) {
[08:26:20.127]                         if (!is.null(pattern)) {
[08:26:20.127]                           computeRestarts <- base::computeRestarts
[08:26:20.127]                           grepl <- base::grepl
[08:26:20.127]                           restarts <- computeRestarts(cond)
[08:26:20.127]                           for (restart in restarts) {
[08:26:20.127]                             name <- restart$name
[08:26:20.127]                             if (is.null(name)) 
[08:26:20.127]                               next
[08:26:20.127]                             if (!grepl(pattern, name)) 
[08:26:20.127]                               next
[08:26:20.127]                             invokeRestart(restart)
[08:26:20.127]                             muffled <- TRUE
[08:26:20.127]                             break
[08:26:20.127]                           }
[08:26:20.127]                         }
[08:26:20.127]                       }
[08:26:20.127]                       invisible(muffled)
[08:26:20.127]                     }
[08:26:20.127]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.127]                   }
[08:26:20.127]                 }
[08:26:20.127]             }
[08:26:20.127]         }))
[08:26:20.127]     }, error = function(ex) {
[08:26:20.127]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:20.127]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.127]                 ...future.rng), started = ...future.startTime, 
[08:26:20.127]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:20.127]             version = "1.8"), class = "FutureResult")
[08:26:20.127]     }, finally = {
[08:26:20.127]         if (!identical(...future.workdir, getwd())) 
[08:26:20.127]             setwd(...future.workdir)
[08:26:20.127]         {
[08:26:20.127]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:20.127]                 ...future.oldOptions$nwarnings <- NULL
[08:26:20.127]             }
[08:26:20.127]             base::options(...future.oldOptions)
[08:26:20.127]             if (.Platform$OS.type == "windows") {
[08:26:20.127]                 old_names <- names(...future.oldEnvVars)
[08:26:20.127]                 envs <- base::Sys.getenv()
[08:26:20.127]                 names <- names(envs)
[08:26:20.127]                 common <- intersect(names, old_names)
[08:26:20.127]                 added <- setdiff(names, old_names)
[08:26:20.127]                 removed <- setdiff(old_names, names)
[08:26:20.127]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:20.127]                   envs[common]]
[08:26:20.127]                 NAMES <- toupper(changed)
[08:26:20.127]                 args <- list()
[08:26:20.127]                 for (kk in seq_along(NAMES)) {
[08:26:20.127]                   name <- changed[[kk]]
[08:26:20.127]                   NAME <- NAMES[[kk]]
[08:26:20.127]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.127]                     next
[08:26:20.127]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.127]                 }
[08:26:20.127]                 NAMES <- toupper(added)
[08:26:20.127]                 for (kk in seq_along(NAMES)) {
[08:26:20.127]                   name <- added[[kk]]
[08:26:20.127]                   NAME <- NAMES[[kk]]
[08:26:20.127]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.127]                     next
[08:26:20.127]                   args[[name]] <- ""
[08:26:20.127]                 }
[08:26:20.127]                 NAMES <- toupper(removed)
[08:26:20.127]                 for (kk in seq_along(NAMES)) {
[08:26:20.127]                   name <- removed[[kk]]
[08:26:20.127]                   NAME <- NAMES[[kk]]
[08:26:20.127]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.127]                     next
[08:26:20.127]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.127]                 }
[08:26:20.127]                 if (length(args) > 0) 
[08:26:20.127]                   base::do.call(base::Sys.setenv, args = args)
[08:26:20.127]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:20.127]             }
[08:26:20.127]             else {
[08:26:20.127]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:20.127]             }
[08:26:20.127]             {
[08:26:20.127]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:20.127]                   0L) {
[08:26:20.127]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:20.127]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:20.127]                   base::options(opts)
[08:26:20.127]                 }
[08:26:20.127]                 {
[08:26:20.127]                   {
[08:26:20.127]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:20.127]                     NULL
[08:26:20.127]                   }
[08:26:20.127]                   options(future.plan = NULL)
[08:26:20.127]                   if (is.na(NA_character_)) 
[08:26:20.127]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.127]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:20.127]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:20.127]                     .init = FALSE)
[08:26:20.127]                 }
[08:26:20.127]             }
[08:26:20.127]         }
[08:26:20.127]     })
[08:26:20.127]     if (TRUE) {
[08:26:20.127]         base::sink(type = "output", split = FALSE)
[08:26:20.127]         if (TRUE) {
[08:26:20.127]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:20.127]         }
[08:26:20.127]         else {
[08:26:20.127]             ...future.result["stdout"] <- base::list(NULL)
[08:26:20.127]         }
[08:26:20.127]         base::close(...future.stdout)
[08:26:20.127]         ...future.stdout <- NULL
[08:26:20.127]     }
[08:26:20.127]     ...future.result$conditions <- ...future.conditions
[08:26:20.127]     ...future.result$finished <- base::Sys.time()
[08:26:20.127]     ...future.result
[08:26:20.127] }
[08:26:20.130] assign_globals() ...
[08:26:20.130] List of 11
[08:26:20.130]  $ ...future.FUN            :function (x, ...)  
[08:26:20.130]  $ x_FUN                    :function (x)  
[08:26:20.130]  $ times                    : int 1
[08:26:20.130]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:20.130]  $ stop_if_not              :function (...)  
[08:26:20.130]  $ dim                      : NULL
[08:26:20.130]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:20.130]  $ future.call.arguments    : list()
[08:26:20.130]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.130]  $ ...future.elements_ii    :List of 5
[08:26:20.130]   ..$ : int 6
[08:26:20.130]   ..$ : int 7
[08:26:20.130]   ..$ : int 8
[08:26:20.130]   ..$ : int 9
[08:26:20.130]   ..$ : int 10
[08:26:20.130]  $ ...future.seeds_ii       : NULL
[08:26:20.130]  $ ...future.globals.maxSize: NULL
[08:26:20.130]  - attr(*, "where")=List of 11
[08:26:20.130]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:20.130]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:20.130]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:20.130]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:20.130]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:20.130]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:20.130]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:20.130]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:20.130]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:20.130]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:20.130]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:20.130]  - attr(*, "resolved")= logi FALSE
[08:26:20.130]  - attr(*, "total_size")= num 22322
[08:26:20.130]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.130]  - attr(*, "already-done")= logi TRUE
[08:26:20.142] - copied ‘...future.FUN’ to environment
[08:26:20.142] - copied ‘x_FUN’ to environment
[08:26:20.142] - copied ‘times’ to environment
[08:26:20.142] - copied ‘stopf’ to environment
[08:26:20.142] - copied ‘stop_if_not’ to environment
[08:26:20.143] - copied ‘dim’ to environment
[08:26:20.143] - copied ‘valid_types’ to environment
[08:26:20.143] - copied ‘future.call.arguments’ to environment
[08:26:20.143] - copied ‘...future.elements_ii’ to environment
[08:26:20.143] - copied ‘...future.seeds_ii’ to environment
[08:26:20.143] - copied ‘...future.globals.maxSize’ to environment
[08:26:20.143] assign_globals() ... done
[08:26:20.143] requestCore(): workers = 2
[08:26:20.146] MulticoreFuture started
[08:26:20.146] - Launch lazy future ... done
[08:26:20.146] run() for ‘MulticoreFuture’ ... done
[08:26:20.147] Created future:
[08:26:20.147] plan(): Setting new future strategy stack:
[08:26:20.147] List of future strategies:
[08:26:20.147] 1. sequential:
[08:26:20.147]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:20.147]    - tweaked: FALSE
[08:26:20.147]    - call: NULL
[08:26:20.148] plan(): nbrOfWorkers() = 1
[08:26:20.151] plan(): Setting new future strategy stack:
[08:26:20.151] List of future strategies:
[08:26:20.151] 1. multicore:
[08:26:20.151]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:20.151]    - tweaked: FALSE
[08:26:20.151]    - call: plan(strategy)
[08:26:20.154] plan(): nbrOfWorkers() = 2
[08:26:20.147] MulticoreFuture:
[08:26:20.147] Label: ‘future_vapply-2’
[08:26:20.147] Expression:
[08:26:20.147] {
[08:26:20.147]     do.call(function(...) {
[08:26:20.147]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.147]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.147]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.147]             on.exit(options(oopts), add = TRUE)
[08:26:20.147]         }
[08:26:20.147]         {
[08:26:20.147]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.147]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.147]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.147]             })
[08:26:20.147]         }
[08:26:20.147]     }, args = future.call.arguments)
[08:26:20.147] }
[08:26:20.147] Lazy evaluation: FALSE
[08:26:20.147] Asynchronous evaluation: TRUE
[08:26:20.147] Local evaluation: TRUE
[08:26:20.147] Environment: R_GlobalEnv
[08:26:20.147] Capture standard output: TRUE
[08:26:20.147] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:20.147] Globals: 11 objects totaling 12.31 KiB (function ‘...future.FUN’ of 4.06 KiB, function ‘x_FUN’ of 35 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:20.147] Packages: 1 packages (‘future.apply’)
[08:26:20.147] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:20.147] Resolved: TRUE
[08:26:20.147] Value: <not collected>
[08:26:20.147] Conditions captured: <none>
[08:26:20.147] Early signaling: FALSE
[08:26:20.147] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:20.147] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.155] Chunk #2 of 2 ... DONE
[08:26:20.155] Launching 2 futures (chunks) ... DONE
[08:26:20.155] Resolving 2 futures (chunks) ...
[08:26:20.155] resolve() on list ...
[08:26:20.156]  recursive: 0
[08:26:20.156]  length: 2
[08:26:20.156] 
[08:26:20.156] Future #1
[08:26:20.156] result() for MulticoreFuture ...
[08:26:20.157] result() for MulticoreFuture ...
[08:26:20.157] result() for MulticoreFuture ... done
[08:26:20.158] result() for MulticoreFuture ... done
[08:26:20.158] result() for MulticoreFuture ...
[08:26:20.158] result() for MulticoreFuture ... done
[08:26:20.158] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:26:20.158] - nx: 2
[08:26:20.158] - relay: TRUE
[08:26:20.158] - stdout: TRUE
[08:26:20.159] - signal: TRUE
[08:26:20.159] - resignal: FALSE
[08:26:20.159] - force: TRUE
[08:26:20.159] - relayed: [n=2] FALSE, FALSE
[08:26:20.159] - queued futures: [n=2] FALSE, FALSE
[08:26:20.159]  - until=1
[08:26:20.159]  - relaying element #1
[08:26:20.160] result() for MulticoreFuture ...
[08:26:20.160] result() for MulticoreFuture ... done
[08:26:20.163] result() for MulticoreFuture ...
[08:26:20.164] result() for MulticoreFuture ... done
[08:26:20.164] result() for MulticoreFuture ...
[08:26:20.165] result() for MulticoreFuture ... done
[08:26:20.165] result() for MulticoreFuture ...
[08:26:20.165] result() for MulticoreFuture ... done
[08:26:20.166] - relayed: [n=2] TRUE, FALSE
[08:26:20.166] - queued futures: [n=2] TRUE, FALSE
[08:26:20.166] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:26:20.167]  length: 1 (resolved future 1)
[08:26:20.167] Future #2
[08:26:20.168] result() for MulticoreFuture ...
[08:26:20.169] result() for MulticoreFuture ...
[08:26:20.169] result() for MulticoreFuture ... done
[08:26:20.169] result() for MulticoreFuture ... done
[08:26:20.170] result() for MulticoreFuture ...
[08:26:20.170] result() for MulticoreFuture ... done
[08:26:20.170] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:26:20.170] - nx: 2
[08:26:20.171] - relay: TRUE
[08:26:20.171] - stdout: TRUE
[08:26:20.171] - signal: TRUE
[08:26:20.171] - resignal: FALSE
[08:26:20.171] - force: TRUE
[08:26:20.171] - relayed: [n=2] TRUE, FALSE
[08:26:20.172] - queued futures: [n=2] TRUE, FALSE
[08:26:20.172]  - until=2
[08:26:20.172]  - relaying element #2
[08:26:20.172] result() for MulticoreFuture ...
[08:26:20.172] result() for MulticoreFuture ... done
[08:26:20.172] result() for MulticoreFuture ...
[08:26:20.173] result() for MulticoreFuture ... done
[08:26:20.173] result() for MulticoreFuture ...
[08:26:20.173] result() for MulticoreFuture ... done
[08:26:20.173] result() for MulticoreFuture ...
[08:26:20.173] result() for MulticoreFuture ... done
[08:26:20.173] - relayed: [n=2] TRUE, TRUE
[08:26:20.173] - queued futures: [n=2] TRUE, TRUE
[08:26:20.173] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:26:20.174]  length: 0 (resolved future 2)
[08:26:20.174] Relaying remaining futures
[08:26:20.174] signalConditionsASAP(NULL, pos=0) ...
[08:26:20.174] - nx: 2
[08:26:20.174] - relay: TRUE
[08:26:20.174] - stdout: TRUE
[08:26:20.174] - signal: TRUE
[08:26:20.174] - resignal: FALSE
[08:26:20.174] - force: TRUE
[08:26:20.174] - relayed: [n=2] TRUE, TRUE
[08:26:20.175] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:20.175] - relayed: [n=2] TRUE, TRUE
[08:26:20.175] - queued futures: [n=2] TRUE, TRUE
[08:26:20.175] signalConditionsASAP(NULL, pos=0) ... done
[08:26:20.175] resolve() on list ... DONE
[08:26:20.175] result() for MulticoreFuture ...
[08:26:20.175] result() for MulticoreFuture ... done
[08:26:20.175] result() for MulticoreFuture ...
[08:26:20.176] result() for MulticoreFuture ... done
[08:26:20.176] result() for MulticoreFuture ...
[08:26:20.176] result() for MulticoreFuture ... done
[08:26:20.176] result() for MulticoreFuture ...
[08:26:20.176] result() for MulticoreFuture ... done
[08:26:20.176]  - Number of value chunks collected: 2
[08:26:20.176] Resolving 2 futures (chunks) ... DONE
[08:26:20.176] Reducing values from 2 chunks ...
[08:26:20.177]  - Number of values collected after concatenation: 10
[08:26:20.177]  - Number of values expected: 10
[08:26:20.177] Reducing values from 2 chunks ... DONE
[08:26:20.177] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[08:26:20.178] future_lapply() ...
[08:26:20.182] Number of chunks: 2
[08:26:20.182] getGlobalsAndPackagesXApply() ...
[08:26:20.182]  - future.globals: TRUE
[08:26:20.182] getGlobalsAndPackages() ...
[08:26:20.182] Searching for globals...
[08:26:20.187] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[08:26:20.187] Searching for globals ... DONE
[08:26:20.187] Resolving globals: FALSE
[08:26:20.188] The total size of the 7 globals is 13.34 KiB (13657 bytes)
[08:26:20.188] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.89 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:20.188] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:20.188] - packages: [1] ‘future.apply’
[08:26:20.189] getGlobalsAndPackages() ... DONE
[08:26:20.189]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:20.189]  - needed namespaces: [n=1] ‘future.apply’
[08:26:20.189] Finding globals ... DONE
[08:26:20.189]  - use_args: TRUE
[08:26:20.189]  - Getting '...' globals ...
[08:26:20.189] resolve() on list ...
[08:26:20.189]  recursive: 0
[08:26:20.190]  length: 1
[08:26:20.190]  elements: ‘...’
[08:26:20.190]  length: 0 (resolved future 1)
[08:26:20.190] resolve() on list ... DONE
[08:26:20.190]    - '...' content: [n=0] 
[08:26:20.190] List of 1
[08:26:20.190]  $ ...: list()
[08:26:20.190]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.190]  - attr(*, "where")=List of 1
[08:26:20.190]   ..$ ...:<environment: 0x562ca5745170> 
[08:26:20.190]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.190]  - attr(*, "resolved")= logi TRUE
[08:26:20.190]  - attr(*, "total_size")= num NA
[08:26:20.195]  - Getting '...' globals ... DONE
[08:26:20.195] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:20.195] List of 8
[08:26:20.195]  $ ...future.FUN:function (x, ...)  
[08:26:20.195]  $ x_FUN        :function (x)  
[08:26:20.195]  $ times        : int 2
[08:26:20.195]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:20.195]  $ stop_if_not  :function (...)  
[08:26:20.195]  $ dim          : NULL
[08:26:20.195]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:20.195]  $ ...          : list()
[08:26:20.195]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.195]  - attr(*, "where")=List of 8
[08:26:20.195]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:20.195]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:20.195]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:20.195]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:20.195]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:20.195]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:20.195]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:20.195]   ..$ ...          :<environment: 0x562ca5745170> 
[08:26:20.195]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.195]  - attr(*, "resolved")= logi FALSE
[08:26:20.195]  - attr(*, "total_size")= num 24454
[08:26:20.201] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:20.201] getGlobalsAndPackagesXApply() ... DONE
[08:26:20.202] Number of futures (= number of chunks): 2
[08:26:20.202] Launching 2 futures (chunks) ...
[08:26:20.202] Chunk #1 of 2 ...
[08:26:20.202]  - Finding globals in 'X' for chunk #1 ...
[08:26:20.202] getGlobalsAndPackages() ...
[08:26:20.202] Searching for globals...
[08:26:20.202] 
[08:26:20.202] Searching for globals ... DONE
[08:26:20.203] - globals: [0] <none>
[08:26:20.203] getGlobalsAndPackages() ... DONE
[08:26:20.203]    + additional globals found: [n=0] 
[08:26:20.203]    + additional namespaces needed: [n=0] 
[08:26:20.203]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:20.203]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:20.203]  - seeds: <none>
[08:26:20.203]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.203] getGlobalsAndPackages() ...
[08:26:20.203] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.204] Resolving globals: FALSE
[08:26:20.204] Tweak future expression to call with '...' arguments ...
[08:26:20.204] {
[08:26:20.204]     do.call(function(...) {
[08:26:20.204]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.204]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.204]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.204]             on.exit(options(oopts), add = TRUE)
[08:26:20.204]         }
[08:26:20.204]         {
[08:26:20.204]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.204]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.204]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.204]             })
[08:26:20.204]         }
[08:26:20.204]     }, args = future.call.arguments)
[08:26:20.204] }
[08:26:20.204] Tweak future expression to call with '...' arguments ... DONE
[08:26:20.205] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.205] - packages: [1] ‘future.apply’
[08:26:20.205] getGlobalsAndPackages() ... DONE
[08:26:20.205] run() for ‘Future’ ...
[08:26:20.205] - state: ‘created’
[08:26:20.205] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:20.207] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.207] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:20.207]   - Field: ‘label’
[08:26:20.208]   - Field: ‘local’
[08:26:20.208]   - Field: ‘owner’
[08:26:20.208]   - Field: ‘envir’
[08:26:20.208]   - Field: ‘workers’
[08:26:20.208]   - Field: ‘packages’
[08:26:20.208]   - Field: ‘gc’
[08:26:20.208]   - Field: ‘job’
[08:26:20.208]   - Field: ‘conditions’
[08:26:20.208]   - Field: ‘expr’
[08:26:20.208]   - Field: ‘uuid’
[08:26:20.208]   - Field: ‘seed’
[08:26:20.209]   - Field: ‘version’
[08:26:20.209]   - Field: ‘result’
[08:26:20.209]   - Field: ‘asynchronous’
[08:26:20.209]   - Field: ‘calls’
[08:26:20.209]   - Field: ‘globals’
[08:26:20.209]   - Field: ‘stdout’
[08:26:20.209]   - Field: ‘earlySignal’
[08:26:20.209]   - Field: ‘lazy’
[08:26:20.209]   - Field: ‘state’
[08:26:20.209] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:20.209] - Launch lazy future ...
[08:26:20.210] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:20.210] Packages needed by future strategies (n = 0): <none>
[08:26:20.210] {
[08:26:20.210]     {
[08:26:20.210]         {
[08:26:20.210]             ...future.startTime <- base::Sys.time()
[08:26:20.210]             {
[08:26:20.210]                 {
[08:26:20.210]                   {
[08:26:20.210]                     {
[08:26:20.210]                       {
[08:26:20.210]                         base::local({
[08:26:20.210]                           has_future <- base::requireNamespace("future", 
[08:26:20.210]                             quietly = TRUE)
[08:26:20.210]                           if (has_future) {
[08:26:20.210]                             ns <- base::getNamespace("future")
[08:26:20.210]                             version <- ns[[".package"]][["version"]]
[08:26:20.210]                             if (is.null(version)) 
[08:26:20.210]                               version <- utils::packageVersion("future")
[08:26:20.210]                           }
[08:26:20.210]                           else {
[08:26:20.210]                             version <- NULL
[08:26:20.210]                           }
[08:26:20.210]                           if (!has_future || version < "1.8.0") {
[08:26:20.210]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:20.210]                               "", base::R.version$version.string), 
[08:26:20.210]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:20.210]                                 base::R.version$platform, 8 * 
[08:26:20.210]                                   base::.Machine$sizeof.pointer), 
[08:26:20.210]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:20.210]                                 "release", "version")], collapse = " "), 
[08:26:20.210]                               hostname = base::Sys.info()[["nodename"]])
[08:26:20.210]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:20.210]                               info)
[08:26:20.210]                             info <- base::paste(info, collapse = "; ")
[08:26:20.210]                             if (!has_future) {
[08:26:20.210]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:20.210]                                 info)
[08:26:20.210]                             }
[08:26:20.210]                             else {
[08:26:20.210]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:20.210]                                 info, version)
[08:26:20.210]                             }
[08:26:20.210]                             base::stop(msg)
[08:26:20.210]                           }
[08:26:20.210]                         })
[08:26:20.210]                       }
[08:26:20.210]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:20.210]                       base::options(mc.cores = 1L)
[08:26:20.210]                     }
[08:26:20.210]                     base::local({
[08:26:20.210]                       for (pkg in "future.apply") {
[08:26:20.210]                         base::loadNamespace(pkg)
[08:26:20.210]                         base::library(pkg, character.only = TRUE)
[08:26:20.210]                       }
[08:26:20.210]                     })
[08:26:20.210]                   }
[08:26:20.210]                   ...future.strategy.old <- future::plan("list")
[08:26:20.210]                   options(future.plan = NULL)
[08:26:20.210]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.210]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:20.210]                 }
[08:26:20.210]                 ...future.workdir <- getwd()
[08:26:20.210]             }
[08:26:20.210]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:20.210]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:20.210]         }
[08:26:20.210]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:20.210]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:20.210]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:20.210]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:20.210]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:20.210]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:20.210]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:20.210]             base::names(...future.oldOptions))
[08:26:20.210]     }
[08:26:20.210]     if (FALSE) {
[08:26:20.210]     }
[08:26:20.210]     else {
[08:26:20.210]         if (TRUE) {
[08:26:20.210]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:20.210]                 open = "w")
[08:26:20.210]         }
[08:26:20.210]         else {
[08:26:20.210]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:20.210]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:20.210]         }
[08:26:20.210]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:20.210]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:20.210]             base::sink(type = "output", split = FALSE)
[08:26:20.210]             base::close(...future.stdout)
[08:26:20.210]         }, add = TRUE)
[08:26:20.210]     }
[08:26:20.210]     ...future.frame <- base::sys.nframe()
[08:26:20.210]     ...future.conditions <- base::list()
[08:26:20.210]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:20.210]     if (FALSE) {
[08:26:20.210]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:20.210]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:20.210]     }
[08:26:20.210]     ...future.result <- base::tryCatch({
[08:26:20.210]         base::withCallingHandlers({
[08:26:20.210]             ...future.value <- base::withVisible(base::local({
[08:26:20.210]                 withCallingHandlers({
[08:26:20.210]                   {
[08:26:20.210]                     do.call(function(...) {
[08:26:20.210]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.210]                       if (!identical(...future.globals.maxSize.org, 
[08:26:20.210]                         ...future.globals.maxSize)) {
[08:26:20.210]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.210]                         on.exit(options(oopts), add = TRUE)
[08:26:20.210]                       }
[08:26:20.210]                       {
[08:26:20.210]                         lapply(seq_along(...future.elements_ii), 
[08:26:20.210]                           FUN = function(jj) {
[08:26:20.210]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.210]                             ...future.FUN(...future.X_jj, ...)
[08:26:20.210]                           })
[08:26:20.210]                       }
[08:26:20.210]                     }, args = future.call.arguments)
[08:26:20.210]                   }
[08:26:20.210]                 }, immediateCondition = function(cond) {
[08:26:20.210]                   save_rds <- function (object, pathname, ...) 
[08:26:20.210]                   {
[08:26:20.210]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:20.210]                     if (file_test("-f", pathname_tmp)) {
[08:26:20.210]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.210]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:20.210]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.210]                         fi_tmp[["mtime"]])
[08:26:20.210]                     }
[08:26:20.210]                     tryCatch({
[08:26:20.210]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:20.210]                     }, error = function(ex) {
[08:26:20.210]                       msg <- conditionMessage(ex)
[08:26:20.210]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.210]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:20.210]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.210]                         fi_tmp[["mtime"]], msg)
[08:26:20.210]                       ex$message <- msg
[08:26:20.210]                       stop(ex)
[08:26:20.210]                     })
[08:26:20.210]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:20.210]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:20.210]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:20.210]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.210]                       fi <- file.info(pathname)
[08:26:20.210]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:20.210]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.210]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:20.210]                         fi[["size"]], fi[["mtime"]])
[08:26:20.210]                       stop(msg)
[08:26:20.210]                     }
[08:26:20.210]                     invisible(pathname)
[08:26:20.210]                   }
[08:26:20.210]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:20.210]                     rootPath = tempdir()) 
[08:26:20.210]                   {
[08:26:20.210]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:20.210]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:20.210]                       tmpdir = path, fileext = ".rds")
[08:26:20.210]                     save_rds(obj, file)
[08:26:20.210]                   }
[08:26:20.210]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:20.210]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.210]                   {
[08:26:20.210]                     inherits <- base::inherits
[08:26:20.210]                     invokeRestart <- base::invokeRestart
[08:26:20.210]                     is.null <- base::is.null
[08:26:20.210]                     muffled <- FALSE
[08:26:20.210]                     if (inherits(cond, "message")) {
[08:26:20.210]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:20.210]                       if (muffled) 
[08:26:20.210]                         invokeRestart("muffleMessage")
[08:26:20.210]                     }
[08:26:20.210]                     else if (inherits(cond, "warning")) {
[08:26:20.210]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:20.210]                       if (muffled) 
[08:26:20.210]                         invokeRestart("muffleWarning")
[08:26:20.210]                     }
[08:26:20.210]                     else if (inherits(cond, "condition")) {
[08:26:20.210]                       if (!is.null(pattern)) {
[08:26:20.210]                         computeRestarts <- base::computeRestarts
[08:26:20.210]                         grepl <- base::grepl
[08:26:20.210]                         restarts <- computeRestarts(cond)
[08:26:20.210]                         for (restart in restarts) {
[08:26:20.210]                           name <- restart$name
[08:26:20.210]                           if (is.null(name)) 
[08:26:20.210]                             next
[08:26:20.210]                           if (!grepl(pattern, name)) 
[08:26:20.210]                             next
[08:26:20.210]                           invokeRestart(restart)
[08:26:20.210]                           muffled <- TRUE
[08:26:20.210]                           break
[08:26:20.210]                         }
[08:26:20.210]                       }
[08:26:20.210]                     }
[08:26:20.210]                     invisible(muffled)
[08:26:20.210]                   }
[08:26:20.210]                   muffleCondition(cond)
[08:26:20.210]                 })
[08:26:20.210]             }))
[08:26:20.210]             future::FutureResult(value = ...future.value$value, 
[08:26:20.210]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.210]                   ...future.rng), globalenv = if (FALSE) 
[08:26:20.210]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:20.210]                     ...future.globalenv.names))
[08:26:20.210]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:20.210]         }, condition = base::local({
[08:26:20.210]             c <- base::c
[08:26:20.210]             inherits <- base::inherits
[08:26:20.210]             invokeRestart <- base::invokeRestart
[08:26:20.210]             length <- base::length
[08:26:20.210]             list <- base::list
[08:26:20.210]             seq.int <- base::seq.int
[08:26:20.210]             signalCondition <- base::signalCondition
[08:26:20.210]             sys.calls <- base::sys.calls
[08:26:20.210]             `[[` <- base::`[[`
[08:26:20.210]             `+` <- base::`+`
[08:26:20.210]             `<<-` <- base::`<<-`
[08:26:20.210]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:20.210]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:20.210]                   3L)]
[08:26:20.210]             }
[08:26:20.210]             function(cond) {
[08:26:20.210]                 is_error <- inherits(cond, "error")
[08:26:20.210]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:20.210]                   NULL)
[08:26:20.210]                 if (is_error) {
[08:26:20.210]                   sessionInformation <- function() {
[08:26:20.210]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:20.210]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:20.210]                       search = base::search(), system = base::Sys.info())
[08:26:20.210]                   }
[08:26:20.210]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.210]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:20.210]                     cond$call), session = sessionInformation(), 
[08:26:20.210]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:20.210]                   signalCondition(cond)
[08:26:20.210]                 }
[08:26:20.210]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:20.210]                 "immediateCondition"))) {
[08:26:20.210]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:20.210]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.210]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:20.210]                   if (TRUE && !signal) {
[08:26:20.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.210]                     {
[08:26:20.210]                       inherits <- base::inherits
[08:26:20.210]                       invokeRestart <- base::invokeRestart
[08:26:20.210]                       is.null <- base::is.null
[08:26:20.210]                       muffled <- FALSE
[08:26:20.210]                       if (inherits(cond, "message")) {
[08:26:20.210]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.210]                         if (muffled) 
[08:26:20.210]                           invokeRestart("muffleMessage")
[08:26:20.210]                       }
[08:26:20.210]                       else if (inherits(cond, "warning")) {
[08:26:20.210]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.210]                         if (muffled) 
[08:26:20.210]                           invokeRestart("muffleWarning")
[08:26:20.210]                       }
[08:26:20.210]                       else if (inherits(cond, "condition")) {
[08:26:20.210]                         if (!is.null(pattern)) {
[08:26:20.210]                           computeRestarts <- base::computeRestarts
[08:26:20.210]                           grepl <- base::grepl
[08:26:20.210]                           restarts <- computeRestarts(cond)
[08:26:20.210]                           for (restart in restarts) {
[08:26:20.210]                             name <- restart$name
[08:26:20.210]                             if (is.null(name)) 
[08:26:20.210]                               next
[08:26:20.210]                             if (!grepl(pattern, name)) 
[08:26:20.210]                               next
[08:26:20.210]                             invokeRestart(restart)
[08:26:20.210]                             muffled <- TRUE
[08:26:20.210]                             break
[08:26:20.210]                           }
[08:26:20.210]                         }
[08:26:20.210]                       }
[08:26:20.210]                       invisible(muffled)
[08:26:20.210]                     }
[08:26:20.210]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.210]                   }
[08:26:20.210]                 }
[08:26:20.210]                 else {
[08:26:20.210]                   if (TRUE) {
[08:26:20.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.210]                     {
[08:26:20.210]                       inherits <- base::inherits
[08:26:20.210]                       invokeRestart <- base::invokeRestart
[08:26:20.210]                       is.null <- base::is.null
[08:26:20.210]                       muffled <- FALSE
[08:26:20.210]                       if (inherits(cond, "message")) {
[08:26:20.210]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.210]                         if (muffled) 
[08:26:20.210]                           invokeRestart("muffleMessage")
[08:26:20.210]                       }
[08:26:20.210]                       else if (inherits(cond, "warning")) {
[08:26:20.210]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.210]                         if (muffled) 
[08:26:20.210]                           invokeRestart("muffleWarning")
[08:26:20.210]                       }
[08:26:20.210]                       else if (inherits(cond, "condition")) {
[08:26:20.210]                         if (!is.null(pattern)) {
[08:26:20.210]                           computeRestarts <- base::computeRestarts
[08:26:20.210]                           grepl <- base::grepl
[08:26:20.210]                           restarts <- computeRestarts(cond)
[08:26:20.210]                           for (restart in restarts) {
[08:26:20.210]                             name <- restart$name
[08:26:20.210]                             if (is.null(name)) 
[08:26:20.210]                               next
[08:26:20.210]                             if (!grepl(pattern, name)) 
[08:26:20.210]                               next
[08:26:20.210]                             invokeRestart(restart)
[08:26:20.210]                             muffled <- TRUE
[08:26:20.210]                             break
[08:26:20.210]                           }
[08:26:20.210]                         }
[08:26:20.210]                       }
[08:26:20.210]                       invisible(muffled)
[08:26:20.210]                     }
[08:26:20.210]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.210]                   }
[08:26:20.210]                 }
[08:26:20.210]             }
[08:26:20.210]         }))
[08:26:20.210]     }, error = function(ex) {
[08:26:20.210]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:20.210]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.210]                 ...future.rng), started = ...future.startTime, 
[08:26:20.210]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:20.210]             version = "1.8"), class = "FutureResult")
[08:26:20.210]     }, finally = {
[08:26:20.210]         if (!identical(...future.workdir, getwd())) 
[08:26:20.210]             setwd(...future.workdir)
[08:26:20.210]         {
[08:26:20.210]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:20.210]                 ...future.oldOptions$nwarnings <- NULL
[08:26:20.210]             }
[08:26:20.210]             base::options(...future.oldOptions)
[08:26:20.210]             if (.Platform$OS.type == "windows") {
[08:26:20.210]                 old_names <- names(...future.oldEnvVars)
[08:26:20.210]                 envs <- base::Sys.getenv()
[08:26:20.210]                 names <- names(envs)
[08:26:20.210]                 common <- intersect(names, old_names)
[08:26:20.210]                 added <- setdiff(names, old_names)
[08:26:20.210]                 removed <- setdiff(old_names, names)
[08:26:20.210]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:20.210]                   envs[common]]
[08:26:20.210]                 NAMES <- toupper(changed)
[08:26:20.210]                 args <- list()
[08:26:20.210]                 for (kk in seq_along(NAMES)) {
[08:26:20.210]                   name <- changed[[kk]]
[08:26:20.210]                   NAME <- NAMES[[kk]]
[08:26:20.210]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.210]                     next
[08:26:20.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.210]                 }
[08:26:20.210]                 NAMES <- toupper(added)
[08:26:20.210]                 for (kk in seq_along(NAMES)) {
[08:26:20.210]                   name <- added[[kk]]
[08:26:20.210]                   NAME <- NAMES[[kk]]
[08:26:20.210]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.210]                     next
[08:26:20.210]                   args[[name]] <- ""
[08:26:20.210]                 }
[08:26:20.210]                 NAMES <- toupper(removed)
[08:26:20.210]                 for (kk in seq_along(NAMES)) {
[08:26:20.210]                   name <- removed[[kk]]
[08:26:20.210]                   NAME <- NAMES[[kk]]
[08:26:20.210]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.210]                     next
[08:26:20.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.210]                 }
[08:26:20.210]                 if (length(args) > 0) 
[08:26:20.210]                   base::do.call(base::Sys.setenv, args = args)
[08:26:20.210]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:20.210]             }
[08:26:20.210]             else {
[08:26:20.210]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:20.210]             }
[08:26:20.210]             {
[08:26:20.210]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:20.210]                   0L) {
[08:26:20.210]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:20.210]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:20.210]                   base::options(opts)
[08:26:20.210]                 }
[08:26:20.210]                 {
[08:26:20.210]                   {
[08:26:20.210]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:20.210]                     NULL
[08:26:20.210]                   }
[08:26:20.210]                   options(future.plan = NULL)
[08:26:20.210]                   if (is.na(NA_character_)) 
[08:26:20.210]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.210]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:20.210]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:20.210]                     .init = FALSE)
[08:26:20.210]                 }
[08:26:20.210]             }
[08:26:20.210]         }
[08:26:20.210]     })
[08:26:20.210]     if (TRUE) {
[08:26:20.210]         base::sink(type = "output", split = FALSE)
[08:26:20.210]         if (TRUE) {
[08:26:20.210]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:20.210]         }
[08:26:20.210]         else {
[08:26:20.210]             ...future.result["stdout"] <- base::list(NULL)
[08:26:20.210]         }
[08:26:20.210]         base::close(...future.stdout)
[08:26:20.210]         ...future.stdout <- NULL
[08:26:20.210]     }
[08:26:20.210]     ...future.result$conditions <- ...future.conditions
[08:26:20.210]     ...future.result$finished <- base::Sys.time()
[08:26:20.210]     ...future.result
[08:26:20.210] }
[08:26:20.213] assign_globals() ...
[08:26:20.213] List of 11
[08:26:20.213]  $ ...future.FUN            :function (x, ...)  
[08:26:20.213]  $ x_FUN                    :function (x)  
[08:26:20.213]  $ times                    : int 2
[08:26:20.213]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:20.213]  $ stop_if_not              :function (...)  
[08:26:20.213]  $ dim                      : NULL
[08:26:20.213]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:20.213]  $ future.call.arguments    : list()
[08:26:20.213]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.213]  $ ...future.elements_ii    :List of 5
[08:26:20.213]   ..$ : int 1
[08:26:20.213]   ..$ : int 2
[08:26:20.213]   ..$ : int 3
[08:26:20.213]   ..$ : int 4
[08:26:20.213]   ..$ : int 5
[08:26:20.213]  $ ...future.seeds_ii       : NULL
[08:26:20.213]  $ ...future.globals.maxSize: NULL
[08:26:20.213]  - attr(*, "where")=List of 11
[08:26:20.213]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:20.213]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:20.213]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:20.213]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:20.213]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:20.213]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:20.213]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:20.213]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:20.213]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:20.213]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:20.213]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:20.213]  - attr(*, "resolved")= logi FALSE
[08:26:20.213]  - attr(*, "total_size")= num 24454
[08:26:20.213]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.213]  - attr(*, "already-done")= logi TRUE
[08:26:20.224] - copied ‘...future.FUN’ to environment
[08:26:20.224] - reassign environment for ‘x_FUN’
[08:26:20.225] - copied ‘x_FUN’ to environment
[08:26:20.225] - copied ‘times’ to environment
[08:26:20.225] - copied ‘stopf’ to environment
[08:26:20.225] - copied ‘stop_if_not’ to environment
[08:26:20.225] - copied ‘dim’ to environment
[08:26:20.225] - copied ‘valid_types’ to environment
[08:26:20.225] - copied ‘future.call.arguments’ to environment
[08:26:20.225] - copied ‘...future.elements_ii’ to environment
[08:26:20.225] - copied ‘...future.seeds_ii’ to environment
[08:26:20.225] - copied ‘...future.globals.maxSize’ to environment
[08:26:20.225] assign_globals() ... done
[08:26:20.226] requestCore(): workers = 2
[08:26:20.228] MulticoreFuture started
[08:26:20.229] - Launch lazy future ... done
[08:26:20.229] run() for ‘MulticoreFuture’ ... done
[08:26:20.229] Created future:
[08:26:20.230] plan(): Setting new future strategy stack:
[08:26:20.230] List of future strategies:
[08:26:20.230] 1. sequential:
[08:26:20.230]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:20.230]    - tweaked: FALSE
[08:26:20.230]    - call: NULL
[08:26:20.231] plan(): nbrOfWorkers() = 1
[08:26:20.233] plan(): Setting new future strategy stack:
[08:26:20.233] List of future strategies:
[08:26:20.233] 1. multicore:
[08:26:20.233]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:20.233]    - tweaked: FALSE
[08:26:20.233]    - call: plan(strategy)
[08:26:20.236] plan(): nbrOfWorkers() = 2
[08:26:20.229] MulticoreFuture:
[08:26:20.229] Label: ‘future_vapply-1’
[08:26:20.229] Expression:
[08:26:20.229] {
[08:26:20.229]     do.call(function(...) {
[08:26:20.229]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.229]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.229]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.229]             on.exit(options(oopts), add = TRUE)
[08:26:20.229]         }
[08:26:20.229]         {
[08:26:20.229]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.229]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.229]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.229]             })
[08:26:20.229]         }
[08:26:20.229]     }, args = future.call.arguments)
[08:26:20.229] }
[08:26:20.229] Lazy evaluation: FALSE
[08:26:20.229] Asynchronous evaluation: TRUE
[08:26:20.229] Local evaluation: TRUE
[08:26:20.229] Environment: R_GlobalEnv
[08:26:20.229] Capture standard output: TRUE
[08:26:20.229] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:20.229] Globals: 11 objects totaling 13.57 KiB (function ‘...future.FUN’ of 4.88 KiB, function ‘x_FUN’ of 483 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:20.229] Packages: 1 packages (‘future.apply’)
[08:26:20.229] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:20.229] Resolved: TRUE
[08:26:20.229] Value: <not collected>
[08:26:20.229] Conditions captured: <none>
[08:26:20.229] Early signaling: FALSE
[08:26:20.229] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:20.229] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.238] Chunk #1 of 2 ... DONE
[08:26:20.238] Chunk #2 of 2 ...
[08:26:20.238]  - Finding globals in 'X' for chunk #2 ...
[08:26:20.238] getGlobalsAndPackages() ...
[08:26:20.238] Searching for globals...
[08:26:20.239] 
[08:26:20.239] Searching for globals ... DONE
[08:26:20.239] - globals: [0] <none>
[08:26:20.239] getGlobalsAndPackages() ... DONE
[08:26:20.239]    + additional globals found: [n=0] 
[08:26:20.239]    + additional namespaces needed: [n=0] 
[08:26:20.239]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:20.240]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:20.240]  - seeds: <none>
[08:26:20.240]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.240] getGlobalsAndPackages() ...
[08:26:20.240] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.240] Resolving globals: FALSE
[08:26:20.240] Tweak future expression to call with '...' arguments ...
[08:26:20.241] {
[08:26:20.241]     do.call(function(...) {
[08:26:20.241]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.241]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.241]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.241]             on.exit(options(oopts), add = TRUE)
[08:26:20.241]         }
[08:26:20.241]         {
[08:26:20.241]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.241]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.241]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.241]             })
[08:26:20.241]         }
[08:26:20.241]     }, args = future.call.arguments)
[08:26:20.241] }
[08:26:20.241] Tweak future expression to call with '...' arguments ... DONE
[08:26:20.242] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.242] - packages: [1] ‘future.apply’
[08:26:20.242] getGlobalsAndPackages() ... DONE
[08:26:20.243] run() for ‘Future’ ...
[08:26:20.243] - state: ‘created’
[08:26:20.243] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:20.246] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.246] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:20.247]   - Field: ‘label’
[08:26:20.247]   - Field: ‘local’
[08:26:20.247]   - Field: ‘owner’
[08:26:20.247]   - Field: ‘envir’
[08:26:20.247]   - Field: ‘workers’
[08:26:20.247]   - Field: ‘packages’
[08:26:20.247]   - Field: ‘gc’
[08:26:20.248]   - Field: ‘job’
[08:26:20.248]   - Field: ‘conditions’
[08:26:20.248]   - Field: ‘expr’
[08:26:20.248]   - Field: ‘uuid’
[08:26:20.248]   - Field: ‘seed’
[08:26:20.248]   - Field: ‘version’
[08:26:20.248]   - Field: ‘result’
[08:26:20.249]   - Field: ‘asynchronous’
[08:26:20.249]   - Field: ‘calls’
[08:26:20.249]   - Field: ‘globals’
[08:26:20.249]   - Field: ‘stdout’
[08:26:20.249]   - Field: ‘earlySignal’
[08:26:20.249]   - Field: ‘lazy’
[08:26:20.249]   - Field: ‘state’
[08:26:20.250] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:20.250] - Launch lazy future ...
[08:26:20.250] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:20.250] Packages needed by future strategies (n = 0): <none>
[08:26:20.251] {
[08:26:20.251]     {
[08:26:20.251]         {
[08:26:20.251]             ...future.startTime <- base::Sys.time()
[08:26:20.251]             {
[08:26:20.251]                 {
[08:26:20.251]                   {
[08:26:20.251]                     {
[08:26:20.251]                       {
[08:26:20.251]                         base::local({
[08:26:20.251]                           has_future <- base::requireNamespace("future", 
[08:26:20.251]                             quietly = TRUE)
[08:26:20.251]                           if (has_future) {
[08:26:20.251]                             ns <- base::getNamespace("future")
[08:26:20.251]                             version <- ns[[".package"]][["version"]]
[08:26:20.251]                             if (is.null(version)) 
[08:26:20.251]                               version <- utils::packageVersion("future")
[08:26:20.251]                           }
[08:26:20.251]                           else {
[08:26:20.251]                             version <- NULL
[08:26:20.251]                           }
[08:26:20.251]                           if (!has_future || version < "1.8.0") {
[08:26:20.251]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:20.251]                               "", base::R.version$version.string), 
[08:26:20.251]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:20.251]                                 base::R.version$platform, 8 * 
[08:26:20.251]                                   base::.Machine$sizeof.pointer), 
[08:26:20.251]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:20.251]                                 "release", "version")], collapse = " "), 
[08:26:20.251]                               hostname = base::Sys.info()[["nodename"]])
[08:26:20.251]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:20.251]                               info)
[08:26:20.251]                             info <- base::paste(info, collapse = "; ")
[08:26:20.251]                             if (!has_future) {
[08:26:20.251]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:20.251]                                 info)
[08:26:20.251]                             }
[08:26:20.251]                             else {
[08:26:20.251]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:20.251]                                 info, version)
[08:26:20.251]                             }
[08:26:20.251]                             base::stop(msg)
[08:26:20.251]                           }
[08:26:20.251]                         })
[08:26:20.251]                       }
[08:26:20.251]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:20.251]                       base::options(mc.cores = 1L)
[08:26:20.251]                     }
[08:26:20.251]                     base::local({
[08:26:20.251]                       for (pkg in "future.apply") {
[08:26:20.251]                         base::loadNamespace(pkg)
[08:26:20.251]                         base::library(pkg, character.only = TRUE)
[08:26:20.251]                       }
[08:26:20.251]                     })
[08:26:20.251]                   }
[08:26:20.251]                   ...future.strategy.old <- future::plan("list")
[08:26:20.251]                   options(future.plan = NULL)
[08:26:20.251]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.251]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:20.251]                 }
[08:26:20.251]                 ...future.workdir <- getwd()
[08:26:20.251]             }
[08:26:20.251]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:20.251]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:20.251]         }
[08:26:20.251]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:20.251]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:20.251]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:20.251]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:20.251]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:20.251]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:20.251]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:20.251]             base::names(...future.oldOptions))
[08:26:20.251]     }
[08:26:20.251]     if (FALSE) {
[08:26:20.251]     }
[08:26:20.251]     else {
[08:26:20.251]         if (TRUE) {
[08:26:20.251]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:20.251]                 open = "w")
[08:26:20.251]         }
[08:26:20.251]         else {
[08:26:20.251]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:20.251]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:20.251]         }
[08:26:20.251]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:20.251]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:20.251]             base::sink(type = "output", split = FALSE)
[08:26:20.251]             base::close(...future.stdout)
[08:26:20.251]         }, add = TRUE)
[08:26:20.251]     }
[08:26:20.251]     ...future.frame <- base::sys.nframe()
[08:26:20.251]     ...future.conditions <- base::list()
[08:26:20.251]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:20.251]     if (FALSE) {
[08:26:20.251]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:20.251]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:20.251]     }
[08:26:20.251]     ...future.result <- base::tryCatch({
[08:26:20.251]         base::withCallingHandlers({
[08:26:20.251]             ...future.value <- base::withVisible(base::local({
[08:26:20.251]                 withCallingHandlers({
[08:26:20.251]                   {
[08:26:20.251]                     do.call(function(...) {
[08:26:20.251]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.251]                       if (!identical(...future.globals.maxSize.org, 
[08:26:20.251]                         ...future.globals.maxSize)) {
[08:26:20.251]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.251]                         on.exit(options(oopts), add = TRUE)
[08:26:20.251]                       }
[08:26:20.251]                       {
[08:26:20.251]                         lapply(seq_along(...future.elements_ii), 
[08:26:20.251]                           FUN = function(jj) {
[08:26:20.251]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.251]                             ...future.FUN(...future.X_jj, ...)
[08:26:20.251]                           })
[08:26:20.251]                       }
[08:26:20.251]                     }, args = future.call.arguments)
[08:26:20.251]                   }
[08:26:20.251]                 }, immediateCondition = function(cond) {
[08:26:20.251]                   save_rds <- function (object, pathname, ...) 
[08:26:20.251]                   {
[08:26:20.251]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:20.251]                     if (file_test("-f", pathname_tmp)) {
[08:26:20.251]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.251]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:20.251]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.251]                         fi_tmp[["mtime"]])
[08:26:20.251]                     }
[08:26:20.251]                     tryCatch({
[08:26:20.251]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:20.251]                     }, error = function(ex) {
[08:26:20.251]                       msg <- conditionMessage(ex)
[08:26:20.251]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.251]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:20.251]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.251]                         fi_tmp[["mtime"]], msg)
[08:26:20.251]                       ex$message <- msg
[08:26:20.251]                       stop(ex)
[08:26:20.251]                     })
[08:26:20.251]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:20.251]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:20.251]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:20.251]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.251]                       fi <- file.info(pathname)
[08:26:20.251]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:20.251]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.251]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:20.251]                         fi[["size"]], fi[["mtime"]])
[08:26:20.251]                       stop(msg)
[08:26:20.251]                     }
[08:26:20.251]                     invisible(pathname)
[08:26:20.251]                   }
[08:26:20.251]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:20.251]                     rootPath = tempdir()) 
[08:26:20.251]                   {
[08:26:20.251]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:20.251]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:20.251]                       tmpdir = path, fileext = ".rds")
[08:26:20.251]                     save_rds(obj, file)
[08:26:20.251]                   }
[08:26:20.251]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:20.251]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.251]                   {
[08:26:20.251]                     inherits <- base::inherits
[08:26:20.251]                     invokeRestart <- base::invokeRestart
[08:26:20.251]                     is.null <- base::is.null
[08:26:20.251]                     muffled <- FALSE
[08:26:20.251]                     if (inherits(cond, "message")) {
[08:26:20.251]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:20.251]                       if (muffled) 
[08:26:20.251]                         invokeRestart("muffleMessage")
[08:26:20.251]                     }
[08:26:20.251]                     else if (inherits(cond, "warning")) {
[08:26:20.251]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:20.251]                       if (muffled) 
[08:26:20.251]                         invokeRestart("muffleWarning")
[08:26:20.251]                     }
[08:26:20.251]                     else if (inherits(cond, "condition")) {
[08:26:20.251]                       if (!is.null(pattern)) {
[08:26:20.251]                         computeRestarts <- base::computeRestarts
[08:26:20.251]                         grepl <- base::grepl
[08:26:20.251]                         restarts <- computeRestarts(cond)
[08:26:20.251]                         for (restart in restarts) {
[08:26:20.251]                           name <- restart$name
[08:26:20.251]                           if (is.null(name)) 
[08:26:20.251]                             next
[08:26:20.251]                           if (!grepl(pattern, name)) 
[08:26:20.251]                             next
[08:26:20.251]                           invokeRestart(restart)
[08:26:20.251]                           muffled <- TRUE
[08:26:20.251]                           break
[08:26:20.251]                         }
[08:26:20.251]                       }
[08:26:20.251]                     }
[08:26:20.251]                     invisible(muffled)
[08:26:20.251]                   }
[08:26:20.251]                   muffleCondition(cond)
[08:26:20.251]                 })
[08:26:20.251]             }))
[08:26:20.251]             future::FutureResult(value = ...future.value$value, 
[08:26:20.251]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.251]                   ...future.rng), globalenv = if (FALSE) 
[08:26:20.251]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:20.251]                     ...future.globalenv.names))
[08:26:20.251]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:20.251]         }, condition = base::local({
[08:26:20.251]             c <- base::c
[08:26:20.251]             inherits <- base::inherits
[08:26:20.251]             invokeRestart <- base::invokeRestart
[08:26:20.251]             length <- base::length
[08:26:20.251]             list <- base::list
[08:26:20.251]             seq.int <- base::seq.int
[08:26:20.251]             signalCondition <- base::signalCondition
[08:26:20.251]             sys.calls <- base::sys.calls
[08:26:20.251]             `[[` <- base::`[[`
[08:26:20.251]             `+` <- base::`+`
[08:26:20.251]             `<<-` <- base::`<<-`
[08:26:20.251]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:20.251]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:20.251]                   3L)]
[08:26:20.251]             }
[08:26:20.251]             function(cond) {
[08:26:20.251]                 is_error <- inherits(cond, "error")
[08:26:20.251]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:20.251]                   NULL)
[08:26:20.251]                 if (is_error) {
[08:26:20.251]                   sessionInformation <- function() {
[08:26:20.251]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:20.251]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:20.251]                       search = base::search(), system = base::Sys.info())
[08:26:20.251]                   }
[08:26:20.251]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.251]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:20.251]                     cond$call), session = sessionInformation(), 
[08:26:20.251]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:20.251]                   signalCondition(cond)
[08:26:20.251]                 }
[08:26:20.251]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:20.251]                 "immediateCondition"))) {
[08:26:20.251]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:20.251]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.251]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:20.251]                   if (TRUE && !signal) {
[08:26:20.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.251]                     {
[08:26:20.251]                       inherits <- base::inherits
[08:26:20.251]                       invokeRestart <- base::invokeRestart
[08:26:20.251]                       is.null <- base::is.null
[08:26:20.251]                       muffled <- FALSE
[08:26:20.251]                       if (inherits(cond, "message")) {
[08:26:20.251]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.251]                         if (muffled) 
[08:26:20.251]                           invokeRestart("muffleMessage")
[08:26:20.251]                       }
[08:26:20.251]                       else if (inherits(cond, "warning")) {
[08:26:20.251]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.251]                         if (muffled) 
[08:26:20.251]                           invokeRestart("muffleWarning")
[08:26:20.251]                       }
[08:26:20.251]                       else if (inherits(cond, "condition")) {
[08:26:20.251]                         if (!is.null(pattern)) {
[08:26:20.251]                           computeRestarts <- base::computeRestarts
[08:26:20.251]                           grepl <- base::grepl
[08:26:20.251]                           restarts <- computeRestarts(cond)
[08:26:20.251]                           for (restart in restarts) {
[08:26:20.251]                             name <- restart$name
[08:26:20.251]                             if (is.null(name)) 
[08:26:20.251]                               next
[08:26:20.251]                             if (!grepl(pattern, name)) 
[08:26:20.251]                               next
[08:26:20.251]                             invokeRestart(restart)
[08:26:20.251]                             muffled <- TRUE
[08:26:20.251]                             break
[08:26:20.251]                           }
[08:26:20.251]                         }
[08:26:20.251]                       }
[08:26:20.251]                       invisible(muffled)
[08:26:20.251]                     }
[08:26:20.251]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.251]                   }
[08:26:20.251]                 }
[08:26:20.251]                 else {
[08:26:20.251]                   if (TRUE) {
[08:26:20.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.251]                     {
[08:26:20.251]                       inherits <- base::inherits
[08:26:20.251]                       invokeRestart <- base::invokeRestart
[08:26:20.251]                       is.null <- base::is.null
[08:26:20.251]                       muffled <- FALSE
[08:26:20.251]                       if (inherits(cond, "message")) {
[08:26:20.251]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.251]                         if (muffled) 
[08:26:20.251]                           invokeRestart("muffleMessage")
[08:26:20.251]                       }
[08:26:20.251]                       else if (inherits(cond, "warning")) {
[08:26:20.251]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.251]                         if (muffled) 
[08:26:20.251]                           invokeRestart("muffleWarning")
[08:26:20.251]                       }
[08:26:20.251]                       else if (inherits(cond, "condition")) {
[08:26:20.251]                         if (!is.null(pattern)) {
[08:26:20.251]                           computeRestarts <- base::computeRestarts
[08:26:20.251]                           grepl <- base::grepl
[08:26:20.251]                           restarts <- computeRestarts(cond)
[08:26:20.251]                           for (restart in restarts) {
[08:26:20.251]                             name <- restart$name
[08:26:20.251]                             if (is.null(name)) 
[08:26:20.251]                               next
[08:26:20.251]                             if (!grepl(pattern, name)) 
[08:26:20.251]                               next
[08:26:20.251]                             invokeRestart(restart)
[08:26:20.251]                             muffled <- TRUE
[08:26:20.251]                             break
[08:26:20.251]                           }
[08:26:20.251]                         }
[08:26:20.251]                       }
[08:26:20.251]                       invisible(muffled)
[08:26:20.251]                     }
[08:26:20.251]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.251]                   }
[08:26:20.251]                 }
[08:26:20.251]             }
[08:26:20.251]         }))
[08:26:20.251]     }, error = function(ex) {
[08:26:20.251]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:20.251]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.251]                 ...future.rng), started = ...future.startTime, 
[08:26:20.251]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:20.251]             version = "1.8"), class = "FutureResult")
[08:26:20.251]     }, finally = {
[08:26:20.251]         if (!identical(...future.workdir, getwd())) 
[08:26:20.251]             setwd(...future.workdir)
[08:26:20.251]         {
[08:26:20.251]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:20.251]                 ...future.oldOptions$nwarnings <- NULL
[08:26:20.251]             }
[08:26:20.251]             base::options(...future.oldOptions)
[08:26:20.251]             if (.Platform$OS.type == "windows") {
[08:26:20.251]                 old_names <- names(...future.oldEnvVars)
[08:26:20.251]                 envs <- base::Sys.getenv()
[08:26:20.251]                 names <- names(envs)
[08:26:20.251]                 common <- intersect(names, old_names)
[08:26:20.251]                 added <- setdiff(names, old_names)
[08:26:20.251]                 removed <- setdiff(old_names, names)
[08:26:20.251]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:20.251]                   envs[common]]
[08:26:20.251]                 NAMES <- toupper(changed)
[08:26:20.251]                 args <- list()
[08:26:20.251]                 for (kk in seq_along(NAMES)) {
[08:26:20.251]                   name <- changed[[kk]]
[08:26:20.251]                   NAME <- NAMES[[kk]]
[08:26:20.251]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.251]                     next
[08:26:20.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.251]                 }
[08:26:20.251]                 NAMES <- toupper(added)
[08:26:20.251]                 for (kk in seq_along(NAMES)) {
[08:26:20.251]                   name <- added[[kk]]
[08:26:20.251]                   NAME <- NAMES[[kk]]
[08:26:20.251]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.251]                     next
[08:26:20.251]                   args[[name]] <- ""
[08:26:20.251]                 }
[08:26:20.251]                 NAMES <- toupper(removed)
[08:26:20.251]                 for (kk in seq_along(NAMES)) {
[08:26:20.251]                   name <- removed[[kk]]
[08:26:20.251]                   NAME <- NAMES[[kk]]
[08:26:20.251]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.251]                     next
[08:26:20.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.251]                 }
[08:26:20.251]                 if (length(args) > 0) 
[08:26:20.251]                   base::do.call(base::Sys.setenv, args = args)
[08:26:20.251]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:20.251]             }
[08:26:20.251]             else {
[08:26:20.251]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:20.251]             }
[08:26:20.251]             {
[08:26:20.251]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:20.251]                   0L) {
[08:26:20.251]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:20.251]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:20.251]                   base::options(opts)
[08:26:20.251]                 }
[08:26:20.251]                 {
[08:26:20.251]                   {
[08:26:20.251]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:20.251]                     NULL
[08:26:20.251]                   }
[08:26:20.251]                   options(future.plan = NULL)
[08:26:20.251]                   if (is.na(NA_character_)) 
[08:26:20.251]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.251]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:20.251]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:20.251]                     .init = FALSE)
[08:26:20.251]                 }
[08:26:20.251]             }
[08:26:20.251]         }
[08:26:20.251]     })
[08:26:20.251]     if (TRUE) {
[08:26:20.251]         base::sink(type = "output", split = FALSE)
[08:26:20.251]         if (TRUE) {
[08:26:20.251]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:20.251]         }
[08:26:20.251]         else {
[08:26:20.251]             ...future.result["stdout"] <- base::list(NULL)
[08:26:20.251]         }
[08:26:20.251]         base::close(...future.stdout)
[08:26:20.251]         ...future.stdout <- NULL
[08:26:20.251]     }
[08:26:20.251]     ...future.result$conditions <- ...future.conditions
[08:26:20.251]     ...future.result$finished <- base::Sys.time()
[08:26:20.251]     ...future.result
[08:26:20.251] }
[08:26:20.255] assign_globals() ...
[08:26:20.255] List of 11
[08:26:20.255]  $ ...future.FUN            :function (x, ...)  
[08:26:20.255]  $ x_FUN                    :function (x)  
[08:26:20.255]  $ times                    : int 2
[08:26:20.255]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:20.255]  $ stop_if_not              :function (...)  
[08:26:20.255]  $ dim                      : NULL
[08:26:20.255]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:20.255]  $ future.call.arguments    : list()
[08:26:20.255]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.255]  $ ...future.elements_ii    :List of 5
[08:26:20.255]   ..$ : int 6
[08:26:20.255]   ..$ : int 7
[08:26:20.255]   ..$ : int 8
[08:26:20.255]   ..$ : int 9
[08:26:20.255]   ..$ : int 10
[08:26:20.255]  $ ...future.seeds_ii       : NULL
[08:26:20.255]  $ ...future.globals.maxSize: NULL
[08:26:20.255]  - attr(*, "where")=List of 11
[08:26:20.255]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:20.255]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:20.255]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:20.255]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:20.255]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:20.255]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:20.255]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:20.255]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:20.255]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:20.255]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:20.255]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:20.255]  - attr(*, "resolved")= logi FALSE
[08:26:20.255]  - attr(*, "total_size")= num 24454
[08:26:20.255]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.255]  - attr(*, "already-done")= logi TRUE
[08:26:20.273] - copied ‘...future.FUN’ to environment
[08:26:20.273] - reassign environment for ‘x_FUN’
[08:26:20.273] - copied ‘x_FUN’ to environment
[08:26:20.274] - copied ‘times’ to environment
[08:26:20.274] - copied ‘stopf’ to environment
[08:26:20.274] - copied ‘stop_if_not’ to environment
[08:26:20.274] - copied ‘dim’ to environment
[08:26:20.274] - copied ‘valid_types’ to environment
[08:26:20.274] - copied ‘future.call.arguments’ to environment
[08:26:20.274] - copied ‘...future.elements_ii’ to environment
[08:26:20.274] - copied ‘...future.seeds_ii’ to environment
[08:26:20.274] - copied ‘...future.globals.maxSize’ to environment
[08:26:20.274] assign_globals() ... done
[08:26:20.275] requestCore(): workers = 2
[08:26:20.277] MulticoreFuture started
[08:26:20.277] - Launch lazy future ... done
[08:26:20.278] run() for ‘MulticoreFuture’ ... done
[08:26:20.278] Created future:
[08:26:20.278] plan(): Setting new future strategy stack:
[08:26:20.279] List of future strategies:
[08:26:20.279] 1. sequential:
[08:26:20.279]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:20.279]    - tweaked: FALSE
[08:26:20.279]    - call: NULL
[08:26:20.280] plan(): nbrOfWorkers() = 1
[08:26:20.282] plan(): Setting new future strategy stack:
[08:26:20.282] List of future strategies:
[08:26:20.282] 1. multicore:
[08:26:20.282]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:20.282]    - tweaked: FALSE
[08:26:20.282]    - call: plan(strategy)
[08:26:20.285] plan(): nbrOfWorkers() = 2
[08:26:20.278] MulticoreFuture:
[08:26:20.278] Label: ‘future_vapply-2’
[08:26:20.278] Expression:
[08:26:20.278] {
[08:26:20.278]     do.call(function(...) {
[08:26:20.278]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.278]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.278]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.278]             on.exit(options(oopts), add = TRUE)
[08:26:20.278]         }
[08:26:20.278]         {
[08:26:20.278]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.278]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.278]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.278]             })
[08:26:20.278]         }
[08:26:20.278]     }, args = future.call.arguments)
[08:26:20.278] }
[08:26:20.278] Lazy evaluation: FALSE
[08:26:20.278] Asynchronous evaluation: TRUE
[08:26:20.278] Local evaluation: TRUE
[08:26:20.278] Environment: R_GlobalEnv
[08:26:20.278] Capture standard output: TRUE
[08:26:20.278] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:20.278] Globals: 11 objects totaling 13.57 KiB (function ‘...future.FUN’ of 4.88 KiB, function ‘x_FUN’ of 483 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:20.278] Packages: 1 packages (‘future.apply’)
[08:26:20.278] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:20.278] Resolved: TRUE
[08:26:20.278] Value: <not collected>
[08:26:20.278] Conditions captured: <none>
[08:26:20.278] Early signaling: FALSE
[08:26:20.278] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:20.278] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.286] Chunk #2 of 2 ... DONE
[08:26:20.286] Launching 2 futures (chunks) ... DONE
[08:26:20.287] Resolving 2 futures (chunks) ...
[08:26:20.287] resolve() on list ...
[08:26:20.287]  recursive: 0
[08:26:20.287]  length: 2
[08:26:20.287] 
[08:26:20.287] Future #1
[08:26:20.288] result() for MulticoreFuture ...
[08:26:20.289] result() for MulticoreFuture ...
[08:26:20.289] result() for MulticoreFuture ... done
[08:26:20.289] result() for MulticoreFuture ... done
[08:26:20.289] result() for MulticoreFuture ...
[08:26:20.289] result() for MulticoreFuture ... done
[08:26:20.289] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:26:20.289] - nx: 2
[08:26:20.290] - relay: TRUE
[08:26:20.290] - stdout: TRUE
[08:26:20.290] - signal: TRUE
[08:26:20.290] - resignal: FALSE
[08:26:20.290] - force: TRUE
[08:26:20.290] - relayed: [n=2] FALSE, FALSE
[08:26:20.290] - queued futures: [n=2] FALSE, FALSE
[08:26:20.291]  - until=1
[08:26:20.291]  - relaying element #1
[08:26:20.291] result() for MulticoreFuture ...
[08:26:20.291] result() for MulticoreFuture ... done
[08:26:20.291] result() for MulticoreFuture ...
[08:26:20.291] result() for MulticoreFuture ... done
[08:26:20.291] result() for MulticoreFuture ...
[08:26:20.292] result() for MulticoreFuture ... done
[08:26:20.292] result() for MulticoreFuture ...
[08:26:20.292] result() for MulticoreFuture ... done
[08:26:20.292] - relayed: [n=2] TRUE, FALSE
[08:26:20.292] - queued futures: [n=2] TRUE, FALSE
[08:26:20.292] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:26:20.293]  length: 1 (resolved future 1)
[08:26:20.293] Future #2
[08:26:20.293] result() for MulticoreFuture ...
[08:26:20.294] result() for MulticoreFuture ...
[08:26:20.294] result() for MulticoreFuture ... done
[08:26:20.294] result() for MulticoreFuture ... done
[08:26:20.294] result() for MulticoreFuture ...
[08:26:20.294] result() for MulticoreFuture ... done
[08:26:20.295] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:26:20.295] - nx: 2
[08:26:20.295] - relay: TRUE
[08:26:20.295] - stdout: TRUE
[08:26:20.295] - signal: TRUE
[08:26:20.295] - resignal: FALSE
[08:26:20.295] - force: TRUE
[08:26:20.295] - relayed: [n=2] TRUE, FALSE
[08:26:20.295] - queued futures: [n=2] TRUE, FALSE
[08:26:20.296]  - until=2
[08:26:20.296]  - relaying element #2
[08:26:20.296] result() for MulticoreFuture ...
[08:26:20.296] result() for MulticoreFuture ... done
[08:26:20.296] result() for MulticoreFuture ...
[08:26:20.296] result() for MulticoreFuture ... done
[08:26:20.296] result() for MulticoreFuture ...
[08:26:20.297] result() for MulticoreFuture ... done
[08:26:20.297] result() for MulticoreFuture ...
[08:26:20.297] result() for MulticoreFuture ... done
[08:26:20.297] - relayed: [n=2] TRUE, TRUE
[08:26:20.297] - queued futures: [n=2] TRUE, TRUE
[08:26:20.297] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:26:20.297]  length: 0 (resolved future 2)
[08:26:20.297] Relaying remaining futures
[08:26:20.297] signalConditionsASAP(NULL, pos=0) ...
[08:26:20.298] - nx: 2
[08:26:20.298] - relay: TRUE
[08:26:20.298] - stdout: TRUE
[08:26:20.298] - signal: TRUE
[08:26:20.298] - resignal: FALSE
[08:26:20.298] - force: TRUE
[08:26:20.298] - relayed: [n=2] TRUE, TRUE
[08:26:20.298] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:20.298] - relayed: [n=2] TRUE, TRUE
[08:26:20.299] - queued futures: [n=2] TRUE, TRUE
[08:26:20.299] signalConditionsASAP(NULL, pos=0) ... done
[08:26:20.299] resolve() on list ... DONE
[08:26:20.299] result() for MulticoreFuture ...
[08:26:20.299] result() for MulticoreFuture ... done
[08:26:20.301] result() for MulticoreFuture ...
[08:26:20.302] result() for MulticoreFuture ... done
[08:26:20.302] result() for MulticoreFuture ...
[08:26:20.302] result() for MulticoreFuture ... done
[08:26:20.302] result() for MulticoreFuture ...
[08:26:20.302] result() for MulticoreFuture ... done
[08:26:20.303]  - Number of value chunks collected: 2
[08:26:20.303] Resolving 2 futures (chunks) ... DONE
[08:26:20.303] Reducing values from 2 chunks ...
[08:26:20.303]  - Number of values collected after concatenation: 10
[08:26:20.303]  - Number of values expected: 10
[08:26:20.303] Reducing values from 2 chunks ... DONE
[08:26:20.304] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[08:26:20.305] future_lapply() ...
[08:26:20.310] Number of chunks: 2
[08:26:20.310] getGlobalsAndPackagesXApply() ...
[08:26:20.310]  - future.globals: TRUE
[08:26:20.310] getGlobalsAndPackages() ...
[08:26:20.310] Searching for globals...
[08:26:20.315] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[08:26:20.315] Searching for globals ... DONE
[08:26:20.315] Resolving globals: FALSE
[08:26:20.316] The total size of the 7 globals is 13.59 KiB (13914 bytes)
[08:26:20.316] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.59 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.06 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:20.316] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:20.317] - packages: [1] ‘future.apply’
[08:26:20.317] getGlobalsAndPackages() ... DONE
[08:26:20.317]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:20.317]  - needed namespaces: [n=1] ‘future.apply’
[08:26:20.317] Finding globals ... DONE
[08:26:20.317]  - use_args: TRUE
[08:26:20.317]  - Getting '...' globals ...
[08:26:20.317] resolve() on list ...
[08:26:20.318]  recursive: 0
[08:26:20.318]  length: 1
[08:26:20.318]  elements: ‘...’
[08:26:20.318]  length: 0 (resolved future 1)
[08:26:20.318] resolve() on list ... DONE
[08:26:20.318]    - '...' content: [n=0] 
[08:26:20.318] List of 1
[08:26:20.318]  $ ...: list()
[08:26:20.318]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.318]  - attr(*, "where")=List of 1
[08:26:20.318]   ..$ ...:<environment: 0x562ca5ffa908> 
[08:26:20.318]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.318]  - attr(*, "resolved")= logi TRUE
[08:26:20.318]  - attr(*, "total_size")= num NA
[08:26:20.321]  - Getting '...' globals ... DONE
[08:26:20.321] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:20.321] List of 8
[08:26:20.321]  $ ...future.FUN:function (x, ...)  
[08:26:20.321]  $ x_FUN        :function (x)  
[08:26:20.321]  $ times        : int 4
[08:26:20.321]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:20.321]  $ stop_if_not  :function (...)  
[08:26:20.321]  $ dim          : int [1:2] 2 2
[08:26:20.321]  $ valid_types  : chr [1:2] "logical" "integer"
[08:26:20.321]  $ ...          : list()
[08:26:20.321]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.321]  - attr(*, "where")=List of 8
[08:26:20.321]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:20.321]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:20.321]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:20.321]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:20.321]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:20.321]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:20.321]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:20.321]   ..$ ...          :<environment: 0x562ca5ffa908> 
[08:26:20.321]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.321]  - attr(*, "resolved")= logi FALSE
[08:26:20.321]  - attr(*, "total_size")= num 24886
[08:26:20.329] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:20.329] getGlobalsAndPackagesXApply() ... DONE
[08:26:20.330] Number of futures (= number of chunks): 2
[08:26:20.330] Launching 2 futures (chunks) ...
[08:26:20.330] Chunk #1 of 2 ...
[08:26:20.330]  - Finding globals in 'X' for chunk #1 ...
[08:26:20.330] getGlobalsAndPackages() ...
[08:26:20.330] Searching for globals...
[08:26:20.330] 
[08:26:20.330] Searching for globals ... DONE
[08:26:20.331] - globals: [0] <none>
[08:26:20.331] getGlobalsAndPackages() ... DONE
[08:26:20.331]    + additional globals found: [n=0] 
[08:26:20.331]    + additional namespaces needed: [n=0] 
[08:26:20.331]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:20.331]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:20.331]  - seeds: <none>
[08:26:20.331]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.331] getGlobalsAndPackages() ...
[08:26:20.331] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.332] Resolving globals: FALSE
[08:26:20.332] Tweak future expression to call with '...' arguments ...
[08:26:20.332] {
[08:26:20.332]     do.call(function(...) {
[08:26:20.332]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.332]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.332]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.332]             on.exit(options(oopts), add = TRUE)
[08:26:20.332]         }
[08:26:20.332]         {
[08:26:20.332]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.332]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.332]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.332]             })
[08:26:20.332]         }
[08:26:20.332]     }, args = future.call.arguments)
[08:26:20.332] }
[08:26:20.332] Tweak future expression to call with '...' arguments ... DONE
[08:26:20.333] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.333] - packages: [1] ‘future.apply’
[08:26:20.333] getGlobalsAndPackages() ... DONE
[08:26:20.333] run() for ‘Future’ ...
[08:26:20.333] - state: ‘created’
[08:26:20.333] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:20.335] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.335] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:20.335]   - Field: ‘label’
[08:26:20.335]   - Field: ‘local’
[08:26:20.336]   - Field: ‘owner’
[08:26:20.336]   - Field: ‘envir’
[08:26:20.336]   - Field: ‘workers’
[08:26:20.336]   - Field: ‘packages’
[08:26:20.336]   - Field: ‘gc’
[08:26:20.336]   - Field: ‘job’
[08:26:20.336]   - Field: ‘conditions’
[08:26:20.336]   - Field: ‘expr’
[08:26:20.336]   - Field: ‘uuid’
[08:26:20.336]   - Field: ‘seed’
[08:26:20.336]   - Field: ‘version’
[08:26:20.337]   - Field: ‘result’
[08:26:20.337]   - Field: ‘asynchronous’
[08:26:20.337]   - Field: ‘calls’
[08:26:20.337]   - Field: ‘globals’
[08:26:20.337]   - Field: ‘stdout’
[08:26:20.337]   - Field: ‘earlySignal’
[08:26:20.337]   - Field: ‘lazy’
[08:26:20.337]   - Field: ‘state’
[08:26:20.337] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:20.337] - Launch lazy future ...
[08:26:20.338] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:20.338] Packages needed by future strategies (n = 0): <none>
[08:26:20.338] {
[08:26:20.338]     {
[08:26:20.338]         {
[08:26:20.338]             ...future.startTime <- base::Sys.time()
[08:26:20.338]             {
[08:26:20.338]                 {
[08:26:20.338]                   {
[08:26:20.338]                     {
[08:26:20.338]                       {
[08:26:20.338]                         base::local({
[08:26:20.338]                           has_future <- base::requireNamespace("future", 
[08:26:20.338]                             quietly = TRUE)
[08:26:20.338]                           if (has_future) {
[08:26:20.338]                             ns <- base::getNamespace("future")
[08:26:20.338]                             version <- ns[[".package"]][["version"]]
[08:26:20.338]                             if (is.null(version)) 
[08:26:20.338]                               version <- utils::packageVersion("future")
[08:26:20.338]                           }
[08:26:20.338]                           else {
[08:26:20.338]                             version <- NULL
[08:26:20.338]                           }
[08:26:20.338]                           if (!has_future || version < "1.8.0") {
[08:26:20.338]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:20.338]                               "", base::R.version$version.string), 
[08:26:20.338]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:20.338]                                 base::R.version$platform, 8 * 
[08:26:20.338]                                   base::.Machine$sizeof.pointer), 
[08:26:20.338]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:20.338]                                 "release", "version")], collapse = " "), 
[08:26:20.338]                               hostname = base::Sys.info()[["nodename"]])
[08:26:20.338]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:20.338]                               info)
[08:26:20.338]                             info <- base::paste(info, collapse = "; ")
[08:26:20.338]                             if (!has_future) {
[08:26:20.338]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:20.338]                                 info)
[08:26:20.338]                             }
[08:26:20.338]                             else {
[08:26:20.338]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:20.338]                                 info, version)
[08:26:20.338]                             }
[08:26:20.338]                             base::stop(msg)
[08:26:20.338]                           }
[08:26:20.338]                         })
[08:26:20.338]                       }
[08:26:20.338]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:20.338]                       base::options(mc.cores = 1L)
[08:26:20.338]                     }
[08:26:20.338]                     base::local({
[08:26:20.338]                       for (pkg in "future.apply") {
[08:26:20.338]                         base::loadNamespace(pkg)
[08:26:20.338]                         base::library(pkg, character.only = TRUE)
[08:26:20.338]                       }
[08:26:20.338]                     })
[08:26:20.338]                   }
[08:26:20.338]                   ...future.strategy.old <- future::plan("list")
[08:26:20.338]                   options(future.plan = NULL)
[08:26:20.338]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.338]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:20.338]                 }
[08:26:20.338]                 ...future.workdir <- getwd()
[08:26:20.338]             }
[08:26:20.338]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:20.338]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:20.338]         }
[08:26:20.338]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:20.338]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:20.338]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:20.338]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:20.338]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:20.338]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:20.338]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:20.338]             base::names(...future.oldOptions))
[08:26:20.338]     }
[08:26:20.338]     if (FALSE) {
[08:26:20.338]     }
[08:26:20.338]     else {
[08:26:20.338]         if (TRUE) {
[08:26:20.338]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:20.338]                 open = "w")
[08:26:20.338]         }
[08:26:20.338]         else {
[08:26:20.338]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:20.338]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:20.338]         }
[08:26:20.338]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:20.338]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:20.338]             base::sink(type = "output", split = FALSE)
[08:26:20.338]             base::close(...future.stdout)
[08:26:20.338]         }, add = TRUE)
[08:26:20.338]     }
[08:26:20.338]     ...future.frame <- base::sys.nframe()
[08:26:20.338]     ...future.conditions <- base::list()
[08:26:20.338]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:20.338]     if (FALSE) {
[08:26:20.338]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:20.338]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:20.338]     }
[08:26:20.338]     ...future.result <- base::tryCatch({
[08:26:20.338]         base::withCallingHandlers({
[08:26:20.338]             ...future.value <- base::withVisible(base::local({
[08:26:20.338]                 withCallingHandlers({
[08:26:20.338]                   {
[08:26:20.338]                     do.call(function(...) {
[08:26:20.338]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.338]                       if (!identical(...future.globals.maxSize.org, 
[08:26:20.338]                         ...future.globals.maxSize)) {
[08:26:20.338]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.338]                         on.exit(options(oopts), add = TRUE)
[08:26:20.338]                       }
[08:26:20.338]                       {
[08:26:20.338]                         lapply(seq_along(...future.elements_ii), 
[08:26:20.338]                           FUN = function(jj) {
[08:26:20.338]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.338]                             ...future.FUN(...future.X_jj, ...)
[08:26:20.338]                           })
[08:26:20.338]                       }
[08:26:20.338]                     }, args = future.call.arguments)
[08:26:20.338]                   }
[08:26:20.338]                 }, immediateCondition = function(cond) {
[08:26:20.338]                   save_rds <- function (object, pathname, ...) 
[08:26:20.338]                   {
[08:26:20.338]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:20.338]                     if (file_test("-f", pathname_tmp)) {
[08:26:20.338]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.338]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:20.338]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.338]                         fi_tmp[["mtime"]])
[08:26:20.338]                     }
[08:26:20.338]                     tryCatch({
[08:26:20.338]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:20.338]                     }, error = function(ex) {
[08:26:20.338]                       msg <- conditionMessage(ex)
[08:26:20.338]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.338]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:20.338]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.338]                         fi_tmp[["mtime"]], msg)
[08:26:20.338]                       ex$message <- msg
[08:26:20.338]                       stop(ex)
[08:26:20.338]                     })
[08:26:20.338]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:20.338]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:20.338]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:20.338]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.338]                       fi <- file.info(pathname)
[08:26:20.338]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:20.338]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.338]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:20.338]                         fi[["size"]], fi[["mtime"]])
[08:26:20.338]                       stop(msg)
[08:26:20.338]                     }
[08:26:20.338]                     invisible(pathname)
[08:26:20.338]                   }
[08:26:20.338]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:20.338]                     rootPath = tempdir()) 
[08:26:20.338]                   {
[08:26:20.338]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:20.338]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:20.338]                       tmpdir = path, fileext = ".rds")
[08:26:20.338]                     save_rds(obj, file)
[08:26:20.338]                   }
[08:26:20.338]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:20.338]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.338]                   {
[08:26:20.338]                     inherits <- base::inherits
[08:26:20.338]                     invokeRestart <- base::invokeRestart
[08:26:20.338]                     is.null <- base::is.null
[08:26:20.338]                     muffled <- FALSE
[08:26:20.338]                     if (inherits(cond, "message")) {
[08:26:20.338]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:20.338]                       if (muffled) 
[08:26:20.338]                         invokeRestart("muffleMessage")
[08:26:20.338]                     }
[08:26:20.338]                     else if (inherits(cond, "warning")) {
[08:26:20.338]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:20.338]                       if (muffled) 
[08:26:20.338]                         invokeRestart("muffleWarning")
[08:26:20.338]                     }
[08:26:20.338]                     else if (inherits(cond, "condition")) {
[08:26:20.338]                       if (!is.null(pattern)) {
[08:26:20.338]                         computeRestarts <- base::computeRestarts
[08:26:20.338]                         grepl <- base::grepl
[08:26:20.338]                         restarts <- computeRestarts(cond)
[08:26:20.338]                         for (restart in restarts) {
[08:26:20.338]                           name <- restart$name
[08:26:20.338]                           if (is.null(name)) 
[08:26:20.338]                             next
[08:26:20.338]                           if (!grepl(pattern, name)) 
[08:26:20.338]                             next
[08:26:20.338]                           invokeRestart(restart)
[08:26:20.338]                           muffled <- TRUE
[08:26:20.338]                           break
[08:26:20.338]                         }
[08:26:20.338]                       }
[08:26:20.338]                     }
[08:26:20.338]                     invisible(muffled)
[08:26:20.338]                   }
[08:26:20.338]                   muffleCondition(cond)
[08:26:20.338]                 })
[08:26:20.338]             }))
[08:26:20.338]             future::FutureResult(value = ...future.value$value, 
[08:26:20.338]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.338]                   ...future.rng), globalenv = if (FALSE) 
[08:26:20.338]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:20.338]                     ...future.globalenv.names))
[08:26:20.338]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:20.338]         }, condition = base::local({
[08:26:20.338]             c <- base::c
[08:26:20.338]             inherits <- base::inherits
[08:26:20.338]             invokeRestart <- base::invokeRestart
[08:26:20.338]             length <- base::length
[08:26:20.338]             list <- base::list
[08:26:20.338]             seq.int <- base::seq.int
[08:26:20.338]             signalCondition <- base::signalCondition
[08:26:20.338]             sys.calls <- base::sys.calls
[08:26:20.338]             `[[` <- base::`[[`
[08:26:20.338]             `+` <- base::`+`
[08:26:20.338]             `<<-` <- base::`<<-`
[08:26:20.338]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:20.338]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:20.338]                   3L)]
[08:26:20.338]             }
[08:26:20.338]             function(cond) {
[08:26:20.338]                 is_error <- inherits(cond, "error")
[08:26:20.338]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:20.338]                   NULL)
[08:26:20.338]                 if (is_error) {
[08:26:20.338]                   sessionInformation <- function() {
[08:26:20.338]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:20.338]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:20.338]                       search = base::search(), system = base::Sys.info())
[08:26:20.338]                   }
[08:26:20.338]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.338]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:20.338]                     cond$call), session = sessionInformation(), 
[08:26:20.338]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:20.338]                   signalCondition(cond)
[08:26:20.338]                 }
[08:26:20.338]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:20.338]                 "immediateCondition"))) {
[08:26:20.338]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:20.338]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.338]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:20.338]                   if (TRUE && !signal) {
[08:26:20.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.338]                     {
[08:26:20.338]                       inherits <- base::inherits
[08:26:20.338]                       invokeRestart <- base::invokeRestart
[08:26:20.338]                       is.null <- base::is.null
[08:26:20.338]                       muffled <- FALSE
[08:26:20.338]                       if (inherits(cond, "message")) {
[08:26:20.338]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.338]                         if (muffled) 
[08:26:20.338]                           invokeRestart("muffleMessage")
[08:26:20.338]                       }
[08:26:20.338]                       else if (inherits(cond, "warning")) {
[08:26:20.338]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.338]                         if (muffled) 
[08:26:20.338]                           invokeRestart("muffleWarning")
[08:26:20.338]                       }
[08:26:20.338]                       else if (inherits(cond, "condition")) {
[08:26:20.338]                         if (!is.null(pattern)) {
[08:26:20.338]                           computeRestarts <- base::computeRestarts
[08:26:20.338]                           grepl <- base::grepl
[08:26:20.338]                           restarts <- computeRestarts(cond)
[08:26:20.338]                           for (restart in restarts) {
[08:26:20.338]                             name <- restart$name
[08:26:20.338]                             if (is.null(name)) 
[08:26:20.338]                               next
[08:26:20.338]                             if (!grepl(pattern, name)) 
[08:26:20.338]                               next
[08:26:20.338]                             invokeRestart(restart)
[08:26:20.338]                             muffled <- TRUE
[08:26:20.338]                             break
[08:26:20.338]                           }
[08:26:20.338]                         }
[08:26:20.338]                       }
[08:26:20.338]                       invisible(muffled)
[08:26:20.338]                     }
[08:26:20.338]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.338]                   }
[08:26:20.338]                 }
[08:26:20.338]                 else {
[08:26:20.338]                   if (TRUE) {
[08:26:20.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.338]                     {
[08:26:20.338]                       inherits <- base::inherits
[08:26:20.338]                       invokeRestart <- base::invokeRestart
[08:26:20.338]                       is.null <- base::is.null
[08:26:20.338]                       muffled <- FALSE
[08:26:20.338]                       if (inherits(cond, "message")) {
[08:26:20.338]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.338]                         if (muffled) 
[08:26:20.338]                           invokeRestart("muffleMessage")
[08:26:20.338]                       }
[08:26:20.338]                       else if (inherits(cond, "warning")) {
[08:26:20.338]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.338]                         if (muffled) 
[08:26:20.338]                           invokeRestart("muffleWarning")
[08:26:20.338]                       }
[08:26:20.338]                       else if (inherits(cond, "condition")) {
[08:26:20.338]                         if (!is.null(pattern)) {
[08:26:20.338]                           computeRestarts <- base::computeRestarts
[08:26:20.338]                           grepl <- base::grepl
[08:26:20.338]                           restarts <- computeRestarts(cond)
[08:26:20.338]                           for (restart in restarts) {
[08:26:20.338]                             name <- restart$name
[08:26:20.338]                             if (is.null(name)) 
[08:26:20.338]                               next
[08:26:20.338]                             if (!grepl(pattern, name)) 
[08:26:20.338]                               next
[08:26:20.338]                             invokeRestart(restart)
[08:26:20.338]                             muffled <- TRUE
[08:26:20.338]                             break
[08:26:20.338]                           }
[08:26:20.338]                         }
[08:26:20.338]                       }
[08:26:20.338]                       invisible(muffled)
[08:26:20.338]                     }
[08:26:20.338]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.338]                   }
[08:26:20.338]                 }
[08:26:20.338]             }
[08:26:20.338]         }))
[08:26:20.338]     }, error = function(ex) {
[08:26:20.338]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:20.338]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.338]                 ...future.rng), started = ...future.startTime, 
[08:26:20.338]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:20.338]             version = "1.8"), class = "FutureResult")
[08:26:20.338]     }, finally = {
[08:26:20.338]         if (!identical(...future.workdir, getwd())) 
[08:26:20.338]             setwd(...future.workdir)
[08:26:20.338]         {
[08:26:20.338]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:20.338]                 ...future.oldOptions$nwarnings <- NULL
[08:26:20.338]             }
[08:26:20.338]             base::options(...future.oldOptions)
[08:26:20.338]             if (.Platform$OS.type == "windows") {
[08:26:20.338]                 old_names <- names(...future.oldEnvVars)
[08:26:20.338]                 envs <- base::Sys.getenv()
[08:26:20.338]                 names <- names(envs)
[08:26:20.338]                 common <- intersect(names, old_names)
[08:26:20.338]                 added <- setdiff(names, old_names)
[08:26:20.338]                 removed <- setdiff(old_names, names)
[08:26:20.338]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:20.338]                   envs[common]]
[08:26:20.338]                 NAMES <- toupper(changed)
[08:26:20.338]                 args <- list()
[08:26:20.338]                 for (kk in seq_along(NAMES)) {
[08:26:20.338]                   name <- changed[[kk]]
[08:26:20.338]                   NAME <- NAMES[[kk]]
[08:26:20.338]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.338]                     next
[08:26:20.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.338]                 }
[08:26:20.338]                 NAMES <- toupper(added)
[08:26:20.338]                 for (kk in seq_along(NAMES)) {
[08:26:20.338]                   name <- added[[kk]]
[08:26:20.338]                   NAME <- NAMES[[kk]]
[08:26:20.338]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.338]                     next
[08:26:20.338]                   args[[name]] <- ""
[08:26:20.338]                 }
[08:26:20.338]                 NAMES <- toupper(removed)
[08:26:20.338]                 for (kk in seq_along(NAMES)) {
[08:26:20.338]                   name <- removed[[kk]]
[08:26:20.338]                   NAME <- NAMES[[kk]]
[08:26:20.338]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.338]                     next
[08:26:20.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.338]                 }
[08:26:20.338]                 if (length(args) > 0) 
[08:26:20.338]                   base::do.call(base::Sys.setenv, args = args)
[08:26:20.338]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:20.338]             }
[08:26:20.338]             else {
[08:26:20.338]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:20.338]             }
[08:26:20.338]             {
[08:26:20.338]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:20.338]                   0L) {
[08:26:20.338]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:20.338]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:20.338]                   base::options(opts)
[08:26:20.338]                 }
[08:26:20.338]                 {
[08:26:20.338]                   {
[08:26:20.338]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:20.338]                     NULL
[08:26:20.338]                   }
[08:26:20.338]                   options(future.plan = NULL)
[08:26:20.338]                   if (is.na(NA_character_)) 
[08:26:20.338]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.338]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:20.338]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:20.338]                     .init = FALSE)
[08:26:20.338]                 }
[08:26:20.338]             }
[08:26:20.338]         }
[08:26:20.338]     })
[08:26:20.338]     if (TRUE) {
[08:26:20.338]         base::sink(type = "output", split = FALSE)
[08:26:20.338]         if (TRUE) {
[08:26:20.338]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:20.338]         }
[08:26:20.338]         else {
[08:26:20.338]             ...future.result["stdout"] <- base::list(NULL)
[08:26:20.338]         }
[08:26:20.338]         base::close(...future.stdout)
[08:26:20.338]         ...future.stdout <- NULL
[08:26:20.338]     }
[08:26:20.338]     ...future.result$conditions <- ...future.conditions
[08:26:20.338]     ...future.result$finished <- base::Sys.time()
[08:26:20.338]     ...future.result
[08:26:20.338] }
[08:26:20.341] assign_globals() ...
[08:26:20.341] List of 11
[08:26:20.341]  $ ...future.FUN            :function (x, ...)  
[08:26:20.341]  $ x_FUN                    :function (x)  
[08:26:20.341]  $ times                    : int 4
[08:26:20.341]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:20.341]  $ stop_if_not              :function (...)  
[08:26:20.341]  $ dim                      : int [1:2] 2 2
[08:26:20.341]  $ valid_types              : chr [1:2] "logical" "integer"
[08:26:20.341]  $ future.call.arguments    : list()
[08:26:20.341]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.341]  $ ...future.elements_ii    :List of 5
[08:26:20.341]   ..$ : int 1
[08:26:20.341]   ..$ : int 2
[08:26:20.341]   ..$ : int 3
[08:26:20.341]   ..$ : int 4
[08:26:20.341]   ..$ : int 5
[08:26:20.341]  $ ...future.seeds_ii       : NULL
[08:26:20.341]  $ ...future.globals.maxSize: NULL
[08:26:20.341]  - attr(*, "where")=List of 11
[08:26:20.341]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:20.341]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:20.341]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:20.341]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:20.341]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:20.341]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:20.341]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:20.341]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:20.341]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:20.341]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:20.341]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:20.341]  - attr(*, "resolved")= logi FALSE
[08:26:20.341]  - attr(*, "total_size")= num 24886
[08:26:20.341]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.341]  - attr(*, "already-done")= logi TRUE
[08:26:20.352] - copied ‘...future.FUN’ to environment
[08:26:20.352] - reassign environment for ‘x_FUN’
[08:26:20.352] - copied ‘x_FUN’ to environment
[08:26:20.352] - copied ‘times’ to environment
[08:26:20.352] - copied ‘stopf’ to environment
[08:26:20.352] - copied ‘stop_if_not’ to environment
[08:26:20.353] - copied ‘dim’ to environment
[08:26:20.353] - copied ‘valid_types’ to environment
[08:26:20.353] - copied ‘future.call.arguments’ to environment
[08:26:20.353] - copied ‘...future.elements_ii’ to environment
[08:26:20.353] - copied ‘...future.seeds_ii’ to environment
[08:26:20.353] - copied ‘...future.globals.maxSize’ to environment
[08:26:20.353] assign_globals() ... done
[08:26:20.353] requestCore(): workers = 2
[08:26:20.356] MulticoreFuture started
[08:26:20.356] - Launch lazy future ... done
[08:26:20.357] run() for ‘MulticoreFuture’ ... done
[08:26:20.357] Created future:
[08:26:20.357] plan(): Setting new future strategy stack:
[08:26:20.358] List of future strategies:
[08:26:20.358] 1. sequential:
[08:26:20.358]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:20.358]    - tweaked: FALSE
[08:26:20.358]    - call: NULL
[08:26:20.359] plan(): nbrOfWorkers() = 1
[08:26:20.361] plan(): Setting new future strategy stack:
[08:26:20.361] List of future strategies:
[08:26:20.361] 1. multicore:
[08:26:20.361]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:20.361]    - tweaked: FALSE
[08:26:20.361]    - call: plan(strategy)
[08:26:20.365] plan(): nbrOfWorkers() = 2
[08:26:20.357] MulticoreFuture:
[08:26:20.357] Label: ‘future_vapply-1’
[08:26:20.357] Expression:
[08:26:20.357] {
[08:26:20.357]     do.call(function(...) {
[08:26:20.357]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.357]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.357]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.357]             on.exit(options(oopts), add = TRUE)
[08:26:20.357]         }
[08:26:20.357]         {
[08:26:20.357]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.357]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.357]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.357]             })
[08:26:20.357]         }
[08:26:20.357]     }, args = future.call.arguments)
[08:26:20.357] }
[08:26:20.357] Lazy evaluation: FALSE
[08:26:20.357] Asynchronous evaluation: TRUE
[08:26:20.357] Local evaluation: TRUE
[08:26:20.357] Environment: R_GlobalEnv
[08:26:20.357] Capture standard output: TRUE
[08:26:20.357] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:20.357] Globals: 11 objects totaling 13.82 KiB (function ‘...future.FUN’ of 5.05 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:20.357] Packages: 1 packages (‘future.apply’)
[08:26:20.357] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:20.357] Resolved: TRUE
[08:26:20.357] Value: <not collected>
[08:26:20.357] Conditions captured: <none>
[08:26:20.357] Early signaling: FALSE
[08:26:20.357] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:20.357] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.366] Chunk #1 of 2 ... DONE
[08:26:20.367] Chunk #2 of 2 ...
[08:26:20.367]  - Finding globals in 'X' for chunk #2 ...
[08:26:20.367] getGlobalsAndPackages() ...
[08:26:20.367] Searching for globals...
[08:26:20.367] 
[08:26:20.368] Searching for globals ... DONE
[08:26:20.368] - globals: [0] <none>
[08:26:20.368] getGlobalsAndPackages() ... DONE
[08:26:20.368]    + additional globals found: [n=0] 
[08:26:20.368]    + additional namespaces needed: [n=0] 
[08:26:20.368]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:20.369]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:20.369]  - seeds: <none>
[08:26:20.369]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.369] getGlobalsAndPackages() ...
[08:26:20.369] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.369] Resolving globals: FALSE
[08:26:20.370] Tweak future expression to call with '...' arguments ...
[08:26:20.370] {
[08:26:20.370]     do.call(function(...) {
[08:26:20.370]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.370]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.370]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.370]             on.exit(options(oopts), add = TRUE)
[08:26:20.370]         }
[08:26:20.370]         {
[08:26:20.370]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.370]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.370]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.370]             })
[08:26:20.370]         }
[08:26:20.370]     }, args = future.call.arguments)
[08:26:20.370] }
[08:26:20.370] Tweak future expression to call with '...' arguments ... DONE
[08:26:20.371] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.371] - packages: [1] ‘future.apply’
[08:26:20.372] getGlobalsAndPackages() ... DONE
[08:26:20.372] run() for ‘Future’ ...
[08:26:20.372] - state: ‘created’
[08:26:20.373] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:20.375] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.375] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:20.375]   - Field: ‘label’
[08:26:20.376]   - Field: ‘local’
[08:26:20.376]   - Field: ‘owner’
[08:26:20.376]   - Field: ‘envir’
[08:26:20.376]   - Field: ‘workers’
[08:26:20.376]   - Field: ‘packages’
[08:26:20.376]   - Field: ‘gc’
[08:26:20.376]   - Field: ‘job’
[08:26:20.377]   - Field: ‘conditions’
[08:26:20.377]   - Field: ‘expr’
[08:26:20.377]   - Field: ‘uuid’
[08:26:20.377]   - Field: ‘seed’
[08:26:20.377]   - Field: ‘version’
[08:26:20.377]   - Field: ‘result’
[08:26:20.377]   - Field: ‘asynchronous’
[08:26:20.378]   - Field: ‘calls’
[08:26:20.378]   - Field: ‘globals’
[08:26:20.378]   - Field: ‘stdout’
[08:26:20.378]   - Field: ‘earlySignal’
[08:26:20.378]   - Field: ‘lazy’
[08:26:20.378]   - Field: ‘state’
[08:26:20.379] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:20.379] - Launch lazy future ...
[08:26:20.379] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:20.379] Packages needed by future strategies (n = 0): <none>
[08:26:20.380] {
[08:26:20.380]     {
[08:26:20.380]         {
[08:26:20.380]             ...future.startTime <- base::Sys.time()
[08:26:20.380]             {
[08:26:20.380]                 {
[08:26:20.380]                   {
[08:26:20.380]                     {
[08:26:20.380]                       {
[08:26:20.380]                         base::local({
[08:26:20.380]                           has_future <- base::requireNamespace("future", 
[08:26:20.380]                             quietly = TRUE)
[08:26:20.380]                           if (has_future) {
[08:26:20.380]                             ns <- base::getNamespace("future")
[08:26:20.380]                             version <- ns[[".package"]][["version"]]
[08:26:20.380]                             if (is.null(version)) 
[08:26:20.380]                               version <- utils::packageVersion("future")
[08:26:20.380]                           }
[08:26:20.380]                           else {
[08:26:20.380]                             version <- NULL
[08:26:20.380]                           }
[08:26:20.380]                           if (!has_future || version < "1.8.0") {
[08:26:20.380]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:20.380]                               "", base::R.version$version.string), 
[08:26:20.380]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:20.380]                                 base::R.version$platform, 8 * 
[08:26:20.380]                                   base::.Machine$sizeof.pointer), 
[08:26:20.380]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:20.380]                                 "release", "version")], collapse = " "), 
[08:26:20.380]                               hostname = base::Sys.info()[["nodename"]])
[08:26:20.380]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:20.380]                               info)
[08:26:20.380]                             info <- base::paste(info, collapse = "; ")
[08:26:20.380]                             if (!has_future) {
[08:26:20.380]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:20.380]                                 info)
[08:26:20.380]                             }
[08:26:20.380]                             else {
[08:26:20.380]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:20.380]                                 info, version)
[08:26:20.380]                             }
[08:26:20.380]                             base::stop(msg)
[08:26:20.380]                           }
[08:26:20.380]                         })
[08:26:20.380]                       }
[08:26:20.380]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:20.380]                       base::options(mc.cores = 1L)
[08:26:20.380]                     }
[08:26:20.380]                     base::local({
[08:26:20.380]                       for (pkg in "future.apply") {
[08:26:20.380]                         base::loadNamespace(pkg)
[08:26:20.380]                         base::library(pkg, character.only = TRUE)
[08:26:20.380]                       }
[08:26:20.380]                     })
[08:26:20.380]                   }
[08:26:20.380]                   ...future.strategy.old <- future::plan("list")
[08:26:20.380]                   options(future.plan = NULL)
[08:26:20.380]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.380]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:20.380]                 }
[08:26:20.380]                 ...future.workdir <- getwd()
[08:26:20.380]             }
[08:26:20.380]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:20.380]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:20.380]         }
[08:26:20.380]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:20.380]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:20.380]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:20.380]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:20.380]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:20.380]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:20.380]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:20.380]             base::names(...future.oldOptions))
[08:26:20.380]     }
[08:26:20.380]     if (FALSE) {
[08:26:20.380]     }
[08:26:20.380]     else {
[08:26:20.380]         if (TRUE) {
[08:26:20.380]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:20.380]                 open = "w")
[08:26:20.380]         }
[08:26:20.380]         else {
[08:26:20.380]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:20.380]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:20.380]         }
[08:26:20.380]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:20.380]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:20.380]             base::sink(type = "output", split = FALSE)
[08:26:20.380]             base::close(...future.stdout)
[08:26:20.380]         }, add = TRUE)
[08:26:20.380]     }
[08:26:20.380]     ...future.frame <- base::sys.nframe()
[08:26:20.380]     ...future.conditions <- base::list()
[08:26:20.380]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:20.380]     if (FALSE) {
[08:26:20.380]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:20.380]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:20.380]     }
[08:26:20.380]     ...future.result <- base::tryCatch({
[08:26:20.380]         base::withCallingHandlers({
[08:26:20.380]             ...future.value <- base::withVisible(base::local({
[08:26:20.380]                 withCallingHandlers({
[08:26:20.380]                   {
[08:26:20.380]                     do.call(function(...) {
[08:26:20.380]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.380]                       if (!identical(...future.globals.maxSize.org, 
[08:26:20.380]                         ...future.globals.maxSize)) {
[08:26:20.380]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.380]                         on.exit(options(oopts), add = TRUE)
[08:26:20.380]                       }
[08:26:20.380]                       {
[08:26:20.380]                         lapply(seq_along(...future.elements_ii), 
[08:26:20.380]                           FUN = function(jj) {
[08:26:20.380]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.380]                             ...future.FUN(...future.X_jj, ...)
[08:26:20.380]                           })
[08:26:20.380]                       }
[08:26:20.380]                     }, args = future.call.arguments)
[08:26:20.380]                   }
[08:26:20.380]                 }, immediateCondition = function(cond) {
[08:26:20.380]                   save_rds <- function (object, pathname, ...) 
[08:26:20.380]                   {
[08:26:20.380]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:20.380]                     if (file_test("-f", pathname_tmp)) {
[08:26:20.380]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.380]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:20.380]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.380]                         fi_tmp[["mtime"]])
[08:26:20.380]                     }
[08:26:20.380]                     tryCatch({
[08:26:20.380]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:20.380]                     }, error = function(ex) {
[08:26:20.380]                       msg <- conditionMessage(ex)
[08:26:20.380]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.380]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:20.380]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.380]                         fi_tmp[["mtime"]], msg)
[08:26:20.380]                       ex$message <- msg
[08:26:20.380]                       stop(ex)
[08:26:20.380]                     })
[08:26:20.380]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:20.380]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:20.380]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:20.380]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.380]                       fi <- file.info(pathname)
[08:26:20.380]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:20.380]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.380]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:20.380]                         fi[["size"]], fi[["mtime"]])
[08:26:20.380]                       stop(msg)
[08:26:20.380]                     }
[08:26:20.380]                     invisible(pathname)
[08:26:20.380]                   }
[08:26:20.380]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:20.380]                     rootPath = tempdir()) 
[08:26:20.380]                   {
[08:26:20.380]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:20.380]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:20.380]                       tmpdir = path, fileext = ".rds")
[08:26:20.380]                     save_rds(obj, file)
[08:26:20.380]                   }
[08:26:20.380]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:20.380]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.380]                   {
[08:26:20.380]                     inherits <- base::inherits
[08:26:20.380]                     invokeRestart <- base::invokeRestart
[08:26:20.380]                     is.null <- base::is.null
[08:26:20.380]                     muffled <- FALSE
[08:26:20.380]                     if (inherits(cond, "message")) {
[08:26:20.380]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:20.380]                       if (muffled) 
[08:26:20.380]                         invokeRestart("muffleMessage")
[08:26:20.380]                     }
[08:26:20.380]                     else if (inherits(cond, "warning")) {
[08:26:20.380]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:20.380]                       if (muffled) 
[08:26:20.380]                         invokeRestart("muffleWarning")
[08:26:20.380]                     }
[08:26:20.380]                     else if (inherits(cond, "condition")) {
[08:26:20.380]                       if (!is.null(pattern)) {
[08:26:20.380]                         computeRestarts <- base::computeRestarts
[08:26:20.380]                         grepl <- base::grepl
[08:26:20.380]                         restarts <- computeRestarts(cond)
[08:26:20.380]                         for (restart in restarts) {
[08:26:20.380]                           name <- restart$name
[08:26:20.380]                           if (is.null(name)) 
[08:26:20.380]                             next
[08:26:20.380]                           if (!grepl(pattern, name)) 
[08:26:20.380]                             next
[08:26:20.380]                           invokeRestart(restart)
[08:26:20.380]                           muffled <- TRUE
[08:26:20.380]                           break
[08:26:20.380]                         }
[08:26:20.380]                       }
[08:26:20.380]                     }
[08:26:20.380]                     invisible(muffled)
[08:26:20.380]                   }
[08:26:20.380]                   muffleCondition(cond)
[08:26:20.380]                 })
[08:26:20.380]             }))
[08:26:20.380]             future::FutureResult(value = ...future.value$value, 
[08:26:20.380]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.380]                   ...future.rng), globalenv = if (FALSE) 
[08:26:20.380]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:20.380]                     ...future.globalenv.names))
[08:26:20.380]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:20.380]         }, condition = base::local({
[08:26:20.380]             c <- base::c
[08:26:20.380]             inherits <- base::inherits
[08:26:20.380]             invokeRestart <- base::invokeRestart
[08:26:20.380]             length <- base::length
[08:26:20.380]             list <- base::list
[08:26:20.380]             seq.int <- base::seq.int
[08:26:20.380]             signalCondition <- base::signalCondition
[08:26:20.380]             sys.calls <- base::sys.calls
[08:26:20.380]             `[[` <- base::`[[`
[08:26:20.380]             `+` <- base::`+`
[08:26:20.380]             `<<-` <- base::`<<-`
[08:26:20.380]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:20.380]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:20.380]                   3L)]
[08:26:20.380]             }
[08:26:20.380]             function(cond) {
[08:26:20.380]                 is_error <- inherits(cond, "error")
[08:26:20.380]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:20.380]                   NULL)
[08:26:20.380]                 if (is_error) {
[08:26:20.380]                   sessionInformation <- function() {
[08:26:20.380]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:20.380]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:20.380]                       search = base::search(), system = base::Sys.info())
[08:26:20.380]                   }
[08:26:20.380]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.380]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:20.380]                     cond$call), session = sessionInformation(), 
[08:26:20.380]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:20.380]                   signalCondition(cond)
[08:26:20.380]                 }
[08:26:20.380]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:20.380]                 "immediateCondition"))) {
[08:26:20.380]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:20.380]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.380]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:20.380]                   if (TRUE && !signal) {
[08:26:20.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.380]                     {
[08:26:20.380]                       inherits <- base::inherits
[08:26:20.380]                       invokeRestart <- base::invokeRestart
[08:26:20.380]                       is.null <- base::is.null
[08:26:20.380]                       muffled <- FALSE
[08:26:20.380]                       if (inherits(cond, "message")) {
[08:26:20.380]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.380]                         if (muffled) 
[08:26:20.380]                           invokeRestart("muffleMessage")
[08:26:20.380]                       }
[08:26:20.380]                       else if (inherits(cond, "warning")) {
[08:26:20.380]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.380]                         if (muffled) 
[08:26:20.380]                           invokeRestart("muffleWarning")
[08:26:20.380]                       }
[08:26:20.380]                       else if (inherits(cond, "condition")) {
[08:26:20.380]                         if (!is.null(pattern)) {
[08:26:20.380]                           computeRestarts <- base::computeRestarts
[08:26:20.380]                           grepl <- base::grepl
[08:26:20.380]                           restarts <- computeRestarts(cond)
[08:26:20.380]                           for (restart in restarts) {
[08:26:20.380]                             name <- restart$name
[08:26:20.380]                             if (is.null(name)) 
[08:26:20.380]                               next
[08:26:20.380]                             if (!grepl(pattern, name)) 
[08:26:20.380]                               next
[08:26:20.380]                             invokeRestart(restart)
[08:26:20.380]                             muffled <- TRUE
[08:26:20.380]                             break
[08:26:20.380]                           }
[08:26:20.380]                         }
[08:26:20.380]                       }
[08:26:20.380]                       invisible(muffled)
[08:26:20.380]                     }
[08:26:20.380]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.380]                   }
[08:26:20.380]                 }
[08:26:20.380]                 else {
[08:26:20.380]                   if (TRUE) {
[08:26:20.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.380]                     {
[08:26:20.380]                       inherits <- base::inherits
[08:26:20.380]                       invokeRestart <- base::invokeRestart
[08:26:20.380]                       is.null <- base::is.null
[08:26:20.380]                       muffled <- FALSE
[08:26:20.380]                       if (inherits(cond, "message")) {
[08:26:20.380]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.380]                         if (muffled) 
[08:26:20.380]                           invokeRestart("muffleMessage")
[08:26:20.380]                       }
[08:26:20.380]                       else if (inherits(cond, "warning")) {
[08:26:20.380]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.380]                         if (muffled) 
[08:26:20.380]                           invokeRestart("muffleWarning")
[08:26:20.380]                       }
[08:26:20.380]                       else if (inherits(cond, "condition")) {
[08:26:20.380]                         if (!is.null(pattern)) {
[08:26:20.380]                           computeRestarts <- base::computeRestarts
[08:26:20.380]                           grepl <- base::grepl
[08:26:20.380]                           restarts <- computeRestarts(cond)
[08:26:20.380]                           for (restart in restarts) {
[08:26:20.380]                             name <- restart$name
[08:26:20.380]                             if (is.null(name)) 
[08:26:20.380]                               next
[08:26:20.380]                             if (!grepl(pattern, name)) 
[08:26:20.380]                               next
[08:26:20.380]                             invokeRestart(restart)
[08:26:20.380]                             muffled <- TRUE
[08:26:20.380]                             break
[08:26:20.380]                           }
[08:26:20.380]                         }
[08:26:20.380]                       }
[08:26:20.380]                       invisible(muffled)
[08:26:20.380]                     }
[08:26:20.380]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.380]                   }
[08:26:20.380]                 }
[08:26:20.380]             }
[08:26:20.380]         }))
[08:26:20.380]     }, error = function(ex) {
[08:26:20.380]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:20.380]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.380]                 ...future.rng), started = ...future.startTime, 
[08:26:20.380]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:20.380]             version = "1.8"), class = "FutureResult")
[08:26:20.380]     }, finally = {
[08:26:20.380]         if (!identical(...future.workdir, getwd())) 
[08:26:20.380]             setwd(...future.workdir)
[08:26:20.380]         {
[08:26:20.380]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:20.380]                 ...future.oldOptions$nwarnings <- NULL
[08:26:20.380]             }
[08:26:20.380]             base::options(...future.oldOptions)
[08:26:20.380]             if (.Platform$OS.type == "windows") {
[08:26:20.380]                 old_names <- names(...future.oldEnvVars)
[08:26:20.380]                 envs <- base::Sys.getenv()
[08:26:20.380]                 names <- names(envs)
[08:26:20.380]                 common <- intersect(names, old_names)
[08:26:20.380]                 added <- setdiff(names, old_names)
[08:26:20.380]                 removed <- setdiff(old_names, names)
[08:26:20.380]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:20.380]                   envs[common]]
[08:26:20.380]                 NAMES <- toupper(changed)
[08:26:20.380]                 args <- list()
[08:26:20.380]                 for (kk in seq_along(NAMES)) {
[08:26:20.380]                   name <- changed[[kk]]
[08:26:20.380]                   NAME <- NAMES[[kk]]
[08:26:20.380]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.380]                     next
[08:26:20.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.380]                 }
[08:26:20.380]                 NAMES <- toupper(added)
[08:26:20.380]                 for (kk in seq_along(NAMES)) {
[08:26:20.380]                   name <- added[[kk]]
[08:26:20.380]                   NAME <- NAMES[[kk]]
[08:26:20.380]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.380]                     next
[08:26:20.380]                   args[[name]] <- ""
[08:26:20.380]                 }
[08:26:20.380]                 NAMES <- toupper(removed)
[08:26:20.380]                 for (kk in seq_along(NAMES)) {
[08:26:20.380]                   name <- removed[[kk]]
[08:26:20.380]                   NAME <- NAMES[[kk]]
[08:26:20.380]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.380]                     next
[08:26:20.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.380]                 }
[08:26:20.380]                 if (length(args) > 0) 
[08:26:20.380]                   base::do.call(base::Sys.setenv, args = args)
[08:26:20.380]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:20.380]             }
[08:26:20.380]             else {
[08:26:20.380]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:20.380]             }
[08:26:20.380]             {
[08:26:20.380]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:20.380]                   0L) {
[08:26:20.380]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:20.380]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:20.380]                   base::options(opts)
[08:26:20.380]                 }
[08:26:20.380]                 {
[08:26:20.380]                   {
[08:26:20.380]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:20.380]                     NULL
[08:26:20.380]                   }
[08:26:20.380]                   options(future.plan = NULL)
[08:26:20.380]                   if (is.na(NA_character_)) 
[08:26:20.380]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.380]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:20.380]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:20.380]                     .init = FALSE)
[08:26:20.380]                 }
[08:26:20.380]             }
[08:26:20.380]         }
[08:26:20.380]     })
[08:26:20.380]     if (TRUE) {
[08:26:20.380]         base::sink(type = "output", split = FALSE)
[08:26:20.380]         if (TRUE) {
[08:26:20.380]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:20.380]         }
[08:26:20.380]         else {
[08:26:20.380]             ...future.result["stdout"] <- base::list(NULL)
[08:26:20.380]         }
[08:26:20.380]         base::close(...future.stdout)
[08:26:20.380]         ...future.stdout <- NULL
[08:26:20.380]     }
[08:26:20.380]     ...future.result$conditions <- ...future.conditions
[08:26:20.380]     ...future.result$finished <- base::Sys.time()
[08:26:20.380]     ...future.result
[08:26:20.380] }
[08:26:20.384] assign_globals() ...
[08:26:20.384] List of 11
[08:26:20.384]  $ ...future.FUN            :function (x, ...)  
[08:26:20.384]  $ x_FUN                    :function (x)  
[08:26:20.384]  $ times                    : int 4
[08:26:20.384]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:20.384]  $ stop_if_not              :function (...)  
[08:26:20.384]  $ dim                      : int [1:2] 2 2
[08:26:20.384]  $ valid_types              : chr [1:2] "logical" "integer"
[08:26:20.384]  $ future.call.arguments    : list()
[08:26:20.384]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.384]  $ ...future.elements_ii    :List of 5
[08:26:20.384]   ..$ : int 6
[08:26:20.384]   ..$ : int 7
[08:26:20.384]   ..$ : int 8
[08:26:20.384]   ..$ : int 9
[08:26:20.384]   ..$ : int 10
[08:26:20.384]  $ ...future.seeds_ii       : NULL
[08:26:20.384]  $ ...future.globals.maxSize: NULL
[08:26:20.384]  - attr(*, "where")=List of 11
[08:26:20.384]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:20.384]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:20.384]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:20.384]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:20.384]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:20.384]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:20.384]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:20.384]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:20.384]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:20.384]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:20.384]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:20.384]  - attr(*, "resolved")= logi FALSE
[08:26:20.384]  - attr(*, "total_size")= num 24886
[08:26:20.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.384]  - attr(*, "already-done")= logi TRUE
[08:26:20.402] - copied ‘...future.FUN’ to environment
[08:26:20.402] - reassign environment for ‘x_FUN’
[08:26:20.402] - copied ‘x_FUN’ to environment
[08:26:20.402] - copied ‘times’ to environment
[08:26:20.402] - copied ‘stopf’ to environment
[08:26:20.402] - copied ‘stop_if_not’ to environment
[08:26:20.402] - copied ‘dim’ to environment
[08:26:20.402] - copied ‘valid_types’ to environment
[08:26:20.402] - copied ‘future.call.arguments’ to environment
[08:26:20.403] - copied ‘...future.elements_ii’ to environment
[08:26:20.403] - copied ‘...future.seeds_ii’ to environment
[08:26:20.403] - copied ‘...future.globals.maxSize’ to environment
[08:26:20.403] assign_globals() ... done
[08:26:20.403] requestCore(): workers = 2
[08:26:20.405] MulticoreFuture started
[08:26:20.406] - Launch lazy future ... done
[08:26:20.406] run() for ‘MulticoreFuture’ ... done
[08:26:20.406] Created future:
[08:26:20.407] plan(): Setting new future strategy stack:
[08:26:20.407] List of future strategies:
[08:26:20.407] 1. sequential:
[08:26:20.407]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:20.407]    - tweaked: FALSE
[08:26:20.407]    - call: NULL
[08:26:20.408] plan(): nbrOfWorkers() = 1
[08:26:20.411] plan(): Setting new future strategy stack:
[08:26:20.411] List of future strategies:
[08:26:20.411] 1. multicore:
[08:26:20.411]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:20.411]    - tweaked: FALSE
[08:26:20.411]    - call: plan(strategy)
[08:26:20.414] plan(): nbrOfWorkers() = 2
[08:26:20.407] MulticoreFuture:
[08:26:20.407] Label: ‘future_vapply-2’
[08:26:20.407] Expression:
[08:26:20.407] {
[08:26:20.407]     do.call(function(...) {
[08:26:20.407]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.407]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.407]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.407]             on.exit(options(oopts), add = TRUE)
[08:26:20.407]         }
[08:26:20.407]         {
[08:26:20.407]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.407]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.407]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.407]             })
[08:26:20.407]         }
[08:26:20.407]     }, args = future.call.arguments)
[08:26:20.407] }
[08:26:20.407] Lazy evaluation: FALSE
[08:26:20.407] Asynchronous evaluation: TRUE
[08:26:20.407] Local evaluation: TRUE
[08:26:20.407] Environment: R_GlobalEnv
[08:26:20.407] Capture standard output: TRUE
[08:26:20.407] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:20.407] Globals: 11 objects totaling 13.82 KiB (function ‘...future.FUN’ of 5.05 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:20.407] Packages: 1 packages (‘future.apply’)
[08:26:20.407] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:20.407] Resolved: TRUE
[08:26:20.407] Value: <not collected>
[08:26:20.407] Conditions captured: <none>
[08:26:20.407] Early signaling: FALSE
[08:26:20.407] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:20.407] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.415] Chunk #2 of 2 ... DONE
[08:26:20.415] Launching 2 futures (chunks) ... DONE
[08:26:20.416] Resolving 2 futures (chunks) ...
[08:26:20.416] resolve() on list ...
[08:26:20.416]  recursive: 0
[08:26:20.416]  length: 2
[08:26:20.416] 
[08:26:20.417] Future #1
[08:26:20.417] result() for MulticoreFuture ...
[08:26:20.418] result() for MulticoreFuture ...
[08:26:20.418] result() for MulticoreFuture ... done
[08:26:20.418] result() for MulticoreFuture ... done
[08:26:20.418] result() for MulticoreFuture ...
[08:26:20.418] result() for MulticoreFuture ... done
[08:26:20.418] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:26:20.418] - nx: 2
[08:26:20.419] - relay: TRUE
[08:26:20.419] - stdout: TRUE
[08:26:20.419] - signal: TRUE
[08:26:20.419] - resignal: FALSE
[08:26:20.419] - force: TRUE
[08:26:20.419] - relayed: [n=2] FALSE, FALSE
[08:26:20.419] - queued futures: [n=2] FALSE, FALSE
[08:26:20.420]  - until=1
[08:26:20.420]  - relaying element #1
[08:26:20.420] result() for MulticoreFuture ...
[08:26:20.420] result() for MulticoreFuture ... done
[08:26:20.420] result() for MulticoreFuture ...
[08:26:20.420] result() for MulticoreFuture ... done
[08:26:20.421] result() for MulticoreFuture ...
[08:26:20.421] result() for MulticoreFuture ... done
[08:26:20.421] result() for MulticoreFuture ...
[08:26:20.421] result() for MulticoreFuture ... done
[08:26:20.421] - relayed: [n=2] TRUE, FALSE
[08:26:20.421] - queued futures: [n=2] TRUE, FALSE
[08:26:20.421] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:26:20.422]  length: 1 (resolved future 1)
[08:26:20.422] Future #2
[08:26:20.422] result() for MulticoreFuture ...
[08:26:20.423] result() for MulticoreFuture ...
[08:26:20.423] result() for MulticoreFuture ... done
[08:26:20.423] result() for MulticoreFuture ... done
[08:26:20.423] result() for MulticoreFuture ...
[08:26:20.423] result() for MulticoreFuture ... done
[08:26:20.424] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:26:20.424] - nx: 2
[08:26:20.424] - relay: TRUE
[08:26:20.424] - stdout: TRUE
[08:26:20.424] - signal: TRUE
[08:26:20.424] - resignal: FALSE
[08:26:20.424] - force: TRUE
[08:26:20.425] - relayed: [n=2] TRUE, FALSE
[08:26:20.425] - queued futures: [n=2] TRUE, FALSE
[08:26:20.425]  - until=2
[08:26:20.425]  - relaying element #2
[08:26:20.425] result() for MulticoreFuture ...
[08:26:20.425] result() for MulticoreFuture ... done
[08:26:20.425] result() for MulticoreFuture ...
[08:26:20.425] result() for MulticoreFuture ... done
[08:26:20.426] result() for MulticoreFuture ...
[08:26:20.426] result() for MulticoreFuture ... done
[08:26:20.426] result() for MulticoreFuture ...
[08:26:20.426] result() for MulticoreFuture ... done
[08:26:20.426] - relayed: [n=2] TRUE, TRUE
[08:26:20.426] - queued futures: [n=2] TRUE, TRUE
[08:26:20.426] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:26:20.426]  length: 0 (resolved future 2)
[08:26:20.427] Relaying remaining futures
[08:26:20.427] signalConditionsASAP(NULL, pos=0) ...
[08:26:20.427] - nx: 2
[08:26:20.427] - relay: TRUE
[08:26:20.427] - stdout: TRUE
[08:26:20.427] - signal: TRUE
[08:26:20.427] - resignal: FALSE
[08:26:20.427] - force: TRUE
[08:26:20.427] - relayed: [n=2] TRUE, TRUE
[08:26:20.427] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:20.428] - relayed: [n=2] TRUE, TRUE
[08:26:20.428] - queued futures: [n=2] TRUE, TRUE
[08:26:20.428] signalConditionsASAP(NULL, pos=0) ... done
[08:26:20.428] resolve() on list ... DONE
[08:26:20.428] result() for MulticoreFuture ...
[08:26:20.428] result() for MulticoreFuture ... done
[08:26:20.428] result() for MulticoreFuture ...
[08:26:20.428] result() for MulticoreFuture ... done
[08:26:20.429] result() for MulticoreFuture ...
[08:26:20.429] result() for MulticoreFuture ... done
[08:26:20.429] result() for MulticoreFuture ...
[08:26:20.429] result() for MulticoreFuture ... done
[08:26:20.429]  - Number of value chunks collected: 2
[08:26:20.429] Resolving 2 futures (chunks) ... DONE
[08:26:20.429] Reducing values from 2 chunks ...
[08:26:20.429]  - Number of values collected after concatenation: 10
[08:26:20.429]  - Number of values expected: 10
[08:26:20.430] Reducing values from 2 chunks ... DONE
[08:26:20.430] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[08:26:20.431] future_lapply() ...
[08:26:20.439] Number of chunks: 2
[08:26:20.439] getGlobalsAndPackagesXApply() ...
[08:26:20.439]  - future.globals: TRUE
[08:26:20.439] getGlobalsAndPackages() ...
[08:26:20.439] Searching for globals...
[08:26:20.444] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[08:26:20.444] Searching for globals ... DONE
[08:26:20.444] Resolving globals: FALSE
[08:26:20.445] The total size of the 7 globals is 13.63 KiB (13957 bytes)
[08:26:20.445] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.63 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.09 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:20.445] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:20.445] - packages: [1] ‘future.apply’
[08:26:20.446] getGlobalsAndPackages() ... DONE
[08:26:20.446]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:20.446]  - needed namespaces: [n=1] ‘future.apply’
[08:26:20.446] Finding globals ... DONE
[08:26:20.446]  - use_args: TRUE
[08:26:20.446]  - Getting '...' globals ...
[08:26:20.446] resolve() on list ...
[08:26:20.447]  recursive: 0
[08:26:20.447]  length: 1
[08:26:20.447]  elements: ‘...’
[08:26:20.447]  length: 0 (resolved future 1)
[08:26:20.447] resolve() on list ... DONE
[08:26:20.447]    - '...' content: [n=0] 
[08:26:20.447] List of 1
[08:26:20.447]  $ ...: list()
[08:26:20.447]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.447]  - attr(*, "where")=List of 1
[08:26:20.447]   ..$ ...:<environment: 0x562ca7d86f20> 
[08:26:20.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.447]  - attr(*, "resolved")= logi TRUE
[08:26:20.447]  - attr(*, "total_size")= num NA
[08:26:20.450]  - Getting '...' globals ... DONE
[08:26:20.450] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:20.450] List of 8
[08:26:20.450]  $ ...future.FUN:function (x, ...)  
[08:26:20.450]  $ x_FUN        :function (x)  
[08:26:20.450]  $ times        : int 4
[08:26:20.450]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:20.450]  $ stop_if_not  :function (...)  
[08:26:20.450]  $ dim          : int [1:2] 2 2
[08:26:20.450]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:20.450]  $ ...          : list()
[08:26:20.450]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.450]  - attr(*, "where")=List of 8
[08:26:20.450]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:20.450]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:20.450]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:20.450]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:20.450]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:20.450]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:20.450]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:20.450]   ..$ ...          :<environment: 0x562ca7d86f20> 
[08:26:20.450]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.450]  - attr(*, "resolved")= logi FALSE
[08:26:20.450]  - attr(*, "total_size")= num 24958
[08:26:20.458] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:20.458] getGlobalsAndPackagesXApply() ... DONE
[08:26:20.458] Number of futures (= number of chunks): 2
[08:26:20.458] Launching 2 futures (chunks) ...
[08:26:20.458] Chunk #1 of 2 ...
[08:26:20.459]  - Finding globals in 'X' for chunk #1 ...
[08:26:20.459] getGlobalsAndPackages() ...
[08:26:20.459] Searching for globals...
[08:26:20.459] 
[08:26:20.459] Searching for globals ... DONE
[08:26:20.459] - globals: [0] <none>
[08:26:20.459] getGlobalsAndPackages() ... DONE
[08:26:20.459]    + additional globals found: [n=0] 
[08:26:20.460]    + additional namespaces needed: [n=0] 
[08:26:20.460]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:20.460]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:20.460]  - seeds: <none>
[08:26:20.460]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.460] getGlobalsAndPackages() ...
[08:26:20.460] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.460] Resolving globals: FALSE
[08:26:20.461] Tweak future expression to call with '...' arguments ...
[08:26:20.461] {
[08:26:20.461]     do.call(function(...) {
[08:26:20.461]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.461]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.461]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.461]             on.exit(options(oopts), add = TRUE)
[08:26:20.461]         }
[08:26:20.461]         {
[08:26:20.461]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.461]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.461]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.461]             })
[08:26:20.461]         }
[08:26:20.461]     }, args = future.call.arguments)
[08:26:20.461] }
[08:26:20.461] Tweak future expression to call with '...' arguments ... DONE
[08:26:20.461] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.462] - packages: [1] ‘future.apply’
[08:26:20.462] getGlobalsAndPackages() ... DONE
[08:26:20.462] run() for ‘Future’ ...
[08:26:20.462] - state: ‘created’
[08:26:20.462] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:20.464] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.464] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:20.464]   - Field: ‘label’
[08:26:20.464]   - Field: ‘local’
[08:26:20.464]   - Field: ‘owner’
[08:26:20.464]   - Field: ‘envir’
[08:26:20.465]   - Field: ‘workers’
[08:26:20.465]   - Field: ‘packages’
[08:26:20.465]   - Field: ‘gc’
[08:26:20.465]   - Field: ‘job’
[08:26:20.465]   - Field: ‘conditions’
[08:26:20.465]   - Field: ‘expr’
[08:26:20.465]   - Field: ‘uuid’
[08:26:20.465]   - Field: ‘seed’
[08:26:20.465]   - Field: ‘version’
[08:26:20.465]   - Field: ‘result’
[08:26:20.465]   - Field: ‘asynchronous’
[08:26:20.466]   - Field: ‘calls’
[08:26:20.466]   - Field: ‘globals’
[08:26:20.466]   - Field: ‘stdout’
[08:26:20.466]   - Field: ‘earlySignal’
[08:26:20.466]   - Field: ‘lazy’
[08:26:20.466]   - Field: ‘state’
[08:26:20.466] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:20.466] - Launch lazy future ...
[08:26:20.466] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:20.467] Packages needed by future strategies (n = 0): <none>
[08:26:20.467] {
[08:26:20.467]     {
[08:26:20.467]         {
[08:26:20.467]             ...future.startTime <- base::Sys.time()
[08:26:20.467]             {
[08:26:20.467]                 {
[08:26:20.467]                   {
[08:26:20.467]                     {
[08:26:20.467]                       {
[08:26:20.467]                         base::local({
[08:26:20.467]                           has_future <- base::requireNamespace("future", 
[08:26:20.467]                             quietly = TRUE)
[08:26:20.467]                           if (has_future) {
[08:26:20.467]                             ns <- base::getNamespace("future")
[08:26:20.467]                             version <- ns[[".package"]][["version"]]
[08:26:20.467]                             if (is.null(version)) 
[08:26:20.467]                               version <- utils::packageVersion("future")
[08:26:20.467]                           }
[08:26:20.467]                           else {
[08:26:20.467]                             version <- NULL
[08:26:20.467]                           }
[08:26:20.467]                           if (!has_future || version < "1.8.0") {
[08:26:20.467]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:20.467]                               "", base::R.version$version.string), 
[08:26:20.467]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:20.467]                                 base::R.version$platform, 8 * 
[08:26:20.467]                                   base::.Machine$sizeof.pointer), 
[08:26:20.467]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:20.467]                                 "release", "version")], collapse = " "), 
[08:26:20.467]                               hostname = base::Sys.info()[["nodename"]])
[08:26:20.467]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:20.467]                               info)
[08:26:20.467]                             info <- base::paste(info, collapse = "; ")
[08:26:20.467]                             if (!has_future) {
[08:26:20.467]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:20.467]                                 info)
[08:26:20.467]                             }
[08:26:20.467]                             else {
[08:26:20.467]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:20.467]                                 info, version)
[08:26:20.467]                             }
[08:26:20.467]                             base::stop(msg)
[08:26:20.467]                           }
[08:26:20.467]                         })
[08:26:20.467]                       }
[08:26:20.467]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:20.467]                       base::options(mc.cores = 1L)
[08:26:20.467]                     }
[08:26:20.467]                     base::local({
[08:26:20.467]                       for (pkg in "future.apply") {
[08:26:20.467]                         base::loadNamespace(pkg)
[08:26:20.467]                         base::library(pkg, character.only = TRUE)
[08:26:20.467]                       }
[08:26:20.467]                     })
[08:26:20.467]                   }
[08:26:20.467]                   ...future.strategy.old <- future::plan("list")
[08:26:20.467]                   options(future.plan = NULL)
[08:26:20.467]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.467]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:20.467]                 }
[08:26:20.467]                 ...future.workdir <- getwd()
[08:26:20.467]             }
[08:26:20.467]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:20.467]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:20.467]         }
[08:26:20.467]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:20.467]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:20.467]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:20.467]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:20.467]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:20.467]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:20.467]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:20.467]             base::names(...future.oldOptions))
[08:26:20.467]     }
[08:26:20.467]     if (FALSE) {
[08:26:20.467]     }
[08:26:20.467]     else {
[08:26:20.467]         if (TRUE) {
[08:26:20.467]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:20.467]                 open = "w")
[08:26:20.467]         }
[08:26:20.467]         else {
[08:26:20.467]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:20.467]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:20.467]         }
[08:26:20.467]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:20.467]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:20.467]             base::sink(type = "output", split = FALSE)
[08:26:20.467]             base::close(...future.stdout)
[08:26:20.467]         }, add = TRUE)
[08:26:20.467]     }
[08:26:20.467]     ...future.frame <- base::sys.nframe()
[08:26:20.467]     ...future.conditions <- base::list()
[08:26:20.467]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:20.467]     if (FALSE) {
[08:26:20.467]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:20.467]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:20.467]     }
[08:26:20.467]     ...future.result <- base::tryCatch({
[08:26:20.467]         base::withCallingHandlers({
[08:26:20.467]             ...future.value <- base::withVisible(base::local({
[08:26:20.467]                 withCallingHandlers({
[08:26:20.467]                   {
[08:26:20.467]                     do.call(function(...) {
[08:26:20.467]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.467]                       if (!identical(...future.globals.maxSize.org, 
[08:26:20.467]                         ...future.globals.maxSize)) {
[08:26:20.467]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.467]                         on.exit(options(oopts), add = TRUE)
[08:26:20.467]                       }
[08:26:20.467]                       {
[08:26:20.467]                         lapply(seq_along(...future.elements_ii), 
[08:26:20.467]                           FUN = function(jj) {
[08:26:20.467]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.467]                             ...future.FUN(...future.X_jj, ...)
[08:26:20.467]                           })
[08:26:20.467]                       }
[08:26:20.467]                     }, args = future.call.arguments)
[08:26:20.467]                   }
[08:26:20.467]                 }, immediateCondition = function(cond) {
[08:26:20.467]                   save_rds <- function (object, pathname, ...) 
[08:26:20.467]                   {
[08:26:20.467]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:20.467]                     if (file_test("-f", pathname_tmp)) {
[08:26:20.467]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.467]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:20.467]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.467]                         fi_tmp[["mtime"]])
[08:26:20.467]                     }
[08:26:20.467]                     tryCatch({
[08:26:20.467]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:20.467]                     }, error = function(ex) {
[08:26:20.467]                       msg <- conditionMessage(ex)
[08:26:20.467]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.467]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:20.467]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.467]                         fi_tmp[["mtime"]], msg)
[08:26:20.467]                       ex$message <- msg
[08:26:20.467]                       stop(ex)
[08:26:20.467]                     })
[08:26:20.467]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:20.467]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:20.467]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:20.467]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.467]                       fi <- file.info(pathname)
[08:26:20.467]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:20.467]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.467]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:20.467]                         fi[["size"]], fi[["mtime"]])
[08:26:20.467]                       stop(msg)
[08:26:20.467]                     }
[08:26:20.467]                     invisible(pathname)
[08:26:20.467]                   }
[08:26:20.467]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:20.467]                     rootPath = tempdir()) 
[08:26:20.467]                   {
[08:26:20.467]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:20.467]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:20.467]                       tmpdir = path, fileext = ".rds")
[08:26:20.467]                     save_rds(obj, file)
[08:26:20.467]                   }
[08:26:20.467]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:20.467]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.467]                   {
[08:26:20.467]                     inherits <- base::inherits
[08:26:20.467]                     invokeRestart <- base::invokeRestart
[08:26:20.467]                     is.null <- base::is.null
[08:26:20.467]                     muffled <- FALSE
[08:26:20.467]                     if (inherits(cond, "message")) {
[08:26:20.467]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:20.467]                       if (muffled) 
[08:26:20.467]                         invokeRestart("muffleMessage")
[08:26:20.467]                     }
[08:26:20.467]                     else if (inherits(cond, "warning")) {
[08:26:20.467]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:20.467]                       if (muffled) 
[08:26:20.467]                         invokeRestart("muffleWarning")
[08:26:20.467]                     }
[08:26:20.467]                     else if (inherits(cond, "condition")) {
[08:26:20.467]                       if (!is.null(pattern)) {
[08:26:20.467]                         computeRestarts <- base::computeRestarts
[08:26:20.467]                         grepl <- base::grepl
[08:26:20.467]                         restarts <- computeRestarts(cond)
[08:26:20.467]                         for (restart in restarts) {
[08:26:20.467]                           name <- restart$name
[08:26:20.467]                           if (is.null(name)) 
[08:26:20.467]                             next
[08:26:20.467]                           if (!grepl(pattern, name)) 
[08:26:20.467]                             next
[08:26:20.467]                           invokeRestart(restart)
[08:26:20.467]                           muffled <- TRUE
[08:26:20.467]                           break
[08:26:20.467]                         }
[08:26:20.467]                       }
[08:26:20.467]                     }
[08:26:20.467]                     invisible(muffled)
[08:26:20.467]                   }
[08:26:20.467]                   muffleCondition(cond)
[08:26:20.467]                 })
[08:26:20.467]             }))
[08:26:20.467]             future::FutureResult(value = ...future.value$value, 
[08:26:20.467]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.467]                   ...future.rng), globalenv = if (FALSE) 
[08:26:20.467]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:20.467]                     ...future.globalenv.names))
[08:26:20.467]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:20.467]         }, condition = base::local({
[08:26:20.467]             c <- base::c
[08:26:20.467]             inherits <- base::inherits
[08:26:20.467]             invokeRestart <- base::invokeRestart
[08:26:20.467]             length <- base::length
[08:26:20.467]             list <- base::list
[08:26:20.467]             seq.int <- base::seq.int
[08:26:20.467]             signalCondition <- base::signalCondition
[08:26:20.467]             sys.calls <- base::sys.calls
[08:26:20.467]             `[[` <- base::`[[`
[08:26:20.467]             `+` <- base::`+`
[08:26:20.467]             `<<-` <- base::`<<-`
[08:26:20.467]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:20.467]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:20.467]                   3L)]
[08:26:20.467]             }
[08:26:20.467]             function(cond) {
[08:26:20.467]                 is_error <- inherits(cond, "error")
[08:26:20.467]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:20.467]                   NULL)
[08:26:20.467]                 if (is_error) {
[08:26:20.467]                   sessionInformation <- function() {
[08:26:20.467]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:20.467]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:20.467]                       search = base::search(), system = base::Sys.info())
[08:26:20.467]                   }
[08:26:20.467]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.467]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:20.467]                     cond$call), session = sessionInformation(), 
[08:26:20.467]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:20.467]                   signalCondition(cond)
[08:26:20.467]                 }
[08:26:20.467]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:20.467]                 "immediateCondition"))) {
[08:26:20.467]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:20.467]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.467]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:20.467]                   if (TRUE && !signal) {
[08:26:20.467]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.467]                     {
[08:26:20.467]                       inherits <- base::inherits
[08:26:20.467]                       invokeRestart <- base::invokeRestart
[08:26:20.467]                       is.null <- base::is.null
[08:26:20.467]                       muffled <- FALSE
[08:26:20.467]                       if (inherits(cond, "message")) {
[08:26:20.467]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.467]                         if (muffled) 
[08:26:20.467]                           invokeRestart("muffleMessage")
[08:26:20.467]                       }
[08:26:20.467]                       else if (inherits(cond, "warning")) {
[08:26:20.467]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.467]                         if (muffled) 
[08:26:20.467]                           invokeRestart("muffleWarning")
[08:26:20.467]                       }
[08:26:20.467]                       else if (inherits(cond, "condition")) {
[08:26:20.467]                         if (!is.null(pattern)) {
[08:26:20.467]                           computeRestarts <- base::computeRestarts
[08:26:20.467]                           grepl <- base::grepl
[08:26:20.467]                           restarts <- computeRestarts(cond)
[08:26:20.467]                           for (restart in restarts) {
[08:26:20.467]                             name <- restart$name
[08:26:20.467]                             if (is.null(name)) 
[08:26:20.467]                               next
[08:26:20.467]                             if (!grepl(pattern, name)) 
[08:26:20.467]                               next
[08:26:20.467]                             invokeRestart(restart)
[08:26:20.467]                             muffled <- TRUE
[08:26:20.467]                             break
[08:26:20.467]                           }
[08:26:20.467]                         }
[08:26:20.467]                       }
[08:26:20.467]                       invisible(muffled)
[08:26:20.467]                     }
[08:26:20.467]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.467]                   }
[08:26:20.467]                 }
[08:26:20.467]                 else {
[08:26:20.467]                   if (TRUE) {
[08:26:20.467]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.467]                     {
[08:26:20.467]                       inherits <- base::inherits
[08:26:20.467]                       invokeRestart <- base::invokeRestart
[08:26:20.467]                       is.null <- base::is.null
[08:26:20.467]                       muffled <- FALSE
[08:26:20.467]                       if (inherits(cond, "message")) {
[08:26:20.467]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.467]                         if (muffled) 
[08:26:20.467]                           invokeRestart("muffleMessage")
[08:26:20.467]                       }
[08:26:20.467]                       else if (inherits(cond, "warning")) {
[08:26:20.467]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.467]                         if (muffled) 
[08:26:20.467]                           invokeRestart("muffleWarning")
[08:26:20.467]                       }
[08:26:20.467]                       else if (inherits(cond, "condition")) {
[08:26:20.467]                         if (!is.null(pattern)) {
[08:26:20.467]                           computeRestarts <- base::computeRestarts
[08:26:20.467]                           grepl <- base::grepl
[08:26:20.467]                           restarts <- computeRestarts(cond)
[08:26:20.467]                           for (restart in restarts) {
[08:26:20.467]                             name <- restart$name
[08:26:20.467]                             if (is.null(name)) 
[08:26:20.467]                               next
[08:26:20.467]                             if (!grepl(pattern, name)) 
[08:26:20.467]                               next
[08:26:20.467]                             invokeRestart(restart)
[08:26:20.467]                             muffled <- TRUE
[08:26:20.467]                             break
[08:26:20.467]                           }
[08:26:20.467]                         }
[08:26:20.467]                       }
[08:26:20.467]                       invisible(muffled)
[08:26:20.467]                     }
[08:26:20.467]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.467]                   }
[08:26:20.467]                 }
[08:26:20.467]             }
[08:26:20.467]         }))
[08:26:20.467]     }, error = function(ex) {
[08:26:20.467]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:20.467]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.467]                 ...future.rng), started = ...future.startTime, 
[08:26:20.467]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:20.467]             version = "1.8"), class = "FutureResult")
[08:26:20.467]     }, finally = {
[08:26:20.467]         if (!identical(...future.workdir, getwd())) 
[08:26:20.467]             setwd(...future.workdir)
[08:26:20.467]         {
[08:26:20.467]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:20.467]                 ...future.oldOptions$nwarnings <- NULL
[08:26:20.467]             }
[08:26:20.467]             base::options(...future.oldOptions)
[08:26:20.467]             if (.Platform$OS.type == "windows") {
[08:26:20.467]                 old_names <- names(...future.oldEnvVars)
[08:26:20.467]                 envs <- base::Sys.getenv()
[08:26:20.467]                 names <- names(envs)
[08:26:20.467]                 common <- intersect(names, old_names)
[08:26:20.467]                 added <- setdiff(names, old_names)
[08:26:20.467]                 removed <- setdiff(old_names, names)
[08:26:20.467]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:20.467]                   envs[common]]
[08:26:20.467]                 NAMES <- toupper(changed)
[08:26:20.467]                 args <- list()
[08:26:20.467]                 for (kk in seq_along(NAMES)) {
[08:26:20.467]                   name <- changed[[kk]]
[08:26:20.467]                   NAME <- NAMES[[kk]]
[08:26:20.467]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.467]                     next
[08:26:20.467]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.467]                 }
[08:26:20.467]                 NAMES <- toupper(added)
[08:26:20.467]                 for (kk in seq_along(NAMES)) {
[08:26:20.467]                   name <- added[[kk]]
[08:26:20.467]                   NAME <- NAMES[[kk]]
[08:26:20.467]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.467]                     next
[08:26:20.467]                   args[[name]] <- ""
[08:26:20.467]                 }
[08:26:20.467]                 NAMES <- toupper(removed)
[08:26:20.467]                 for (kk in seq_along(NAMES)) {
[08:26:20.467]                   name <- removed[[kk]]
[08:26:20.467]                   NAME <- NAMES[[kk]]
[08:26:20.467]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.467]                     next
[08:26:20.467]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.467]                 }
[08:26:20.467]                 if (length(args) > 0) 
[08:26:20.467]                   base::do.call(base::Sys.setenv, args = args)
[08:26:20.467]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:20.467]             }
[08:26:20.467]             else {
[08:26:20.467]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:20.467]             }
[08:26:20.467]             {
[08:26:20.467]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:20.467]                   0L) {
[08:26:20.467]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:20.467]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:20.467]                   base::options(opts)
[08:26:20.467]                 }
[08:26:20.467]                 {
[08:26:20.467]                   {
[08:26:20.467]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:20.467]                     NULL
[08:26:20.467]                   }
[08:26:20.467]                   options(future.plan = NULL)
[08:26:20.467]                   if (is.na(NA_character_)) 
[08:26:20.467]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.467]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:20.467]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:20.467]                     .init = FALSE)
[08:26:20.467]                 }
[08:26:20.467]             }
[08:26:20.467]         }
[08:26:20.467]     })
[08:26:20.467]     if (TRUE) {
[08:26:20.467]         base::sink(type = "output", split = FALSE)
[08:26:20.467]         if (TRUE) {
[08:26:20.467]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:20.467]         }
[08:26:20.467]         else {
[08:26:20.467]             ...future.result["stdout"] <- base::list(NULL)
[08:26:20.467]         }
[08:26:20.467]         base::close(...future.stdout)
[08:26:20.467]         ...future.stdout <- NULL
[08:26:20.467]     }
[08:26:20.467]     ...future.result$conditions <- ...future.conditions
[08:26:20.467]     ...future.result$finished <- base::Sys.time()
[08:26:20.467]     ...future.result
[08:26:20.467] }
[08:26:20.470] assign_globals() ...
[08:26:20.470] List of 11
[08:26:20.470]  $ ...future.FUN            :function (x, ...)  
[08:26:20.470]  $ x_FUN                    :function (x)  
[08:26:20.470]  $ times                    : int 4
[08:26:20.470]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:20.470]  $ stop_if_not              :function (...)  
[08:26:20.470]  $ dim                      : int [1:2] 2 2
[08:26:20.470]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:20.470]  $ future.call.arguments    : list()
[08:26:20.470]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.470]  $ ...future.elements_ii    :List of 5
[08:26:20.470]   ..$ : int 1
[08:26:20.470]   ..$ : int 2
[08:26:20.470]   ..$ : int 3
[08:26:20.470]   ..$ : int 4
[08:26:20.470]   ..$ : int 5
[08:26:20.470]  $ ...future.seeds_ii       : NULL
[08:26:20.470]  $ ...future.globals.maxSize: NULL
[08:26:20.470]  - attr(*, "where")=List of 11
[08:26:20.470]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:20.470]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:20.470]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:20.470]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:20.470]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:20.470]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:20.470]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:20.470]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:20.470]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:20.470]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:20.470]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:20.470]  - attr(*, "resolved")= logi FALSE
[08:26:20.470]  - attr(*, "total_size")= num 24958
[08:26:20.470]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.470]  - attr(*, "already-done")= logi TRUE
[08:26:20.483] - copied ‘...future.FUN’ to environment
[08:26:20.483] - reassign environment for ‘x_FUN’
[08:26:20.483] - copied ‘x_FUN’ to environment
[08:26:20.483] - copied ‘times’ to environment
[08:26:20.483] - copied ‘stopf’ to environment
[08:26:20.483] - copied ‘stop_if_not’ to environment
[08:26:20.483] - copied ‘dim’ to environment
[08:26:20.483] - copied ‘valid_types’ to environment
[08:26:20.483] - copied ‘future.call.arguments’ to environment
[08:26:20.484] - copied ‘...future.elements_ii’ to environment
[08:26:20.484] - copied ‘...future.seeds_ii’ to environment
[08:26:20.484] - copied ‘...future.globals.maxSize’ to environment
[08:26:20.484] assign_globals() ... done
[08:26:20.484] requestCore(): workers = 2
[08:26:20.487] MulticoreFuture started
[08:26:20.487] - Launch lazy future ... done
[08:26:20.488] run() for ‘MulticoreFuture’ ... done
[08:26:20.488] Created future:
[08:26:20.488] plan(): Setting new future strategy stack:
[08:26:20.489] List of future strategies:
[08:26:20.489] 1. sequential:
[08:26:20.489]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:20.489]    - tweaked: FALSE
[08:26:20.489]    - call: NULL
[08:26:20.491] plan(): nbrOfWorkers() = 1
[08:26:20.494] plan(): Setting new future strategy stack:
[08:26:20.494] List of future strategies:
[08:26:20.494] 1. multicore:
[08:26:20.494]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:20.494]    - tweaked: FALSE
[08:26:20.494]    - call: plan(strategy)
[08:26:20.499] plan(): nbrOfWorkers() = 2
[08:26:20.489] MulticoreFuture:
[08:26:20.489] Label: ‘future_vapply-1’
[08:26:20.489] Expression:
[08:26:20.489] {
[08:26:20.489]     do.call(function(...) {
[08:26:20.489]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.489]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.489]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.489]             on.exit(options(oopts), add = TRUE)
[08:26:20.489]         }
[08:26:20.489]         {
[08:26:20.489]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.489]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.489]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.489]             })
[08:26:20.489]         }
[08:26:20.489]     }, args = future.call.arguments)
[08:26:20.489] }
[08:26:20.489] Lazy evaluation: FALSE
[08:26:20.489] Asynchronous evaluation: TRUE
[08:26:20.489] Local evaluation: TRUE
[08:26:20.489] Environment: R_GlobalEnv
[08:26:20.489] Capture standard output: TRUE
[08:26:20.489] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:20.489] Globals: 11 objects totaling 13.86 KiB (function ‘...future.FUN’ of 5.08 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:20.489] Packages: 1 packages (‘future.apply’)
[08:26:20.489] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:20.489] Resolved: TRUE
[08:26:20.489] Value: <not collected>
[08:26:20.489] Conditions captured: <none>
[08:26:20.489] Early signaling: FALSE
[08:26:20.489] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:20.489] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.500] Chunk #1 of 2 ... DONE
[08:26:20.501] Chunk #2 of 2 ...
[08:26:20.501]  - Finding globals in 'X' for chunk #2 ...
[08:26:20.501] getGlobalsAndPackages() ...
[08:26:20.501] Searching for globals...
[08:26:20.502] 
[08:26:20.502] Searching for globals ... DONE
[08:26:20.503] - globals: [0] <none>
[08:26:20.503] getGlobalsAndPackages() ... DONE
[08:26:20.503]    + additional globals found: [n=0] 
[08:26:20.503]    + additional namespaces needed: [n=0] 
[08:26:20.503]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:20.504]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:20.504]  - seeds: <none>
[08:26:20.504]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.504] getGlobalsAndPackages() ...
[08:26:20.504] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.504] Resolving globals: FALSE
[08:26:20.505] Tweak future expression to call with '...' arguments ...
[08:26:20.505] {
[08:26:20.505]     do.call(function(...) {
[08:26:20.505]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.505]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.505]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.505]             on.exit(options(oopts), add = TRUE)
[08:26:20.505]         }
[08:26:20.505]         {
[08:26:20.505]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.505]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.505]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.505]             })
[08:26:20.505]         }
[08:26:20.505]     }, args = future.call.arguments)
[08:26:20.505] }
[08:26:20.505] Tweak future expression to call with '...' arguments ... DONE
[08:26:20.506] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.506] - packages: [1] ‘future.apply’
[08:26:20.506] getGlobalsAndPackages() ... DONE
[08:26:20.507] run() for ‘Future’ ...
[08:26:20.507] - state: ‘created’
[08:26:20.508] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:20.510] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.510] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:20.511]   - Field: ‘label’
[08:26:20.511]   - Field: ‘local’
[08:26:20.511]   - Field: ‘owner’
[08:26:20.511]   - Field: ‘envir’
[08:26:20.511]   - Field: ‘workers’
[08:26:20.511]   - Field: ‘packages’
[08:26:20.512]   - Field: ‘gc’
[08:26:20.512]   - Field: ‘job’
[08:26:20.512]   - Field: ‘conditions’
[08:26:20.512]   - Field: ‘expr’
[08:26:20.512]   - Field: ‘uuid’
[08:26:20.512]   - Field: ‘seed’
[08:26:20.512]   - Field: ‘version’
[08:26:20.512]   - Field: ‘result’
[08:26:20.513]   - Field: ‘asynchronous’
[08:26:20.513]   - Field: ‘calls’
[08:26:20.513]   - Field: ‘globals’
[08:26:20.513]   - Field: ‘stdout’
[08:26:20.513]   - Field: ‘earlySignal’
[08:26:20.513]   - Field: ‘lazy’
[08:26:20.513]   - Field: ‘state’
[08:26:20.514] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:20.514] - Launch lazy future ...
[08:26:20.514] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:20.514] Packages needed by future strategies (n = 0): <none>
[08:26:20.515] {
[08:26:20.515]     {
[08:26:20.515]         {
[08:26:20.515]             ...future.startTime <- base::Sys.time()
[08:26:20.515]             {
[08:26:20.515]                 {
[08:26:20.515]                   {
[08:26:20.515]                     {
[08:26:20.515]                       {
[08:26:20.515]                         base::local({
[08:26:20.515]                           has_future <- base::requireNamespace("future", 
[08:26:20.515]                             quietly = TRUE)
[08:26:20.515]                           if (has_future) {
[08:26:20.515]                             ns <- base::getNamespace("future")
[08:26:20.515]                             version <- ns[[".package"]][["version"]]
[08:26:20.515]                             if (is.null(version)) 
[08:26:20.515]                               version <- utils::packageVersion("future")
[08:26:20.515]                           }
[08:26:20.515]                           else {
[08:26:20.515]                             version <- NULL
[08:26:20.515]                           }
[08:26:20.515]                           if (!has_future || version < "1.8.0") {
[08:26:20.515]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:20.515]                               "", base::R.version$version.string), 
[08:26:20.515]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:20.515]                                 base::R.version$platform, 8 * 
[08:26:20.515]                                   base::.Machine$sizeof.pointer), 
[08:26:20.515]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:20.515]                                 "release", "version")], collapse = " "), 
[08:26:20.515]                               hostname = base::Sys.info()[["nodename"]])
[08:26:20.515]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:20.515]                               info)
[08:26:20.515]                             info <- base::paste(info, collapse = "; ")
[08:26:20.515]                             if (!has_future) {
[08:26:20.515]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:20.515]                                 info)
[08:26:20.515]                             }
[08:26:20.515]                             else {
[08:26:20.515]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:20.515]                                 info, version)
[08:26:20.515]                             }
[08:26:20.515]                             base::stop(msg)
[08:26:20.515]                           }
[08:26:20.515]                         })
[08:26:20.515]                       }
[08:26:20.515]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:20.515]                       base::options(mc.cores = 1L)
[08:26:20.515]                     }
[08:26:20.515]                     base::local({
[08:26:20.515]                       for (pkg in "future.apply") {
[08:26:20.515]                         base::loadNamespace(pkg)
[08:26:20.515]                         base::library(pkg, character.only = TRUE)
[08:26:20.515]                       }
[08:26:20.515]                     })
[08:26:20.515]                   }
[08:26:20.515]                   ...future.strategy.old <- future::plan("list")
[08:26:20.515]                   options(future.plan = NULL)
[08:26:20.515]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.515]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:20.515]                 }
[08:26:20.515]                 ...future.workdir <- getwd()
[08:26:20.515]             }
[08:26:20.515]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:20.515]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:20.515]         }
[08:26:20.515]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:20.515]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:20.515]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:20.515]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:20.515]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:20.515]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:20.515]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:20.515]             base::names(...future.oldOptions))
[08:26:20.515]     }
[08:26:20.515]     if (FALSE) {
[08:26:20.515]     }
[08:26:20.515]     else {
[08:26:20.515]         if (TRUE) {
[08:26:20.515]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:20.515]                 open = "w")
[08:26:20.515]         }
[08:26:20.515]         else {
[08:26:20.515]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:20.515]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:20.515]         }
[08:26:20.515]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:20.515]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:20.515]             base::sink(type = "output", split = FALSE)
[08:26:20.515]             base::close(...future.stdout)
[08:26:20.515]         }, add = TRUE)
[08:26:20.515]     }
[08:26:20.515]     ...future.frame <- base::sys.nframe()
[08:26:20.515]     ...future.conditions <- base::list()
[08:26:20.515]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:20.515]     if (FALSE) {
[08:26:20.515]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:20.515]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:20.515]     }
[08:26:20.515]     ...future.result <- base::tryCatch({
[08:26:20.515]         base::withCallingHandlers({
[08:26:20.515]             ...future.value <- base::withVisible(base::local({
[08:26:20.515]                 withCallingHandlers({
[08:26:20.515]                   {
[08:26:20.515]                     do.call(function(...) {
[08:26:20.515]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.515]                       if (!identical(...future.globals.maxSize.org, 
[08:26:20.515]                         ...future.globals.maxSize)) {
[08:26:20.515]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.515]                         on.exit(options(oopts), add = TRUE)
[08:26:20.515]                       }
[08:26:20.515]                       {
[08:26:20.515]                         lapply(seq_along(...future.elements_ii), 
[08:26:20.515]                           FUN = function(jj) {
[08:26:20.515]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.515]                             ...future.FUN(...future.X_jj, ...)
[08:26:20.515]                           })
[08:26:20.515]                       }
[08:26:20.515]                     }, args = future.call.arguments)
[08:26:20.515]                   }
[08:26:20.515]                 }, immediateCondition = function(cond) {
[08:26:20.515]                   save_rds <- function (object, pathname, ...) 
[08:26:20.515]                   {
[08:26:20.515]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:20.515]                     if (file_test("-f", pathname_tmp)) {
[08:26:20.515]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.515]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:20.515]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.515]                         fi_tmp[["mtime"]])
[08:26:20.515]                     }
[08:26:20.515]                     tryCatch({
[08:26:20.515]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:20.515]                     }, error = function(ex) {
[08:26:20.515]                       msg <- conditionMessage(ex)
[08:26:20.515]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.515]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:20.515]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.515]                         fi_tmp[["mtime"]], msg)
[08:26:20.515]                       ex$message <- msg
[08:26:20.515]                       stop(ex)
[08:26:20.515]                     })
[08:26:20.515]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:20.515]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:20.515]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:20.515]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.515]                       fi <- file.info(pathname)
[08:26:20.515]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:20.515]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.515]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:20.515]                         fi[["size"]], fi[["mtime"]])
[08:26:20.515]                       stop(msg)
[08:26:20.515]                     }
[08:26:20.515]                     invisible(pathname)
[08:26:20.515]                   }
[08:26:20.515]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:20.515]                     rootPath = tempdir()) 
[08:26:20.515]                   {
[08:26:20.515]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:20.515]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:20.515]                       tmpdir = path, fileext = ".rds")
[08:26:20.515]                     save_rds(obj, file)
[08:26:20.515]                   }
[08:26:20.515]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:20.515]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.515]                   {
[08:26:20.515]                     inherits <- base::inherits
[08:26:20.515]                     invokeRestart <- base::invokeRestart
[08:26:20.515]                     is.null <- base::is.null
[08:26:20.515]                     muffled <- FALSE
[08:26:20.515]                     if (inherits(cond, "message")) {
[08:26:20.515]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:20.515]                       if (muffled) 
[08:26:20.515]                         invokeRestart("muffleMessage")
[08:26:20.515]                     }
[08:26:20.515]                     else if (inherits(cond, "warning")) {
[08:26:20.515]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:20.515]                       if (muffled) 
[08:26:20.515]                         invokeRestart("muffleWarning")
[08:26:20.515]                     }
[08:26:20.515]                     else if (inherits(cond, "condition")) {
[08:26:20.515]                       if (!is.null(pattern)) {
[08:26:20.515]                         computeRestarts <- base::computeRestarts
[08:26:20.515]                         grepl <- base::grepl
[08:26:20.515]                         restarts <- computeRestarts(cond)
[08:26:20.515]                         for (restart in restarts) {
[08:26:20.515]                           name <- restart$name
[08:26:20.515]                           if (is.null(name)) 
[08:26:20.515]                             next
[08:26:20.515]                           if (!grepl(pattern, name)) 
[08:26:20.515]                             next
[08:26:20.515]                           invokeRestart(restart)
[08:26:20.515]                           muffled <- TRUE
[08:26:20.515]                           break
[08:26:20.515]                         }
[08:26:20.515]                       }
[08:26:20.515]                     }
[08:26:20.515]                     invisible(muffled)
[08:26:20.515]                   }
[08:26:20.515]                   muffleCondition(cond)
[08:26:20.515]                 })
[08:26:20.515]             }))
[08:26:20.515]             future::FutureResult(value = ...future.value$value, 
[08:26:20.515]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.515]                   ...future.rng), globalenv = if (FALSE) 
[08:26:20.515]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:20.515]                     ...future.globalenv.names))
[08:26:20.515]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:20.515]         }, condition = base::local({
[08:26:20.515]             c <- base::c
[08:26:20.515]             inherits <- base::inherits
[08:26:20.515]             invokeRestart <- base::invokeRestart
[08:26:20.515]             length <- base::length
[08:26:20.515]             list <- base::list
[08:26:20.515]             seq.int <- base::seq.int
[08:26:20.515]             signalCondition <- base::signalCondition
[08:26:20.515]             sys.calls <- base::sys.calls
[08:26:20.515]             `[[` <- base::`[[`
[08:26:20.515]             `+` <- base::`+`
[08:26:20.515]             `<<-` <- base::`<<-`
[08:26:20.515]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:20.515]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:20.515]                   3L)]
[08:26:20.515]             }
[08:26:20.515]             function(cond) {
[08:26:20.515]                 is_error <- inherits(cond, "error")
[08:26:20.515]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:20.515]                   NULL)
[08:26:20.515]                 if (is_error) {
[08:26:20.515]                   sessionInformation <- function() {
[08:26:20.515]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:20.515]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:20.515]                       search = base::search(), system = base::Sys.info())
[08:26:20.515]                   }
[08:26:20.515]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.515]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:20.515]                     cond$call), session = sessionInformation(), 
[08:26:20.515]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:20.515]                   signalCondition(cond)
[08:26:20.515]                 }
[08:26:20.515]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:20.515]                 "immediateCondition"))) {
[08:26:20.515]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:20.515]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.515]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:20.515]                   if (TRUE && !signal) {
[08:26:20.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.515]                     {
[08:26:20.515]                       inherits <- base::inherits
[08:26:20.515]                       invokeRestart <- base::invokeRestart
[08:26:20.515]                       is.null <- base::is.null
[08:26:20.515]                       muffled <- FALSE
[08:26:20.515]                       if (inherits(cond, "message")) {
[08:26:20.515]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.515]                         if (muffled) 
[08:26:20.515]                           invokeRestart("muffleMessage")
[08:26:20.515]                       }
[08:26:20.515]                       else if (inherits(cond, "warning")) {
[08:26:20.515]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.515]                         if (muffled) 
[08:26:20.515]                           invokeRestart("muffleWarning")
[08:26:20.515]                       }
[08:26:20.515]                       else if (inherits(cond, "condition")) {
[08:26:20.515]                         if (!is.null(pattern)) {
[08:26:20.515]                           computeRestarts <- base::computeRestarts
[08:26:20.515]                           grepl <- base::grepl
[08:26:20.515]                           restarts <- computeRestarts(cond)
[08:26:20.515]                           for (restart in restarts) {
[08:26:20.515]                             name <- restart$name
[08:26:20.515]                             if (is.null(name)) 
[08:26:20.515]                               next
[08:26:20.515]                             if (!grepl(pattern, name)) 
[08:26:20.515]                               next
[08:26:20.515]                             invokeRestart(restart)
[08:26:20.515]                             muffled <- TRUE
[08:26:20.515]                             break
[08:26:20.515]                           }
[08:26:20.515]                         }
[08:26:20.515]                       }
[08:26:20.515]                       invisible(muffled)
[08:26:20.515]                     }
[08:26:20.515]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.515]                   }
[08:26:20.515]                 }
[08:26:20.515]                 else {
[08:26:20.515]                   if (TRUE) {
[08:26:20.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.515]                     {
[08:26:20.515]                       inherits <- base::inherits
[08:26:20.515]                       invokeRestart <- base::invokeRestart
[08:26:20.515]                       is.null <- base::is.null
[08:26:20.515]                       muffled <- FALSE
[08:26:20.515]                       if (inherits(cond, "message")) {
[08:26:20.515]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.515]                         if (muffled) 
[08:26:20.515]                           invokeRestart("muffleMessage")
[08:26:20.515]                       }
[08:26:20.515]                       else if (inherits(cond, "warning")) {
[08:26:20.515]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.515]                         if (muffled) 
[08:26:20.515]                           invokeRestart("muffleWarning")
[08:26:20.515]                       }
[08:26:20.515]                       else if (inherits(cond, "condition")) {
[08:26:20.515]                         if (!is.null(pattern)) {
[08:26:20.515]                           computeRestarts <- base::computeRestarts
[08:26:20.515]                           grepl <- base::grepl
[08:26:20.515]                           restarts <- computeRestarts(cond)
[08:26:20.515]                           for (restart in restarts) {
[08:26:20.515]                             name <- restart$name
[08:26:20.515]                             if (is.null(name)) 
[08:26:20.515]                               next
[08:26:20.515]                             if (!grepl(pattern, name)) 
[08:26:20.515]                               next
[08:26:20.515]                             invokeRestart(restart)
[08:26:20.515]                             muffled <- TRUE
[08:26:20.515]                             break
[08:26:20.515]                           }
[08:26:20.515]                         }
[08:26:20.515]                       }
[08:26:20.515]                       invisible(muffled)
[08:26:20.515]                     }
[08:26:20.515]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.515]                   }
[08:26:20.515]                 }
[08:26:20.515]             }
[08:26:20.515]         }))
[08:26:20.515]     }, error = function(ex) {
[08:26:20.515]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:20.515]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.515]                 ...future.rng), started = ...future.startTime, 
[08:26:20.515]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:20.515]             version = "1.8"), class = "FutureResult")
[08:26:20.515]     }, finally = {
[08:26:20.515]         if (!identical(...future.workdir, getwd())) 
[08:26:20.515]             setwd(...future.workdir)
[08:26:20.515]         {
[08:26:20.515]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:20.515]                 ...future.oldOptions$nwarnings <- NULL
[08:26:20.515]             }
[08:26:20.515]             base::options(...future.oldOptions)
[08:26:20.515]             if (.Platform$OS.type == "windows") {
[08:26:20.515]                 old_names <- names(...future.oldEnvVars)
[08:26:20.515]                 envs <- base::Sys.getenv()
[08:26:20.515]                 names <- names(envs)
[08:26:20.515]                 common <- intersect(names, old_names)
[08:26:20.515]                 added <- setdiff(names, old_names)
[08:26:20.515]                 removed <- setdiff(old_names, names)
[08:26:20.515]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:20.515]                   envs[common]]
[08:26:20.515]                 NAMES <- toupper(changed)
[08:26:20.515]                 args <- list()
[08:26:20.515]                 for (kk in seq_along(NAMES)) {
[08:26:20.515]                   name <- changed[[kk]]
[08:26:20.515]                   NAME <- NAMES[[kk]]
[08:26:20.515]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.515]                     next
[08:26:20.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.515]                 }
[08:26:20.515]                 NAMES <- toupper(added)
[08:26:20.515]                 for (kk in seq_along(NAMES)) {
[08:26:20.515]                   name <- added[[kk]]
[08:26:20.515]                   NAME <- NAMES[[kk]]
[08:26:20.515]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.515]                     next
[08:26:20.515]                   args[[name]] <- ""
[08:26:20.515]                 }
[08:26:20.515]                 NAMES <- toupper(removed)
[08:26:20.515]                 for (kk in seq_along(NAMES)) {
[08:26:20.515]                   name <- removed[[kk]]
[08:26:20.515]                   NAME <- NAMES[[kk]]
[08:26:20.515]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.515]                     next
[08:26:20.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.515]                 }
[08:26:20.515]                 if (length(args) > 0) 
[08:26:20.515]                   base::do.call(base::Sys.setenv, args = args)
[08:26:20.515]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:20.515]             }
[08:26:20.515]             else {
[08:26:20.515]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:20.515]             }
[08:26:20.515]             {
[08:26:20.515]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:20.515]                   0L) {
[08:26:20.515]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:20.515]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:20.515]                   base::options(opts)
[08:26:20.515]                 }
[08:26:20.515]                 {
[08:26:20.515]                   {
[08:26:20.515]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:20.515]                     NULL
[08:26:20.515]                   }
[08:26:20.515]                   options(future.plan = NULL)
[08:26:20.515]                   if (is.na(NA_character_)) 
[08:26:20.515]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.515]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:20.515]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:20.515]                     .init = FALSE)
[08:26:20.515]                 }
[08:26:20.515]             }
[08:26:20.515]         }
[08:26:20.515]     })
[08:26:20.515]     if (TRUE) {
[08:26:20.515]         base::sink(type = "output", split = FALSE)
[08:26:20.515]         if (TRUE) {
[08:26:20.515]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:20.515]         }
[08:26:20.515]         else {
[08:26:20.515]             ...future.result["stdout"] <- base::list(NULL)
[08:26:20.515]         }
[08:26:20.515]         base::close(...future.stdout)
[08:26:20.515]         ...future.stdout <- NULL
[08:26:20.515]     }
[08:26:20.515]     ...future.result$conditions <- ...future.conditions
[08:26:20.515]     ...future.result$finished <- base::Sys.time()
[08:26:20.515]     ...future.result
[08:26:20.515] }
[08:26:20.518] assign_globals() ...
[08:26:20.518] List of 11
[08:26:20.518]  $ ...future.FUN            :function (x, ...)  
[08:26:20.518]  $ x_FUN                    :function (x)  
[08:26:20.518]  $ times                    : int 4
[08:26:20.518]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:20.518]  $ stop_if_not              :function (...)  
[08:26:20.518]  $ dim                      : int [1:2] 2 2
[08:26:20.518]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:20.518]  $ future.call.arguments    : list()
[08:26:20.518]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.518]  $ ...future.elements_ii    :List of 5
[08:26:20.518]   ..$ : int 6
[08:26:20.518]   ..$ : int 7
[08:26:20.518]   ..$ : int 8
[08:26:20.518]   ..$ : int 9
[08:26:20.518]   ..$ : int 10
[08:26:20.518]  $ ...future.seeds_ii       : NULL
[08:26:20.518]  $ ...future.globals.maxSize: NULL
[08:26:20.518]  - attr(*, "where")=List of 11
[08:26:20.518]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:20.518]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:20.518]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:20.518]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:20.518]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:20.518]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:20.518]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:20.518]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:20.518]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:20.518]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:20.518]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:20.518]  - attr(*, "resolved")= logi FALSE
[08:26:20.518]  - attr(*, "total_size")= num 24958
[08:26:20.518]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.518]  - attr(*, "already-done")= logi TRUE
[08:26:20.532] - copied ‘...future.FUN’ to environment
[08:26:20.532] - reassign environment for ‘x_FUN’
[08:26:20.533] - copied ‘x_FUN’ to environment
[08:26:20.533] - copied ‘times’ to environment
[08:26:20.533] - copied ‘stopf’ to environment
[08:26:20.533] - copied ‘stop_if_not’ to environment
[08:26:20.533] - copied ‘dim’ to environment
[08:26:20.533] - copied ‘valid_types’ to environment
[08:26:20.533] - copied ‘future.call.arguments’ to environment
[08:26:20.533] - copied ‘...future.elements_ii’ to environment
[08:26:20.534] - copied ‘...future.seeds_ii’ to environment
[08:26:20.534] - copied ‘...future.globals.maxSize’ to environment
[08:26:20.534] assign_globals() ... done
[08:26:20.534] requestCore(): workers = 2
[08:26:20.537] MulticoreFuture started
[08:26:20.537] - Launch lazy future ... done
[08:26:20.538] run() for ‘MulticoreFuture’ ... done
[08:26:20.539] Created future:
[08:26:20.539] plan(): Setting new future strategy stack:
[08:26:20.539] List of future strategies:
[08:26:20.539] 1. sequential:
[08:26:20.539]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:20.539]    - tweaked: FALSE
[08:26:20.539]    - call: NULL
[08:26:20.541] plan(): nbrOfWorkers() = 1
[08:26:20.544] plan(): Setting new future strategy stack:
[08:26:20.545] List of future strategies:
[08:26:20.545] 1. multicore:
[08:26:20.545]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:20.545]    - tweaked: FALSE
[08:26:20.545]    - call: plan(strategy)
[08:26:20.549] plan(): nbrOfWorkers() = 2
[08:26:20.539] MulticoreFuture:
[08:26:20.539] Label: ‘future_vapply-2’
[08:26:20.539] Expression:
[08:26:20.539] {
[08:26:20.539]     do.call(function(...) {
[08:26:20.539]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.539]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.539]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.539]             on.exit(options(oopts), add = TRUE)
[08:26:20.539]         }
[08:26:20.539]         {
[08:26:20.539]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.539]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.539]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.539]             })
[08:26:20.539]         }
[08:26:20.539]     }, args = future.call.arguments)
[08:26:20.539] }
[08:26:20.539] Lazy evaluation: FALSE
[08:26:20.539] Asynchronous evaluation: TRUE
[08:26:20.539] Local evaluation: TRUE
[08:26:20.539] Environment: R_GlobalEnv
[08:26:20.539] Capture standard output: TRUE
[08:26:20.539] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:20.539] Globals: 11 objects totaling 13.86 KiB (function ‘...future.FUN’ of 5.08 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:20.539] Packages: 1 packages (‘future.apply’)
[08:26:20.539] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:20.539] Resolved: TRUE
[08:26:20.539] Value: <not collected>
[08:26:20.539] Conditions captured: <none>
[08:26:20.539] Early signaling: FALSE
[08:26:20.539] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:20.539] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.550] Chunk #2 of 2 ... DONE
[08:26:20.550] Launching 2 futures (chunks) ... DONE
[08:26:20.551] Resolving 2 futures (chunks) ...
[08:26:20.551] resolve() on list ...
[08:26:20.551]  recursive: 0
[08:26:20.551]  length: 2
[08:26:20.552] 
[08:26:20.552] Future #1
[08:26:20.552] result() for MulticoreFuture ...
[08:26:20.553] result() for MulticoreFuture ...
[08:26:20.553] result() for MulticoreFuture ... done
[08:26:20.553] result() for MulticoreFuture ... done
[08:26:20.554] result() for MulticoreFuture ...
[08:26:20.554] result() for MulticoreFuture ... done
[08:26:20.554] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:26:20.554] - nx: 2
[08:26:20.554] - relay: TRUE
[08:26:20.554] - stdout: TRUE
[08:26:20.555] - signal: TRUE
[08:26:20.555] - resignal: FALSE
[08:26:20.555] - force: TRUE
[08:26:20.555] - relayed: [n=2] FALSE, FALSE
[08:26:20.555] - queued futures: [n=2] FALSE, FALSE
[08:26:20.555]  - until=1
[08:26:20.555]  - relaying element #1
[08:26:20.556] result() for MulticoreFuture ...
[08:26:20.556] result() for MulticoreFuture ... done
[08:26:20.556] result() for MulticoreFuture ...
[08:26:20.556] result() for MulticoreFuture ... done
[08:26:20.556] result() for MulticoreFuture ...
[08:26:20.557] result() for MulticoreFuture ... done
[08:26:20.557] result() for MulticoreFuture ...
[08:26:20.557] result() for MulticoreFuture ... done
[08:26:20.557] - relayed: [n=2] TRUE, FALSE
[08:26:20.557] - queued futures: [n=2] TRUE, FALSE
[08:26:20.557] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:26:20.558]  length: 1 (resolved future 1)
[08:26:20.558] Future #2
[08:26:20.558] result() for MulticoreFuture ...
[08:26:20.559] result() for MulticoreFuture ...
[08:26:20.559] result() for MulticoreFuture ... done
[08:26:20.559] result() for MulticoreFuture ... done
[08:26:20.559] result() for MulticoreFuture ...
[08:26:20.559] result() for MulticoreFuture ... done
[08:26:20.559] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:26:20.560] - nx: 2
[08:26:20.560] - relay: TRUE
[08:26:20.560] - stdout: TRUE
[08:26:20.560] - signal: TRUE
[08:26:20.560] - resignal: FALSE
[08:26:20.560] - force: TRUE
[08:26:20.560] - relayed: [n=2] TRUE, FALSE
[08:26:20.560] - queued futures: [n=2] TRUE, FALSE
[08:26:20.560]  - until=2
[08:26:20.561]  - relaying element #2
[08:26:20.561] result() for MulticoreFuture ...
[08:26:20.561] result() for MulticoreFuture ... done
[08:26:20.561] result() for MulticoreFuture ...
[08:26:20.561] result() for MulticoreFuture ... done
[08:26:20.561] result() for MulticoreFuture ...
[08:26:20.561] result() for MulticoreFuture ... done
[08:26:20.562] result() for MulticoreFuture ...
[08:26:20.562] result() for MulticoreFuture ... done
[08:26:20.562] - relayed: [n=2] TRUE, TRUE
[08:26:20.562] - queued futures: [n=2] TRUE, TRUE
[08:26:20.562] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:26:20.562]  length: 0 (resolved future 2)
[08:26:20.562] Relaying remaining futures
[08:26:20.562] signalConditionsASAP(NULL, pos=0) ...
[08:26:20.562] - nx: 2
[08:26:20.562] - relay: TRUE
[08:26:20.563] - stdout: TRUE
[08:26:20.563] - signal: TRUE
[08:26:20.563] - resignal: FALSE
[08:26:20.563] - force: TRUE
[08:26:20.563] - relayed: [n=2] TRUE, TRUE
[08:26:20.563] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:20.563] - relayed: [n=2] TRUE, TRUE
[08:26:20.563] - queued futures: [n=2] TRUE, TRUE
[08:26:20.563] signalConditionsASAP(NULL, pos=0) ... done
[08:26:20.563] resolve() on list ... DONE
[08:26:20.564] result() for MulticoreFuture ...
[08:26:20.564] result() for MulticoreFuture ... done
[08:26:20.564] result() for MulticoreFuture ...
[08:26:20.564] result() for MulticoreFuture ... done
[08:26:20.564] result() for MulticoreFuture ...
[08:26:20.564] result() for MulticoreFuture ... done
[08:26:20.564] result() for MulticoreFuture ...
[08:26:20.564] result() for MulticoreFuture ... done
[08:26:20.564]  - Number of value chunks collected: 2
[08:26:20.565] Resolving 2 futures (chunks) ... DONE
[08:26:20.565] Reducing values from 2 chunks ...
[08:26:20.565]  - Number of values collected after concatenation: 10
[08:26:20.565]  - Number of values expected: 10
[08:26:20.565] Reducing values from 2 chunks ... DONE
[08:26:20.565] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[08:26:20.568] future_lapply() ...
[08:26:20.572] Number of chunks: 2
[08:26:20.572] getGlobalsAndPackagesXApply() ...
[08:26:20.572]  - future.globals: TRUE
[08:26:20.572] getGlobalsAndPackages() ...
[08:26:20.572] Searching for globals...
[08:26:20.580] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[08:26:20.580] Searching for globals ... DONE
[08:26:20.580] Resolving globals: FALSE
[08:26:20.581] The total size of the 7 globals is 16.05 KiB (16436 bytes)
[08:26:20.582] The total size of the 7 globals exported for future expression (‘FUN()’) is 16.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (6.71 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:20.582] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:20.582] - packages: [1] ‘future.apply’
[08:26:20.582] getGlobalsAndPackages() ... DONE
[08:26:20.582]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:20.583]  - needed namespaces: [n=1] ‘future.apply’
[08:26:20.583] Finding globals ... DONE
[08:26:20.583]  - use_args: TRUE
[08:26:20.583]  - Getting '...' globals ...
[08:26:20.583] resolve() on list ...
[08:26:20.583]  recursive: 0
[08:26:20.583]  length: 1
[08:26:20.583]  elements: ‘...’
[08:26:20.584]  length: 0 (resolved future 1)
[08:26:20.584] resolve() on list ... DONE
[08:26:20.584]    - '...' content: [n=0] 
[08:26:20.584] List of 1
[08:26:20.584]  $ ...: list()
[08:26:20.584]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.584]  - attr(*, "where")=List of 1
[08:26:20.584]   ..$ ...:<environment: 0x562ca7ada238> 
[08:26:20.584]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.584]  - attr(*, "resolved")= logi TRUE
[08:26:20.584]  - attr(*, "total_size")= num NA
[08:26:20.586]  - Getting '...' globals ... DONE
[08:26:20.587] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:20.587] List of 8
[08:26:20.587]  $ ...future.FUN:function (x, ...)  
[08:26:20.587]  $ x_FUN        :function (x)  
[08:26:20.587]  $ times        : int 4
[08:26:20.587]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:20.587]  $ stop_if_not  :function (...)  
[08:26:20.587]  $ dim          : int [1:2] 2 2
[08:26:20.587]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:20.587]  $ ...          : list()
[08:26:20.587]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.587]  - attr(*, "where")=List of 8
[08:26:20.587]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:20.587]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:20.587]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:20.587]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:20.587]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:20.587]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:20.587]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:20.587]   ..$ ...          :<environment: 0x562ca7ada238> 
[08:26:20.587]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.587]  - attr(*, "resolved")= logi FALSE
[08:26:20.587]  - attr(*, "total_size")= num 29094
[08:26:20.592] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:20.593] getGlobalsAndPackagesXApply() ... DONE
[08:26:20.593] Number of futures (= number of chunks): 2
[08:26:20.593] Launching 2 futures (chunks) ...
[08:26:20.593] Chunk #1 of 2 ...
[08:26:20.593]  - Finding globals in 'X' for chunk #1 ...
[08:26:20.593] getGlobalsAndPackages() ...
[08:26:20.593] Searching for globals...
[08:26:20.594] 
[08:26:20.594] Searching for globals ... DONE
[08:26:20.594] - globals: [0] <none>
[08:26:20.594] getGlobalsAndPackages() ... DONE
[08:26:20.594]    + additional globals found: [n=0] 
[08:26:20.594]    + additional namespaces needed: [n=0] 
[08:26:20.594]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:20.594]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:20.594]  - seeds: <none>
[08:26:20.594]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.594] getGlobalsAndPackages() ...
[08:26:20.595] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.595] Resolving globals: FALSE
[08:26:20.595] Tweak future expression to call with '...' arguments ...
[08:26:20.595] {
[08:26:20.595]     do.call(function(...) {
[08:26:20.595]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.595]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.595]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.595]             on.exit(options(oopts), add = TRUE)
[08:26:20.595]         }
[08:26:20.595]         {
[08:26:20.595]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.595]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.595]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.595]             })
[08:26:20.595]         }
[08:26:20.595]     }, args = future.call.arguments)
[08:26:20.595] }
[08:26:20.595] Tweak future expression to call with '...' arguments ... DONE
[08:26:20.596] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.596] - packages: [1] ‘future.apply’
[08:26:20.596] getGlobalsAndPackages() ... DONE
[08:26:20.598] run() for ‘Future’ ...
[08:26:20.599] - state: ‘created’
[08:26:20.599] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:20.601] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.601] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:20.601]   - Field: ‘label’
[08:26:20.601]   - Field: ‘local’
[08:26:20.601]   - Field: ‘owner’
[08:26:20.601]   - Field: ‘envir’
[08:26:20.602]   - Field: ‘workers’
[08:26:20.602]   - Field: ‘packages’
[08:26:20.602]   - Field: ‘gc’
[08:26:20.602]   - Field: ‘job’
[08:26:20.602]   - Field: ‘conditions’
[08:26:20.602]   - Field: ‘expr’
[08:26:20.602]   - Field: ‘uuid’
[08:26:20.602]   - Field: ‘seed’
[08:26:20.602]   - Field: ‘version’
[08:26:20.603]   - Field: ‘result’
[08:26:20.603]   - Field: ‘asynchronous’
[08:26:20.603]   - Field: ‘calls’
[08:26:20.603]   - Field: ‘globals’
[08:26:20.603]   - Field: ‘stdout’
[08:26:20.603]   - Field: ‘earlySignal’
[08:26:20.603]   - Field: ‘lazy’
[08:26:20.603]   - Field: ‘state’
[08:26:20.603] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:20.604] - Launch lazy future ...
[08:26:20.604] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:20.604] Packages needed by future strategies (n = 0): <none>
[08:26:20.605] {
[08:26:20.605]     {
[08:26:20.605]         {
[08:26:20.605]             ...future.startTime <- base::Sys.time()
[08:26:20.605]             {
[08:26:20.605]                 {
[08:26:20.605]                   {
[08:26:20.605]                     {
[08:26:20.605]                       {
[08:26:20.605]                         base::local({
[08:26:20.605]                           has_future <- base::requireNamespace("future", 
[08:26:20.605]                             quietly = TRUE)
[08:26:20.605]                           if (has_future) {
[08:26:20.605]                             ns <- base::getNamespace("future")
[08:26:20.605]                             version <- ns[[".package"]][["version"]]
[08:26:20.605]                             if (is.null(version)) 
[08:26:20.605]                               version <- utils::packageVersion("future")
[08:26:20.605]                           }
[08:26:20.605]                           else {
[08:26:20.605]                             version <- NULL
[08:26:20.605]                           }
[08:26:20.605]                           if (!has_future || version < "1.8.0") {
[08:26:20.605]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:20.605]                               "", base::R.version$version.string), 
[08:26:20.605]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:20.605]                                 base::R.version$platform, 8 * 
[08:26:20.605]                                   base::.Machine$sizeof.pointer), 
[08:26:20.605]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:20.605]                                 "release", "version")], collapse = " "), 
[08:26:20.605]                               hostname = base::Sys.info()[["nodename"]])
[08:26:20.605]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:20.605]                               info)
[08:26:20.605]                             info <- base::paste(info, collapse = "; ")
[08:26:20.605]                             if (!has_future) {
[08:26:20.605]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:20.605]                                 info)
[08:26:20.605]                             }
[08:26:20.605]                             else {
[08:26:20.605]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:20.605]                                 info, version)
[08:26:20.605]                             }
[08:26:20.605]                             base::stop(msg)
[08:26:20.605]                           }
[08:26:20.605]                         })
[08:26:20.605]                       }
[08:26:20.605]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:20.605]                       base::options(mc.cores = 1L)
[08:26:20.605]                     }
[08:26:20.605]                     base::local({
[08:26:20.605]                       for (pkg in "future.apply") {
[08:26:20.605]                         base::loadNamespace(pkg)
[08:26:20.605]                         base::library(pkg, character.only = TRUE)
[08:26:20.605]                       }
[08:26:20.605]                     })
[08:26:20.605]                   }
[08:26:20.605]                   ...future.strategy.old <- future::plan("list")
[08:26:20.605]                   options(future.plan = NULL)
[08:26:20.605]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.605]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:20.605]                 }
[08:26:20.605]                 ...future.workdir <- getwd()
[08:26:20.605]             }
[08:26:20.605]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:20.605]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:20.605]         }
[08:26:20.605]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:20.605]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:20.605]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:20.605]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:20.605]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:20.605]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:20.605]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:20.605]             base::names(...future.oldOptions))
[08:26:20.605]     }
[08:26:20.605]     if (FALSE) {
[08:26:20.605]     }
[08:26:20.605]     else {
[08:26:20.605]         if (TRUE) {
[08:26:20.605]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:20.605]                 open = "w")
[08:26:20.605]         }
[08:26:20.605]         else {
[08:26:20.605]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:20.605]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:20.605]         }
[08:26:20.605]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:20.605]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:20.605]             base::sink(type = "output", split = FALSE)
[08:26:20.605]             base::close(...future.stdout)
[08:26:20.605]         }, add = TRUE)
[08:26:20.605]     }
[08:26:20.605]     ...future.frame <- base::sys.nframe()
[08:26:20.605]     ...future.conditions <- base::list()
[08:26:20.605]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:20.605]     if (FALSE) {
[08:26:20.605]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:20.605]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:20.605]     }
[08:26:20.605]     ...future.result <- base::tryCatch({
[08:26:20.605]         base::withCallingHandlers({
[08:26:20.605]             ...future.value <- base::withVisible(base::local({
[08:26:20.605]                 withCallingHandlers({
[08:26:20.605]                   {
[08:26:20.605]                     do.call(function(...) {
[08:26:20.605]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.605]                       if (!identical(...future.globals.maxSize.org, 
[08:26:20.605]                         ...future.globals.maxSize)) {
[08:26:20.605]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.605]                         on.exit(options(oopts), add = TRUE)
[08:26:20.605]                       }
[08:26:20.605]                       {
[08:26:20.605]                         lapply(seq_along(...future.elements_ii), 
[08:26:20.605]                           FUN = function(jj) {
[08:26:20.605]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.605]                             ...future.FUN(...future.X_jj, ...)
[08:26:20.605]                           })
[08:26:20.605]                       }
[08:26:20.605]                     }, args = future.call.arguments)
[08:26:20.605]                   }
[08:26:20.605]                 }, immediateCondition = function(cond) {
[08:26:20.605]                   save_rds <- function (object, pathname, ...) 
[08:26:20.605]                   {
[08:26:20.605]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:20.605]                     if (file_test("-f", pathname_tmp)) {
[08:26:20.605]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.605]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:20.605]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.605]                         fi_tmp[["mtime"]])
[08:26:20.605]                     }
[08:26:20.605]                     tryCatch({
[08:26:20.605]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:20.605]                     }, error = function(ex) {
[08:26:20.605]                       msg <- conditionMessage(ex)
[08:26:20.605]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.605]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:20.605]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.605]                         fi_tmp[["mtime"]], msg)
[08:26:20.605]                       ex$message <- msg
[08:26:20.605]                       stop(ex)
[08:26:20.605]                     })
[08:26:20.605]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:20.605]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:20.605]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:20.605]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.605]                       fi <- file.info(pathname)
[08:26:20.605]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:20.605]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.605]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:20.605]                         fi[["size"]], fi[["mtime"]])
[08:26:20.605]                       stop(msg)
[08:26:20.605]                     }
[08:26:20.605]                     invisible(pathname)
[08:26:20.605]                   }
[08:26:20.605]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:20.605]                     rootPath = tempdir()) 
[08:26:20.605]                   {
[08:26:20.605]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:20.605]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:20.605]                       tmpdir = path, fileext = ".rds")
[08:26:20.605]                     save_rds(obj, file)
[08:26:20.605]                   }
[08:26:20.605]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:20.605]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.605]                   {
[08:26:20.605]                     inherits <- base::inherits
[08:26:20.605]                     invokeRestart <- base::invokeRestart
[08:26:20.605]                     is.null <- base::is.null
[08:26:20.605]                     muffled <- FALSE
[08:26:20.605]                     if (inherits(cond, "message")) {
[08:26:20.605]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:20.605]                       if (muffled) 
[08:26:20.605]                         invokeRestart("muffleMessage")
[08:26:20.605]                     }
[08:26:20.605]                     else if (inherits(cond, "warning")) {
[08:26:20.605]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:20.605]                       if (muffled) 
[08:26:20.605]                         invokeRestart("muffleWarning")
[08:26:20.605]                     }
[08:26:20.605]                     else if (inherits(cond, "condition")) {
[08:26:20.605]                       if (!is.null(pattern)) {
[08:26:20.605]                         computeRestarts <- base::computeRestarts
[08:26:20.605]                         grepl <- base::grepl
[08:26:20.605]                         restarts <- computeRestarts(cond)
[08:26:20.605]                         for (restart in restarts) {
[08:26:20.605]                           name <- restart$name
[08:26:20.605]                           if (is.null(name)) 
[08:26:20.605]                             next
[08:26:20.605]                           if (!grepl(pattern, name)) 
[08:26:20.605]                             next
[08:26:20.605]                           invokeRestart(restart)
[08:26:20.605]                           muffled <- TRUE
[08:26:20.605]                           break
[08:26:20.605]                         }
[08:26:20.605]                       }
[08:26:20.605]                     }
[08:26:20.605]                     invisible(muffled)
[08:26:20.605]                   }
[08:26:20.605]                   muffleCondition(cond)
[08:26:20.605]                 })
[08:26:20.605]             }))
[08:26:20.605]             future::FutureResult(value = ...future.value$value, 
[08:26:20.605]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.605]                   ...future.rng), globalenv = if (FALSE) 
[08:26:20.605]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:20.605]                     ...future.globalenv.names))
[08:26:20.605]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:20.605]         }, condition = base::local({
[08:26:20.605]             c <- base::c
[08:26:20.605]             inherits <- base::inherits
[08:26:20.605]             invokeRestart <- base::invokeRestart
[08:26:20.605]             length <- base::length
[08:26:20.605]             list <- base::list
[08:26:20.605]             seq.int <- base::seq.int
[08:26:20.605]             signalCondition <- base::signalCondition
[08:26:20.605]             sys.calls <- base::sys.calls
[08:26:20.605]             `[[` <- base::`[[`
[08:26:20.605]             `+` <- base::`+`
[08:26:20.605]             `<<-` <- base::`<<-`
[08:26:20.605]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:20.605]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:20.605]                   3L)]
[08:26:20.605]             }
[08:26:20.605]             function(cond) {
[08:26:20.605]                 is_error <- inherits(cond, "error")
[08:26:20.605]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:20.605]                   NULL)
[08:26:20.605]                 if (is_error) {
[08:26:20.605]                   sessionInformation <- function() {
[08:26:20.605]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:20.605]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:20.605]                       search = base::search(), system = base::Sys.info())
[08:26:20.605]                   }
[08:26:20.605]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.605]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:20.605]                     cond$call), session = sessionInformation(), 
[08:26:20.605]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:20.605]                   signalCondition(cond)
[08:26:20.605]                 }
[08:26:20.605]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:20.605]                 "immediateCondition"))) {
[08:26:20.605]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:20.605]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.605]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:20.605]                   if (TRUE && !signal) {
[08:26:20.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.605]                     {
[08:26:20.605]                       inherits <- base::inherits
[08:26:20.605]                       invokeRestart <- base::invokeRestart
[08:26:20.605]                       is.null <- base::is.null
[08:26:20.605]                       muffled <- FALSE
[08:26:20.605]                       if (inherits(cond, "message")) {
[08:26:20.605]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.605]                         if (muffled) 
[08:26:20.605]                           invokeRestart("muffleMessage")
[08:26:20.605]                       }
[08:26:20.605]                       else if (inherits(cond, "warning")) {
[08:26:20.605]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.605]                         if (muffled) 
[08:26:20.605]                           invokeRestart("muffleWarning")
[08:26:20.605]                       }
[08:26:20.605]                       else if (inherits(cond, "condition")) {
[08:26:20.605]                         if (!is.null(pattern)) {
[08:26:20.605]                           computeRestarts <- base::computeRestarts
[08:26:20.605]                           grepl <- base::grepl
[08:26:20.605]                           restarts <- computeRestarts(cond)
[08:26:20.605]                           for (restart in restarts) {
[08:26:20.605]                             name <- restart$name
[08:26:20.605]                             if (is.null(name)) 
[08:26:20.605]                               next
[08:26:20.605]                             if (!grepl(pattern, name)) 
[08:26:20.605]                               next
[08:26:20.605]                             invokeRestart(restart)
[08:26:20.605]                             muffled <- TRUE
[08:26:20.605]                             break
[08:26:20.605]                           }
[08:26:20.605]                         }
[08:26:20.605]                       }
[08:26:20.605]                       invisible(muffled)
[08:26:20.605]                     }
[08:26:20.605]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.605]                   }
[08:26:20.605]                 }
[08:26:20.605]                 else {
[08:26:20.605]                   if (TRUE) {
[08:26:20.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.605]                     {
[08:26:20.605]                       inherits <- base::inherits
[08:26:20.605]                       invokeRestart <- base::invokeRestart
[08:26:20.605]                       is.null <- base::is.null
[08:26:20.605]                       muffled <- FALSE
[08:26:20.605]                       if (inherits(cond, "message")) {
[08:26:20.605]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.605]                         if (muffled) 
[08:26:20.605]                           invokeRestart("muffleMessage")
[08:26:20.605]                       }
[08:26:20.605]                       else if (inherits(cond, "warning")) {
[08:26:20.605]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.605]                         if (muffled) 
[08:26:20.605]                           invokeRestart("muffleWarning")
[08:26:20.605]                       }
[08:26:20.605]                       else if (inherits(cond, "condition")) {
[08:26:20.605]                         if (!is.null(pattern)) {
[08:26:20.605]                           computeRestarts <- base::computeRestarts
[08:26:20.605]                           grepl <- base::grepl
[08:26:20.605]                           restarts <- computeRestarts(cond)
[08:26:20.605]                           for (restart in restarts) {
[08:26:20.605]                             name <- restart$name
[08:26:20.605]                             if (is.null(name)) 
[08:26:20.605]                               next
[08:26:20.605]                             if (!grepl(pattern, name)) 
[08:26:20.605]                               next
[08:26:20.605]                             invokeRestart(restart)
[08:26:20.605]                             muffled <- TRUE
[08:26:20.605]                             break
[08:26:20.605]                           }
[08:26:20.605]                         }
[08:26:20.605]                       }
[08:26:20.605]                       invisible(muffled)
[08:26:20.605]                     }
[08:26:20.605]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.605]                   }
[08:26:20.605]                 }
[08:26:20.605]             }
[08:26:20.605]         }))
[08:26:20.605]     }, error = function(ex) {
[08:26:20.605]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:20.605]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.605]                 ...future.rng), started = ...future.startTime, 
[08:26:20.605]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:20.605]             version = "1.8"), class = "FutureResult")
[08:26:20.605]     }, finally = {
[08:26:20.605]         if (!identical(...future.workdir, getwd())) 
[08:26:20.605]             setwd(...future.workdir)
[08:26:20.605]         {
[08:26:20.605]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:20.605]                 ...future.oldOptions$nwarnings <- NULL
[08:26:20.605]             }
[08:26:20.605]             base::options(...future.oldOptions)
[08:26:20.605]             if (.Platform$OS.type == "windows") {
[08:26:20.605]                 old_names <- names(...future.oldEnvVars)
[08:26:20.605]                 envs <- base::Sys.getenv()
[08:26:20.605]                 names <- names(envs)
[08:26:20.605]                 common <- intersect(names, old_names)
[08:26:20.605]                 added <- setdiff(names, old_names)
[08:26:20.605]                 removed <- setdiff(old_names, names)
[08:26:20.605]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:20.605]                   envs[common]]
[08:26:20.605]                 NAMES <- toupper(changed)
[08:26:20.605]                 args <- list()
[08:26:20.605]                 for (kk in seq_along(NAMES)) {
[08:26:20.605]                   name <- changed[[kk]]
[08:26:20.605]                   NAME <- NAMES[[kk]]
[08:26:20.605]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.605]                     next
[08:26:20.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.605]                 }
[08:26:20.605]                 NAMES <- toupper(added)
[08:26:20.605]                 for (kk in seq_along(NAMES)) {
[08:26:20.605]                   name <- added[[kk]]
[08:26:20.605]                   NAME <- NAMES[[kk]]
[08:26:20.605]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.605]                     next
[08:26:20.605]                   args[[name]] <- ""
[08:26:20.605]                 }
[08:26:20.605]                 NAMES <- toupper(removed)
[08:26:20.605]                 for (kk in seq_along(NAMES)) {
[08:26:20.605]                   name <- removed[[kk]]
[08:26:20.605]                   NAME <- NAMES[[kk]]
[08:26:20.605]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.605]                     next
[08:26:20.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.605]                 }
[08:26:20.605]                 if (length(args) > 0) 
[08:26:20.605]                   base::do.call(base::Sys.setenv, args = args)
[08:26:20.605]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:20.605]             }
[08:26:20.605]             else {
[08:26:20.605]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:20.605]             }
[08:26:20.605]             {
[08:26:20.605]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:20.605]                   0L) {
[08:26:20.605]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:20.605]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:20.605]                   base::options(opts)
[08:26:20.605]                 }
[08:26:20.605]                 {
[08:26:20.605]                   {
[08:26:20.605]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:20.605]                     NULL
[08:26:20.605]                   }
[08:26:20.605]                   options(future.plan = NULL)
[08:26:20.605]                   if (is.na(NA_character_)) 
[08:26:20.605]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.605]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:20.605]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:20.605]                     .init = FALSE)
[08:26:20.605]                 }
[08:26:20.605]             }
[08:26:20.605]         }
[08:26:20.605]     })
[08:26:20.605]     if (TRUE) {
[08:26:20.605]         base::sink(type = "output", split = FALSE)
[08:26:20.605]         if (TRUE) {
[08:26:20.605]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:20.605]         }
[08:26:20.605]         else {
[08:26:20.605]             ...future.result["stdout"] <- base::list(NULL)
[08:26:20.605]         }
[08:26:20.605]         base::close(...future.stdout)
[08:26:20.605]         ...future.stdout <- NULL
[08:26:20.605]     }
[08:26:20.605]     ...future.result$conditions <- ...future.conditions
[08:26:20.605]     ...future.result$finished <- base::Sys.time()
[08:26:20.605]     ...future.result
[08:26:20.605] }
[08:26:20.607] assign_globals() ...
[08:26:20.608] List of 11
[08:26:20.608]  $ ...future.FUN            :function (x, ...)  
[08:26:20.608]  $ x_FUN                    :function (x)  
[08:26:20.608]  $ times                    : int 4
[08:26:20.608]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:20.608]  $ stop_if_not              :function (...)  
[08:26:20.608]  $ dim                      : int [1:2] 2 2
[08:26:20.608]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:20.608]  $ future.call.arguments    : list()
[08:26:20.608]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.608]  $ ...future.elements_ii    :List of 5
[08:26:20.608]   ..$ : int 1
[08:26:20.608]   ..$ : int 2
[08:26:20.608]   ..$ : int 3
[08:26:20.608]   ..$ : int 4
[08:26:20.608]   ..$ : int 5
[08:26:20.608]  $ ...future.seeds_ii       : NULL
[08:26:20.608]  $ ...future.globals.maxSize: NULL
[08:26:20.608]  - attr(*, "where")=List of 11
[08:26:20.608]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:20.608]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:20.608]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:20.608]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:20.608]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:20.608]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:20.608]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:20.608]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:20.608]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:20.608]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:20.608]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:20.608]  - attr(*, "resolved")= logi FALSE
[08:26:20.608]  - attr(*, "total_size")= num 29094
[08:26:20.608]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.608]  - attr(*, "already-done")= logi TRUE
[08:26:20.616] - copied ‘...future.FUN’ to environment
[08:26:20.617] - reassign environment for ‘x_FUN’
[08:26:20.617] - copied ‘x_FUN’ to environment
[08:26:20.617] - copied ‘times’ to environment
[08:26:20.617] - copied ‘stopf’ to environment
[08:26:20.617] - copied ‘stop_if_not’ to environment
[08:26:20.617] - copied ‘dim’ to environment
[08:26:20.617] - copied ‘valid_types’ to environment
[08:26:20.617] - copied ‘future.call.arguments’ to environment
[08:26:20.617] - copied ‘...future.elements_ii’ to environment
[08:26:20.617] - copied ‘...future.seeds_ii’ to environment
[08:26:20.618] - copied ‘...future.globals.maxSize’ to environment
[08:26:20.618] assign_globals() ... done
[08:26:20.618] requestCore(): workers = 2
[08:26:20.620] MulticoreFuture started
[08:26:20.621] - Launch lazy future ... done
[08:26:20.621] run() for ‘MulticoreFuture’ ... done
[08:26:20.621] Created future:
[08:26:20.622] plan(): Setting new future strategy stack:
[08:26:20.622] List of future strategies:
[08:26:20.622] 1. sequential:
[08:26:20.622]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:20.622]    - tweaked: FALSE
[08:26:20.622]    - call: NULL
[08:26:20.623] plan(): nbrOfWorkers() = 1
[08:26:20.625] plan(): Setting new future strategy stack:
[08:26:20.625] List of future strategies:
[08:26:20.625] 1. multicore:
[08:26:20.625]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:20.625]    - tweaked: FALSE
[08:26:20.625]    - call: plan(strategy)
[08:26:20.629] plan(): nbrOfWorkers() = 2
[08:26:20.621] MulticoreFuture:
[08:26:20.621] Label: ‘future_vapply-1’
[08:26:20.621] Expression:
[08:26:20.621] {
[08:26:20.621]     do.call(function(...) {
[08:26:20.621]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.621]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.621]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.621]             on.exit(options(oopts), add = TRUE)
[08:26:20.621]         }
[08:26:20.621]         {
[08:26:20.621]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.621]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.621]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.621]             })
[08:26:20.621]         }
[08:26:20.621]     }, args = future.call.arguments)
[08:26:20.621] }
[08:26:20.621] Lazy evaluation: FALSE
[08:26:20.621] Asynchronous evaluation: TRUE
[08:26:20.621] Local evaluation: TRUE
[08:26:20.621] Environment: R_GlobalEnv
[08:26:20.621] Capture standard output: TRUE
[08:26:20.621] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:20.621] Globals: 11 objects totaling 16.28 KiB (function ‘...future.FUN’ of 6.70 KiB, function ‘x_FUN’ of 1.36 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:20.621] Packages: 1 packages (‘future.apply’)
[08:26:20.621] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:20.621] Resolved: TRUE
[08:26:20.621] Value: <not collected>
[08:26:20.621] Conditions captured: <none>
[08:26:20.621] Early signaling: FALSE
[08:26:20.621] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:20.621] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.630] Chunk #1 of 2 ... DONE
[08:26:20.630] Chunk #2 of 2 ...
[08:26:20.630]  - Finding globals in 'X' for chunk #2 ...
[08:26:20.630] getGlobalsAndPackages() ...
[08:26:20.631] Searching for globals...
[08:26:20.631] 
[08:26:20.631] Searching for globals ... DONE
[08:26:20.631] - globals: [0] <none>
[08:26:20.631] getGlobalsAndPackages() ... DONE
[08:26:20.631]    + additional globals found: [n=0] 
[08:26:20.632]    + additional namespaces needed: [n=0] 
[08:26:20.632]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:20.632]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:20.632]  - seeds: <none>
[08:26:20.632]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.632] getGlobalsAndPackages() ...
[08:26:20.632] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.633] Resolving globals: FALSE
[08:26:20.633] Tweak future expression to call with '...' arguments ...
[08:26:20.637] {
[08:26:20.637]     do.call(function(...) {
[08:26:20.637]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.637]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.637]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.637]             on.exit(options(oopts), add = TRUE)
[08:26:20.637]         }
[08:26:20.637]         {
[08:26:20.637]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.637]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.637]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.637]             })
[08:26:20.637]         }
[08:26:20.637]     }, args = future.call.arguments)
[08:26:20.637] }
[08:26:20.638] Tweak future expression to call with '...' arguments ... DONE
[08:26:20.639] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.640] - packages: [1] ‘future.apply’
[08:26:20.640] getGlobalsAndPackages() ... DONE
[08:26:20.641] run() for ‘Future’ ...
[08:26:20.641] - state: ‘created’
[08:26:20.642] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:20.646] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.646] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:20.646]   - Field: ‘label’
[08:26:20.647]   - Field: ‘local’
[08:26:20.647]   - Field: ‘owner’
[08:26:20.647]   - Field: ‘envir’
[08:26:20.647]   - Field: ‘workers’
[08:26:20.647]   - Field: ‘packages’
[08:26:20.648]   - Field: ‘gc’
[08:26:20.648]   - Field: ‘job’
[08:26:20.648]   - Field: ‘conditions’
[08:26:20.648]   - Field: ‘expr’
[08:26:20.648]   - Field: ‘uuid’
[08:26:20.649]   - Field: ‘seed’
[08:26:20.649]   - Field: ‘version’
[08:26:20.649]   - Field: ‘result’
[08:26:20.649]   - Field: ‘asynchronous’
[08:26:20.650]   - Field: ‘calls’
[08:26:20.650]   - Field: ‘globals’
[08:26:20.650]   - Field: ‘stdout’
[08:26:20.650]   - Field: ‘earlySignal’
[08:26:20.650]   - Field: ‘lazy’
[08:26:20.651]   - Field: ‘state’
[08:26:20.651] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:20.651] - Launch lazy future ...
[08:26:20.652] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:20.652] Packages needed by future strategies (n = 0): <none>
[08:26:20.653] {
[08:26:20.653]     {
[08:26:20.653]         {
[08:26:20.653]             ...future.startTime <- base::Sys.time()
[08:26:20.653]             {
[08:26:20.653]                 {
[08:26:20.653]                   {
[08:26:20.653]                     {
[08:26:20.653]                       {
[08:26:20.653]                         base::local({
[08:26:20.653]                           has_future <- base::requireNamespace("future", 
[08:26:20.653]                             quietly = TRUE)
[08:26:20.653]                           if (has_future) {
[08:26:20.653]                             ns <- base::getNamespace("future")
[08:26:20.653]                             version <- ns[[".package"]][["version"]]
[08:26:20.653]                             if (is.null(version)) 
[08:26:20.653]                               version <- utils::packageVersion("future")
[08:26:20.653]                           }
[08:26:20.653]                           else {
[08:26:20.653]                             version <- NULL
[08:26:20.653]                           }
[08:26:20.653]                           if (!has_future || version < "1.8.0") {
[08:26:20.653]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:20.653]                               "", base::R.version$version.string), 
[08:26:20.653]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:20.653]                                 base::R.version$platform, 8 * 
[08:26:20.653]                                   base::.Machine$sizeof.pointer), 
[08:26:20.653]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:20.653]                                 "release", "version")], collapse = " "), 
[08:26:20.653]                               hostname = base::Sys.info()[["nodename"]])
[08:26:20.653]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:20.653]                               info)
[08:26:20.653]                             info <- base::paste(info, collapse = "; ")
[08:26:20.653]                             if (!has_future) {
[08:26:20.653]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:20.653]                                 info)
[08:26:20.653]                             }
[08:26:20.653]                             else {
[08:26:20.653]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:20.653]                                 info, version)
[08:26:20.653]                             }
[08:26:20.653]                             base::stop(msg)
[08:26:20.653]                           }
[08:26:20.653]                         })
[08:26:20.653]                       }
[08:26:20.653]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:20.653]                       base::options(mc.cores = 1L)
[08:26:20.653]                     }
[08:26:20.653]                     base::local({
[08:26:20.653]                       for (pkg in "future.apply") {
[08:26:20.653]                         base::loadNamespace(pkg)
[08:26:20.653]                         base::library(pkg, character.only = TRUE)
[08:26:20.653]                       }
[08:26:20.653]                     })
[08:26:20.653]                   }
[08:26:20.653]                   ...future.strategy.old <- future::plan("list")
[08:26:20.653]                   options(future.plan = NULL)
[08:26:20.653]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.653]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:20.653]                 }
[08:26:20.653]                 ...future.workdir <- getwd()
[08:26:20.653]             }
[08:26:20.653]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:20.653]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:20.653]         }
[08:26:20.653]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:20.653]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:20.653]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:20.653]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:20.653]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:20.653]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:20.653]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:20.653]             base::names(...future.oldOptions))
[08:26:20.653]     }
[08:26:20.653]     if (FALSE) {
[08:26:20.653]     }
[08:26:20.653]     else {
[08:26:20.653]         if (TRUE) {
[08:26:20.653]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:20.653]                 open = "w")
[08:26:20.653]         }
[08:26:20.653]         else {
[08:26:20.653]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:20.653]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:20.653]         }
[08:26:20.653]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:20.653]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:20.653]             base::sink(type = "output", split = FALSE)
[08:26:20.653]             base::close(...future.stdout)
[08:26:20.653]         }, add = TRUE)
[08:26:20.653]     }
[08:26:20.653]     ...future.frame <- base::sys.nframe()
[08:26:20.653]     ...future.conditions <- base::list()
[08:26:20.653]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:20.653]     if (FALSE) {
[08:26:20.653]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:20.653]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:20.653]     }
[08:26:20.653]     ...future.result <- base::tryCatch({
[08:26:20.653]         base::withCallingHandlers({
[08:26:20.653]             ...future.value <- base::withVisible(base::local({
[08:26:20.653]                 withCallingHandlers({
[08:26:20.653]                   {
[08:26:20.653]                     do.call(function(...) {
[08:26:20.653]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.653]                       if (!identical(...future.globals.maxSize.org, 
[08:26:20.653]                         ...future.globals.maxSize)) {
[08:26:20.653]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.653]                         on.exit(options(oopts), add = TRUE)
[08:26:20.653]                       }
[08:26:20.653]                       {
[08:26:20.653]                         lapply(seq_along(...future.elements_ii), 
[08:26:20.653]                           FUN = function(jj) {
[08:26:20.653]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.653]                             ...future.FUN(...future.X_jj, ...)
[08:26:20.653]                           })
[08:26:20.653]                       }
[08:26:20.653]                     }, args = future.call.arguments)
[08:26:20.653]                   }
[08:26:20.653]                 }, immediateCondition = function(cond) {
[08:26:20.653]                   save_rds <- function (object, pathname, ...) 
[08:26:20.653]                   {
[08:26:20.653]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:20.653]                     if (file_test("-f", pathname_tmp)) {
[08:26:20.653]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.653]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:20.653]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.653]                         fi_tmp[["mtime"]])
[08:26:20.653]                     }
[08:26:20.653]                     tryCatch({
[08:26:20.653]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:20.653]                     }, error = function(ex) {
[08:26:20.653]                       msg <- conditionMessage(ex)
[08:26:20.653]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.653]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:20.653]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.653]                         fi_tmp[["mtime"]], msg)
[08:26:20.653]                       ex$message <- msg
[08:26:20.653]                       stop(ex)
[08:26:20.653]                     })
[08:26:20.653]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:20.653]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:20.653]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:20.653]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.653]                       fi <- file.info(pathname)
[08:26:20.653]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:20.653]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.653]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:20.653]                         fi[["size"]], fi[["mtime"]])
[08:26:20.653]                       stop(msg)
[08:26:20.653]                     }
[08:26:20.653]                     invisible(pathname)
[08:26:20.653]                   }
[08:26:20.653]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:20.653]                     rootPath = tempdir()) 
[08:26:20.653]                   {
[08:26:20.653]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:20.653]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:20.653]                       tmpdir = path, fileext = ".rds")
[08:26:20.653]                     save_rds(obj, file)
[08:26:20.653]                   }
[08:26:20.653]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:20.653]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.653]                   {
[08:26:20.653]                     inherits <- base::inherits
[08:26:20.653]                     invokeRestart <- base::invokeRestart
[08:26:20.653]                     is.null <- base::is.null
[08:26:20.653]                     muffled <- FALSE
[08:26:20.653]                     if (inherits(cond, "message")) {
[08:26:20.653]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:20.653]                       if (muffled) 
[08:26:20.653]                         invokeRestart("muffleMessage")
[08:26:20.653]                     }
[08:26:20.653]                     else if (inherits(cond, "warning")) {
[08:26:20.653]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:20.653]                       if (muffled) 
[08:26:20.653]                         invokeRestart("muffleWarning")
[08:26:20.653]                     }
[08:26:20.653]                     else if (inherits(cond, "condition")) {
[08:26:20.653]                       if (!is.null(pattern)) {
[08:26:20.653]                         computeRestarts <- base::computeRestarts
[08:26:20.653]                         grepl <- base::grepl
[08:26:20.653]                         restarts <- computeRestarts(cond)
[08:26:20.653]                         for (restart in restarts) {
[08:26:20.653]                           name <- restart$name
[08:26:20.653]                           if (is.null(name)) 
[08:26:20.653]                             next
[08:26:20.653]                           if (!grepl(pattern, name)) 
[08:26:20.653]                             next
[08:26:20.653]                           invokeRestart(restart)
[08:26:20.653]                           muffled <- TRUE
[08:26:20.653]                           break
[08:26:20.653]                         }
[08:26:20.653]                       }
[08:26:20.653]                     }
[08:26:20.653]                     invisible(muffled)
[08:26:20.653]                   }
[08:26:20.653]                   muffleCondition(cond)
[08:26:20.653]                 })
[08:26:20.653]             }))
[08:26:20.653]             future::FutureResult(value = ...future.value$value, 
[08:26:20.653]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.653]                   ...future.rng), globalenv = if (FALSE) 
[08:26:20.653]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:20.653]                     ...future.globalenv.names))
[08:26:20.653]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:20.653]         }, condition = base::local({
[08:26:20.653]             c <- base::c
[08:26:20.653]             inherits <- base::inherits
[08:26:20.653]             invokeRestart <- base::invokeRestart
[08:26:20.653]             length <- base::length
[08:26:20.653]             list <- base::list
[08:26:20.653]             seq.int <- base::seq.int
[08:26:20.653]             signalCondition <- base::signalCondition
[08:26:20.653]             sys.calls <- base::sys.calls
[08:26:20.653]             `[[` <- base::`[[`
[08:26:20.653]             `+` <- base::`+`
[08:26:20.653]             `<<-` <- base::`<<-`
[08:26:20.653]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:20.653]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:20.653]                   3L)]
[08:26:20.653]             }
[08:26:20.653]             function(cond) {
[08:26:20.653]                 is_error <- inherits(cond, "error")
[08:26:20.653]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:20.653]                   NULL)
[08:26:20.653]                 if (is_error) {
[08:26:20.653]                   sessionInformation <- function() {
[08:26:20.653]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:20.653]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:20.653]                       search = base::search(), system = base::Sys.info())
[08:26:20.653]                   }
[08:26:20.653]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.653]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:20.653]                     cond$call), session = sessionInformation(), 
[08:26:20.653]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:20.653]                   signalCondition(cond)
[08:26:20.653]                 }
[08:26:20.653]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:20.653]                 "immediateCondition"))) {
[08:26:20.653]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:20.653]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.653]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:20.653]                   if (TRUE && !signal) {
[08:26:20.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.653]                     {
[08:26:20.653]                       inherits <- base::inherits
[08:26:20.653]                       invokeRestart <- base::invokeRestart
[08:26:20.653]                       is.null <- base::is.null
[08:26:20.653]                       muffled <- FALSE
[08:26:20.653]                       if (inherits(cond, "message")) {
[08:26:20.653]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.653]                         if (muffled) 
[08:26:20.653]                           invokeRestart("muffleMessage")
[08:26:20.653]                       }
[08:26:20.653]                       else if (inherits(cond, "warning")) {
[08:26:20.653]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.653]                         if (muffled) 
[08:26:20.653]                           invokeRestart("muffleWarning")
[08:26:20.653]                       }
[08:26:20.653]                       else if (inherits(cond, "condition")) {
[08:26:20.653]                         if (!is.null(pattern)) {
[08:26:20.653]                           computeRestarts <- base::computeRestarts
[08:26:20.653]                           grepl <- base::grepl
[08:26:20.653]                           restarts <- computeRestarts(cond)
[08:26:20.653]                           for (restart in restarts) {
[08:26:20.653]                             name <- restart$name
[08:26:20.653]                             if (is.null(name)) 
[08:26:20.653]                               next
[08:26:20.653]                             if (!grepl(pattern, name)) 
[08:26:20.653]                               next
[08:26:20.653]                             invokeRestart(restart)
[08:26:20.653]                             muffled <- TRUE
[08:26:20.653]                             break
[08:26:20.653]                           }
[08:26:20.653]                         }
[08:26:20.653]                       }
[08:26:20.653]                       invisible(muffled)
[08:26:20.653]                     }
[08:26:20.653]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.653]                   }
[08:26:20.653]                 }
[08:26:20.653]                 else {
[08:26:20.653]                   if (TRUE) {
[08:26:20.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.653]                     {
[08:26:20.653]                       inherits <- base::inherits
[08:26:20.653]                       invokeRestart <- base::invokeRestart
[08:26:20.653]                       is.null <- base::is.null
[08:26:20.653]                       muffled <- FALSE
[08:26:20.653]                       if (inherits(cond, "message")) {
[08:26:20.653]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.653]                         if (muffled) 
[08:26:20.653]                           invokeRestart("muffleMessage")
[08:26:20.653]                       }
[08:26:20.653]                       else if (inherits(cond, "warning")) {
[08:26:20.653]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.653]                         if (muffled) 
[08:26:20.653]                           invokeRestart("muffleWarning")
[08:26:20.653]                       }
[08:26:20.653]                       else if (inherits(cond, "condition")) {
[08:26:20.653]                         if (!is.null(pattern)) {
[08:26:20.653]                           computeRestarts <- base::computeRestarts
[08:26:20.653]                           grepl <- base::grepl
[08:26:20.653]                           restarts <- computeRestarts(cond)
[08:26:20.653]                           for (restart in restarts) {
[08:26:20.653]                             name <- restart$name
[08:26:20.653]                             if (is.null(name)) 
[08:26:20.653]                               next
[08:26:20.653]                             if (!grepl(pattern, name)) 
[08:26:20.653]                               next
[08:26:20.653]                             invokeRestart(restart)
[08:26:20.653]                             muffled <- TRUE
[08:26:20.653]                             break
[08:26:20.653]                           }
[08:26:20.653]                         }
[08:26:20.653]                       }
[08:26:20.653]                       invisible(muffled)
[08:26:20.653]                     }
[08:26:20.653]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.653]                   }
[08:26:20.653]                 }
[08:26:20.653]             }
[08:26:20.653]         }))
[08:26:20.653]     }, error = function(ex) {
[08:26:20.653]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:20.653]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.653]                 ...future.rng), started = ...future.startTime, 
[08:26:20.653]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:20.653]             version = "1.8"), class = "FutureResult")
[08:26:20.653]     }, finally = {
[08:26:20.653]         if (!identical(...future.workdir, getwd())) 
[08:26:20.653]             setwd(...future.workdir)
[08:26:20.653]         {
[08:26:20.653]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:20.653]                 ...future.oldOptions$nwarnings <- NULL
[08:26:20.653]             }
[08:26:20.653]             base::options(...future.oldOptions)
[08:26:20.653]             if (.Platform$OS.type == "windows") {
[08:26:20.653]                 old_names <- names(...future.oldEnvVars)
[08:26:20.653]                 envs <- base::Sys.getenv()
[08:26:20.653]                 names <- names(envs)
[08:26:20.653]                 common <- intersect(names, old_names)
[08:26:20.653]                 added <- setdiff(names, old_names)
[08:26:20.653]                 removed <- setdiff(old_names, names)
[08:26:20.653]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:20.653]                   envs[common]]
[08:26:20.653]                 NAMES <- toupper(changed)
[08:26:20.653]                 args <- list()
[08:26:20.653]                 for (kk in seq_along(NAMES)) {
[08:26:20.653]                   name <- changed[[kk]]
[08:26:20.653]                   NAME <- NAMES[[kk]]
[08:26:20.653]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.653]                     next
[08:26:20.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.653]                 }
[08:26:20.653]                 NAMES <- toupper(added)
[08:26:20.653]                 for (kk in seq_along(NAMES)) {
[08:26:20.653]                   name <- added[[kk]]
[08:26:20.653]                   NAME <- NAMES[[kk]]
[08:26:20.653]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.653]                     next
[08:26:20.653]                   args[[name]] <- ""
[08:26:20.653]                 }
[08:26:20.653]                 NAMES <- toupper(removed)
[08:26:20.653]                 for (kk in seq_along(NAMES)) {
[08:26:20.653]                   name <- removed[[kk]]
[08:26:20.653]                   NAME <- NAMES[[kk]]
[08:26:20.653]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.653]                     next
[08:26:20.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.653]                 }
[08:26:20.653]                 if (length(args) > 0) 
[08:26:20.653]                   base::do.call(base::Sys.setenv, args = args)
[08:26:20.653]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:20.653]             }
[08:26:20.653]             else {
[08:26:20.653]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:20.653]             }
[08:26:20.653]             {
[08:26:20.653]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:20.653]                   0L) {
[08:26:20.653]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:20.653]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:20.653]                   base::options(opts)
[08:26:20.653]                 }
[08:26:20.653]                 {
[08:26:20.653]                   {
[08:26:20.653]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:20.653]                     NULL
[08:26:20.653]                   }
[08:26:20.653]                   options(future.plan = NULL)
[08:26:20.653]                   if (is.na(NA_character_)) 
[08:26:20.653]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.653]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:20.653]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:20.653]                     .init = FALSE)
[08:26:20.653]                 }
[08:26:20.653]             }
[08:26:20.653]         }
[08:26:20.653]     })
[08:26:20.653]     if (TRUE) {
[08:26:20.653]         base::sink(type = "output", split = FALSE)
[08:26:20.653]         if (TRUE) {
[08:26:20.653]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:20.653]         }
[08:26:20.653]         else {
[08:26:20.653]             ...future.result["stdout"] <- base::list(NULL)
[08:26:20.653]         }
[08:26:20.653]         base::close(...future.stdout)
[08:26:20.653]         ...future.stdout <- NULL
[08:26:20.653]     }
[08:26:20.653]     ...future.result$conditions <- ...future.conditions
[08:26:20.653]     ...future.result$finished <- base::Sys.time()
[08:26:20.653]     ...future.result
[08:26:20.653] }
[08:26:20.656] assign_globals() ...
[08:26:20.656] List of 11
[08:26:20.656]  $ ...future.FUN            :function (x, ...)  
[08:26:20.656]  $ x_FUN                    :function (x)  
[08:26:20.656]  $ times                    : int 4
[08:26:20.656]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:20.656]  $ stop_if_not              :function (...)  
[08:26:20.656]  $ dim                      : int [1:2] 2 2
[08:26:20.656]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:20.656]  $ future.call.arguments    : list()
[08:26:20.656]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.656]  $ ...future.elements_ii    :List of 5
[08:26:20.656]   ..$ : int 6
[08:26:20.656]   ..$ : int 7
[08:26:20.656]   ..$ : int 8
[08:26:20.656]   ..$ : int 9
[08:26:20.656]   ..$ : int 10
[08:26:20.656]  $ ...future.seeds_ii       : NULL
[08:26:20.656]  $ ...future.globals.maxSize: NULL
[08:26:20.656]  - attr(*, "where")=List of 11
[08:26:20.656]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:20.656]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:20.656]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:20.656]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:20.656]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:20.656]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:20.656]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:20.656]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:20.656]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:20.656]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:20.656]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:20.656]  - attr(*, "resolved")= logi FALSE
[08:26:20.656]  - attr(*, "total_size")= num 29094
[08:26:20.656]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.656]  - attr(*, "already-done")= logi TRUE
[08:26:20.667] - copied ‘...future.FUN’ to environment
[08:26:20.667] - reassign environment for ‘x_FUN’
[08:26:20.667] - copied ‘x_FUN’ to environment
[08:26:20.667] - copied ‘times’ to environment
[08:26:20.668] - copied ‘stopf’ to environment
[08:26:20.668] - copied ‘stop_if_not’ to environment
[08:26:20.668] - copied ‘dim’ to environment
[08:26:20.668] - copied ‘valid_types’ to environment
[08:26:20.668] - copied ‘future.call.arguments’ to environment
[08:26:20.668] - copied ‘...future.elements_ii’ to environment
[08:26:20.668] - copied ‘...future.seeds_ii’ to environment
[08:26:20.668] - copied ‘...future.globals.maxSize’ to environment
[08:26:20.668] assign_globals() ... done
[08:26:20.668] requestCore(): workers = 2
[08:26:20.671] MulticoreFuture started
[08:26:20.671] - Launch lazy future ... done
[08:26:20.671] run() for ‘MulticoreFuture’ ... done
[08:26:20.672] Created future:
[08:26:20.673] plan(): Setting new future strategy stack:
[08:26:20.673] List of future strategies:
[08:26:20.673] 1. sequential:
[08:26:20.673]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:20.673]    - tweaked: FALSE
[08:26:20.673]    - call: NULL
[08:26:20.674] plan(): nbrOfWorkers() = 1
[08:26:20.677] plan(): Setting new future strategy stack:
[08:26:20.677] List of future strategies:
[08:26:20.677] 1. multicore:
[08:26:20.677]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:20.677]    - tweaked: FALSE
[08:26:20.677]    - call: plan(strategy)
[08:26:20.672] MulticoreFuture:
[08:26:20.672] Label: ‘future_vapply-2’
[08:26:20.672] Expression:
[08:26:20.672] {
[08:26:20.672]     do.call(function(...) {
[08:26:20.672]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.672]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.672]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.672]             on.exit(options(oopts), add = TRUE)
[08:26:20.672]         }
[08:26:20.672]         {
[08:26:20.672]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.672]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.672]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.672]             })
[08:26:20.672]         }
[08:26:20.672]     }, args = future.call.arguments)
[08:26:20.672] }
[08:26:20.672] Lazy evaluation: FALSE
[08:26:20.672] Asynchronous evaluation: TRUE
[08:26:20.672] Local evaluation: TRUE
[08:26:20.672] Environment: R_GlobalEnv
[08:26:20.672] Capture standard output: TRUE
[08:26:20.672] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:20.672] Globals: 11 objects totaling 16.28 KiB (function ‘...future.FUN’ of 6.70 KiB, function ‘x_FUN’ of 1.36 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:20.672] Packages: 1 packages (‘future.apply’)
[08:26:20.672] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:20.672] Resolved: FALSE
[08:26:20.672] Value: <not collected>
[08:26:20.672] Conditions captured: <none>
[08:26:20.672] Early signaling: FALSE
[08:26:20.672] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:20.672] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.685] Chunk #2 of 2 ... DONE
[08:26:20.685] Launching 2 futures (chunks) ... DONE
[08:26:20.685] Resolving 2 futures (chunks) ...
[08:26:20.685] resolve() on list ...
[08:26:20.685]  recursive: 0
[08:26:20.686]  length: 2
[08:26:20.686] 
[08:26:20.686] Future #1
[08:26:20.686] result() for MulticoreFuture ...
[08:26:20.688] plan(): nbrOfWorkers() = 2
[08:26:20.690] result() for MulticoreFuture ...
[08:26:20.690] result() for MulticoreFuture ... done
[08:26:20.690] result() for MulticoreFuture ... done
[08:26:20.691] result() for MulticoreFuture ...
[08:26:20.691] result() for MulticoreFuture ... done
[08:26:20.691] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:26:20.692] - nx: 2
[08:26:20.692] - relay: TRUE
[08:26:20.692] - stdout: TRUE
[08:26:20.692] - signal: TRUE
[08:26:20.693] - resignal: FALSE
[08:26:20.693] - force: TRUE
[08:26:20.693] - relayed: [n=2] FALSE, FALSE
[08:26:20.693] - queued futures: [n=2] FALSE, FALSE
[08:26:20.694]  - until=1
[08:26:20.694]  - relaying element #1
[08:26:20.694] result() for MulticoreFuture ...
[08:26:20.694] result() for MulticoreFuture ... done
[08:26:20.695] result() for MulticoreFuture ...
[08:26:20.695] result() for MulticoreFuture ... done
[08:26:20.695] result() for MulticoreFuture ...
[08:26:20.695] result() for MulticoreFuture ... done
[08:26:20.696] result() for MulticoreFuture ...
[08:26:20.696] result() for MulticoreFuture ... done
[08:26:20.696] - relayed: [n=2] TRUE, FALSE
[08:26:20.697] - queued futures: [n=2] TRUE, FALSE
[08:26:20.697] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:26:20.697]  length: 1 (resolved future 1)
[08:26:20.697] Future #2
[08:26:20.698] result() for MulticoreFuture ...
[08:26:20.699] result() for MulticoreFuture ...
[08:26:20.699] result() for MulticoreFuture ... done
[08:26:20.699] result() for MulticoreFuture ... done
[08:26:20.699] result() for MulticoreFuture ...
[08:26:20.700] result() for MulticoreFuture ... done
[08:26:20.700] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:26:20.700] - nx: 2
[08:26:20.700] - relay: TRUE
[08:26:20.700] - stdout: TRUE
[08:26:20.701] - signal: TRUE
[08:26:20.701] - resignal: FALSE
[08:26:20.701] - force: TRUE
[08:26:20.701] - relayed: [n=2] TRUE, FALSE
[08:26:20.701] - queued futures: [n=2] TRUE, FALSE
[08:26:20.701]  - until=2
[08:26:20.702]  - relaying element #2
[08:26:20.702] result() for MulticoreFuture ...
[08:26:20.702] result() for MulticoreFuture ... done
[08:26:20.702] result() for MulticoreFuture ...
[08:26:20.702] result() for MulticoreFuture ... done
[08:26:20.702] result() for MulticoreFuture ...
[08:26:20.702] result() for MulticoreFuture ... done
[08:26:20.703] result() for MulticoreFuture ...
[08:26:20.703] result() for MulticoreFuture ... done
[08:26:20.703] - relayed: [n=2] TRUE, TRUE
[08:26:20.703] - queued futures: [n=2] TRUE, TRUE
[08:26:20.703] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:26:20.703]  length: 0 (resolved future 2)
[08:26:20.703] Relaying remaining futures
[08:26:20.703] signalConditionsASAP(NULL, pos=0) ...
[08:26:20.703] - nx: 2
[08:26:20.703] - relay: TRUE
[08:26:20.704] - stdout: TRUE
[08:26:20.704] - signal: TRUE
[08:26:20.704] - resignal: FALSE
[08:26:20.704] - force: TRUE
[08:26:20.704] - relayed: [n=2] TRUE, TRUE
[08:26:20.704] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:20.704] - relayed: [n=2] TRUE, TRUE
[08:26:20.704] - queued futures: [n=2] TRUE, TRUE
[08:26:20.704] signalConditionsASAP(NULL, pos=0) ... done
[08:26:20.705] resolve() on list ... DONE
[08:26:20.705] result() for MulticoreFuture ...
[08:26:20.705] result() for MulticoreFuture ... done
[08:26:20.705] result() for MulticoreFuture ...
[08:26:20.705] result() for MulticoreFuture ... done
[08:26:20.705] result() for MulticoreFuture ...
[08:26:20.705] result() for MulticoreFuture ... done
[08:26:20.705] result() for MulticoreFuture ...
[08:26:20.705] result() for MulticoreFuture ... done
[08:26:20.706]  - Number of value chunks collected: 2
[08:26:20.706] Resolving 2 futures (chunks) ... DONE
[08:26:20.706] Reducing values from 2 chunks ...
[08:26:20.706]  - Number of values collected after concatenation: 10
[08:26:20.706]  - Number of values expected: 10
[08:26:20.706] Reducing values from 2 chunks ... DONE
[08:26:20.706] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[08:26:20.709] future_lapply() ...
[08:26:20.713] Number of chunks: 2
[08:26:20.713] getGlobalsAndPackagesXApply() ...
[08:26:20.713]  - future.globals: TRUE
[08:26:20.713] getGlobalsAndPackages() ...
[08:26:20.713] Searching for globals...
[08:26:20.717] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[08:26:20.717] Searching for globals ... DONE
[08:26:20.718] Resolving globals: FALSE
[08:26:20.720] The total size of the 7 globals is 13.03 KiB (13339 bytes)
[08:26:20.721] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.03 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.75 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:20.721] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:20.721] - packages: [2] ‘stats’, ‘future.apply’
[08:26:20.721] getGlobalsAndPackages() ... DONE
[08:26:20.722]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:20.722]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[08:26:20.722] Finding globals ... DONE
[08:26:20.722]  - use_args: TRUE
[08:26:20.722]  - Getting '...' globals ...
[08:26:20.723] resolve() on list ...
[08:26:20.723]  recursive: 0
[08:26:20.723]  length: 1
[08:26:20.723]  elements: ‘...’
[08:26:20.723]  length: 0 (resolved future 1)
[08:26:20.723] resolve() on list ... DONE
[08:26:20.723]    - '...' content: [n=0] 
[08:26:20.723] List of 1
[08:26:20.723]  $ ...: list()
[08:26:20.723]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.723]  - attr(*, "where")=List of 1
[08:26:20.723]   ..$ ...:<environment: 0x562ca723c890> 
[08:26:20.723]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.723]  - attr(*, "resolved")= logi TRUE
[08:26:20.723]  - attr(*, "total_size")= num NA
[08:26:20.726]  - Getting '...' globals ... DONE
[08:26:20.727] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:20.727] List of 8
[08:26:20.727]  $ ...future.FUN:function (x, ...)  
[08:26:20.727]  $ x_FUN        :function (x, ...)  
[08:26:20.727]  $ times        : int 5
[08:26:20.727]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:20.727]  $ stop_if_not  :function (...)  
[08:26:20.727]  $ dim          : NULL
[08:26:20.727]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:20.727]  $ ...          : list()
[08:26:20.727]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.727]  - attr(*, "where")=List of 8
[08:26:20.727]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:20.727]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:20.727]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:20.727]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:20.727]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:20.727]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:20.727]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:20.727]   ..$ ...          :<environment: 0x562ca723c890> 
[08:26:20.727]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.727]  - attr(*, "resolved")= logi FALSE
[08:26:20.727]  - attr(*, "total_size")= num 24127
[08:26:20.732] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[08:26:20.732] getGlobalsAndPackagesXApply() ... DONE
[08:26:20.733] Number of futures (= number of chunks): 2
[08:26:20.733] Launching 2 futures (chunks) ...
[08:26:20.733] Chunk #1 of 2 ...
[08:26:20.733]  - Finding globals in 'X' for chunk #1 ...
[08:26:20.733] getGlobalsAndPackages() ...
[08:26:20.733] Searching for globals...
[08:26:20.733] 
[08:26:20.734] Searching for globals ... DONE
[08:26:20.734] - globals: [0] <none>
[08:26:20.734] getGlobalsAndPackages() ... DONE
[08:26:20.734]    + additional globals found: [n=0] 
[08:26:20.734]    + additional namespaces needed: [n=0] 
[08:26:20.734]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:20.734]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:20.734]  - seeds: <none>
[08:26:20.734]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.734] getGlobalsAndPackages() ...
[08:26:20.735] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.735] Resolving globals: FALSE
[08:26:20.735] Tweak future expression to call with '...' arguments ...
[08:26:20.735] {
[08:26:20.735]     do.call(function(...) {
[08:26:20.735]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.735]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.735]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.735]             on.exit(options(oopts), add = TRUE)
[08:26:20.735]         }
[08:26:20.735]         {
[08:26:20.735]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.735]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.735]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.735]             })
[08:26:20.735]         }
[08:26:20.735]     }, args = future.call.arguments)
[08:26:20.735] }
[08:26:20.735] Tweak future expression to call with '...' arguments ... DONE
[08:26:20.736] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.736] - packages: [2] ‘stats’, ‘future.apply’
[08:26:20.736] getGlobalsAndPackages() ... DONE
[08:26:20.736] run() for ‘Future’ ...
[08:26:20.736] - state: ‘created’
[08:26:20.737] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:20.738] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.738] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:20.739]   - Field: ‘label’
[08:26:20.739]   - Field: ‘local’
[08:26:20.739]   - Field: ‘owner’
[08:26:20.739]   - Field: ‘envir’
[08:26:20.739]   - Field: ‘workers’
[08:26:20.739]   - Field: ‘packages’
[08:26:20.739]   - Field: ‘gc’
[08:26:20.739]   - Field: ‘job’
[08:26:20.739]   - Field: ‘conditions’
[08:26:20.739]   - Field: ‘expr’
[08:26:20.739]   - Field: ‘uuid’
[08:26:20.740]   - Field: ‘seed’
[08:26:20.740]   - Field: ‘version’
[08:26:20.740]   - Field: ‘result’
[08:26:20.740]   - Field: ‘asynchronous’
[08:26:20.740]   - Field: ‘calls’
[08:26:20.740]   - Field: ‘globals’
[08:26:20.740]   - Field: ‘stdout’
[08:26:20.740]   - Field: ‘earlySignal’
[08:26:20.740]   - Field: ‘lazy’
[08:26:20.740]   - Field: ‘state’
[08:26:20.740] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:20.741] - Launch lazy future ...
[08:26:20.741] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[08:26:20.741] Packages needed by future strategies (n = 0): <none>
[08:26:20.742] {
[08:26:20.742]     {
[08:26:20.742]         {
[08:26:20.742]             ...future.startTime <- base::Sys.time()
[08:26:20.742]             {
[08:26:20.742]                 {
[08:26:20.742]                   {
[08:26:20.742]                     {
[08:26:20.742]                       {
[08:26:20.742]                         base::local({
[08:26:20.742]                           has_future <- base::requireNamespace("future", 
[08:26:20.742]                             quietly = TRUE)
[08:26:20.742]                           if (has_future) {
[08:26:20.742]                             ns <- base::getNamespace("future")
[08:26:20.742]                             version <- ns[[".package"]][["version"]]
[08:26:20.742]                             if (is.null(version)) 
[08:26:20.742]                               version <- utils::packageVersion("future")
[08:26:20.742]                           }
[08:26:20.742]                           else {
[08:26:20.742]                             version <- NULL
[08:26:20.742]                           }
[08:26:20.742]                           if (!has_future || version < "1.8.0") {
[08:26:20.742]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:20.742]                               "", base::R.version$version.string), 
[08:26:20.742]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:20.742]                                 base::R.version$platform, 8 * 
[08:26:20.742]                                   base::.Machine$sizeof.pointer), 
[08:26:20.742]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:20.742]                                 "release", "version")], collapse = " "), 
[08:26:20.742]                               hostname = base::Sys.info()[["nodename"]])
[08:26:20.742]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:20.742]                               info)
[08:26:20.742]                             info <- base::paste(info, collapse = "; ")
[08:26:20.742]                             if (!has_future) {
[08:26:20.742]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:20.742]                                 info)
[08:26:20.742]                             }
[08:26:20.742]                             else {
[08:26:20.742]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:20.742]                                 info, version)
[08:26:20.742]                             }
[08:26:20.742]                             base::stop(msg)
[08:26:20.742]                           }
[08:26:20.742]                         })
[08:26:20.742]                       }
[08:26:20.742]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:20.742]                       base::options(mc.cores = 1L)
[08:26:20.742]                     }
[08:26:20.742]                     base::local({
[08:26:20.742]                       for (pkg in c("stats", "future.apply")) {
[08:26:20.742]                         base::loadNamespace(pkg)
[08:26:20.742]                         base::library(pkg, character.only = TRUE)
[08:26:20.742]                       }
[08:26:20.742]                     })
[08:26:20.742]                   }
[08:26:20.742]                   ...future.strategy.old <- future::plan("list")
[08:26:20.742]                   options(future.plan = NULL)
[08:26:20.742]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.742]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:20.742]                 }
[08:26:20.742]                 ...future.workdir <- getwd()
[08:26:20.742]             }
[08:26:20.742]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:20.742]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:20.742]         }
[08:26:20.742]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:20.742]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:20.742]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:20.742]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:20.742]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:20.742]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:20.742]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:20.742]             base::names(...future.oldOptions))
[08:26:20.742]     }
[08:26:20.742]     if (FALSE) {
[08:26:20.742]     }
[08:26:20.742]     else {
[08:26:20.742]         if (TRUE) {
[08:26:20.742]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:20.742]                 open = "w")
[08:26:20.742]         }
[08:26:20.742]         else {
[08:26:20.742]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:20.742]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:20.742]         }
[08:26:20.742]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:20.742]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:20.742]             base::sink(type = "output", split = FALSE)
[08:26:20.742]             base::close(...future.stdout)
[08:26:20.742]         }, add = TRUE)
[08:26:20.742]     }
[08:26:20.742]     ...future.frame <- base::sys.nframe()
[08:26:20.742]     ...future.conditions <- base::list()
[08:26:20.742]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:20.742]     if (FALSE) {
[08:26:20.742]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:20.742]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:20.742]     }
[08:26:20.742]     ...future.result <- base::tryCatch({
[08:26:20.742]         base::withCallingHandlers({
[08:26:20.742]             ...future.value <- base::withVisible(base::local({
[08:26:20.742]                 withCallingHandlers({
[08:26:20.742]                   {
[08:26:20.742]                     do.call(function(...) {
[08:26:20.742]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.742]                       if (!identical(...future.globals.maxSize.org, 
[08:26:20.742]                         ...future.globals.maxSize)) {
[08:26:20.742]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.742]                         on.exit(options(oopts), add = TRUE)
[08:26:20.742]                       }
[08:26:20.742]                       {
[08:26:20.742]                         lapply(seq_along(...future.elements_ii), 
[08:26:20.742]                           FUN = function(jj) {
[08:26:20.742]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.742]                             ...future.FUN(...future.X_jj, ...)
[08:26:20.742]                           })
[08:26:20.742]                       }
[08:26:20.742]                     }, args = future.call.arguments)
[08:26:20.742]                   }
[08:26:20.742]                 }, immediateCondition = function(cond) {
[08:26:20.742]                   save_rds <- function (object, pathname, ...) 
[08:26:20.742]                   {
[08:26:20.742]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:20.742]                     if (file_test("-f", pathname_tmp)) {
[08:26:20.742]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.742]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:20.742]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.742]                         fi_tmp[["mtime"]])
[08:26:20.742]                     }
[08:26:20.742]                     tryCatch({
[08:26:20.742]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:20.742]                     }, error = function(ex) {
[08:26:20.742]                       msg <- conditionMessage(ex)
[08:26:20.742]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.742]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:20.742]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.742]                         fi_tmp[["mtime"]], msg)
[08:26:20.742]                       ex$message <- msg
[08:26:20.742]                       stop(ex)
[08:26:20.742]                     })
[08:26:20.742]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:20.742]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:20.742]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:20.742]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.742]                       fi <- file.info(pathname)
[08:26:20.742]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:20.742]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.742]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:20.742]                         fi[["size"]], fi[["mtime"]])
[08:26:20.742]                       stop(msg)
[08:26:20.742]                     }
[08:26:20.742]                     invisible(pathname)
[08:26:20.742]                   }
[08:26:20.742]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:20.742]                     rootPath = tempdir()) 
[08:26:20.742]                   {
[08:26:20.742]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:20.742]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:20.742]                       tmpdir = path, fileext = ".rds")
[08:26:20.742]                     save_rds(obj, file)
[08:26:20.742]                   }
[08:26:20.742]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:20.742]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.742]                   {
[08:26:20.742]                     inherits <- base::inherits
[08:26:20.742]                     invokeRestart <- base::invokeRestart
[08:26:20.742]                     is.null <- base::is.null
[08:26:20.742]                     muffled <- FALSE
[08:26:20.742]                     if (inherits(cond, "message")) {
[08:26:20.742]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:20.742]                       if (muffled) 
[08:26:20.742]                         invokeRestart("muffleMessage")
[08:26:20.742]                     }
[08:26:20.742]                     else if (inherits(cond, "warning")) {
[08:26:20.742]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:20.742]                       if (muffled) 
[08:26:20.742]                         invokeRestart("muffleWarning")
[08:26:20.742]                     }
[08:26:20.742]                     else if (inherits(cond, "condition")) {
[08:26:20.742]                       if (!is.null(pattern)) {
[08:26:20.742]                         computeRestarts <- base::computeRestarts
[08:26:20.742]                         grepl <- base::grepl
[08:26:20.742]                         restarts <- computeRestarts(cond)
[08:26:20.742]                         for (restart in restarts) {
[08:26:20.742]                           name <- restart$name
[08:26:20.742]                           if (is.null(name)) 
[08:26:20.742]                             next
[08:26:20.742]                           if (!grepl(pattern, name)) 
[08:26:20.742]                             next
[08:26:20.742]                           invokeRestart(restart)
[08:26:20.742]                           muffled <- TRUE
[08:26:20.742]                           break
[08:26:20.742]                         }
[08:26:20.742]                       }
[08:26:20.742]                     }
[08:26:20.742]                     invisible(muffled)
[08:26:20.742]                   }
[08:26:20.742]                   muffleCondition(cond)
[08:26:20.742]                 })
[08:26:20.742]             }))
[08:26:20.742]             future::FutureResult(value = ...future.value$value, 
[08:26:20.742]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.742]                   ...future.rng), globalenv = if (FALSE) 
[08:26:20.742]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:20.742]                     ...future.globalenv.names))
[08:26:20.742]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:20.742]         }, condition = base::local({
[08:26:20.742]             c <- base::c
[08:26:20.742]             inherits <- base::inherits
[08:26:20.742]             invokeRestart <- base::invokeRestart
[08:26:20.742]             length <- base::length
[08:26:20.742]             list <- base::list
[08:26:20.742]             seq.int <- base::seq.int
[08:26:20.742]             signalCondition <- base::signalCondition
[08:26:20.742]             sys.calls <- base::sys.calls
[08:26:20.742]             `[[` <- base::`[[`
[08:26:20.742]             `+` <- base::`+`
[08:26:20.742]             `<<-` <- base::`<<-`
[08:26:20.742]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:20.742]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:20.742]                   3L)]
[08:26:20.742]             }
[08:26:20.742]             function(cond) {
[08:26:20.742]                 is_error <- inherits(cond, "error")
[08:26:20.742]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:20.742]                   NULL)
[08:26:20.742]                 if (is_error) {
[08:26:20.742]                   sessionInformation <- function() {
[08:26:20.742]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:20.742]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:20.742]                       search = base::search(), system = base::Sys.info())
[08:26:20.742]                   }
[08:26:20.742]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.742]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:20.742]                     cond$call), session = sessionInformation(), 
[08:26:20.742]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:20.742]                   signalCondition(cond)
[08:26:20.742]                 }
[08:26:20.742]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:20.742]                 "immediateCondition"))) {
[08:26:20.742]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:20.742]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.742]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:20.742]                   if (TRUE && !signal) {
[08:26:20.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.742]                     {
[08:26:20.742]                       inherits <- base::inherits
[08:26:20.742]                       invokeRestart <- base::invokeRestart
[08:26:20.742]                       is.null <- base::is.null
[08:26:20.742]                       muffled <- FALSE
[08:26:20.742]                       if (inherits(cond, "message")) {
[08:26:20.742]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.742]                         if (muffled) 
[08:26:20.742]                           invokeRestart("muffleMessage")
[08:26:20.742]                       }
[08:26:20.742]                       else if (inherits(cond, "warning")) {
[08:26:20.742]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.742]                         if (muffled) 
[08:26:20.742]                           invokeRestart("muffleWarning")
[08:26:20.742]                       }
[08:26:20.742]                       else if (inherits(cond, "condition")) {
[08:26:20.742]                         if (!is.null(pattern)) {
[08:26:20.742]                           computeRestarts <- base::computeRestarts
[08:26:20.742]                           grepl <- base::grepl
[08:26:20.742]                           restarts <- computeRestarts(cond)
[08:26:20.742]                           for (restart in restarts) {
[08:26:20.742]                             name <- restart$name
[08:26:20.742]                             if (is.null(name)) 
[08:26:20.742]                               next
[08:26:20.742]                             if (!grepl(pattern, name)) 
[08:26:20.742]                               next
[08:26:20.742]                             invokeRestart(restart)
[08:26:20.742]                             muffled <- TRUE
[08:26:20.742]                             break
[08:26:20.742]                           }
[08:26:20.742]                         }
[08:26:20.742]                       }
[08:26:20.742]                       invisible(muffled)
[08:26:20.742]                     }
[08:26:20.742]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.742]                   }
[08:26:20.742]                 }
[08:26:20.742]                 else {
[08:26:20.742]                   if (TRUE) {
[08:26:20.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.742]                     {
[08:26:20.742]                       inherits <- base::inherits
[08:26:20.742]                       invokeRestart <- base::invokeRestart
[08:26:20.742]                       is.null <- base::is.null
[08:26:20.742]                       muffled <- FALSE
[08:26:20.742]                       if (inherits(cond, "message")) {
[08:26:20.742]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.742]                         if (muffled) 
[08:26:20.742]                           invokeRestart("muffleMessage")
[08:26:20.742]                       }
[08:26:20.742]                       else if (inherits(cond, "warning")) {
[08:26:20.742]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.742]                         if (muffled) 
[08:26:20.742]                           invokeRestart("muffleWarning")
[08:26:20.742]                       }
[08:26:20.742]                       else if (inherits(cond, "condition")) {
[08:26:20.742]                         if (!is.null(pattern)) {
[08:26:20.742]                           computeRestarts <- base::computeRestarts
[08:26:20.742]                           grepl <- base::grepl
[08:26:20.742]                           restarts <- computeRestarts(cond)
[08:26:20.742]                           for (restart in restarts) {
[08:26:20.742]                             name <- restart$name
[08:26:20.742]                             if (is.null(name)) 
[08:26:20.742]                               next
[08:26:20.742]                             if (!grepl(pattern, name)) 
[08:26:20.742]                               next
[08:26:20.742]                             invokeRestart(restart)
[08:26:20.742]                             muffled <- TRUE
[08:26:20.742]                             break
[08:26:20.742]                           }
[08:26:20.742]                         }
[08:26:20.742]                       }
[08:26:20.742]                       invisible(muffled)
[08:26:20.742]                     }
[08:26:20.742]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.742]                   }
[08:26:20.742]                 }
[08:26:20.742]             }
[08:26:20.742]         }))
[08:26:20.742]     }, error = function(ex) {
[08:26:20.742]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:20.742]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.742]                 ...future.rng), started = ...future.startTime, 
[08:26:20.742]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:20.742]             version = "1.8"), class = "FutureResult")
[08:26:20.742]     }, finally = {
[08:26:20.742]         if (!identical(...future.workdir, getwd())) 
[08:26:20.742]             setwd(...future.workdir)
[08:26:20.742]         {
[08:26:20.742]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:20.742]                 ...future.oldOptions$nwarnings <- NULL
[08:26:20.742]             }
[08:26:20.742]             base::options(...future.oldOptions)
[08:26:20.742]             if (.Platform$OS.type == "windows") {
[08:26:20.742]                 old_names <- names(...future.oldEnvVars)
[08:26:20.742]                 envs <- base::Sys.getenv()
[08:26:20.742]                 names <- names(envs)
[08:26:20.742]                 common <- intersect(names, old_names)
[08:26:20.742]                 added <- setdiff(names, old_names)
[08:26:20.742]                 removed <- setdiff(old_names, names)
[08:26:20.742]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:20.742]                   envs[common]]
[08:26:20.742]                 NAMES <- toupper(changed)
[08:26:20.742]                 args <- list()
[08:26:20.742]                 for (kk in seq_along(NAMES)) {
[08:26:20.742]                   name <- changed[[kk]]
[08:26:20.742]                   NAME <- NAMES[[kk]]
[08:26:20.742]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.742]                     next
[08:26:20.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.742]                 }
[08:26:20.742]                 NAMES <- toupper(added)
[08:26:20.742]                 for (kk in seq_along(NAMES)) {
[08:26:20.742]                   name <- added[[kk]]
[08:26:20.742]                   NAME <- NAMES[[kk]]
[08:26:20.742]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.742]                     next
[08:26:20.742]                   args[[name]] <- ""
[08:26:20.742]                 }
[08:26:20.742]                 NAMES <- toupper(removed)
[08:26:20.742]                 for (kk in seq_along(NAMES)) {
[08:26:20.742]                   name <- removed[[kk]]
[08:26:20.742]                   NAME <- NAMES[[kk]]
[08:26:20.742]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.742]                     next
[08:26:20.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.742]                 }
[08:26:20.742]                 if (length(args) > 0) 
[08:26:20.742]                   base::do.call(base::Sys.setenv, args = args)
[08:26:20.742]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:20.742]             }
[08:26:20.742]             else {
[08:26:20.742]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:20.742]             }
[08:26:20.742]             {
[08:26:20.742]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:20.742]                   0L) {
[08:26:20.742]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:20.742]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:20.742]                   base::options(opts)
[08:26:20.742]                 }
[08:26:20.742]                 {
[08:26:20.742]                   {
[08:26:20.742]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:20.742]                     NULL
[08:26:20.742]                   }
[08:26:20.742]                   options(future.plan = NULL)
[08:26:20.742]                   if (is.na(NA_character_)) 
[08:26:20.742]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.742]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:20.742]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:20.742]                     .init = FALSE)
[08:26:20.742]                 }
[08:26:20.742]             }
[08:26:20.742]         }
[08:26:20.742]     })
[08:26:20.742]     if (TRUE) {
[08:26:20.742]         base::sink(type = "output", split = FALSE)
[08:26:20.742]         if (TRUE) {
[08:26:20.742]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:20.742]         }
[08:26:20.742]         else {
[08:26:20.742]             ...future.result["stdout"] <- base::list(NULL)
[08:26:20.742]         }
[08:26:20.742]         base::close(...future.stdout)
[08:26:20.742]         ...future.stdout <- NULL
[08:26:20.742]     }
[08:26:20.742]     ...future.result$conditions <- ...future.conditions
[08:26:20.742]     ...future.result$finished <- base::Sys.time()
[08:26:20.742]     ...future.result
[08:26:20.742] }
[08:26:20.746] assign_globals() ...
[08:26:20.746] List of 11
[08:26:20.746]  $ ...future.FUN            :function (x, ...)  
[08:26:20.746]  $ x_FUN                    :function (x, ...)  
[08:26:20.746]  $ times                    : int 5
[08:26:20.746]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:20.746]  $ stop_if_not              :function (...)  
[08:26:20.746]  $ dim                      : NULL
[08:26:20.746]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:20.746]  $ future.call.arguments    : list()
[08:26:20.746]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.746]  $ ...future.elements_ii    :List of 1
[08:26:20.746]   ..$ a: int [1:10] 1 2 3 4 5 6 7 8 9 10
[08:26:20.746]  $ ...future.seeds_ii       : NULL
[08:26:20.746]  $ ...future.globals.maxSize: NULL
[08:26:20.746]  - attr(*, "where")=List of 11
[08:26:20.746]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:20.746]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:20.746]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:20.746]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:20.746]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:20.746]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:20.746]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:20.746]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:20.746]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:20.746]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:20.746]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:20.746]  - attr(*, "resolved")= logi FALSE
[08:26:20.746]  - attr(*, "total_size")= num 24127
[08:26:20.746]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.746]  - attr(*, "already-done")= logi TRUE
[08:26:20.755] - copied ‘...future.FUN’ to environment
[08:26:20.755] - copied ‘x_FUN’ to environment
[08:26:20.755] - copied ‘times’ to environment
[08:26:20.755] - copied ‘stopf’ to environment
[08:26:20.755] - copied ‘stop_if_not’ to environment
[08:26:20.755] - copied ‘dim’ to environment
[08:26:20.756] - copied ‘valid_types’ to environment
[08:26:20.756] - copied ‘future.call.arguments’ to environment
[08:26:20.756] - copied ‘...future.elements_ii’ to environment
[08:26:20.756] - copied ‘...future.seeds_ii’ to environment
[08:26:20.756] - copied ‘...future.globals.maxSize’ to environment
[08:26:20.756] assign_globals() ... done
[08:26:20.756] requestCore(): workers = 2
[08:26:20.758] MulticoreFuture started
[08:26:20.759] - Launch lazy future ... done
[08:26:20.759] run() for ‘MulticoreFuture’ ... done
[08:26:20.759] Created future:
[08:26:20.760] plan(): Setting new future strategy stack:
[08:26:20.760] List of future strategies:
[08:26:20.760] 1. sequential:
[08:26:20.760]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:20.760]    - tweaked: FALSE
[08:26:20.760]    - call: NULL
[08:26:20.761] plan(): nbrOfWorkers() = 1
[08:26:20.764] plan(): Setting new future strategy stack:
[08:26:20.764] List of future strategies:
[08:26:20.764] 1. multicore:
[08:26:20.764]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:20.764]    - tweaked: FALSE
[08:26:20.764]    - call: plan(strategy)
[08:26:20.768] plan(): nbrOfWorkers() = 2
[08:26:20.760] MulticoreFuture:
[08:26:20.760] Label: ‘future_vapply-1’
[08:26:20.760] Expression:
[08:26:20.760] {
[08:26:20.760]     do.call(function(...) {
[08:26:20.760]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.760]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.760]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.760]             on.exit(options(oopts), add = TRUE)
[08:26:20.760]         }
[08:26:20.760]         {
[08:26:20.760]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.760]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.760]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.760]             })
[08:26:20.760]         }
[08:26:20.760]     }, args = future.call.arguments)
[08:26:20.760] }
[08:26:20.760] Lazy evaluation: FALSE
[08:26:20.760] Asynchronous evaluation: TRUE
[08:26:20.760] Local evaluation: TRUE
[08:26:20.760] Environment: R_GlobalEnv
[08:26:20.760] Capture standard output: TRUE
[08:26:20.760] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:20.760] Globals: 11 objects totaling 13.35 KiB (function ‘...future.FUN’ of 4.74 KiB, function ‘x_FUN’ of 311 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:20.760] Packages: 2 packages (‘stats’, ‘future.apply’)
[08:26:20.760] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:20.760] Resolved: TRUE
[08:26:20.760] Value: <not collected>
[08:26:20.760] Conditions captured: <none>
[08:26:20.760] Early signaling: FALSE
[08:26:20.760] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:20.760] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.769] Chunk #1 of 2 ... DONE
[08:26:20.769] Chunk #2 of 2 ...
[08:26:20.769]  - Finding globals in 'X' for chunk #2 ...
[08:26:20.770] getGlobalsAndPackages() ...
[08:26:20.770] Searching for globals...
[08:26:20.770] 
[08:26:20.770] Searching for globals ... DONE
[08:26:20.771] - globals: [0] <none>
[08:26:20.771] getGlobalsAndPackages() ... DONE
[08:26:20.771]    + additional globals found: [n=0] 
[08:26:20.771]    + additional namespaces needed: [n=0] 
[08:26:20.771]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:20.771]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:20.771]  - seeds: <none>
[08:26:20.771]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.772] getGlobalsAndPackages() ...
[08:26:20.772] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.772] Resolving globals: FALSE
[08:26:20.772] Tweak future expression to call with '...' arguments ...
[08:26:20.772] {
[08:26:20.772]     do.call(function(...) {
[08:26:20.772]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.772]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.772]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.772]             on.exit(options(oopts), add = TRUE)
[08:26:20.772]         }
[08:26:20.772]         {
[08:26:20.772]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.772]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.772]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.772]             })
[08:26:20.772]         }
[08:26:20.772]     }, args = future.call.arguments)
[08:26:20.772] }
[08:26:20.773] Tweak future expression to call with '...' arguments ... DONE
[08:26:20.774] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.774] - packages: [2] ‘stats’, ‘future.apply’
[08:26:20.774] getGlobalsAndPackages() ... DONE
[08:26:20.775] run() for ‘Future’ ...
[08:26:20.775] - state: ‘created’
[08:26:20.775] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:20.778] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.778] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:20.778]   - Field: ‘label’
[08:26:20.778]   - Field: ‘local’
[08:26:20.778]   - Field: ‘owner’
[08:26:20.779]   - Field: ‘envir’
[08:26:20.779]   - Field: ‘workers’
[08:26:20.779]   - Field: ‘packages’
[08:26:20.779]   - Field: ‘gc’
[08:26:20.779]   - Field: ‘job’
[08:26:20.779]   - Field: ‘conditions’
[08:26:20.779]   - Field: ‘expr’
[08:26:20.780]   - Field: ‘uuid’
[08:26:20.780]   - Field: ‘seed’
[08:26:20.780]   - Field: ‘version’
[08:26:20.780]   - Field: ‘result’
[08:26:20.780]   - Field: ‘asynchronous’
[08:26:20.780]   - Field: ‘calls’
[08:26:20.780]   - Field: ‘globals’
[08:26:20.780]   - Field: ‘stdout’
[08:26:20.781]   - Field: ‘earlySignal’
[08:26:20.781]   - Field: ‘lazy’
[08:26:20.781]   - Field: ‘state’
[08:26:20.781] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:20.781] - Launch lazy future ...
[08:26:20.782] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[08:26:20.782] Packages needed by future strategies (n = 0): <none>
[08:26:20.783] {
[08:26:20.783]     {
[08:26:20.783]         {
[08:26:20.783]             ...future.startTime <- base::Sys.time()
[08:26:20.783]             {
[08:26:20.783]                 {
[08:26:20.783]                   {
[08:26:20.783]                     {
[08:26:20.783]                       {
[08:26:20.783]                         base::local({
[08:26:20.783]                           has_future <- base::requireNamespace("future", 
[08:26:20.783]                             quietly = TRUE)
[08:26:20.783]                           if (has_future) {
[08:26:20.783]                             ns <- base::getNamespace("future")
[08:26:20.783]                             version <- ns[[".package"]][["version"]]
[08:26:20.783]                             if (is.null(version)) 
[08:26:20.783]                               version <- utils::packageVersion("future")
[08:26:20.783]                           }
[08:26:20.783]                           else {
[08:26:20.783]                             version <- NULL
[08:26:20.783]                           }
[08:26:20.783]                           if (!has_future || version < "1.8.0") {
[08:26:20.783]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:20.783]                               "", base::R.version$version.string), 
[08:26:20.783]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:20.783]                                 base::R.version$platform, 8 * 
[08:26:20.783]                                   base::.Machine$sizeof.pointer), 
[08:26:20.783]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:20.783]                                 "release", "version")], collapse = " "), 
[08:26:20.783]                               hostname = base::Sys.info()[["nodename"]])
[08:26:20.783]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:20.783]                               info)
[08:26:20.783]                             info <- base::paste(info, collapse = "; ")
[08:26:20.783]                             if (!has_future) {
[08:26:20.783]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:20.783]                                 info)
[08:26:20.783]                             }
[08:26:20.783]                             else {
[08:26:20.783]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:20.783]                                 info, version)
[08:26:20.783]                             }
[08:26:20.783]                             base::stop(msg)
[08:26:20.783]                           }
[08:26:20.783]                         })
[08:26:20.783]                       }
[08:26:20.783]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:20.783]                       base::options(mc.cores = 1L)
[08:26:20.783]                     }
[08:26:20.783]                     base::local({
[08:26:20.783]                       for (pkg in c("stats", "future.apply")) {
[08:26:20.783]                         base::loadNamespace(pkg)
[08:26:20.783]                         base::library(pkg, character.only = TRUE)
[08:26:20.783]                       }
[08:26:20.783]                     })
[08:26:20.783]                   }
[08:26:20.783]                   ...future.strategy.old <- future::plan("list")
[08:26:20.783]                   options(future.plan = NULL)
[08:26:20.783]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.783]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:20.783]                 }
[08:26:20.783]                 ...future.workdir <- getwd()
[08:26:20.783]             }
[08:26:20.783]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:20.783]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:20.783]         }
[08:26:20.783]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:20.783]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:20.783]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:20.783]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:20.783]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:20.783]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:20.783]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:20.783]             base::names(...future.oldOptions))
[08:26:20.783]     }
[08:26:20.783]     if (FALSE) {
[08:26:20.783]     }
[08:26:20.783]     else {
[08:26:20.783]         if (TRUE) {
[08:26:20.783]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:20.783]                 open = "w")
[08:26:20.783]         }
[08:26:20.783]         else {
[08:26:20.783]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:20.783]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:20.783]         }
[08:26:20.783]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:20.783]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:20.783]             base::sink(type = "output", split = FALSE)
[08:26:20.783]             base::close(...future.stdout)
[08:26:20.783]         }, add = TRUE)
[08:26:20.783]     }
[08:26:20.783]     ...future.frame <- base::sys.nframe()
[08:26:20.783]     ...future.conditions <- base::list()
[08:26:20.783]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:20.783]     if (FALSE) {
[08:26:20.783]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:20.783]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:20.783]     }
[08:26:20.783]     ...future.result <- base::tryCatch({
[08:26:20.783]         base::withCallingHandlers({
[08:26:20.783]             ...future.value <- base::withVisible(base::local({
[08:26:20.783]                 withCallingHandlers({
[08:26:20.783]                   {
[08:26:20.783]                     do.call(function(...) {
[08:26:20.783]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.783]                       if (!identical(...future.globals.maxSize.org, 
[08:26:20.783]                         ...future.globals.maxSize)) {
[08:26:20.783]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.783]                         on.exit(options(oopts), add = TRUE)
[08:26:20.783]                       }
[08:26:20.783]                       {
[08:26:20.783]                         lapply(seq_along(...future.elements_ii), 
[08:26:20.783]                           FUN = function(jj) {
[08:26:20.783]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.783]                             ...future.FUN(...future.X_jj, ...)
[08:26:20.783]                           })
[08:26:20.783]                       }
[08:26:20.783]                     }, args = future.call.arguments)
[08:26:20.783]                   }
[08:26:20.783]                 }, immediateCondition = function(cond) {
[08:26:20.783]                   save_rds <- function (object, pathname, ...) 
[08:26:20.783]                   {
[08:26:20.783]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:20.783]                     if (file_test("-f", pathname_tmp)) {
[08:26:20.783]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.783]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:20.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.783]                         fi_tmp[["mtime"]])
[08:26:20.783]                     }
[08:26:20.783]                     tryCatch({
[08:26:20.783]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:20.783]                     }, error = function(ex) {
[08:26:20.783]                       msg <- conditionMessage(ex)
[08:26:20.783]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.783]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:20.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.783]                         fi_tmp[["mtime"]], msg)
[08:26:20.783]                       ex$message <- msg
[08:26:20.783]                       stop(ex)
[08:26:20.783]                     })
[08:26:20.783]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:20.783]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:20.783]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:20.783]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.783]                       fi <- file.info(pathname)
[08:26:20.783]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:20.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.783]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:20.783]                         fi[["size"]], fi[["mtime"]])
[08:26:20.783]                       stop(msg)
[08:26:20.783]                     }
[08:26:20.783]                     invisible(pathname)
[08:26:20.783]                   }
[08:26:20.783]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:20.783]                     rootPath = tempdir()) 
[08:26:20.783]                   {
[08:26:20.783]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:20.783]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:20.783]                       tmpdir = path, fileext = ".rds")
[08:26:20.783]                     save_rds(obj, file)
[08:26:20.783]                   }
[08:26:20.783]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:20.783]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.783]                   {
[08:26:20.783]                     inherits <- base::inherits
[08:26:20.783]                     invokeRestart <- base::invokeRestart
[08:26:20.783]                     is.null <- base::is.null
[08:26:20.783]                     muffled <- FALSE
[08:26:20.783]                     if (inherits(cond, "message")) {
[08:26:20.783]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:20.783]                       if (muffled) 
[08:26:20.783]                         invokeRestart("muffleMessage")
[08:26:20.783]                     }
[08:26:20.783]                     else if (inherits(cond, "warning")) {
[08:26:20.783]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:20.783]                       if (muffled) 
[08:26:20.783]                         invokeRestart("muffleWarning")
[08:26:20.783]                     }
[08:26:20.783]                     else if (inherits(cond, "condition")) {
[08:26:20.783]                       if (!is.null(pattern)) {
[08:26:20.783]                         computeRestarts <- base::computeRestarts
[08:26:20.783]                         grepl <- base::grepl
[08:26:20.783]                         restarts <- computeRestarts(cond)
[08:26:20.783]                         for (restart in restarts) {
[08:26:20.783]                           name <- restart$name
[08:26:20.783]                           if (is.null(name)) 
[08:26:20.783]                             next
[08:26:20.783]                           if (!grepl(pattern, name)) 
[08:26:20.783]                             next
[08:26:20.783]                           invokeRestart(restart)
[08:26:20.783]                           muffled <- TRUE
[08:26:20.783]                           break
[08:26:20.783]                         }
[08:26:20.783]                       }
[08:26:20.783]                     }
[08:26:20.783]                     invisible(muffled)
[08:26:20.783]                   }
[08:26:20.783]                   muffleCondition(cond)
[08:26:20.783]                 })
[08:26:20.783]             }))
[08:26:20.783]             future::FutureResult(value = ...future.value$value, 
[08:26:20.783]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.783]                   ...future.rng), globalenv = if (FALSE) 
[08:26:20.783]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:20.783]                     ...future.globalenv.names))
[08:26:20.783]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:20.783]         }, condition = base::local({
[08:26:20.783]             c <- base::c
[08:26:20.783]             inherits <- base::inherits
[08:26:20.783]             invokeRestart <- base::invokeRestart
[08:26:20.783]             length <- base::length
[08:26:20.783]             list <- base::list
[08:26:20.783]             seq.int <- base::seq.int
[08:26:20.783]             signalCondition <- base::signalCondition
[08:26:20.783]             sys.calls <- base::sys.calls
[08:26:20.783]             `[[` <- base::`[[`
[08:26:20.783]             `+` <- base::`+`
[08:26:20.783]             `<<-` <- base::`<<-`
[08:26:20.783]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:20.783]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:20.783]                   3L)]
[08:26:20.783]             }
[08:26:20.783]             function(cond) {
[08:26:20.783]                 is_error <- inherits(cond, "error")
[08:26:20.783]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:20.783]                   NULL)
[08:26:20.783]                 if (is_error) {
[08:26:20.783]                   sessionInformation <- function() {
[08:26:20.783]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:20.783]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:20.783]                       search = base::search(), system = base::Sys.info())
[08:26:20.783]                   }
[08:26:20.783]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.783]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:20.783]                     cond$call), session = sessionInformation(), 
[08:26:20.783]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:20.783]                   signalCondition(cond)
[08:26:20.783]                 }
[08:26:20.783]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:20.783]                 "immediateCondition"))) {
[08:26:20.783]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:20.783]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.783]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:20.783]                   if (TRUE && !signal) {
[08:26:20.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.783]                     {
[08:26:20.783]                       inherits <- base::inherits
[08:26:20.783]                       invokeRestart <- base::invokeRestart
[08:26:20.783]                       is.null <- base::is.null
[08:26:20.783]                       muffled <- FALSE
[08:26:20.783]                       if (inherits(cond, "message")) {
[08:26:20.783]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.783]                         if (muffled) 
[08:26:20.783]                           invokeRestart("muffleMessage")
[08:26:20.783]                       }
[08:26:20.783]                       else if (inherits(cond, "warning")) {
[08:26:20.783]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.783]                         if (muffled) 
[08:26:20.783]                           invokeRestart("muffleWarning")
[08:26:20.783]                       }
[08:26:20.783]                       else if (inherits(cond, "condition")) {
[08:26:20.783]                         if (!is.null(pattern)) {
[08:26:20.783]                           computeRestarts <- base::computeRestarts
[08:26:20.783]                           grepl <- base::grepl
[08:26:20.783]                           restarts <- computeRestarts(cond)
[08:26:20.783]                           for (restart in restarts) {
[08:26:20.783]                             name <- restart$name
[08:26:20.783]                             if (is.null(name)) 
[08:26:20.783]                               next
[08:26:20.783]                             if (!grepl(pattern, name)) 
[08:26:20.783]                               next
[08:26:20.783]                             invokeRestart(restart)
[08:26:20.783]                             muffled <- TRUE
[08:26:20.783]                             break
[08:26:20.783]                           }
[08:26:20.783]                         }
[08:26:20.783]                       }
[08:26:20.783]                       invisible(muffled)
[08:26:20.783]                     }
[08:26:20.783]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.783]                   }
[08:26:20.783]                 }
[08:26:20.783]                 else {
[08:26:20.783]                   if (TRUE) {
[08:26:20.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.783]                     {
[08:26:20.783]                       inherits <- base::inherits
[08:26:20.783]                       invokeRestart <- base::invokeRestart
[08:26:20.783]                       is.null <- base::is.null
[08:26:20.783]                       muffled <- FALSE
[08:26:20.783]                       if (inherits(cond, "message")) {
[08:26:20.783]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.783]                         if (muffled) 
[08:26:20.783]                           invokeRestart("muffleMessage")
[08:26:20.783]                       }
[08:26:20.783]                       else if (inherits(cond, "warning")) {
[08:26:20.783]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.783]                         if (muffled) 
[08:26:20.783]                           invokeRestart("muffleWarning")
[08:26:20.783]                       }
[08:26:20.783]                       else if (inherits(cond, "condition")) {
[08:26:20.783]                         if (!is.null(pattern)) {
[08:26:20.783]                           computeRestarts <- base::computeRestarts
[08:26:20.783]                           grepl <- base::grepl
[08:26:20.783]                           restarts <- computeRestarts(cond)
[08:26:20.783]                           for (restart in restarts) {
[08:26:20.783]                             name <- restart$name
[08:26:20.783]                             if (is.null(name)) 
[08:26:20.783]                               next
[08:26:20.783]                             if (!grepl(pattern, name)) 
[08:26:20.783]                               next
[08:26:20.783]                             invokeRestart(restart)
[08:26:20.783]                             muffled <- TRUE
[08:26:20.783]                             break
[08:26:20.783]                           }
[08:26:20.783]                         }
[08:26:20.783]                       }
[08:26:20.783]                       invisible(muffled)
[08:26:20.783]                     }
[08:26:20.783]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.783]                   }
[08:26:20.783]                 }
[08:26:20.783]             }
[08:26:20.783]         }))
[08:26:20.783]     }, error = function(ex) {
[08:26:20.783]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:20.783]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.783]                 ...future.rng), started = ...future.startTime, 
[08:26:20.783]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:20.783]             version = "1.8"), class = "FutureResult")
[08:26:20.783]     }, finally = {
[08:26:20.783]         if (!identical(...future.workdir, getwd())) 
[08:26:20.783]             setwd(...future.workdir)
[08:26:20.783]         {
[08:26:20.783]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:20.783]                 ...future.oldOptions$nwarnings <- NULL
[08:26:20.783]             }
[08:26:20.783]             base::options(...future.oldOptions)
[08:26:20.783]             if (.Platform$OS.type == "windows") {
[08:26:20.783]                 old_names <- names(...future.oldEnvVars)
[08:26:20.783]                 envs <- base::Sys.getenv()
[08:26:20.783]                 names <- names(envs)
[08:26:20.783]                 common <- intersect(names, old_names)
[08:26:20.783]                 added <- setdiff(names, old_names)
[08:26:20.783]                 removed <- setdiff(old_names, names)
[08:26:20.783]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:20.783]                   envs[common]]
[08:26:20.783]                 NAMES <- toupper(changed)
[08:26:20.783]                 args <- list()
[08:26:20.783]                 for (kk in seq_along(NAMES)) {
[08:26:20.783]                   name <- changed[[kk]]
[08:26:20.783]                   NAME <- NAMES[[kk]]
[08:26:20.783]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.783]                     next
[08:26:20.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.783]                 }
[08:26:20.783]                 NAMES <- toupper(added)
[08:26:20.783]                 for (kk in seq_along(NAMES)) {
[08:26:20.783]                   name <- added[[kk]]
[08:26:20.783]                   NAME <- NAMES[[kk]]
[08:26:20.783]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.783]                     next
[08:26:20.783]                   args[[name]] <- ""
[08:26:20.783]                 }
[08:26:20.783]                 NAMES <- toupper(removed)
[08:26:20.783]                 for (kk in seq_along(NAMES)) {
[08:26:20.783]                   name <- removed[[kk]]
[08:26:20.783]                   NAME <- NAMES[[kk]]
[08:26:20.783]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.783]                     next
[08:26:20.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.783]                 }
[08:26:20.783]                 if (length(args) > 0) 
[08:26:20.783]                   base::do.call(base::Sys.setenv, args = args)
[08:26:20.783]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:20.783]             }
[08:26:20.783]             else {
[08:26:20.783]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:20.783]             }
[08:26:20.783]             {
[08:26:20.783]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:20.783]                   0L) {
[08:26:20.783]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:20.783]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:20.783]                   base::options(opts)
[08:26:20.783]                 }
[08:26:20.783]                 {
[08:26:20.783]                   {
[08:26:20.783]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:20.783]                     NULL
[08:26:20.783]                   }
[08:26:20.783]                   options(future.plan = NULL)
[08:26:20.783]                   if (is.na(NA_character_)) 
[08:26:20.783]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.783]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:20.783]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:20.783]                     .init = FALSE)
[08:26:20.783]                 }
[08:26:20.783]             }
[08:26:20.783]         }
[08:26:20.783]     })
[08:26:20.783]     if (TRUE) {
[08:26:20.783]         base::sink(type = "output", split = FALSE)
[08:26:20.783]         if (TRUE) {
[08:26:20.783]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:20.783]         }
[08:26:20.783]         else {
[08:26:20.783]             ...future.result["stdout"] <- base::list(NULL)
[08:26:20.783]         }
[08:26:20.783]         base::close(...future.stdout)
[08:26:20.783]         ...future.stdout <- NULL
[08:26:20.783]     }
[08:26:20.783]     ...future.result$conditions <- ...future.conditions
[08:26:20.783]     ...future.result$finished <- base::Sys.time()
[08:26:20.783]     ...future.result
[08:26:20.783] }
[08:26:20.789] assign_globals() ...
[08:26:20.789] List of 11
[08:26:20.789]  $ ...future.FUN            :function (x, ...)  
[08:26:20.789]  $ x_FUN                    :function (x, ...)  
[08:26:20.789]  $ times                    : int 5
[08:26:20.789]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:20.789]  $ stop_if_not              :function (...)  
[08:26:20.789]  $ dim                      : NULL
[08:26:20.789]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:20.789]  $ future.call.arguments    : list()
[08:26:20.789]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.789]  $ ...future.elements_ii    :List of 2
[08:26:20.789]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[08:26:20.789]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[08:26:20.789]  $ ...future.seeds_ii       : NULL
[08:26:20.789]  $ ...future.globals.maxSize: NULL
[08:26:20.789]  - attr(*, "where")=List of 11
[08:26:20.789]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:20.789]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:20.789]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:20.789]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:20.789]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:20.789]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:20.789]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:20.789]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:20.789]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:20.789]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:20.789]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:20.789]  - attr(*, "resolved")= logi FALSE
[08:26:20.789]  - attr(*, "total_size")= num 24127
[08:26:20.789]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.789]  - attr(*, "already-done")= logi TRUE
[08:26:20.805] - copied ‘...future.FUN’ to environment
[08:26:20.805] - copied ‘x_FUN’ to environment
[08:26:20.805] - copied ‘times’ to environment
[08:26:20.805] - copied ‘stopf’ to environment
[08:26:20.805] - copied ‘stop_if_not’ to environment
[08:26:20.805] - copied ‘dim’ to environment
[08:26:20.805] - copied ‘valid_types’ to environment
[08:26:20.806] - copied ‘future.call.arguments’ to environment
[08:26:20.806] - copied ‘...future.elements_ii’ to environment
[08:26:20.806] - copied ‘...future.seeds_ii’ to environment
[08:26:20.806] - copied ‘...future.globals.maxSize’ to environment
[08:26:20.806] assign_globals() ... done
[08:26:20.806] requestCore(): workers = 2
[08:26:20.809] MulticoreFuture started
[08:26:20.809] - Launch lazy future ... done
[08:26:20.809] run() for ‘MulticoreFuture’ ... done
[08:26:20.810] Created future:
[08:26:20.810] plan(): Setting new future strategy stack:
[08:26:20.811] List of future strategies:
[08:26:20.811] 1. sequential:
[08:26:20.811]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:20.811]    - tweaked: FALSE
[08:26:20.811]    - call: NULL
[08:26:20.812] plan(): nbrOfWorkers() = 1
[08:26:20.815] plan(): Setting new future strategy stack:
[08:26:20.815] List of future strategies:
[08:26:20.815] 1. multicore:
[08:26:20.815]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:20.815]    - tweaked: FALSE
[08:26:20.815]    - call: plan(strategy)
[08:26:20.819] plan(): nbrOfWorkers() = 2
[08:26:20.810] MulticoreFuture:
[08:26:20.810] Label: ‘future_vapply-2’
[08:26:20.810] Expression:
[08:26:20.810] {
[08:26:20.810]     do.call(function(...) {
[08:26:20.810]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.810]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.810]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.810]             on.exit(options(oopts), add = TRUE)
[08:26:20.810]         }
[08:26:20.810]         {
[08:26:20.810]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.810]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.810]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.810]             })
[08:26:20.810]         }
[08:26:20.810]     }, args = future.call.arguments)
[08:26:20.810] }
[08:26:20.810] Lazy evaluation: FALSE
[08:26:20.810] Asynchronous evaluation: TRUE
[08:26:20.810] Local evaluation: TRUE
[08:26:20.810] Environment: R_GlobalEnv
[08:26:20.810] Capture standard output: TRUE
[08:26:20.810] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:20.810] Globals: 11 objects totaling 13.34 KiB (function ‘...future.FUN’ of 4.74 KiB, function ‘x_FUN’ of 311 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:20.810] Packages: 2 packages (‘stats’, ‘future.apply’)
[08:26:20.810] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:20.810] Resolved: TRUE
[08:26:20.810] Value: <not collected>
[08:26:20.810] Conditions captured: <none>
[08:26:20.810] Early signaling: FALSE
[08:26:20.810] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:20.810] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.820] Chunk #2 of 2 ... DONE
[08:26:20.820] Launching 2 futures (chunks) ... DONE
[08:26:20.820] Resolving 2 futures (chunks) ...
[08:26:20.820] resolve() on list ...
[08:26:20.820]  recursive: 0
[08:26:20.820]  length: 2
[08:26:20.820] 
[08:26:20.821] Future #1
[08:26:20.821] result() for MulticoreFuture ...
[08:26:20.822] result() for MulticoreFuture ...
[08:26:20.822] result() for MulticoreFuture ... done
[08:26:20.822] result() for MulticoreFuture ... done
[08:26:20.822] result() for MulticoreFuture ...
[08:26:20.822] result() for MulticoreFuture ... done
[08:26:20.823] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:26:20.823] - nx: 2
[08:26:20.823] - relay: TRUE
[08:26:20.823] - stdout: TRUE
[08:26:20.823] - signal: TRUE
[08:26:20.823] - resignal: FALSE
[08:26:20.823] - force: TRUE
[08:26:20.823] - relayed: [n=2] FALSE, FALSE
[08:26:20.824] - queued futures: [n=2] FALSE, FALSE
[08:26:20.824]  - until=1
[08:26:20.824]  - relaying element #1
[08:26:20.824] result() for MulticoreFuture ...
[08:26:20.824] result() for MulticoreFuture ... done
[08:26:20.824] result() for MulticoreFuture ...
[08:26:20.824] result() for MulticoreFuture ... done
[08:26:20.825] result() for MulticoreFuture ...
[08:26:20.825] result() for MulticoreFuture ... done
[08:26:20.825] result() for MulticoreFuture ...
[08:26:20.825] result() for MulticoreFuture ... done
[08:26:20.825] - relayed: [n=2] TRUE, FALSE
[08:26:20.825] - queued futures: [n=2] TRUE, FALSE
[08:26:20.826] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:26:20.826]  length: 1 (resolved future 1)
[08:26:20.826] Future #2
[08:26:20.826] result() for MulticoreFuture ...
[08:26:20.827] result() for MulticoreFuture ...
[08:26:20.827] result() for MulticoreFuture ... done
[08:26:20.827] result() for MulticoreFuture ... done
[08:26:20.827] result() for MulticoreFuture ...
[08:26:20.828] result() for MulticoreFuture ... done
[08:26:20.828] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:26:20.828] - nx: 2
[08:26:20.828] - relay: TRUE
[08:26:20.828] - stdout: TRUE
[08:26:20.828] - signal: TRUE
[08:26:20.828] - resignal: FALSE
[08:26:20.828] - force: TRUE
[08:26:20.829] - relayed: [n=2] TRUE, FALSE
[08:26:20.829] - queued futures: [n=2] TRUE, FALSE
[08:26:20.829]  - until=2
[08:26:20.829]  - relaying element #2
[08:26:20.829] result() for MulticoreFuture ...
[08:26:20.829] result() for MulticoreFuture ... done
[08:26:20.829] result() for MulticoreFuture ...
[08:26:20.829] result() for MulticoreFuture ... done
[08:26:20.830] result() for MulticoreFuture ...
[08:26:20.830] result() for MulticoreFuture ... done
[08:26:20.830] result() for MulticoreFuture ...
[08:26:20.830] result() for MulticoreFuture ... done
[08:26:20.830] - relayed: [n=2] TRUE, TRUE
[08:26:20.830] - queued futures: [n=2] TRUE, TRUE
[08:26:20.830] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:26:20.831]  length: 0 (resolved future 2)
[08:26:20.831] Relaying remaining futures
[08:26:20.831] signalConditionsASAP(NULL, pos=0) ...
[08:26:20.831] - nx: 2
[08:26:20.831] - relay: TRUE
[08:26:20.831] - stdout: TRUE
[08:26:20.833] - signal: TRUE
[08:26:20.834] - resignal: FALSE
[08:26:20.834] - force: TRUE
[08:26:20.834] - relayed: [n=2] TRUE, TRUE
[08:26:20.834] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:20.834] - relayed: [n=2] TRUE, TRUE
[08:26:20.835] - queued futures: [n=2] TRUE, TRUE
[08:26:20.835] signalConditionsASAP(NULL, pos=0) ... done
[08:26:20.835] resolve() on list ... DONE
[08:26:20.835] result() for MulticoreFuture ...
[08:26:20.835] result() for MulticoreFuture ... done
[08:26:20.835] result() for MulticoreFuture ...
[08:26:20.836] result() for MulticoreFuture ... done
[08:26:20.836] result() for MulticoreFuture ...
[08:26:20.836] result() for MulticoreFuture ... done
[08:26:20.836] result() for MulticoreFuture ...
[08:26:20.836] result() for MulticoreFuture ... done
[08:26:20.836]  - Number of value chunks collected: 2
[08:26:20.837] Resolving 2 futures (chunks) ... DONE
[08:26:20.837] Reducing values from 2 chunks ...
[08:26:20.837]  - Number of values collected after concatenation: 3
[08:26:20.837]  - Number of values expected: 3
[08:26:20.837] Reducing values from 2 chunks ... DONE
[08:26:20.837] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[08:26:20.840] future_lapply() ...
[08:26:20.847] Number of chunks: 2
[08:26:20.847] getGlobalsAndPackagesXApply() ...
[08:26:20.847]  - future.globals: TRUE
[08:26:20.848] getGlobalsAndPackages() ...
[08:26:20.848] Searching for globals...
[08:26:20.853] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[08:26:20.853] Searching for globals ... DONE
[08:26:20.853] Resolving globals: FALSE
[08:26:20.854] The total size of the 1 globals is 4.67 KiB (4777 bytes)
[08:26:20.854] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.67 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.67 KiB of class ‘function’)
[08:26:20.854] - globals: [1] ‘FUN’
[08:26:20.854] - packages: [1] ‘stats’
[08:26:20.854] getGlobalsAndPackages() ... DONE
[08:26:20.855]  - globals found/used: [n=1] ‘FUN’
[08:26:20.855]  - needed namespaces: [n=1] ‘stats’
[08:26:20.855] Finding globals ... DONE
[08:26:20.855]  - use_args: TRUE
[08:26:20.855]  - Getting '...' globals ...
[08:26:20.855] resolve() on list ...
[08:26:20.855]  recursive: 0
[08:26:20.856]  length: 1
[08:26:20.856]  elements: ‘...’
[08:26:20.856]  length: 0 (resolved future 1)
[08:26:20.858] resolve() on list ... DONE
[08:26:20.858]    - '...' content: [n=0] 
[08:26:20.858] List of 1
[08:26:20.858]  $ ...: list()
[08:26:20.858]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.858]  - attr(*, "where")=List of 1
[08:26:20.858]   ..$ ...:<environment: 0x562ca7ed6b80> 
[08:26:20.858]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.858]  - attr(*, "resolved")= logi TRUE
[08:26:20.858]  - attr(*, "total_size")= num NA
[08:26:20.861]  - Getting '...' globals ... DONE
[08:26:20.862] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:26:20.862] List of 2
[08:26:20.862]  $ ...future.FUN:function (x, na.rm = TRUE)  
[08:26:20.862]  $ ...          : list()
[08:26:20.862]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.862]  - attr(*, "where")=List of 2
[08:26:20.862]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:20.862]   ..$ ...          :<environment: 0x562ca7ed6b80> 
[08:26:20.862]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.862]  - attr(*, "resolved")= logi FALSE
[08:26:20.862]  - attr(*, "total_size")= num 18895
[08:26:20.865] Packages to be attached in all futures: [n=1] ‘stats’
[08:26:20.865] getGlobalsAndPackagesXApply() ... DONE
[08:26:20.865] Number of futures (= number of chunks): 2
[08:26:20.866] Launching 2 futures (chunks) ...
[08:26:20.866] Chunk #1 of 2 ...
[08:26:20.866]  - Finding globals in 'X' for chunk #1 ...
[08:26:20.866] getGlobalsAndPackages() ...
[08:26:20.866] Searching for globals...
[08:26:20.866] 
[08:26:20.866] Searching for globals ... DONE
[08:26:20.866] - globals: [0] <none>
[08:26:20.867] getGlobalsAndPackages() ... DONE
[08:26:20.867]    + additional globals found: [n=0] 
[08:26:20.867]    + additional namespaces needed: [n=0] 
[08:26:20.867]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:20.867]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:20.867]  - seeds: <none>
[08:26:20.867]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.867] getGlobalsAndPackages() ...
[08:26:20.867] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.867] Resolving globals: FALSE
[08:26:20.868] Tweak future expression to call with '...' arguments ...
[08:26:20.868] {
[08:26:20.868]     do.call(function(...) {
[08:26:20.868]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.868]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.868]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.868]             on.exit(options(oopts), add = TRUE)
[08:26:20.868]         }
[08:26:20.868]         {
[08:26:20.868]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.868]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.868]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.868]             })
[08:26:20.868]         }
[08:26:20.868]     }, args = future.call.arguments)
[08:26:20.868] }
[08:26:20.868] Tweak future expression to call with '...' arguments ... DONE
[08:26:20.868] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.868] - packages: [1] ‘stats’
[08:26:20.869] getGlobalsAndPackages() ... DONE
[08:26:20.869] run() for ‘Future’ ...
[08:26:20.869] - state: ‘created’
[08:26:20.869] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:20.871] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.871] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:20.871]   - Field: ‘label’
[08:26:20.871]   - Field: ‘local’
[08:26:20.871]   - Field: ‘owner’
[08:26:20.872]   - Field: ‘envir’
[08:26:20.872]   - Field: ‘workers’
[08:26:20.872]   - Field: ‘packages’
[08:26:20.872]   - Field: ‘gc’
[08:26:20.872]   - Field: ‘job’
[08:26:20.872]   - Field: ‘conditions’
[08:26:20.872]   - Field: ‘expr’
[08:26:20.872]   - Field: ‘uuid’
[08:26:20.872]   - Field: ‘seed’
[08:26:20.872]   - Field: ‘version’
[08:26:20.872]   - Field: ‘result’
[08:26:20.873]   - Field: ‘asynchronous’
[08:26:20.873]   - Field: ‘calls’
[08:26:20.873]   - Field: ‘globals’
[08:26:20.873]   - Field: ‘stdout’
[08:26:20.873]   - Field: ‘earlySignal’
[08:26:20.873]   - Field: ‘lazy’
[08:26:20.873]   - Field: ‘state’
[08:26:20.873] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:20.873] - Launch lazy future ...
[08:26:20.874] Packages needed by the future expression (n = 1): ‘stats’
[08:26:20.874] Packages needed by future strategies (n = 0): <none>
[08:26:20.874] {
[08:26:20.874]     {
[08:26:20.874]         {
[08:26:20.874]             ...future.startTime <- base::Sys.time()
[08:26:20.874]             {
[08:26:20.874]                 {
[08:26:20.874]                   {
[08:26:20.874]                     {
[08:26:20.874]                       {
[08:26:20.874]                         base::local({
[08:26:20.874]                           has_future <- base::requireNamespace("future", 
[08:26:20.874]                             quietly = TRUE)
[08:26:20.874]                           if (has_future) {
[08:26:20.874]                             ns <- base::getNamespace("future")
[08:26:20.874]                             version <- ns[[".package"]][["version"]]
[08:26:20.874]                             if (is.null(version)) 
[08:26:20.874]                               version <- utils::packageVersion("future")
[08:26:20.874]                           }
[08:26:20.874]                           else {
[08:26:20.874]                             version <- NULL
[08:26:20.874]                           }
[08:26:20.874]                           if (!has_future || version < "1.8.0") {
[08:26:20.874]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:20.874]                               "", base::R.version$version.string), 
[08:26:20.874]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:20.874]                                 base::R.version$platform, 8 * 
[08:26:20.874]                                   base::.Machine$sizeof.pointer), 
[08:26:20.874]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:20.874]                                 "release", "version")], collapse = " "), 
[08:26:20.874]                               hostname = base::Sys.info()[["nodename"]])
[08:26:20.874]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:20.874]                               info)
[08:26:20.874]                             info <- base::paste(info, collapse = "; ")
[08:26:20.874]                             if (!has_future) {
[08:26:20.874]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:20.874]                                 info)
[08:26:20.874]                             }
[08:26:20.874]                             else {
[08:26:20.874]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:20.874]                                 info, version)
[08:26:20.874]                             }
[08:26:20.874]                             base::stop(msg)
[08:26:20.874]                           }
[08:26:20.874]                         })
[08:26:20.874]                       }
[08:26:20.874]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:20.874]                       base::options(mc.cores = 1L)
[08:26:20.874]                     }
[08:26:20.874]                     base::local({
[08:26:20.874]                       for (pkg in "stats") {
[08:26:20.874]                         base::loadNamespace(pkg)
[08:26:20.874]                         base::library(pkg, character.only = TRUE)
[08:26:20.874]                       }
[08:26:20.874]                     })
[08:26:20.874]                   }
[08:26:20.874]                   ...future.strategy.old <- future::plan("list")
[08:26:20.874]                   options(future.plan = NULL)
[08:26:20.874]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.874]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:20.874]                 }
[08:26:20.874]                 ...future.workdir <- getwd()
[08:26:20.874]             }
[08:26:20.874]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:20.874]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:20.874]         }
[08:26:20.874]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:20.874]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:20.874]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:20.874]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:20.874]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:20.874]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:20.874]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:20.874]             base::names(...future.oldOptions))
[08:26:20.874]     }
[08:26:20.874]     if (FALSE) {
[08:26:20.874]     }
[08:26:20.874]     else {
[08:26:20.874]         if (TRUE) {
[08:26:20.874]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:20.874]                 open = "w")
[08:26:20.874]         }
[08:26:20.874]         else {
[08:26:20.874]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:20.874]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:20.874]         }
[08:26:20.874]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:20.874]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:20.874]             base::sink(type = "output", split = FALSE)
[08:26:20.874]             base::close(...future.stdout)
[08:26:20.874]         }, add = TRUE)
[08:26:20.874]     }
[08:26:20.874]     ...future.frame <- base::sys.nframe()
[08:26:20.874]     ...future.conditions <- base::list()
[08:26:20.874]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:20.874]     if (FALSE) {
[08:26:20.874]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:20.874]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:20.874]     }
[08:26:20.874]     ...future.result <- base::tryCatch({
[08:26:20.874]         base::withCallingHandlers({
[08:26:20.874]             ...future.value <- base::withVisible(base::local({
[08:26:20.874]                 withCallingHandlers({
[08:26:20.874]                   {
[08:26:20.874]                     do.call(function(...) {
[08:26:20.874]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.874]                       if (!identical(...future.globals.maxSize.org, 
[08:26:20.874]                         ...future.globals.maxSize)) {
[08:26:20.874]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.874]                         on.exit(options(oopts), add = TRUE)
[08:26:20.874]                       }
[08:26:20.874]                       {
[08:26:20.874]                         lapply(seq_along(...future.elements_ii), 
[08:26:20.874]                           FUN = function(jj) {
[08:26:20.874]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.874]                             ...future.FUN(...future.X_jj, ...)
[08:26:20.874]                           })
[08:26:20.874]                       }
[08:26:20.874]                     }, args = future.call.arguments)
[08:26:20.874]                   }
[08:26:20.874]                 }, immediateCondition = function(cond) {
[08:26:20.874]                   save_rds <- function (object, pathname, ...) 
[08:26:20.874]                   {
[08:26:20.874]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:20.874]                     if (file_test("-f", pathname_tmp)) {
[08:26:20.874]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.874]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:20.874]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.874]                         fi_tmp[["mtime"]])
[08:26:20.874]                     }
[08:26:20.874]                     tryCatch({
[08:26:20.874]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:20.874]                     }, error = function(ex) {
[08:26:20.874]                       msg <- conditionMessage(ex)
[08:26:20.874]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.874]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:20.874]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.874]                         fi_tmp[["mtime"]], msg)
[08:26:20.874]                       ex$message <- msg
[08:26:20.874]                       stop(ex)
[08:26:20.874]                     })
[08:26:20.874]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:20.874]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:20.874]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:20.874]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.874]                       fi <- file.info(pathname)
[08:26:20.874]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:20.874]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.874]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:20.874]                         fi[["size"]], fi[["mtime"]])
[08:26:20.874]                       stop(msg)
[08:26:20.874]                     }
[08:26:20.874]                     invisible(pathname)
[08:26:20.874]                   }
[08:26:20.874]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:20.874]                     rootPath = tempdir()) 
[08:26:20.874]                   {
[08:26:20.874]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:20.874]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:20.874]                       tmpdir = path, fileext = ".rds")
[08:26:20.874]                     save_rds(obj, file)
[08:26:20.874]                   }
[08:26:20.874]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:20.874]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.874]                   {
[08:26:20.874]                     inherits <- base::inherits
[08:26:20.874]                     invokeRestart <- base::invokeRestart
[08:26:20.874]                     is.null <- base::is.null
[08:26:20.874]                     muffled <- FALSE
[08:26:20.874]                     if (inherits(cond, "message")) {
[08:26:20.874]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:20.874]                       if (muffled) 
[08:26:20.874]                         invokeRestart("muffleMessage")
[08:26:20.874]                     }
[08:26:20.874]                     else if (inherits(cond, "warning")) {
[08:26:20.874]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:20.874]                       if (muffled) 
[08:26:20.874]                         invokeRestart("muffleWarning")
[08:26:20.874]                     }
[08:26:20.874]                     else if (inherits(cond, "condition")) {
[08:26:20.874]                       if (!is.null(pattern)) {
[08:26:20.874]                         computeRestarts <- base::computeRestarts
[08:26:20.874]                         grepl <- base::grepl
[08:26:20.874]                         restarts <- computeRestarts(cond)
[08:26:20.874]                         for (restart in restarts) {
[08:26:20.874]                           name <- restart$name
[08:26:20.874]                           if (is.null(name)) 
[08:26:20.874]                             next
[08:26:20.874]                           if (!grepl(pattern, name)) 
[08:26:20.874]                             next
[08:26:20.874]                           invokeRestart(restart)
[08:26:20.874]                           muffled <- TRUE
[08:26:20.874]                           break
[08:26:20.874]                         }
[08:26:20.874]                       }
[08:26:20.874]                     }
[08:26:20.874]                     invisible(muffled)
[08:26:20.874]                   }
[08:26:20.874]                   muffleCondition(cond)
[08:26:20.874]                 })
[08:26:20.874]             }))
[08:26:20.874]             future::FutureResult(value = ...future.value$value, 
[08:26:20.874]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.874]                   ...future.rng), globalenv = if (FALSE) 
[08:26:20.874]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:20.874]                     ...future.globalenv.names))
[08:26:20.874]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:20.874]         }, condition = base::local({
[08:26:20.874]             c <- base::c
[08:26:20.874]             inherits <- base::inherits
[08:26:20.874]             invokeRestart <- base::invokeRestart
[08:26:20.874]             length <- base::length
[08:26:20.874]             list <- base::list
[08:26:20.874]             seq.int <- base::seq.int
[08:26:20.874]             signalCondition <- base::signalCondition
[08:26:20.874]             sys.calls <- base::sys.calls
[08:26:20.874]             `[[` <- base::`[[`
[08:26:20.874]             `+` <- base::`+`
[08:26:20.874]             `<<-` <- base::`<<-`
[08:26:20.874]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:20.874]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:20.874]                   3L)]
[08:26:20.874]             }
[08:26:20.874]             function(cond) {
[08:26:20.874]                 is_error <- inherits(cond, "error")
[08:26:20.874]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:20.874]                   NULL)
[08:26:20.874]                 if (is_error) {
[08:26:20.874]                   sessionInformation <- function() {
[08:26:20.874]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:20.874]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:20.874]                       search = base::search(), system = base::Sys.info())
[08:26:20.874]                   }
[08:26:20.874]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.874]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:20.874]                     cond$call), session = sessionInformation(), 
[08:26:20.874]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:20.874]                   signalCondition(cond)
[08:26:20.874]                 }
[08:26:20.874]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:20.874]                 "immediateCondition"))) {
[08:26:20.874]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:20.874]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.874]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:20.874]                   if (TRUE && !signal) {
[08:26:20.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.874]                     {
[08:26:20.874]                       inherits <- base::inherits
[08:26:20.874]                       invokeRestart <- base::invokeRestart
[08:26:20.874]                       is.null <- base::is.null
[08:26:20.874]                       muffled <- FALSE
[08:26:20.874]                       if (inherits(cond, "message")) {
[08:26:20.874]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.874]                         if (muffled) 
[08:26:20.874]                           invokeRestart("muffleMessage")
[08:26:20.874]                       }
[08:26:20.874]                       else if (inherits(cond, "warning")) {
[08:26:20.874]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.874]                         if (muffled) 
[08:26:20.874]                           invokeRestart("muffleWarning")
[08:26:20.874]                       }
[08:26:20.874]                       else if (inherits(cond, "condition")) {
[08:26:20.874]                         if (!is.null(pattern)) {
[08:26:20.874]                           computeRestarts <- base::computeRestarts
[08:26:20.874]                           grepl <- base::grepl
[08:26:20.874]                           restarts <- computeRestarts(cond)
[08:26:20.874]                           for (restart in restarts) {
[08:26:20.874]                             name <- restart$name
[08:26:20.874]                             if (is.null(name)) 
[08:26:20.874]                               next
[08:26:20.874]                             if (!grepl(pattern, name)) 
[08:26:20.874]                               next
[08:26:20.874]                             invokeRestart(restart)
[08:26:20.874]                             muffled <- TRUE
[08:26:20.874]                             break
[08:26:20.874]                           }
[08:26:20.874]                         }
[08:26:20.874]                       }
[08:26:20.874]                       invisible(muffled)
[08:26:20.874]                     }
[08:26:20.874]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.874]                   }
[08:26:20.874]                 }
[08:26:20.874]                 else {
[08:26:20.874]                   if (TRUE) {
[08:26:20.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.874]                     {
[08:26:20.874]                       inherits <- base::inherits
[08:26:20.874]                       invokeRestart <- base::invokeRestart
[08:26:20.874]                       is.null <- base::is.null
[08:26:20.874]                       muffled <- FALSE
[08:26:20.874]                       if (inherits(cond, "message")) {
[08:26:20.874]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.874]                         if (muffled) 
[08:26:20.874]                           invokeRestart("muffleMessage")
[08:26:20.874]                       }
[08:26:20.874]                       else if (inherits(cond, "warning")) {
[08:26:20.874]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.874]                         if (muffled) 
[08:26:20.874]                           invokeRestart("muffleWarning")
[08:26:20.874]                       }
[08:26:20.874]                       else if (inherits(cond, "condition")) {
[08:26:20.874]                         if (!is.null(pattern)) {
[08:26:20.874]                           computeRestarts <- base::computeRestarts
[08:26:20.874]                           grepl <- base::grepl
[08:26:20.874]                           restarts <- computeRestarts(cond)
[08:26:20.874]                           for (restart in restarts) {
[08:26:20.874]                             name <- restart$name
[08:26:20.874]                             if (is.null(name)) 
[08:26:20.874]                               next
[08:26:20.874]                             if (!grepl(pattern, name)) 
[08:26:20.874]                               next
[08:26:20.874]                             invokeRestart(restart)
[08:26:20.874]                             muffled <- TRUE
[08:26:20.874]                             break
[08:26:20.874]                           }
[08:26:20.874]                         }
[08:26:20.874]                       }
[08:26:20.874]                       invisible(muffled)
[08:26:20.874]                     }
[08:26:20.874]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.874]                   }
[08:26:20.874]                 }
[08:26:20.874]             }
[08:26:20.874]         }))
[08:26:20.874]     }, error = function(ex) {
[08:26:20.874]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:20.874]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.874]                 ...future.rng), started = ...future.startTime, 
[08:26:20.874]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:20.874]             version = "1.8"), class = "FutureResult")
[08:26:20.874]     }, finally = {
[08:26:20.874]         if (!identical(...future.workdir, getwd())) 
[08:26:20.874]             setwd(...future.workdir)
[08:26:20.874]         {
[08:26:20.874]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:20.874]                 ...future.oldOptions$nwarnings <- NULL
[08:26:20.874]             }
[08:26:20.874]             base::options(...future.oldOptions)
[08:26:20.874]             if (.Platform$OS.type == "windows") {
[08:26:20.874]                 old_names <- names(...future.oldEnvVars)
[08:26:20.874]                 envs <- base::Sys.getenv()
[08:26:20.874]                 names <- names(envs)
[08:26:20.874]                 common <- intersect(names, old_names)
[08:26:20.874]                 added <- setdiff(names, old_names)
[08:26:20.874]                 removed <- setdiff(old_names, names)
[08:26:20.874]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:20.874]                   envs[common]]
[08:26:20.874]                 NAMES <- toupper(changed)
[08:26:20.874]                 args <- list()
[08:26:20.874]                 for (kk in seq_along(NAMES)) {
[08:26:20.874]                   name <- changed[[kk]]
[08:26:20.874]                   NAME <- NAMES[[kk]]
[08:26:20.874]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.874]                     next
[08:26:20.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.874]                 }
[08:26:20.874]                 NAMES <- toupper(added)
[08:26:20.874]                 for (kk in seq_along(NAMES)) {
[08:26:20.874]                   name <- added[[kk]]
[08:26:20.874]                   NAME <- NAMES[[kk]]
[08:26:20.874]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.874]                     next
[08:26:20.874]                   args[[name]] <- ""
[08:26:20.874]                 }
[08:26:20.874]                 NAMES <- toupper(removed)
[08:26:20.874]                 for (kk in seq_along(NAMES)) {
[08:26:20.874]                   name <- removed[[kk]]
[08:26:20.874]                   NAME <- NAMES[[kk]]
[08:26:20.874]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.874]                     next
[08:26:20.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.874]                 }
[08:26:20.874]                 if (length(args) > 0) 
[08:26:20.874]                   base::do.call(base::Sys.setenv, args = args)
[08:26:20.874]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:20.874]             }
[08:26:20.874]             else {
[08:26:20.874]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:20.874]             }
[08:26:20.874]             {
[08:26:20.874]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:20.874]                   0L) {
[08:26:20.874]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:20.874]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:20.874]                   base::options(opts)
[08:26:20.874]                 }
[08:26:20.874]                 {
[08:26:20.874]                   {
[08:26:20.874]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:20.874]                     NULL
[08:26:20.874]                   }
[08:26:20.874]                   options(future.plan = NULL)
[08:26:20.874]                   if (is.na(NA_character_)) 
[08:26:20.874]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.874]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:20.874]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:20.874]                     .init = FALSE)
[08:26:20.874]                 }
[08:26:20.874]             }
[08:26:20.874]         }
[08:26:20.874]     })
[08:26:20.874]     if (TRUE) {
[08:26:20.874]         base::sink(type = "output", split = FALSE)
[08:26:20.874]         if (TRUE) {
[08:26:20.874]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:20.874]         }
[08:26:20.874]         else {
[08:26:20.874]             ...future.result["stdout"] <- base::list(NULL)
[08:26:20.874]         }
[08:26:20.874]         base::close(...future.stdout)
[08:26:20.874]         ...future.stdout <- NULL
[08:26:20.874]     }
[08:26:20.874]     ...future.result$conditions <- ...future.conditions
[08:26:20.874]     ...future.result$finished <- base::Sys.time()
[08:26:20.874]     ...future.result
[08:26:20.874] }
[08:26:20.877] assign_globals() ...
[08:26:20.877] List of 5
[08:26:20.877]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[08:26:20.877]  $ future.call.arguments    : list()
[08:26:20.877]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.877]  $ ...future.elements_ii    :List of 4
[08:26:20.877]   ..$ : int [1:3] 1 2 3
[08:26:20.877]   ..$ : int [1:4] 1 2 3 4
[08:26:20.877]   ..$ : int [1:5] 1 2 3 4 5
[08:26:20.877]   ..$ : int [1:6] 1 2 3 4 5 6
[08:26:20.877]  $ ...future.seeds_ii       : NULL
[08:26:20.877]  $ ...future.globals.maxSize: NULL
[08:26:20.877]  - attr(*, "where")=List of 5
[08:26:20.877]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:20.877]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:20.877]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:20.877]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:20.877]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:20.877]  - attr(*, "resolved")= logi FALSE
[08:26:20.877]  - attr(*, "total_size")= num 18895
[08:26:20.877]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.877]  - attr(*, "already-done")= logi TRUE
[08:26:20.885] - copied ‘...future.FUN’ to environment
[08:26:20.885] - copied ‘future.call.arguments’ to environment
[08:26:20.886] - copied ‘...future.elements_ii’ to environment
[08:26:20.886] - copied ‘...future.seeds_ii’ to environment
[08:26:20.886] - copied ‘...future.globals.maxSize’ to environment
[08:26:20.886] assign_globals() ... done
[08:26:20.886] requestCore(): workers = 2
[08:26:20.889] MulticoreFuture started
[08:26:20.890] - Launch lazy future ... done
[08:26:20.890] run() for ‘MulticoreFuture’ ... done
[08:26:20.891] Created future:
[08:26:20.891] plan(): Setting new future strategy stack:
[08:26:20.891] List of future strategies:
[08:26:20.891] 1. sequential:
[08:26:20.891]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:20.891]    - tweaked: FALSE
[08:26:20.891]    - call: NULL
[08:26:20.893] plan(): nbrOfWorkers() = 1
[08:26:20.897] plan(): Setting new future strategy stack:
[08:26:20.897] List of future strategies:
[08:26:20.897] 1. multicore:
[08:26:20.897]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:20.897]    - tweaked: FALSE
[08:26:20.897]    - call: plan(strategy)
[08:26:20.902] plan(): nbrOfWorkers() = 2
[08:26:20.891] MulticoreFuture:
[08:26:20.891] Label: ‘future_sapply-1’
[08:26:20.891] Expression:
[08:26:20.891] {
[08:26:20.891]     do.call(function(...) {
[08:26:20.891]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.891]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.891]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.891]             on.exit(options(oopts), add = TRUE)
[08:26:20.891]         }
[08:26:20.891]         {
[08:26:20.891]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.891]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.891]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.891]             })
[08:26:20.891]         }
[08:26:20.891]     }, args = future.call.arguments)
[08:26:20.891] }
[08:26:20.891] Lazy evaluation: FALSE
[08:26:20.891] Asynchronous evaluation: TRUE
[08:26:20.891] Local evaluation: TRUE
[08:26:20.891] Environment: R_GlobalEnv
[08:26:20.891] Capture standard output: TRUE
[08:26:20.891] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:20.891] Globals: 5 objects totaling 5.17 KiB (function ‘...future.FUN’ of 4.67 KiB, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 369 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:20.891] Packages: 1 packages (‘stats’)
[08:26:20.891] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:20.891] Resolved: TRUE
[08:26:20.891] Value: <not collected>
[08:26:20.891] Conditions captured: <none>
[08:26:20.891] Early signaling: FALSE
[08:26:20.891] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:20.891] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.903] Chunk #1 of 2 ... DONE
[08:26:20.903] Chunk #2 of 2 ...
[08:26:20.904]  - Finding globals in 'X' for chunk #2 ...
[08:26:20.904] getGlobalsAndPackages() ...
[08:26:20.904] Searching for globals...
[08:26:20.905] 
[08:26:20.905] Searching for globals ... DONE
[08:26:20.905] - globals: [0] <none>
[08:26:20.905] getGlobalsAndPackages() ... DONE
[08:26:20.905]    + additional globals found: [n=0] 
[08:26:20.906]    + additional namespaces needed: [n=0] 
[08:26:20.906]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:20.906]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:20.906]  - seeds: <none>
[08:26:20.906]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.907] getGlobalsAndPackages() ...
[08:26:20.907] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.907] Resolving globals: FALSE
[08:26:20.907] Tweak future expression to call with '...' arguments ...
[08:26:20.908] {
[08:26:20.908]     do.call(function(...) {
[08:26:20.908]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.908]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.908]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.908]             on.exit(options(oopts), add = TRUE)
[08:26:20.908]         }
[08:26:20.908]         {
[08:26:20.908]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.908]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.908]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.908]             })
[08:26:20.908]         }
[08:26:20.908]     }, args = future.call.arguments)
[08:26:20.908] }
[08:26:20.908] Tweak future expression to call with '...' arguments ... DONE
[08:26:20.909] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.909] - packages: [1] ‘stats’
[08:26:20.909] getGlobalsAndPackages() ... DONE
[08:26:20.909] run() for ‘Future’ ...
[08:26:20.910] - state: ‘created’
[08:26:20.910] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:20.913] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.913] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:20.913]   - Field: ‘label’
[08:26:20.913]   - Field: ‘local’
[08:26:20.913]   - Field: ‘owner’
[08:26:20.913]   - Field: ‘envir’
[08:26:20.914]   - Field: ‘workers’
[08:26:20.914]   - Field: ‘packages’
[08:26:20.914]   - Field: ‘gc’
[08:26:20.914]   - Field: ‘job’
[08:26:20.914]   - Field: ‘conditions’
[08:26:20.914]   - Field: ‘expr’
[08:26:20.914]   - Field: ‘uuid’
[08:26:20.915]   - Field: ‘seed’
[08:26:20.915]   - Field: ‘version’
[08:26:20.915]   - Field: ‘result’
[08:26:20.915]   - Field: ‘asynchronous’
[08:26:20.915]   - Field: ‘calls’
[08:26:20.915]   - Field: ‘globals’
[08:26:20.915]   - Field: ‘stdout’
[08:26:20.915]   - Field: ‘earlySignal’
[08:26:20.916]   - Field: ‘lazy’
[08:26:20.916]   - Field: ‘state’
[08:26:20.916] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:20.916] - Launch lazy future ...
[08:26:20.916] Packages needed by the future expression (n = 1): ‘stats’
[08:26:20.917] Packages needed by future strategies (n = 0): <none>
[08:26:20.917] {
[08:26:20.917]     {
[08:26:20.917]         {
[08:26:20.917]             ...future.startTime <- base::Sys.time()
[08:26:20.917]             {
[08:26:20.917]                 {
[08:26:20.917]                   {
[08:26:20.917]                     {
[08:26:20.917]                       {
[08:26:20.917]                         base::local({
[08:26:20.917]                           has_future <- base::requireNamespace("future", 
[08:26:20.917]                             quietly = TRUE)
[08:26:20.917]                           if (has_future) {
[08:26:20.917]                             ns <- base::getNamespace("future")
[08:26:20.917]                             version <- ns[[".package"]][["version"]]
[08:26:20.917]                             if (is.null(version)) 
[08:26:20.917]                               version <- utils::packageVersion("future")
[08:26:20.917]                           }
[08:26:20.917]                           else {
[08:26:20.917]                             version <- NULL
[08:26:20.917]                           }
[08:26:20.917]                           if (!has_future || version < "1.8.0") {
[08:26:20.917]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:20.917]                               "", base::R.version$version.string), 
[08:26:20.917]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:20.917]                                 base::R.version$platform, 8 * 
[08:26:20.917]                                   base::.Machine$sizeof.pointer), 
[08:26:20.917]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:20.917]                                 "release", "version")], collapse = " "), 
[08:26:20.917]                               hostname = base::Sys.info()[["nodename"]])
[08:26:20.917]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:20.917]                               info)
[08:26:20.917]                             info <- base::paste(info, collapse = "; ")
[08:26:20.917]                             if (!has_future) {
[08:26:20.917]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:20.917]                                 info)
[08:26:20.917]                             }
[08:26:20.917]                             else {
[08:26:20.917]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:20.917]                                 info, version)
[08:26:20.917]                             }
[08:26:20.917]                             base::stop(msg)
[08:26:20.917]                           }
[08:26:20.917]                         })
[08:26:20.917]                       }
[08:26:20.917]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:20.917]                       base::options(mc.cores = 1L)
[08:26:20.917]                     }
[08:26:20.917]                     base::local({
[08:26:20.917]                       for (pkg in "stats") {
[08:26:20.917]                         base::loadNamespace(pkg)
[08:26:20.917]                         base::library(pkg, character.only = TRUE)
[08:26:20.917]                       }
[08:26:20.917]                     })
[08:26:20.917]                   }
[08:26:20.917]                   ...future.strategy.old <- future::plan("list")
[08:26:20.917]                   options(future.plan = NULL)
[08:26:20.917]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.917]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:20.917]                 }
[08:26:20.917]                 ...future.workdir <- getwd()
[08:26:20.917]             }
[08:26:20.917]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:20.917]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:20.917]         }
[08:26:20.917]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:20.917]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:20.917]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:20.917]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:20.917]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:20.917]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:20.917]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:20.917]             base::names(...future.oldOptions))
[08:26:20.917]     }
[08:26:20.917]     if (FALSE) {
[08:26:20.917]     }
[08:26:20.917]     else {
[08:26:20.917]         if (TRUE) {
[08:26:20.917]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:20.917]                 open = "w")
[08:26:20.917]         }
[08:26:20.917]         else {
[08:26:20.917]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:20.917]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:20.917]         }
[08:26:20.917]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:20.917]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:20.917]             base::sink(type = "output", split = FALSE)
[08:26:20.917]             base::close(...future.stdout)
[08:26:20.917]         }, add = TRUE)
[08:26:20.917]     }
[08:26:20.917]     ...future.frame <- base::sys.nframe()
[08:26:20.917]     ...future.conditions <- base::list()
[08:26:20.917]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:20.917]     if (FALSE) {
[08:26:20.917]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:20.917]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:20.917]     }
[08:26:20.917]     ...future.result <- base::tryCatch({
[08:26:20.917]         base::withCallingHandlers({
[08:26:20.917]             ...future.value <- base::withVisible(base::local({
[08:26:20.917]                 withCallingHandlers({
[08:26:20.917]                   {
[08:26:20.917]                     do.call(function(...) {
[08:26:20.917]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.917]                       if (!identical(...future.globals.maxSize.org, 
[08:26:20.917]                         ...future.globals.maxSize)) {
[08:26:20.917]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.917]                         on.exit(options(oopts), add = TRUE)
[08:26:20.917]                       }
[08:26:20.917]                       {
[08:26:20.917]                         lapply(seq_along(...future.elements_ii), 
[08:26:20.917]                           FUN = function(jj) {
[08:26:20.917]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.917]                             ...future.FUN(...future.X_jj, ...)
[08:26:20.917]                           })
[08:26:20.917]                       }
[08:26:20.917]                     }, args = future.call.arguments)
[08:26:20.917]                   }
[08:26:20.917]                 }, immediateCondition = function(cond) {
[08:26:20.917]                   save_rds <- function (object, pathname, ...) 
[08:26:20.917]                   {
[08:26:20.917]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:20.917]                     if (file_test("-f", pathname_tmp)) {
[08:26:20.917]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.917]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:20.917]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.917]                         fi_tmp[["mtime"]])
[08:26:20.917]                     }
[08:26:20.917]                     tryCatch({
[08:26:20.917]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:20.917]                     }, error = function(ex) {
[08:26:20.917]                       msg <- conditionMessage(ex)
[08:26:20.917]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.917]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:20.917]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.917]                         fi_tmp[["mtime"]], msg)
[08:26:20.917]                       ex$message <- msg
[08:26:20.917]                       stop(ex)
[08:26:20.917]                     })
[08:26:20.917]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:20.917]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:20.917]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:20.917]                       fi_tmp <- file.info(pathname_tmp)
[08:26:20.917]                       fi <- file.info(pathname)
[08:26:20.917]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:20.917]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:20.917]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:20.917]                         fi[["size"]], fi[["mtime"]])
[08:26:20.917]                       stop(msg)
[08:26:20.917]                     }
[08:26:20.917]                     invisible(pathname)
[08:26:20.917]                   }
[08:26:20.917]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:20.917]                     rootPath = tempdir()) 
[08:26:20.917]                   {
[08:26:20.917]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:20.917]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:20.917]                       tmpdir = path, fileext = ".rds")
[08:26:20.917]                     save_rds(obj, file)
[08:26:20.917]                   }
[08:26:20.917]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:20.917]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.917]                   {
[08:26:20.917]                     inherits <- base::inherits
[08:26:20.917]                     invokeRestart <- base::invokeRestart
[08:26:20.917]                     is.null <- base::is.null
[08:26:20.917]                     muffled <- FALSE
[08:26:20.917]                     if (inherits(cond, "message")) {
[08:26:20.917]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:20.917]                       if (muffled) 
[08:26:20.917]                         invokeRestart("muffleMessage")
[08:26:20.917]                     }
[08:26:20.917]                     else if (inherits(cond, "warning")) {
[08:26:20.917]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:20.917]                       if (muffled) 
[08:26:20.917]                         invokeRestart("muffleWarning")
[08:26:20.917]                     }
[08:26:20.917]                     else if (inherits(cond, "condition")) {
[08:26:20.917]                       if (!is.null(pattern)) {
[08:26:20.917]                         computeRestarts <- base::computeRestarts
[08:26:20.917]                         grepl <- base::grepl
[08:26:20.917]                         restarts <- computeRestarts(cond)
[08:26:20.917]                         for (restart in restarts) {
[08:26:20.917]                           name <- restart$name
[08:26:20.917]                           if (is.null(name)) 
[08:26:20.917]                             next
[08:26:20.917]                           if (!grepl(pattern, name)) 
[08:26:20.917]                             next
[08:26:20.917]                           invokeRestart(restart)
[08:26:20.917]                           muffled <- TRUE
[08:26:20.917]                           break
[08:26:20.917]                         }
[08:26:20.917]                       }
[08:26:20.917]                     }
[08:26:20.917]                     invisible(muffled)
[08:26:20.917]                   }
[08:26:20.917]                   muffleCondition(cond)
[08:26:20.917]                 })
[08:26:20.917]             }))
[08:26:20.917]             future::FutureResult(value = ...future.value$value, 
[08:26:20.917]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.917]                   ...future.rng), globalenv = if (FALSE) 
[08:26:20.917]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:20.917]                     ...future.globalenv.names))
[08:26:20.917]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:20.917]         }, condition = base::local({
[08:26:20.917]             c <- base::c
[08:26:20.917]             inherits <- base::inherits
[08:26:20.917]             invokeRestart <- base::invokeRestart
[08:26:20.917]             length <- base::length
[08:26:20.917]             list <- base::list
[08:26:20.917]             seq.int <- base::seq.int
[08:26:20.917]             signalCondition <- base::signalCondition
[08:26:20.917]             sys.calls <- base::sys.calls
[08:26:20.917]             `[[` <- base::`[[`
[08:26:20.917]             `+` <- base::`+`
[08:26:20.917]             `<<-` <- base::`<<-`
[08:26:20.917]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:20.917]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:20.917]                   3L)]
[08:26:20.917]             }
[08:26:20.917]             function(cond) {
[08:26:20.917]                 is_error <- inherits(cond, "error")
[08:26:20.917]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:20.917]                   NULL)
[08:26:20.917]                 if (is_error) {
[08:26:20.917]                   sessionInformation <- function() {
[08:26:20.917]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:20.917]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:20.917]                       search = base::search(), system = base::Sys.info())
[08:26:20.917]                   }
[08:26:20.917]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.917]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:20.917]                     cond$call), session = sessionInformation(), 
[08:26:20.917]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:20.917]                   signalCondition(cond)
[08:26:20.917]                 }
[08:26:20.917]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:20.917]                 "immediateCondition"))) {
[08:26:20.917]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:20.917]                   ...future.conditions[[length(...future.conditions) + 
[08:26:20.917]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:20.917]                   if (TRUE && !signal) {
[08:26:20.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.917]                     {
[08:26:20.917]                       inherits <- base::inherits
[08:26:20.917]                       invokeRestart <- base::invokeRestart
[08:26:20.917]                       is.null <- base::is.null
[08:26:20.917]                       muffled <- FALSE
[08:26:20.917]                       if (inherits(cond, "message")) {
[08:26:20.917]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.917]                         if (muffled) 
[08:26:20.917]                           invokeRestart("muffleMessage")
[08:26:20.917]                       }
[08:26:20.917]                       else if (inherits(cond, "warning")) {
[08:26:20.917]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.917]                         if (muffled) 
[08:26:20.917]                           invokeRestart("muffleWarning")
[08:26:20.917]                       }
[08:26:20.917]                       else if (inherits(cond, "condition")) {
[08:26:20.917]                         if (!is.null(pattern)) {
[08:26:20.917]                           computeRestarts <- base::computeRestarts
[08:26:20.917]                           grepl <- base::grepl
[08:26:20.917]                           restarts <- computeRestarts(cond)
[08:26:20.917]                           for (restart in restarts) {
[08:26:20.917]                             name <- restart$name
[08:26:20.917]                             if (is.null(name)) 
[08:26:20.917]                               next
[08:26:20.917]                             if (!grepl(pattern, name)) 
[08:26:20.917]                               next
[08:26:20.917]                             invokeRestart(restart)
[08:26:20.917]                             muffled <- TRUE
[08:26:20.917]                             break
[08:26:20.917]                           }
[08:26:20.917]                         }
[08:26:20.917]                       }
[08:26:20.917]                       invisible(muffled)
[08:26:20.917]                     }
[08:26:20.917]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.917]                   }
[08:26:20.917]                 }
[08:26:20.917]                 else {
[08:26:20.917]                   if (TRUE) {
[08:26:20.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:20.917]                     {
[08:26:20.917]                       inherits <- base::inherits
[08:26:20.917]                       invokeRestart <- base::invokeRestart
[08:26:20.917]                       is.null <- base::is.null
[08:26:20.917]                       muffled <- FALSE
[08:26:20.917]                       if (inherits(cond, "message")) {
[08:26:20.917]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:20.917]                         if (muffled) 
[08:26:20.917]                           invokeRestart("muffleMessage")
[08:26:20.917]                       }
[08:26:20.917]                       else if (inherits(cond, "warning")) {
[08:26:20.917]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:20.917]                         if (muffled) 
[08:26:20.917]                           invokeRestart("muffleWarning")
[08:26:20.917]                       }
[08:26:20.917]                       else if (inherits(cond, "condition")) {
[08:26:20.917]                         if (!is.null(pattern)) {
[08:26:20.917]                           computeRestarts <- base::computeRestarts
[08:26:20.917]                           grepl <- base::grepl
[08:26:20.917]                           restarts <- computeRestarts(cond)
[08:26:20.917]                           for (restart in restarts) {
[08:26:20.917]                             name <- restart$name
[08:26:20.917]                             if (is.null(name)) 
[08:26:20.917]                               next
[08:26:20.917]                             if (!grepl(pattern, name)) 
[08:26:20.917]                               next
[08:26:20.917]                             invokeRestart(restart)
[08:26:20.917]                             muffled <- TRUE
[08:26:20.917]                             break
[08:26:20.917]                           }
[08:26:20.917]                         }
[08:26:20.917]                       }
[08:26:20.917]                       invisible(muffled)
[08:26:20.917]                     }
[08:26:20.917]                     muffleCondition(cond, pattern = "^muffle")
[08:26:20.917]                   }
[08:26:20.917]                 }
[08:26:20.917]             }
[08:26:20.917]         }))
[08:26:20.917]     }, error = function(ex) {
[08:26:20.917]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:20.917]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:20.917]                 ...future.rng), started = ...future.startTime, 
[08:26:20.917]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:20.917]             version = "1.8"), class = "FutureResult")
[08:26:20.917]     }, finally = {
[08:26:20.917]         if (!identical(...future.workdir, getwd())) 
[08:26:20.917]             setwd(...future.workdir)
[08:26:20.917]         {
[08:26:20.917]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:20.917]                 ...future.oldOptions$nwarnings <- NULL
[08:26:20.917]             }
[08:26:20.917]             base::options(...future.oldOptions)
[08:26:20.917]             if (.Platform$OS.type == "windows") {
[08:26:20.917]                 old_names <- names(...future.oldEnvVars)
[08:26:20.917]                 envs <- base::Sys.getenv()
[08:26:20.917]                 names <- names(envs)
[08:26:20.917]                 common <- intersect(names, old_names)
[08:26:20.917]                 added <- setdiff(names, old_names)
[08:26:20.917]                 removed <- setdiff(old_names, names)
[08:26:20.917]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:20.917]                   envs[common]]
[08:26:20.917]                 NAMES <- toupper(changed)
[08:26:20.917]                 args <- list()
[08:26:20.917]                 for (kk in seq_along(NAMES)) {
[08:26:20.917]                   name <- changed[[kk]]
[08:26:20.917]                   NAME <- NAMES[[kk]]
[08:26:20.917]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.917]                     next
[08:26:20.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.917]                 }
[08:26:20.917]                 NAMES <- toupper(added)
[08:26:20.917]                 for (kk in seq_along(NAMES)) {
[08:26:20.917]                   name <- added[[kk]]
[08:26:20.917]                   NAME <- NAMES[[kk]]
[08:26:20.917]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.917]                     next
[08:26:20.917]                   args[[name]] <- ""
[08:26:20.917]                 }
[08:26:20.917]                 NAMES <- toupper(removed)
[08:26:20.917]                 for (kk in seq_along(NAMES)) {
[08:26:20.917]                   name <- removed[[kk]]
[08:26:20.917]                   NAME <- NAMES[[kk]]
[08:26:20.917]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:20.917]                     next
[08:26:20.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:20.917]                 }
[08:26:20.917]                 if (length(args) > 0) 
[08:26:20.917]                   base::do.call(base::Sys.setenv, args = args)
[08:26:20.917]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:20.917]             }
[08:26:20.917]             else {
[08:26:20.917]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:20.917]             }
[08:26:20.917]             {
[08:26:20.917]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:20.917]                   0L) {
[08:26:20.917]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:20.917]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:20.917]                   base::options(opts)
[08:26:20.917]                 }
[08:26:20.917]                 {
[08:26:20.917]                   {
[08:26:20.917]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:20.917]                     NULL
[08:26:20.917]                   }
[08:26:20.917]                   options(future.plan = NULL)
[08:26:20.917]                   if (is.na(NA_character_)) 
[08:26:20.917]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:20.917]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:20.917]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:20.917]                     .init = FALSE)
[08:26:20.917]                 }
[08:26:20.917]             }
[08:26:20.917]         }
[08:26:20.917]     })
[08:26:20.917]     if (TRUE) {
[08:26:20.917]         base::sink(type = "output", split = FALSE)
[08:26:20.917]         if (TRUE) {
[08:26:20.917]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:20.917]         }
[08:26:20.917]         else {
[08:26:20.917]             ...future.result["stdout"] <- base::list(NULL)
[08:26:20.917]         }
[08:26:20.917]         base::close(...future.stdout)
[08:26:20.917]         ...future.stdout <- NULL
[08:26:20.917]     }
[08:26:20.917]     ...future.result$conditions <- ...future.conditions
[08:26:20.917]     ...future.result$finished <- base::Sys.time()
[08:26:20.917]     ...future.result
[08:26:20.917] }
[08:26:20.921] assign_globals() ...
[08:26:20.921] List of 5
[08:26:20.921]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[08:26:20.921]  $ future.call.arguments    : list()
[08:26:20.921]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.921]  $ ...future.elements_ii    :List of 3
[08:26:20.921]   ..$ : int [1:7] 1 2 3 4 5 6 7
[08:26:20.921]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[08:26:20.921]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[08:26:20.921]  $ ...future.seeds_ii       : NULL
[08:26:20.921]  $ ...future.globals.maxSize: NULL
[08:26:20.921]  - attr(*, "where")=List of 5
[08:26:20.921]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:20.921]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:20.921]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:20.921]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:20.921]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:20.921]  - attr(*, "resolved")= logi FALSE
[08:26:20.921]  - attr(*, "total_size")= num 18895
[08:26:20.921]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.921]  - attr(*, "already-done")= logi TRUE
[08:26:20.928] - copied ‘...future.FUN’ to environment
[08:26:20.928] - copied ‘future.call.arguments’ to environment
[08:26:20.928] - copied ‘...future.elements_ii’ to environment
[08:26:20.928] - copied ‘...future.seeds_ii’ to environment
[08:26:20.929] - copied ‘...future.globals.maxSize’ to environment
[08:26:20.929] assign_globals() ... done
[08:26:20.929] requestCore(): workers = 2
[08:26:20.931] MulticoreFuture started
[08:26:20.932] - Launch lazy future ... done
[08:26:20.932] run() for ‘MulticoreFuture’ ... done
[08:26:20.932] Created future:
[08:26:20.933] plan(): Setting new future strategy stack:
[08:26:20.933] List of future strategies:
[08:26:20.933] 1. sequential:
[08:26:20.933]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:20.933]    - tweaked: FALSE
[08:26:20.933]    - call: NULL
[08:26:20.937] plan(): nbrOfWorkers() = 1
[08:26:20.941] plan(): Setting new future strategy stack:
[08:26:20.941] List of future strategies:
[08:26:20.941] 1. multicore:
[08:26:20.941]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:20.941]    - tweaked: FALSE
[08:26:20.941]    - call: plan(strategy)
[08:26:20.946] plan(): nbrOfWorkers() = 2
[08:26:20.932] MulticoreFuture:
[08:26:20.932] Label: ‘future_sapply-2’
[08:26:20.932] Expression:
[08:26:20.932] {
[08:26:20.932]     do.call(function(...) {
[08:26:20.932]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.932]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.932]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.932]             on.exit(options(oopts), add = TRUE)
[08:26:20.932]         }
[08:26:20.932]         {
[08:26:20.932]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.932]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.932]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.932]             })
[08:26:20.932]         }
[08:26:20.932]     }, args = future.call.arguments)
[08:26:20.932] }
[08:26:20.932] Lazy evaluation: FALSE
[08:26:20.932] Asynchronous evaluation: TRUE
[08:26:20.932] Local evaluation: TRUE
[08:26:20.932] Environment: R_GlobalEnv
[08:26:20.932] Capture standard output: TRUE
[08:26:20.932] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:20.932] Globals: 5 objects totaling 5.10 KiB (function ‘...future.FUN’ of 4.67 KiB, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 293 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:20.932] Packages: 1 packages (‘stats’)
[08:26:20.932] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:20.932] Resolved: TRUE
[08:26:20.932] Value: <not collected>
[08:26:20.932] Conditions captured: <none>
[08:26:20.932] Early signaling: FALSE
[08:26:20.932] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:20.932] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:20.947] Chunk #2 of 2 ... DONE
[08:26:20.948] Launching 2 futures (chunks) ... DONE
[08:26:20.948] Resolving 2 futures (chunks) ...
[08:26:20.948] resolve() on list ...
[08:26:20.949]  recursive: 0
[08:26:20.949]  length: 2
[08:26:20.949] 
[08:26:20.949] Future #1
[08:26:20.950] result() for MulticoreFuture ...
[08:26:20.951] result() for MulticoreFuture ...
[08:26:20.951] result() for MulticoreFuture ... done
[08:26:20.951] result() for MulticoreFuture ... done
[08:26:20.951] result() for MulticoreFuture ...
[08:26:20.952] result() for MulticoreFuture ... done
[08:26:20.952] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:26:20.952] - nx: 2
[08:26:20.952] - relay: TRUE
[08:26:20.953] - stdout: TRUE
[08:26:20.953] - signal: TRUE
[08:26:20.953] - resignal: FALSE
[08:26:20.953] - force: TRUE
[08:26:20.954] - relayed: [n=2] FALSE, FALSE
[08:26:20.954] - queued futures: [n=2] FALSE, FALSE
[08:26:20.954]  - until=1
[08:26:20.954]  - relaying element #1
[08:26:20.954] result() for MulticoreFuture ...
[08:26:20.955] result() for MulticoreFuture ... done
[08:26:20.955] result() for MulticoreFuture ...
[08:26:20.955] result() for MulticoreFuture ... done
[08:26:20.956] result() for MulticoreFuture ...
[08:26:20.956] result() for MulticoreFuture ... done
[08:26:20.956] result() for MulticoreFuture ...
[08:26:20.956] result() for MulticoreFuture ... done
[08:26:20.957] - relayed: [n=2] TRUE, FALSE
[08:26:20.957] - queued futures: [n=2] TRUE, FALSE
[08:26:20.957] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:26:20.957]  length: 1 (resolved future 1)
[08:26:20.958] Future #2
[08:26:20.958] result() for MulticoreFuture ...
[08:26:20.959] result() for MulticoreFuture ...
[08:26:20.959] result() for MulticoreFuture ... done
[08:26:20.959] result() for MulticoreFuture ... done
[08:26:20.959] result() for MulticoreFuture ...
[08:26:20.960] result() for MulticoreFuture ... done
[08:26:20.960] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:26:20.960] - nx: 2
[08:26:20.960] - relay: TRUE
[08:26:20.960] - stdout: TRUE
[08:26:20.960] - signal: TRUE
[08:26:20.960] - resignal: FALSE
[08:26:20.960] - force: TRUE
[08:26:20.960] - relayed: [n=2] TRUE, FALSE
[08:26:20.961] - queued futures: [n=2] TRUE, FALSE
[08:26:20.961]  - until=2
[08:26:20.961]  - relaying element #2
[08:26:20.961] result() for MulticoreFuture ...
[08:26:20.961] result() for MulticoreFuture ... done
[08:26:20.961] result() for MulticoreFuture ...
[08:26:20.961] result() for MulticoreFuture ... done
[08:26:20.961] result() for MulticoreFuture ...
[08:26:20.962] result() for MulticoreFuture ... done
[08:26:20.962] result() for MulticoreFuture ...
[08:26:20.962] result() for MulticoreFuture ... done
[08:26:20.962] - relayed: [n=2] TRUE, TRUE
[08:26:20.962] - queued futures: [n=2] TRUE, TRUE
[08:26:20.962] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:26:20.962]  length: 0 (resolved future 2)
[08:26:20.962] Relaying remaining futures
[08:26:20.962] signalConditionsASAP(NULL, pos=0) ...
[08:26:20.963] - nx: 2
[08:26:20.963] - relay: TRUE
[08:26:20.963] - stdout: TRUE
[08:26:20.963] - signal: TRUE
[08:26:20.963] - resignal: FALSE
[08:26:20.963] - force: TRUE
[08:26:20.963] - relayed: [n=2] TRUE, TRUE
[08:26:20.963] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:20.963] - relayed: [n=2] TRUE, TRUE
[08:26:20.963] - queued futures: [n=2] TRUE, TRUE
[08:26:20.964] signalConditionsASAP(NULL, pos=0) ... done
[08:26:20.964] resolve() on list ... DONE
[08:26:20.964] result() for MulticoreFuture ...
[08:26:20.964] result() for MulticoreFuture ... done
[08:26:20.964] result() for MulticoreFuture ...
[08:26:20.964] result() for MulticoreFuture ... done
[08:26:20.964] result() for MulticoreFuture ...
[08:26:20.964] result() for MulticoreFuture ... done
[08:26:20.964] result() for MulticoreFuture ...
[08:26:20.965] result() for MulticoreFuture ... done
[08:26:20.965]  - Number of value chunks collected: 2
[08:26:20.965] Resolving 2 futures (chunks) ... DONE
[08:26:20.965] Reducing values from 2 chunks ...
[08:26:20.965]  - Number of values collected after concatenation: 7
[08:26:20.965]  - Number of values expected: 7
[08:26:20.965] Reducing values from 2 chunks ... DONE
[08:26:20.965] future_lapply() ... DONE
[08:26:20.966] future_lapply() ...
[08:26:20.970] Number of chunks: 2
[08:26:20.970] getGlobalsAndPackagesXApply() ...
[08:26:20.970]  - future.globals: TRUE
[08:26:20.970] getGlobalsAndPackages() ...
[08:26:20.970] Searching for globals...
[08:26:20.981] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[08:26:20.981] Searching for globals ... DONE
[08:26:20.981] Resolving globals: FALSE
[08:26:20.983] The total size of the 7 globals is 26.71 KiB (27354 bytes)
[08:26:20.983] The total size of the 7 globals exported for future expression (‘FUN()’) is 26.71 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (14.07 KiB of class ‘function’), ‘x_FUN’ (4.67 KiB of class ‘function’) and ‘stop_if_not’ (4.51 KiB of class ‘function’)
[08:26:20.983] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:20.984] - packages: [2] ‘stats’, ‘future.apply’
[08:26:20.984] getGlobalsAndPackages() ... DONE
[08:26:20.984]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:20.984]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[08:26:20.984] Finding globals ... DONE
[08:26:20.984]  - use_args: TRUE
[08:26:20.984]  - Getting '...' globals ...
[08:26:20.985] resolve() on list ...
[08:26:20.985]  recursive: 0
[08:26:20.985]  length: 1
[08:26:20.985]  elements: ‘...’
[08:26:20.985]  length: 0 (resolved future 1)
[08:26:20.985] resolve() on list ... DONE
[08:26:20.985]    - '...' content: [n=0] 
[08:26:20.985] List of 1
[08:26:20.985]  $ ...: list()
[08:26:20.985]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.985]  - attr(*, "where")=List of 1
[08:26:20.985]   ..$ ...:<environment: 0x562ca5f65e08> 
[08:26:20.985]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.985]  - attr(*, "resolved")= logi TRUE
[08:26:20.985]  - attr(*, "total_size")= num NA
[08:26:20.988]  - Getting '...' globals ... DONE
[08:26:20.988] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:20.988] List of 8
[08:26:20.988]  $ ...future.FUN:function (x, ...)  
[08:26:20.988]  $ x_FUN        :function (x, na.rm = TRUE)  
[08:26:20.988]  $ times        : int 5
[08:26:20.988]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:20.988]  $ stop_if_not  :function (...)  
[08:26:20.988]  $ dim          : NULL
[08:26:20.988]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:20.988]  $ ...          : list()
[08:26:20.988]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:20.988]  - attr(*, "where")=List of 8
[08:26:20.988]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:20.988]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:20.988]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:20.988]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:20.988]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:20.988]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:20.988]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:20.988]   ..$ ...          :<environment: 0x562ca5f65e08> 
[08:26:20.988]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:20.988]  - attr(*, "resolved")= logi FALSE
[08:26:20.988]  - attr(*, "total_size")= num 48005
[08:26:20.994] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[08:26:20.994] getGlobalsAndPackagesXApply() ... DONE
[08:26:20.994] Number of futures (= number of chunks): 2
[08:26:20.994] Launching 2 futures (chunks) ...
[08:26:20.994] Chunk #1 of 2 ...
[08:26:20.994]  - Finding globals in 'X' for chunk #1 ...
[08:26:20.994] getGlobalsAndPackages() ...
[08:26:20.995] Searching for globals...
[08:26:20.995] 
[08:26:20.995] Searching for globals ... DONE
[08:26:20.995] - globals: [0] <none>
[08:26:20.995] getGlobalsAndPackages() ... DONE
[08:26:20.995]    + additional globals found: [n=0] 
[08:26:20.997]    + additional namespaces needed: [n=0] 
[08:26:20.998]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:20.998]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:20.998]  - seeds: <none>
[08:26:20.998]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.998] getGlobalsAndPackages() ...
[08:26:20.998] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:20.998] Resolving globals: FALSE
[08:26:20.998] Tweak future expression to call with '...' arguments ...
[08:26:20.999] {
[08:26:20.999]     do.call(function(...) {
[08:26:20.999]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:20.999]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:20.999]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:20.999]             on.exit(options(oopts), add = TRUE)
[08:26:20.999]         }
[08:26:20.999]         {
[08:26:20.999]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:20.999]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:20.999]                 ...future.FUN(...future.X_jj, ...)
[08:26:20.999]             })
[08:26:20.999]         }
[08:26:20.999]     }, args = future.call.arguments)
[08:26:20.999] }
[08:26:20.999] Tweak future expression to call with '...' arguments ... DONE
[08:26:20.999] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.000] - packages: [2] ‘stats’, ‘future.apply’
[08:26:21.000] getGlobalsAndPackages() ... DONE
[08:26:21.000] run() for ‘Future’ ...
[08:26:21.000] - state: ‘created’
[08:26:21.000] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:21.002] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.002] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:21.003]   - Field: ‘label’
[08:26:21.003]   - Field: ‘local’
[08:26:21.003]   - Field: ‘owner’
[08:26:21.003]   - Field: ‘envir’
[08:26:21.003]   - Field: ‘workers’
[08:26:21.003]   - Field: ‘packages’
[08:26:21.003]   - Field: ‘gc’
[08:26:21.003]   - Field: ‘job’
[08:26:21.004]   - Field: ‘conditions’
[08:26:21.004]   - Field: ‘expr’
[08:26:21.004]   - Field: ‘uuid’
[08:26:21.004]   - Field: ‘seed’
[08:26:21.004]   - Field: ‘version’
[08:26:21.004]   - Field: ‘result’
[08:26:21.004]   - Field: ‘asynchronous’
[08:26:21.004]   - Field: ‘calls’
[08:26:21.004]   - Field: ‘globals’
[08:26:21.005]   - Field: ‘stdout’
[08:26:21.005]   - Field: ‘earlySignal’
[08:26:21.005]   - Field: ‘lazy’
[08:26:21.005]   - Field: ‘state’
[08:26:21.005] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:21.005] - Launch lazy future ...
[08:26:21.005] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[08:26:21.005] Packages needed by future strategies (n = 0): <none>
[08:26:21.006] {
[08:26:21.006]     {
[08:26:21.006]         {
[08:26:21.006]             ...future.startTime <- base::Sys.time()
[08:26:21.006]             {
[08:26:21.006]                 {
[08:26:21.006]                   {
[08:26:21.006]                     {
[08:26:21.006]                       {
[08:26:21.006]                         base::local({
[08:26:21.006]                           has_future <- base::requireNamespace("future", 
[08:26:21.006]                             quietly = TRUE)
[08:26:21.006]                           if (has_future) {
[08:26:21.006]                             ns <- base::getNamespace("future")
[08:26:21.006]                             version <- ns[[".package"]][["version"]]
[08:26:21.006]                             if (is.null(version)) 
[08:26:21.006]                               version <- utils::packageVersion("future")
[08:26:21.006]                           }
[08:26:21.006]                           else {
[08:26:21.006]                             version <- NULL
[08:26:21.006]                           }
[08:26:21.006]                           if (!has_future || version < "1.8.0") {
[08:26:21.006]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:21.006]                               "", base::R.version$version.string), 
[08:26:21.006]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:21.006]                                 base::R.version$platform, 8 * 
[08:26:21.006]                                   base::.Machine$sizeof.pointer), 
[08:26:21.006]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:21.006]                                 "release", "version")], collapse = " "), 
[08:26:21.006]                               hostname = base::Sys.info()[["nodename"]])
[08:26:21.006]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:21.006]                               info)
[08:26:21.006]                             info <- base::paste(info, collapse = "; ")
[08:26:21.006]                             if (!has_future) {
[08:26:21.006]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:21.006]                                 info)
[08:26:21.006]                             }
[08:26:21.006]                             else {
[08:26:21.006]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:21.006]                                 info, version)
[08:26:21.006]                             }
[08:26:21.006]                             base::stop(msg)
[08:26:21.006]                           }
[08:26:21.006]                         })
[08:26:21.006]                       }
[08:26:21.006]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:21.006]                       base::options(mc.cores = 1L)
[08:26:21.006]                     }
[08:26:21.006]                     base::local({
[08:26:21.006]                       for (pkg in c("stats", "future.apply")) {
[08:26:21.006]                         base::loadNamespace(pkg)
[08:26:21.006]                         base::library(pkg, character.only = TRUE)
[08:26:21.006]                       }
[08:26:21.006]                     })
[08:26:21.006]                   }
[08:26:21.006]                   ...future.strategy.old <- future::plan("list")
[08:26:21.006]                   options(future.plan = NULL)
[08:26:21.006]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.006]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:21.006]                 }
[08:26:21.006]                 ...future.workdir <- getwd()
[08:26:21.006]             }
[08:26:21.006]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:21.006]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:21.006]         }
[08:26:21.006]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:21.006]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:21.006]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:21.006]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:21.006]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:21.006]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:21.006]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:21.006]             base::names(...future.oldOptions))
[08:26:21.006]     }
[08:26:21.006]     if (FALSE) {
[08:26:21.006]     }
[08:26:21.006]     else {
[08:26:21.006]         if (TRUE) {
[08:26:21.006]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:21.006]                 open = "w")
[08:26:21.006]         }
[08:26:21.006]         else {
[08:26:21.006]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:21.006]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:21.006]         }
[08:26:21.006]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:21.006]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:21.006]             base::sink(type = "output", split = FALSE)
[08:26:21.006]             base::close(...future.stdout)
[08:26:21.006]         }, add = TRUE)
[08:26:21.006]     }
[08:26:21.006]     ...future.frame <- base::sys.nframe()
[08:26:21.006]     ...future.conditions <- base::list()
[08:26:21.006]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:21.006]     if (FALSE) {
[08:26:21.006]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:21.006]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:21.006]     }
[08:26:21.006]     ...future.result <- base::tryCatch({
[08:26:21.006]         base::withCallingHandlers({
[08:26:21.006]             ...future.value <- base::withVisible(base::local({
[08:26:21.006]                 withCallingHandlers({
[08:26:21.006]                   {
[08:26:21.006]                     do.call(function(...) {
[08:26:21.006]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.006]                       if (!identical(...future.globals.maxSize.org, 
[08:26:21.006]                         ...future.globals.maxSize)) {
[08:26:21.006]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.006]                         on.exit(options(oopts), add = TRUE)
[08:26:21.006]                       }
[08:26:21.006]                       {
[08:26:21.006]                         lapply(seq_along(...future.elements_ii), 
[08:26:21.006]                           FUN = function(jj) {
[08:26:21.006]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.006]                             ...future.FUN(...future.X_jj, ...)
[08:26:21.006]                           })
[08:26:21.006]                       }
[08:26:21.006]                     }, args = future.call.arguments)
[08:26:21.006]                   }
[08:26:21.006]                 }, immediateCondition = function(cond) {
[08:26:21.006]                   save_rds <- function (object, pathname, ...) 
[08:26:21.006]                   {
[08:26:21.006]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:21.006]                     if (file_test("-f", pathname_tmp)) {
[08:26:21.006]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.006]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:21.006]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.006]                         fi_tmp[["mtime"]])
[08:26:21.006]                     }
[08:26:21.006]                     tryCatch({
[08:26:21.006]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:21.006]                     }, error = function(ex) {
[08:26:21.006]                       msg <- conditionMessage(ex)
[08:26:21.006]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.006]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:21.006]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.006]                         fi_tmp[["mtime"]], msg)
[08:26:21.006]                       ex$message <- msg
[08:26:21.006]                       stop(ex)
[08:26:21.006]                     })
[08:26:21.006]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:21.006]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:21.006]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:21.006]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.006]                       fi <- file.info(pathname)
[08:26:21.006]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:21.006]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.006]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:21.006]                         fi[["size"]], fi[["mtime"]])
[08:26:21.006]                       stop(msg)
[08:26:21.006]                     }
[08:26:21.006]                     invisible(pathname)
[08:26:21.006]                   }
[08:26:21.006]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:21.006]                     rootPath = tempdir()) 
[08:26:21.006]                   {
[08:26:21.006]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:21.006]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:21.006]                       tmpdir = path, fileext = ".rds")
[08:26:21.006]                     save_rds(obj, file)
[08:26:21.006]                   }
[08:26:21.006]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:21.006]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.006]                   {
[08:26:21.006]                     inherits <- base::inherits
[08:26:21.006]                     invokeRestart <- base::invokeRestart
[08:26:21.006]                     is.null <- base::is.null
[08:26:21.006]                     muffled <- FALSE
[08:26:21.006]                     if (inherits(cond, "message")) {
[08:26:21.006]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:21.006]                       if (muffled) 
[08:26:21.006]                         invokeRestart("muffleMessage")
[08:26:21.006]                     }
[08:26:21.006]                     else if (inherits(cond, "warning")) {
[08:26:21.006]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:21.006]                       if (muffled) 
[08:26:21.006]                         invokeRestart("muffleWarning")
[08:26:21.006]                     }
[08:26:21.006]                     else if (inherits(cond, "condition")) {
[08:26:21.006]                       if (!is.null(pattern)) {
[08:26:21.006]                         computeRestarts <- base::computeRestarts
[08:26:21.006]                         grepl <- base::grepl
[08:26:21.006]                         restarts <- computeRestarts(cond)
[08:26:21.006]                         for (restart in restarts) {
[08:26:21.006]                           name <- restart$name
[08:26:21.006]                           if (is.null(name)) 
[08:26:21.006]                             next
[08:26:21.006]                           if (!grepl(pattern, name)) 
[08:26:21.006]                             next
[08:26:21.006]                           invokeRestart(restart)
[08:26:21.006]                           muffled <- TRUE
[08:26:21.006]                           break
[08:26:21.006]                         }
[08:26:21.006]                       }
[08:26:21.006]                     }
[08:26:21.006]                     invisible(muffled)
[08:26:21.006]                   }
[08:26:21.006]                   muffleCondition(cond)
[08:26:21.006]                 })
[08:26:21.006]             }))
[08:26:21.006]             future::FutureResult(value = ...future.value$value, 
[08:26:21.006]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.006]                   ...future.rng), globalenv = if (FALSE) 
[08:26:21.006]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:21.006]                     ...future.globalenv.names))
[08:26:21.006]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:21.006]         }, condition = base::local({
[08:26:21.006]             c <- base::c
[08:26:21.006]             inherits <- base::inherits
[08:26:21.006]             invokeRestart <- base::invokeRestart
[08:26:21.006]             length <- base::length
[08:26:21.006]             list <- base::list
[08:26:21.006]             seq.int <- base::seq.int
[08:26:21.006]             signalCondition <- base::signalCondition
[08:26:21.006]             sys.calls <- base::sys.calls
[08:26:21.006]             `[[` <- base::`[[`
[08:26:21.006]             `+` <- base::`+`
[08:26:21.006]             `<<-` <- base::`<<-`
[08:26:21.006]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:21.006]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:21.006]                   3L)]
[08:26:21.006]             }
[08:26:21.006]             function(cond) {
[08:26:21.006]                 is_error <- inherits(cond, "error")
[08:26:21.006]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:21.006]                   NULL)
[08:26:21.006]                 if (is_error) {
[08:26:21.006]                   sessionInformation <- function() {
[08:26:21.006]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:21.006]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:21.006]                       search = base::search(), system = base::Sys.info())
[08:26:21.006]                   }
[08:26:21.006]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.006]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:21.006]                     cond$call), session = sessionInformation(), 
[08:26:21.006]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:21.006]                   signalCondition(cond)
[08:26:21.006]                 }
[08:26:21.006]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:21.006]                 "immediateCondition"))) {
[08:26:21.006]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:21.006]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.006]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:21.006]                   if (TRUE && !signal) {
[08:26:21.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.006]                     {
[08:26:21.006]                       inherits <- base::inherits
[08:26:21.006]                       invokeRestart <- base::invokeRestart
[08:26:21.006]                       is.null <- base::is.null
[08:26:21.006]                       muffled <- FALSE
[08:26:21.006]                       if (inherits(cond, "message")) {
[08:26:21.006]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.006]                         if (muffled) 
[08:26:21.006]                           invokeRestart("muffleMessage")
[08:26:21.006]                       }
[08:26:21.006]                       else if (inherits(cond, "warning")) {
[08:26:21.006]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.006]                         if (muffled) 
[08:26:21.006]                           invokeRestart("muffleWarning")
[08:26:21.006]                       }
[08:26:21.006]                       else if (inherits(cond, "condition")) {
[08:26:21.006]                         if (!is.null(pattern)) {
[08:26:21.006]                           computeRestarts <- base::computeRestarts
[08:26:21.006]                           grepl <- base::grepl
[08:26:21.006]                           restarts <- computeRestarts(cond)
[08:26:21.006]                           for (restart in restarts) {
[08:26:21.006]                             name <- restart$name
[08:26:21.006]                             if (is.null(name)) 
[08:26:21.006]                               next
[08:26:21.006]                             if (!grepl(pattern, name)) 
[08:26:21.006]                               next
[08:26:21.006]                             invokeRestart(restart)
[08:26:21.006]                             muffled <- TRUE
[08:26:21.006]                             break
[08:26:21.006]                           }
[08:26:21.006]                         }
[08:26:21.006]                       }
[08:26:21.006]                       invisible(muffled)
[08:26:21.006]                     }
[08:26:21.006]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.006]                   }
[08:26:21.006]                 }
[08:26:21.006]                 else {
[08:26:21.006]                   if (TRUE) {
[08:26:21.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.006]                     {
[08:26:21.006]                       inherits <- base::inherits
[08:26:21.006]                       invokeRestart <- base::invokeRestart
[08:26:21.006]                       is.null <- base::is.null
[08:26:21.006]                       muffled <- FALSE
[08:26:21.006]                       if (inherits(cond, "message")) {
[08:26:21.006]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.006]                         if (muffled) 
[08:26:21.006]                           invokeRestart("muffleMessage")
[08:26:21.006]                       }
[08:26:21.006]                       else if (inherits(cond, "warning")) {
[08:26:21.006]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.006]                         if (muffled) 
[08:26:21.006]                           invokeRestart("muffleWarning")
[08:26:21.006]                       }
[08:26:21.006]                       else if (inherits(cond, "condition")) {
[08:26:21.006]                         if (!is.null(pattern)) {
[08:26:21.006]                           computeRestarts <- base::computeRestarts
[08:26:21.006]                           grepl <- base::grepl
[08:26:21.006]                           restarts <- computeRestarts(cond)
[08:26:21.006]                           for (restart in restarts) {
[08:26:21.006]                             name <- restart$name
[08:26:21.006]                             if (is.null(name)) 
[08:26:21.006]                               next
[08:26:21.006]                             if (!grepl(pattern, name)) 
[08:26:21.006]                               next
[08:26:21.006]                             invokeRestart(restart)
[08:26:21.006]                             muffled <- TRUE
[08:26:21.006]                             break
[08:26:21.006]                           }
[08:26:21.006]                         }
[08:26:21.006]                       }
[08:26:21.006]                       invisible(muffled)
[08:26:21.006]                     }
[08:26:21.006]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.006]                   }
[08:26:21.006]                 }
[08:26:21.006]             }
[08:26:21.006]         }))
[08:26:21.006]     }, error = function(ex) {
[08:26:21.006]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:21.006]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.006]                 ...future.rng), started = ...future.startTime, 
[08:26:21.006]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:21.006]             version = "1.8"), class = "FutureResult")
[08:26:21.006]     }, finally = {
[08:26:21.006]         if (!identical(...future.workdir, getwd())) 
[08:26:21.006]             setwd(...future.workdir)
[08:26:21.006]         {
[08:26:21.006]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:21.006]                 ...future.oldOptions$nwarnings <- NULL
[08:26:21.006]             }
[08:26:21.006]             base::options(...future.oldOptions)
[08:26:21.006]             if (.Platform$OS.type == "windows") {
[08:26:21.006]                 old_names <- names(...future.oldEnvVars)
[08:26:21.006]                 envs <- base::Sys.getenv()
[08:26:21.006]                 names <- names(envs)
[08:26:21.006]                 common <- intersect(names, old_names)
[08:26:21.006]                 added <- setdiff(names, old_names)
[08:26:21.006]                 removed <- setdiff(old_names, names)
[08:26:21.006]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:21.006]                   envs[common]]
[08:26:21.006]                 NAMES <- toupper(changed)
[08:26:21.006]                 args <- list()
[08:26:21.006]                 for (kk in seq_along(NAMES)) {
[08:26:21.006]                   name <- changed[[kk]]
[08:26:21.006]                   NAME <- NAMES[[kk]]
[08:26:21.006]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.006]                     next
[08:26:21.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.006]                 }
[08:26:21.006]                 NAMES <- toupper(added)
[08:26:21.006]                 for (kk in seq_along(NAMES)) {
[08:26:21.006]                   name <- added[[kk]]
[08:26:21.006]                   NAME <- NAMES[[kk]]
[08:26:21.006]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.006]                     next
[08:26:21.006]                   args[[name]] <- ""
[08:26:21.006]                 }
[08:26:21.006]                 NAMES <- toupper(removed)
[08:26:21.006]                 for (kk in seq_along(NAMES)) {
[08:26:21.006]                   name <- removed[[kk]]
[08:26:21.006]                   NAME <- NAMES[[kk]]
[08:26:21.006]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.006]                     next
[08:26:21.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.006]                 }
[08:26:21.006]                 if (length(args) > 0) 
[08:26:21.006]                   base::do.call(base::Sys.setenv, args = args)
[08:26:21.006]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:21.006]             }
[08:26:21.006]             else {
[08:26:21.006]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:21.006]             }
[08:26:21.006]             {
[08:26:21.006]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:21.006]                   0L) {
[08:26:21.006]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:21.006]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:21.006]                   base::options(opts)
[08:26:21.006]                 }
[08:26:21.006]                 {
[08:26:21.006]                   {
[08:26:21.006]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:21.006]                     NULL
[08:26:21.006]                   }
[08:26:21.006]                   options(future.plan = NULL)
[08:26:21.006]                   if (is.na(NA_character_)) 
[08:26:21.006]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.006]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:21.006]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:21.006]                     .init = FALSE)
[08:26:21.006]                 }
[08:26:21.006]             }
[08:26:21.006]         }
[08:26:21.006]     })
[08:26:21.006]     if (TRUE) {
[08:26:21.006]         base::sink(type = "output", split = FALSE)
[08:26:21.006]         if (TRUE) {
[08:26:21.006]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:21.006]         }
[08:26:21.006]         else {
[08:26:21.006]             ...future.result["stdout"] <- base::list(NULL)
[08:26:21.006]         }
[08:26:21.006]         base::close(...future.stdout)
[08:26:21.006]         ...future.stdout <- NULL
[08:26:21.006]     }
[08:26:21.006]     ...future.result$conditions <- ...future.conditions
[08:26:21.006]     ...future.result$finished <- base::Sys.time()
[08:26:21.006]     ...future.result
[08:26:21.006] }
[08:26:21.009] assign_globals() ...
[08:26:21.009] List of 11
[08:26:21.009]  $ ...future.FUN            :function (x, ...)  
[08:26:21.009]  $ x_FUN                    :function (x, na.rm = TRUE)  
[08:26:21.009]  $ times                    : int 5
[08:26:21.009]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:21.009]  $ stop_if_not              :function (...)  
[08:26:21.009]  $ dim                      : NULL
[08:26:21.009]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:21.009]  $ future.call.arguments    : list()
[08:26:21.009]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:21.009]  $ ...future.elements_ii    :List of 4
[08:26:21.009]   ..$ : int [1:3] 1 2 3
[08:26:21.009]   ..$ : int [1:4] 1 2 3 4
[08:26:21.009]   ..$ : int [1:5] 1 2 3 4 5
[08:26:21.009]   ..$ : int [1:6] 1 2 3 4 5 6
[08:26:21.009]  $ ...future.seeds_ii       : NULL
[08:26:21.009]  $ ...future.globals.maxSize: NULL
[08:26:21.009]  - attr(*, "where")=List of 11
[08:26:21.009]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:21.009]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:21.009]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:21.009]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:21.009]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:21.009]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:21.009]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:21.009]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:21.009]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:21.009]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:21.009]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:21.009]  - attr(*, "resolved")= logi FALSE
[08:26:21.009]  - attr(*, "total_size")= num 48005
[08:26:21.009]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:21.009]  - attr(*, "already-done")= logi TRUE
[08:26:21.017] - copied ‘...future.FUN’ to environment
[08:26:21.017] - copied ‘x_FUN’ to environment
[08:26:21.017] - copied ‘times’ to environment
[08:26:21.018] - copied ‘stopf’ to environment
[08:26:21.018] - copied ‘stop_if_not’ to environment
[08:26:21.018] - copied ‘dim’ to environment
[08:26:21.018] - copied ‘valid_types’ to environment
[08:26:21.018] - copied ‘future.call.arguments’ to environment
[08:26:21.018] - copied ‘...future.elements_ii’ to environment
[08:26:21.018] - copied ‘...future.seeds_ii’ to environment
[08:26:21.018] - copied ‘...future.globals.maxSize’ to environment
[08:26:21.018] assign_globals() ... done
[08:26:21.018] requestCore(): workers = 2
[08:26:21.021] MulticoreFuture started
[08:26:21.021] - Launch lazy future ... done
[08:26:21.021] run() for ‘MulticoreFuture’ ... done
[08:26:21.022] Created future:
[08:26:21.022] plan(): Setting new future strategy stack:
[08:26:21.026] List of future strategies:
[08:26:21.026] 1. sequential:
[08:26:21.026]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:21.026]    - tweaked: FALSE
[08:26:21.026]    - call: NULL
[08:26:21.028] plan(): nbrOfWorkers() = 1
[08:26:21.031] plan(): Setting new future strategy stack:
[08:26:21.032] List of future strategies:
[08:26:21.032] 1. multicore:
[08:26:21.032]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:21.032]    - tweaked: FALSE
[08:26:21.032]    - call: plan(strategy)
[08:26:21.036] plan(): nbrOfWorkers() = 2
[08:26:21.022] MulticoreFuture:
[08:26:21.022] Label: ‘future_vapply-1’
[08:26:21.022] Expression:
[08:26:21.022] {
[08:26:21.022]     do.call(function(...) {
[08:26:21.022]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.022]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.022]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.022]             on.exit(options(oopts), add = TRUE)
[08:26:21.022]         }
[08:26:21.022]         {
[08:26:21.022]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.022]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.022]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.022]             })
[08:26:21.022]         }
[08:26:21.022]     }, args = future.call.arguments)
[08:26:21.022] }
[08:26:21.022] Lazy evaluation: FALSE
[08:26:21.022] Asynchronous evaluation: TRUE
[08:26:21.022] Local evaluation: TRUE
[08:26:21.022] Environment: R_GlobalEnv
[08:26:21.022] Capture standard output: TRUE
[08:26:21.022] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:21.022] Globals: 11 objects totaling 27.22 KiB (function ‘...future.FUN’ of 14.07 KiB, function ‘x_FUN’ of 4.67 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:21.022] Packages: 2 packages (‘stats’, ‘future.apply’)
[08:26:21.022] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:21.022] Resolved: TRUE
[08:26:21.022] Value: <not collected>
[08:26:21.022] Conditions captured: <none>
[08:26:21.022] Early signaling: FALSE
[08:26:21.022] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:21.022] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.037] Chunk #1 of 2 ... DONE
[08:26:21.038] Chunk #2 of 2 ...
[08:26:21.038]  - Finding globals in 'X' for chunk #2 ...
[08:26:21.038] getGlobalsAndPackages() ...
[08:26:21.039] Searching for globals...
[08:26:21.039] 
[08:26:21.039] Searching for globals ... DONE
[08:26:21.040] - globals: [0] <none>
[08:26:21.040] getGlobalsAndPackages() ... DONE
[08:26:21.040]    + additional globals found: [n=0] 
[08:26:21.040]    + additional namespaces needed: [n=0] 
[08:26:21.040]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:21.040]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:21.041]  - seeds: <none>
[08:26:21.041]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.041] getGlobalsAndPackages() ...
[08:26:21.041] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.042] Resolving globals: FALSE
[08:26:21.042] Tweak future expression to call with '...' arguments ...
[08:26:21.042] {
[08:26:21.042]     do.call(function(...) {
[08:26:21.042]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.042]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.042]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.042]             on.exit(options(oopts), add = TRUE)
[08:26:21.042]         }
[08:26:21.042]         {
[08:26:21.042]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.042]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.042]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.042]             })
[08:26:21.042]         }
[08:26:21.042]     }, args = future.call.arguments)
[08:26:21.042] }
[08:26:21.043] Tweak future expression to call with '...' arguments ... DONE
[08:26:21.044] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.044] - packages: [2] ‘stats’, ‘future.apply’
[08:26:21.044] getGlobalsAndPackages() ... DONE
[08:26:21.045] run() for ‘Future’ ...
[08:26:21.045] - state: ‘created’
[08:26:21.046] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:21.049] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.049] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:21.049]   - Field: ‘label’
[08:26:21.050]   - Field: ‘local’
[08:26:21.050]   - Field: ‘owner’
[08:26:21.050]   - Field: ‘envir’
[08:26:21.050]   - Field: ‘workers’
[08:26:21.050]   - Field: ‘packages’
[08:26:21.050]   - Field: ‘gc’
[08:26:21.050]   - Field: ‘job’
[08:26:21.050]   - Field: ‘conditions’
[08:26:21.051]   - Field: ‘expr’
[08:26:21.051]   - Field: ‘uuid’
[08:26:21.051]   - Field: ‘seed’
[08:26:21.051]   - Field: ‘version’
[08:26:21.051]   - Field: ‘result’
[08:26:21.051]   - Field: ‘asynchronous’
[08:26:21.051]   - Field: ‘calls’
[08:26:21.052]   - Field: ‘globals’
[08:26:21.052]   - Field: ‘stdout’
[08:26:21.052]   - Field: ‘earlySignal’
[08:26:21.052]   - Field: ‘lazy’
[08:26:21.052]   - Field: ‘state’
[08:26:21.052] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:21.052] - Launch lazy future ...
[08:26:21.053] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[08:26:21.053] Packages needed by future strategies (n = 0): <none>
[08:26:21.054] {
[08:26:21.054]     {
[08:26:21.054]         {
[08:26:21.054]             ...future.startTime <- base::Sys.time()
[08:26:21.054]             {
[08:26:21.054]                 {
[08:26:21.054]                   {
[08:26:21.054]                     {
[08:26:21.054]                       {
[08:26:21.054]                         base::local({
[08:26:21.054]                           has_future <- base::requireNamespace("future", 
[08:26:21.054]                             quietly = TRUE)
[08:26:21.054]                           if (has_future) {
[08:26:21.054]                             ns <- base::getNamespace("future")
[08:26:21.054]                             version <- ns[[".package"]][["version"]]
[08:26:21.054]                             if (is.null(version)) 
[08:26:21.054]                               version <- utils::packageVersion("future")
[08:26:21.054]                           }
[08:26:21.054]                           else {
[08:26:21.054]                             version <- NULL
[08:26:21.054]                           }
[08:26:21.054]                           if (!has_future || version < "1.8.0") {
[08:26:21.054]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:21.054]                               "", base::R.version$version.string), 
[08:26:21.054]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:21.054]                                 base::R.version$platform, 8 * 
[08:26:21.054]                                   base::.Machine$sizeof.pointer), 
[08:26:21.054]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:21.054]                                 "release", "version")], collapse = " "), 
[08:26:21.054]                               hostname = base::Sys.info()[["nodename"]])
[08:26:21.054]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:21.054]                               info)
[08:26:21.054]                             info <- base::paste(info, collapse = "; ")
[08:26:21.054]                             if (!has_future) {
[08:26:21.054]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:21.054]                                 info)
[08:26:21.054]                             }
[08:26:21.054]                             else {
[08:26:21.054]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:21.054]                                 info, version)
[08:26:21.054]                             }
[08:26:21.054]                             base::stop(msg)
[08:26:21.054]                           }
[08:26:21.054]                         })
[08:26:21.054]                       }
[08:26:21.054]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:21.054]                       base::options(mc.cores = 1L)
[08:26:21.054]                     }
[08:26:21.054]                     base::local({
[08:26:21.054]                       for (pkg in c("stats", "future.apply")) {
[08:26:21.054]                         base::loadNamespace(pkg)
[08:26:21.054]                         base::library(pkg, character.only = TRUE)
[08:26:21.054]                       }
[08:26:21.054]                     })
[08:26:21.054]                   }
[08:26:21.054]                   ...future.strategy.old <- future::plan("list")
[08:26:21.054]                   options(future.plan = NULL)
[08:26:21.054]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.054]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:21.054]                 }
[08:26:21.054]                 ...future.workdir <- getwd()
[08:26:21.054]             }
[08:26:21.054]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:21.054]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:21.054]         }
[08:26:21.054]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:21.054]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:21.054]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:21.054]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:21.054]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:21.054]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:21.054]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:21.054]             base::names(...future.oldOptions))
[08:26:21.054]     }
[08:26:21.054]     if (FALSE) {
[08:26:21.054]     }
[08:26:21.054]     else {
[08:26:21.054]         if (TRUE) {
[08:26:21.054]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:21.054]                 open = "w")
[08:26:21.054]         }
[08:26:21.054]         else {
[08:26:21.054]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:21.054]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:21.054]         }
[08:26:21.054]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:21.054]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:21.054]             base::sink(type = "output", split = FALSE)
[08:26:21.054]             base::close(...future.stdout)
[08:26:21.054]         }, add = TRUE)
[08:26:21.054]     }
[08:26:21.054]     ...future.frame <- base::sys.nframe()
[08:26:21.054]     ...future.conditions <- base::list()
[08:26:21.054]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:21.054]     if (FALSE) {
[08:26:21.054]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:21.054]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:21.054]     }
[08:26:21.054]     ...future.result <- base::tryCatch({
[08:26:21.054]         base::withCallingHandlers({
[08:26:21.054]             ...future.value <- base::withVisible(base::local({
[08:26:21.054]                 withCallingHandlers({
[08:26:21.054]                   {
[08:26:21.054]                     do.call(function(...) {
[08:26:21.054]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.054]                       if (!identical(...future.globals.maxSize.org, 
[08:26:21.054]                         ...future.globals.maxSize)) {
[08:26:21.054]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.054]                         on.exit(options(oopts), add = TRUE)
[08:26:21.054]                       }
[08:26:21.054]                       {
[08:26:21.054]                         lapply(seq_along(...future.elements_ii), 
[08:26:21.054]                           FUN = function(jj) {
[08:26:21.054]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.054]                             ...future.FUN(...future.X_jj, ...)
[08:26:21.054]                           })
[08:26:21.054]                       }
[08:26:21.054]                     }, args = future.call.arguments)
[08:26:21.054]                   }
[08:26:21.054]                 }, immediateCondition = function(cond) {
[08:26:21.054]                   save_rds <- function (object, pathname, ...) 
[08:26:21.054]                   {
[08:26:21.054]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:21.054]                     if (file_test("-f", pathname_tmp)) {
[08:26:21.054]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.054]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:21.054]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.054]                         fi_tmp[["mtime"]])
[08:26:21.054]                     }
[08:26:21.054]                     tryCatch({
[08:26:21.054]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:21.054]                     }, error = function(ex) {
[08:26:21.054]                       msg <- conditionMessage(ex)
[08:26:21.054]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.054]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:21.054]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.054]                         fi_tmp[["mtime"]], msg)
[08:26:21.054]                       ex$message <- msg
[08:26:21.054]                       stop(ex)
[08:26:21.054]                     })
[08:26:21.054]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:21.054]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:21.054]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:21.054]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.054]                       fi <- file.info(pathname)
[08:26:21.054]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:21.054]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.054]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:21.054]                         fi[["size"]], fi[["mtime"]])
[08:26:21.054]                       stop(msg)
[08:26:21.054]                     }
[08:26:21.054]                     invisible(pathname)
[08:26:21.054]                   }
[08:26:21.054]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:21.054]                     rootPath = tempdir()) 
[08:26:21.054]                   {
[08:26:21.054]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:21.054]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:21.054]                       tmpdir = path, fileext = ".rds")
[08:26:21.054]                     save_rds(obj, file)
[08:26:21.054]                   }
[08:26:21.054]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:21.054]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.054]                   {
[08:26:21.054]                     inherits <- base::inherits
[08:26:21.054]                     invokeRestart <- base::invokeRestart
[08:26:21.054]                     is.null <- base::is.null
[08:26:21.054]                     muffled <- FALSE
[08:26:21.054]                     if (inherits(cond, "message")) {
[08:26:21.054]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:21.054]                       if (muffled) 
[08:26:21.054]                         invokeRestart("muffleMessage")
[08:26:21.054]                     }
[08:26:21.054]                     else if (inherits(cond, "warning")) {
[08:26:21.054]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:21.054]                       if (muffled) 
[08:26:21.054]                         invokeRestart("muffleWarning")
[08:26:21.054]                     }
[08:26:21.054]                     else if (inherits(cond, "condition")) {
[08:26:21.054]                       if (!is.null(pattern)) {
[08:26:21.054]                         computeRestarts <- base::computeRestarts
[08:26:21.054]                         grepl <- base::grepl
[08:26:21.054]                         restarts <- computeRestarts(cond)
[08:26:21.054]                         for (restart in restarts) {
[08:26:21.054]                           name <- restart$name
[08:26:21.054]                           if (is.null(name)) 
[08:26:21.054]                             next
[08:26:21.054]                           if (!grepl(pattern, name)) 
[08:26:21.054]                             next
[08:26:21.054]                           invokeRestart(restart)
[08:26:21.054]                           muffled <- TRUE
[08:26:21.054]                           break
[08:26:21.054]                         }
[08:26:21.054]                       }
[08:26:21.054]                     }
[08:26:21.054]                     invisible(muffled)
[08:26:21.054]                   }
[08:26:21.054]                   muffleCondition(cond)
[08:26:21.054]                 })
[08:26:21.054]             }))
[08:26:21.054]             future::FutureResult(value = ...future.value$value, 
[08:26:21.054]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.054]                   ...future.rng), globalenv = if (FALSE) 
[08:26:21.054]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:21.054]                     ...future.globalenv.names))
[08:26:21.054]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:21.054]         }, condition = base::local({
[08:26:21.054]             c <- base::c
[08:26:21.054]             inherits <- base::inherits
[08:26:21.054]             invokeRestart <- base::invokeRestart
[08:26:21.054]             length <- base::length
[08:26:21.054]             list <- base::list
[08:26:21.054]             seq.int <- base::seq.int
[08:26:21.054]             signalCondition <- base::signalCondition
[08:26:21.054]             sys.calls <- base::sys.calls
[08:26:21.054]             `[[` <- base::`[[`
[08:26:21.054]             `+` <- base::`+`
[08:26:21.054]             `<<-` <- base::`<<-`
[08:26:21.054]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:21.054]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:21.054]                   3L)]
[08:26:21.054]             }
[08:26:21.054]             function(cond) {
[08:26:21.054]                 is_error <- inherits(cond, "error")
[08:26:21.054]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:21.054]                   NULL)
[08:26:21.054]                 if (is_error) {
[08:26:21.054]                   sessionInformation <- function() {
[08:26:21.054]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:21.054]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:21.054]                       search = base::search(), system = base::Sys.info())
[08:26:21.054]                   }
[08:26:21.054]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.054]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:21.054]                     cond$call), session = sessionInformation(), 
[08:26:21.054]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:21.054]                   signalCondition(cond)
[08:26:21.054]                 }
[08:26:21.054]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:21.054]                 "immediateCondition"))) {
[08:26:21.054]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:21.054]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.054]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:21.054]                   if (TRUE && !signal) {
[08:26:21.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.054]                     {
[08:26:21.054]                       inherits <- base::inherits
[08:26:21.054]                       invokeRestart <- base::invokeRestart
[08:26:21.054]                       is.null <- base::is.null
[08:26:21.054]                       muffled <- FALSE
[08:26:21.054]                       if (inherits(cond, "message")) {
[08:26:21.054]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.054]                         if (muffled) 
[08:26:21.054]                           invokeRestart("muffleMessage")
[08:26:21.054]                       }
[08:26:21.054]                       else if (inherits(cond, "warning")) {
[08:26:21.054]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.054]                         if (muffled) 
[08:26:21.054]                           invokeRestart("muffleWarning")
[08:26:21.054]                       }
[08:26:21.054]                       else if (inherits(cond, "condition")) {
[08:26:21.054]                         if (!is.null(pattern)) {
[08:26:21.054]                           computeRestarts <- base::computeRestarts
[08:26:21.054]                           grepl <- base::grepl
[08:26:21.054]                           restarts <- computeRestarts(cond)
[08:26:21.054]                           for (restart in restarts) {
[08:26:21.054]                             name <- restart$name
[08:26:21.054]                             if (is.null(name)) 
[08:26:21.054]                               next
[08:26:21.054]                             if (!grepl(pattern, name)) 
[08:26:21.054]                               next
[08:26:21.054]                             invokeRestart(restart)
[08:26:21.054]                             muffled <- TRUE
[08:26:21.054]                             break
[08:26:21.054]                           }
[08:26:21.054]                         }
[08:26:21.054]                       }
[08:26:21.054]                       invisible(muffled)
[08:26:21.054]                     }
[08:26:21.054]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.054]                   }
[08:26:21.054]                 }
[08:26:21.054]                 else {
[08:26:21.054]                   if (TRUE) {
[08:26:21.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.054]                     {
[08:26:21.054]                       inherits <- base::inherits
[08:26:21.054]                       invokeRestart <- base::invokeRestart
[08:26:21.054]                       is.null <- base::is.null
[08:26:21.054]                       muffled <- FALSE
[08:26:21.054]                       if (inherits(cond, "message")) {
[08:26:21.054]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.054]                         if (muffled) 
[08:26:21.054]                           invokeRestart("muffleMessage")
[08:26:21.054]                       }
[08:26:21.054]                       else if (inherits(cond, "warning")) {
[08:26:21.054]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.054]                         if (muffled) 
[08:26:21.054]                           invokeRestart("muffleWarning")
[08:26:21.054]                       }
[08:26:21.054]                       else if (inherits(cond, "condition")) {
[08:26:21.054]                         if (!is.null(pattern)) {
[08:26:21.054]                           computeRestarts <- base::computeRestarts
[08:26:21.054]                           grepl <- base::grepl
[08:26:21.054]                           restarts <- computeRestarts(cond)
[08:26:21.054]                           for (restart in restarts) {
[08:26:21.054]                             name <- restart$name
[08:26:21.054]                             if (is.null(name)) 
[08:26:21.054]                               next
[08:26:21.054]                             if (!grepl(pattern, name)) 
[08:26:21.054]                               next
[08:26:21.054]                             invokeRestart(restart)
[08:26:21.054]                             muffled <- TRUE
[08:26:21.054]                             break
[08:26:21.054]                           }
[08:26:21.054]                         }
[08:26:21.054]                       }
[08:26:21.054]                       invisible(muffled)
[08:26:21.054]                     }
[08:26:21.054]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.054]                   }
[08:26:21.054]                 }
[08:26:21.054]             }
[08:26:21.054]         }))
[08:26:21.054]     }, error = function(ex) {
[08:26:21.054]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:21.054]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.054]                 ...future.rng), started = ...future.startTime, 
[08:26:21.054]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:21.054]             version = "1.8"), class = "FutureResult")
[08:26:21.054]     }, finally = {
[08:26:21.054]         if (!identical(...future.workdir, getwd())) 
[08:26:21.054]             setwd(...future.workdir)
[08:26:21.054]         {
[08:26:21.054]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:21.054]                 ...future.oldOptions$nwarnings <- NULL
[08:26:21.054]             }
[08:26:21.054]             base::options(...future.oldOptions)
[08:26:21.054]             if (.Platform$OS.type == "windows") {
[08:26:21.054]                 old_names <- names(...future.oldEnvVars)
[08:26:21.054]                 envs <- base::Sys.getenv()
[08:26:21.054]                 names <- names(envs)
[08:26:21.054]                 common <- intersect(names, old_names)
[08:26:21.054]                 added <- setdiff(names, old_names)
[08:26:21.054]                 removed <- setdiff(old_names, names)
[08:26:21.054]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:21.054]                   envs[common]]
[08:26:21.054]                 NAMES <- toupper(changed)
[08:26:21.054]                 args <- list()
[08:26:21.054]                 for (kk in seq_along(NAMES)) {
[08:26:21.054]                   name <- changed[[kk]]
[08:26:21.054]                   NAME <- NAMES[[kk]]
[08:26:21.054]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.054]                     next
[08:26:21.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.054]                 }
[08:26:21.054]                 NAMES <- toupper(added)
[08:26:21.054]                 for (kk in seq_along(NAMES)) {
[08:26:21.054]                   name <- added[[kk]]
[08:26:21.054]                   NAME <- NAMES[[kk]]
[08:26:21.054]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.054]                     next
[08:26:21.054]                   args[[name]] <- ""
[08:26:21.054]                 }
[08:26:21.054]                 NAMES <- toupper(removed)
[08:26:21.054]                 for (kk in seq_along(NAMES)) {
[08:26:21.054]                   name <- removed[[kk]]
[08:26:21.054]                   NAME <- NAMES[[kk]]
[08:26:21.054]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.054]                     next
[08:26:21.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.054]                 }
[08:26:21.054]                 if (length(args) > 0) 
[08:26:21.054]                   base::do.call(base::Sys.setenv, args = args)
[08:26:21.054]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:21.054]             }
[08:26:21.054]             else {
[08:26:21.054]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:21.054]             }
[08:26:21.054]             {
[08:26:21.054]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:21.054]                   0L) {
[08:26:21.054]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:21.054]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:21.054]                   base::options(opts)
[08:26:21.054]                 }
[08:26:21.054]                 {
[08:26:21.054]                   {
[08:26:21.054]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:21.054]                     NULL
[08:26:21.054]                   }
[08:26:21.054]                   options(future.plan = NULL)
[08:26:21.054]                   if (is.na(NA_character_)) 
[08:26:21.054]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.054]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:21.054]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:21.054]                     .init = FALSE)
[08:26:21.054]                 }
[08:26:21.054]             }
[08:26:21.054]         }
[08:26:21.054]     })
[08:26:21.054]     if (TRUE) {
[08:26:21.054]         base::sink(type = "output", split = FALSE)
[08:26:21.054]         if (TRUE) {
[08:26:21.054]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:21.054]         }
[08:26:21.054]         else {
[08:26:21.054]             ...future.result["stdout"] <- base::list(NULL)
[08:26:21.054]         }
[08:26:21.054]         base::close(...future.stdout)
[08:26:21.054]         ...future.stdout <- NULL
[08:26:21.054]     }
[08:26:21.054]     ...future.result$conditions <- ...future.conditions
[08:26:21.054]     ...future.result$finished <- base::Sys.time()
[08:26:21.054]     ...future.result
[08:26:21.054] }
[08:26:21.057] assign_globals() ...
[08:26:21.057] List of 11
[08:26:21.057]  $ ...future.FUN            :function (x, ...)  
[08:26:21.057]  $ x_FUN                    :function (x, na.rm = TRUE)  
[08:26:21.057]  $ times                    : int 5
[08:26:21.057]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:21.057]  $ stop_if_not              :function (...)  
[08:26:21.057]  $ dim                      : NULL
[08:26:21.057]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:21.057]  $ future.call.arguments    : list()
[08:26:21.057]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:21.057]  $ ...future.elements_ii    :List of 3
[08:26:21.057]   ..$ : int [1:7] 1 2 3 4 5 6 7
[08:26:21.057]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[08:26:21.057]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[08:26:21.057]  $ ...future.seeds_ii       : NULL
[08:26:21.057]  $ ...future.globals.maxSize: NULL
[08:26:21.057]  - attr(*, "where")=List of 11
[08:26:21.057]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:21.057]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:21.057]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:21.057]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:21.057]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:21.057]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:21.057]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:21.057]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:21.057]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:21.057]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:21.057]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:21.057]  - attr(*, "resolved")= logi FALSE
[08:26:21.057]  - attr(*, "total_size")= num 48005
[08:26:21.057]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:21.057]  - attr(*, "already-done")= logi TRUE
[08:26:21.067] - copied ‘...future.FUN’ to environment
[08:26:21.067] - copied ‘x_FUN’ to environment
[08:26:21.067] - copied ‘times’ to environment
[08:26:21.067] - copied ‘stopf’ to environment
[08:26:21.069] - copied ‘stop_if_not’ to environment
[08:26:21.070] - copied ‘dim’ to environment
[08:26:21.070] - copied ‘valid_types’ to environment
[08:26:21.070] - copied ‘future.call.arguments’ to environment
[08:26:21.070] - copied ‘...future.elements_ii’ to environment
[08:26:21.070] - copied ‘...future.seeds_ii’ to environment
[08:26:21.070] - copied ‘...future.globals.maxSize’ to environment
[08:26:21.070] assign_globals() ... done
[08:26:21.071] requestCore(): workers = 2
[08:26:21.073] MulticoreFuture started
[08:26:21.074] - Launch lazy future ... done
[08:26:21.074] run() for ‘MulticoreFuture’ ... done
[08:26:21.075] Created future:
[08:26:21.076] plan(): Setting new future strategy stack:
[08:26:21.076] List of future strategies:
[08:26:21.076] 1. sequential:
[08:26:21.076]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:21.076]    - tweaked: FALSE
[08:26:21.076]    - call: NULL
[08:26:21.078] plan(): nbrOfWorkers() = 1
[08:26:21.082] plan(): Setting new future strategy stack:
[08:26:21.082] List of future strategies:
[08:26:21.082] 1. multicore:
[08:26:21.082]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:21.082]    - tweaked: FALSE
[08:26:21.082]    - call: plan(strategy)
[08:26:21.086] plan(): nbrOfWorkers() = 2
[08:26:21.075] MulticoreFuture:
[08:26:21.075] Label: ‘future_vapply-2’
[08:26:21.075] Expression:
[08:26:21.075] {
[08:26:21.075]     do.call(function(...) {
[08:26:21.075]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.075]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.075]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.075]             on.exit(options(oopts), add = TRUE)
[08:26:21.075]         }
[08:26:21.075]         {
[08:26:21.075]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.075]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.075]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.075]             })
[08:26:21.075]         }
[08:26:21.075]     }, args = future.call.arguments)
[08:26:21.075] }
[08:26:21.075] Lazy evaluation: FALSE
[08:26:21.075] Asynchronous evaluation: TRUE
[08:26:21.075] Local evaluation: TRUE
[08:26:21.075] Environment: R_GlobalEnv
[08:26:21.075] Capture standard output: TRUE
[08:26:21.075] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:21.075] Globals: 11 objects totaling 27.14 KiB (function ‘...future.FUN’ of 14.07 KiB, function ‘x_FUN’ of 4.67 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:21.075] Packages: 2 packages (‘stats’, ‘future.apply’)
[08:26:21.075] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:21.075] Resolved: TRUE
[08:26:21.075] Value: <not collected>
[08:26:21.075] Conditions captured: <none>
[08:26:21.075] Early signaling: FALSE
[08:26:21.075] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:21.075] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.088] Chunk #2 of 2 ... DONE
[08:26:21.088] Launching 2 futures (chunks) ... DONE
[08:26:21.088] Resolving 2 futures (chunks) ...
[08:26:21.089] resolve() on list ...
[08:26:21.089]  recursive: 0
[08:26:21.089]  length: 2
[08:26:21.089] 
[08:26:21.089] Future #1
[08:26:21.090] result() for MulticoreFuture ...
[08:26:21.091] result() for MulticoreFuture ...
[08:26:21.091] result() for MulticoreFuture ... done
[08:26:21.091] result() for MulticoreFuture ... done
[08:26:21.091] result() for MulticoreFuture ...
[08:26:21.092] result() for MulticoreFuture ... done
[08:26:21.092] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:26:21.092] - nx: 2
[08:26:21.092] - relay: TRUE
[08:26:21.093] - stdout: TRUE
[08:26:21.093] - signal: TRUE
[08:26:21.093] - resignal: FALSE
[08:26:21.093] - force: TRUE
[08:26:21.093] - relayed: [n=2] FALSE, FALSE
[08:26:21.094] - queued futures: [n=2] FALSE, FALSE
[08:26:21.094]  - until=1
[08:26:21.094]  - relaying element #1
[08:26:21.094] result() for MulticoreFuture ...
[08:26:21.094] result() for MulticoreFuture ... done
[08:26:21.095] result() for MulticoreFuture ...
[08:26:21.095] result() for MulticoreFuture ... done
[08:26:21.095] result() for MulticoreFuture ...
[08:26:21.095] result() for MulticoreFuture ... done
[08:26:21.095] result() for MulticoreFuture ...
[08:26:21.095] result() for MulticoreFuture ... done
[08:26:21.095] - relayed: [n=2] TRUE, FALSE
[08:26:21.096] - queued futures: [n=2] TRUE, FALSE
[08:26:21.096] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:26:21.096]  length: 1 (resolved future 1)
[08:26:21.096] Future #2
[08:26:21.096] result() for MulticoreFuture ...
[08:26:21.097] result() for MulticoreFuture ...
[08:26:21.097] result() for MulticoreFuture ... done
[08:26:21.097] result() for MulticoreFuture ... done
[08:26:21.098] result() for MulticoreFuture ...
[08:26:21.098] result() for MulticoreFuture ... done
[08:26:21.098] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:26:21.098] - nx: 2
[08:26:21.098] - relay: TRUE
[08:26:21.098] - stdout: TRUE
[08:26:21.098] - signal: TRUE
[08:26:21.098] - resignal: FALSE
[08:26:21.099] - force: TRUE
[08:26:21.099] - relayed: [n=2] TRUE, FALSE
[08:26:21.099] - queued futures: [n=2] TRUE, FALSE
[08:26:21.099]  - until=2
[08:26:21.099]  - relaying element #2
[08:26:21.099] result() for MulticoreFuture ...
[08:26:21.099] result() for MulticoreFuture ... done
[08:26:21.099] result() for MulticoreFuture ...
[08:26:21.099] result() for MulticoreFuture ... done
[08:26:21.100] result() for MulticoreFuture ...
[08:26:21.100] result() for MulticoreFuture ... done
[08:26:21.100] result() for MulticoreFuture ...
[08:26:21.100] result() for MulticoreFuture ... done
[08:26:21.100] - relayed: [n=2] TRUE, TRUE
[08:26:21.100] - queued futures: [n=2] TRUE, TRUE
[08:26:21.100] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:26:21.100]  length: 0 (resolved future 2)
[08:26:21.101] Relaying remaining futures
[08:26:21.101] signalConditionsASAP(NULL, pos=0) ...
[08:26:21.101] - nx: 2
[08:26:21.101] - relay: TRUE
[08:26:21.101] - stdout: TRUE
[08:26:21.101] - signal: TRUE
[08:26:21.101] - resignal: FALSE
[08:26:21.101] - force: TRUE
[08:26:21.101] - relayed: [n=2] TRUE, TRUE
[08:26:21.101] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:21.102] - relayed: [n=2] TRUE, TRUE
[08:26:21.102] - queued futures: [n=2] TRUE, TRUE
[08:26:21.102] signalConditionsASAP(NULL, pos=0) ... done
[08:26:21.102] resolve() on list ... DONE
[08:26:21.102] result() for MulticoreFuture ...
[08:26:21.102] result() for MulticoreFuture ... done
[08:26:21.102] result() for MulticoreFuture ...
[08:26:21.102] result() for MulticoreFuture ... done
[08:26:21.102] result() for MulticoreFuture ...
[08:26:21.102] result() for MulticoreFuture ... done
[08:26:21.103] result() for MulticoreFuture ...
[08:26:21.103] result() for MulticoreFuture ... done
[08:26:21.103]  - Number of value chunks collected: 2
[08:26:21.103] Resolving 2 futures (chunks) ... DONE
[08:26:21.103] Reducing values from 2 chunks ...
[08:26:21.103]  - Number of values collected after concatenation: 7
[08:26:21.103]  - Number of values expected: 7
[08:26:21.103] Reducing values from 2 chunks ... DONE
[08:26:21.103] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[08:26:21.105] future_lapply() ...
[08:26:21.108] Number of chunks: 2
[08:26:21.108] getGlobalsAndPackagesXApply() ...
[08:26:21.108]  - future.globals: TRUE
[08:26:21.109] getGlobalsAndPackages() ...
[08:26:21.109] Searching for globals...
[08:26:21.110] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[08:26:21.110] Searching for globals ... DONE
[08:26:21.110] Resolving globals: FALSE
[08:26:21.111] The total size of the 1 globals is 680 bytes (680 bytes)
[08:26:21.111] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 680 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (680 bytes of class ‘function’)
[08:26:21.111] - globals: [1] ‘FUN’
[08:26:21.111] 
[08:26:21.112] getGlobalsAndPackages() ... DONE
[08:26:21.112]  - globals found/used: [n=1] ‘FUN’
[08:26:21.114]  - needed namespaces: [n=0] 
[08:26:21.114] Finding globals ... DONE
[08:26:21.114]  - use_args: TRUE
[08:26:21.114]  - Getting '...' globals ...
[08:26:21.115] resolve() on list ...
[08:26:21.115]  recursive: 0
[08:26:21.115]  length: 1
[08:26:21.115]  elements: ‘...’
[08:26:21.115]  length: 0 (resolved future 1)
[08:26:21.116] resolve() on list ... DONE
[08:26:21.116]    - '...' content: [n=1] ‘y’
[08:26:21.116] List of 1
[08:26:21.116]  $ ...:List of 1
[08:26:21.116]   ..$ y: num [1:5] 2 4 6 8 10
[08:26:21.116]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:21.116]  - attr(*, "where")=List of 1
[08:26:21.116]   ..$ ...:<environment: 0x562ca78fc980> 
[08:26:21.116]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:21.116]  - attr(*, "resolved")= logi TRUE
[08:26:21.116]  - attr(*, "total_size")= num NA
[08:26:21.119]  - Getting '...' globals ... DONE
[08:26:21.120] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:26:21.120] List of 2
[08:26:21.120]  $ ...future.FUN:function (x, y)  
[08:26:21.120]  $ ...          :List of 1
[08:26:21.120]   ..$ y: num [1:5] 2 4 6 8 10
[08:26:21.120]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:21.120]  - attr(*, "where")=List of 2
[08:26:21.120]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:21.120]   ..$ ...          :<environment: 0x562ca78fc980> 
[08:26:21.120]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:21.120]  - attr(*, "resolved")= logi FALSE
[08:26:21.120]  - attr(*, "total_size")= num 7318
[08:26:21.123] Packages to be attached in all futures: [n=0] 
[08:26:21.123] getGlobalsAndPackagesXApply() ... DONE
[08:26:21.124] Number of futures (= number of chunks): 2
[08:26:21.124] Launching 2 futures (chunks) ...
[08:26:21.124] Chunk #1 of 2 ...
[08:26:21.124]  - Finding globals in 'X' for chunk #1 ...
[08:26:21.124] getGlobalsAndPackages() ...
[08:26:21.124] Searching for globals...
[08:26:21.124] 
[08:26:21.124] Searching for globals ... DONE
[08:26:21.125] - globals: [0] <none>
[08:26:21.125] getGlobalsAndPackages() ... DONE
[08:26:21.125]    + additional globals found: [n=0] 
[08:26:21.125]    + additional namespaces needed: [n=0] 
[08:26:21.125]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:21.125]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:21.125]  - seeds: <none>
[08:26:21.125]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.125] getGlobalsAndPackages() ...
[08:26:21.125] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.126] Resolving globals: FALSE
[08:26:21.126] Tweak future expression to call with '...' arguments ...
[08:26:21.126] {
[08:26:21.126]     do.call(function(...) {
[08:26:21.126]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.126]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.126]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.126]             on.exit(options(oopts), add = TRUE)
[08:26:21.126]         }
[08:26:21.126]         {
[08:26:21.126]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.126]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.126]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.126]             })
[08:26:21.126]         }
[08:26:21.126]     }, args = future.call.arguments)
[08:26:21.126] }
[08:26:21.126] Tweak future expression to call with '...' arguments ... DONE
[08:26:21.126] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.126] 
[08:26:21.127] getGlobalsAndPackages() ... DONE
[08:26:21.127] run() for ‘Future’ ...
[08:26:21.127] - state: ‘created’
[08:26:21.127] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:21.129] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.129] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:21.129]   - Field: ‘label’
[08:26:21.129]   - Field: ‘local’
[08:26:21.129]   - Field: ‘owner’
[08:26:21.129]   - Field: ‘envir’
[08:26:21.130]   - Field: ‘workers’
[08:26:21.130]   - Field: ‘packages’
[08:26:21.130]   - Field: ‘gc’
[08:26:21.130]   - Field: ‘job’
[08:26:21.130]   - Field: ‘conditions’
[08:26:21.130]   - Field: ‘expr’
[08:26:21.130]   - Field: ‘uuid’
[08:26:21.130]   - Field: ‘seed’
[08:26:21.130]   - Field: ‘version’
[08:26:21.130]   - Field: ‘result’
[08:26:21.130]   - Field: ‘asynchronous’
[08:26:21.131]   - Field: ‘calls’
[08:26:21.131]   - Field: ‘globals’
[08:26:21.131]   - Field: ‘stdout’
[08:26:21.131]   - Field: ‘earlySignal’
[08:26:21.131]   - Field: ‘lazy’
[08:26:21.131]   - Field: ‘state’
[08:26:21.131] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:21.131] - Launch lazy future ...
[08:26:21.131] Packages needed by the future expression (n = 0): <none>
[08:26:21.132] Packages needed by future strategies (n = 0): <none>
[08:26:21.132] {
[08:26:21.132]     {
[08:26:21.132]         {
[08:26:21.132]             ...future.startTime <- base::Sys.time()
[08:26:21.132]             {
[08:26:21.132]                 {
[08:26:21.132]                   {
[08:26:21.132]                     {
[08:26:21.132]                       base::local({
[08:26:21.132]                         has_future <- base::requireNamespace("future", 
[08:26:21.132]                           quietly = TRUE)
[08:26:21.132]                         if (has_future) {
[08:26:21.132]                           ns <- base::getNamespace("future")
[08:26:21.132]                           version <- ns[[".package"]][["version"]]
[08:26:21.132]                           if (is.null(version)) 
[08:26:21.132]                             version <- utils::packageVersion("future")
[08:26:21.132]                         }
[08:26:21.132]                         else {
[08:26:21.132]                           version <- NULL
[08:26:21.132]                         }
[08:26:21.132]                         if (!has_future || version < "1.8.0") {
[08:26:21.132]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:21.132]                             "", base::R.version$version.string), 
[08:26:21.132]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:21.132]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:21.132]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:21.132]                               "release", "version")], collapse = " "), 
[08:26:21.132]                             hostname = base::Sys.info()[["nodename"]])
[08:26:21.132]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:21.132]                             info)
[08:26:21.132]                           info <- base::paste(info, collapse = "; ")
[08:26:21.132]                           if (!has_future) {
[08:26:21.132]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:21.132]                               info)
[08:26:21.132]                           }
[08:26:21.132]                           else {
[08:26:21.132]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:21.132]                               info, version)
[08:26:21.132]                           }
[08:26:21.132]                           base::stop(msg)
[08:26:21.132]                         }
[08:26:21.132]                       })
[08:26:21.132]                     }
[08:26:21.132]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:21.132]                     base::options(mc.cores = 1L)
[08:26:21.132]                   }
[08:26:21.132]                   ...future.strategy.old <- future::plan("list")
[08:26:21.132]                   options(future.plan = NULL)
[08:26:21.132]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.132]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:21.132]                 }
[08:26:21.132]                 ...future.workdir <- getwd()
[08:26:21.132]             }
[08:26:21.132]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:21.132]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:21.132]         }
[08:26:21.132]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:21.132]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:21.132]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:21.132]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:21.132]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:21.132]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:21.132]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:21.132]             base::names(...future.oldOptions))
[08:26:21.132]     }
[08:26:21.132]     if (FALSE) {
[08:26:21.132]     }
[08:26:21.132]     else {
[08:26:21.132]         if (TRUE) {
[08:26:21.132]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:21.132]                 open = "w")
[08:26:21.132]         }
[08:26:21.132]         else {
[08:26:21.132]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:21.132]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:21.132]         }
[08:26:21.132]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:21.132]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:21.132]             base::sink(type = "output", split = FALSE)
[08:26:21.132]             base::close(...future.stdout)
[08:26:21.132]         }, add = TRUE)
[08:26:21.132]     }
[08:26:21.132]     ...future.frame <- base::sys.nframe()
[08:26:21.132]     ...future.conditions <- base::list()
[08:26:21.132]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:21.132]     if (FALSE) {
[08:26:21.132]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:21.132]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:21.132]     }
[08:26:21.132]     ...future.result <- base::tryCatch({
[08:26:21.132]         base::withCallingHandlers({
[08:26:21.132]             ...future.value <- base::withVisible(base::local({
[08:26:21.132]                 withCallingHandlers({
[08:26:21.132]                   {
[08:26:21.132]                     do.call(function(...) {
[08:26:21.132]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.132]                       if (!identical(...future.globals.maxSize.org, 
[08:26:21.132]                         ...future.globals.maxSize)) {
[08:26:21.132]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.132]                         on.exit(options(oopts), add = TRUE)
[08:26:21.132]                       }
[08:26:21.132]                       {
[08:26:21.132]                         lapply(seq_along(...future.elements_ii), 
[08:26:21.132]                           FUN = function(jj) {
[08:26:21.132]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.132]                             ...future.FUN(...future.X_jj, ...)
[08:26:21.132]                           })
[08:26:21.132]                       }
[08:26:21.132]                     }, args = future.call.arguments)
[08:26:21.132]                   }
[08:26:21.132]                 }, immediateCondition = function(cond) {
[08:26:21.132]                   save_rds <- function (object, pathname, ...) 
[08:26:21.132]                   {
[08:26:21.132]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:21.132]                     if (file_test("-f", pathname_tmp)) {
[08:26:21.132]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.132]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:21.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.132]                         fi_tmp[["mtime"]])
[08:26:21.132]                     }
[08:26:21.132]                     tryCatch({
[08:26:21.132]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:21.132]                     }, error = function(ex) {
[08:26:21.132]                       msg <- conditionMessage(ex)
[08:26:21.132]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.132]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:21.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.132]                         fi_tmp[["mtime"]], msg)
[08:26:21.132]                       ex$message <- msg
[08:26:21.132]                       stop(ex)
[08:26:21.132]                     })
[08:26:21.132]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:21.132]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:21.132]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:21.132]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.132]                       fi <- file.info(pathname)
[08:26:21.132]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:21.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.132]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:21.132]                         fi[["size"]], fi[["mtime"]])
[08:26:21.132]                       stop(msg)
[08:26:21.132]                     }
[08:26:21.132]                     invisible(pathname)
[08:26:21.132]                   }
[08:26:21.132]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:21.132]                     rootPath = tempdir()) 
[08:26:21.132]                   {
[08:26:21.132]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:21.132]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:21.132]                       tmpdir = path, fileext = ".rds")
[08:26:21.132]                     save_rds(obj, file)
[08:26:21.132]                   }
[08:26:21.132]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:21.132]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.132]                   {
[08:26:21.132]                     inherits <- base::inherits
[08:26:21.132]                     invokeRestart <- base::invokeRestart
[08:26:21.132]                     is.null <- base::is.null
[08:26:21.132]                     muffled <- FALSE
[08:26:21.132]                     if (inherits(cond, "message")) {
[08:26:21.132]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:21.132]                       if (muffled) 
[08:26:21.132]                         invokeRestart("muffleMessage")
[08:26:21.132]                     }
[08:26:21.132]                     else if (inherits(cond, "warning")) {
[08:26:21.132]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:21.132]                       if (muffled) 
[08:26:21.132]                         invokeRestart("muffleWarning")
[08:26:21.132]                     }
[08:26:21.132]                     else if (inherits(cond, "condition")) {
[08:26:21.132]                       if (!is.null(pattern)) {
[08:26:21.132]                         computeRestarts <- base::computeRestarts
[08:26:21.132]                         grepl <- base::grepl
[08:26:21.132]                         restarts <- computeRestarts(cond)
[08:26:21.132]                         for (restart in restarts) {
[08:26:21.132]                           name <- restart$name
[08:26:21.132]                           if (is.null(name)) 
[08:26:21.132]                             next
[08:26:21.132]                           if (!grepl(pattern, name)) 
[08:26:21.132]                             next
[08:26:21.132]                           invokeRestart(restart)
[08:26:21.132]                           muffled <- TRUE
[08:26:21.132]                           break
[08:26:21.132]                         }
[08:26:21.132]                       }
[08:26:21.132]                     }
[08:26:21.132]                     invisible(muffled)
[08:26:21.132]                   }
[08:26:21.132]                   muffleCondition(cond)
[08:26:21.132]                 })
[08:26:21.132]             }))
[08:26:21.132]             future::FutureResult(value = ...future.value$value, 
[08:26:21.132]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.132]                   ...future.rng), globalenv = if (FALSE) 
[08:26:21.132]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:21.132]                     ...future.globalenv.names))
[08:26:21.132]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:21.132]         }, condition = base::local({
[08:26:21.132]             c <- base::c
[08:26:21.132]             inherits <- base::inherits
[08:26:21.132]             invokeRestart <- base::invokeRestart
[08:26:21.132]             length <- base::length
[08:26:21.132]             list <- base::list
[08:26:21.132]             seq.int <- base::seq.int
[08:26:21.132]             signalCondition <- base::signalCondition
[08:26:21.132]             sys.calls <- base::sys.calls
[08:26:21.132]             `[[` <- base::`[[`
[08:26:21.132]             `+` <- base::`+`
[08:26:21.132]             `<<-` <- base::`<<-`
[08:26:21.132]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:21.132]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:21.132]                   3L)]
[08:26:21.132]             }
[08:26:21.132]             function(cond) {
[08:26:21.132]                 is_error <- inherits(cond, "error")
[08:26:21.132]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:21.132]                   NULL)
[08:26:21.132]                 if (is_error) {
[08:26:21.132]                   sessionInformation <- function() {
[08:26:21.132]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:21.132]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:21.132]                       search = base::search(), system = base::Sys.info())
[08:26:21.132]                   }
[08:26:21.132]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.132]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:21.132]                     cond$call), session = sessionInformation(), 
[08:26:21.132]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:21.132]                   signalCondition(cond)
[08:26:21.132]                 }
[08:26:21.132]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:21.132]                 "immediateCondition"))) {
[08:26:21.132]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:21.132]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.132]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:21.132]                   if (TRUE && !signal) {
[08:26:21.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.132]                     {
[08:26:21.132]                       inherits <- base::inherits
[08:26:21.132]                       invokeRestart <- base::invokeRestart
[08:26:21.132]                       is.null <- base::is.null
[08:26:21.132]                       muffled <- FALSE
[08:26:21.132]                       if (inherits(cond, "message")) {
[08:26:21.132]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.132]                         if (muffled) 
[08:26:21.132]                           invokeRestart("muffleMessage")
[08:26:21.132]                       }
[08:26:21.132]                       else if (inherits(cond, "warning")) {
[08:26:21.132]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.132]                         if (muffled) 
[08:26:21.132]                           invokeRestart("muffleWarning")
[08:26:21.132]                       }
[08:26:21.132]                       else if (inherits(cond, "condition")) {
[08:26:21.132]                         if (!is.null(pattern)) {
[08:26:21.132]                           computeRestarts <- base::computeRestarts
[08:26:21.132]                           grepl <- base::grepl
[08:26:21.132]                           restarts <- computeRestarts(cond)
[08:26:21.132]                           for (restart in restarts) {
[08:26:21.132]                             name <- restart$name
[08:26:21.132]                             if (is.null(name)) 
[08:26:21.132]                               next
[08:26:21.132]                             if (!grepl(pattern, name)) 
[08:26:21.132]                               next
[08:26:21.132]                             invokeRestart(restart)
[08:26:21.132]                             muffled <- TRUE
[08:26:21.132]                             break
[08:26:21.132]                           }
[08:26:21.132]                         }
[08:26:21.132]                       }
[08:26:21.132]                       invisible(muffled)
[08:26:21.132]                     }
[08:26:21.132]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.132]                   }
[08:26:21.132]                 }
[08:26:21.132]                 else {
[08:26:21.132]                   if (TRUE) {
[08:26:21.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.132]                     {
[08:26:21.132]                       inherits <- base::inherits
[08:26:21.132]                       invokeRestart <- base::invokeRestart
[08:26:21.132]                       is.null <- base::is.null
[08:26:21.132]                       muffled <- FALSE
[08:26:21.132]                       if (inherits(cond, "message")) {
[08:26:21.132]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.132]                         if (muffled) 
[08:26:21.132]                           invokeRestart("muffleMessage")
[08:26:21.132]                       }
[08:26:21.132]                       else if (inherits(cond, "warning")) {
[08:26:21.132]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.132]                         if (muffled) 
[08:26:21.132]                           invokeRestart("muffleWarning")
[08:26:21.132]                       }
[08:26:21.132]                       else if (inherits(cond, "condition")) {
[08:26:21.132]                         if (!is.null(pattern)) {
[08:26:21.132]                           computeRestarts <- base::computeRestarts
[08:26:21.132]                           grepl <- base::grepl
[08:26:21.132]                           restarts <- computeRestarts(cond)
[08:26:21.132]                           for (restart in restarts) {
[08:26:21.132]                             name <- restart$name
[08:26:21.132]                             if (is.null(name)) 
[08:26:21.132]                               next
[08:26:21.132]                             if (!grepl(pattern, name)) 
[08:26:21.132]                               next
[08:26:21.132]                             invokeRestart(restart)
[08:26:21.132]                             muffled <- TRUE
[08:26:21.132]                             break
[08:26:21.132]                           }
[08:26:21.132]                         }
[08:26:21.132]                       }
[08:26:21.132]                       invisible(muffled)
[08:26:21.132]                     }
[08:26:21.132]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.132]                   }
[08:26:21.132]                 }
[08:26:21.132]             }
[08:26:21.132]         }))
[08:26:21.132]     }, error = function(ex) {
[08:26:21.132]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:21.132]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.132]                 ...future.rng), started = ...future.startTime, 
[08:26:21.132]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:21.132]             version = "1.8"), class = "FutureResult")
[08:26:21.132]     }, finally = {
[08:26:21.132]         if (!identical(...future.workdir, getwd())) 
[08:26:21.132]             setwd(...future.workdir)
[08:26:21.132]         {
[08:26:21.132]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:21.132]                 ...future.oldOptions$nwarnings <- NULL
[08:26:21.132]             }
[08:26:21.132]             base::options(...future.oldOptions)
[08:26:21.132]             if (.Platform$OS.type == "windows") {
[08:26:21.132]                 old_names <- names(...future.oldEnvVars)
[08:26:21.132]                 envs <- base::Sys.getenv()
[08:26:21.132]                 names <- names(envs)
[08:26:21.132]                 common <- intersect(names, old_names)
[08:26:21.132]                 added <- setdiff(names, old_names)
[08:26:21.132]                 removed <- setdiff(old_names, names)
[08:26:21.132]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:21.132]                   envs[common]]
[08:26:21.132]                 NAMES <- toupper(changed)
[08:26:21.132]                 args <- list()
[08:26:21.132]                 for (kk in seq_along(NAMES)) {
[08:26:21.132]                   name <- changed[[kk]]
[08:26:21.132]                   NAME <- NAMES[[kk]]
[08:26:21.132]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.132]                     next
[08:26:21.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.132]                 }
[08:26:21.132]                 NAMES <- toupper(added)
[08:26:21.132]                 for (kk in seq_along(NAMES)) {
[08:26:21.132]                   name <- added[[kk]]
[08:26:21.132]                   NAME <- NAMES[[kk]]
[08:26:21.132]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.132]                     next
[08:26:21.132]                   args[[name]] <- ""
[08:26:21.132]                 }
[08:26:21.132]                 NAMES <- toupper(removed)
[08:26:21.132]                 for (kk in seq_along(NAMES)) {
[08:26:21.132]                   name <- removed[[kk]]
[08:26:21.132]                   NAME <- NAMES[[kk]]
[08:26:21.132]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.132]                     next
[08:26:21.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.132]                 }
[08:26:21.132]                 if (length(args) > 0) 
[08:26:21.132]                   base::do.call(base::Sys.setenv, args = args)
[08:26:21.132]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:21.132]             }
[08:26:21.132]             else {
[08:26:21.132]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:21.132]             }
[08:26:21.132]             {
[08:26:21.132]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:21.132]                   0L) {
[08:26:21.132]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:21.132]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:21.132]                   base::options(opts)
[08:26:21.132]                 }
[08:26:21.132]                 {
[08:26:21.132]                   {
[08:26:21.132]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:21.132]                     NULL
[08:26:21.132]                   }
[08:26:21.132]                   options(future.plan = NULL)
[08:26:21.132]                   if (is.na(NA_character_)) 
[08:26:21.132]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.132]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:21.132]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:21.132]                     .init = FALSE)
[08:26:21.132]                 }
[08:26:21.132]             }
[08:26:21.132]         }
[08:26:21.132]     })
[08:26:21.132]     if (TRUE) {
[08:26:21.132]         base::sink(type = "output", split = FALSE)
[08:26:21.132]         if (TRUE) {
[08:26:21.132]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:21.132]         }
[08:26:21.132]         else {
[08:26:21.132]             ...future.result["stdout"] <- base::list(NULL)
[08:26:21.132]         }
[08:26:21.132]         base::close(...future.stdout)
[08:26:21.132]         ...future.stdout <- NULL
[08:26:21.132]     }
[08:26:21.132]     ...future.result$conditions <- ...future.conditions
[08:26:21.132]     ...future.result$finished <- base::Sys.time()
[08:26:21.132]     ...future.result
[08:26:21.132] }
[08:26:21.135] assign_globals() ...
[08:26:21.135] List of 5
[08:26:21.135]  $ ...future.FUN            :function (x, y)  
[08:26:21.135]  $ future.call.arguments    :List of 1
[08:26:21.135]   ..$ y: num [1:5] 2 4 6 8 10
[08:26:21.135]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:21.135]  $ ...future.elements_ii    :List of 2
[08:26:21.135]   ..$ A: num 50
[08:26:21.135]   ..$ B: num 60
[08:26:21.135]  $ ...future.seeds_ii       : NULL
[08:26:21.135]  $ ...future.globals.maxSize: NULL
[08:26:21.135]  - attr(*, "where")=List of 5
[08:26:21.135]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:21.135]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:21.135]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:21.135]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:21.135]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:21.135]  - attr(*, "resolved")= logi FALSE
[08:26:21.135]  - attr(*, "total_size")= num 7318
[08:26:21.135]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:21.135]  - attr(*, "already-done")= logi TRUE
[08:26:21.143] - reassign environment for ‘...future.FUN’
[08:26:21.144] - copied ‘...future.FUN’ to environment
[08:26:21.144] - copied ‘future.call.arguments’ to environment
[08:26:21.144] - copied ‘...future.elements_ii’ to environment
[08:26:21.144] - copied ‘...future.seeds_ii’ to environment
[08:26:21.144] - copied ‘...future.globals.maxSize’ to environment
[08:26:21.144] assign_globals() ... done
[08:26:21.144] requestCore(): workers = 2
[08:26:21.147] MulticoreFuture started
[08:26:21.148] - Launch lazy future ... done
[08:26:21.148] plan(): Setting new future strategy stack:
[08:26:21.148] run() for ‘MulticoreFuture’ ... done
[08:26:21.149] Created future:
[08:26:21.149] List of future strategies:
[08:26:21.149] 1. sequential:
[08:26:21.149]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:21.149]    - tweaked: FALSE
[08:26:21.149]    - call: NULL
[08:26:21.150] plan(): nbrOfWorkers() = 1
[08:26:21.153] plan(): Setting new future strategy stack:
[08:26:21.153] List of future strategies:
[08:26:21.153] 1. multicore:
[08:26:21.153]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:21.153]    - tweaked: FALSE
[08:26:21.153]    - call: plan(strategy)
[08:26:21.156] plan(): nbrOfWorkers() = 2
[08:26:21.149] MulticoreFuture:
[08:26:21.149] Label: ‘future_sapply-1’
[08:26:21.149] Expression:
[08:26:21.149] {
[08:26:21.149]     do.call(function(...) {
[08:26:21.149]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.149]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.149]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.149]             on.exit(options(oopts), add = TRUE)
[08:26:21.149]         }
[08:26:21.149]         {
[08:26:21.149]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.149]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.149]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.149]             })
[08:26:21.149]         }
[08:26:21.149]     }, args = future.call.arguments)
[08:26:21.149] }
[08:26:21.149] Lazy evaluation: FALSE
[08:26:21.149] Asynchronous evaluation: TRUE
[08:26:21.149] Local evaluation: TRUE
[08:26:21.149] Environment: R_GlobalEnv
[08:26:21.149] Capture standard output: TRUE
[08:26:21.149] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:21.149] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 680 bytes, DotDotDotList ‘future.call.arguments’ of 183 bytes, list ‘...future.elements_ii’ of 114 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:21.149] Packages: <none>
[08:26:21.149] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:21.149] Resolved: TRUE
[08:26:21.149] Value: <not collected>
[08:26:21.149] Conditions captured: <none>
[08:26:21.149] Early signaling: FALSE
[08:26:21.149] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:21.149] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.158] Chunk #1 of 2 ... DONE
[08:26:21.158] Chunk #2 of 2 ...
[08:26:21.158]  - Finding globals in 'X' for chunk #2 ...
[08:26:21.158] getGlobalsAndPackages() ...
[08:26:21.158] Searching for globals...
[08:26:21.159] 
[08:26:21.159] Searching for globals ... DONE
[08:26:21.159] - globals: [0] <none>
[08:26:21.159] getGlobalsAndPackages() ... DONE
[08:26:21.159]    + additional globals found: [n=0] 
[08:26:21.159]    + additional namespaces needed: [n=0] 
[08:26:21.160]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:21.160]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:21.160]  - seeds: <none>
[08:26:21.160]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.160] getGlobalsAndPackages() ...
[08:26:21.160] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.161] Resolving globals: FALSE
[08:26:21.161] Tweak future expression to call with '...' arguments ...
[08:26:21.161] {
[08:26:21.161]     do.call(function(...) {
[08:26:21.161]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.161]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.161]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.161]             on.exit(options(oopts), add = TRUE)
[08:26:21.161]         }
[08:26:21.161]         {
[08:26:21.161]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.161]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.161]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.161]             })
[08:26:21.161]         }
[08:26:21.161]     }, args = future.call.arguments)
[08:26:21.161] }
[08:26:21.161] Tweak future expression to call with '...' arguments ... DONE
[08:26:21.162] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.162] 
[08:26:21.163] getGlobalsAndPackages() ... DONE
[08:26:21.163] run() for ‘Future’ ...
[08:26:21.163] - state: ‘created’
[08:26:21.163] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:21.166] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.166] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:21.167]   - Field: ‘label’
[08:26:21.167]   - Field: ‘local’
[08:26:21.167]   - Field: ‘owner’
[08:26:21.167]   - Field: ‘envir’
[08:26:21.167]   - Field: ‘workers’
[08:26:21.167]   - Field: ‘packages’
[08:26:21.168]   - Field: ‘gc’
[08:26:21.168]   - Field: ‘job’
[08:26:21.168]   - Field: ‘conditions’
[08:26:21.168]   - Field: ‘expr’
[08:26:21.168]   - Field: ‘uuid’
[08:26:21.168]   - Field: ‘seed’
[08:26:21.168]   - Field: ‘version’
[08:26:21.168]   - Field: ‘result’
[08:26:21.169]   - Field: ‘asynchronous’
[08:26:21.169]   - Field: ‘calls’
[08:26:21.169]   - Field: ‘globals’
[08:26:21.169]   - Field: ‘stdout’
[08:26:21.169]   - Field: ‘earlySignal’
[08:26:21.169]   - Field: ‘lazy’
[08:26:21.169]   - Field: ‘state’
[08:26:21.169] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:21.170] - Launch lazy future ...
[08:26:21.170] Packages needed by the future expression (n = 0): <none>
[08:26:21.170] Packages needed by future strategies (n = 0): <none>
[08:26:21.171] {
[08:26:21.171]     {
[08:26:21.171]         {
[08:26:21.171]             ...future.startTime <- base::Sys.time()
[08:26:21.171]             {
[08:26:21.171]                 {
[08:26:21.171]                   {
[08:26:21.171]                     {
[08:26:21.171]                       base::local({
[08:26:21.171]                         has_future <- base::requireNamespace("future", 
[08:26:21.171]                           quietly = TRUE)
[08:26:21.171]                         if (has_future) {
[08:26:21.171]                           ns <- base::getNamespace("future")
[08:26:21.171]                           version <- ns[[".package"]][["version"]]
[08:26:21.171]                           if (is.null(version)) 
[08:26:21.171]                             version <- utils::packageVersion("future")
[08:26:21.171]                         }
[08:26:21.171]                         else {
[08:26:21.171]                           version <- NULL
[08:26:21.171]                         }
[08:26:21.171]                         if (!has_future || version < "1.8.0") {
[08:26:21.171]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:21.171]                             "", base::R.version$version.string), 
[08:26:21.171]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:21.171]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:21.171]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:21.171]                               "release", "version")], collapse = " "), 
[08:26:21.171]                             hostname = base::Sys.info()[["nodename"]])
[08:26:21.171]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:21.171]                             info)
[08:26:21.171]                           info <- base::paste(info, collapse = "; ")
[08:26:21.171]                           if (!has_future) {
[08:26:21.171]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:21.171]                               info)
[08:26:21.171]                           }
[08:26:21.171]                           else {
[08:26:21.171]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:21.171]                               info, version)
[08:26:21.171]                           }
[08:26:21.171]                           base::stop(msg)
[08:26:21.171]                         }
[08:26:21.171]                       })
[08:26:21.171]                     }
[08:26:21.171]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:21.171]                     base::options(mc.cores = 1L)
[08:26:21.171]                   }
[08:26:21.171]                   ...future.strategy.old <- future::plan("list")
[08:26:21.171]                   options(future.plan = NULL)
[08:26:21.171]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.171]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:21.171]                 }
[08:26:21.171]                 ...future.workdir <- getwd()
[08:26:21.171]             }
[08:26:21.171]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:21.171]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:21.171]         }
[08:26:21.171]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:21.171]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:21.171]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:21.171]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:21.171]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:21.171]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:21.171]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:21.171]             base::names(...future.oldOptions))
[08:26:21.171]     }
[08:26:21.171]     if (FALSE) {
[08:26:21.171]     }
[08:26:21.171]     else {
[08:26:21.171]         if (TRUE) {
[08:26:21.171]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:21.171]                 open = "w")
[08:26:21.171]         }
[08:26:21.171]         else {
[08:26:21.171]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:21.171]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:21.171]         }
[08:26:21.171]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:21.171]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:21.171]             base::sink(type = "output", split = FALSE)
[08:26:21.171]             base::close(...future.stdout)
[08:26:21.171]         }, add = TRUE)
[08:26:21.171]     }
[08:26:21.171]     ...future.frame <- base::sys.nframe()
[08:26:21.171]     ...future.conditions <- base::list()
[08:26:21.171]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:21.171]     if (FALSE) {
[08:26:21.171]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:21.171]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:21.171]     }
[08:26:21.171]     ...future.result <- base::tryCatch({
[08:26:21.171]         base::withCallingHandlers({
[08:26:21.171]             ...future.value <- base::withVisible(base::local({
[08:26:21.171]                 withCallingHandlers({
[08:26:21.171]                   {
[08:26:21.171]                     do.call(function(...) {
[08:26:21.171]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.171]                       if (!identical(...future.globals.maxSize.org, 
[08:26:21.171]                         ...future.globals.maxSize)) {
[08:26:21.171]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.171]                         on.exit(options(oopts), add = TRUE)
[08:26:21.171]                       }
[08:26:21.171]                       {
[08:26:21.171]                         lapply(seq_along(...future.elements_ii), 
[08:26:21.171]                           FUN = function(jj) {
[08:26:21.171]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.171]                             ...future.FUN(...future.X_jj, ...)
[08:26:21.171]                           })
[08:26:21.171]                       }
[08:26:21.171]                     }, args = future.call.arguments)
[08:26:21.171]                   }
[08:26:21.171]                 }, immediateCondition = function(cond) {
[08:26:21.171]                   save_rds <- function (object, pathname, ...) 
[08:26:21.171]                   {
[08:26:21.171]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:21.171]                     if (file_test("-f", pathname_tmp)) {
[08:26:21.171]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.171]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:21.171]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.171]                         fi_tmp[["mtime"]])
[08:26:21.171]                     }
[08:26:21.171]                     tryCatch({
[08:26:21.171]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:21.171]                     }, error = function(ex) {
[08:26:21.171]                       msg <- conditionMessage(ex)
[08:26:21.171]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.171]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:21.171]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.171]                         fi_tmp[["mtime"]], msg)
[08:26:21.171]                       ex$message <- msg
[08:26:21.171]                       stop(ex)
[08:26:21.171]                     })
[08:26:21.171]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:21.171]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:21.171]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:21.171]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.171]                       fi <- file.info(pathname)
[08:26:21.171]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:21.171]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.171]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:21.171]                         fi[["size"]], fi[["mtime"]])
[08:26:21.171]                       stop(msg)
[08:26:21.171]                     }
[08:26:21.171]                     invisible(pathname)
[08:26:21.171]                   }
[08:26:21.171]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:21.171]                     rootPath = tempdir()) 
[08:26:21.171]                   {
[08:26:21.171]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:21.171]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:21.171]                       tmpdir = path, fileext = ".rds")
[08:26:21.171]                     save_rds(obj, file)
[08:26:21.171]                   }
[08:26:21.171]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:21.171]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.171]                   {
[08:26:21.171]                     inherits <- base::inherits
[08:26:21.171]                     invokeRestart <- base::invokeRestart
[08:26:21.171]                     is.null <- base::is.null
[08:26:21.171]                     muffled <- FALSE
[08:26:21.171]                     if (inherits(cond, "message")) {
[08:26:21.171]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:21.171]                       if (muffled) 
[08:26:21.171]                         invokeRestart("muffleMessage")
[08:26:21.171]                     }
[08:26:21.171]                     else if (inherits(cond, "warning")) {
[08:26:21.171]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:21.171]                       if (muffled) 
[08:26:21.171]                         invokeRestart("muffleWarning")
[08:26:21.171]                     }
[08:26:21.171]                     else if (inherits(cond, "condition")) {
[08:26:21.171]                       if (!is.null(pattern)) {
[08:26:21.171]                         computeRestarts <- base::computeRestarts
[08:26:21.171]                         grepl <- base::grepl
[08:26:21.171]                         restarts <- computeRestarts(cond)
[08:26:21.171]                         for (restart in restarts) {
[08:26:21.171]                           name <- restart$name
[08:26:21.171]                           if (is.null(name)) 
[08:26:21.171]                             next
[08:26:21.171]                           if (!grepl(pattern, name)) 
[08:26:21.171]                             next
[08:26:21.171]                           invokeRestart(restart)
[08:26:21.171]                           muffled <- TRUE
[08:26:21.171]                           break
[08:26:21.171]                         }
[08:26:21.171]                       }
[08:26:21.171]                     }
[08:26:21.171]                     invisible(muffled)
[08:26:21.171]                   }
[08:26:21.171]                   muffleCondition(cond)
[08:26:21.171]                 })
[08:26:21.171]             }))
[08:26:21.171]             future::FutureResult(value = ...future.value$value, 
[08:26:21.171]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.171]                   ...future.rng), globalenv = if (FALSE) 
[08:26:21.171]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:21.171]                     ...future.globalenv.names))
[08:26:21.171]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:21.171]         }, condition = base::local({
[08:26:21.171]             c <- base::c
[08:26:21.171]             inherits <- base::inherits
[08:26:21.171]             invokeRestart <- base::invokeRestart
[08:26:21.171]             length <- base::length
[08:26:21.171]             list <- base::list
[08:26:21.171]             seq.int <- base::seq.int
[08:26:21.171]             signalCondition <- base::signalCondition
[08:26:21.171]             sys.calls <- base::sys.calls
[08:26:21.171]             `[[` <- base::`[[`
[08:26:21.171]             `+` <- base::`+`
[08:26:21.171]             `<<-` <- base::`<<-`
[08:26:21.171]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:21.171]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:21.171]                   3L)]
[08:26:21.171]             }
[08:26:21.171]             function(cond) {
[08:26:21.171]                 is_error <- inherits(cond, "error")
[08:26:21.171]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:21.171]                   NULL)
[08:26:21.171]                 if (is_error) {
[08:26:21.171]                   sessionInformation <- function() {
[08:26:21.171]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:21.171]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:21.171]                       search = base::search(), system = base::Sys.info())
[08:26:21.171]                   }
[08:26:21.171]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.171]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:21.171]                     cond$call), session = sessionInformation(), 
[08:26:21.171]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:21.171]                   signalCondition(cond)
[08:26:21.171]                 }
[08:26:21.171]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:21.171]                 "immediateCondition"))) {
[08:26:21.171]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:21.171]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.171]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:21.171]                   if (TRUE && !signal) {
[08:26:21.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.171]                     {
[08:26:21.171]                       inherits <- base::inherits
[08:26:21.171]                       invokeRestart <- base::invokeRestart
[08:26:21.171]                       is.null <- base::is.null
[08:26:21.171]                       muffled <- FALSE
[08:26:21.171]                       if (inherits(cond, "message")) {
[08:26:21.171]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.171]                         if (muffled) 
[08:26:21.171]                           invokeRestart("muffleMessage")
[08:26:21.171]                       }
[08:26:21.171]                       else if (inherits(cond, "warning")) {
[08:26:21.171]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.171]                         if (muffled) 
[08:26:21.171]                           invokeRestart("muffleWarning")
[08:26:21.171]                       }
[08:26:21.171]                       else if (inherits(cond, "condition")) {
[08:26:21.171]                         if (!is.null(pattern)) {
[08:26:21.171]                           computeRestarts <- base::computeRestarts
[08:26:21.171]                           grepl <- base::grepl
[08:26:21.171]                           restarts <- computeRestarts(cond)
[08:26:21.171]                           for (restart in restarts) {
[08:26:21.171]                             name <- restart$name
[08:26:21.171]                             if (is.null(name)) 
[08:26:21.171]                               next
[08:26:21.171]                             if (!grepl(pattern, name)) 
[08:26:21.171]                               next
[08:26:21.171]                             invokeRestart(restart)
[08:26:21.171]                             muffled <- TRUE
[08:26:21.171]                             break
[08:26:21.171]                           }
[08:26:21.171]                         }
[08:26:21.171]                       }
[08:26:21.171]                       invisible(muffled)
[08:26:21.171]                     }
[08:26:21.171]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.171]                   }
[08:26:21.171]                 }
[08:26:21.171]                 else {
[08:26:21.171]                   if (TRUE) {
[08:26:21.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.171]                     {
[08:26:21.171]                       inherits <- base::inherits
[08:26:21.171]                       invokeRestart <- base::invokeRestart
[08:26:21.171]                       is.null <- base::is.null
[08:26:21.171]                       muffled <- FALSE
[08:26:21.171]                       if (inherits(cond, "message")) {
[08:26:21.171]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.171]                         if (muffled) 
[08:26:21.171]                           invokeRestart("muffleMessage")
[08:26:21.171]                       }
[08:26:21.171]                       else if (inherits(cond, "warning")) {
[08:26:21.171]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.171]                         if (muffled) 
[08:26:21.171]                           invokeRestart("muffleWarning")
[08:26:21.171]                       }
[08:26:21.171]                       else if (inherits(cond, "condition")) {
[08:26:21.171]                         if (!is.null(pattern)) {
[08:26:21.171]                           computeRestarts <- base::computeRestarts
[08:26:21.171]                           grepl <- base::grepl
[08:26:21.171]                           restarts <- computeRestarts(cond)
[08:26:21.171]                           for (restart in restarts) {
[08:26:21.171]                             name <- restart$name
[08:26:21.171]                             if (is.null(name)) 
[08:26:21.171]                               next
[08:26:21.171]                             if (!grepl(pattern, name)) 
[08:26:21.171]                               next
[08:26:21.171]                             invokeRestart(restart)
[08:26:21.171]                             muffled <- TRUE
[08:26:21.171]                             break
[08:26:21.171]                           }
[08:26:21.171]                         }
[08:26:21.171]                       }
[08:26:21.171]                       invisible(muffled)
[08:26:21.171]                     }
[08:26:21.171]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.171]                   }
[08:26:21.171]                 }
[08:26:21.171]             }
[08:26:21.171]         }))
[08:26:21.171]     }, error = function(ex) {
[08:26:21.171]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:21.171]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.171]                 ...future.rng), started = ...future.startTime, 
[08:26:21.171]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:21.171]             version = "1.8"), class = "FutureResult")
[08:26:21.171]     }, finally = {
[08:26:21.171]         if (!identical(...future.workdir, getwd())) 
[08:26:21.171]             setwd(...future.workdir)
[08:26:21.171]         {
[08:26:21.171]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:21.171]                 ...future.oldOptions$nwarnings <- NULL
[08:26:21.171]             }
[08:26:21.171]             base::options(...future.oldOptions)
[08:26:21.171]             if (.Platform$OS.type == "windows") {
[08:26:21.171]                 old_names <- names(...future.oldEnvVars)
[08:26:21.171]                 envs <- base::Sys.getenv()
[08:26:21.171]                 names <- names(envs)
[08:26:21.171]                 common <- intersect(names, old_names)
[08:26:21.171]                 added <- setdiff(names, old_names)
[08:26:21.171]                 removed <- setdiff(old_names, names)
[08:26:21.171]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:21.171]                   envs[common]]
[08:26:21.171]                 NAMES <- toupper(changed)
[08:26:21.171]                 args <- list()
[08:26:21.171]                 for (kk in seq_along(NAMES)) {
[08:26:21.171]                   name <- changed[[kk]]
[08:26:21.171]                   NAME <- NAMES[[kk]]
[08:26:21.171]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.171]                     next
[08:26:21.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.171]                 }
[08:26:21.171]                 NAMES <- toupper(added)
[08:26:21.171]                 for (kk in seq_along(NAMES)) {
[08:26:21.171]                   name <- added[[kk]]
[08:26:21.171]                   NAME <- NAMES[[kk]]
[08:26:21.171]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.171]                     next
[08:26:21.171]                   args[[name]] <- ""
[08:26:21.171]                 }
[08:26:21.171]                 NAMES <- toupper(removed)
[08:26:21.171]                 for (kk in seq_along(NAMES)) {
[08:26:21.171]                   name <- removed[[kk]]
[08:26:21.171]                   NAME <- NAMES[[kk]]
[08:26:21.171]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.171]                     next
[08:26:21.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.171]                 }
[08:26:21.171]                 if (length(args) > 0) 
[08:26:21.171]                   base::do.call(base::Sys.setenv, args = args)
[08:26:21.171]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:21.171]             }
[08:26:21.171]             else {
[08:26:21.171]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:21.171]             }
[08:26:21.171]             {
[08:26:21.171]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:21.171]                   0L) {
[08:26:21.171]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:21.171]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:21.171]                   base::options(opts)
[08:26:21.171]                 }
[08:26:21.171]                 {
[08:26:21.171]                   {
[08:26:21.171]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:21.171]                     NULL
[08:26:21.171]                   }
[08:26:21.171]                   options(future.plan = NULL)
[08:26:21.171]                   if (is.na(NA_character_)) 
[08:26:21.171]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.171]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:21.171]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:21.171]                     .init = FALSE)
[08:26:21.171]                 }
[08:26:21.171]             }
[08:26:21.171]         }
[08:26:21.171]     })
[08:26:21.171]     if (TRUE) {
[08:26:21.171]         base::sink(type = "output", split = FALSE)
[08:26:21.171]         if (TRUE) {
[08:26:21.171]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:21.171]         }
[08:26:21.171]         else {
[08:26:21.171]             ...future.result["stdout"] <- base::list(NULL)
[08:26:21.171]         }
[08:26:21.171]         base::close(...future.stdout)
[08:26:21.171]         ...future.stdout <- NULL
[08:26:21.171]     }
[08:26:21.171]     ...future.result$conditions <- ...future.conditions
[08:26:21.171]     ...future.result$finished <- base::Sys.time()
[08:26:21.171]     ...future.result
[08:26:21.171] }
[08:26:21.174] assign_globals() ...
[08:26:21.174] List of 5
[08:26:21.174]  $ ...future.FUN            :function (x, y)  
[08:26:21.174]  $ future.call.arguments    :List of 1
[08:26:21.174]   ..$ y: num [1:5] 2 4 6 8 10
[08:26:21.174]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:21.174]  $ ...future.elements_ii    :List of 2
[08:26:21.174]   ..$ C: num 70
[08:26:21.174]   ..$ D: num 80
[08:26:21.174]  $ ...future.seeds_ii       : NULL
[08:26:21.174]  $ ...future.globals.maxSize: NULL
[08:26:21.174]  - attr(*, "where")=List of 5
[08:26:21.174]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:21.174]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:21.174]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:21.174]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:21.174]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:21.174]  - attr(*, "resolved")= logi FALSE
[08:26:21.174]  - attr(*, "total_size")= num 7318
[08:26:21.174]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:21.174]  - attr(*, "already-done")= logi TRUE
[08:26:21.186] - reassign environment for ‘...future.FUN’
[08:26:21.187] - copied ‘...future.FUN’ to environment
[08:26:21.187] - copied ‘future.call.arguments’ to environment
[08:26:21.187] - copied ‘...future.elements_ii’ to environment
[08:26:21.187] - copied ‘...future.seeds_ii’ to environment
[08:26:21.187] - copied ‘...future.globals.maxSize’ to environment
[08:26:21.188] assign_globals() ... done
[08:26:21.188] requestCore(): workers = 2
[08:26:21.190] MulticoreFuture started
[08:26:21.191] - Launch lazy future ... done
[08:26:21.192] run() for ‘MulticoreFuture’ ... done
[08:26:21.192] plan(): Setting new future strategy stack:
[08:26:21.192] Created future:
[08:26:21.192] List of future strategies:
[08:26:21.192] 1. sequential:
[08:26:21.192]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:21.192]    - tweaked: FALSE
[08:26:21.192]    - call: NULL
[08:26:21.194] plan(): nbrOfWorkers() = 1
[08:26:21.198] plan(): Setting new future strategy stack:
[08:26:21.198] List of future strategies:
[08:26:21.198] 1. multicore:
[08:26:21.198]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:21.198]    - tweaked: FALSE
[08:26:21.198]    - call: plan(strategy)
[08:26:21.203] plan(): nbrOfWorkers() = 2
[08:26:21.193] MulticoreFuture:
[08:26:21.193] Label: ‘future_sapply-2’
[08:26:21.193] Expression:
[08:26:21.193] {
[08:26:21.193]     do.call(function(...) {
[08:26:21.193]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.193]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.193]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.193]             on.exit(options(oopts), add = TRUE)
[08:26:21.193]         }
[08:26:21.193]         {
[08:26:21.193]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.193]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.193]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.193]             })
[08:26:21.193]         }
[08:26:21.193]     }, args = future.call.arguments)
[08:26:21.193] }
[08:26:21.193] Lazy evaluation: FALSE
[08:26:21.193] Asynchronous evaluation: TRUE
[08:26:21.193] Local evaluation: TRUE
[08:26:21.193] Environment: R_GlobalEnv
[08:26:21.193] Capture standard output: TRUE
[08:26:21.193] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:21.193] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 680 bytes, DotDotDotList ‘future.call.arguments’ of 183 bytes, list ‘...future.elements_ii’ of 114 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:21.193] Packages: <none>
[08:26:21.193] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:21.193] Resolved: TRUE
[08:26:21.193] Value: <not collected>
[08:26:21.193] Conditions captured: <none>
[08:26:21.193] Early signaling: FALSE
[08:26:21.193] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:21.193] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.204] Chunk #2 of 2 ... DONE
[08:26:21.204] Launching 2 futures (chunks) ... DONE
[08:26:21.205] Resolving 2 futures (chunks) ...
[08:26:21.205] resolve() on list ...
[08:26:21.205]  recursive: 0
[08:26:21.205]  length: 2
[08:26:21.205] 
[08:26:21.206] Future #1
[08:26:21.206] result() for MulticoreFuture ...
[08:26:21.207] result() for MulticoreFuture ...
[08:26:21.207] result() for MulticoreFuture ... done
[08:26:21.208] result() for MulticoreFuture ... done
[08:26:21.208] result() for MulticoreFuture ...
[08:26:21.208] result() for MulticoreFuture ... done
[08:26:21.208] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:26:21.208] - nx: 2
[08:26:21.208] - relay: TRUE
[08:26:21.208] - stdout: TRUE
[08:26:21.209] - signal: TRUE
[08:26:21.209] - resignal: FALSE
[08:26:21.209] - force: TRUE
[08:26:21.209] - relayed: [n=2] FALSE, FALSE
[08:26:21.209] - queued futures: [n=2] FALSE, FALSE
[08:26:21.209]  - until=1
[08:26:21.209]  - relaying element #1
[08:26:21.210] result() for MulticoreFuture ...
[08:26:21.210] result() for MulticoreFuture ... done
[08:26:21.210] result() for MulticoreFuture ...
[08:26:21.210] result() for MulticoreFuture ... done
[08:26:21.210] result() for MulticoreFuture ...
[08:26:21.211] result() for MulticoreFuture ... done
[08:26:21.211] result() for MulticoreFuture ...
[08:26:21.211] result() for MulticoreFuture ... done
[08:26:21.211] - relayed: [n=2] TRUE, FALSE
[08:26:21.211] - queued futures: [n=2] TRUE, FALSE
[08:26:21.211] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:26:21.212]  length: 1 (resolved future 1)
[08:26:21.212] Future #2
[08:26:21.212] result() for MulticoreFuture ...
[08:26:21.213] result() for MulticoreFuture ...
[08:26:21.213] result() for MulticoreFuture ... done
[08:26:21.213] result() for MulticoreFuture ... done
[08:26:21.213] result() for MulticoreFuture ...
[08:26:21.213] result() for MulticoreFuture ... done
[08:26:21.213] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:26:21.214] - nx: 2
[08:26:21.214] - relay: TRUE
[08:26:21.214] - stdout: TRUE
[08:26:21.214] - signal: TRUE
[08:26:21.214] - resignal: FALSE
[08:26:21.214] - force: TRUE
[08:26:21.214] - relayed: [n=2] TRUE, FALSE
[08:26:21.214] - queued futures: [n=2] TRUE, FALSE
[08:26:21.215]  - until=2
[08:26:21.215]  - relaying element #2
[08:26:21.215] result() for MulticoreFuture ...
[08:26:21.215] result() for MulticoreFuture ... done
[08:26:21.215] result() for MulticoreFuture ...
[08:26:21.215] result() for MulticoreFuture ... done
[08:26:21.215] result() for MulticoreFuture ...
[08:26:21.215] result() for MulticoreFuture ... done
[08:26:21.215] result() for MulticoreFuture ...
[08:26:21.216] result() for MulticoreFuture ... done
[08:26:21.216] - relayed: [n=2] TRUE, TRUE
[08:26:21.216] - queued futures: [n=2] TRUE, TRUE
[08:26:21.216] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:26:21.216]  length: 0 (resolved future 2)
[08:26:21.216] Relaying remaining futures
[08:26:21.216] signalConditionsASAP(NULL, pos=0) ...
[08:26:21.216] - nx: 2
[08:26:21.216] - relay: TRUE
[08:26:21.217] - stdout: TRUE
[08:26:21.217] - signal: TRUE
[08:26:21.217] - resignal: FALSE
[08:26:21.217] - force: TRUE
[08:26:21.217] - relayed: [n=2] TRUE, TRUE
[08:26:21.217] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:21.217] - relayed: [n=2] TRUE, TRUE
[08:26:21.217] - queued futures: [n=2] TRUE, TRUE
[08:26:21.217] signalConditionsASAP(NULL, pos=0) ... done
[08:26:21.217] resolve() on list ... DONE
[08:26:21.218] result() for MulticoreFuture ...
[08:26:21.218] result() for MulticoreFuture ... done
[08:26:21.218] result() for MulticoreFuture ...
[08:26:21.218] result() for MulticoreFuture ... done
[08:26:21.218] result() for MulticoreFuture ...
[08:26:21.218] result() for MulticoreFuture ... done
[08:26:21.218] result() for MulticoreFuture ...
[08:26:21.218] result() for MulticoreFuture ... done
[08:26:21.218]  - Number of value chunks collected: 2
[08:26:21.219] Resolving 2 futures (chunks) ... DONE
[08:26:21.219] Reducing values from 2 chunks ...
[08:26:21.219]  - Number of values collected after concatenation: 4
[08:26:21.219]  - Number of values expected: 4
[08:26:21.219] Reducing values from 2 chunks ... DONE
[08:26:21.219] future_lapply() ... DONE
[08:26:21.220] future_lapply() ...
[08:26:21.224] Number of chunks: 2
[08:26:21.224] getGlobalsAndPackagesXApply() ...
[08:26:21.224]  - future.globals: TRUE
[08:26:21.224] getGlobalsAndPackages() ...
[08:26:21.224] Searching for globals...
[08:26:21.232] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[08:26:21.232] Searching for globals ... DONE
[08:26:21.232] Resolving globals: FALSE
[08:26:21.233] The total size of the 7 globals is 14.32 KiB (14666 bytes)
[08:26:21.234] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 14.32 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.67 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:21.234] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:21.234] - packages: [1] ‘future.apply’
[08:26:21.234] getGlobalsAndPackages() ... DONE
[08:26:21.234]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:21.234]  - needed namespaces: [n=1] ‘future.apply’
[08:26:21.235] Finding globals ... DONE
[08:26:21.235]  - use_args: TRUE
[08:26:21.235]  - Getting '...' globals ...
[08:26:21.235] resolve() on list ...
[08:26:21.235]  recursive: 0
[08:26:21.235]  length: 1
[08:26:21.235]  elements: ‘...’
[08:26:21.235]  length: 0 (resolved future 1)
[08:26:21.236] resolve() on list ... DONE
[08:26:21.236]    - '...' content: [n=1] ‘y’
[08:26:21.236] List of 1
[08:26:21.236]  $ ...:List of 1
[08:26:21.236]   ..$ y: num [1:5] 2 4 6 8 10
[08:26:21.236]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:21.236]  - attr(*, "where")=List of 1
[08:26:21.236]   ..$ ...:<environment: 0x562ca79dbf90> 
[08:26:21.236]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:21.236]  - attr(*, "resolved")= logi TRUE
[08:26:21.236]  - attr(*, "total_size")= num NA
[08:26:21.239]  - Getting '...' globals ... DONE
[08:26:21.239] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:21.239] List of 8
[08:26:21.239]  $ ...future.FUN:function (x, ...)  
[08:26:21.239]  $ x_FUN        :function (x, y)  
[08:26:21.239]  $ times        : int 15
[08:26:21.239]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:21.239]  $ stop_if_not  :function (...)  
[08:26:21.239]  $ dim          : int [1:2] 3 5
[08:26:21.239]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:21.239]  $ ...          :List of 1
[08:26:21.239]   ..$ y: num [1:5] 2 4 6 8 10
[08:26:21.239]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:21.239]  - attr(*, "where")=List of 8
[08:26:21.239]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:21.239]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:21.239]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:21.239]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:21.239]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:21.239]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:21.239]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:21.239]   ..$ ...          :<environment: 0x562ca79dbf90> 
[08:26:21.239]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:21.239]  - attr(*, "resolved")= logi FALSE
[08:26:21.239]  - attr(*, "total_size")= num 26659
[08:26:21.245] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:21.245] getGlobalsAndPackagesXApply() ... DONE
[08:26:21.250] Number of futures (= number of chunks): 2
[08:26:21.250] Launching 2 futures (chunks) ...
[08:26:21.250] Chunk #1 of 2 ...
[08:26:21.250]  - Finding globals in 'X' for chunk #1 ...
[08:26:21.250] getGlobalsAndPackages() ...
[08:26:21.251] Searching for globals...
[08:26:21.251] 
[08:26:21.251] Searching for globals ... DONE
[08:26:21.251] - globals: [0] <none>
[08:26:21.251] getGlobalsAndPackages() ... DONE
[08:26:21.251]    + additional globals found: [n=0] 
[08:26:21.251]    + additional namespaces needed: [n=0] 
[08:26:21.252]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:21.252]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:21.252]  - seeds: <none>
[08:26:21.252]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.252] getGlobalsAndPackages() ...
[08:26:21.252] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.252] Resolving globals: FALSE
[08:26:21.252] Tweak future expression to call with '...' arguments ...
[08:26:21.252] {
[08:26:21.252]     do.call(function(...) {
[08:26:21.252]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.252]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.252]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.252]             on.exit(options(oopts), add = TRUE)
[08:26:21.252]         }
[08:26:21.252]         {
[08:26:21.252]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.252]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.252]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.252]             })
[08:26:21.252]         }
[08:26:21.252]     }, args = future.call.arguments)
[08:26:21.252] }
[08:26:21.253] Tweak future expression to call with '...' arguments ... DONE
[08:26:21.253] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.254] - packages: [1] ‘future.apply’
[08:26:21.254] getGlobalsAndPackages() ... DONE
[08:26:21.254] run() for ‘Future’ ...
[08:26:21.254] - state: ‘created’
[08:26:21.254] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:21.256] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.256] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:21.257]   - Field: ‘label’
[08:26:21.257]   - Field: ‘local’
[08:26:21.257]   - Field: ‘owner’
[08:26:21.257]   - Field: ‘envir’
[08:26:21.257]   - Field: ‘workers’
[08:26:21.257]   - Field: ‘packages’
[08:26:21.257]   - Field: ‘gc’
[08:26:21.257]   - Field: ‘job’
[08:26:21.257]   - Field: ‘conditions’
[08:26:21.258]   - Field: ‘expr’
[08:26:21.258]   - Field: ‘uuid’
[08:26:21.258]   - Field: ‘seed’
[08:26:21.258]   - Field: ‘version’
[08:26:21.258]   - Field: ‘result’
[08:26:21.258]   - Field: ‘asynchronous’
[08:26:21.258]   - Field: ‘calls’
[08:26:21.258]   - Field: ‘globals’
[08:26:21.258]   - Field: ‘stdout’
[08:26:21.258]   - Field: ‘earlySignal’
[08:26:21.259]   - Field: ‘lazy’
[08:26:21.259]   - Field: ‘state’
[08:26:21.259] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:21.259] - Launch lazy future ...
[08:26:21.259] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:21.259] Packages needed by future strategies (n = 0): <none>
[08:26:21.260] {
[08:26:21.260]     {
[08:26:21.260]         {
[08:26:21.260]             ...future.startTime <- base::Sys.time()
[08:26:21.260]             {
[08:26:21.260]                 {
[08:26:21.260]                   {
[08:26:21.260]                     {
[08:26:21.260]                       {
[08:26:21.260]                         base::local({
[08:26:21.260]                           has_future <- base::requireNamespace("future", 
[08:26:21.260]                             quietly = TRUE)
[08:26:21.260]                           if (has_future) {
[08:26:21.260]                             ns <- base::getNamespace("future")
[08:26:21.260]                             version <- ns[[".package"]][["version"]]
[08:26:21.260]                             if (is.null(version)) 
[08:26:21.260]                               version <- utils::packageVersion("future")
[08:26:21.260]                           }
[08:26:21.260]                           else {
[08:26:21.260]                             version <- NULL
[08:26:21.260]                           }
[08:26:21.260]                           if (!has_future || version < "1.8.0") {
[08:26:21.260]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:21.260]                               "", base::R.version$version.string), 
[08:26:21.260]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:21.260]                                 base::R.version$platform, 8 * 
[08:26:21.260]                                   base::.Machine$sizeof.pointer), 
[08:26:21.260]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:21.260]                                 "release", "version")], collapse = " "), 
[08:26:21.260]                               hostname = base::Sys.info()[["nodename"]])
[08:26:21.260]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:21.260]                               info)
[08:26:21.260]                             info <- base::paste(info, collapse = "; ")
[08:26:21.260]                             if (!has_future) {
[08:26:21.260]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:21.260]                                 info)
[08:26:21.260]                             }
[08:26:21.260]                             else {
[08:26:21.260]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:21.260]                                 info, version)
[08:26:21.260]                             }
[08:26:21.260]                             base::stop(msg)
[08:26:21.260]                           }
[08:26:21.260]                         })
[08:26:21.260]                       }
[08:26:21.260]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:21.260]                       base::options(mc.cores = 1L)
[08:26:21.260]                     }
[08:26:21.260]                     base::local({
[08:26:21.260]                       for (pkg in "future.apply") {
[08:26:21.260]                         base::loadNamespace(pkg)
[08:26:21.260]                         base::library(pkg, character.only = TRUE)
[08:26:21.260]                       }
[08:26:21.260]                     })
[08:26:21.260]                   }
[08:26:21.260]                   ...future.strategy.old <- future::plan("list")
[08:26:21.260]                   options(future.plan = NULL)
[08:26:21.260]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.260]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:21.260]                 }
[08:26:21.260]                 ...future.workdir <- getwd()
[08:26:21.260]             }
[08:26:21.260]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:21.260]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:21.260]         }
[08:26:21.260]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:21.260]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:21.260]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:21.260]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:21.260]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:21.260]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:21.260]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:21.260]             base::names(...future.oldOptions))
[08:26:21.260]     }
[08:26:21.260]     if (FALSE) {
[08:26:21.260]     }
[08:26:21.260]     else {
[08:26:21.260]         if (TRUE) {
[08:26:21.260]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:21.260]                 open = "w")
[08:26:21.260]         }
[08:26:21.260]         else {
[08:26:21.260]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:21.260]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:21.260]         }
[08:26:21.260]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:21.260]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:21.260]             base::sink(type = "output", split = FALSE)
[08:26:21.260]             base::close(...future.stdout)
[08:26:21.260]         }, add = TRUE)
[08:26:21.260]     }
[08:26:21.260]     ...future.frame <- base::sys.nframe()
[08:26:21.260]     ...future.conditions <- base::list()
[08:26:21.260]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:21.260]     if (FALSE) {
[08:26:21.260]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:21.260]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:21.260]     }
[08:26:21.260]     ...future.result <- base::tryCatch({
[08:26:21.260]         base::withCallingHandlers({
[08:26:21.260]             ...future.value <- base::withVisible(base::local({
[08:26:21.260]                 withCallingHandlers({
[08:26:21.260]                   {
[08:26:21.260]                     do.call(function(...) {
[08:26:21.260]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.260]                       if (!identical(...future.globals.maxSize.org, 
[08:26:21.260]                         ...future.globals.maxSize)) {
[08:26:21.260]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.260]                         on.exit(options(oopts), add = TRUE)
[08:26:21.260]                       }
[08:26:21.260]                       {
[08:26:21.260]                         lapply(seq_along(...future.elements_ii), 
[08:26:21.260]                           FUN = function(jj) {
[08:26:21.260]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.260]                             ...future.FUN(...future.X_jj, ...)
[08:26:21.260]                           })
[08:26:21.260]                       }
[08:26:21.260]                     }, args = future.call.arguments)
[08:26:21.260]                   }
[08:26:21.260]                 }, immediateCondition = function(cond) {
[08:26:21.260]                   save_rds <- function (object, pathname, ...) 
[08:26:21.260]                   {
[08:26:21.260]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:21.260]                     if (file_test("-f", pathname_tmp)) {
[08:26:21.260]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.260]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:21.260]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.260]                         fi_tmp[["mtime"]])
[08:26:21.260]                     }
[08:26:21.260]                     tryCatch({
[08:26:21.260]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:21.260]                     }, error = function(ex) {
[08:26:21.260]                       msg <- conditionMessage(ex)
[08:26:21.260]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.260]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:21.260]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.260]                         fi_tmp[["mtime"]], msg)
[08:26:21.260]                       ex$message <- msg
[08:26:21.260]                       stop(ex)
[08:26:21.260]                     })
[08:26:21.260]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:21.260]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:21.260]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:21.260]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.260]                       fi <- file.info(pathname)
[08:26:21.260]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:21.260]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.260]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:21.260]                         fi[["size"]], fi[["mtime"]])
[08:26:21.260]                       stop(msg)
[08:26:21.260]                     }
[08:26:21.260]                     invisible(pathname)
[08:26:21.260]                   }
[08:26:21.260]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:21.260]                     rootPath = tempdir()) 
[08:26:21.260]                   {
[08:26:21.260]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:21.260]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:21.260]                       tmpdir = path, fileext = ".rds")
[08:26:21.260]                     save_rds(obj, file)
[08:26:21.260]                   }
[08:26:21.260]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:21.260]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.260]                   {
[08:26:21.260]                     inherits <- base::inherits
[08:26:21.260]                     invokeRestart <- base::invokeRestart
[08:26:21.260]                     is.null <- base::is.null
[08:26:21.260]                     muffled <- FALSE
[08:26:21.260]                     if (inherits(cond, "message")) {
[08:26:21.260]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:21.260]                       if (muffled) 
[08:26:21.260]                         invokeRestart("muffleMessage")
[08:26:21.260]                     }
[08:26:21.260]                     else if (inherits(cond, "warning")) {
[08:26:21.260]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:21.260]                       if (muffled) 
[08:26:21.260]                         invokeRestart("muffleWarning")
[08:26:21.260]                     }
[08:26:21.260]                     else if (inherits(cond, "condition")) {
[08:26:21.260]                       if (!is.null(pattern)) {
[08:26:21.260]                         computeRestarts <- base::computeRestarts
[08:26:21.260]                         grepl <- base::grepl
[08:26:21.260]                         restarts <- computeRestarts(cond)
[08:26:21.260]                         for (restart in restarts) {
[08:26:21.260]                           name <- restart$name
[08:26:21.260]                           if (is.null(name)) 
[08:26:21.260]                             next
[08:26:21.260]                           if (!grepl(pattern, name)) 
[08:26:21.260]                             next
[08:26:21.260]                           invokeRestart(restart)
[08:26:21.260]                           muffled <- TRUE
[08:26:21.260]                           break
[08:26:21.260]                         }
[08:26:21.260]                       }
[08:26:21.260]                     }
[08:26:21.260]                     invisible(muffled)
[08:26:21.260]                   }
[08:26:21.260]                   muffleCondition(cond)
[08:26:21.260]                 })
[08:26:21.260]             }))
[08:26:21.260]             future::FutureResult(value = ...future.value$value, 
[08:26:21.260]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.260]                   ...future.rng), globalenv = if (FALSE) 
[08:26:21.260]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:21.260]                     ...future.globalenv.names))
[08:26:21.260]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:21.260]         }, condition = base::local({
[08:26:21.260]             c <- base::c
[08:26:21.260]             inherits <- base::inherits
[08:26:21.260]             invokeRestart <- base::invokeRestart
[08:26:21.260]             length <- base::length
[08:26:21.260]             list <- base::list
[08:26:21.260]             seq.int <- base::seq.int
[08:26:21.260]             signalCondition <- base::signalCondition
[08:26:21.260]             sys.calls <- base::sys.calls
[08:26:21.260]             `[[` <- base::`[[`
[08:26:21.260]             `+` <- base::`+`
[08:26:21.260]             `<<-` <- base::`<<-`
[08:26:21.260]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:21.260]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:21.260]                   3L)]
[08:26:21.260]             }
[08:26:21.260]             function(cond) {
[08:26:21.260]                 is_error <- inherits(cond, "error")
[08:26:21.260]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:21.260]                   NULL)
[08:26:21.260]                 if (is_error) {
[08:26:21.260]                   sessionInformation <- function() {
[08:26:21.260]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:21.260]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:21.260]                       search = base::search(), system = base::Sys.info())
[08:26:21.260]                   }
[08:26:21.260]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.260]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:21.260]                     cond$call), session = sessionInformation(), 
[08:26:21.260]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:21.260]                   signalCondition(cond)
[08:26:21.260]                 }
[08:26:21.260]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:21.260]                 "immediateCondition"))) {
[08:26:21.260]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:21.260]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.260]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:21.260]                   if (TRUE && !signal) {
[08:26:21.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.260]                     {
[08:26:21.260]                       inherits <- base::inherits
[08:26:21.260]                       invokeRestart <- base::invokeRestart
[08:26:21.260]                       is.null <- base::is.null
[08:26:21.260]                       muffled <- FALSE
[08:26:21.260]                       if (inherits(cond, "message")) {
[08:26:21.260]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.260]                         if (muffled) 
[08:26:21.260]                           invokeRestart("muffleMessage")
[08:26:21.260]                       }
[08:26:21.260]                       else if (inherits(cond, "warning")) {
[08:26:21.260]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.260]                         if (muffled) 
[08:26:21.260]                           invokeRestart("muffleWarning")
[08:26:21.260]                       }
[08:26:21.260]                       else if (inherits(cond, "condition")) {
[08:26:21.260]                         if (!is.null(pattern)) {
[08:26:21.260]                           computeRestarts <- base::computeRestarts
[08:26:21.260]                           grepl <- base::grepl
[08:26:21.260]                           restarts <- computeRestarts(cond)
[08:26:21.260]                           for (restart in restarts) {
[08:26:21.260]                             name <- restart$name
[08:26:21.260]                             if (is.null(name)) 
[08:26:21.260]                               next
[08:26:21.260]                             if (!grepl(pattern, name)) 
[08:26:21.260]                               next
[08:26:21.260]                             invokeRestart(restart)
[08:26:21.260]                             muffled <- TRUE
[08:26:21.260]                             break
[08:26:21.260]                           }
[08:26:21.260]                         }
[08:26:21.260]                       }
[08:26:21.260]                       invisible(muffled)
[08:26:21.260]                     }
[08:26:21.260]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.260]                   }
[08:26:21.260]                 }
[08:26:21.260]                 else {
[08:26:21.260]                   if (TRUE) {
[08:26:21.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.260]                     {
[08:26:21.260]                       inherits <- base::inherits
[08:26:21.260]                       invokeRestart <- base::invokeRestart
[08:26:21.260]                       is.null <- base::is.null
[08:26:21.260]                       muffled <- FALSE
[08:26:21.260]                       if (inherits(cond, "message")) {
[08:26:21.260]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.260]                         if (muffled) 
[08:26:21.260]                           invokeRestart("muffleMessage")
[08:26:21.260]                       }
[08:26:21.260]                       else if (inherits(cond, "warning")) {
[08:26:21.260]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.260]                         if (muffled) 
[08:26:21.260]                           invokeRestart("muffleWarning")
[08:26:21.260]                       }
[08:26:21.260]                       else if (inherits(cond, "condition")) {
[08:26:21.260]                         if (!is.null(pattern)) {
[08:26:21.260]                           computeRestarts <- base::computeRestarts
[08:26:21.260]                           grepl <- base::grepl
[08:26:21.260]                           restarts <- computeRestarts(cond)
[08:26:21.260]                           for (restart in restarts) {
[08:26:21.260]                             name <- restart$name
[08:26:21.260]                             if (is.null(name)) 
[08:26:21.260]                               next
[08:26:21.260]                             if (!grepl(pattern, name)) 
[08:26:21.260]                               next
[08:26:21.260]                             invokeRestart(restart)
[08:26:21.260]                             muffled <- TRUE
[08:26:21.260]                             break
[08:26:21.260]                           }
[08:26:21.260]                         }
[08:26:21.260]                       }
[08:26:21.260]                       invisible(muffled)
[08:26:21.260]                     }
[08:26:21.260]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.260]                   }
[08:26:21.260]                 }
[08:26:21.260]             }
[08:26:21.260]         }))
[08:26:21.260]     }, error = function(ex) {
[08:26:21.260]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:21.260]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.260]                 ...future.rng), started = ...future.startTime, 
[08:26:21.260]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:21.260]             version = "1.8"), class = "FutureResult")
[08:26:21.260]     }, finally = {
[08:26:21.260]         if (!identical(...future.workdir, getwd())) 
[08:26:21.260]             setwd(...future.workdir)
[08:26:21.260]         {
[08:26:21.260]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:21.260]                 ...future.oldOptions$nwarnings <- NULL
[08:26:21.260]             }
[08:26:21.260]             base::options(...future.oldOptions)
[08:26:21.260]             if (.Platform$OS.type == "windows") {
[08:26:21.260]                 old_names <- names(...future.oldEnvVars)
[08:26:21.260]                 envs <- base::Sys.getenv()
[08:26:21.260]                 names <- names(envs)
[08:26:21.260]                 common <- intersect(names, old_names)
[08:26:21.260]                 added <- setdiff(names, old_names)
[08:26:21.260]                 removed <- setdiff(old_names, names)
[08:26:21.260]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:21.260]                   envs[common]]
[08:26:21.260]                 NAMES <- toupper(changed)
[08:26:21.260]                 args <- list()
[08:26:21.260]                 for (kk in seq_along(NAMES)) {
[08:26:21.260]                   name <- changed[[kk]]
[08:26:21.260]                   NAME <- NAMES[[kk]]
[08:26:21.260]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.260]                     next
[08:26:21.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.260]                 }
[08:26:21.260]                 NAMES <- toupper(added)
[08:26:21.260]                 for (kk in seq_along(NAMES)) {
[08:26:21.260]                   name <- added[[kk]]
[08:26:21.260]                   NAME <- NAMES[[kk]]
[08:26:21.260]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.260]                     next
[08:26:21.260]                   args[[name]] <- ""
[08:26:21.260]                 }
[08:26:21.260]                 NAMES <- toupper(removed)
[08:26:21.260]                 for (kk in seq_along(NAMES)) {
[08:26:21.260]                   name <- removed[[kk]]
[08:26:21.260]                   NAME <- NAMES[[kk]]
[08:26:21.260]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.260]                     next
[08:26:21.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.260]                 }
[08:26:21.260]                 if (length(args) > 0) 
[08:26:21.260]                   base::do.call(base::Sys.setenv, args = args)
[08:26:21.260]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:21.260]             }
[08:26:21.260]             else {
[08:26:21.260]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:21.260]             }
[08:26:21.260]             {
[08:26:21.260]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:21.260]                   0L) {
[08:26:21.260]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:21.260]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:21.260]                   base::options(opts)
[08:26:21.260]                 }
[08:26:21.260]                 {
[08:26:21.260]                   {
[08:26:21.260]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:21.260]                     NULL
[08:26:21.260]                   }
[08:26:21.260]                   options(future.plan = NULL)
[08:26:21.260]                   if (is.na(NA_character_)) 
[08:26:21.260]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.260]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:21.260]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:21.260]                     .init = FALSE)
[08:26:21.260]                 }
[08:26:21.260]             }
[08:26:21.260]         }
[08:26:21.260]     })
[08:26:21.260]     if (TRUE) {
[08:26:21.260]         base::sink(type = "output", split = FALSE)
[08:26:21.260]         if (TRUE) {
[08:26:21.260]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:21.260]         }
[08:26:21.260]         else {
[08:26:21.260]             ...future.result["stdout"] <- base::list(NULL)
[08:26:21.260]         }
[08:26:21.260]         base::close(...future.stdout)
[08:26:21.260]         ...future.stdout <- NULL
[08:26:21.260]     }
[08:26:21.260]     ...future.result$conditions <- ...future.conditions
[08:26:21.260]     ...future.result$finished <- base::Sys.time()
[08:26:21.260]     ...future.result
[08:26:21.260] }
[08:26:21.262] assign_globals() ...
[08:26:21.262] List of 11
[08:26:21.262]  $ ...future.FUN            :function (x, ...)  
[08:26:21.262]  $ x_FUN                    :function (x, y)  
[08:26:21.262]  $ times                    : int 15
[08:26:21.262]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:21.262]  $ stop_if_not              :function (...)  
[08:26:21.262]  $ dim                      : int [1:2] 3 5
[08:26:21.262]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:21.262]  $ future.call.arguments    :List of 1
[08:26:21.262]   ..$ y: num [1:5] 2 4 6 8 10
[08:26:21.262]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:21.262]  $ ...future.elements_ii    :List of 2
[08:26:21.262]   ..$ A: num 50
[08:26:21.262]   ..$ B: num 60
[08:26:21.262]  $ ...future.seeds_ii       : NULL
[08:26:21.262]  $ ...future.globals.maxSize: NULL
[08:26:21.262]  - attr(*, "where")=List of 11
[08:26:21.262]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:21.262]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:21.262]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:21.262]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:21.262]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:21.262]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:21.262]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:21.262]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:21.262]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:21.262]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:21.262]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:21.262]  - attr(*, "resolved")= logi FALSE
[08:26:21.262]  - attr(*, "total_size")= num 26659
[08:26:21.262]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:21.262]  - attr(*, "already-done")= logi TRUE
[08:26:21.271] - copied ‘...future.FUN’ to environment
[08:26:21.271] - reassign environment for ‘x_FUN’
[08:26:21.271] - copied ‘x_FUN’ to environment
[08:26:21.271] - copied ‘times’ to environment
[08:26:21.271] - copied ‘stopf’ to environment
[08:26:21.271] - copied ‘stop_if_not’ to environment
[08:26:21.271] - copied ‘dim’ to environment
[08:26:21.271] - copied ‘valid_types’ to environment
[08:26:21.271] - copied ‘future.call.arguments’ to environment
[08:26:21.271] - copied ‘...future.elements_ii’ to environment
[08:26:21.272] - copied ‘...future.seeds_ii’ to environment
[08:26:21.272] - copied ‘...future.globals.maxSize’ to environment
[08:26:21.272] assign_globals() ... done
[08:26:21.272] requestCore(): workers = 2
[08:26:21.274] MulticoreFuture started
[08:26:21.275] - Launch lazy future ... done
[08:26:21.279] run() for ‘MulticoreFuture’ ... done
[08:26:21.280] Created future:
[08:26:21.280] plan(): Setting new future strategy stack:
[08:26:21.280] List of future strategies:
[08:26:21.280] 1. sequential:
[08:26:21.280]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:21.280]    - tweaked: FALSE
[08:26:21.280]    - call: NULL
[08:26:21.282] plan(): nbrOfWorkers() = 1
[08:26:21.285] plan(): Setting new future strategy stack:
[08:26:21.286] List of future strategies:
[08:26:21.286] 1. multicore:
[08:26:21.286]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:21.286]    - tweaked: FALSE
[08:26:21.286]    - call: plan(strategy)
[08:26:21.290] plan(): nbrOfWorkers() = 2
[08:26:21.280] MulticoreFuture:
[08:26:21.280] Label: ‘future_vapply-1’
[08:26:21.280] Expression:
[08:26:21.280] {
[08:26:21.280]     do.call(function(...) {
[08:26:21.280]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.280]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.280]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.280]             on.exit(options(oopts), add = TRUE)
[08:26:21.280]         }
[08:26:21.280]         {
[08:26:21.280]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.280]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.280]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.280]             })
[08:26:21.280]         }
[08:26:21.280]     }, args = future.call.arguments)
[08:26:21.280] }
[08:26:21.280] Lazy evaluation: FALSE
[08:26:21.280] Asynchronous evaluation: TRUE
[08:26:21.280] Local evaluation: TRUE
[08:26:21.280] Environment: R_GlobalEnv
[08:26:21.280] Capture standard output: TRUE
[08:26:21.280] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:21.280] Globals: 11 objects totaling 14.66 KiB (function ‘...future.FUN’ of 5.67 KiB, function ‘x_FUN’ of 680 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:21.280] Packages: 1 packages (‘future.apply’)
[08:26:21.280] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:21.280] Resolved: TRUE
[08:26:21.280] Value: <not collected>
[08:26:21.280] Conditions captured: <none>
[08:26:21.280] Early signaling: FALSE
[08:26:21.280] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:21.280] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.291] Chunk #1 of 2 ... DONE
[08:26:21.291] Chunk #2 of 2 ...
[08:26:21.291]  - Finding globals in 'X' for chunk #2 ...
[08:26:21.292] getGlobalsAndPackages() ...
[08:26:21.292] Searching for globals...
[08:26:21.292] 
[08:26:21.293] Searching for globals ... DONE
[08:26:21.293] - globals: [0] <none>
[08:26:21.293] getGlobalsAndPackages() ... DONE
[08:26:21.293]    + additional globals found: [n=0] 
[08:26:21.293]    + additional namespaces needed: [n=0] 
[08:26:21.293]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:21.294]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:21.294]  - seeds: <none>
[08:26:21.294]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.294] getGlobalsAndPackages() ...
[08:26:21.294] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.295] Resolving globals: FALSE
[08:26:21.295] Tweak future expression to call with '...' arguments ...
[08:26:21.295] {
[08:26:21.295]     do.call(function(...) {
[08:26:21.295]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.295]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.295]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.295]             on.exit(options(oopts), add = TRUE)
[08:26:21.295]         }
[08:26:21.295]         {
[08:26:21.295]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.295]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.295]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.295]             })
[08:26:21.295]         }
[08:26:21.295]     }, args = future.call.arguments)
[08:26:21.295] }
[08:26:21.296] Tweak future expression to call with '...' arguments ... DONE
[08:26:21.297] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.297] - packages: [1] ‘future.apply’
[08:26:21.297] getGlobalsAndPackages() ... DONE
[08:26:21.298] run() for ‘Future’ ...
[08:26:21.298] - state: ‘created’
[08:26:21.298] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:21.302] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.302] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:21.302]   - Field: ‘label’
[08:26:21.302]   - Field: ‘local’
[08:26:21.303]   - Field: ‘owner’
[08:26:21.303]   - Field: ‘envir’
[08:26:21.303]   - Field: ‘workers’
[08:26:21.303]   - Field: ‘packages’
[08:26:21.303]   - Field: ‘gc’
[08:26:21.303]   - Field: ‘job’
[08:26:21.304]   - Field: ‘conditions’
[08:26:21.304]   - Field: ‘expr’
[08:26:21.304]   - Field: ‘uuid’
[08:26:21.304]   - Field: ‘seed’
[08:26:21.304]   - Field: ‘version’
[08:26:21.304]   - Field: ‘result’
[08:26:21.304]   - Field: ‘asynchronous’
[08:26:21.305]   - Field: ‘calls’
[08:26:21.305]   - Field: ‘globals’
[08:26:21.305]   - Field: ‘stdout’
[08:26:21.305]   - Field: ‘earlySignal’
[08:26:21.305]   - Field: ‘lazy’
[08:26:21.305]   - Field: ‘state’
[08:26:21.305] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:21.305] - Launch lazy future ...
[08:26:21.306] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:21.306] Packages needed by future strategies (n = 0): <none>
[08:26:21.307] {
[08:26:21.307]     {
[08:26:21.307]         {
[08:26:21.307]             ...future.startTime <- base::Sys.time()
[08:26:21.307]             {
[08:26:21.307]                 {
[08:26:21.307]                   {
[08:26:21.307]                     {
[08:26:21.307]                       {
[08:26:21.307]                         base::local({
[08:26:21.307]                           has_future <- base::requireNamespace("future", 
[08:26:21.307]                             quietly = TRUE)
[08:26:21.307]                           if (has_future) {
[08:26:21.307]                             ns <- base::getNamespace("future")
[08:26:21.307]                             version <- ns[[".package"]][["version"]]
[08:26:21.307]                             if (is.null(version)) 
[08:26:21.307]                               version <- utils::packageVersion("future")
[08:26:21.307]                           }
[08:26:21.307]                           else {
[08:26:21.307]                             version <- NULL
[08:26:21.307]                           }
[08:26:21.307]                           if (!has_future || version < "1.8.0") {
[08:26:21.307]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:21.307]                               "", base::R.version$version.string), 
[08:26:21.307]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:21.307]                                 base::R.version$platform, 8 * 
[08:26:21.307]                                   base::.Machine$sizeof.pointer), 
[08:26:21.307]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:21.307]                                 "release", "version")], collapse = " "), 
[08:26:21.307]                               hostname = base::Sys.info()[["nodename"]])
[08:26:21.307]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:21.307]                               info)
[08:26:21.307]                             info <- base::paste(info, collapse = "; ")
[08:26:21.307]                             if (!has_future) {
[08:26:21.307]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:21.307]                                 info)
[08:26:21.307]                             }
[08:26:21.307]                             else {
[08:26:21.307]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:21.307]                                 info, version)
[08:26:21.307]                             }
[08:26:21.307]                             base::stop(msg)
[08:26:21.307]                           }
[08:26:21.307]                         })
[08:26:21.307]                       }
[08:26:21.307]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:21.307]                       base::options(mc.cores = 1L)
[08:26:21.307]                     }
[08:26:21.307]                     base::local({
[08:26:21.307]                       for (pkg in "future.apply") {
[08:26:21.307]                         base::loadNamespace(pkg)
[08:26:21.307]                         base::library(pkg, character.only = TRUE)
[08:26:21.307]                       }
[08:26:21.307]                     })
[08:26:21.307]                   }
[08:26:21.307]                   ...future.strategy.old <- future::plan("list")
[08:26:21.307]                   options(future.plan = NULL)
[08:26:21.307]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.307]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:21.307]                 }
[08:26:21.307]                 ...future.workdir <- getwd()
[08:26:21.307]             }
[08:26:21.307]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:21.307]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:21.307]         }
[08:26:21.307]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:21.307]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:21.307]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:21.307]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:21.307]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:21.307]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:21.307]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:21.307]             base::names(...future.oldOptions))
[08:26:21.307]     }
[08:26:21.307]     if (FALSE) {
[08:26:21.307]     }
[08:26:21.307]     else {
[08:26:21.307]         if (TRUE) {
[08:26:21.307]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:21.307]                 open = "w")
[08:26:21.307]         }
[08:26:21.307]         else {
[08:26:21.307]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:21.307]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:21.307]         }
[08:26:21.307]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:21.307]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:21.307]             base::sink(type = "output", split = FALSE)
[08:26:21.307]             base::close(...future.stdout)
[08:26:21.307]         }, add = TRUE)
[08:26:21.307]     }
[08:26:21.307]     ...future.frame <- base::sys.nframe()
[08:26:21.307]     ...future.conditions <- base::list()
[08:26:21.307]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:21.307]     if (FALSE) {
[08:26:21.307]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:21.307]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:21.307]     }
[08:26:21.307]     ...future.result <- base::tryCatch({
[08:26:21.307]         base::withCallingHandlers({
[08:26:21.307]             ...future.value <- base::withVisible(base::local({
[08:26:21.307]                 withCallingHandlers({
[08:26:21.307]                   {
[08:26:21.307]                     do.call(function(...) {
[08:26:21.307]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.307]                       if (!identical(...future.globals.maxSize.org, 
[08:26:21.307]                         ...future.globals.maxSize)) {
[08:26:21.307]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.307]                         on.exit(options(oopts), add = TRUE)
[08:26:21.307]                       }
[08:26:21.307]                       {
[08:26:21.307]                         lapply(seq_along(...future.elements_ii), 
[08:26:21.307]                           FUN = function(jj) {
[08:26:21.307]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.307]                             ...future.FUN(...future.X_jj, ...)
[08:26:21.307]                           })
[08:26:21.307]                       }
[08:26:21.307]                     }, args = future.call.arguments)
[08:26:21.307]                   }
[08:26:21.307]                 }, immediateCondition = function(cond) {
[08:26:21.307]                   save_rds <- function (object, pathname, ...) 
[08:26:21.307]                   {
[08:26:21.307]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:21.307]                     if (file_test("-f", pathname_tmp)) {
[08:26:21.307]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.307]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:21.307]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.307]                         fi_tmp[["mtime"]])
[08:26:21.307]                     }
[08:26:21.307]                     tryCatch({
[08:26:21.307]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:21.307]                     }, error = function(ex) {
[08:26:21.307]                       msg <- conditionMessage(ex)
[08:26:21.307]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.307]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:21.307]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.307]                         fi_tmp[["mtime"]], msg)
[08:26:21.307]                       ex$message <- msg
[08:26:21.307]                       stop(ex)
[08:26:21.307]                     })
[08:26:21.307]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:21.307]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:21.307]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:21.307]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.307]                       fi <- file.info(pathname)
[08:26:21.307]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:21.307]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.307]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:21.307]                         fi[["size"]], fi[["mtime"]])
[08:26:21.307]                       stop(msg)
[08:26:21.307]                     }
[08:26:21.307]                     invisible(pathname)
[08:26:21.307]                   }
[08:26:21.307]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:21.307]                     rootPath = tempdir()) 
[08:26:21.307]                   {
[08:26:21.307]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:21.307]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:21.307]                       tmpdir = path, fileext = ".rds")
[08:26:21.307]                     save_rds(obj, file)
[08:26:21.307]                   }
[08:26:21.307]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:21.307]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.307]                   {
[08:26:21.307]                     inherits <- base::inherits
[08:26:21.307]                     invokeRestart <- base::invokeRestart
[08:26:21.307]                     is.null <- base::is.null
[08:26:21.307]                     muffled <- FALSE
[08:26:21.307]                     if (inherits(cond, "message")) {
[08:26:21.307]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:21.307]                       if (muffled) 
[08:26:21.307]                         invokeRestart("muffleMessage")
[08:26:21.307]                     }
[08:26:21.307]                     else if (inherits(cond, "warning")) {
[08:26:21.307]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:21.307]                       if (muffled) 
[08:26:21.307]                         invokeRestart("muffleWarning")
[08:26:21.307]                     }
[08:26:21.307]                     else if (inherits(cond, "condition")) {
[08:26:21.307]                       if (!is.null(pattern)) {
[08:26:21.307]                         computeRestarts <- base::computeRestarts
[08:26:21.307]                         grepl <- base::grepl
[08:26:21.307]                         restarts <- computeRestarts(cond)
[08:26:21.307]                         for (restart in restarts) {
[08:26:21.307]                           name <- restart$name
[08:26:21.307]                           if (is.null(name)) 
[08:26:21.307]                             next
[08:26:21.307]                           if (!grepl(pattern, name)) 
[08:26:21.307]                             next
[08:26:21.307]                           invokeRestart(restart)
[08:26:21.307]                           muffled <- TRUE
[08:26:21.307]                           break
[08:26:21.307]                         }
[08:26:21.307]                       }
[08:26:21.307]                     }
[08:26:21.307]                     invisible(muffled)
[08:26:21.307]                   }
[08:26:21.307]                   muffleCondition(cond)
[08:26:21.307]                 })
[08:26:21.307]             }))
[08:26:21.307]             future::FutureResult(value = ...future.value$value, 
[08:26:21.307]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.307]                   ...future.rng), globalenv = if (FALSE) 
[08:26:21.307]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:21.307]                     ...future.globalenv.names))
[08:26:21.307]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:21.307]         }, condition = base::local({
[08:26:21.307]             c <- base::c
[08:26:21.307]             inherits <- base::inherits
[08:26:21.307]             invokeRestart <- base::invokeRestart
[08:26:21.307]             length <- base::length
[08:26:21.307]             list <- base::list
[08:26:21.307]             seq.int <- base::seq.int
[08:26:21.307]             signalCondition <- base::signalCondition
[08:26:21.307]             sys.calls <- base::sys.calls
[08:26:21.307]             `[[` <- base::`[[`
[08:26:21.307]             `+` <- base::`+`
[08:26:21.307]             `<<-` <- base::`<<-`
[08:26:21.307]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:21.307]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:21.307]                   3L)]
[08:26:21.307]             }
[08:26:21.307]             function(cond) {
[08:26:21.307]                 is_error <- inherits(cond, "error")
[08:26:21.307]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:21.307]                   NULL)
[08:26:21.307]                 if (is_error) {
[08:26:21.307]                   sessionInformation <- function() {
[08:26:21.307]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:21.307]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:21.307]                       search = base::search(), system = base::Sys.info())
[08:26:21.307]                   }
[08:26:21.307]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.307]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:21.307]                     cond$call), session = sessionInformation(), 
[08:26:21.307]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:21.307]                   signalCondition(cond)
[08:26:21.307]                 }
[08:26:21.307]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:21.307]                 "immediateCondition"))) {
[08:26:21.307]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:21.307]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.307]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:21.307]                   if (TRUE && !signal) {
[08:26:21.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.307]                     {
[08:26:21.307]                       inherits <- base::inherits
[08:26:21.307]                       invokeRestart <- base::invokeRestart
[08:26:21.307]                       is.null <- base::is.null
[08:26:21.307]                       muffled <- FALSE
[08:26:21.307]                       if (inherits(cond, "message")) {
[08:26:21.307]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.307]                         if (muffled) 
[08:26:21.307]                           invokeRestart("muffleMessage")
[08:26:21.307]                       }
[08:26:21.307]                       else if (inherits(cond, "warning")) {
[08:26:21.307]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.307]                         if (muffled) 
[08:26:21.307]                           invokeRestart("muffleWarning")
[08:26:21.307]                       }
[08:26:21.307]                       else if (inherits(cond, "condition")) {
[08:26:21.307]                         if (!is.null(pattern)) {
[08:26:21.307]                           computeRestarts <- base::computeRestarts
[08:26:21.307]                           grepl <- base::grepl
[08:26:21.307]                           restarts <- computeRestarts(cond)
[08:26:21.307]                           for (restart in restarts) {
[08:26:21.307]                             name <- restart$name
[08:26:21.307]                             if (is.null(name)) 
[08:26:21.307]                               next
[08:26:21.307]                             if (!grepl(pattern, name)) 
[08:26:21.307]                               next
[08:26:21.307]                             invokeRestart(restart)
[08:26:21.307]                             muffled <- TRUE
[08:26:21.307]                             break
[08:26:21.307]                           }
[08:26:21.307]                         }
[08:26:21.307]                       }
[08:26:21.307]                       invisible(muffled)
[08:26:21.307]                     }
[08:26:21.307]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.307]                   }
[08:26:21.307]                 }
[08:26:21.307]                 else {
[08:26:21.307]                   if (TRUE) {
[08:26:21.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.307]                     {
[08:26:21.307]                       inherits <- base::inherits
[08:26:21.307]                       invokeRestart <- base::invokeRestart
[08:26:21.307]                       is.null <- base::is.null
[08:26:21.307]                       muffled <- FALSE
[08:26:21.307]                       if (inherits(cond, "message")) {
[08:26:21.307]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.307]                         if (muffled) 
[08:26:21.307]                           invokeRestart("muffleMessage")
[08:26:21.307]                       }
[08:26:21.307]                       else if (inherits(cond, "warning")) {
[08:26:21.307]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.307]                         if (muffled) 
[08:26:21.307]                           invokeRestart("muffleWarning")
[08:26:21.307]                       }
[08:26:21.307]                       else if (inherits(cond, "condition")) {
[08:26:21.307]                         if (!is.null(pattern)) {
[08:26:21.307]                           computeRestarts <- base::computeRestarts
[08:26:21.307]                           grepl <- base::grepl
[08:26:21.307]                           restarts <- computeRestarts(cond)
[08:26:21.307]                           for (restart in restarts) {
[08:26:21.307]                             name <- restart$name
[08:26:21.307]                             if (is.null(name)) 
[08:26:21.307]                               next
[08:26:21.307]                             if (!grepl(pattern, name)) 
[08:26:21.307]                               next
[08:26:21.307]                             invokeRestart(restart)
[08:26:21.307]                             muffled <- TRUE
[08:26:21.307]                             break
[08:26:21.307]                           }
[08:26:21.307]                         }
[08:26:21.307]                       }
[08:26:21.307]                       invisible(muffled)
[08:26:21.307]                     }
[08:26:21.307]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.307]                   }
[08:26:21.307]                 }
[08:26:21.307]             }
[08:26:21.307]         }))
[08:26:21.307]     }, error = function(ex) {
[08:26:21.307]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:21.307]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.307]                 ...future.rng), started = ...future.startTime, 
[08:26:21.307]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:21.307]             version = "1.8"), class = "FutureResult")
[08:26:21.307]     }, finally = {
[08:26:21.307]         if (!identical(...future.workdir, getwd())) 
[08:26:21.307]             setwd(...future.workdir)
[08:26:21.307]         {
[08:26:21.307]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:21.307]                 ...future.oldOptions$nwarnings <- NULL
[08:26:21.307]             }
[08:26:21.307]             base::options(...future.oldOptions)
[08:26:21.307]             if (.Platform$OS.type == "windows") {
[08:26:21.307]                 old_names <- names(...future.oldEnvVars)
[08:26:21.307]                 envs <- base::Sys.getenv()
[08:26:21.307]                 names <- names(envs)
[08:26:21.307]                 common <- intersect(names, old_names)
[08:26:21.307]                 added <- setdiff(names, old_names)
[08:26:21.307]                 removed <- setdiff(old_names, names)
[08:26:21.307]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:21.307]                   envs[common]]
[08:26:21.307]                 NAMES <- toupper(changed)
[08:26:21.307]                 args <- list()
[08:26:21.307]                 for (kk in seq_along(NAMES)) {
[08:26:21.307]                   name <- changed[[kk]]
[08:26:21.307]                   NAME <- NAMES[[kk]]
[08:26:21.307]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.307]                     next
[08:26:21.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.307]                 }
[08:26:21.307]                 NAMES <- toupper(added)
[08:26:21.307]                 for (kk in seq_along(NAMES)) {
[08:26:21.307]                   name <- added[[kk]]
[08:26:21.307]                   NAME <- NAMES[[kk]]
[08:26:21.307]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.307]                     next
[08:26:21.307]                   args[[name]] <- ""
[08:26:21.307]                 }
[08:26:21.307]                 NAMES <- toupper(removed)
[08:26:21.307]                 for (kk in seq_along(NAMES)) {
[08:26:21.307]                   name <- removed[[kk]]
[08:26:21.307]                   NAME <- NAMES[[kk]]
[08:26:21.307]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.307]                     next
[08:26:21.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.307]                 }
[08:26:21.307]                 if (length(args) > 0) 
[08:26:21.307]                   base::do.call(base::Sys.setenv, args = args)
[08:26:21.307]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:21.307]             }
[08:26:21.307]             else {
[08:26:21.307]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:21.307]             }
[08:26:21.307]             {
[08:26:21.307]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:21.307]                   0L) {
[08:26:21.307]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:21.307]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:21.307]                   base::options(opts)
[08:26:21.307]                 }
[08:26:21.307]                 {
[08:26:21.307]                   {
[08:26:21.307]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:21.307]                     NULL
[08:26:21.307]                   }
[08:26:21.307]                   options(future.plan = NULL)
[08:26:21.307]                   if (is.na(NA_character_)) 
[08:26:21.307]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.307]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:21.307]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:21.307]                     .init = FALSE)
[08:26:21.307]                 }
[08:26:21.307]             }
[08:26:21.307]         }
[08:26:21.307]     })
[08:26:21.307]     if (TRUE) {
[08:26:21.307]         base::sink(type = "output", split = FALSE)
[08:26:21.307]         if (TRUE) {
[08:26:21.307]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:21.307]         }
[08:26:21.307]         else {
[08:26:21.307]             ...future.result["stdout"] <- base::list(NULL)
[08:26:21.307]         }
[08:26:21.307]         base::close(...future.stdout)
[08:26:21.307]         ...future.stdout <- NULL
[08:26:21.307]     }
[08:26:21.307]     ...future.result$conditions <- ...future.conditions
[08:26:21.307]     ...future.result$finished <- base::Sys.time()
[08:26:21.307]     ...future.result
[08:26:21.307] }
[08:26:21.310] assign_globals() ...
[08:26:21.310] List of 11
[08:26:21.310]  $ ...future.FUN            :function (x, ...)  
[08:26:21.310]  $ x_FUN                    :function (x, y)  
[08:26:21.310]  $ times                    : int 15
[08:26:21.310]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:21.310]  $ stop_if_not              :function (...)  
[08:26:21.310]  $ dim                      : int [1:2] 3 5
[08:26:21.310]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:21.310]  $ future.call.arguments    :List of 1
[08:26:21.310]   ..$ y: num [1:5] 2 4 6 8 10
[08:26:21.310]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:21.310]  $ ...future.elements_ii    :List of 2
[08:26:21.310]   ..$ C: num 70
[08:26:21.310]   ..$ D: num 80
[08:26:21.310]  $ ...future.seeds_ii       : NULL
[08:26:21.310]  $ ...future.globals.maxSize: NULL
[08:26:21.310]  - attr(*, "where")=List of 11
[08:26:21.310]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:21.310]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:21.310]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:21.310]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:21.310]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:21.310]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:21.310]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:21.310]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:21.310]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:21.310]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:21.310]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:21.310]  - attr(*, "resolved")= logi FALSE
[08:26:21.310]  - attr(*, "total_size")= num 26659
[08:26:21.310]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:21.310]  - attr(*, "already-done")= logi TRUE
[08:26:21.320] - copied ‘...future.FUN’ to environment
[08:26:21.320] - reassign environment for ‘x_FUN’
[08:26:21.320] - copied ‘x_FUN’ to environment
[08:26:21.320] - copied ‘times’ to environment
[08:26:21.320] - copied ‘stopf’ to environment
[08:26:21.320] - copied ‘stop_if_not’ to environment
[08:26:21.321] - copied ‘dim’ to environment
[08:26:21.323] - copied ‘valid_types’ to environment
[08:26:21.323] - copied ‘future.call.arguments’ to environment
[08:26:21.323] - copied ‘...future.elements_ii’ to environment
[08:26:21.323] - copied ‘...future.seeds_ii’ to environment
[08:26:21.323] - copied ‘...future.globals.maxSize’ to environment
[08:26:21.324] assign_globals() ... done
[08:26:21.324] requestCore(): workers = 2
[08:26:21.326] MulticoreFuture started
[08:26:21.327] - Launch lazy future ... done
[08:26:21.328] run() for ‘MulticoreFuture’ ... done
[08:26:21.328] Created future:
[08:26:21.329] plan(): Setting new future strategy stack:
[08:26:21.329] List of future strategies:
[08:26:21.329] 1. sequential:
[08:26:21.329]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:21.329]    - tweaked: FALSE
[08:26:21.329]    - call: NULL
[08:26:21.331] plan(): nbrOfWorkers() = 1
[08:26:21.334] plan(): Setting new future strategy stack:
[08:26:21.334] List of future strategies:
[08:26:21.334] 1. multicore:
[08:26:21.334]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:21.334]    - tweaked: FALSE
[08:26:21.334]    - call: plan(strategy)
[08:26:21.339] plan(): nbrOfWorkers() = 2
[08:26:21.329] MulticoreFuture:
[08:26:21.329] Label: ‘future_vapply-2’
[08:26:21.329] Expression:
[08:26:21.329] {
[08:26:21.329]     do.call(function(...) {
[08:26:21.329]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.329]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.329]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.329]             on.exit(options(oopts), add = TRUE)
[08:26:21.329]         }
[08:26:21.329]         {
[08:26:21.329]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.329]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.329]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.329]             })
[08:26:21.329]         }
[08:26:21.329]     }, args = future.call.arguments)
[08:26:21.329] }
[08:26:21.329] Lazy evaluation: FALSE
[08:26:21.329] Asynchronous evaluation: TRUE
[08:26:21.329] Local evaluation: TRUE
[08:26:21.329] Environment: R_GlobalEnv
[08:26:21.329] Capture standard output: TRUE
[08:26:21.329] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:21.329] Globals: 11 objects totaling 14.66 KiB (function ‘...future.FUN’ of 5.67 KiB, function ‘x_FUN’ of 680 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:21.329] Packages: 1 packages (‘future.apply’)
[08:26:21.329] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:21.329] Resolved: TRUE
[08:26:21.329] Value: <not collected>
[08:26:21.329] Conditions captured: <none>
[08:26:21.329] Early signaling: FALSE
[08:26:21.329] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:21.329] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.340] Chunk #2 of 2 ... DONE
[08:26:21.340] Launching 2 futures (chunks) ... DONE
[08:26:21.340] Resolving 2 futures (chunks) ...
[08:26:21.340] resolve() on list ...
[08:26:21.341]  recursive: 0
[08:26:21.341]  length: 2
[08:26:21.341] 
[08:26:21.341] Future #1
[08:26:21.342] result() for MulticoreFuture ...
[08:26:21.343] result() for MulticoreFuture ...
[08:26:21.343] result() for MulticoreFuture ... done
[08:26:21.343] result() for MulticoreFuture ... done
[08:26:21.343] result() for MulticoreFuture ...
[08:26:21.343] result() for MulticoreFuture ... done
[08:26:21.344] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:26:21.344] - nx: 2
[08:26:21.344] - relay: TRUE
[08:26:21.344] - stdout: TRUE
[08:26:21.345] - signal: TRUE
[08:26:21.345] - resignal: FALSE
[08:26:21.345] - force: TRUE
[08:26:21.345] - relayed: [n=2] FALSE, FALSE
[08:26:21.346] - queued futures: [n=2] FALSE, FALSE
[08:26:21.346]  - until=1
[08:26:21.346]  - relaying element #1
[08:26:21.346] result() for MulticoreFuture ...
[08:26:21.346] result() for MulticoreFuture ... done
[08:26:21.347] result() for MulticoreFuture ...
[08:26:21.347] result() for MulticoreFuture ... done
[08:26:21.347] result() for MulticoreFuture ...
[08:26:21.348] result() for MulticoreFuture ... done
[08:26:21.348] result() for MulticoreFuture ...
[08:26:21.348] result() for MulticoreFuture ... done
[08:26:21.348] - relayed: [n=2] TRUE, FALSE
[08:26:21.348] - queued futures: [n=2] TRUE, FALSE
[08:26:21.349] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:26:21.349]  length: 1 (resolved future 1)
[08:26:21.349] Future #2
[08:26:21.349] result() for MulticoreFuture ...
[08:26:21.350] result() for MulticoreFuture ...
[08:26:21.350] result() for MulticoreFuture ... done
[08:26:21.351] result() for MulticoreFuture ... done
[08:26:21.351] result() for MulticoreFuture ...
[08:26:21.351] result() for MulticoreFuture ... done
[08:26:21.351] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:26:21.351] - nx: 2
[08:26:21.351] - relay: TRUE
[08:26:21.351] - stdout: TRUE
[08:26:21.352] - signal: TRUE
[08:26:21.352] - resignal: FALSE
[08:26:21.352] - force: TRUE
[08:26:21.352] - relayed: [n=2] TRUE, FALSE
[08:26:21.352] - queued futures: [n=2] TRUE, FALSE
[08:26:21.352]  - until=2
[08:26:21.352]  - relaying element #2
[08:26:21.352] result() for MulticoreFuture ...
[08:26:21.353] result() for MulticoreFuture ... done
[08:26:21.353] result() for MulticoreFuture ...
[08:26:21.353] result() for MulticoreFuture ... done
[08:26:21.353] result() for MulticoreFuture ...
[08:26:21.353] result() for MulticoreFuture ... done
[08:26:21.353] result() for MulticoreFuture ...
[08:26:21.353] result() for MulticoreFuture ... done
[08:26:21.353] - relayed: [n=2] TRUE, TRUE
[08:26:21.353] - queued futures: [n=2] TRUE, TRUE
[08:26:21.354] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:26:21.354]  length: 0 (resolved future 2)
[08:26:21.354] Relaying remaining futures
[08:26:21.354] signalConditionsASAP(NULL, pos=0) ...
[08:26:21.354] - nx: 2
[08:26:21.354] - relay: TRUE
[08:26:21.354] - stdout: TRUE
[08:26:21.354] - signal: TRUE
[08:26:21.354] - resignal: FALSE
[08:26:21.355] - force: TRUE
[08:26:21.355] - relayed: [n=2] TRUE, TRUE
[08:26:21.355] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:21.355] - relayed: [n=2] TRUE, TRUE
[08:26:21.355] - queued futures: [n=2] TRUE, TRUE
[08:26:21.355] signalConditionsASAP(NULL, pos=0) ... done
[08:26:21.355] resolve() on list ... DONE
[08:26:21.355] result() for MulticoreFuture ...
[08:26:21.355] result() for MulticoreFuture ... done
[08:26:21.355] result() for MulticoreFuture ...
[08:26:21.356] result() for MulticoreFuture ... done
[08:26:21.356] result() for MulticoreFuture ...
[08:26:21.356] result() for MulticoreFuture ... done
[08:26:21.356] result() for MulticoreFuture ...
[08:26:21.356] result() for MulticoreFuture ... done
[08:26:21.356]  - Number of value chunks collected: 2
[08:26:21.356] Resolving 2 futures (chunks) ... DONE
[08:26:21.356] Reducing values from 2 chunks ...
[08:26:21.356]  - Number of values collected after concatenation: 4
[08:26:21.357]  - Number of values expected: 4
[08:26:21.357] Reducing values from 2 chunks ... DONE
[08:26:21.357] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[08:26:21.359] future_lapply() ...
[08:26:21.363] Number of chunks: 2
[08:26:21.363] getGlobalsAndPackagesXApply() ...
[08:26:21.363]  - future.globals: TRUE
[08:26:21.363] getGlobalsAndPackages() ...
[08:26:21.363] Searching for globals...
[08:26:21.369] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[08:26:21.369] Searching for globals ... DONE
[08:26:21.370] Resolving globals: FALSE
[08:26:21.371] The total size of the 7 globals is 14.73 KiB (15079 bytes)
[08:26:21.371] The total size of the 7 globals exported for future expression (‘FUN()’) is 14.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (6.74 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:21.371] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:21.371] - packages: [1] ‘future.apply’
[08:26:21.372] getGlobalsAndPackages() ... DONE
[08:26:21.372]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:21.372]  - needed namespaces: [n=1] ‘future.apply’
[08:26:21.372] Finding globals ... DONE
[08:26:21.372]  - use_args: TRUE
[08:26:21.372]  - Getting '...' globals ...
[08:26:21.373] resolve() on list ...
[08:26:21.373]  recursive: 0
[08:26:21.373]  length: 1
[08:26:21.373]  elements: ‘...’
[08:26:21.373]  length: 0 (resolved future 1)
[08:26:21.373] resolve() on list ... DONE
[08:26:21.373]    - '...' content: [n=0] 
[08:26:21.373] List of 1
[08:26:21.373]  $ ...: list()
[08:26:21.373]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:21.373]  - attr(*, "where")=List of 1
[08:26:21.373]   ..$ ...:<environment: 0x562ca73d41a0> 
[08:26:21.373]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:21.373]  - attr(*, "resolved")= logi TRUE
[08:26:21.373]  - attr(*, "total_size")= num NA
[08:26:21.376]  - Getting '...' globals ... DONE
[08:26:21.377] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:21.377] List of 8
[08:26:21.377]  $ ...future.FUN:function (x, ...)  
[08:26:21.377]  $ x_FUN        :function (x)  
[08:26:21.377]  $ times        : int 1
[08:26:21.377]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:21.377]  $ stop_if_not  :function (...)  
[08:26:21.377]  $ dim          : NULL
[08:26:21.377]  $ valid_types  : chr "logical"
[08:26:21.377]  $ ...          : list()
[08:26:21.377]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:21.377]  - attr(*, "where")=List of 8
[08:26:21.377]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:21.377]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:21.377]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:21.377]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:21.377]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:21.377]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:21.377]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:21.377]   ..$ ...          :<environment: 0x562ca73d41a0> 
[08:26:21.377]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:21.377]  - attr(*, "resolved")= logi FALSE
[08:26:21.377]  - attr(*, "total_size")= num 30734
[08:26:21.382] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:21.382] getGlobalsAndPackagesXApply() ... DONE
[08:26:21.382] Number of futures (= number of chunks): 2
[08:26:21.383] Launching 2 futures (chunks) ...
[08:26:21.383] Chunk #1 of 2 ...
[08:26:21.383]  - Finding globals in 'X' for chunk #1 ...
[08:26:21.383] getGlobalsAndPackages() ...
[08:26:21.383] Searching for globals...
[08:26:21.383] 
[08:26:21.383] Searching for globals ... DONE
[08:26:21.383] - globals: [0] <none>
[08:26:21.384] getGlobalsAndPackages() ... DONE
[08:26:21.384]    + additional globals found: [n=0] 
[08:26:21.384]    + additional namespaces needed: [n=0] 
[08:26:21.384]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:21.384]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:21.384]  - seeds: <none>
[08:26:21.384]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.384] getGlobalsAndPackages() ...
[08:26:21.384] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.384] Resolving globals: FALSE
[08:26:21.385] Tweak future expression to call with '...' arguments ...
[08:26:21.385] {
[08:26:21.385]     do.call(function(...) {
[08:26:21.385]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.385]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.385]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.385]             on.exit(options(oopts), add = TRUE)
[08:26:21.385]         }
[08:26:21.385]         {
[08:26:21.385]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.385]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.385]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.385]             })
[08:26:21.385]         }
[08:26:21.385]     }, args = future.call.arguments)
[08:26:21.385] }
[08:26:21.385] Tweak future expression to call with '...' arguments ... DONE
[08:26:21.385] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.386] - packages: [1] ‘future.apply’
[08:26:21.386] getGlobalsAndPackages() ... DONE
[08:26:21.386] run() for ‘Future’ ...
[08:26:21.386] - state: ‘created’
[08:26:21.386] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:21.388] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.388] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:21.388]   - Field: ‘label’
[08:26:21.388]   - Field: ‘local’
[08:26:21.388]   - Field: ‘owner’
[08:26:21.391]   - Field: ‘envir’
[08:26:21.391]   - Field: ‘workers’
[08:26:21.391]   - Field: ‘packages’
[08:26:21.391]   - Field: ‘gc’
[08:26:21.391]   - Field: ‘job’
[08:26:21.391]   - Field: ‘conditions’
[08:26:21.391]   - Field: ‘expr’
[08:26:21.392]   - Field: ‘uuid’
[08:26:21.392]   - Field: ‘seed’
[08:26:21.392]   - Field: ‘version’
[08:26:21.392]   - Field: ‘result’
[08:26:21.392]   - Field: ‘asynchronous’
[08:26:21.392]   - Field: ‘calls’
[08:26:21.392]   - Field: ‘globals’
[08:26:21.392]   - Field: ‘stdout’
[08:26:21.392]   - Field: ‘earlySignal’
[08:26:21.393]   - Field: ‘lazy’
[08:26:21.393]   - Field: ‘state’
[08:26:21.393] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:21.393] - Launch lazy future ...
[08:26:21.393] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:21.393] Packages needed by future strategies (n = 0): <none>
[08:26:21.394] {
[08:26:21.394]     {
[08:26:21.394]         {
[08:26:21.394]             ...future.startTime <- base::Sys.time()
[08:26:21.394]             {
[08:26:21.394]                 {
[08:26:21.394]                   {
[08:26:21.394]                     {
[08:26:21.394]                       {
[08:26:21.394]                         base::local({
[08:26:21.394]                           has_future <- base::requireNamespace("future", 
[08:26:21.394]                             quietly = TRUE)
[08:26:21.394]                           if (has_future) {
[08:26:21.394]                             ns <- base::getNamespace("future")
[08:26:21.394]                             version <- ns[[".package"]][["version"]]
[08:26:21.394]                             if (is.null(version)) 
[08:26:21.394]                               version <- utils::packageVersion("future")
[08:26:21.394]                           }
[08:26:21.394]                           else {
[08:26:21.394]                             version <- NULL
[08:26:21.394]                           }
[08:26:21.394]                           if (!has_future || version < "1.8.0") {
[08:26:21.394]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:21.394]                               "", base::R.version$version.string), 
[08:26:21.394]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:21.394]                                 base::R.version$platform, 8 * 
[08:26:21.394]                                   base::.Machine$sizeof.pointer), 
[08:26:21.394]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:21.394]                                 "release", "version")], collapse = " "), 
[08:26:21.394]                               hostname = base::Sys.info()[["nodename"]])
[08:26:21.394]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:21.394]                               info)
[08:26:21.394]                             info <- base::paste(info, collapse = "; ")
[08:26:21.394]                             if (!has_future) {
[08:26:21.394]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:21.394]                                 info)
[08:26:21.394]                             }
[08:26:21.394]                             else {
[08:26:21.394]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:21.394]                                 info, version)
[08:26:21.394]                             }
[08:26:21.394]                             base::stop(msg)
[08:26:21.394]                           }
[08:26:21.394]                         })
[08:26:21.394]                       }
[08:26:21.394]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:21.394]                       base::options(mc.cores = 1L)
[08:26:21.394]                     }
[08:26:21.394]                     base::local({
[08:26:21.394]                       for (pkg in "future.apply") {
[08:26:21.394]                         base::loadNamespace(pkg)
[08:26:21.394]                         base::library(pkg, character.only = TRUE)
[08:26:21.394]                       }
[08:26:21.394]                     })
[08:26:21.394]                   }
[08:26:21.394]                   ...future.strategy.old <- future::plan("list")
[08:26:21.394]                   options(future.plan = NULL)
[08:26:21.394]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.394]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:21.394]                 }
[08:26:21.394]                 ...future.workdir <- getwd()
[08:26:21.394]             }
[08:26:21.394]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:21.394]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:21.394]         }
[08:26:21.394]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:21.394]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:21.394]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:21.394]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:21.394]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:21.394]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:21.394]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:21.394]             base::names(...future.oldOptions))
[08:26:21.394]     }
[08:26:21.394]     if (FALSE) {
[08:26:21.394]     }
[08:26:21.394]     else {
[08:26:21.394]         if (TRUE) {
[08:26:21.394]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:21.394]                 open = "w")
[08:26:21.394]         }
[08:26:21.394]         else {
[08:26:21.394]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:21.394]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:21.394]         }
[08:26:21.394]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:21.394]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:21.394]             base::sink(type = "output", split = FALSE)
[08:26:21.394]             base::close(...future.stdout)
[08:26:21.394]         }, add = TRUE)
[08:26:21.394]     }
[08:26:21.394]     ...future.frame <- base::sys.nframe()
[08:26:21.394]     ...future.conditions <- base::list()
[08:26:21.394]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:21.394]     if (FALSE) {
[08:26:21.394]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:21.394]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:21.394]     }
[08:26:21.394]     ...future.result <- base::tryCatch({
[08:26:21.394]         base::withCallingHandlers({
[08:26:21.394]             ...future.value <- base::withVisible(base::local({
[08:26:21.394]                 withCallingHandlers({
[08:26:21.394]                   {
[08:26:21.394]                     do.call(function(...) {
[08:26:21.394]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.394]                       if (!identical(...future.globals.maxSize.org, 
[08:26:21.394]                         ...future.globals.maxSize)) {
[08:26:21.394]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.394]                         on.exit(options(oopts), add = TRUE)
[08:26:21.394]                       }
[08:26:21.394]                       {
[08:26:21.394]                         lapply(seq_along(...future.elements_ii), 
[08:26:21.394]                           FUN = function(jj) {
[08:26:21.394]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.394]                             ...future.FUN(...future.X_jj, ...)
[08:26:21.394]                           })
[08:26:21.394]                       }
[08:26:21.394]                     }, args = future.call.arguments)
[08:26:21.394]                   }
[08:26:21.394]                 }, immediateCondition = function(cond) {
[08:26:21.394]                   save_rds <- function (object, pathname, ...) 
[08:26:21.394]                   {
[08:26:21.394]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:21.394]                     if (file_test("-f", pathname_tmp)) {
[08:26:21.394]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.394]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:21.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.394]                         fi_tmp[["mtime"]])
[08:26:21.394]                     }
[08:26:21.394]                     tryCatch({
[08:26:21.394]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:21.394]                     }, error = function(ex) {
[08:26:21.394]                       msg <- conditionMessage(ex)
[08:26:21.394]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.394]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:21.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.394]                         fi_tmp[["mtime"]], msg)
[08:26:21.394]                       ex$message <- msg
[08:26:21.394]                       stop(ex)
[08:26:21.394]                     })
[08:26:21.394]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:21.394]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:21.394]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:21.394]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.394]                       fi <- file.info(pathname)
[08:26:21.394]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:21.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.394]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:21.394]                         fi[["size"]], fi[["mtime"]])
[08:26:21.394]                       stop(msg)
[08:26:21.394]                     }
[08:26:21.394]                     invisible(pathname)
[08:26:21.394]                   }
[08:26:21.394]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:21.394]                     rootPath = tempdir()) 
[08:26:21.394]                   {
[08:26:21.394]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:21.394]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:21.394]                       tmpdir = path, fileext = ".rds")
[08:26:21.394]                     save_rds(obj, file)
[08:26:21.394]                   }
[08:26:21.394]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:21.394]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.394]                   {
[08:26:21.394]                     inherits <- base::inherits
[08:26:21.394]                     invokeRestart <- base::invokeRestart
[08:26:21.394]                     is.null <- base::is.null
[08:26:21.394]                     muffled <- FALSE
[08:26:21.394]                     if (inherits(cond, "message")) {
[08:26:21.394]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:21.394]                       if (muffled) 
[08:26:21.394]                         invokeRestart("muffleMessage")
[08:26:21.394]                     }
[08:26:21.394]                     else if (inherits(cond, "warning")) {
[08:26:21.394]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:21.394]                       if (muffled) 
[08:26:21.394]                         invokeRestart("muffleWarning")
[08:26:21.394]                     }
[08:26:21.394]                     else if (inherits(cond, "condition")) {
[08:26:21.394]                       if (!is.null(pattern)) {
[08:26:21.394]                         computeRestarts <- base::computeRestarts
[08:26:21.394]                         grepl <- base::grepl
[08:26:21.394]                         restarts <- computeRestarts(cond)
[08:26:21.394]                         for (restart in restarts) {
[08:26:21.394]                           name <- restart$name
[08:26:21.394]                           if (is.null(name)) 
[08:26:21.394]                             next
[08:26:21.394]                           if (!grepl(pattern, name)) 
[08:26:21.394]                             next
[08:26:21.394]                           invokeRestart(restart)
[08:26:21.394]                           muffled <- TRUE
[08:26:21.394]                           break
[08:26:21.394]                         }
[08:26:21.394]                       }
[08:26:21.394]                     }
[08:26:21.394]                     invisible(muffled)
[08:26:21.394]                   }
[08:26:21.394]                   muffleCondition(cond)
[08:26:21.394]                 })
[08:26:21.394]             }))
[08:26:21.394]             future::FutureResult(value = ...future.value$value, 
[08:26:21.394]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.394]                   ...future.rng), globalenv = if (FALSE) 
[08:26:21.394]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:21.394]                     ...future.globalenv.names))
[08:26:21.394]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:21.394]         }, condition = base::local({
[08:26:21.394]             c <- base::c
[08:26:21.394]             inherits <- base::inherits
[08:26:21.394]             invokeRestart <- base::invokeRestart
[08:26:21.394]             length <- base::length
[08:26:21.394]             list <- base::list
[08:26:21.394]             seq.int <- base::seq.int
[08:26:21.394]             signalCondition <- base::signalCondition
[08:26:21.394]             sys.calls <- base::sys.calls
[08:26:21.394]             `[[` <- base::`[[`
[08:26:21.394]             `+` <- base::`+`
[08:26:21.394]             `<<-` <- base::`<<-`
[08:26:21.394]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:21.394]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:21.394]                   3L)]
[08:26:21.394]             }
[08:26:21.394]             function(cond) {
[08:26:21.394]                 is_error <- inherits(cond, "error")
[08:26:21.394]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:21.394]                   NULL)
[08:26:21.394]                 if (is_error) {
[08:26:21.394]                   sessionInformation <- function() {
[08:26:21.394]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:21.394]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:21.394]                       search = base::search(), system = base::Sys.info())
[08:26:21.394]                   }
[08:26:21.394]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.394]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:21.394]                     cond$call), session = sessionInformation(), 
[08:26:21.394]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:21.394]                   signalCondition(cond)
[08:26:21.394]                 }
[08:26:21.394]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:21.394]                 "immediateCondition"))) {
[08:26:21.394]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:21.394]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.394]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:21.394]                   if (TRUE && !signal) {
[08:26:21.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.394]                     {
[08:26:21.394]                       inherits <- base::inherits
[08:26:21.394]                       invokeRestart <- base::invokeRestart
[08:26:21.394]                       is.null <- base::is.null
[08:26:21.394]                       muffled <- FALSE
[08:26:21.394]                       if (inherits(cond, "message")) {
[08:26:21.394]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.394]                         if (muffled) 
[08:26:21.394]                           invokeRestart("muffleMessage")
[08:26:21.394]                       }
[08:26:21.394]                       else if (inherits(cond, "warning")) {
[08:26:21.394]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.394]                         if (muffled) 
[08:26:21.394]                           invokeRestart("muffleWarning")
[08:26:21.394]                       }
[08:26:21.394]                       else if (inherits(cond, "condition")) {
[08:26:21.394]                         if (!is.null(pattern)) {
[08:26:21.394]                           computeRestarts <- base::computeRestarts
[08:26:21.394]                           grepl <- base::grepl
[08:26:21.394]                           restarts <- computeRestarts(cond)
[08:26:21.394]                           for (restart in restarts) {
[08:26:21.394]                             name <- restart$name
[08:26:21.394]                             if (is.null(name)) 
[08:26:21.394]                               next
[08:26:21.394]                             if (!grepl(pattern, name)) 
[08:26:21.394]                               next
[08:26:21.394]                             invokeRestart(restart)
[08:26:21.394]                             muffled <- TRUE
[08:26:21.394]                             break
[08:26:21.394]                           }
[08:26:21.394]                         }
[08:26:21.394]                       }
[08:26:21.394]                       invisible(muffled)
[08:26:21.394]                     }
[08:26:21.394]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.394]                   }
[08:26:21.394]                 }
[08:26:21.394]                 else {
[08:26:21.394]                   if (TRUE) {
[08:26:21.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.394]                     {
[08:26:21.394]                       inherits <- base::inherits
[08:26:21.394]                       invokeRestart <- base::invokeRestart
[08:26:21.394]                       is.null <- base::is.null
[08:26:21.394]                       muffled <- FALSE
[08:26:21.394]                       if (inherits(cond, "message")) {
[08:26:21.394]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.394]                         if (muffled) 
[08:26:21.394]                           invokeRestart("muffleMessage")
[08:26:21.394]                       }
[08:26:21.394]                       else if (inherits(cond, "warning")) {
[08:26:21.394]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.394]                         if (muffled) 
[08:26:21.394]                           invokeRestart("muffleWarning")
[08:26:21.394]                       }
[08:26:21.394]                       else if (inherits(cond, "condition")) {
[08:26:21.394]                         if (!is.null(pattern)) {
[08:26:21.394]                           computeRestarts <- base::computeRestarts
[08:26:21.394]                           grepl <- base::grepl
[08:26:21.394]                           restarts <- computeRestarts(cond)
[08:26:21.394]                           for (restart in restarts) {
[08:26:21.394]                             name <- restart$name
[08:26:21.394]                             if (is.null(name)) 
[08:26:21.394]                               next
[08:26:21.394]                             if (!grepl(pattern, name)) 
[08:26:21.394]                               next
[08:26:21.394]                             invokeRestart(restart)
[08:26:21.394]                             muffled <- TRUE
[08:26:21.394]                             break
[08:26:21.394]                           }
[08:26:21.394]                         }
[08:26:21.394]                       }
[08:26:21.394]                       invisible(muffled)
[08:26:21.394]                     }
[08:26:21.394]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.394]                   }
[08:26:21.394]                 }
[08:26:21.394]             }
[08:26:21.394]         }))
[08:26:21.394]     }, error = function(ex) {
[08:26:21.394]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:21.394]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.394]                 ...future.rng), started = ...future.startTime, 
[08:26:21.394]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:21.394]             version = "1.8"), class = "FutureResult")
[08:26:21.394]     }, finally = {
[08:26:21.394]         if (!identical(...future.workdir, getwd())) 
[08:26:21.394]             setwd(...future.workdir)
[08:26:21.394]         {
[08:26:21.394]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:21.394]                 ...future.oldOptions$nwarnings <- NULL
[08:26:21.394]             }
[08:26:21.394]             base::options(...future.oldOptions)
[08:26:21.394]             if (.Platform$OS.type == "windows") {
[08:26:21.394]                 old_names <- names(...future.oldEnvVars)
[08:26:21.394]                 envs <- base::Sys.getenv()
[08:26:21.394]                 names <- names(envs)
[08:26:21.394]                 common <- intersect(names, old_names)
[08:26:21.394]                 added <- setdiff(names, old_names)
[08:26:21.394]                 removed <- setdiff(old_names, names)
[08:26:21.394]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:21.394]                   envs[common]]
[08:26:21.394]                 NAMES <- toupper(changed)
[08:26:21.394]                 args <- list()
[08:26:21.394]                 for (kk in seq_along(NAMES)) {
[08:26:21.394]                   name <- changed[[kk]]
[08:26:21.394]                   NAME <- NAMES[[kk]]
[08:26:21.394]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.394]                     next
[08:26:21.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.394]                 }
[08:26:21.394]                 NAMES <- toupper(added)
[08:26:21.394]                 for (kk in seq_along(NAMES)) {
[08:26:21.394]                   name <- added[[kk]]
[08:26:21.394]                   NAME <- NAMES[[kk]]
[08:26:21.394]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.394]                     next
[08:26:21.394]                   args[[name]] <- ""
[08:26:21.394]                 }
[08:26:21.394]                 NAMES <- toupper(removed)
[08:26:21.394]                 for (kk in seq_along(NAMES)) {
[08:26:21.394]                   name <- removed[[kk]]
[08:26:21.394]                   NAME <- NAMES[[kk]]
[08:26:21.394]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.394]                     next
[08:26:21.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.394]                 }
[08:26:21.394]                 if (length(args) > 0) 
[08:26:21.394]                   base::do.call(base::Sys.setenv, args = args)
[08:26:21.394]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:21.394]             }
[08:26:21.394]             else {
[08:26:21.394]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:21.394]             }
[08:26:21.394]             {
[08:26:21.394]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:21.394]                   0L) {
[08:26:21.394]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:21.394]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:21.394]                   base::options(opts)
[08:26:21.394]                 }
[08:26:21.394]                 {
[08:26:21.394]                   {
[08:26:21.394]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:21.394]                     NULL
[08:26:21.394]                   }
[08:26:21.394]                   options(future.plan = NULL)
[08:26:21.394]                   if (is.na(NA_character_)) 
[08:26:21.394]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.394]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:21.394]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:21.394]                     .init = FALSE)
[08:26:21.394]                 }
[08:26:21.394]             }
[08:26:21.394]         }
[08:26:21.394]     })
[08:26:21.394]     if (TRUE) {
[08:26:21.394]         base::sink(type = "output", split = FALSE)
[08:26:21.394]         if (TRUE) {
[08:26:21.394]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:21.394]         }
[08:26:21.394]         else {
[08:26:21.394]             ...future.result["stdout"] <- base::list(NULL)
[08:26:21.394]         }
[08:26:21.394]         base::close(...future.stdout)
[08:26:21.394]         ...future.stdout <- NULL
[08:26:21.394]     }
[08:26:21.394]     ...future.result$conditions <- ...future.conditions
[08:26:21.394]     ...future.result$finished <- base::Sys.time()
[08:26:21.394]     ...future.result
[08:26:21.394] }
[08:26:21.397] assign_globals() ...
[08:26:21.397] List of 11
[08:26:21.397]  $ ...future.FUN            :function (x, ...)  
[08:26:21.397]  $ x_FUN                    :function (x)  
[08:26:21.397]  $ times                    : int 1
[08:26:21.397]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:21.397]  $ stop_if_not              :function (...)  
[08:26:21.397]  $ dim                      : NULL
[08:26:21.397]  $ valid_types              : chr "logical"
[08:26:21.397]  $ future.call.arguments    : list()
[08:26:21.397]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:21.397]  $ ...future.elements_ii    :List of 6
[08:26:21.397]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[08:26:21.397]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[08:26:21.397]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[08:26:21.397]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[08:26:21.397]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[08:26:21.397]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[08:26:21.397]  $ ...future.seeds_ii       : NULL
[08:26:21.397]  $ ...future.globals.maxSize: NULL
[08:26:21.397]  - attr(*, "where")=List of 11
[08:26:21.397]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:21.397]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:21.397]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:21.397]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:21.397]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:21.397]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:21.397]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:21.397]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:21.397]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:21.397]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:21.397]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:21.397]  - attr(*, "resolved")= logi FALSE
[08:26:21.397]  - attr(*, "total_size")= num 30734
[08:26:21.397]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:21.397]  - attr(*, "already-done")= logi TRUE
[08:26:21.407] - copied ‘...future.FUN’ to environment
[08:26:21.407] - copied ‘x_FUN’ to environment
[08:26:21.407] - copied ‘times’ to environment
[08:26:21.407] - copied ‘stopf’ to environment
[08:26:21.408] - copied ‘stop_if_not’ to environment
[08:26:21.408] - copied ‘dim’ to environment
[08:26:21.408] - copied ‘valid_types’ to environment
[08:26:21.408] - copied ‘future.call.arguments’ to environment
[08:26:21.408] - copied ‘...future.elements_ii’ to environment
[08:26:21.408] - copied ‘...future.seeds_ii’ to environment
[08:26:21.408] - copied ‘...future.globals.maxSize’ to environment
[08:26:21.408] assign_globals() ... done
[08:26:21.408] requestCore(): workers = 2
[08:26:21.411] MulticoreFuture started
[08:26:21.411] - Launch lazy future ... done
[08:26:21.411] run() for ‘MulticoreFuture’ ... done
[08:26:21.412] Created future:
[08:26:21.412] plan(): Setting new future strategy stack:
[08:26:21.413] List of future strategies:
[08:26:21.413] 1. sequential:
[08:26:21.413]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:21.413]    - tweaked: FALSE
[08:26:21.413]    - call: NULL
[08:26:21.414] plan(): nbrOfWorkers() = 1
[08:26:21.416] plan(): Setting new future strategy stack:
[08:26:21.416] List of future strategies:
[08:26:21.416] 1. multicore:
[08:26:21.416]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:21.416]    - tweaked: FALSE
[08:26:21.416]    - call: plan(strategy)
[08:26:21.420] plan(): nbrOfWorkers() = 2
[08:26:21.412] MulticoreFuture:
[08:26:21.412] Label: ‘future_vapply-1’
[08:26:21.412] Expression:
[08:26:21.412] {
[08:26:21.412]     do.call(function(...) {
[08:26:21.412]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.412]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.412]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.412]             on.exit(options(oopts), add = TRUE)
[08:26:21.412]         }
[08:26:21.412]         {
[08:26:21.412]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.412]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.412]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.412]             })
[08:26:21.412]         }
[08:26:21.412]     }, args = future.call.arguments)
[08:26:21.412] }
[08:26:21.412] Lazy evaluation: FALSE
[08:26:21.412] Asynchronous evaluation: TRUE
[08:26:21.412] Local evaluation: TRUE
[08:26:21.412] Environment: R_GlobalEnv
[08:26:21.412] Capture standard output: TRUE
[08:26:21.412] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:21.412] Globals: 11 objects totaling 16.54 KiB (function ‘...future.FUN’ of 6.73 KiB, function ‘x_FUN’ of 41 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:21.412] Packages: 1 packages (‘future.apply’)
[08:26:21.412] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:21.412] Resolved: TRUE
[08:26:21.412] Value: <not collected>
[08:26:21.412] Conditions captured: <none>
[08:26:21.412] Early signaling: FALSE
[08:26:21.412] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:21.412] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.421] Chunk #1 of 2 ... DONE
[08:26:21.421] Chunk #2 of 2 ...
[08:26:21.421]  - Finding globals in 'X' for chunk #2 ...
[08:26:21.421] getGlobalsAndPackages() ...
[08:26:21.422] Searching for globals...
[08:26:21.422] 
[08:26:21.422] Searching for globals ... DONE
[08:26:21.422] - globals: [0] <none>
[08:26:21.422] getGlobalsAndPackages() ... DONE
[08:26:21.423]    + additional globals found: [n=0] 
[08:26:21.423]    + additional namespaces needed: [n=0] 
[08:26:21.423]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:21.423]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:21.423]  - seeds: <none>
[08:26:21.423]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.423] getGlobalsAndPackages() ...
[08:26:21.424] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.424] Resolving globals: FALSE
[08:26:21.424] Tweak future expression to call with '...' arguments ...
[08:26:21.424] {
[08:26:21.424]     do.call(function(...) {
[08:26:21.424]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.424]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.424]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.424]             on.exit(options(oopts), add = TRUE)
[08:26:21.424]         }
[08:26:21.424]         {
[08:26:21.424]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.424]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.424]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.424]             })
[08:26:21.424]         }
[08:26:21.424]     }, args = future.call.arguments)
[08:26:21.424] }
[08:26:21.425] Tweak future expression to call with '...' arguments ... DONE
[08:26:21.426] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.430] - packages: [1] ‘future.apply’
[08:26:21.430] getGlobalsAndPackages() ... DONE
[08:26:21.431] run() for ‘Future’ ...
[08:26:21.432] - state: ‘created’
[08:26:21.432] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:21.436] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.437] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:21.437]   - Field: ‘label’
[08:26:21.437]   - Field: ‘local’
[08:26:21.437]   - Field: ‘owner’
[08:26:21.438]   - Field: ‘envir’
[08:26:21.438]   - Field: ‘workers’
[08:26:21.438]   - Field: ‘packages’
[08:26:21.438]   - Field: ‘gc’
[08:26:21.438]   - Field: ‘job’
[08:26:21.439]   - Field: ‘conditions’
[08:26:21.439]   - Field: ‘expr’
[08:26:21.439]   - Field: ‘uuid’
[08:26:21.439]   - Field: ‘seed’
[08:26:21.439]   - Field: ‘version’
[08:26:21.439]   - Field: ‘result’
[08:26:21.440]   - Field: ‘asynchronous’
[08:26:21.440]   - Field: ‘calls’
[08:26:21.440]   - Field: ‘globals’
[08:26:21.440]   - Field: ‘stdout’
[08:26:21.440]   - Field: ‘earlySignal’
[08:26:21.441]   - Field: ‘lazy’
[08:26:21.441]   - Field: ‘state’
[08:26:21.441] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:21.441] - Launch lazy future ...
[08:26:21.442] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:21.442] Packages needed by future strategies (n = 0): <none>
[08:26:21.443] {
[08:26:21.443]     {
[08:26:21.443]         {
[08:26:21.443]             ...future.startTime <- base::Sys.time()
[08:26:21.443]             {
[08:26:21.443]                 {
[08:26:21.443]                   {
[08:26:21.443]                     {
[08:26:21.443]                       {
[08:26:21.443]                         base::local({
[08:26:21.443]                           has_future <- base::requireNamespace("future", 
[08:26:21.443]                             quietly = TRUE)
[08:26:21.443]                           if (has_future) {
[08:26:21.443]                             ns <- base::getNamespace("future")
[08:26:21.443]                             version <- ns[[".package"]][["version"]]
[08:26:21.443]                             if (is.null(version)) 
[08:26:21.443]                               version <- utils::packageVersion("future")
[08:26:21.443]                           }
[08:26:21.443]                           else {
[08:26:21.443]                             version <- NULL
[08:26:21.443]                           }
[08:26:21.443]                           if (!has_future || version < "1.8.0") {
[08:26:21.443]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:21.443]                               "", base::R.version$version.string), 
[08:26:21.443]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:21.443]                                 base::R.version$platform, 8 * 
[08:26:21.443]                                   base::.Machine$sizeof.pointer), 
[08:26:21.443]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:21.443]                                 "release", "version")], collapse = " "), 
[08:26:21.443]                               hostname = base::Sys.info()[["nodename"]])
[08:26:21.443]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:21.443]                               info)
[08:26:21.443]                             info <- base::paste(info, collapse = "; ")
[08:26:21.443]                             if (!has_future) {
[08:26:21.443]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:21.443]                                 info)
[08:26:21.443]                             }
[08:26:21.443]                             else {
[08:26:21.443]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:21.443]                                 info, version)
[08:26:21.443]                             }
[08:26:21.443]                             base::stop(msg)
[08:26:21.443]                           }
[08:26:21.443]                         })
[08:26:21.443]                       }
[08:26:21.443]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:21.443]                       base::options(mc.cores = 1L)
[08:26:21.443]                     }
[08:26:21.443]                     base::local({
[08:26:21.443]                       for (pkg in "future.apply") {
[08:26:21.443]                         base::loadNamespace(pkg)
[08:26:21.443]                         base::library(pkg, character.only = TRUE)
[08:26:21.443]                       }
[08:26:21.443]                     })
[08:26:21.443]                   }
[08:26:21.443]                   ...future.strategy.old <- future::plan("list")
[08:26:21.443]                   options(future.plan = NULL)
[08:26:21.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:21.443]                 }
[08:26:21.443]                 ...future.workdir <- getwd()
[08:26:21.443]             }
[08:26:21.443]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:21.443]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:21.443]         }
[08:26:21.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:21.443]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:21.443]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:21.443]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:21.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:21.443]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:21.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:21.443]             base::names(...future.oldOptions))
[08:26:21.443]     }
[08:26:21.443]     if (FALSE) {
[08:26:21.443]     }
[08:26:21.443]     else {
[08:26:21.443]         if (TRUE) {
[08:26:21.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:21.443]                 open = "w")
[08:26:21.443]         }
[08:26:21.443]         else {
[08:26:21.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:21.443]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:21.443]         }
[08:26:21.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:21.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:21.443]             base::sink(type = "output", split = FALSE)
[08:26:21.443]             base::close(...future.stdout)
[08:26:21.443]         }, add = TRUE)
[08:26:21.443]     }
[08:26:21.443]     ...future.frame <- base::sys.nframe()
[08:26:21.443]     ...future.conditions <- base::list()
[08:26:21.443]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:21.443]     if (FALSE) {
[08:26:21.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:21.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:21.443]     }
[08:26:21.443]     ...future.result <- base::tryCatch({
[08:26:21.443]         base::withCallingHandlers({
[08:26:21.443]             ...future.value <- base::withVisible(base::local({
[08:26:21.443]                 withCallingHandlers({
[08:26:21.443]                   {
[08:26:21.443]                     do.call(function(...) {
[08:26:21.443]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.443]                       if (!identical(...future.globals.maxSize.org, 
[08:26:21.443]                         ...future.globals.maxSize)) {
[08:26:21.443]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.443]                         on.exit(options(oopts), add = TRUE)
[08:26:21.443]                       }
[08:26:21.443]                       {
[08:26:21.443]                         lapply(seq_along(...future.elements_ii), 
[08:26:21.443]                           FUN = function(jj) {
[08:26:21.443]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.443]                             ...future.FUN(...future.X_jj, ...)
[08:26:21.443]                           })
[08:26:21.443]                       }
[08:26:21.443]                     }, args = future.call.arguments)
[08:26:21.443]                   }
[08:26:21.443]                 }, immediateCondition = function(cond) {
[08:26:21.443]                   save_rds <- function (object, pathname, ...) 
[08:26:21.443]                   {
[08:26:21.443]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:21.443]                     if (file_test("-f", pathname_tmp)) {
[08:26:21.443]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.443]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:21.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.443]                         fi_tmp[["mtime"]])
[08:26:21.443]                     }
[08:26:21.443]                     tryCatch({
[08:26:21.443]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:21.443]                     }, error = function(ex) {
[08:26:21.443]                       msg <- conditionMessage(ex)
[08:26:21.443]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.443]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:21.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.443]                         fi_tmp[["mtime"]], msg)
[08:26:21.443]                       ex$message <- msg
[08:26:21.443]                       stop(ex)
[08:26:21.443]                     })
[08:26:21.443]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:21.443]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:21.443]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:21.443]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.443]                       fi <- file.info(pathname)
[08:26:21.443]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:21.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.443]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:21.443]                         fi[["size"]], fi[["mtime"]])
[08:26:21.443]                       stop(msg)
[08:26:21.443]                     }
[08:26:21.443]                     invisible(pathname)
[08:26:21.443]                   }
[08:26:21.443]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:21.443]                     rootPath = tempdir()) 
[08:26:21.443]                   {
[08:26:21.443]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:21.443]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:21.443]                       tmpdir = path, fileext = ".rds")
[08:26:21.443]                     save_rds(obj, file)
[08:26:21.443]                   }
[08:26:21.443]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:21.443]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.443]                   {
[08:26:21.443]                     inherits <- base::inherits
[08:26:21.443]                     invokeRestart <- base::invokeRestart
[08:26:21.443]                     is.null <- base::is.null
[08:26:21.443]                     muffled <- FALSE
[08:26:21.443]                     if (inherits(cond, "message")) {
[08:26:21.443]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:21.443]                       if (muffled) 
[08:26:21.443]                         invokeRestart("muffleMessage")
[08:26:21.443]                     }
[08:26:21.443]                     else if (inherits(cond, "warning")) {
[08:26:21.443]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:21.443]                       if (muffled) 
[08:26:21.443]                         invokeRestart("muffleWarning")
[08:26:21.443]                     }
[08:26:21.443]                     else if (inherits(cond, "condition")) {
[08:26:21.443]                       if (!is.null(pattern)) {
[08:26:21.443]                         computeRestarts <- base::computeRestarts
[08:26:21.443]                         grepl <- base::grepl
[08:26:21.443]                         restarts <- computeRestarts(cond)
[08:26:21.443]                         for (restart in restarts) {
[08:26:21.443]                           name <- restart$name
[08:26:21.443]                           if (is.null(name)) 
[08:26:21.443]                             next
[08:26:21.443]                           if (!grepl(pattern, name)) 
[08:26:21.443]                             next
[08:26:21.443]                           invokeRestart(restart)
[08:26:21.443]                           muffled <- TRUE
[08:26:21.443]                           break
[08:26:21.443]                         }
[08:26:21.443]                       }
[08:26:21.443]                     }
[08:26:21.443]                     invisible(muffled)
[08:26:21.443]                   }
[08:26:21.443]                   muffleCondition(cond)
[08:26:21.443]                 })
[08:26:21.443]             }))
[08:26:21.443]             future::FutureResult(value = ...future.value$value, 
[08:26:21.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.443]                   ...future.rng), globalenv = if (FALSE) 
[08:26:21.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:21.443]                     ...future.globalenv.names))
[08:26:21.443]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:21.443]         }, condition = base::local({
[08:26:21.443]             c <- base::c
[08:26:21.443]             inherits <- base::inherits
[08:26:21.443]             invokeRestart <- base::invokeRestart
[08:26:21.443]             length <- base::length
[08:26:21.443]             list <- base::list
[08:26:21.443]             seq.int <- base::seq.int
[08:26:21.443]             signalCondition <- base::signalCondition
[08:26:21.443]             sys.calls <- base::sys.calls
[08:26:21.443]             `[[` <- base::`[[`
[08:26:21.443]             `+` <- base::`+`
[08:26:21.443]             `<<-` <- base::`<<-`
[08:26:21.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:21.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:21.443]                   3L)]
[08:26:21.443]             }
[08:26:21.443]             function(cond) {
[08:26:21.443]                 is_error <- inherits(cond, "error")
[08:26:21.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:21.443]                   NULL)
[08:26:21.443]                 if (is_error) {
[08:26:21.443]                   sessionInformation <- function() {
[08:26:21.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:21.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:21.443]                       search = base::search(), system = base::Sys.info())
[08:26:21.443]                   }
[08:26:21.443]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:21.443]                     cond$call), session = sessionInformation(), 
[08:26:21.443]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:21.443]                   signalCondition(cond)
[08:26:21.443]                 }
[08:26:21.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:21.443]                 "immediateCondition"))) {
[08:26:21.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:21.443]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:21.443]                   if (TRUE && !signal) {
[08:26:21.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.443]                     {
[08:26:21.443]                       inherits <- base::inherits
[08:26:21.443]                       invokeRestart <- base::invokeRestart
[08:26:21.443]                       is.null <- base::is.null
[08:26:21.443]                       muffled <- FALSE
[08:26:21.443]                       if (inherits(cond, "message")) {
[08:26:21.443]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.443]                         if (muffled) 
[08:26:21.443]                           invokeRestart("muffleMessage")
[08:26:21.443]                       }
[08:26:21.443]                       else if (inherits(cond, "warning")) {
[08:26:21.443]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.443]                         if (muffled) 
[08:26:21.443]                           invokeRestart("muffleWarning")
[08:26:21.443]                       }
[08:26:21.443]                       else if (inherits(cond, "condition")) {
[08:26:21.443]                         if (!is.null(pattern)) {
[08:26:21.443]                           computeRestarts <- base::computeRestarts
[08:26:21.443]                           grepl <- base::grepl
[08:26:21.443]                           restarts <- computeRestarts(cond)
[08:26:21.443]                           for (restart in restarts) {
[08:26:21.443]                             name <- restart$name
[08:26:21.443]                             if (is.null(name)) 
[08:26:21.443]                               next
[08:26:21.443]                             if (!grepl(pattern, name)) 
[08:26:21.443]                               next
[08:26:21.443]                             invokeRestart(restart)
[08:26:21.443]                             muffled <- TRUE
[08:26:21.443]                             break
[08:26:21.443]                           }
[08:26:21.443]                         }
[08:26:21.443]                       }
[08:26:21.443]                       invisible(muffled)
[08:26:21.443]                     }
[08:26:21.443]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.443]                   }
[08:26:21.443]                 }
[08:26:21.443]                 else {
[08:26:21.443]                   if (TRUE) {
[08:26:21.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.443]                     {
[08:26:21.443]                       inherits <- base::inherits
[08:26:21.443]                       invokeRestart <- base::invokeRestart
[08:26:21.443]                       is.null <- base::is.null
[08:26:21.443]                       muffled <- FALSE
[08:26:21.443]                       if (inherits(cond, "message")) {
[08:26:21.443]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.443]                         if (muffled) 
[08:26:21.443]                           invokeRestart("muffleMessage")
[08:26:21.443]                       }
[08:26:21.443]                       else if (inherits(cond, "warning")) {
[08:26:21.443]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.443]                         if (muffled) 
[08:26:21.443]                           invokeRestart("muffleWarning")
[08:26:21.443]                       }
[08:26:21.443]                       else if (inherits(cond, "condition")) {
[08:26:21.443]                         if (!is.null(pattern)) {
[08:26:21.443]                           computeRestarts <- base::computeRestarts
[08:26:21.443]                           grepl <- base::grepl
[08:26:21.443]                           restarts <- computeRestarts(cond)
[08:26:21.443]                           for (restart in restarts) {
[08:26:21.443]                             name <- restart$name
[08:26:21.443]                             if (is.null(name)) 
[08:26:21.443]                               next
[08:26:21.443]                             if (!grepl(pattern, name)) 
[08:26:21.443]                               next
[08:26:21.443]                             invokeRestart(restart)
[08:26:21.443]                             muffled <- TRUE
[08:26:21.443]                             break
[08:26:21.443]                           }
[08:26:21.443]                         }
[08:26:21.443]                       }
[08:26:21.443]                       invisible(muffled)
[08:26:21.443]                     }
[08:26:21.443]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.443]                   }
[08:26:21.443]                 }
[08:26:21.443]             }
[08:26:21.443]         }))
[08:26:21.443]     }, error = function(ex) {
[08:26:21.443]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:21.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.443]                 ...future.rng), started = ...future.startTime, 
[08:26:21.443]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:21.443]             version = "1.8"), class = "FutureResult")
[08:26:21.443]     }, finally = {
[08:26:21.443]         if (!identical(...future.workdir, getwd())) 
[08:26:21.443]             setwd(...future.workdir)
[08:26:21.443]         {
[08:26:21.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:21.443]                 ...future.oldOptions$nwarnings <- NULL
[08:26:21.443]             }
[08:26:21.443]             base::options(...future.oldOptions)
[08:26:21.443]             if (.Platform$OS.type == "windows") {
[08:26:21.443]                 old_names <- names(...future.oldEnvVars)
[08:26:21.443]                 envs <- base::Sys.getenv()
[08:26:21.443]                 names <- names(envs)
[08:26:21.443]                 common <- intersect(names, old_names)
[08:26:21.443]                 added <- setdiff(names, old_names)
[08:26:21.443]                 removed <- setdiff(old_names, names)
[08:26:21.443]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:21.443]                   envs[common]]
[08:26:21.443]                 NAMES <- toupper(changed)
[08:26:21.443]                 args <- list()
[08:26:21.443]                 for (kk in seq_along(NAMES)) {
[08:26:21.443]                   name <- changed[[kk]]
[08:26:21.443]                   NAME <- NAMES[[kk]]
[08:26:21.443]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.443]                     next
[08:26:21.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.443]                 }
[08:26:21.443]                 NAMES <- toupper(added)
[08:26:21.443]                 for (kk in seq_along(NAMES)) {
[08:26:21.443]                   name <- added[[kk]]
[08:26:21.443]                   NAME <- NAMES[[kk]]
[08:26:21.443]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.443]                     next
[08:26:21.443]                   args[[name]] <- ""
[08:26:21.443]                 }
[08:26:21.443]                 NAMES <- toupper(removed)
[08:26:21.443]                 for (kk in seq_along(NAMES)) {
[08:26:21.443]                   name <- removed[[kk]]
[08:26:21.443]                   NAME <- NAMES[[kk]]
[08:26:21.443]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.443]                     next
[08:26:21.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.443]                 }
[08:26:21.443]                 if (length(args) > 0) 
[08:26:21.443]                   base::do.call(base::Sys.setenv, args = args)
[08:26:21.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:21.443]             }
[08:26:21.443]             else {
[08:26:21.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:21.443]             }
[08:26:21.443]             {
[08:26:21.443]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:21.443]                   0L) {
[08:26:21.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:21.443]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:21.443]                   base::options(opts)
[08:26:21.443]                 }
[08:26:21.443]                 {
[08:26:21.443]                   {
[08:26:21.443]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:21.443]                     NULL
[08:26:21.443]                   }
[08:26:21.443]                   options(future.plan = NULL)
[08:26:21.443]                   if (is.na(NA_character_)) 
[08:26:21.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:21.443]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:21.443]                     .init = FALSE)
[08:26:21.443]                 }
[08:26:21.443]             }
[08:26:21.443]         }
[08:26:21.443]     })
[08:26:21.443]     if (TRUE) {
[08:26:21.443]         base::sink(type = "output", split = FALSE)
[08:26:21.443]         if (TRUE) {
[08:26:21.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:21.443]         }
[08:26:21.443]         else {
[08:26:21.443]             ...future.result["stdout"] <- base::list(NULL)
[08:26:21.443]         }
[08:26:21.443]         base::close(...future.stdout)
[08:26:21.443]         ...future.stdout <- NULL
[08:26:21.443]     }
[08:26:21.443]     ...future.result$conditions <- ...future.conditions
[08:26:21.443]     ...future.result$finished <- base::Sys.time()
[08:26:21.443]     ...future.result
[08:26:21.443] }
[08:26:21.446] assign_globals() ...
[08:26:21.447] List of 11
[08:26:21.447]  $ ...future.FUN            :function (x, ...)  
[08:26:21.447]  $ x_FUN                    :function (x)  
[08:26:21.447]  $ times                    : int 1
[08:26:21.447]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:21.447]  $ stop_if_not              :function (...)  
[08:26:21.447]  $ dim                      : NULL
[08:26:21.447]  $ valid_types              : chr "logical"
[08:26:21.447]  $ future.call.arguments    : list()
[08:26:21.447]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:21.447]  $ ...future.elements_ii    :List of 5
[08:26:21.447]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[08:26:21.447]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[08:26:21.447]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[08:26:21.447]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[08:26:21.447]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[08:26:21.447]  $ ...future.seeds_ii       : NULL
[08:26:21.447]  $ ...future.globals.maxSize: NULL
[08:26:21.447]  - attr(*, "where")=List of 11
[08:26:21.447]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:21.447]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:21.447]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:21.447]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:21.447]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:21.447]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:21.447]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:21.447]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:21.447]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:21.447]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:21.447]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:21.447]  - attr(*, "resolved")= logi FALSE
[08:26:21.447]  - attr(*, "total_size")= num 30734
[08:26:21.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:21.447]  - attr(*, "already-done")= logi TRUE
[08:26:21.458] - copied ‘...future.FUN’ to environment
[08:26:21.458] - copied ‘x_FUN’ to environment
[08:26:21.459] - copied ‘times’ to environment
[08:26:21.459] - copied ‘stopf’ to environment
[08:26:21.459] - copied ‘stop_if_not’ to environment
[08:26:21.459] - copied ‘dim’ to environment
[08:26:21.459] - copied ‘valid_types’ to environment
[08:26:21.459] - copied ‘future.call.arguments’ to environment
[08:26:21.459] - copied ‘...future.elements_ii’ to environment
[08:26:21.459] - copied ‘...future.seeds_ii’ to environment
[08:26:21.459] - copied ‘...future.globals.maxSize’ to environment
[08:26:21.459] assign_globals() ... done
[08:26:21.460] requestCore(): workers = 2
[08:26:21.462] MulticoreFuture started
[08:26:21.463] - Launch lazy future ... done
[08:26:21.463] run() for ‘MulticoreFuture’ ... done
[08:26:21.464] Created future:
[08:26:21.464] plan(): Setting new future strategy stack:
[08:26:21.465] List of future strategies:
[08:26:21.465] 1. sequential:
[08:26:21.465]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:21.465]    - tweaked: FALSE
[08:26:21.465]    - call: NULL
[08:26:21.466] plan(): nbrOfWorkers() = 1
[08:26:21.469] plan(): Setting new future strategy stack:
[08:26:21.469] List of future strategies:
[08:26:21.469] 1. multicore:
[08:26:21.469]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:21.469]    - tweaked: FALSE
[08:26:21.469]    - call: plan(strategy)
[08:26:21.464] MulticoreFuture:
[08:26:21.464] Label: ‘future_vapply-2’
[08:26:21.464] Expression:
[08:26:21.464] {
[08:26:21.464]     do.call(function(...) {
[08:26:21.464]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.464]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.464]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.464]             on.exit(options(oopts), add = TRUE)
[08:26:21.464]         }
[08:26:21.464]         {
[08:26:21.464]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.464]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.464]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.464]             })
[08:26:21.464]         }
[08:26:21.464]     }, args = future.call.arguments)
[08:26:21.464] }
[08:26:21.464] Lazy evaluation: FALSE
[08:26:21.464] Asynchronous evaluation: TRUE
[08:26:21.464] Local evaluation: TRUE
[08:26:21.464] Environment: R_GlobalEnv
[08:26:21.464] Capture standard output: TRUE
[08:26:21.464] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:21.464] Globals: 11 objects totaling 16.28 KiB (function ‘...future.FUN’ of 6.73 KiB, function ‘x_FUN’ of 41 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:21.464] Packages: 1 packages (‘future.apply’)
[08:26:21.464] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:21.464] Resolved: FALSE
[08:26:21.464] Value: <not collected>
[08:26:21.464] Conditions captured: <none>
[08:26:21.464] Early signaling: FALSE
[08:26:21.464] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:21.464] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.478] Chunk #2 of 2 ... DONE
[08:26:21.478] Launching 2 futures (chunks) ... DONE
[08:26:21.478] Resolving 2 futures (chunks) ...
[08:26:21.478] resolve() on list ...
[08:26:21.479]  recursive: 0
[08:26:21.479]  length: 2
[08:26:21.479] 
[08:26:21.479] plan(): nbrOfWorkers() = 2
[08:26:21.480] Future #1
[08:26:21.480] result() for MulticoreFuture ...
[08:26:21.484] result() for MulticoreFuture ...
[08:26:21.484] result() for MulticoreFuture ... done
[08:26:21.485] result() for MulticoreFuture ... done
[08:26:21.485] result() for MulticoreFuture ...
[08:26:21.485] result() for MulticoreFuture ... done
[08:26:21.486] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:26:21.486] - nx: 2
[08:26:21.486] - relay: TRUE
[08:26:21.487] - stdout: TRUE
[08:26:21.487] - signal: TRUE
[08:26:21.487] - resignal: FALSE
[08:26:21.487] - force: TRUE
[08:26:21.488] - relayed: [n=2] FALSE, FALSE
[08:26:21.488] - queued futures: [n=2] FALSE, FALSE
[08:26:21.488]  - until=1
[08:26:21.488]  - relaying element #1
[08:26:21.489] result() for MulticoreFuture ...
[08:26:21.489] result() for MulticoreFuture ... done
[08:26:21.489] result() for MulticoreFuture ...
[08:26:21.489] result() for MulticoreFuture ... done
[08:26:21.490] result() for MulticoreFuture ...
[08:26:21.490] result() for MulticoreFuture ... done
[08:26:21.490] result() for MulticoreFuture ...
[08:26:21.490] result() for MulticoreFuture ... done
[08:26:21.490] - relayed: [n=2] TRUE, FALSE
[08:26:21.491] - queued futures: [n=2] TRUE, FALSE
[08:26:21.491] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:26:21.491]  length: 1 (resolved future 1)
[08:26:21.491] Future #2
[08:26:21.492] result() for MulticoreFuture ...
[08:26:21.493] result() for MulticoreFuture ...
[08:26:21.493] result() for MulticoreFuture ... done
[08:26:21.493] result() for MulticoreFuture ... done
[08:26:21.494] result() for MulticoreFuture ...
[08:26:21.494] result() for MulticoreFuture ... done
[08:26:21.494] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:26:21.494] - nx: 2
[08:26:21.495] - relay: TRUE
[08:26:21.495] - stdout: TRUE
[08:26:21.495] - signal: TRUE
[08:26:21.495] - resignal: FALSE
[08:26:21.495] - force: TRUE
[08:26:21.496] - relayed: [n=2] TRUE, FALSE
[08:26:21.496] - queued futures: [n=2] TRUE, FALSE
[08:26:21.496]  - until=2
[08:26:21.496]  - relaying element #2
[08:26:21.497] result() for MulticoreFuture ...
[08:26:21.497] result() for MulticoreFuture ... done
[08:26:21.497] result() for MulticoreFuture ...
[08:26:21.497] result() for MulticoreFuture ... done
[08:26:21.497] result() for MulticoreFuture ...
[08:26:21.498] result() for MulticoreFuture ... done
[08:26:21.498] result() for MulticoreFuture ...
[08:26:21.498] result() for MulticoreFuture ... done
[08:26:21.498] - relayed: [n=2] TRUE, TRUE
[08:26:21.498] - queued futures: [n=2] TRUE, TRUE
[08:26:21.498] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:26:21.498]  length: 0 (resolved future 2)
[08:26:21.499] Relaying remaining futures
[08:26:21.499] signalConditionsASAP(NULL, pos=0) ...
[08:26:21.499] - nx: 2
[08:26:21.499] - relay: TRUE
[08:26:21.499] - stdout: TRUE
[08:26:21.499] - signal: TRUE
[08:26:21.499] - resignal: FALSE
[08:26:21.499] - force: TRUE
[08:26:21.499] - relayed: [n=2] TRUE, TRUE
[08:26:21.499] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:21.500] - relayed: [n=2] TRUE, TRUE
[08:26:21.500] - queued futures: [n=2] TRUE, TRUE
[08:26:21.500] signalConditionsASAP(NULL, pos=0) ... done
[08:26:21.500] resolve() on list ... DONE
[08:26:21.500] result() for MulticoreFuture ...
[08:26:21.500] result() for MulticoreFuture ... done
[08:26:21.500] result() for MulticoreFuture ...
[08:26:21.500] result() for MulticoreFuture ... done
[08:26:21.501] result() for MulticoreFuture ...
[08:26:21.501] result() for MulticoreFuture ... done
[08:26:21.501] result() for MulticoreFuture ...
[08:26:21.501] result() for MulticoreFuture ... done
[08:26:21.501]  - Number of value chunks collected: 2
[08:26:21.501] Resolving 2 futures (chunks) ... DONE
[08:26:21.501] Reducing values from 2 chunks ...
[08:26:21.501]  - Number of values collected after concatenation: 11
[08:26:21.501]  - Number of values expected: 11
[08:26:21.502] Reducing values from 2 chunks ... DONE
[08:26:21.502] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[08:26:21.503] future_lapply() ...
[08:26:21.507] Number of chunks: 2
[08:26:21.507] getGlobalsAndPackagesXApply() ...
[08:26:21.507]  - future.globals: TRUE
[08:26:21.507] getGlobalsAndPackages() ...
[08:26:21.507] Searching for globals...
[08:26:21.510] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[08:26:21.511] Searching for globals ... DONE
[08:26:21.511] Resolving globals: FALSE
[08:26:21.512] The total size of the 7 globals is 11.92 KiB (12201 bytes)
[08:26:21.512] The total size of the 7 globals exported for future expression (‘FUN()’) is 11.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (3.92 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:21.512] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:21.512] - packages: [1] ‘future.apply’
[08:26:21.513] getGlobalsAndPackages() ... DONE
[08:26:21.513]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:21.513]  - needed namespaces: [n=1] ‘future.apply’
[08:26:21.515] Finding globals ... DONE
[08:26:21.515]  - use_args: TRUE
[08:26:21.515]  - Getting '...' globals ...
[08:26:21.516] resolve() on list ...
[08:26:21.516]  recursive: 0
[08:26:21.516]  length: 1
[08:26:21.516]  elements: ‘...’
[08:26:21.516]  length: 0 (resolved future 1)
[08:26:21.516] resolve() on list ... DONE
[08:26:21.517]    - '...' content: [n=0] 
[08:26:21.517] List of 1
[08:26:21.517]  $ ...: list()
[08:26:21.517]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:21.517]  - attr(*, "where")=List of 1
[08:26:21.517]   ..$ ...:<environment: 0x562ca58950b8> 
[08:26:21.517]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:21.517]  - attr(*, "resolved")= logi TRUE
[08:26:21.517]  - attr(*, "total_size")= num NA
[08:26:21.520]  - Getting '...' globals ... DONE
[08:26:21.520] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:21.520] List of 8
[08:26:21.520]  $ ...future.FUN:function (x, ...)  
[08:26:21.520]  $ x_FUN        :function (x)  
[08:26:21.520]  $ times        : int 1
[08:26:21.520]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:21.520]  $ stop_if_not  :function (...)  
[08:26:21.520]  $ dim          : NULL
[08:26:21.520]  $ valid_types  : chr [1:2] "logical" "integer"
[08:26:21.520]  $ ...          : list()
[08:26:21.520]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:21.520]  - attr(*, "where")=List of 8
[08:26:21.520]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:21.520]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:21.520]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:21.520]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:21.520]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:21.520]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:21.520]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:21.520]   ..$ ...          :<environment: 0x562ca58950b8> 
[08:26:21.520]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:21.520]  - attr(*, "resolved")= logi FALSE
[08:26:21.520]  - attr(*, "total_size")= num 22016
[08:26:21.526] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:21.526] getGlobalsAndPackagesXApply() ... DONE
[08:26:21.526] Number of futures (= number of chunks): 2
[08:26:21.526] Launching 2 futures (chunks) ...
[08:26:21.527] Chunk #1 of 2 ...
[08:26:21.527]  - Finding globals in 'X' for chunk #1 ...
[08:26:21.527] getGlobalsAndPackages() ...
[08:26:21.527] Searching for globals...
[08:26:21.527] 
[08:26:21.527] Searching for globals ... DONE
[08:26:21.527] - globals: [0] <none>
[08:26:21.527] getGlobalsAndPackages() ... DONE
[08:26:21.527]    + additional globals found: [n=0] 
[08:26:21.528]    + additional namespaces needed: [n=0] 
[08:26:21.528]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:21.528]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:21.528]  - seeds: <none>
[08:26:21.528]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.528] getGlobalsAndPackages() ...
[08:26:21.528] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.528] Resolving globals: FALSE
[08:26:21.528] Tweak future expression to call with '...' arguments ...
[08:26:21.528] {
[08:26:21.528]     do.call(function(...) {
[08:26:21.528]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.528]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.528]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.528]             on.exit(options(oopts), add = TRUE)
[08:26:21.528]         }
[08:26:21.528]         {
[08:26:21.528]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.528]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.528]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.528]             })
[08:26:21.528]         }
[08:26:21.528]     }, args = future.call.arguments)
[08:26:21.528] }
[08:26:21.529] Tweak future expression to call with '...' arguments ... DONE
[08:26:21.529] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.529] - packages: [1] ‘future.apply’
[08:26:21.530] getGlobalsAndPackages() ... DONE
[08:26:21.530] run() for ‘Future’ ...
[08:26:21.530] - state: ‘created’
[08:26:21.530] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:21.532] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.532] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:21.532]   - Field: ‘label’
[08:26:21.532]   - Field: ‘local’
[08:26:21.532]   - Field: ‘owner’
[08:26:21.532]   - Field: ‘envir’
[08:26:21.533]   - Field: ‘workers’
[08:26:21.533]   - Field: ‘packages’
[08:26:21.533]   - Field: ‘gc’
[08:26:21.533]   - Field: ‘job’
[08:26:21.533]   - Field: ‘conditions’
[08:26:21.533]   - Field: ‘expr’
[08:26:21.533]   - Field: ‘uuid’
[08:26:21.533]   - Field: ‘seed’
[08:26:21.533]   - Field: ‘version’
[08:26:21.533]   - Field: ‘result’
[08:26:21.533]   - Field: ‘asynchronous’
[08:26:21.534]   - Field: ‘calls’
[08:26:21.534]   - Field: ‘globals’
[08:26:21.534]   - Field: ‘stdout’
[08:26:21.534]   - Field: ‘earlySignal’
[08:26:21.534]   - Field: ‘lazy’
[08:26:21.534]   - Field: ‘state’
[08:26:21.534] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:21.534] - Launch lazy future ...
[08:26:21.534] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:21.535] Packages needed by future strategies (n = 0): <none>
[08:26:21.535] {
[08:26:21.535]     {
[08:26:21.535]         {
[08:26:21.535]             ...future.startTime <- base::Sys.time()
[08:26:21.535]             {
[08:26:21.535]                 {
[08:26:21.535]                   {
[08:26:21.535]                     {
[08:26:21.535]                       {
[08:26:21.535]                         base::local({
[08:26:21.535]                           has_future <- base::requireNamespace("future", 
[08:26:21.535]                             quietly = TRUE)
[08:26:21.535]                           if (has_future) {
[08:26:21.535]                             ns <- base::getNamespace("future")
[08:26:21.535]                             version <- ns[[".package"]][["version"]]
[08:26:21.535]                             if (is.null(version)) 
[08:26:21.535]                               version <- utils::packageVersion("future")
[08:26:21.535]                           }
[08:26:21.535]                           else {
[08:26:21.535]                             version <- NULL
[08:26:21.535]                           }
[08:26:21.535]                           if (!has_future || version < "1.8.0") {
[08:26:21.535]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:21.535]                               "", base::R.version$version.string), 
[08:26:21.535]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:21.535]                                 base::R.version$platform, 8 * 
[08:26:21.535]                                   base::.Machine$sizeof.pointer), 
[08:26:21.535]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:21.535]                                 "release", "version")], collapse = " "), 
[08:26:21.535]                               hostname = base::Sys.info()[["nodename"]])
[08:26:21.535]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:21.535]                               info)
[08:26:21.535]                             info <- base::paste(info, collapse = "; ")
[08:26:21.535]                             if (!has_future) {
[08:26:21.535]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:21.535]                                 info)
[08:26:21.535]                             }
[08:26:21.535]                             else {
[08:26:21.535]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:21.535]                                 info, version)
[08:26:21.535]                             }
[08:26:21.535]                             base::stop(msg)
[08:26:21.535]                           }
[08:26:21.535]                         })
[08:26:21.535]                       }
[08:26:21.535]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:21.535]                       base::options(mc.cores = 1L)
[08:26:21.535]                     }
[08:26:21.535]                     base::local({
[08:26:21.535]                       for (pkg in "future.apply") {
[08:26:21.535]                         base::loadNamespace(pkg)
[08:26:21.535]                         base::library(pkg, character.only = TRUE)
[08:26:21.535]                       }
[08:26:21.535]                     })
[08:26:21.535]                   }
[08:26:21.535]                   ...future.strategy.old <- future::plan("list")
[08:26:21.535]                   options(future.plan = NULL)
[08:26:21.535]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.535]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:21.535]                 }
[08:26:21.535]                 ...future.workdir <- getwd()
[08:26:21.535]             }
[08:26:21.535]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:21.535]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:21.535]         }
[08:26:21.535]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:21.535]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:21.535]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:21.535]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:21.535]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:21.535]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:21.535]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:21.535]             base::names(...future.oldOptions))
[08:26:21.535]     }
[08:26:21.535]     if (FALSE) {
[08:26:21.535]     }
[08:26:21.535]     else {
[08:26:21.535]         if (TRUE) {
[08:26:21.535]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:21.535]                 open = "w")
[08:26:21.535]         }
[08:26:21.535]         else {
[08:26:21.535]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:21.535]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:21.535]         }
[08:26:21.535]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:21.535]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:21.535]             base::sink(type = "output", split = FALSE)
[08:26:21.535]             base::close(...future.stdout)
[08:26:21.535]         }, add = TRUE)
[08:26:21.535]     }
[08:26:21.535]     ...future.frame <- base::sys.nframe()
[08:26:21.535]     ...future.conditions <- base::list()
[08:26:21.535]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:21.535]     if (FALSE) {
[08:26:21.535]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:21.535]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:21.535]     }
[08:26:21.535]     ...future.result <- base::tryCatch({
[08:26:21.535]         base::withCallingHandlers({
[08:26:21.535]             ...future.value <- base::withVisible(base::local({
[08:26:21.535]                 withCallingHandlers({
[08:26:21.535]                   {
[08:26:21.535]                     do.call(function(...) {
[08:26:21.535]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.535]                       if (!identical(...future.globals.maxSize.org, 
[08:26:21.535]                         ...future.globals.maxSize)) {
[08:26:21.535]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.535]                         on.exit(options(oopts), add = TRUE)
[08:26:21.535]                       }
[08:26:21.535]                       {
[08:26:21.535]                         lapply(seq_along(...future.elements_ii), 
[08:26:21.535]                           FUN = function(jj) {
[08:26:21.535]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.535]                             ...future.FUN(...future.X_jj, ...)
[08:26:21.535]                           })
[08:26:21.535]                       }
[08:26:21.535]                     }, args = future.call.arguments)
[08:26:21.535]                   }
[08:26:21.535]                 }, immediateCondition = function(cond) {
[08:26:21.535]                   save_rds <- function (object, pathname, ...) 
[08:26:21.535]                   {
[08:26:21.535]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:21.535]                     if (file_test("-f", pathname_tmp)) {
[08:26:21.535]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.535]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:21.535]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.535]                         fi_tmp[["mtime"]])
[08:26:21.535]                     }
[08:26:21.535]                     tryCatch({
[08:26:21.535]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:21.535]                     }, error = function(ex) {
[08:26:21.535]                       msg <- conditionMessage(ex)
[08:26:21.535]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.535]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:21.535]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.535]                         fi_tmp[["mtime"]], msg)
[08:26:21.535]                       ex$message <- msg
[08:26:21.535]                       stop(ex)
[08:26:21.535]                     })
[08:26:21.535]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:21.535]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:21.535]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:21.535]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.535]                       fi <- file.info(pathname)
[08:26:21.535]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:21.535]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.535]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:21.535]                         fi[["size"]], fi[["mtime"]])
[08:26:21.535]                       stop(msg)
[08:26:21.535]                     }
[08:26:21.535]                     invisible(pathname)
[08:26:21.535]                   }
[08:26:21.535]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:21.535]                     rootPath = tempdir()) 
[08:26:21.535]                   {
[08:26:21.535]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:21.535]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:21.535]                       tmpdir = path, fileext = ".rds")
[08:26:21.535]                     save_rds(obj, file)
[08:26:21.535]                   }
[08:26:21.535]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:21.535]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.535]                   {
[08:26:21.535]                     inherits <- base::inherits
[08:26:21.535]                     invokeRestart <- base::invokeRestart
[08:26:21.535]                     is.null <- base::is.null
[08:26:21.535]                     muffled <- FALSE
[08:26:21.535]                     if (inherits(cond, "message")) {
[08:26:21.535]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:21.535]                       if (muffled) 
[08:26:21.535]                         invokeRestart("muffleMessage")
[08:26:21.535]                     }
[08:26:21.535]                     else if (inherits(cond, "warning")) {
[08:26:21.535]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:21.535]                       if (muffled) 
[08:26:21.535]                         invokeRestart("muffleWarning")
[08:26:21.535]                     }
[08:26:21.535]                     else if (inherits(cond, "condition")) {
[08:26:21.535]                       if (!is.null(pattern)) {
[08:26:21.535]                         computeRestarts <- base::computeRestarts
[08:26:21.535]                         grepl <- base::grepl
[08:26:21.535]                         restarts <- computeRestarts(cond)
[08:26:21.535]                         for (restart in restarts) {
[08:26:21.535]                           name <- restart$name
[08:26:21.535]                           if (is.null(name)) 
[08:26:21.535]                             next
[08:26:21.535]                           if (!grepl(pattern, name)) 
[08:26:21.535]                             next
[08:26:21.535]                           invokeRestart(restart)
[08:26:21.535]                           muffled <- TRUE
[08:26:21.535]                           break
[08:26:21.535]                         }
[08:26:21.535]                       }
[08:26:21.535]                     }
[08:26:21.535]                     invisible(muffled)
[08:26:21.535]                   }
[08:26:21.535]                   muffleCondition(cond)
[08:26:21.535]                 })
[08:26:21.535]             }))
[08:26:21.535]             future::FutureResult(value = ...future.value$value, 
[08:26:21.535]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.535]                   ...future.rng), globalenv = if (FALSE) 
[08:26:21.535]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:21.535]                     ...future.globalenv.names))
[08:26:21.535]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:21.535]         }, condition = base::local({
[08:26:21.535]             c <- base::c
[08:26:21.535]             inherits <- base::inherits
[08:26:21.535]             invokeRestart <- base::invokeRestart
[08:26:21.535]             length <- base::length
[08:26:21.535]             list <- base::list
[08:26:21.535]             seq.int <- base::seq.int
[08:26:21.535]             signalCondition <- base::signalCondition
[08:26:21.535]             sys.calls <- base::sys.calls
[08:26:21.535]             `[[` <- base::`[[`
[08:26:21.535]             `+` <- base::`+`
[08:26:21.535]             `<<-` <- base::`<<-`
[08:26:21.535]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:21.535]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:21.535]                   3L)]
[08:26:21.535]             }
[08:26:21.535]             function(cond) {
[08:26:21.535]                 is_error <- inherits(cond, "error")
[08:26:21.535]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:21.535]                   NULL)
[08:26:21.535]                 if (is_error) {
[08:26:21.535]                   sessionInformation <- function() {
[08:26:21.535]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:21.535]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:21.535]                       search = base::search(), system = base::Sys.info())
[08:26:21.535]                   }
[08:26:21.535]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.535]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:21.535]                     cond$call), session = sessionInformation(), 
[08:26:21.535]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:21.535]                   signalCondition(cond)
[08:26:21.535]                 }
[08:26:21.535]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:21.535]                 "immediateCondition"))) {
[08:26:21.535]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:21.535]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.535]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:21.535]                   if (TRUE && !signal) {
[08:26:21.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.535]                     {
[08:26:21.535]                       inherits <- base::inherits
[08:26:21.535]                       invokeRestart <- base::invokeRestart
[08:26:21.535]                       is.null <- base::is.null
[08:26:21.535]                       muffled <- FALSE
[08:26:21.535]                       if (inherits(cond, "message")) {
[08:26:21.535]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.535]                         if (muffled) 
[08:26:21.535]                           invokeRestart("muffleMessage")
[08:26:21.535]                       }
[08:26:21.535]                       else if (inherits(cond, "warning")) {
[08:26:21.535]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.535]                         if (muffled) 
[08:26:21.535]                           invokeRestart("muffleWarning")
[08:26:21.535]                       }
[08:26:21.535]                       else if (inherits(cond, "condition")) {
[08:26:21.535]                         if (!is.null(pattern)) {
[08:26:21.535]                           computeRestarts <- base::computeRestarts
[08:26:21.535]                           grepl <- base::grepl
[08:26:21.535]                           restarts <- computeRestarts(cond)
[08:26:21.535]                           for (restart in restarts) {
[08:26:21.535]                             name <- restart$name
[08:26:21.535]                             if (is.null(name)) 
[08:26:21.535]                               next
[08:26:21.535]                             if (!grepl(pattern, name)) 
[08:26:21.535]                               next
[08:26:21.535]                             invokeRestart(restart)
[08:26:21.535]                             muffled <- TRUE
[08:26:21.535]                             break
[08:26:21.535]                           }
[08:26:21.535]                         }
[08:26:21.535]                       }
[08:26:21.535]                       invisible(muffled)
[08:26:21.535]                     }
[08:26:21.535]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.535]                   }
[08:26:21.535]                 }
[08:26:21.535]                 else {
[08:26:21.535]                   if (TRUE) {
[08:26:21.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.535]                     {
[08:26:21.535]                       inherits <- base::inherits
[08:26:21.535]                       invokeRestart <- base::invokeRestart
[08:26:21.535]                       is.null <- base::is.null
[08:26:21.535]                       muffled <- FALSE
[08:26:21.535]                       if (inherits(cond, "message")) {
[08:26:21.535]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.535]                         if (muffled) 
[08:26:21.535]                           invokeRestart("muffleMessage")
[08:26:21.535]                       }
[08:26:21.535]                       else if (inherits(cond, "warning")) {
[08:26:21.535]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.535]                         if (muffled) 
[08:26:21.535]                           invokeRestart("muffleWarning")
[08:26:21.535]                       }
[08:26:21.535]                       else if (inherits(cond, "condition")) {
[08:26:21.535]                         if (!is.null(pattern)) {
[08:26:21.535]                           computeRestarts <- base::computeRestarts
[08:26:21.535]                           grepl <- base::grepl
[08:26:21.535]                           restarts <- computeRestarts(cond)
[08:26:21.535]                           for (restart in restarts) {
[08:26:21.535]                             name <- restart$name
[08:26:21.535]                             if (is.null(name)) 
[08:26:21.535]                               next
[08:26:21.535]                             if (!grepl(pattern, name)) 
[08:26:21.535]                               next
[08:26:21.535]                             invokeRestart(restart)
[08:26:21.535]                             muffled <- TRUE
[08:26:21.535]                             break
[08:26:21.535]                           }
[08:26:21.535]                         }
[08:26:21.535]                       }
[08:26:21.535]                       invisible(muffled)
[08:26:21.535]                     }
[08:26:21.535]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.535]                   }
[08:26:21.535]                 }
[08:26:21.535]             }
[08:26:21.535]         }))
[08:26:21.535]     }, error = function(ex) {
[08:26:21.535]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:21.535]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.535]                 ...future.rng), started = ...future.startTime, 
[08:26:21.535]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:21.535]             version = "1.8"), class = "FutureResult")
[08:26:21.535]     }, finally = {
[08:26:21.535]         if (!identical(...future.workdir, getwd())) 
[08:26:21.535]             setwd(...future.workdir)
[08:26:21.535]         {
[08:26:21.535]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:21.535]                 ...future.oldOptions$nwarnings <- NULL
[08:26:21.535]             }
[08:26:21.535]             base::options(...future.oldOptions)
[08:26:21.535]             if (.Platform$OS.type == "windows") {
[08:26:21.535]                 old_names <- names(...future.oldEnvVars)
[08:26:21.535]                 envs <- base::Sys.getenv()
[08:26:21.535]                 names <- names(envs)
[08:26:21.535]                 common <- intersect(names, old_names)
[08:26:21.535]                 added <- setdiff(names, old_names)
[08:26:21.535]                 removed <- setdiff(old_names, names)
[08:26:21.535]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:21.535]                   envs[common]]
[08:26:21.535]                 NAMES <- toupper(changed)
[08:26:21.535]                 args <- list()
[08:26:21.535]                 for (kk in seq_along(NAMES)) {
[08:26:21.535]                   name <- changed[[kk]]
[08:26:21.535]                   NAME <- NAMES[[kk]]
[08:26:21.535]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.535]                     next
[08:26:21.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.535]                 }
[08:26:21.535]                 NAMES <- toupper(added)
[08:26:21.535]                 for (kk in seq_along(NAMES)) {
[08:26:21.535]                   name <- added[[kk]]
[08:26:21.535]                   NAME <- NAMES[[kk]]
[08:26:21.535]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.535]                     next
[08:26:21.535]                   args[[name]] <- ""
[08:26:21.535]                 }
[08:26:21.535]                 NAMES <- toupper(removed)
[08:26:21.535]                 for (kk in seq_along(NAMES)) {
[08:26:21.535]                   name <- removed[[kk]]
[08:26:21.535]                   NAME <- NAMES[[kk]]
[08:26:21.535]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.535]                     next
[08:26:21.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.535]                 }
[08:26:21.535]                 if (length(args) > 0) 
[08:26:21.535]                   base::do.call(base::Sys.setenv, args = args)
[08:26:21.535]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:21.535]             }
[08:26:21.535]             else {
[08:26:21.535]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:21.535]             }
[08:26:21.535]             {
[08:26:21.535]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:21.535]                   0L) {
[08:26:21.535]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:21.535]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:21.535]                   base::options(opts)
[08:26:21.535]                 }
[08:26:21.535]                 {
[08:26:21.535]                   {
[08:26:21.535]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:21.535]                     NULL
[08:26:21.535]                   }
[08:26:21.535]                   options(future.plan = NULL)
[08:26:21.535]                   if (is.na(NA_character_)) 
[08:26:21.535]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.535]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:21.535]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:21.535]                     .init = FALSE)
[08:26:21.535]                 }
[08:26:21.535]             }
[08:26:21.535]         }
[08:26:21.535]     })
[08:26:21.535]     if (TRUE) {
[08:26:21.535]         base::sink(type = "output", split = FALSE)
[08:26:21.535]         if (TRUE) {
[08:26:21.535]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:21.535]         }
[08:26:21.535]         else {
[08:26:21.535]             ...future.result["stdout"] <- base::list(NULL)
[08:26:21.535]         }
[08:26:21.535]         base::close(...future.stdout)
[08:26:21.535]         ...future.stdout <- NULL
[08:26:21.535]     }
[08:26:21.535]     ...future.result$conditions <- ...future.conditions
[08:26:21.535]     ...future.result$finished <- base::Sys.time()
[08:26:21.535]     ...future.result
[08:26:21.535] }
[08:26:21.540] assign_globals() ...
[08:26:21.540] List of 11
[08:26:21.540]  $ ...future.FUN            :function (x, ...)  
[08:26:21.540]  $ x_FUN                    :function (x)  
[08:26:21.540]  $ times                    : int 1
[08:26:21.540]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:21.540]  $ stop_if_not              :function (...)  
[08:26:21.540]  $ dim                      : NULL
[08:26:21.540]  $ valid_types              : chr [1:2] "logical" "integer"
[08:26:21.540]  $ future.call.arguments    : list()
[08:26:21.540]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:21.540]  $ ...future.elements_ii    :List of 1
[08:26:21.540]   ..$ a: num 1
[08:26:21.540]  $ ...future.seeds_ii       : NULL
[08:26:21.540]  $ ...future.globals.maxSize: NULL
[08:26:21.540]  - attr(*, "where")=List of 11
[08:26:21.540]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:21.540]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:21.540]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:21.540]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:21.540]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:21.540]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:21.540]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:21.540]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:21.540]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:21.540]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:21.540]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:21.540]  - attr(*, "resolved")= logi FALSE
[08:26:21.540]  - attr(*, "total_size")= num 22016
[08:26:21.540]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:21.540]  - attr(*, "already-done")= logi TRUE
[08:26:21.549] - copied ‘...future.FUN’ to environment
[08:26:21.550] - copied ‘x_FUN’ to environment
[08:26:21.550] - copied ‘times’ to environment
[08:26:21.550] - copied ‘stopf’ to environment
[08:26:21.550] - copied ‘stop_if_not’ to environment
[08:26:21.550] - copied ‘dim’ to environment
[08:26:21.550] - copied ‘valid_types’ to environment
[08:26:21.550] - copied ‘future.call.arguments’ to environment
[08:26:21.550] - copied ‘...future.elements_ii’ to environment
[08:26:21.550] - copied ‘...future.seeds_ii’ to environment
[08:26:21.550] - copied ‘...future.globals.maxSize’ to environment
[08:26:21.550] assign_globals() ... done
[08:26:21.551] requestCore(): workers = 2
[08:26:21.553] MulticoreFuture started
[08:26:21.553] - Launch lazy future ... done
[08:26:21.554] run() for ‘MulticoreFuture’ ... done
[08:26:21.554] Created future:
[08:26:21.555] plan(): Setting new future strategy stack:
[08:26:21.555] List of future strategies:
[08:26:21.555] 1. sequential:
[08:26:21.555]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:21.555]    - tweaked: FALSE
[08:26:21.555]    - call: NULL
[08:26:21.556] plan(): nbrOfWorkers() = 1
[08:26:21.558] plan(): Setting new future strategy stack:
[08:26:21.558] List of future strategies:
[08:26:21.558] 1. multicore:
[08:26:21.558]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:21.558]    - tweaked: FALSE
[08:26:21.558]    - call: plan(strategy)
[08:26:21.562] plan(): nbrOfWorkers() = 2
[08:26:21.554] MulticoreFuture:
[08:26:21.554] Label: ‘future_vapply-1’
[08:26:21.554] Expression:
[08:26:21.554] {
[08:26:21.554]     do.call(function(...) {
[08:26:21.554]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.554]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.554]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.554]             on.exit(options(oopts), add = TRUE)
[08:26:21.554]         }
[08:26:21.554]         {
[08:26:21.554]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.554]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.554]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.554]             })
[08:26:21.554]         }
[08:26:21.554]     }, args = future.call.arguments)
[08:26:21.554] }
[08:26:21.554] Lazy evaluation: FALSE
[08:26:21.554] Asynchronous evaluation: TRUE
[08:26:21.554] Local evaluation: TRUE
[08:26:21.554] Environment: R_GlobalEnv
[08:26:21.554] Capture standard output: TRUE
[08:26:21.554] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:21.554] Globals: 11 objects totaling 12.15 KiB (function ‘...future.FUN’ of 3.91 KiB, function ‘x_FUN’ of 37 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:21.554] Packages: 1 packages (‘future.apply’)
[08:26:21.554] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:21.554] Resolved: TRUE
[08:26:21.554] Value: <not collected>
[08:26:21.554] Conditions captured: <none>
[08:26:21.554] Early signaling: FALSE
[08:26:21.554] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:21.554] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.563] Chunk #1 of 2 ... DONE
[08:26:21.563] Chunk #2 of 2 ...
[08:26:21.563]  - Finding globals in 'X' for chunk #2 ...
[08:26:21.563] getGlobalsAndPackages() ...
[08:26:21.564] Searching for globals...
[08:26:21.564] 
[08:26:21.564] Searching for globals ... DONE
[08:26:21.564] - globals: [0] <none>
[08:26:21.564] getGlobalsAndPackages() ... DONE
[08:26:21.565]    + additional globals found: [n=0] 
[08:26:21.565]    + additional namespaces needed: [n=0] 
[08:26:21.565]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:21.565]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:21.565]  - seeds: <none>
[08:26:21.565]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.565] getGlobalsAndPackages() ...
[08:26:21.566] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.566] Resolving globals: FALSE
[08:26:21.566] Tweak future expression to call with '...' arguments ...
[08:26:21.566] {
[08:26:21.566]     do.call(function(...) {
[08:26:21.566]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.566]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.566]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.566]             on.exit(options(oopts), add = TRUE)
[08:26:21.566]         }
[08:26:21.566]         {
[08:26:21.566]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.566]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.566]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.566]             })
[08:26:21.566]         }
[08:26:21.566]     }, args = future.call.arguments)
[08:26:21.566] }
[08:26:21.567] Tweak future expression to call with '...' arguments ... DONE
[08:26:21.568] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.568] - packages: [1] ‘future.apply’
[08:26:21.568] getGlobalsAndPackages() ... DONE
[08:26:21.569] run() for ‘Future’ ...
[08:26:21.569] - state: ‘created’
[08:26:21.569] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:21.572] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.572] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:21.572]   - Field: ‘label’
[08:26:21.572]   - Field: ‘local’
[08:26:21.573]   - Field: ‘owner’
[08:26:21.573]   - Field: ‘envir’
[08:26:21.573]   - Field: ‘workers’
[08:26:21.573]   - Field: ‘packages’
[08:26:21.573]   - Field: ‘gc’
[08:26:21.573]   - Field: ‘job’
[08:26:21.573]   - Field: ‘conditions’
[08:26:21.574]   - Field: ‘expr’
[08:26:21.574]   - Field: ‘uuid’
[08:26:21.574]   - Field: ‘seed’
[08:26:21.574]   - Field: ‘version’
[08:26:21.574]   - Field: ‘result’
[08:26:21.574]   - Field: ‘asynchronous’
[08:26:21.574]   - Field: ‘calls’
[08:26:21.575]   - Field: ‘globals’
[08:26:21.575]   - Field: ‘stdout’
[08:26:21.575]   - Field: ‘earlySignal’
[08:26:21.575]   - Field: ‘lazy’
[08:26:21.575]   - Field: ‘state’
[08:26:21.575] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:21.576] - Launch lazy future ...
[08:26:21.576] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:21.579] Packages needed by future strategies (n = 0): <none>
[08:26:21.581] {
[08:26:21.581]     {
[08:26:21.581]         {
[08:26:21.581]             ...future.startTime <- base::Sys.time()
[08:26:21.581]             {
[08:26:21.581]                 {
[08:26:21.581]                   {
[08:26:21.581]                     {
[08:26:21.581]                       {
[08:26:21.581]                         base::local({
[08:26:21.581]                           has_future <- base::requireNamespace("future", 
[08:26:21.581]                             quietly = TRUE)
[08:26:21.581]                           if (has_future) {
[08:26:21.581]                             ns <- base::getNamespace("future")
[08:26:21.581]                             version <- ns[[".package"]][["version"]]
[08:26:21.581]                             if (is.null(version)) 
[08:26:21.581]                               version <- utils::packageVersion("future")
[08:26:21.581]                           }
[08:26:21.581]                           else {
[08:26:21.581]                             version <- NULL
[08:26:21.581]                           }
[08:26:21.581]                           if (!has_future || version < "1.8.0") {
[08:26:21.581]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:21.581]                               "", base::R.version$version.string), 
[08:26:21.581]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:21.581]                                 base::R.version$platform, 8 * 
[08:26:21.581]                                   base::.Machine$sizeof.pointer), 
[08:26:21.581]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:21.581]                                 "release", "version")], collapse = " "), 
[08:26:21.581]                               hostname = base::Sys.info()[["nodename"]])
[08:26:21.581]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:21.581]                               info)
[08:26:21.581]                             info <- base::paste(info, collapse = "; ")
[08:26:21.581]                             if (!has_future) {
[08:26:21.581]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:21.581]                                 info)
[08:26:21.581]                             }
[08:26:21.581]                             else {
[08:26:21.581]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:21.581]                                 info, version)
[08:26:21.581]                             }
[08:26:21.581]                             base::stop(msg)
[08:26:21.581]                           }
[08:26:21.581]                         })
[08:26:21.581]                       }
[08:26:21.581]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:21.581]                       base::options(mc.cores = 1L)
[08:26:21.581]                     }
[08:26:21.581]                     base::local({
[08:26:21.581]                       for (pkg in "future.apply") {
[08:26:21.581]                         base::loadNamespace(pkg)
[08:26:21.581]                         base::library(pkg, character.only = TRUE)
[08:26:21.581]                       }
[08:26:21.581]                     })
[08:26:21.581]                   }
[08:26:21.581]                   ...future.strategy.old <- future::plan("list")
[08:26:21.581]                   options(future.plan = NULL)
[08:26:21.581]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.581]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:21.581]                 }
[08:26:21.581]                 ...future.workdir <- getwd()
[08:26:21.581]             }
[08:26:21.581]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:21.581]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:21.581]         }
[08:26:21.581]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:21.581]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:21.581]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:21.581]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:21.581]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:21.581]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:21.581]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:21.581]             base::names(...future.oldOptions))
[08:26:21.581]     }
[08:26:21.581]     if (FALSE) {
[08:26:21.581]     }
[08:26:21.581]     else {
[08:26:21.581]         if (TRUE) {
[08:26:21.581]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:21.581]                 open = "w")
[08:26:21.581]         }
[08:26:21.581]         else {
[08:26:21.581]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:21.581]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:21.581]         }
[08:26:21.581]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:21.581]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:21.581]             base::sink(type = "output", split = FALSE)
[08:26:21.581]             base::close(...future.stdout)
[08:26:21.581]         }, add = TRUE)
[08:26:21.581]     }
[08:26:21.581]     ...future.frame <- base::sys.nframe()
[08:26:21.581]     ...future.conditions <- base::list()
[08:26:21.581]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:21.581]     if (FALSE) {
[08:26:21.581]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:21.581]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:21.581]     }
[08:26:21.581]     ...future.result <- base::tryCatch({
[08:26:21.581]         base::withCallingHandlers({
[08:26:21.581]             ...future.value <- base::withVisible(base::local({
[08:26:21.581]                 withCallingHandlers({
[08:26:21.581]                   {
[08:26:21.581]                     do.call(function(...) {
[08:26:21.581]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.581]                       if (!identical(...future.globals.maxSize.org, 
[08:26:21.581]                         ...future.globals.maxSize)) {
[08:26:21.581]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.581]                         on.exit(options(oopts), add = TRUE)
[08:26:21.581]                       }
[08:26:21.581]                       {
[08:26:21.581]                         lapply(seq_along(...future.elements_ii), 
[08:26:21.581]                           FUN = function(jj) {
[08:26:21.581]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.581]                             ...future.FUN(...future.X_jj, ...)
[08:26:21.581]                           })
[08:26:21.581]                       }
[08:26:21.581]                     }, args = future.call.arguments)
[08:26:21.581]                   }
[08:26:21.581]                 }, immediateCondition = function(cond) {
[08:26:21.581]                   save_rds <- function (object, pathname, ...) 
[08:26:21.581]                   {
[08:26:21.581]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:21.581]                     if (file_test("-f", pathname_tmp)) {
[08:26:21.581]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.581]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:21.581]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.581]                         fi_tmp[["mtime"]])
[08:26:21.581]                     }
[08:26:21.581]                     tryCatch({
[08:26:21.581]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:21.581]                     }, error = function(ex) {
[08:26:21.581]                       msg <- conditionMessage(ex)
[08:26:21.581]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.581]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:21.581]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.581]                         fi_tmp[["mtime"]], msg)
[08:26:21.581]                       ex$message <- msg
[08:26:21.581]                       stop(ex)
[08:26:21.581]                     })
[08:26:21.581]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:21.581]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:21.581]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:21.581]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.581]                       fi <- file.info(pathname)
[08:26:21.581]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:21.581]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.581]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:21.581]                         fi[["size"]], fi[["mtime"]])
[08:26:21.581]                       stop(msg)
[08:26:21.581]                     }
[08:26:21.581]                     invisible(pathname)
[08:26:21.581]                   }
[08:26:21.581]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:21.581]                     rootPath = tempdir()) 
[08:26:21.581]                   {
[08:26:21.581]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:21.581]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:21.581]                       tmpdir = path, fileext = ".rds")
[08:26:21.581]                     save_rds(obj, file)
[08:26:21.581]                   }
[08:26:21.581]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:21.581]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.581]                   {
[08:26:21.581]                     inherits <- base::inherits
[08:26:21.581]                     invokeRestart <- base::invokeRestart
[08:26:21.581]                     is.null <- base::is.null
[08:26:21.581]                     muffled <- FALSE
[08:26:21.581]                     if (inherits(cond, "message")) {
[08:26:21.581]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:21.581]                       if (muffled) 
[08:26:21.581]                         invokeRestart("muffleMessage")
[08:26:21.581]                     }
[08:26:21.581]                     else if (inherits(cond, "warning")) {
[08:26:21.581]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:21.581]                       if (muffled) 
[08:26:21.581]                         invokeRestart("muffleWarning")
[08:26:21.581]                     }
[08:26:21.581]                     else if (inherits(cond, "condition")) {
[08:26:21.581]                       if (!is.null(pattern)) {
[08:26:21.581]                         computeRestarts <- base::computeRestarts
[08:26:21.581]                         grepl <- base::grepl
[08:26:21.581]                         restarts <- computeRestarts(cond)
[08:26:21.581]                         for (restart in restarts) {
[08:26:21.581]                           name <- restart$name
[08:26:21.581]                           if (is.null(name)) 
[08:26:21.581]                             next
[08:26:21.581]                           if (!grepl(pattern, name)) 
[08:26:21.581]                             next
[08:26:21.581]                           invokeRestart(restart)
[08:26:21.581]                           muffled <- TRUE
[08:26:21.581]                           break
[08:26:21.581]                         }
[08:26:21.581]                       }
[08:26:21.581]                     }
[08:26:21.581]                     invisible(muffled)
[08:26:21.581]                   }
[08:26:21.581]                   muffleCondition(cond)
[08:26:21.581]                 })
[08:26:21.581]             }))
[08:26:21.581]             future::FutureResult(value = ...future.value$value, 
[08:26:21.581]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.581]                   ...future.rng), globalenv = if (FALSE) 
[08:26:21.581]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:21.581]                     ...future.globalenv.names))
[08:26:21.581]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:21.581]         }, condition = base::local({
[08:26:21.581]             c <- base::c
[08:26:21.581]             inherits <- base::inherits
[08:26:21.581]             invokeRestart <- base::invokeRestart
[08:26:21.581]             length <- base::length
[08:26:21.581]             list <- base::list
[08:26:21.581]             seq.int <- base::seq.int
[08:26:21.581]             signalCondition <- base::signalCondition
[08:26:21.581]             sys.calls <- base::sys.calls
[08:26:21.581]             `[[` <- base::`[[`
[08:26:21.581]             `+` <- base::`+`
[08:26:21.581]             `<<-` <- base::`<<-`
[08:26:21.581]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:21.581]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:21.581]                   3L)]
[08:26:21.581]             }
[08:26:21.581]             function(cond) {
[08:26:21.581]                 is_error <- inherits(cond, "error")
[08:26:21.581]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:21.581]                   NULL)
[08:26:21.581]                 if (is_error) {
[08:26:21.581]                   sessionInformation <- function() {
[08:26:21.581]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:21.581]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:21.581]                       search = base::search(), system = base::Sys.info())
[08:26:21.581]                   }
[08:26:21.581]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.581]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:21.581]                     cond$call), session = sessionInformation(), 
[08:26:21.581]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:21.581]                   signalCondition(cond)
[08:26:21.581]                 }
[08:26:21.581]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:21.581]                 "immediateCondition"))) {
[08:26:21.581]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:21.581]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.581]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:21.581]                   if (TRUE && !signal) {
[08:26:21.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.581]                     {
[08:26:21.581]                       inherits <- base::inherits
[08:26:21.581]                       invokeRestart <- base::invokeRestart
[08:26:21.581]                       is.null <- base::is.null
[08:26:21.581]                       muffled <- FALSE
[08:26:21.581]                       if (inherits(cond, "message")) {
[08:26:21.581]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.581]                         if (muffled) 
[08:26:21.581]                           invokeRestart("muffleMessage")
[08:26:21.581]                       }
[08:26:21.581]                       else if (inherits(cond, "warning")) {
[08:26:21.581]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.581]                         if (muffled) 
[08:26:21.581]                           invokeRestart("muffleWarning")
[08:26:21.581]                       }
[08:26:21.581]                       else if (inherits(cond, "condition")) {
[08:26:21.581]                         if (!is.null(pattern)) {
[08:26:21.581]                           computeRestarts <- base::computeRestarts
[08:26:21.581]                           grepl <- base::grepl
[08:26:21.581]                           restarts <- computeRestarts(cond)
[08:26:21.581]                           for (restart in restarts) {
[08:26:21.581]                             name <- restart$name
[08:26:21.581]                             if (is.null(name)) 
[08:26:21.581]                               next
[08:26:21.581]                             if (!grepl(pattern, name)) 
[08:26:21.581]                               next
[08:26:21.581]                             invokeRestart(restart)
[08:26:21.581]                             muffled <- TRUE
[08:26:21.581]                             break
[08:26:21.581]                           }
[08:26:21.581]                         }
[08:26:21.581]                       }
[08:26:21.581]                       invisible(muffled)
[08:26:21.581]                     }
[08:26:21.581]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.581]                   }
[08:26:21.581]                 }
[08:26:21.581]                 else {
[08:26:21.581]                   if (TRUE) {
[08:26:21.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.581]                     {
[08:26:21.581]                       inherits <- base::inherits
[08:26:21.581]                       invokeRestart <- base::invokeRestart
[08:26:21.581]                       is.null <- base::is.null
[08:26:21.581]                       muffled <- FALSE
[08:26:21.581]                       if (inherits(cond, "message")) {
[08:26:21.581]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.581]                         if (muffled) 
[08:26:21.581]                           invokeRestart("muffleMessage")
[08:26:21.581]                       }
[08:26:21.581]                       else if (inherits(cond, "warning")) {
[08:26:21.581]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.581]                         if (muffled) 
[08:26:21.581]                           invokeRestart("muffleWarning")
[08:26:21.581]                       }
[08:26:21.581]                       else if (inherits(cond, "condition")) {
[08:26:21.581]                         if (!is.null(pattern)) {
[08:26:21.581]                           computeRestarts <- base::computeRestarts
[08:26:21.581]                           grepl <- base::grepl
[08:26:21.581]                           restarts <- computeRestarts(cond)
[08:26:21.581]                           for (restart in restarts) {
[08:26:21.581]                             name <- restart$name
[08:26:21.581]                             if (is.null(name)) 
[08:26:21.581]                               next
[08:26:21.581]                             if (!grepl(pattern, name)) 
[08:26:21.581]                               next
[08:26:21.581]                             invokeRestart(restart)
[08:26:21.581]                             muffled <- TRUE
[08:26:21.581]                             break
[08:26:21.581]                           }
[08:26:21.581]                         }
[08:26:21.581]                       }
[08:26:21.581]                       invisible(muffled)
[08:26:21.581]                     }
[08:26:21.581]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.581]                   }
[08:26:21.581]                 }
[08:26:21.581]             }
[08:26:21.581]         }))
[08:26:21.581]     }, error = function(ex) {
[08:26:21.581]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:21.581]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.581]                 ...future.rng), started = ...future.startTime, 
[08:26:21.581]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:21.581]             version = "1.8"), class = "FutureResult")
[08:26:21.581]     }, finally = {
[08:26:21.581]         if (!identical(...future.workdir, getwd())) 
[08:26:21.581]             setwd(...future.workdir)
[08:26:21.581]         {
[08:26:21.581]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:21.581]                 ...future.oldOptions$nwarnings <- NULL
[08:26:21.581]             }
[08:26:21.581]             base::options(...future.oldOptions)
[08:26:21.581]             if (.Platform$OS.type == "windows") {
[08:26:21.581]                 old_names <- names(...future.oldEnvVars)
[08:26:21.581]                 envs <- base::Sys.getenv()
[08:26:21.581]                 names <- names(envs)
[08:26:21.581]                 common <- intersect(names, old_names)
[08:26:21.581]                 added <- setdiff(names, old_names)
[08:26:21.581]                 removed <- setdiff(old_names, names)
[08:26:21.581]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:21.581]                   envs[common]]
[08:26:21.581]                 NAMES <- toupper(changed)
[08:26:21.581]                 args <- list()
[08:26:21.581]                 for (kk in seq_along(NAMES)) {
[08:26:21.581]                   name <- changed[[kk]]
[08:26:21.581]                   NAME <- NAMES[[kk]]
[08:26:21.581]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.581]                     next
[08:26:21.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.581]                 }
[08:26:21.581]                 NAMES <- toupper(added)
[08:26:21.581]                 for (kk in seq_along(NAMES)) {
[08:26:21.581]                   name <- added[[kk]]
[08:26:21.581]                   NAME <- NAMES[[kk]]
[08:26:21.581]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.581]                     next
[08:26:21.581]                   args[[name]] <- ""
[08:26:21.581]                 }
[08:26:21.581]                 NAMES <- toupper(removed)
[08:26:21.581]                 for (kk in seq_along(NAMES)) {
[08:26:21.581]                   name <- removed[[kk]]
[08:26:21.581]                   NAME <- NAMES[[kk]]
[08:26:21.581]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.581]                     next
[08:26:21.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.581]                 }
[08:26:21.581]                 if (length(args) > 0) 
[08:26:21.581]                   base::do.call(base::Sys.setenv, args = args)
[08:26:21.581]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:21.581]             }
[08:26:21.581]             else {
[08:26:21.581]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:21.581]             }
[08:26:21.581]             {
[08:26:21.581]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:21.581]                   0L) {
[08:26:21.581]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:21.581]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:21.581]                   base::options(opts)
[08:26:21.581]                 }
[08:26:21.581]                 {
[08:26:21.581]                   {
[08:26:21.581]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:21.581]                     NULL
[08:26:21.581]                   }
[08:26:21.581]                   options(future.plan = NULL)
[08:26:21.581]                   if (is.na(NA_character_)) 
[08:26:21.581]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.581]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:21.581]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:21.581]                     .init = FALSE)
[08:26:21.581]                 }
[08:26:21.581]             }
[08:26:21.581]         }
[08:26:21.581]     })
[08:26:21.581]     if (TRUE) {
[08:26:21.581]         base::sink(type = "output", split = FALSE)
[08:26:21.581]         if (TRUE) {
[08:26:21.581]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:21.581]         }
[08:26:21.581]         else {
[08:26:21.581]             ...future.result["stdout"] <- base::list(NULL)
[08:26:21.581]         }
[08:26:21.581]         base::close(...future.stdout)
[08:26:21.581]         ...future.stdout <- NULL
[08:26:21.581]     }
[08:26:21.581]     ...future.result$conditions <- ...future.conditions
[08:26:21.581]     ...future.result$finished <- base::Sys.time()
[08:26:21.581]     ...future.result
[08:26:21.581] }
[08:26:21.585] assign_globals() ...
[08:26:21.585] List of 11
[08:26:21.585]  $ ...future.FUN            :function (x, ...)  
[08:26:21.585]  $ x_FUN                    :function (x)  
[08:26:21.585]  $ times                    : int 1
[08:26:21.585]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:21.585]  $ stop_if_not              :function (...)  
[08:26:21.585]  $ dim                      : NULL
[08:26:21.585]  $ valid_types              : chr [1:2] "logical" "integer"
[08:26:21.585]  $ future.call.arguments    : list()
[08:26:21.585]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:21.585]  $ ...future.elements_ii    :List of 2
[08:26:21.585]   ..$ b: num 2
[08:26:21.585]   ..$ c: num 3
[08:26:21.585]  $ ...future.seeds_ii       : NULL
[08:26:21.585]  $ ...future.globals.maxSize: NULL
[08:26:21.585]  - attr(*, "where")=List of 11
[08:26:21.585]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:21.585]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:21.585]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:21.585]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:21.585]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:21.585]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:21.585]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:21.585]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:21.585]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:21.585]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:21.585]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:21.585]  - attr(*, "resolved")= logi FALSE
[08:26:21.585]  - attr(*, "total_size")= num 22016
[08:26:21.585]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:21.585]  - attr(*, "already-done")= logi TRUE
[08:26:21.599] - copied ‘...future.FUN’ to environment
[08:26:21.599] - copied ‘x_FUN’ to environment
[08:26:21.600] - copied ‘times’ to environment
[08:26:21.600] - copied ‘stopf’ to environment
[08:26:21.600] - copied ‘stop_if_not’ to environment
[08:26:21.600] - copied ‘dim’ to environment
[08:26:21.600] - copied ‘valid_types’ to environment
[08:26:21.600] - copied ‘future.call.arguments’ to environment
[08:26:21.600] - copied ‘...future.elements_ii’ to environment
[08:26:21.600] - copied ‘...future.seeds_ii’ to environment
[08:26:21.600] - copied ‘...future.globals.maxSize’ to environment
[08:26:21.601] assign_globals() ... done
[08:26:21.601] requestCore(): workers = 2
[08:26:21.603] MulticoreFuture started
[08:26:21.604] - Launch lazy future ... done
[08:26:21.604] run() for ‘MulticoreFuture’ ... done
[08:26:21.604] Created future:
[08:26:21.605] plan(): Setting new future strategy stack:
[08:26:21.605] List of future strategies:
[08:26:21.605] 1. sequential:
[08:26:21.605]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:21.605]    - tweaked: FALSE
[08:26:21.605]    - call: NULL
[08:26:21.606] plan(): nbrOfWorkers() = 1
[08:26:21.609] plan(): Setting new future strategy stack:
[08:26:21.609] List of future strategies:
[08:26:21.609] 1. multicore:
[08:26:21.609]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:21.609]    - tweaked: FALSE
[08:26:21.609]    - call: plan(strategy)
[08:26:21.612] plan(): nbrOfWorkers() = 2
[08:26:21.604] MulticoreFuture:
[08:26:21.604] Label: ‘future_vapply-2’
[08:26:21.604] Expression:
[08:26:21.604] {
[08:26:21.604]     do.call(function(...) {
[08:26:21.604]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.604]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.604]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.604]             on.exit(options(oopts), add = TRUE)
[08:26:21.604]         }
[08:26:21.604]         {
[08:26:21.604]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.604]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.604]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.604]             })
[08:26:21.604]         }
[08:26:21.604]     }, args = future.call.arguments)
[08:26:21.604] }
[08:26:21.604] Lazy evaluation: FALSE
[08:26:21.604] Asynchronous evaluation: TRUE
[08:26:21.604] Local evaluation: TRUE
[08:26:21.604] Environment: R_GlobalEnv
[08:26:21.604] Capture standard output: TRUE
[08:26:21.604] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:21.604] Globals: 11 objects totaling 12.17 KiB (function ‘...future.FUN’ of 3.91 KiB, function ‘x_FUN’ of 37 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:21.604] Packages: 1 packages (‘future.apply’)
[08:26:21.604] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:21.604] Resolved: TRUE
[08:26:21.604] Value: <not collected>
[08:26:21.604] Conditions captured: <none>
[08:26:21.604] Early signaling: FALSE
[08:26:21.604] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:21.604] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.614] Chunk #2 of 2 ... DONE
[08:26:21.614] Launching 2 futures (chunks) ... DONE
[08:26:21.614] Resolving 2 futures (chunks) ...
[08:26:21.614] resolve() on list ...
[08:26:21.614]  recursive: 0
[08:26:21.615]  length: 2
[08:26:21.615] 
[08:26:21.615] Future #1
[08:26:21.615] result() for MulticoreFuture ...
[08:26:21.616] result() for MulticoreFuture ...
[08:26:21.616] result() for MulticoreFuture ... done
[08:26:21.616] result() for MulticoreFuture ... done
[08:26:21.617] result() for MulticoreFuture ...
[08:26:21.617] result() for MulticoreFuture ... done
[08:26:21.617] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:26:21.617] - nx: 2
[08:26:21.617] - relay: TRUE
[08:26:21.617] - stdout: TRUE
[08:26:21.617] - signal: TRUE
[08:26:21.618] - resignal: FALSE
[08:26:21.618] - force: TRUE
[08:26:21.618] - relayed: [n=2] FALSE, FALSE
[08:26:21.618] - queued futures: [n=2] FALSE, FALSE
[08:26:21.618]  - until=1
[08:26:21.618]  - relaying element #1
[08:26:21.618] result() for MulticoreFuture ...
[08:26:21.619] result() for MulticoreFuture ... done
[08:26:21.619] result() for MulticoreFuture ...
[08:26:21.619] result() for MulticoreFuture ... done
[08:26:21.619] result() for MulticoreFuture ...
[08:26:21.619] result() for MulticoreFuture ... done
[08:26:21.620] result() for MulticoreFuture ...
[08:26:21.620] result() for MulticoreFuture ... done
[08:26:21.620] - relayed: [n=2] TRUE, FALSE
[08:26:21.620] - queued futures: [n=2] TRUE, FALSE
[08:26:21.620] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:26:21.620]  length: 1 (resolved future 1)
[08:26:21.621] Future #2
[08:26:21.621] result() for MulticoreFuture ...
[08:26:21.622] result() for MulticoreFuture ...
[08:26:21.622] result() for MulticoreFuture ... done
[08:26:21.622] result() for MulticoreFuture ... done
[08:26:21.622] result() for MulticoreFuture ...
[08:26:21.622] result() for MulticoreFuture ... done
[08:26:21.622] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:26:21.623] - nx: 2
[08:26:21.623] - relay: TRUE
[08:26:21.623] - stdout: TRUE
[08:26:21.623] - signal: TRUE
[08:26:21.623] - resignal: FALSE
[08:26:21.623] - force: TRUE
[08:26:21.623] - relayed: [n=2] TRUE, FALSE
[08:26:21.623] - queued futures: [n=2] TRUE, FALSE
[08:26:21.624]  - until=2
[08:26:21.627]  - relaying element #2
[08:26:21.627] result() for MulticoreFuture ...
[08:26:21.627] result() for MulticoreFuture ... done
[08:26:21.628] result() for MulticoreFuture ...
[08:26:21.628] result() for MulticoreFuture ... done
[08:26:21.628] result() for MulticoreFuture ...
[08:26:21.628] result() for MulticoreFuture ... done
[08:26:21.628] result() for MulticoreFuture ...
[08:26:21.629] result() for MulticoreFuture ... done
[08:26:21.629] - relayed: [n=2] TRUE, TRUE
[08:26:21.629] - queued futures: [n=2] TRUE, TRUE
[08:26:21.629] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:26:21.629]  length: 0 (resolved future 2)
[08:26:21.630] Relaying remaining futures
[08:26:21.630] signalConditionsASAP(NULL, pos=0) ...
[08:26:21.630] - nx: 2
[08:26:21.630] - relay: TRUE
[08:26:21.630] - stdout: TRUE
[08:26:21.630] - signal: TRUE
[08:26:21.630] - resignal: FALSE
[08:26:21.631] - force: TRUE
[08:26:21.631] - relayed: [n=2] TRUE, TRUE
[08:26:21.631] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:21.631] - relayed: [n=2] TRUE, TRUE
[08:26:21.631] - queued futures: [n=2] TRUE, TRUE
[08:26:21.631] signalConditionsASAP(NULL, pos=0) ... done
[08:26:21.631] resolve() on list ... DONE
[08:26:21.632] result() for MulticoreFuture ...
[08:26:21.632] result() for MulticoreFuture ... done
[08:26:21.632] result() for MulticoreFuture ...
[08:26:21.632] result() for MulticoreFuture ... done
[08:26:21.632] result() for MulticoreFuture ...
[08:26:21.632] result() for MulticoreFuture ... done
[08:26:21.632] result() for MulticoreFuture ...
[08:26:21.633] result() for MulticoreFuture ... done
[08:26:21.633]  - Number of value chunks collected: 2
[08:26:21.633] Resolving 2 futures (chunks) ... DONE
[08:26:21.633] Reducing values from 2 chunks ...
[08:26:21.633]  - Number of values collected after concatenation: 3
[08:26:21.633]  - Number of values expected: 3
[08:26:21.634] Reducing values from 2 chunks ... DONE
[08:26:21.634] future_lapply() ... DONE
- exceptions ...
[08:26:21.634] future_lapply() ...
[08:26:21.639] Number of chunks: 2
[08:26:21.639] getGlobalsAndPackagesXApply() ...
[08:26:21.639]  - future.globals: TRUE
[08:26:21.640] getGlobalsAndPackages() ...
[08:26:21.640] Searching for globals...
[08:26:21.644] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[08:26:21.644] Searching for globals ... DONE
[08:26:21.644] Resolving globals: FALSE
[08:26:21.645] The total size of the 7 globals is 12.81 KiB (13119 bytes)
[08:26:21.645] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.65 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:21.645] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:21.646] - packages: [1] ‘future.apply’
[08:26:21.646] getGlobalsAndPackages() ... DONE
[08:26:21.646]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:21.646]  - needed namespaces: [n=1] ‘future.apply’
[08:26:21.646] Finding globals ... DONE
[08:26:21.646]  - use_args: TRUE
[08:26:21.646]  - Getting '...' globals ...
[08:26:21.647] resolve() on list ...
[08:26:21.647]  recursive: 0
[08:26:21.647]  length: 1
[08:26:21.647]  elements: ‘...’
[08:26:21.647]  length: 0 (resolved future 1)
[08:26:21.647] resolve() on list ... DONE
[08:26:21.647]    - '...' content: [n=0] 
[08:26:21.647] List of 1
[08:26:21.647]  $ ...: list()
[08:26:21.647]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:21.647]  - attr(*, "where")=List of 1
[08:26:21.647]   ..$ ...:<environment: 0x562ca8348910> 
[08:26:21.647]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:21.647]  - attr(*, "resolved")= logi TRUE
[08:26:21.647]  - attr(*, "total_size")= num NA
[08:26:21.650]  - Getting '...' globals ... DONE
[08:26:21.650] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:21.650] List of 8
[08:26:21.650]  $ ...future.FUN:function (x, ...)  
[08:26:21.650]  $ x_FUN        :function (x)  
[08:26:21.650]  $ times        : int 2
[08:26:21.650]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:21.650]  $ stop_if_not  :function (...)  
[08:26:21.650]  $ dim          : NULL
[08:26:21.650]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:21.650]  $ ...          : list()
[08:26:21.650]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:21.650]  - attr(*, "where")=List of 8
[08:26:21.650]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:21.650]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:21.650]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:21.650]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:21.650]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:21.650]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:21.650]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:21.650]   ..$ ...          :<environment: 0x562ca8348910> 
[08:26:21.650]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:21.650]  - attr(*, "resolved")= logi FALSE
[08:26:21.650]  - attr(*, "total_size")= num 23676
[08:26:21.660] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:21.660] getGlobalsAndPackagesXApply() ... DONE
[08:26:21.660] Number of futures (= number of chunks): 2
[08:26:21.660] Launching 2 futures (chunks) ...
[08:26:21.660] Chunk #1 of 2 ...
[08:26:21.661]  - Finding globals in 'X' for chunk #1 ...
[08:26:21.661] getGlobalsAndPackages() ...
[08:26:21.661] Searching for globals...
[08:26:21.661] 
[08:26:21.661] Searching for globals ... DONE
[08:26:21.661] - globals: [0] <none>
[08:26:21.661] getGlobalsAndPackages() ... DONE
[08:26:21.662]    + additional globals found: [n=0] 
[08:26:21.662]    + additional namespaces needed: [n=0] 
[08:26:21.662]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:21.662]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:21.662]  - seeds: <none>
[08:26:21.662]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.662] getGlobalsAndPackages() ...
[08:26:21.662] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.662] Resolving globals: FALSE
[08:26:21.662] Tweak future expression to call with '...' arguments ...
[08:26:21.663] {
[08:26:21.663]     do.call(function(...) {
[08:26:21.663]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.663]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.663]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.663]             on.exit(options(oopts), add = TRUE)
[08:26:21.663]         }
[08:26:21.663]         {
[08:26:21.663]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.663]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.663]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.663]             })
[08:26:21.663]         }
[08:26:21.663]     }, args = future.call.arguments)
[08:26:21.663] }
[08:26:21.663] Tweak future expression to call with '...' arguments ... DONE
[08:26:21.663] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.664] - packages: [1] ‘future.apply’
[08:26:21.664] getGlobalsAndPackages() ... DONE
[08:26:21.664] run() for ‘Future’ ...
[08:26:21.664] - state: ‘created’
[08:26:21.664] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:21.666] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.666] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:21.666]   - Field: ‘label’
[08:26:21.666]   - Field: ‘local’
[08:26:21.667]   - Field: ‘owner’
[08:26:21.667]   - Field: ‘envir’
[08:26:21.667]   - Field: ‘workers’
[08:26:21.667]   - Field: ‘packages’
[08:26:21.667]   - Field: ‘gc’
[08:26:21.667]   - Field: ‘job’
[08:26:21.667]   - Field: ‘conditions’
[08:26:21.667]   - Field: ‘expr’
[08:26:21.667]   - Field: ‘uuid’
[08:26:21.667]   - Field: ‘seed’
[08:26:21.667]   - Field: ‘version’
[08:26:21.668]   - Field: ‘result’
[08:26:21.668]   - Field: ‘asynchronous’
[08:26:21.668]   - Field: ‘calls’
[08:26:21.668]   - Field: ‘globals’
[08:26:21.668]   - Field: ‘stdout’
[08:26:21.668]   - Field: ‘earlySignal’
[08:26:21.668]   - Field: ‘lazy’
[08:26:21.668]   - Field: ‘state’
[08:26:21.668] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:21.668] - Launch lazy future ...
[08:26:21.669] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:21.669] Packages needed by future strategies (n = 0): <none>
[08:26:21.669] {
[08:26:21.669]     {
[08:26:21.669]         {
[08:26:21.669]             ...future.startTime <- base::Sys.time()
[08:26:21.669]             {
[08:26:21.669]                 {
[08:26:21.669]                   {
[08:26:21.669]                     {
[08:26:21.669]                       {
[08:26:21.669]                         base::local({
[08:26:21.669]                           has_future <- base::requireNamespace("future", 
[08:26:21.669]                             quietly = TRUE)
[08:26:21.669]                           if (has_future) {
[08:26:21.669]                             ns <- base::getNamespace("future")
[08:26:21.669]                             version <- ns[[".package"]][["version"]]
[08:26:21.669]                             if (is.null(version)) 
[08:26:21.669]                               version <- utils::packageVersion("future")
[08:26:21.669]                           }
[08:26:21.669]                           else {
[08:26:21.669]                             version <- NULL
[08:26:21.669]                           }
[08:26:21.669]                           if (!has_future || version < "1.8.0") {
[08:26:21.669]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:21.669]                               "", base::R.version$version.string), 
[08:26:21.669]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:21.669]                                 base::R.version$platform, 8 * 
[08:26:21.669]                                   base::.Machine$sizeof.pointer), 
[08:26:21.669]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:21.669]                                 "release", "version")], collapse = " "), 
[08:26:21.669]                               hostname = base::Sys.info()[["nodename"]])
[08:26:21.669]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:21.669]                               info)
[08:26:21.669]                             info <- base::paste(info, collapse = "; ")
[08:26:21.669]                             if (!has_future) {
[08:26:21.669]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:21.669]                                 info)
[08:26:21.669]                             }
[08:26:21.669]                             else {
[08:26:21.669]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:21.669]                                 info, version)
[08:26:21.669]                             }
[08:26:21.669]                             base::stop(msg)
[08:26:21.669]                           }
[08:26:21.669]                         })
[08:26:21.669]                       }
[08:26:21.669]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:21.669]                       base::options(mc.cores = 1L)
[08:26:21.669]                     }
[08:26:21.669]                     base::local({
[08:26:21.669]                       for (pkg in "future.apply") {
[08:26:21.669]                         base::loadNamespace(pkg)
[08:26:21.669]                         base::library(pkg, character.only = TRUE)
[08:26:21.669]                       }
[08:26:21.669]                     })
[08:26:21.669]                   }
[08:26:21.669]                   ...future.strategy.old <- future::plan("list")
[08:26:21.669]                   options(future.plan = NULL)
[08:26:21.669]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.669]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:21.669]                 }
[08:26:21.669]                 ...future.workdir <- getwd()
[08:26:21.669]             }
[08:26:21.669]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:21.669]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:21.669]         }
[08:26:21.669]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:21.669]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:21.669]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:21.669]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:21.669]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:21.669]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:21.669]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:21.669]             base::names(...future.oldOptions))
[08:26:21.669]     }
[08:26:21.669]     if (FALSE) {
[08:26:21.669]     }
[08:26:21.669]     else {
[08:26:21.669]         if (TRUE) {
[08:26:21.669]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:21.669]                 open = "w")
[08:26:21.669]         }
[08:26:21.669]         else {
[08:26:21.669]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:21.669]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:21.669]         }
[08:26:21.669]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:21.669]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:21.669]             base::sink(type = "output", split = FALSE)
[08:26:21.669]             base::close(...future.stdout)
[08:26:21.669]         }, add = TRUE)
[08:26:21.669]     }
[08:26:21.669]     ...future.frame <- base::sys.nframe()
[08:26:21.669]     ...future.conditions <- base::list()
[08:26:21.669]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:21.669]     if (FALSE) {
[08:26:21.669]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:21.669]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:21.669]     }
[08:26:21.669]     ...future.result <- base::tryCatch({
[08:26:21.669]         base::withCallingHandlers({
[08:26:21.669]             ...future.value <- base::withVisible(base::local({
[08:26:21.669]                 withCallingHandlers({
[08:26:21.669]                   {
[08:26:21.669]                     do.call(function(...) {
[08:26:21.669]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.669]                       if (!identical(...future.globals.maxSize.org, 
[08:26:21.669]                         ...future.globals.maxSize)) {
[08:26:21.669]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.669]                         on.exit(options(oopts), add = TRUE)
[08:26:21.669]                       }
[08:26:21.669]                       {
[08:26:21.669]                         lapply(seq_along(...future.elements_ii), 
[08:26:21.669]                           FUN = function(jj) {
[08:26:21.669]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.669]                             ...future.FUN(...future.X_jj, ...)
[08:26:21.669]                           })
[08:26:21.669]                       }
[08:26:21.669]                     }, args = future.call.arguments)
[08:26:21.669]                   }
[08:26:21.669]                 }, immediateCondition = function(cond) {
[08:26:21.669]                   save_rds <- function (object, pathname, ...) 
[08:26:21.669]                   {
[08:26:21.669]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:21.669]                     if (file_test("-f", pathname_tmp)) {
[08:26:21.669]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.669]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:21.669]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.669]                         fi_tmp[["mtime"]])
[08:26:21.669]                     }
[08:26:21.669]                     tryCatch({
[08:26:21.669]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:21.669]                     }, error = function(ex) {
[08:26:21.669]                       msg <- conditionMessage(ex)
[08:26:21.669]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.669]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:21.669]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.669]                         fi_tmp[["mtime"]], msg)
[08:26:21.669]                       ex$message <- msg
[08:26:21.669]                       stop(ex)
[08:26:21.669]                     })
[08:26:21.669]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:21.669]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:21.669]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:21.669]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.669]                       fi <- file.info(pathname)
[08:26:21.669]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:21.669]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.669]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:21.669]                         fi[["size"]], fi[["mtime"]])
[08:26:21.669]                       stop(msg)
[08:26:21.669]                     }
[08:26:21.669]                     invisible(pathname)
[08:26:21.669]                   }
[08:26:21.669]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:21.669]                     rootPath = tempdir()) 
[08:26:21.669]                   {
[08:26:21.669]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:21.669]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:21.669]                       tmpdir = path, fileext = ".rds")
[08:26:21.669]                     save_rds(obj, file)
[08:26:21.669]                   }
[08:26:21.669]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:21.669]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.669]                   {
[08:26:21.669]                     inherits <- base::inherits
[08:26:21.669]                     invokeRestart <- base::invokeRestart
[08:26:21.669]                     is.null <- base::is.null
[08:26:21.669]                     muffled <- FALSE
[08:26:21.669]                     if (inherits(cond, "message")) {
[08:26:21.669]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:21.669]                       if (muffled) 
[08:26:21.669]                         invokeRestart("muffleMessage")
[08:26:21.669]                     }
[08:26:21.669]                     else if (inherits(cond, "warning")) {
[08:26:21.669]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:21.669]                       if (muffled) 
[08:26:21.669]                         invokeRestart("muffleWarning")
[08:26:21.669]                     }
[08:26:21.669]                     else if (inherits(cond, "condition")) {
[08:26:21.669]                       if (!is.null(pattern)) {
[08:26:21.669]                         computeRestarts <- base::computeRestarts
[08:26:21.669]                         grepl <- base::grepl
[08:26:21.669]                         restarts <- computeRestarts(cond)
[08:26:21.669]                         for (restart in restarts) {
[08:26:21.669]                           name <- restart$name
[08:26:21.669]                           if (is.null(name)) 
[08:26:21.669]                             next
[08:26:21.669]                           if (!grepl(pattern, name)) 
[08:26:21.669]                             next
[08:26:21.669]                           invokeRestart(restart)
[08:26:21.669]                           muffled <- TRUE
[08:26:21.669]                           break
[08:26:21.669]                         }
[08:26:21.669]                       }
[08:26:21.669]                     }
[08:26:21.669]                     invisible(muffled)
[08:26:21.669]                   }
[08:26:21.669]                   muffleCondition(cond)
[08:26:21.669]                 })
[08:26:21.669]             }))
[08:26:21.669]             future::FutureResult(value = ...future.value$value, 
[08:26:21.669]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.669]                   ...future.rng), globalenv = if (FALSE) 
[08:26:21.669]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:21.669]                     ...future.globalenv.names))
[08:26:21.669]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:21.669]         }, condition = base::local({
[08:26:21.669]             c <- base::c
[08:26:21.669]             inherits <- base::inherits
[08:26:21.669]             invokeRestart <- base::invokeRestart
[08:26:21.669]             length <- base::length
[08:26:21.669]             list <- base::list
[08:26:21.669]             seq.int <- base::seq.int
[08:26:21.669]             signalCondition <- base::signalCondition
[08:26:21.669]             sys.calls <- base::sys.calls
[08:26:21.669]             `[[` <- base::`[[`
[08:26:21.669]             `+` <- base::`+`
[08:26:21.669]             `<<-` <- base::`<<-`
[08:26:21.669]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:21.669]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:21.669]                   3L)]
[08:26:21.669]             }
[08:26:21.669]             function(cond) {
[08:26:21.669]                 is_error <- inherits(cond, "error")
[08:26:21.669]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:21.669]                   NULL)
[08:26:21.669]                 if (is_error) {
[08:26:21.669]                   sessionInformation <- function() {
[08:26:21.669]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:21.669]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:21.669]                       search = base::search(), system = base::Sys.info())
[08:26:21.669]                   }
[08:26:21.669]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.669]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:21.669]                     cond$call), session = sessionInformation(), 
[08:26:21.669]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:21.669]                   signalCondition(cond)
[08:26:21.669]                 }
[08:26:21.669]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:21.669]                 "immediateCondition"))) {
[08:26:21.669]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:21.669]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.669]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:21.669]                   if (TRUE && !signal) {
[08:26:21.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.669]                     {
[08:26:21.669]                       inherits <- base::inherits
[08:26:21.669]                       invokeRestart <- base::invokeRestart
[08:26:21.669]                       is.null <- base::is.null
[08:26:21.669]                       muffled <- FALSE
[08:26:21.669]                       if (inherits(cond, "message")) {
[08:26:21.669]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.669]                         if (muffled) 
[08:26:21.669]                           invokeRestart("muffleMessage")
[08:26:21.669]                       }
[08:26:21.669]                       else if (inherits(cond, "warning")) {
[08:26:21.669]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.669]                         if (muffled) 
[08:26:21.669]                           invokeRestart("muffleWarning")
[08:26:21.669]                       }
[08:26:21.669]                       else if (inherits(cond, "condition")) {
[08:26:21.669]                         if (!is.null(pattern)) {
[08:26:21.669]                           computeRestarts <- base::computeRestarts
[08:26:21.669]                           grepl <- base::grepl
[08:26:21.669]                           restarts <- computeRestarts(cond)
[08:26:21.669]                           for (restart in restarts) {
[08:26:21.669]                             name <- restart$name
[08:26:21.669]                             if (is.null(name)) 
[08:26:21.669]                               next
[08:26:21.669]                             if (!grepl(pattern, name)) 
[08:26:21.669]                               next
[08:26:21.669]                             invokeRestart(restart)
[08:26:21.669]                             muffled <- TRUE
[08:26:21.669]                             break
[08:26:21.669]                           }
[08:26:21.669]                         }
[08:26:21.669]                       }
[08:26:21.669]                       invisible(muffled)
[08:26:21.669]                     }
[08:26:21.669]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.669]                   }
[08:26:21.669]                 }
[08:26:21.669]                 else {
[08:26:21.669]                   if (TRUE) {
[08:26:21.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.669]                     {
[08:26:21.669]                       inherits <- base::inherits
[08:26:21.669]                       invokeRestart <- base::invokeRestart
[08:26:21.669]                       is.null <- base::is.null
[08:26:21.669]                       muffled <- FALSE
[08:26:21.669]                       if (inherits(cond, "message")) {
[08:26:21.669]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.669]                         if (muffled) 
[08:26:21.669]                           invokeRestart("muffleMessage")
[08:26:21.669]                       }
[08:26:21.669]                       else if (inherits(cond, "warning")) {
[08:26:21.669]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.669]                         if (muffled) 
[08:26:21.669]                           invokeRestart("muffleWarning")
[08:26:21.669]                       }
[08:26:21.669]                       else if (inherits(cond, "condition")) {
[08:26:21.669]                         if (!is.null(pattern)) {
[08:26:21.669]                           computeRestarts <- base::computeRestarts
[08:26:21.669]                           grepl <- base::grepl
[08:26:21.669]                           restarts <- computeRestarts(cond)
[08:26:21.669]                           for (restart in restarts) {
[08:26:21.669]                             name <- restart$name
[08:26:21.669]                             if (is.null(name)) 
[08:26:21.669]                               next
[08:26:21.669]                             if (!grepl(pattern, name)) 
[08:26:21.669]                               next
[08:26:21.669]                             invokeRestart(restart)
[08:26:21.669]                             muffled <- TRUE
[08:26:21.669]                             break
[08:26:21.669]                           }
[08:26:21.669]                         }
[08:26:21.669]                       }
[08:26:21.669]                       invisible(muffled)
[08:26:21.669]                     }
[08:26:21.669]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.669]                   }
[08:26:21.669]                 }
[08:26:21.669]             }
[08:26:21.669]         }))
[08:26:21.669]     }, error = function(ex) {
[08:26:21.669]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:21.669]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.669]                 ...future.rng), started = ...future.startTime, 
[08:26:21.669]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:21.669]             version = "1.8"), class = "FutureResult")
[08:26:21.669]     }, finally = {
[08:26:21.669]         if (!identical(...future.workdir, getwd())) 
[08:26:21.669]             setwd(...future.workdir)
[08:26:21.669]         {
[08:26:21.669]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:21.669]                 ...future.oldOptions$nwarnings <- NULL
[08:26:21.669]             }
[08:26:21.669]             base::options(...future.oldOptions)
[08:26:21.669]             if (.Platform$OS.type == "windows") {
[08:26:21.669]                 old_names <- names(...future.oldEnvVars)
[08:26:21.669]                 envs <- base::Sys.getenv()
[08:26:21.669]                 names <- names(envs)
[08:26:21.669]                 common <- intersect(names, old_names)
[08:26:21.669]                 added <- setdiff(names, old_names)
[08:26:21.669]                 removed <- setdiff(old_names, names)
[08:26:21.669]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:21.669]                   envs[common]]
[08:26:21.669]                 NAMES <- toupper(changed)
[08:26:21.669]                 args <- list()
[08:26:21.669]                 for (kk in seq_along(NAMES)) {
[08:26:21.669]                   name <- changed[[kk]]
[08:26:21.669]                   NAME <- NAMES[[kk]]
[08:26:21.669]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.669]                     next
[08:26:21.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.669]                 }
[08:26:21.669]                 NAMES <- toupper(added)
[08:26:21.669]                 for (kk in seq_along(NAMES)) {
[08:26:21.669]                   name <- added[[kk]]
[08:26:21.669]                   NAME <- NAMES[[kk]]
[08:26:21.669]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.669]                     next
[08:26:21.669]                   args[[name]] <- ""
[08:26:21.669]                 }
[08:26:21.669]                 NAMES <- toupper(removed)
[08:26:21.669]                 for (kk in seq_along(NAMES)) {
[08:26:21.669]                   name <- removed[[kk]]
[08:26:21.669]                   NAME <- NAMES[[kk]]
[08:26:21.669]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.669]                     next
[08:26:21.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.669]                 }
[08:26:21.669]                 if (length(args) > 0) 
[08:26:21.669]                   base::do.call(base::Sys.setenv, args = args)
[08:26:21.669]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:21.669]             }
[08:26:21.669]             else {
[08:26:21.669]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:21.669]             }
[08:26:21.669]             {
[08:26:21.669]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:21.669]                   0L) {
[08:26:21.669]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:21.669]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:21.669]                   base::options(opts)
[08:26:21.669]                 }
[08:26:21.669]                 {
[08:26:21.669]                   {
[08:26:21.669]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:21.669]                     NULL
[08:26:21.669]                   }
[08:26:21.669]                   options(future.plan = NULL)
[08:26:21.669]                   if (is.na(NA_character_)) 
[08:26:21.669]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.669]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:21.669]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:21.669]                     .init = FALSE)
[08:26:21.669]                 }
[08:26:21.669]             }
[08:26:21.669]         }
[08:26:21.669]     })
[08:26:21.669]     if (TRUE) {
[08:26:21.669]         base::sink(type = "output", split = FALSE)
[08:26:21.669]         if (TRUE) {
[08:26:21.669]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:21.669]         }
[08:26:21.669]         else {
[08:26:21.669]             ...future.result["stdout"] <- base::list(NULL)
[08:26:21.669]         }
[08:26:21.669]         base::close(...future.stdout)
[08:26:21.669]         ...future.stdout <- NULL
[08:26:21.669]     }
[08:26:21.669]     ...future.result$conditions <- ...future.conditions
[08:26:21.669]     ...future.result$finished <- base::Sys.time()
[08:26:21.669]     ...future.result
[08:26:21.669] }
[08:26:21.672] assign_globals() ...
[08:26:21.672] List of 11
[08:26:21.672]  $ ...future.FUN            :function (x, ...)  
[08:26:21.672]  $ x_FUN                    :function (x)  
[08:26:21.672]  $ times                    : int 2
[08:26:21.672]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:21.672]  $ stop_if_not              :function (...)  
[08:26:21.672]  $ dim                      : NULL
[08:26:21.672]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:21.672]  $ future.call.arguments    : list()
[08:26:21.672]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:21.672]  $ ...future.elements_ii    :List of 1
[08:26:21.672]   ..$ : int 1
[08:26:21.672]  $ ...future.seeds_ii       : NULL
[08:26:21.672]  $ ...future.globals.maxSize: NULL
[08:26:21.672]  - attr(*, "where")=List of 11
[08:26:21.672]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:21.672]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:21.672]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:21.672]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:21.672]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:21.672]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:21.672]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:21.672]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:21.672]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:21.672]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:21.672]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:21.672]  - attr(*, "resolved")= logi FALSE
[08:26:21.672]  - attr(*, "total_size")= num 23676
[08:26:21.672]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:21.672]  - attr(*, "already-done")= logi TRUE
[08:26:21.684] - copied ‘...future.FUN’ to environment
[08:26:21.684] - copied ‘x_FUN’ to environment
[08:26:21.684] - copied ‘times’ to environment
[08:26:21.684] - copied ‘stopf’ to environment
[08:26:21.684] - copied ‘stop_if_not’ to environment
[08:26:21.684] - copied ‘dim’ to environment
[08:26:21.685] - copied ‘valid_types’ to environment
[08:26:21.685] - copied ‘future.call.arguments’ to environment
[08:26:21.685] - copied ‘...future.elements_ii’ to environment
[08:26:21.685] - copied ‘...future.seeds_ii’ to environment
[08:26:21.685] - copied ‘...future.globals.maxSize’ to environment
[08:26:21.685] assign_globals() ... done
[08:26:21.685] requestCore(): workers = 2
[08:26:21.688] MulticoreFuture started
[08:26:21.689] - Launch lazy future ... done
[08:26:21.689] run() for ‘MulticoreFuture’ ... done
[08:26:21.690] Created future:
[08:26:21.690] plan(): Setting new future strategy stack:
[08:26:21.691] List of future strategies:
[08:26:21.691] 1. sequential:
[08:26:21.691]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:21.691]    - tweaked: FALSE
[08:26:21.691]    - call: NULL
[08:26:21.693] plan(): nbrOfWorkers() = 1
[08:26:21.696] plan(): Setting new future strategy stack:
[08:26:21.696] List of future strategies:
[08:26:21.696] 1. multicore:
[08:26:21.696]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:21.696]    - tweaked: FALSE
[08:26:21.696]    - call: plan(strategy)
[08:26:21.701] plan(): nbrOfWorkers() = 2
[08:26:21.690] MulticoreFuture:
[08:26:21.690] Label: ‘future_vapply-1’
[08:26:21.690] Expression:
[08:26:21.690] {
[08:26:21.690]     do.call(function(...) {
[08:26:21.690]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.690]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.690]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.690]             on.exit(options(oopts), add = TRUE)
[08:26:21.690]         }
[08:26:21.690]         {
[08:26:21.690]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.690]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.690]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.690]             })
[08:26:21.690]         }
[08:26:21.690]     }, args = future.call.arguments)
[08:26:21.690] }
[08:26:21.690] Lazy evaluation: FALSE
[08:26:21.690] Asynchronous evaluation: TRUE
[08:26:21.690] Local evaluation: TRUE
[08:26:21.690] Environment: R_GlobalEnv
[08:26:21.690] Capture standard output: TRUE
[08:26:21.690] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:21.690] Globals: 11 objects totaling 13.00 KiB (function ‘...future.FUN’ of 4.65 KiB, function ‘x_FUN’ of 185 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:21.690] Packages: 1 packages (‘future.apply’)
[08:26:21.690] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:21.690] Resolved: FALSE
[08:26:21.690] Value: <not collected>
[08:26:21.690] Conditions captured: <none>
[08:26:21.690] Early signaling: FALSE
[08:26:21.690] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:21.690] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.704] Chunk #1 of 2 ... DONE
[08:26:21.705] Chunk #2 of 2 ...
[08:26:21.705]  - Finding globals in 'X' for chunk #2 ...
[08:26:21.705] getGlobalsAndPackages() ...
[08:26:21.705] Searching for globals...
[08:26:21.706] 
[08:26:21.706] Searching for globals ... DONE
[08:26:21.706] - globals: [0] <none>
[08:26:21.706] getGlobalsAndPackages() ... DONE
[08:26:21.706]    + additional globals found: [n=0] 
[08:26:21.706]    + additional namespaces needed: [n=0] 
[08:26:21.706]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:21.707]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:21.707]  - seeds: <none>
[08:26:21.707]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.707] getGlobalsAndPackages() ...
[08:26:21.707] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.707] Resolving globals: FALSE
[08:26:21.708] Tweak future expression to call with '...' arguments ...
[08:26:21.708] {
[08:26:21.708]     do.call(function(...) {
[08:26:21.708]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.708]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.708]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.708]             on.exit(options(oopts), add = TRUE)
[08:26:21.708]         }
[08:26:21.708]         {
[08:26:21.708]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.708]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.708]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.708]             })
[08:26:21.708]         }
[08:26:21.708]     }, args = future.call.arguments)
[08:26:21.708] }
[08:26:21.708] Tweak future expression to call with '...' arguments ... DONE
[08:26:21.709] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:21.709] - packages: [1] ‘future.apply’
[08:26:21.709] getGlobalsAndPackages() ... DONE
[08:26:21.710] run() for ‘Future’ ...
[08:26:21.710] - state: ‘created’
[08:26:21.710] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:21.713] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.713] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:21.713]   - Field: ‘label’
[08:26:21.713]   - Field: ‘local’
[08:26:21.713]   - Field: ‘owner’
[08:26:21.714]   - Field: ‘envir’
[08:26:21.714]   - Field: ‘workers’
[08:26:21.714]   - Field: ‘packages’
[08:26:21.714]   - Field: ‘gc’
[08:26:21.714]   - Field: ‘job’
[08:26:21.714]   - Field: ‘conditions’
[08:26:21.714]   - Field: ‘expr’
[08:26:21.715]   - Field: ‘uuid’
[08:26:21.715]   - Field: ‘seed’
[08:26:21.715]   - Field: ‘version’
[08:26:21.715]   - Field: ‘result’
[08:26:21.715]   - Field: ‘asynchronous’
[08:26:21.715]   - Field: ‘calls’
[08:26:21.715]   - Field: ‘globals’
[08:26:21.715]   - Field: ‘stdout’
[08:26:21.716]   - Field: ‘earlySignal’
[08:26:21.716]   - Field: ‘lazy’
[08:26:21.716]   - Field: ‘state’
[08:26:21.716] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:21.716] - Launch lazy future ...
[08:26:21.717] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:21.717] Packages needed by future strategies (n = 0): <none>
[08:26:21.718] {
[08:26:21.718]     {
[08:26:21.718]         {
[08:26:21.718]             ...future.startTime <- base::Sys.time()
[08:26:21.718]             {
[08:26:21.718]                 {
[08:26:21.718]                   {
[08:26:21.718]                     {
[08:26:21.718]                       {
[08:26:21.718]                         base::local({
[08:26:21.718]                           has_future <- base::requireNamespace("future", 
[08:26:21.718]                             quietly = TRUE)
[08:26:21.718]                           if (has_future) {
[08:26:21.718]                             ns <- base::getNamespace("future")
[08:26:21.718]                             version <- ns[[".package"]][["version"]]
[08:26:21.718]                             if (is.null(version)) 
[08:26:21.718]                               version <- utils::packageVersion("future")
[08:26:21.718]                           }
[08:26:21.718]                           else {
[08:26:21.718]                             version <- NULL
[08:26:21.718]                           }
[08:26:21.718]                           if (!has_future || version < "1.8.0") {
[08:26:21.718]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:21.718]                               "", base::R.version$version.string), 
[08:26:21.718]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:21.718]                                 base::R.version$platform, 8 * 
[08:26:21.718]                                   base::.Machine$sizeof.pointer), 
[08:26:21.718]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:21.718]                                 "release", "version")], collapse = " "), 
[08:26:21.718]                               hostname = base::Sys.info()[["nodename"]])
[08:26:21.718]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:21.718]                               info)
[08:26:21.718]                             info <- base::paste(info, collapse = "; ")
[08:26:21.718]                             if (!has_future) {
[08:26:21.718]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:21.718]                                 info)
[08:26:21.718]                             }
[08:26:21.718]                             else {
[08:26:21.718]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:21.718]                                 info, version)
[08:26:21.718]                             }
[08:26:21.718]                             base::stop(msg)
[08:26:21.718]                           }
[08:26:21.718]                         })
[08:26:21.718]                       }
[08:26:21.718]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:21.718]                       base::options(mc.cores = 1L)
[08:26:21.718]                     }
[08:26:21.718]                     base::local({
[08:26:21.718]                       for (pkg in "future.apply") {
[08:26:21.718]                         base::loadNamespace(pkg)
[08:26:21.718]                         base::library(pkg, character.only = TRUE)
[08:26:21.718]                       }
[08:26:21.718]                     })
[08:26:21.718]                   }
[08:26:21.718]                   ...future.strategy.old <- future::plan("list")
[08:26:21.718]                   options(future.plan = NULL)
[08:26:21.718]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.718]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:21.718]                 }
[08:26:21.718]                 ...future.workdir <- getwd()
[08:26:21.718]             }
[08:26:21.718]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:21.718]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:21.718]         }
[08:26:21.718]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:21.718]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:21.718]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:21.718]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:21.718]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:21.718]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:21.718]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:21.718]             base::names(...future.oldOptions))
[08:26:21.718]     }
[08:26:21.718]     if (FALSE) {
[08:26:21.718]     }
[08:26:21.718]     else {
[08:26:21.718]         if (TRUE) {
[08:26:21.718]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:21.718]                 open = "w")
[08:26:21.718]         }
[08:26:21.718]         else {
[08:26:21.718]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:21.718]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:21.718]         }
[08:26:21.718]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:21.718]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:21.718]             base::sink(type = "output", split = FALSE)
[08:26:21.718]             base::close(...future.stdout)
[08:26:21.718]         }, add = TRUE)
[08:26:21.718]     }
[08:26:21.718]     ...future.frame <- base::sys.nframe()
[08:26:21.718]     ...future.conditions <- base::list()
[08:26:21.718]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:21.718]     if (FALSE) {
[08:26:21.718]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:21.718]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:21.718]     }
[08:26:21.718]     ...future.result <- base::tryCatch({
[08:26:21.718]         base::withCallingHandlers({
[08:26:21.718]             ...future.value <- base::withVisible(base::local({
[08:26:21.718]                 withCallingHandlers({
[08:26:21.718]                   {
[08:26:21.718]                     do.call(function(...) {
[08:26:21.718]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.718]                       if (!identical(...future.globals.maxSize.org, 
[08:26:21.718]                         ...future.globals.maxSize)) {
[08:26:21.718]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.718]                         on.exit(options(oopts), add = TRUE)
[08:26:21.718]                       }
[08:26:21.718]                       {
[08:26:21.718]                         lapply(seq_along(...future.elements_ii), 
[08:26:21.718]                           FUN = function(jj) {
[08:26:21.718]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.718]                             ...future.FUN(...future.X_jj, ...)
[08:26:21.718]                           })
[08:26:21.718]                       }
[08:26:21.718]                     }, args = future.call.arguments)
[08:26:21.718]                   }
[08:26:21.718]                 }, immediateCondition = function(cond) {
[08:26:21.718]                   save_rds <- function (object, pathname, ...) 
[08:26:21.718]                   {
[08:26:21.718]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:21.718]                     if (file_test("-f", pathname_tmp)) {
[08:26:21.718]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.718]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:21.718]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.718]                         fi_tmp[["mtime"]])
[08:26:21.718]                     }
[08:26:21.718]                     tryCatch({
[08:26:21.718]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:21.718]                     }, error = function(ex) {
[08:26:21.718]                       msg <- conditionMessage(ex)
[08:26:21.718]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.718]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:21.718]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.718]                         fi_tmp[["mtime"]], msg)
[08:26:21.718]                       ex$message <- msg
[08:26:21.718]                       stop(ex)
[08:26:21.718]                     })
[08:26:21.718]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:21.718]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:21.718]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:21.718]                       fi_tmp <- file.info(pathname_tmp)
[08:26:21.718]                       fi <- file.info(pathname)
[08:26:21.718]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:21.718]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:21.718]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:21.718]                         fi[["size"]], fi[["mtime"]])
[08:26:21.718]                       stop(msg)
[08:26:21.718]                     }
[08:26:21.718]                     invisible(pathname)
[08:26:21.718]                   }
[08:26:21.718]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:21.718]                     rootPath = tempdir()) 
[08:26:21.718]                   {
[08:26:21.718]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:21.718]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:21.718]                       tmpdir = path, fileext = ".rds")
[08:26:21.718]                     save_rds(obj, file)
[08:26:21.718]                   }
[08:26:21.718]                   saveImmediateCondition(cond, path = "/tmp/RtmpUzdInz/.future/immediateConditions")
[08:26:21.718]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.718]                   {
[08:26:21.718]                     inherits <- base::inherits
[08:26:21.718]                     invokeRestart <- base::invokeRestart
[08:26:21.718]                     is.null <- base::is.null
[08:26:21.718]                     muffled <- FALSE
[08:26:21.718]                     if (inherits(cond, "message")) {
[08:26:21.718]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:21.718]                       if (muffled) 
[08:26:21.718]                         invokeRestart("muffleMessage")
[08:26:21.718]                     }
[08:26:21.718]                     else if (inherits(cond, "warning")) {
[08:26:21.718]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:21.718]                       if (muffled) 
[08:26:21.718]                         invokeRestart("muffleWarning")
[08:26:21.718]                     }
[08:26:21.718]                     else if (inherits(cond, "condition")) {
[08:26:21.718]                       if (!is.null(pattern)) {
[08:26:21.718]                         computeRestarts <- base::computeRestarts
[08:26:21.718]                         grepl <- base::grepl
[08:26:21.718]                         restarts <- computeRestarts(cond)
[08:26:21.718]                         for (restart in restarts) {
[08:26:21.718]                           name <- restart$name
[08:26:21.718]                           if (is.null(name)) 
[08:26:21.718]                             next
[08:26:21.718]                           if (!grepl(pattern, name)) 
[08:26:21.718]                             next
[08:26:21.718]                           invokeRestart(restart)
[08:26:21.718]                           muffled <- TRUE
[08:26:21.718]                           break
[08:26:21.718]                         }
[08:26:21.718]                       }
[08:26:21.718]                     }
[08:26:21.718]                     invisible(muffled)
[08:26:21.718]                   }
[08:26:21.718]                   muffleCondition(cond)
[08:26:21.718]                 })
[08:26:21.718]             }))
[08:26:21.718]             future::FutureResult(value = ...future.value$value, 
[08:26:21.718]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.718]                   ...future.rng), globalenv = if (FALSE) 
[08:26:21.718]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:21.718]                     ...future.globalenv.names))
[08:26:21.718]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:21.718]         }, condition = base::local({
[08:26:21.718]             c <- base::c
[08:26:21.718]             inherits <- base::inherits
[08:26:21.718]             invokeRestart <- base::invokeRestart
[08:26:21.718]             length <- base::length
[08:26:21.718]             list <- base::list
[08:26:21.718]             seq.int <- base::seq.int
[08:26:21.718]             signalCondition <- base::signalCondition
[08:26:21.718]             sys.calls <- base::sys.calls
[08:26:21.718]             `[[` <- base::`[[`
[08:26:21.718]             `+` <- base::`+`
[08:26:21.718]             `<<-` <- base::`<<-`
[08:26:21.718]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:21.718]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:21.718]                   3L)]
[08:26:21.718]             }
[08:26:21.718]             function(cond) {
[08:26:21.718]                 is_error <- inherits(cond, "error")
[08:26:21.718]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:21.718]                   NULL)
[08:26:21.718]                 if (is_error) {
[08:26:21.718]                   sessionInformation <- function() {
[08:26:21.718]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:21.718]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:21.718]                       search = base::search(), system = base::Sys.info())
[08:26:21.718]                   }
[08:26:21.718]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.718]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:21.718]                     cond$call), session = sessionInformation(), 
[08:26:21.718]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:21.718]                   signalCondition(cond)
[08:26:21.718]                 }
[08:26:21.718]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:21.718]                 "immediateCondition"))) {
[08:26:21.718]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:21.718]                   ...future.conditions[[length(...future.conditions) + 
[08:26:21.718]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:21.718]                   if (TRUE && !signal) {
[08:26:21.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.718]                     {
[08:26:21.718]                       inherits <- base::inherits
[08:26:21.718]                       invokeRestart <- base::invokeRestart
[08:26:21.718]                       is.null <- base::is.null
[08:26:21.718]                       muffled <- FALSE
[08:26:21.718]                       if (inherits(cond, "message")) {
[08:26:21.718]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.718]                         if (muffled) 
[08:26:21.718]                           invokeRestart("muffleMessage")
[08:26:21.718]                       }
[08:26:21.718]                       else if (inherits(cond, "warning")) {
[08:26:21.718]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.718]                         if (muffled) 
[08:26:21.718]                           invokeRestart("muffleWarning")
[08:26:21.718]                       }
[08:26:21.718]                       else if (inherits(cond, "condition")) {
[08:26:21.718]                         if (!is.null(pattern)) {
[08:26:21.718]                           computeRestarts <- base::computeRestarts
[08:26:21.718]                           grepl <- base::grepl
[08:26:21.718]                           restarts <- computeRestarts(cond)
[08:26:21.718]                           for (restart in restarts) {
[08:26:21.718]                             name <- restart$name
[08:26:21.718]                             if (is.null(name)) 
[08:26:21.718]                               next
[08:26:21.718]                             if (!grepl(pattern, name)) 
[08:26:21.718]                               next
[08:26:21.718]                             invokeRestart(restart)
[08:26:21.718]                             muffled <- TRUE
[08:26:21.718]                             break
[08:26:21.718]                           }
[08:26:21.718]                         }
[08:26:21.718]                       }
[08:26:21.718]                       invisible(muffled)
[08:26:21.718]                     }
[08:26:21.718]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.718]                   }
[08:26:21.718]                 }
[08:26:21.718]                 else {
[08:26:21.718]                   if (TRUE) {
[08:26:21.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:21.718]                     {
[08:26:21.718]                       inherits <- base::inherits
[08:26:21.718]                       invokeRestart <- base::invokeRestart
[08:26:21.718]                       is.null <- base::is.null
[08:26:21.718]                       muffled <- FALSE
[08:26:21.718]                       if (inherits(cond, "message")) {
[08:26:21.718]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:21.718]                         if (muffled) 
[08:26:21.718]                           invokeRestart("muffleMessage")
[08:26:21.718]                       }
[08:26:21.718]                       else if (inherits(cond, "warning")) {
[08:26:21.718]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:21.718]                         if (muffled) 
[08:26:21.718]                           invokeRestart("muffleWarning")
[08:26:21.718]                       }
[08:26:21.718]                       else if (inherits(cond, "condition")) {
[08:26:21.718]                         if (!is.null(pattern)) {
[08:26:21.718]                           computeRestarts <- base::computeRestarts
[08:26:21.718]                           grepl <- base::grepl
[08:26:21.718]                           restarts <- computeRestarts(cond)
[08:26:21.718]                           for (restart in restarts) {
[08:26:21.718]                             name <- restart$name
[08:26:21.718]                             if (is.null(name)) 
[08:26:21.718]                               next
[08:26:21.718]                             if (!grepl(pattern, name)) 
[08:26:21.718]                               next
[08:26:21.718]                             invokeRestart(restart)
[08:26:21.718]                             muffled <- TRUE
[08:26:21.718]                             break
[08:26:21.718]                           }
[08:26:21.718]                         }
[08:26:21.718]                       }
[08:26:21.718]                       invisible(muffled)
[08:26:21.718]                     }
[08:26:21.718]                     muffleCondition(cond, pattern = "^muffle")
[08:26:21.718]                   }
[08:26:21.718]                 }
[08:26:21.718]             }
[08:26:21.718]         }))
[08:26:21.718]     }, error = function(ex) {
[08:26:21.718]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:21.718]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:21.718]                 ...future.rng), started = ...future.startTime, 
[08:26:21.718]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:21.718]             version = "1.8"), class = "FutureResult")
[08:26:21.718]     }, finally = {
[08:26:21.718]         if (!identical(...future.workdir, getwd())) 
[08:26:21.718]             setwd(...future.workdir)
[08:26:21.718]         {
[08:26:21.718]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:21.718]                 ...future.oldOptions$nwarnings <- NULL
[08:26:21.718]             }
[08:26:21.718]             base::options(...future.oldOptions)
[08:26:21.718]             if (.Platform$OS.type == "windows") {
[08:26:21.718]                 old_names <- names(...future.oldEnvVars)
[08:26:21.718]                 envs <- base::Sys.getenv()
[08:26:21.718]                 names <- names(envs)
[08:26:21.718]                 common <- intersect(names, old_names)
[08:26:21.718]                 added <- setdiff(names, old_names)
[08:26:21.718]                 removed <- setdiff(old_names, names)
[08:26:21.718]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:21.718]                   envs[common]]
[08:26:21.718]                 NAMES <- toupper(changed)
[08:26:21.718]                 args <- list()
[08:26:21.718]                 for (kk in seq_along(NAMES)) {
[08:26:21.718]                   name <- changed[[kk]]
[08:26:21.718]                   NAME <- NAMES[[kk]]
[08:26:21.718]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.718]                     next
[08:26:21.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.718]                 }
[08:26:21.718]                 NAMES <- toupper(added)
[08:26:21.718]                 for (kk in seq_along(NAMES)) {
[08:26:21.718]                   name <- added[[kk]]
[08:26:21.718]                   NAME <- NAMES[[kk]]
[08:26:21.718]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.718]                     next
[08:26:21.718]                   args[[name]] <- ""
[08:26:21.718]                 }
[08:26:21.718]                 NAMES <- toupper(removed)
[08:26:21.718]                 for (kk in seq_along(NAMES)) {
[08:26:21.718]                   name <- removed[[kk]]
[08:26:21.718]                   NAME <- NAMES[[kk]]
[08:26:21.718]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:21.718]                     next
[08:26:21.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:21.718]                 }
[08:26:21.718]                 if (length(args) > 0) 
[08:26:21.718]                   base::do.call(base::Sys.setenv, args = args)
[08:26:21.718]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:21.718]             }
[08:26:21.718]             else {
[08:26:21.718]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:21.718]             }
[08:26:21.718]             {
[08:26:21.718]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:21.718]                   0L) {
[08:26:21.718]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:21.718]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:21.718]                   base::options(opts)
[08:26:21.718]                 }
[08:26:21.718]                 {
[08:26:21.718]                   {
[08:26:21.718]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:21.718]                     NULL
[08:26:21.718]                   }
[08:26:21.718]                   options(future.plan = NULL)
[08:26:21.718]                   if (is.na(NA_character_)) 
[08:26:21.718]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:21.718]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:21.718]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:21.718]                     .init = FALSE)
[08:26:21.718]                 }
[08:26:21.718]             }
[08:26:21.718]         }
[08:26:21.718]     })
[08:26:21.718]     if (TRUE) {
[08:26:21.718]         base::sink(type = "output", split = FALSE)
[08:26:21.718]         if (TRUE) {
[08:26:21.718]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:21.718]         }
[08:26:21.718]         else {
[08:26:21.718]             ...future.result["stdout"] <- base::list(NULL)
[08:26:21.718]         }
[08:26:21.718]         base::close(...future.stdout)
[08:26:21.718]         ...future.stdout <- NULL
[08:26:21.718]     }
[08:26:21.718]     ...future.result$conditions <- ...future.conditions
[08:26:21.718]     ...future.result$finished <- base::Sys.time()
[08:26:21.718]     ...future.result
[08:26:21.718] }
[08:26:21.721] assign_globals() ...
[08:26:21.722] List of 11
[08:26:21.722]  $ ...future.FUN            :function (x, ...)  
[08:26:21.722]  $ x_FUN                    :function (x)  
[08:26:21.722]  $ times                    : int 2
[08:26:21.722]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:21.722]  $ stop_if_not              :function (...)  
[08:26:21.722]  $ dim                      : NULL
[08:26:21.722]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[08:26:21.722]  $ future.call.arguments    : list()
[08:26:21.722]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:21.722]  $ ...future.elements_ii    :List of 2
[08:26:21.722]   ..$ : int 2
[08:26:21.722]   ..$ : int 3
[08:26:21.722]  $ ...future.seeds_ii       : NULL
[08:26:21.722]  $ ...future.globals.maxSize: NULL
[08:26:21.722]  - attr(*, "where")=List of 11
[08:26:21.722]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:21.722]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[08:26:21.722]   ..$ times                    :<environment: R_EmptyEnv> 
[08:26:21.722]   ..$ stopf                    :<environment: R_EmptyEnv> 
[08:26:21.722]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[08:26:21.722]   ..$ dim                      :<environment: R_EmptyEnv> 
[08:26:21.722]   ..$ valid_types              :<environment: R_EmptyEnv> 
[08:26:21.722]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:21.722]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:21.722]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:21.722]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:21.722]  - attr(*, "resolved")= logi FALSE
[08:26:21.722]  - attr(*, "total_size")= num 23676
[08:26:21.722]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:21.722]  - attr(*, "already-done")= logi TRUE
[08:26:21.738] - copied ‘...future.FUN’ to environment
[08:26:21.739] - copied ‘x_FUN’ to environment
[08:26:21.739] - copied ‘times’ to environment
[08:26:21.739] - copied ‘stopf’ to environment
[08:26:21.739] - copied ‘stop_if_not’ to environment
[08:26:21.739] - copied ‘dim’ to environment
[08:26:21.739] - copied ‘valid_types’ to environment
[08:26:21.739] - copied ‘future.call.arguments’ to environment
[08:26:21.739] - copied ‘...future.elements_ii’ to environment
[08:26:21.740] - copied ‘...future.seeds_ii’ to environment
[08:26:21.740] - copied ‘...future.globals.maxSize’ to environment
[08:26:21.740] assign_globals() ... done
[08:26:21.740] requestCore(): workers = 2
[08:26:21.742] MulticoreFuture started
[08:26:21.743] - Launch lazy future ... done
[08:26:21.743] run() for ‘MulticoreFuture’ ... done
[08:26:21.744] Created future:
[08:26:21.744] plan(): Setting new future strategy stack:
[08:26:21.744] List of future strategies:
[08:26:21.744] 1. sequential:
[08:26:21.744]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:21.744]    - tweaked: FALSE
[08:26:21.744]    - call: NULL
[08:26:21.746] plan(): nbrOfWorkers() = 1
[08:26:21.748] plan(): Setting new future strategy stack:
[08:26:21.748] List of future strategies:
[08:26:21.748] 1. multicore:
[08:26:21.748]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:21.748]    - tweaked: FALSE
[08:26:21.748]    - call: plan(strategy)
[08:26:21.752] plan(): nbrOfWorkers() = 2
[08:26:21.744] MulticoreFuture:
[08:26:21.744] Label: ‘future_vapply-2’
[08:26:21.744] Expression:
[08:26:21.744] {
[08:26:21.744]     do.call(function(...) {
[08:26:21.744]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:21.744]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:21.744]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:21.744]             on.exit(options(oopts), add = TRUE)
[08:26:21.744]         }
[08:26:21.744]         {
[08:26:21.744]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:21.744]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:21.744]                 ...future.FUN(...future.X_jj, ...)
[08:26:21.744]             })
[08:26:21.744]         }
[08:26:21.744]     }, args = future.call.arguments)
[08:26:21.744] }
[08:26:21.744] Lazy evaluation: FALSE
[08:26:21.744] Asynchronous evaluation: TRUE
[08:26:21.744] Local evaluation: TRUE
[08:26:21.744] Environment: R_GlobalEnv
[08:26:21.744] Capture standard output: TRUE
[08:26:21.744] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:21.744] Globals: 11 objects totaling 13.01 KiB (function ‘...future.FUN’ of 4.65 KiB, function ‘x_FUN’ of 185 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:21.744] Packages: 1 packages (‘future.apply’)
[08:26:21.744] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:21.744] Resolved: FALSE
[08:26:21.744] Value: <not collected>
[08:26:21.744] Conditions captured: <none>
[08:26:21.744] Early signaling: FALSE
[08:26:21.744] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:21.744] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:21.757] Chunk #2 of 2 ... DONE
[08:26:21.758] Launching 2 futures (chunks) ... DONE
[08:26:21.758] Resolving 2 futures (chunks) ...
[08:26:21.758] resolve() on list ...
[08:26:21.758]  recursive: 0
[08:26:21.758]  length: 2
[08:26:21.758] 
[08:26:21.759] Future #1
[08:26:21.759] result() for MulticoreFuture ...
[08:26:21.766] result() for MulticoreFuture ...
[08:26:21.767] result() for MulticoreFuture ... done
[08:26:21.767] signalConditions() ...
[08:26:21.767]  - include = ‘immediateCondition’
[08:26:21.767]  - exclude = 
[08:26:21.767]  - resignal = FALSE
[08:26:21.767]  - Number of conditions: 1
[08:26:21.768] signalConditions() ... done
[08:26:21.768] result() for MulticoreFuture ... done
[08:26:21.768] result() for MulticoreFuture ...
[08:26:21.768] result() for MulticoreFuture ... done
[08:26:21.768] signalConditions() ...
[08:26:21.768]  - include = ‘immediateCondition’
[08:26:21.769]  - exclude = 
[08:26:21.769]  - resignal = FALSE
[08:26:21.769]  - Number of conditions: 1
[08:26:21.769] signalConditions() ... done
[08:26:21.769] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:26:21.769] - nx: 2
[08:26:21.769] - relay: TRUE
[08:26:21.770] - stdout: TRUE
[08:26:21.770] - signal: TRUE
[08:26:21.770] - resignal: FALSE
[08:26:21.770] - force: TRUE
[08:26:21.770] - relayed: [n=2] FALSE, FALSE
[08:26:21.770] - queued futures: [n=2] FALSE, FALSE
[08:26:21.770]  - until=1
[08:26:21.771]  - relaying element #1
[08:26:21.771] result() for MulticoreFuture ...
[08:26:21.775] result() for MulticoreFuture ... done
[08:26:21.775] result() for MulticoreFuture ...
[08:26:21.775] result() for MulticoreFuture ... done
[08:26:21.776] signalConditions() ...
[08:26:21.776]  - include = ‘immediateCondition’
[08:26:21.776]  - exclude = 
[08:26:21.777]  - resignal = FALSE
[08:26:21.777]  - Number of conditions: 1
[08:26:21.777] signalConditions() ... done
[08:26:21.777] result() for MulticoreFuture ...
[08:26:21.778] result() for MulticoreFuture ... done
[08:26:21.778] signalConditions() ...
[08:26:21.778]  - include = ‘immediateCondition’
[08:26:21.778]  - exclude = 
[08:26:21.778]  - resignal = FALSE
[08:26:21.779]  - Number of conditions: 1
[08:26:21.779] signalConditions() ... done
[08:26:21.779] result() for MulticoreFuture ...
[08:26:21.779] result() for MulticoreFuture ... done
[08:26:21.779] signalConditions() ...
[08:26:21.780]  - include = ‘condition’
[08:26:21.780]  - exclude = ‘immediateCondition’
[08:26:21.780]  - resignal = TRUE
[08:26:21.780]  - Number of conditions: 1
[08:26:21.780]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:26:21.781] signalConditions() ... done
[08:26:21.781] - relayed: [n=2] FALSE, FALSE
[08:26:21.781] - queued futures: [n=2] TRUE, FALSE
[08:26:21.781] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:26:21.782] plan(): Setting new future strategy stack:
[08:26:21.782] List of future strategies:
[08:26:21.782] 1. sequential:
[08:26:21.782]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:21.782]    - tweaked: FALSE
[08:26:21.782]    - call: plan(sequential)
[08:26:21.783] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[08:26:21.783] plan(): Setting new future strategy stack:
[08:26:21.784] List of future strategies:
[08:26:21.784] 1. multisession:
[08:26:21.784]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:26:21.784]    - tweaked: FALSE
[08:26:21.784]    - call: plan(strategy)
[08:26:21.784] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:26:21.784] multisession:
[08:26:21.784] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:26:21.784] - tweaked: FALSE
[08:26:21.784] - call: plan(strategy)
[08:26:21.790] getGlobalsAndPackages() ...
[08:26:21.791] Not searching for globals
[08:26:21.791] - globals: [0] <none>
[08:26:21.791] getGlobalsAndPackages() ... DONE
[08:26:22.301] Packages needed by the future expression (n = 0): <none>
[08:26:22.302] Packages needed by future strategies (n = 0): <none>
[08:26:22.302] {
[08:26:22.302]     {
[08:26:22.302]         {
[08:26:22.302]             ...future.startTime <- base::Sys.time()
[08:26:22.302]             {
[08:26:22.302]                 {
[08:26:22.302]                   {
[08:26:22.302]                     {
[08:26:22.302]                       base::local({
[08:26:22.302]                         has_future <- base::requireNamespace("future", 
[08:26:22.302]                           quietly = TRUE)
[08:26:22.302]                         if (has_future) {
[08:26:22.302]                           ns <- base::getNamespace("future")
[08:26:22.302]                           version <- ns[[".package"]][["version"]]
[08:26:22.302]                           if (is.null(version)) 
[08:26:22.302]                             version <- utils::packageVersion("future")
[08:26:22.302]                         }
[08:26:22.302]                         else {
[08:26:22.302]                           version <- NULL
[08:26:22.302]                         }
[08:26:22.302]                         if (!has_future || version < "1.8.0") {
[08:26:22.302]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:22.302]                             "", base::R.version$version.string), 
[08:26:22.302]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:22.302]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:22.302]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:22.302]                               "release", "version")], collapse = " "), 
[08:26:22.302]                             hostname = base::Sys.info()[["nodename"]])
[08:26:22.302]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:22.302]                             info)
[08:26:22.302]                           info <- base::paste(info, collapse = "; ")
[08:26:22.302]                           if (!has_future) {
[08:26:22.302]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:22.302]                               info)
[08:26:22.302]                           }
[08:26:22.302]                           else {
[08:26:22.302]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:22.302]                               info, version)
[08:26:22.302]                           }
[08:26:22.302]                           base::stop(msg)
[08:26:22.302]                         }
[08:26:22.302]                       })
[08:26:22.302]                     }
[08:26:22.302]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:22.302]                     base::options(mc.cores = 1L)
[08:26:22.302]                   }
[08:26:22.302]                   ...future.strategy.old <- future::plan("list")
[08:26:22.302]                   options(future.plan = NULL)
[08:26:22.302]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:22.302]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:22.302]                 }
[08:26:22.302]                 ...future.workdir <- getwd()
[08:26:22.302]             }
[08:26:22.302]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:22.302]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:22.302]         }
[08:26:22.302]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:22.302]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:22.302]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:22.302]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:22.302]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:22.302]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:22.302]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:22.302]             base::names(...future.oldOptions))
[08:26:22.302]     }
[08:26:22.302]     if (FALSE) {
[08:26:22.302]     }
[08:26:22.302]     else {
[08:26:22.302]         if (TRUE) {
[08:26:22.302]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:22.302]                 open = "w")
[08:26:22.302]         }
[08:26:22.302]         else {
[08:26:22.302]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:22.302]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:22.302]         }
[08:26:22.302]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:22.302]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:22.302]             base::sink(type = "output", split = FALSE)
[08:26:22.302]             base::close(...future.stdout)
[08:26:22.302]         }, add = TRUE)
[08:26:22.302]     }
[08:26:22.302]     ...future.frame <- base::sys.nframe()
[08:26:22.302]     ...future.conditions <- base::list()
[08:26:22.302]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:22.302]     if (FALSE) {
[08:26:22.302]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:22.302]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:22.302]     }
[08:26:22.302]     ...future.result <- base::tryCatch({
[08:26:22.302]         base::withCallingHandlers({
[08:26:22.302]             ...future.value <- base::withVisible(base::local({
[08:26:22.302]                 ...future.makeSendCondition <- base::local({
[08:26:22.302]                   sendCondition <- NULL
[08:26:22.302]                   function(frame = 1L) {
[08:26:22.302]                     if (is.function(sendCondition)) 
[08:26:22.302]                       return(sendCondition)
[08:26:22.302]                     ns <- getNamespace("parallel")
[08:26:22.302]                     if (exists("sendData", mode = "function", 
[08:26:22.302]                       envir = ns)) {
[08:26:22.302]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:22.302]                         envir = ns)
[08:26:22.302]                       envir <- sys.frame(frame)
[08:26:22.302]                       master <- NULL
[08:26:22.302]                       while (!identical(envir, .GlobalEnv) && 
[08:26:22.302]                         !identical(envir, emptyenv())) {
[08:26:22.302]                         if (exists("master", mode = "list", envir = envir, 
[08:26:22.302]                           inherits = FALSE)) {
[08:26:22.302]                           master <- get("master", mode = "list", 
[08:26:22.302]                             envir = envir, inherits = FALSE)
[08:26:22.302]                           if (inherits(master, c("SOCKnode", 
[08:26:22.302]                             "SOCK0node"))) {
[08:26:22.302]                             sendCondition <<- function(cond) {
[08:26:22.302]                               data <- list(type = "VALUE", value = cond, 
[08:26:22.302]                                 success = TRUE)
[08:26:22.302]                               parallel_sendData(master, data)
[08:26:22.302]                             }
[08:26:22.302]                             return(sendCondition)
[08:26:22.302]                           }
[08:26:22.302]                         }
[08:26:22.302]                         frame <- frame + 1L
[08:26:22.302]                         envir <- sys.frame(frame)
[08:26:22.302]                       }
[08:26:22.302]                     }
[08:26:22.302]                     sendCondition <<- function(cond) NULL
[08:26:22.302]                   }
[08:26:22.302]                 })
[08:26:22.302]                 withCallingHandlers({
[08:26:22.302]                   NA
[08:26:22.302]                 }, immediateCondition = function(cond) {
[08:26:22.302]                   sendCondition <- ...future.makeSendCondition()
[08:26:22.302]                   sendCondition(cond)
[08:26:22.302]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:22.302]                   {
[08:26:22.302]                     inherits <- base::inherits
[08:26:22.302]                     invokeRestart <- base::invokeRestart
[08:26:22.302]                     is.null <- base::is.null
[08:26:22.302]                     muffled <- FALSE
[08:26:22.302]                     if (inherits(cond, "message")) {
[08:26:22.302]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:22.302]                       if (muffled) 
[08:26:22.302]                         invokeRestart("muffleMessage")
[08:26:22.302]                     }
[08:26:22.302]                     else if (inherits(cond, "warning")) {
[08:26:22.302]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:22.302]                       if (muffled) 
[08:26:22.302]                         invokeRestart("muffleWarning")
[08:26:22.302]                     }
[08:26:22.302]                     else if (inherits(cond, "condition")) {
[08:26:22.302]                       if (!is.null(pattern)) {
[08:26:22.302]                         computeRestarts <- base::computeRestarts
[08:26:22.302]                         grepl <- base::grepl
[08:26:22.302]                         restarts <- computeRestarts(cond)
[08:26:22.302]                         for (restart in restarts) {
[08:26:22.302]                           name <- restart$name
[08:26:22.302]                           if (is.null(name)) 
[08:26:22.302]                             next
[08:26:22.302]                           if (!grepl(pattern, name)) 
[08:26:22.302]                             next
[08:26:22.302]                           invokeRestart(restart)
[08:26:22.302]                           muffled <- TRUE
[08:26:22.302]                           break
[08:26:22.302]                         }
[08:26:22.302]                       }
[08:26:22.302]                     }
[08:26:22.302]                     invisible(muffled)
[08:26:22.302]                   }
[08:26:22.302]                   muffleCondition(cond)
[08:26:22.302]                 })
[08:26:22.302]             }))
[08:26:22.302]             future::FutureResult(value = ...future.value$value, 
[08:26:22.302]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:22.302]                   ...future.rng), globalenv = if (FALSE) 
[08:26:22.302]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:22.302]                     ...future.globalenv.names))
[08:26:22.302]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:22.302]         }, condition = base::local({
[08:26:22.302]             c <- base::c
[08:26:22.302]             inherits <- base::inherits
[08:26:22.302]             invokeRestart <- base::invokeRestart
[08:26:22.302]             length <- base::length
[08:26:22.302]             list <- base::list
[08:26:22.302]             seq.int <- base::seq.int
[08:26:22.302]             signalCondition <- base::signalCondition
[08:26:22.302]             sys.calls <- base::sys.calls
[08:26:22.302]             `[[` <- base::`[[`
[08:26:22.302]             `+` <- base::`+`
[08:26:22.302]             `<<-` <- base::`<<-`
[08:26:22.302]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:22.302]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:22.302]                   3L)]
[08:26:22.302]             }
[08:26:22.302]             function(cond) {
[08:26:22.302]                 is_error <- inherits(cond, "error")
[08:26:22.302]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:22.302]                   NULL)
[08:26:22.302]                 if (is_error) {
[08:26:22.302]                   sessionInformation <- function() {
[08:26:22.302]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:22.302]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:22.302]                       search = base::search(), system = base::Sys.info())
[08:26:22.302]                   }
[08:26:22.302]                   ...future.conditions[[length(...future.conditions) + 
[08:26:22.302]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:22.302]                     cond$call), session = sessionInformation(), 
[08:26:22.302]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:22.302]                   signalCondition(cond)
[08:26:22.302]                 }
[08:26:22.302]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:22.302]                 "immediateCondition"))) {
[08:26:22.302]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:22.302]                   ...future.conditions[[length(...future.conditions) + 
[08:26:22.302]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:22.302]                   if (TRUE && !signal) {
[08:26:22.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:22.302]                     {
[08:26:22.302]                       inherits <- base::inherits
[08:26:22.302]                       invokeRestart <- base::invokeRestart
[08:26:22.302]                       is.null <- base::is.null
[08:26:22.302]                       muffled <- FALSE
[08:26:22.302]                       if (inherits(cond, "message")) {
[08:26:22.302]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:22.302]                         if (muffled) 
[08:26:22.302]                           invokeRestart("muffleMessage")
[08:26:22.302]                       }
[08:26:22.302]                       else if (inherits(cond, "warning")) {
[08:26:22.302]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:22.302]                         if (muffled) 
[08:26:22.302]                           invokeRestart("muffleWarning")
[08:26:22.302]                       }
[08:26:22.302]                       else if (inherits(cond, "condition")) {
[08:26:22.302]                         if (!is.null(pattern)) {
[08:26:22.302]                           computeRestarts <- base::computeRestarts
[08:26:22.302]                           grepl <- base::grepl
[08:26:22.302]                           restarts <- computeRestarts(cond)
[08:26:22.302]                           for (restart in restarts) {
[08:26:22.302]                             name <- restart$name
[08:26:22.302]                             if (is.null(name)) 
[08:26:22.302]                               next
[08:26:22.302]                             if (!grepl(pattern, name)) 
[08:26:22.302]                               next
[08:26:22.302]                             invokeRestart(restart)
[08:26:22.302]                             muffled <- TRUE
[08:26:22.302]                             break
[08:26:22.302]                           }
[08:26:22.302]                         }
[08:26:22.302]                       }
[08:26:22.302]                       invisible(muffled)
[08:26:22.302]                     }
[08:26:22.302]                     muffleCondition(cond, pattern = "^muffle")
[08:26:22.302]                   }
[08:26:22.302]                 }
[08:26:22.302]                 else {
[08:26:22.302]                   if (TRUE) {
[08:26:22.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:22.302]                     {
[08:26:22.302]                       inherits <- base::inherits
[08:26:22.302]                       invokeRestart <- base::invokeRestart
[08:26:22.302]                       is.null <- base::is.null
[08:26:22.302]                       muffled <- FALSE
[08:26:22.302]                       if (inherits(cond, "message")) {
[08:26:22.302]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:22.302]                         if (muffled) 
[08:26:22.302]                           invokeRestart("muffleMessage")
[08:26:22.302]                       }
[08:26:22.302]                       else if (inherits(cond, "warning")) {
[08:26:22.302]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:22.302]                         if (muffled) 
[08:26:22.302]                           invokeRestart("muffleWarning")
[08:26:22.302]                       }
[08:26:22.302]                       else if (inherits(cond, "condition")) {
[08:26:22.302]                         if (!is.null(pattern)) {
[08:26:22.302]                           computeRestarts <- base::computeRestarts
[08:26:22.302]                           grepl <- base::grepl
[08:26:22.302]                           restarts <- computeRestarts(cond)
[08:26:22.302]                           for (restart in restarts) {
[08:26:22.302]                             name <- restart$name
[08:26:22.302]                             if (is.null(name)) 
[08:26:22.302]                               next
[08:26:22.302]                             if (!grepl(pattern, name)) 
[08:26:22.302]                               next
[08:26:22.302]                             invokeRestart(restart)
[08:26:22.302]                             muffled <- TRUE
[08:26:22.302]                             break
[08:26:22.302]                           }
[08:26:22.302]                         }
[08:26:22.302]                       }
[08:26:22.302]                       invisible(muffled)
[08:26:22.302]                     }
[08:26:22.302]                     muffleCondition(cond, pattern = "^muffle")
[08:26:22.302]                   }
[08:26:22.302]                 }
[08:26:22.302]             }
[08:26:22.302]         }))
[08:26:22.302]     }, error = function(ex) {
[08:26:22.302]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:22.302]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:22.302]                 ...future.rng), started = ...future.startTime, 
[08:26:22.302]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:22.302]             version = "1.8"), class = "FutureResult")
[08:26:22.302]     }, finally = {
[08:26:22.302]         if (!identical(...future.workdir, getwd())) 
[08:26:22.302]             setwd(...future.workdir)
[08:26:22.302]         {
[08:26:22.302]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:22.302]                 ...future.oldOptions$nwarnings <- NULL
[08:26:22.302]             }
[08:26:22.302]             base::options(...future.oldOptions)
[08:26:22.302]             if (.Platform$OS.type == "windows") {
[08:26:22.302]                 old_names <- names(...future.oldEnvVars)
[08:26:22.302]                 envs <- base::Sys.getenv()
[08:26:22.302]                 names <- names(envs)
[08:26:22.302]                 common <- intersect(names, old_names)
[08:26:22.302]                 added <- setdiff(names, old_names)
[08:26:22.302]                 removed <- setdiff(old_names, names)
[08:26:22.302]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:22.302]                   envs[common]]
[08:26:22.302]                 NAMES <- toupper(changed)
[08:26:22.302]                 args <- list()
[08:26:22.302]                 for (kk in seq_along(NAMES)) {
[08:26:22.302]                   name <- changed[[kk]]
[08:26:22.302]                   NAME <- NAMES[[kk]]
[08:26:22.302]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:22.302]                     next
[08:26:22.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:22.302]                 }
[08:26:22.302]                 NAMES <- toupper(added)
[08:26:22.302]                 for (kk in seq_along(NAMES)) {
[08:26:22.302]                   name <- added[[kk]]
[08:26:22.302]                   NAME <- NAMES[[kk]]
[08:26:22.302]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:22.302]                     next
[08:26:22.302]                   args[[name]] <- ""
[08:26:22.302]                 }
[08:26:22.302]                 NAMES <- toupper(removed)
[08:26:22.302]                 for (kk in seq_along(NAMES)) {
[08:26:22.302]                   name <- removed[[kk]]
[08:26:22.302]                   NAME <- NAMES[[kk]]
[08:26:22.302]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:22.302]                     next
[08:26:22.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:22.302]                 }
[08:26:22.302]                 if (length(args) > 0) 
[08:26:22.302]                   base::do.call(base::Sys.setenv, args = args)
[08:26:22.302]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:22.302]             }
[08:26:22.302]             else {
[08:26:22.302]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:22.302]             }
[08:26:22.302]             {
[08:26:22.302]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:22.302]                   0L) {
[08:26:22.302]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:22.302]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:22.302]                   base::options(opts)
[08:26:22.302]                 }
[08:26:22.302]                 {
[08:26:22.302]                   {
[08:26:22.302]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:22.302]                     NULL
[08:26:22.302]                   }
[08:26:22.302]                   options(future.plan = NULL)
[08:26:22.302]                   if (is.na(NA_character_)) 
[08:26:22.302]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:22.302]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:22.302]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:22.302]                     .init = FALSE)
[08:26:22.302]                 }
[08:26:22.302]             }
[08:26:22.302]         }
[08:26:22.302]     })
[08:26:22.302]     if (TRUE) {
[08:26:22.302]         base::sink(type = "output", split = FALSE)
[08:26:22.302]         if (TRUE) {
[08:26:22.302]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:22.302]         }
[08:26:22.302]         else {
[08:26:22.302]             ...future.result["stdout"] <- base::list(NULL)
[08:26:22.302]         }
[08:26:22.302]         base::close(...future.stdout)
[08:26:22.302]         ...future.stdout <- NULL
[08:26:22.302]     }
[08:26:22.302]     ...future.result$conditions <- ...future.conditions
[08:26:22.302]     ...future.result$finished <- base::Sys.time()
[08:26:22.302]     ...future.result
[08:26:22.302] }
[08:26:22.358] MultisessionFuture started
[08:26:22.358] result() for ClusterFuture ...
[08:26:22.359] receiveMessageFromWorker() for ClusterFuture ...
[08:26:22.359] - Validating connection of MultisessionFuture
[08:26:22.390] - received message: FutureResult
[08:26:22.390] - Received FutureResult
[08:26:22.390] - Erased future from FutureRegistry
[08:26:22.390] result() for ClusterFuture ...
[08:26:22.391] - result already collected: FutureResult
[08:26:22.391] result() for ClusterFuture ... done
[08:26:22.391] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:22.391] result() for ClusterFuture ... done
[08:26:22.391] result() for ClusterFuture ...
[08:26:22.391] - result already collected: FutureResult
[08:26:22.391] result() for ClusterFuture ... done
[08:26:22.391] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:26:22.393] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[08:26:22.395] future_lapply() ...
[08:26:22.399] Number of chunks: 2
[08:26:22.399] getGlobalsAndPackagesXApply() ...
[08:26:22.399]  - future.globals: TRUE
[08:26:22.399] getGlobalsAndPackages() ...
[08:26:22.399] Searching for globals...
[08:26:22.402] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[08:26:22.402] Searching for globals ... DONE
[08:26:22.403] Resolving globals: FALSE
[08:26:22.404] The total size of the 7 globals is 12.01 KiB (12294 bytes)
[08:26:22.404] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.02 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:22.404] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:22.404] - packages: [1] ‘future.apply’
[08:26:22.404] getGlobalsAndPackages() ... DONE
[08:26:22.404]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:22.405]  - needed namespaces: [n=1] ‘future.apply’
[08:26:22.405] Finding globals ... DONE
[08:26:22.405]  - use_args: TRUE
[08:26:22.405]  - Getting '...' globals ...
[08:26:22.405] resolve() on list ...
[08:26:22.405]  recursive: 0
[08:26:22.405]  length: 1
[08:26:22.405]  elements: ‘...’
[08:26:22.406]  length: 0 (resolved future 1)
[08:26:22.406] resolve() on list ... DONE
[08:26:22.406]    - '...' content: [n=0] 
[08:26:22.406] List of 1
[08:26:22.406]  $ ...: list()
[08:26:22.406]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:22.406]  - attr(*, "where")=List of 1
[08:26:22.406]   ..$ ...:<environment: 0x562ca7a74918> 
[08:26:22.406]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:22.406]  - attr(*, "resolved")= logi TRUE
[08:26:22.406]  - attr(*, "total_size")= num NA
[08:26:22.409]  - Getting '...' globals ... DONE
[08:26:22.409] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:22.409] List of 8
[08:26:22.409]  $ ...future.FUN:function (x, ...)  
[08:26:22.409]  $ x_FUN        :function (x)  
[08:26:22.409]  $ times        : int 1
[08:26:22.409]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:22.409]  $ stop_if_not  :function (...)  
[08:26:22.409]  $ dim          : NULL
[08:26:22.409]  $ valid_types  : chr "character"
[08:26:22.409]  $ ...          : list()
[08:26:22.409]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:22.409]  - attr(*, "where")=List of 8
[08:26:22.409]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:22.409]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:22.409]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:22.409]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:22.409]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:22.409]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:22.409]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:22.409]   ..$ ...          :<environment: 0x562ca7a74918> 
[08:26:22.409]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:22.409]  - attr(*, "resolved")= logi FALSE
[08:26:22.409]  - attr(*, "total_size")= num 22333
[08:26:22.416] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:22.416] getGlobalsAndPackagesXApply() ... DONE
[08:26:22.416] Number of futures (= number of chunks): 2
[08:26:22.416] Launching 2 futures (chunks) ...
[08:26:22.416] Chunk #1 of 2 ...
[08:26:22.417]  - Finding globals in 'X' for chunk #1 ...
[08:26:22.417] getGlobalsAndPackages() ...
[08:26:22.417] Searching for globals...
[08:26:22.417] 
[08:26:22.417] Searching for globals ... DONE
[08:26:22.417] - globals: [0] <none>
[08:26:22.417] getGlobalsAndPackages() ... DONE
[08:26:22.417]    + additional globals found: [n=0] 
[08:26:22.418]    + additional namespaces needed: [n=0] 
[08:26:22.418]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:22.418]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:22.418]  - seeds: <none>
[08:26:22.418]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:22.418] getGlobalsAndPackages() ...
[08:26:22.418] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:22.418] Resolving globals: FALSE
[08:26:22.419] Tweak future expression to call with '...' arguments ...
[08:26:22.419] {
[08:26:22.419]     do.call(function(...) {
[08:26:22.419]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:22.419]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:22.419]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:22.419]             on.exit(options(oopts), add = TRUE)
[08:26:22.419]         }
[08:26:22.419]         {
[08:26:22.419]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:22.419]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:22.419]                 ...future.FUN(...future.X_jj, ...)
[08:26:22.419]             })
[08:26:22.419]         }
[08:26:22.419]     }, args = future.call.arguments)
[08:26:22.419] }
[08:26:22.419] Tweak future expression to call with '...' arguments ... DONE
[08:26:22.420] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:22.420] - packages: [1] ‘future.apply’
[08:26:22.420] getGlobalsAndPackages() ... DONE
[08:26:22.420] run() for ‘Future’ ...
[08:26:22.420] - state: ‘created’
[08:26:22.421] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:22.436] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:22.436] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:22.436]   - Field: ‘node’
[08:26:22.436]   - Field: ‘label’
[08:26:22.436]   - Field: ‘local’
[08:26:22.436]   - Field: ‘owner’
[08:26:22.436]   - Field: ‘envir’
[08:26:22.436]   - Field: ‘workers’
[08:26:22.436]   - Field: ‘packages’
[08:26:22.436]   - Field: ‘gc’
[08:26:22.437]   - Field: ‘conditions’
[08:26:22.437]   - Field: ‘persistent’
[08:26:22.437]   - Field: ‘expr’
[08:26:22.437]   - Field: ‘uuid’
[08:26:22.437]   - Field: ‘seed’
[08:26:22.437]   - Field: ‘version’
[08:26:22.437]   - Field: ‘result’
[08:26:22.437]   - Field: ‘asynchronous’
[08:26:22.437]   - Field: ‘calls’
[08:26:22.437]   - Field: ‘globals’
[08:26:22.438]   - Field: ‘stdout’
[08:26:22.438]   - Field: ‘earlySignal’
[08:26:22.438]   - Field: ‘lazy’
[08:26:22.438]   - Field: ‘state’
[08:26:22.438] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:22.438] - Launch lazy future ...
[08:26:22.438] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:22.439] Packages needed by future strategies (n = 0): <none>
[08:26:22.439] {
[08:26:22.439]     {
[08:26:22.439]         {
[08:26:22.439]             ...future.startTime <- base::Sys.time()
[08:26:22.439]             {
[08:26:22.439]                 {
[08:26:22.439]                   {
[08:26:22.439]                     {
[08:26:22.439]                       {
[08:26:22.439]                         base::local({
[08:26:22.439]                           has_future <- base::requireNamespace("future", 
[08:26:22.439]                             quietly = TRUE)
[08:26:22.439]                           if (has_future) {
[08:26:22.439]                             ns <- base::getNamespace("future")
[08:26:22.439]                             version <- ns[[".package"]][["version"]]
[08:26:22.439]                             if (is.null(version)) 
[08:26:22.439]                               version <- utils::packageVersion("future")
[08:26:22.439]                           }
[08:26:22.439]                           else {
[08:26:22.439]                             version <- NULL
[08:26:22.439]                           }
[08:26:22.439]                           if (!has_future || version < "1.8.0") {
[08:26:22.439]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:22.439]                               "", base::R.version$version.string), 
[08:26:22.439]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:22.439]                                 base::R.version$platform, 8 * 
[08:26:22.439]                                   base::.Machine$sizeof.pointer), 
[08:26:22.439]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:22.439]                                 "release", "version")], collapse = " "), 
[08:26:22.439]                               hostname = base::Sys.info()[["nodename"]])
[08:26:22.439]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:22.439]                               info)
[08:26:22.439]                             info <- base::paste(info, collapse = "; ")
[08:26:22.439]                             if (!has_future) {
[08:26:22.439]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:22.439]                                 info)
[08:26:22.439]                             }
[08:26:22.439]                             else {
[08:26:22.439]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:22.439]                                 info, version)
[08:26:22.439]                             }
[08:26:22.439]                             base::stop(msg)
[08:26:22.439]                           }
[08:26:22.439]                         })
[08:26:22.439]                       }
[08:26:22.439]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:22.439]                       base::options(mc.cores = 1L)
[08:26:22.439]                     }
[08:26:22.439]                     base::local({
[08:26:22.439]                       for (pkg in "future.apply") {
[08:26:22.439]                         base::loadNamespace(pkg)
[08:26:22.439]                         base::library(pkg, character.only = TRUE)
[08:26:22.439]                       }
[08:26:22.439]                     })
[08:26:22.439]                   }
[08:26:22.439]                   ...future.strategy.old <- future::plan("list")
[08:26:22.439]                   options(future.plan = NULL)
[08:26:22.439]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:22.439]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:22.439]                 }
[08:26:22.439]                 ...future.workdir <- getwd()
[08:26:22.439]             }
[08:26:22.439]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:22.439]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:22.439]         }
[08:26:22.439]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:22.439]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:22.439]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:22.439]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:22.439]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:22.439]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:22.439]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:22.439]             base::names(...future.oldOptions))
[08:26:22.439]     }
[08:26:22.439]     if (FALSE) {
[08:26:22.439]     }
[08:26:22.439]     else {
[08:26:22.439]         if (TRUE) {
[08:26:22.439]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:22.439]                 open = "w")
[08:26:22.439]         }
[08:26:22.439]         else {
[08:26:22.439]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:22.439]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:22.439]         }
[08:26:22.439]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:22.439]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:22.439]             base::sink(type = "output", split = FALSE)
[08:26:22.439]             base::close(...future.stdout)
[08:26:22.439]         }, add = TRUE)
[08:26:22.439]     }
[08:26:22.439]     ...future.frame <- base::sys.nframe()
[08:26:22.439]     ...future.conditions <- base::list()
[08:26:22.439]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:22.439]     if (FALSE) {
[08:26:22.439]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:22.439]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:22.439]     }
[08:26:22.439]     ...future.result <- base::tryCatch({
[08:26:22.439]         base::withCallingHandlers({
[08:26:22.439]             ...future.value <- base::withVisible(base::local({
[08:26:22.439]                 ...future.makeSendCondition <- base::local({
[08:26:22.439]                   sendCondition <- NULL
[08:26:22.439]                   function(frame = 1L) {
[08:26:22.439]                     if (is.function(sendCondition)) 
[08:26:22.439]                       return(sendCondition)
[08:26:22.439]                     ns <- getNamespace("parallel")
[08:26:22.439]                     if (exists("sendData", mode = "function", 
[08:26:22.439]                       envir = ns)) {
[08:26:22.439]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:22.439]                         envir = ns)
[08:26:22.439]                       envir <- sys.frame(frame)
[08:26:22.439]                       master <- NULL
[08:26:22.439]                       while (!identical(envir, .GlobalEnv) && 
[08:26:22.439]                         !identical(envir, emptyenv())) {
[08:26:22.439]                         if (exists("master", mode = "list", envir = envir, 
[08:26:22.439]                           inherits = FALSE)) {
[08:26:22.439]                           master <- get("master", mode = "list", 
[08:26:22.439]                             envir = envir, inherits = FALSE)
[08:26:22.439]                           if (inherits(master, c("SOCKnode", 
[08:26:22.439]                             "SOCK0node"))) {
[08:26:22.439]                             sendCondition <<- function(cond) {
[08:26:22.439]                               data <- list(type = "VALUE", value = cond, 
[08:26:22.439]                                 success = TRUE)
[08:26:22.439]                               parallel_sendData(master, data)
[08:26:22.439]                             }
[08:26:22.439]                             return(sendCondition)
[08:26:22.439]                           }
[08:26:22.439]                         }
[08:26:22.439]                         frame <- frame + 1L
[08:26:22.439]                         envir <- sys.frame(frame)
[08:26:22.439]                       }
[08:26:22.439]                     }
[08:26:22.439]                     sendCondition <<- function(cond) NULL
[08:26:22.439]                   }
[08:26:22.439]                 })
[08:26:22.439]                 withCallingHandlers({
[08:26:22.439]                   {
[08:26:22.439]                     do.call(function(...) {
[08:26:22.439]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:22.439]                       if (!identical(...future.globals.maxSize.org, 
[08:26:22.439]                         ...future.globals.maxSize)) {
[08:26:22.439]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:22.439]                         on.exit(options(oopts), add = TRUE)
[08:26:22.439]                       }
[08:26:22.439]                       {
[08:26:22.439]                         lapply(seq_along(...future.elements_ii), 
[08:26:22.439]                           FUN = function(jj) {
[08:26:22.439]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:22.439]                             ...future.FUN(...future.X_jj, ...)
[08:26:22.439]                           })
[08:26:22.439]                       }
[08:26:22.439]                     }, args = future.call.arguments)
[08:26:22.439]                   }
[08:26:22.439]                 }, immediateCondition = function(cond) {
[08:26:22.439]                   sendCondition <- ...future.makeSendCondition()
[08:26:22.439]                   sendCondition(cond)
[08:26:22.439]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:22.439]                   {
[08:26:22.439]                     inherits <- base::inherits
[08:26:22.439]                     invokeRestart <- base::invokeRestart
[08:26:22.439]                     is.null <- base::is.null
[08:26:22.439]                     muffled <- FALSE
[08:26:22.439]                     if (inherits(cond, "message")) {
[08:26:22.439]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:22.439]                       if (muffled) 
[08:26:22.439]                         invokeRestart("muffleMessage")
[08:26:22.439]                     }
[08:26:22.439]                     else if (inherits(cond, "warning")) {
[08:26:22.439]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:22.439]                       if (muffled) 
[08:26:22.439]                         invokeRestart("muffleWarning")
[08:26:22.439]                     }
[08:26:22.439]                     else if (inherits(cond, "condition")) {
[08:26:22.439]                       if (!is.null(pattern)) {
[08:26:22.439]                         computeRestarts <- base::computeRestarts
[08:26:22.439]                         grepl <- base::grepl
[08:26:22.439]                         restarts <- computeRestarts(cond)
[08:26:22.439]                         for (restart in restarts) {
[08:26:22.439]                           name <- restart$name
[08:26:22.439]                           if (is.null(name)) 
[08:26:22.439]                             next
[08:26:22.439]                           if (!grepl(pattern, name)) 
[08:26:22.439]                             next
[08:26:22.439]                           invokeRestart(restart)
[08:26:22.439]                           muffled <- TRUE
[08:26:22.439]                           break
[08:26:22.439]                         }
[08:26:22.439]                       }
[08:26:22.439]                     }
[08:26:22.439]                     invisible(muffled)
[08:26:22.439]                   }
[08:26:22.439]                   muffleCondition(cond)
[08:26:22.439]                 })
[08:26:22.439]             }))
[08:26:22.439]             future::FutureResult(value = ...future.value$value, 
[08:26:22.439]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:22.439]                   ...future.rng), globalenv = if (FALSE) 
[08:26:22.439]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:22.439]                     ...future.globalenv.names))
[08:26:22.439]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:22.439]         }, condition = base::local({
[08:26:22.439]             c <- base::c
[08:26:22.439]             inherits <- base::inherits
[08:26:22.439]             invokeRestart <- base::invokeRestart
[08:26:22.439]             length <- base::length
[08:26:22.439]             list <- base::list
[08:26:22.439]             seq.int <- base::seq.int
[08:26:22.439]             signalCondition <- base::signalCondition
[08:26:22.439]             sys.calls <- base::sys.calls
[08:26:22.439]             `[[` <- base::`[[`
[08:26:22.439]             `+` <- base::`+`
[08:26:22.439]             `<<-` <- base::`<<-`
[08:26:22.439]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:22.439]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:22.439]                   3L)]
[08:26:22.439]             }
[08:26:22.439]             function(cond) {
[08:26:22.439]                 is_error <- inherits(cond, "error")
[08:26:22.439]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:22.439]                   NULL)
[08:26:22.439]                 if (is_error) {
[08:26:22.439]                   sessionInformation <- function() {
[08:26:22.439]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:22.439]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:22.439]                       search = base::search(), system = base::Sys.info())
[08:26:22.439]                   }
[08:26:22.439]                   ...future.conditions[[length(...future.conditions) + 
[08:26:22.439]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:22.439]                     cond$call), session = sessionInformation(), 
[08:26:22.439]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:22.439]                   signalCondition(cond)
[08:26:22.439]                 }
[08:26:22.439]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:22.439]                 "immediateCondition"))) {
[08:26:22.439]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:22.439]                   ...future.conditions[[length(...future.conditions) + 
[08:26:22.439]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:22.439]                   if (TRUE && !signal) {
[08:26:22.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:22.439]                     {
[08:26:22.439]                       inherits <- base::inherits
[08:26:22.439]                       invokeRestart <- base::invokeRestart
[08:26:22.439]                       is.null <- base::is.null
[08:26:22.439]                       muffled <- FALSE
[08:26:22.439]                       if (inherits(cond, "message")) {
[08:26:22.439]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:22.439]                         if (muffled) 
[08:26:22.439]                           invokeRestart("muffleMessage")
[08:26:22.439]                       }
[08:26:22.439]                       else if (inherits(cond, "warning")) {
[08:26:22.439]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:22.439]                         if (muffled) 
[08:26:22.439]                           invokeRestart("muffleWarning")
[08:26:22.439]                       }
[08:26:22.439]                       else if (inherits(cond, "condition")) {
[08:26:22.439]                         if (!is.null(pattern)) {
[08:26:22.439]                           computeRestarts <- base::computeRestarts
[08:26:22.439]                           grepl <- base::grepl
[08:26:22.439]                           restarts <- computeRestarts(cond)
[08:26:22.439]                           for (restart in restarts) {
[08:26:22.439]                             name <- restart$name
[08:26:22.439]                             if (is.null(name)) 
[08:26:22.439]                               next
[08:26:22.439]                             if (!grepl(pattern, name)) 
[08:26:22.439]                               next
[08:26:22.439]                             invokeRestart(restart)
[08:26:22.439]                             muffled <- TRUE
[08:26:22.439]                             break
[08:26:22.439]                           }
[08:26:22.439]                         }
[08:26:22.439]                       }
[08:26:22.439]                       invisible(muffled)
[08:26:22.439]                     }
[08:26:22.439]                     muffleCondition(cond, pattern = "^muffle")
[08:26:22.439]                   }
[08:26:22.439]                 }
[08:26:22.439]                 else {
[08:26:22.439]                   if (TRUE) {
[08:26:22.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:22.439]                     {
[08:26:22.439]                       inherits <- base::inherits
[08:26:22.439]                       invokeRestart <- base::invokeRestart
[08:26:22.439]                       is.null <- base::is.null
[08:26:22.439]                       muffled <- FALSE
[08:26:22.439]                       if (inherits(cond, "message")) {
[08:26:22.439]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:22.439]                         if (muffled) 
[08:26:22.439]                           invokeRestart("muffleMessage")
[08:26:22.439]                       }
[08:26:22.439]                       else if (inherits(cond, "warning")) {
[08:26:22.439]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:22.439]                         if (muffled) 
[08:26:22.439]                           invokeRestart("muffleWarning")
[08:26:22.439]                       }
[08:26:22.439]                       else if (inherits(cond, "condition")) {
[08:26:22.439]                         if (!is.null(pattern)) {
[08:26:22.439]                           computeRestarts <- base::computeRestarts
[08:26:22.439]                           grepl <- base::grepl
[08:26:22.439]                           restarts <- computeRestarts(cond)
[08:26:22.439]                           for (restart in restarts) {
[08:26:22.439]                             name <- restart$name
[08:26:22.439]                             if (is.null(name)) 
[08:26:22.439]                               next
[08:26:22.439]                             if (!grepl(pattern, name)) 
[08:26:22.439]                               next
[08:26:22.439]                             invokeRestart(restart)
[08:26:22.439]                             muffled <- TRUE
[08:26:22.439]                             break
[08:26:22.439]                           }
[08:26:22.439]                         }
[08:26:22.439]                       }
[08:26:22.439]                       invisible(muffled)
[08:26:22.439]                     }
[08:26:22.439]                     muffleCondition(cond, pattern = "^muffle")
[08:26:22.439]                   }
[08:26:22.439]                 }
[08:26:22.439]             }
[08:26:22.439]         }))
[08:26:22.439]     }, error = function(ex) {
[08:26:22.439]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:22.439]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:22.439]                 ...future.rng), started = ...future.startTime, 
[08:26:22.439]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:22.439]             version = "1.8"), class = "FutureResult")
[08:26:22.439]     }, finally = {
[08:26:22.439]         if (!identical(...future.workdir, getwd())) 
[08:26:22.439]             setwd(...future.workdir)
[08:26:22.439]         {
[08:26:22.439]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:22.439]                 ...future.oldOptions$nwarnings <- NULL
[08:26:22.439]             }
[08:26:22.439]             base::options(...future.oldOptions)
[08:26:22.439]             if (.Platform$OS.type == "windows") {
[08:26:22.439]                 old_names <- names(...future.oldEnvVars)
[08:26:22.439]                 envs <- base::Sys.getenv()
[08:26:22.439]                 names <- names(envs)
[08:26:22.439]                 common <- intersect(names, old_names)
[08:26:22.439]                 added <- setdiff(names, old_names)
[08:26:22.439]                 removed <- setdiff(old_names, names)
[08:26:22.439]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:22.439]                   envs[common]]
[08:26:22.439]                 NAMES <- toupper(changed)
[08:26:22.439]                 args <- list()
[08:26:22.439]                 for (kk in seq_along(NAMES)) {
[08:26:22.439]                   name <- changed[[kk]]
[08:26:22.439]                   NAME <- NAMES[[kk]]
[08:26:22.439]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:22.439]                     next
[08:26:22.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:22.439]                 }
[08:26:22.439]                 NAMES <- toupper(added)
[08:26:22.439]                 for (kk in seq_along(NAMES)) {
[08:26:22.439]                   name <- added[[kk]]
[08:26:22.439]                   NAME <- NAMES[[kk]]
[08:26:22.439]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:22.439]                     next
[08:26:22.439]                   args[[name]] <- ""
[08:26:22.439]                 }
[08:26:22.439]                 NAMES <- toupper(removed)
[08:26:22.439]                 for (kk in seq_along(NAMES)) {
[08:26:22.439]                   name <- removed[[kk]]
[08:26:22.439]                   NAME <- NAMES[[kk]]
[08:26:22.439]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:22.439]                     next
[08:26:22.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:22.439]                 }
[08:26:22.439]                 if (length(args) > 0) 
[08:26:22.439]                   base::do.call(base::Sys.setenv, args = args)
[08:26:22.439]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:22.439]             }
[08:26:22.439]             else {
[08:26:22.439]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:22.439]             }
[08:26:22.439]             {
[08:26:22.439]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:22.439]                   0L) {
[08:26:22.439]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:22.439]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:22.439]                   base::options(opts)
[08:26:22.439]                 }
[08:26:22.439]                 {
[08:26:22.439]                   {
[08:26:22.439]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:22.439]                     NULL
[08:26:22.439]                   }
[08:26:22.439]                   options(future.plan = NULL)
[08:26:22.439]                   if (is.na(NA_character_)) 
[08:26:22.439]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:22.439]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:22.439]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:22.439]                     .init = FALSE)
[08:26:22.439]                 }
[08:26:22.439]             }
[08:26:22.439]         }
[08:26:22.439]     })
[08:26:22.439]     if (TRUE) {
[08:26:22.439]         base::sink(type = "output", split = FALSE)
[08:26:22.439]         if (TRUE) {
[08:26:22.439]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:22.439]         }
[08:26:22.439]         else {
[08:26:22.439]             ...future.result["stdout"] <- base::list(NULL)
[08:26:22.439]         }
[08:26:22.439]         base::close(...future.stdout)
[08:26:22.439]         ...future.stdout <- NULL
[08:26:22.439]     }
[08:26:22.439]     ...future.result$conditions <- ...future.conditions
[08:26:22.439]     ...future.result$finished <- base::Sys.time()
[08:26:22.439]     ...future.result
[08:26:22.439] }
[08:26:22.443] Exporting 11 global objects (12.52 KiB) to cluster node #1 ...
[08:26:22.443] Exporting ‘...future.FUN’ (4.02 KiB) to cluster node #1 ...
[08:26:22.483] Exporting ‘...future.FUN’ (4.02 KiB) to cluster node #1 ... DONE
[08:26:22.484] Exporting ‘x_FUN’ (36 bytes) to cluster node #1 ...
[08:26:22.484] Exporting ‘x_FUN’ (36 bytes) to cluster node #1 ... DONE
[08:26:22.484] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[08:26:22.485] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[08:26:22.485] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[08:26:22.526] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[08:26:22.527] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[08:26:22.567] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[08:26:22.568] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[08:26:22.568] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[08:26:22.568] Exporting ‘valid_types’ (48 bytes) to cluster node #1 ...
[08:26:22.569] Exporting ‘valid_types’ (48 bytes) to cluster node #1 ... DONE
[08:26:22.569] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:26:22.569] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:26:22.570] Exporting ‘...future.elements_ii’ (183 bytes) to cluster node #1 ...
[08:26:22.570] Exporting ‘...future.elements_ii’ (183 bytes) to cluster node #1 ... DONE
[08:26:22.570] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:26:22.570] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:26:22.571] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:26:22.571] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:26:22.571] Exporting 11 global objects (12.52 KiB) to cluster node #1 ... DONE
[08:26:22.572] MultisessionFuture started
[08:26:22.572] - Launch lazy future ... done
[08:26:22.572] run() for ‘MultisessionFuture’ ... done
[08:26:22.572] Created future:
[08:26:22.572] MultisessionFuture:
[08:26:22.572] Label: ‘future_vapply-1’
[08:26:22.572] Expression:
[08:26:22.572] {
[08:26:22.572]     do.call(function(...) {
[08:26:22.572]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:22.572]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:22.572]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:22.572]             on.exit(options(oopts), add = TRUE)
[08:26:22.572]         }
[08:26:22.572]         {
[08:26:22.572]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:22.572]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:22.572]                 ...future.FUN(...future.X_jj, ...)
[08:26:22.572]             })
[08:26:22.572]         }
[08:26:22.572]     }, args = future.call.arguments)
[08:26:22.572] }
[08:26:22.572] Lazy evaluation: FALSE
[08:26:22.572] Asynchronous evaluation: TRUE
[08:26:22.572] Local evaluation: TRUE
[08:26:22.572] Environment: R_GlobalEnv
[08:26:22.572] Capture standard output: TRUE
[08:26:22.572] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:22.572] Globals: 11 objects totaling 12.33 KiB (function ‘...future.FUN’ of 4.02 KiB, function ‘x_FUN’ of 36 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:22.572] Packages: 1 packages (‘future.apply’)
[08:26:22.572] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:22.572] Resolved: FALSE
[08:26:22.572] Value: <not collected>
[08:26:22.572] Conditions captured: <none>
[08:26:22.572] Early signaling: FALSE
[08:26:22.572] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:22.572] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:22.584] Chunk #1 of 2 ... DONE
[08:26:22.585] Chunk #2 of 2 ...
[08:26:22.585]  - Finding globals in 'X' for chunk #2 ...
[08:26:22.585] getGlobalsAndPackages() ...
[08:26:22.585] Searching for globals...
[08:26:22.585] 
[08:26:22.585] Searching for globals ... DONE
[08:26:22.586] - globals: [0] <none>
[08:26:22.586] getGlobalsAndPackages() ... DONE
[08:26:22.586]    + additional globals found: [n=0] 
[08:26:22.586]    + additional namespaces needed: [n=0] 
[08:26:22.586]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:22.586]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:22.586]  - seeds: <none>
[08:26:22.586]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:22.586] getGlobalsAndPackages() ...
[08:26:22.587] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:22.587] Resolving globals: FALSE
[08:26:22.587] Tweak future expression to call with '...' arguments ...
[08:26:22.587] {
[08:26:22.587]     do.call(function(...) {
[08:26:22.587]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:22.587]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:22.587]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:22.587]             on.exit(options(oopts), add = TRUE)
[08:26:22.587]         }
[08:26:22.587]         {
[08:26:22.587]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:22.587]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:22.587]                 ...future.FUN(...future.X_jj, ...)
[08:26:22.587]             })
[08:26:22.587]         }
[08:26:22.587]     }, args = future.call.arguments)
[08:26:22.587] }
[08:26:22.587] Tweak future expression to call with '...' arguments ... DONE
[08:26:22.588] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:22.588] - packages: [1] ‘future.apply’
[08:26:22.588] getGlobalsAndPackages() ... DONE
[08:26:22.589] run() for ‘Future’ ...
[08:26:22.589] - state: ‘created’
[08:26:22.589] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:22.604] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:22.605] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:22.605]   - Field: ‘node’
[08:26:22.605]   - Field: ‘label’
[08:26:22.605]   - Field: ‘local’
[08:26:22.605]   - Field: ‘owner’
[08:26:22.605]   - Field: ‘envir’
[08:26:22.605]   - Field: ‘workers’
[08:26:22.605]   - Field: ‘packages’
[08:26:22.605]   - Field: ‘gc’
[08:26:22.605]   - Field: ‘conditions’
[08:26:22.606]   - Field: ‘persistent’
[08:26:22.606]   - Field: ‘expr’
[08:26:22.606]   - Field: ‘uuid’
[08:26:22.606]   - Field: ‘seed’
[08:26:22.606]   - Field: ‘version’
[08:26:22.606]   - Field: ‘result’
[08:26:22.606]   - Field: ‘asynchronous’
[08:26:22.606]   - Field: ‘calls’
[08:26:22.606]   - Field: ‘globals’
[08:26:22.607]   - Field: ‘stdout’
[08:26:22.607]   - Field: ‘earlySignal’
[08:26:22.607]   - Field: ‘lazy’
[08:26:22.607]   - Field: ‘state’
[08:26:22.607] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:22.607] - Launch lazy future ...
[08:26:22.607] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:22.608] Packages needed by future strategies (n = 0): <none>
[08:26:22.608] {
[08:26:22.608]     {
[08:26:22.608]         {
[08:26:22.608]             ...future.startTime <- base::Sys.time()
[08:26:22.608]             {
[08:26:22.608]                 {
[08:26:22.608]                   {
[08:26:22.608]                     {
[08:26:22.608]                       {
[08:26:22.608]                         base::local({
[08:26:22.608]                           has_future <- base::requireNamespace("future", 
[08:26:22.608]                             quietly = TRUE)
[08:26:22.608]                           if (has_future) {
[08:26:22.608]                             ns <- base::getNamespace("future")
[08:26:22.608]                             version <- ns[[".package"]][["version"]]
[08:26:22.608]                             if (is.null(version)) 
[08:26:22.608]                               version <- utils::packageVersion("future")
[08:26:22.608]                           }
[08:26:22.608]                           else {
[08:26:22.608]                             version <- NULL
[08:26:22.608]                           }
[08:26:22.608]                           if (!has_future || version < "1.8.0") {
[08:26:22.608]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:22.608]                               "", base::R.version$version.string), 
[08:26:22.608]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:22.608]                                 base::R.version$platform, 8 * 
[08:26:22.608]                                   base::.Machine$sizeof.pointer), 
[08:26:22.608]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:22.608]                                 "release", "version")], collapse = " "), 
[08:26:22.608]                               hostname = base::Sys.info()[["nodename"]])
[08:26:22.608]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:22.608]                               info)
[08:26:22.608]                             info <- base::paste(info, collapse = "; ")
[08:26:22.608]                             if (!has_future) {
[08:26:22.608]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:22.608]                                 info)
[08:26:22.608]                             }
[08:26:22.608]                             else {
[08:26:22.608]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:22.608]                                 info, version)
[08:26:22.608]                             }
[08:26:22.608]                             base::stop(msg)
[08:26:22.608]                           }
[08:26:22.608]                         })
[08:26:22.608]                       }
[08:26:22.608]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:22.608]                       base::options(mc.cores = 1L)
[08:26:22.608]                     }
[08:26:22.608]                     base::local({
[08:26:22.608]                       for (pkg in "future.apply") {
[08:26:22.608]                         base::loadNamespace(pkg)
[08:26:22.608]                         base::library(pkg, character.only = TRUE)
[08:26:22.608]                       }
[08:26:22.608]                     })
[08:26:22.608]                   }
[08:26:22.608]                   ...future.strategy.old <- future::plan("list")
[08:26:22.608]                   options(future.plan = NULL)
[08:26:22.608]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:22.608]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:22.608]                 }
[08:26:22.608]                 ...future.workdir <- getwd()
[08:26:22.608]             }
[08:26:22.608]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:22.608]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:22.608]         }
[08:26:22.608]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:22.608]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:22.608]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:22.608]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:22.608]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:22.608]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:22.608]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:22.608]             base::names(...future.oldOptions))
[08:26:22.608]     }
[08:26:22.608]     if (FALSE) {
[08:26:22.608]     }
[08:26:22.608]     else {
[08:26:22.608]         if (TRUE) {
[08:26:22.608]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:22.608]                 open = "w")
[08:26:22.608]         }
[08:26:22.608]         else {
[08:26:22.608]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:22.608]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:22.608]         }
[08:26:22.608]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:22.608]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:22.608]             base::sink(type = "output", split = FALSE)
[08:26:22.608]             base::close(...future.stdout)
[08:26:22.608]         }, add = TRUE)
[08:26:22.608]     }
[08:26:22.608]     ...future.frame <- base::sys.nframe()
[08:26:22.608]     ...future.conditions <- base::list()
[08:26:22.608]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:22.608]     if (FALSE) {
[08:26:22.608]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:22.608]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:22.608]     }
[08:26:22.608]     ...future.result <- base::tryCatch({
[08:26:22.608]         base::withCallingHandlers({
[08:26:22.608]             ...future.value <- base::withVisible(base::local({
[08:26:22.608]                 ...future.makeSendCondition <- base::local({
[08:26:22.608]                   sendCondition <- NULL
[08:26:22.608]                   function(frame = 1L) {
[08:26:22.608]                     if (is.function(sendCondition)) 
[08:26:22.608]                       return(sendCondition)
[08:26:22.608]                     ns <- getNamespace("parallel")
[08:26:22.608]                     if (exists("sendData", mode = "function", 
[08:26:22.608]                       envir = ns)) {
[08:26:22.608]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:22.608]                         envir = ns)
[08:26:22.608]                       envir <- sys.frame(frame)
[08:26:22.608]                       master <- NULL
[08:26:22.608]                       while (!identical(envir, .GlobalEnv) && 
[08:26:22.608]                         !identical(envir, emptyenv())) {
[08:26:22.608]                         if (exists("master", mode = "list", envir = envir, 
[08:26:22.608]                           inherits = FALSE)) {
[08:26:22.608]                           master <- get("master", mode = "list", 
[08:26:22.608]                             envir = envir, inherits = FALSE)
[08:26:22.608]                           if (inherits(master, c("SOCKnode", 
[08:26:22.608]                             "SOCK0node"))) {
[08:26:22.608]                             sendCondition <<- function(cond) {
[08:26:22.608]                               data <- list(type = "VALUE", value = cond, 
[08:26:22.608]                                 success = TRUE)
[08:26:22.608]                               parallel_sendData(master, data)
[08:26:22.608]                             }
[08:26:22.608]                             return(sendCondition)
[08:26:22.608]                           }
[08:26:22.608]                         }
[08:26:22.608]                         frame <- frame + 1L
[08:26:22.608]                         envir <- sys.frame(frame)
[08:26:22.608]                       }
[08:26:22.608]                     }
[08:26:22.608]                     sendCondition <<- function(cond) NULL
[08:26:22.608]                   }
[08:26:22.608]                 })
[08:26:22.608]                 withCallingHandlers({
[08:26:22.608]                   {
[08:26:22.608]                     do.call(function(...) {
[08:26:22.608]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:22.608]                       if (!identical(...future.globals.maxSize.org, 
[08:26:22.608]                         ...future.globals.maxSize)) {
[08:26:22.608]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:22.608]                         on.exit(options(oopts), add = TRUE)
[08:26:22.608]                       }
[08:26:22.608]                       {
[08:26:22.608]                         lapply(seq_along(...future.elements_ii), 
[08:26:22.608]                           FUN = function(jj) {
[08:26:22.608]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:22.608]                             ...future.FUN(...future.X_jj, ...)
[08:26:22.608]                           })
[08:26:22.608]                       }
[08:26:22.608]                     }, args = future.call.arguments)
[08:26:22.608]                   }
[08:26:22.608]                 }, immediateCondition = function(cond) {
[08:26:22.608]                   sendCondition <- ...future.makeSendCondition()
[08:26:22.608]                   sendCondition(cond)
[08:26:22.608]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:22.608]                   {
[08:26:22.608]                     inherits <- base::inherits
[08:26:22.608]                     invokeRestart <- base::invokeRestart
[08:26:22.608]                     is.null <- base::is.null
[08:26:22.608]                     muffled <- FALSE
[08:26:22.608]                     if (inherits(cond, "message")) {
[08:26:22.608]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:22.608]                       if (muffled) 
[08:26:22.608]                         invokeRestart("muffleMessage")
[08:26:22.608]                     }
[08:26:22.608]                     else if (inherits(cond, "warning")) {
[08:26:22.608]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:22.608]                       if (muffled) 
[08:26:22.608]                         invokeRestart("muffleWarning")
[08:26:22.608]                     }
[08:26:22.608]                     else if (inherits(cond, "condition")) {
[08:26:22.608]                       if (!is.null(pattern)) {
[08:26:22.608]                         computeRestarts <- base::computeRestarts
[08:26:22.608]                         grepl <- base::grepl
[08:26:22.608]                         restarts <- computeRestarts(cond)
[08:26:22.608]                         for (restart in restarts) {
[08:26:22.608]                           name <- restart$name
[08:26:22.608]                           if (is.null(name)) 
[08:26:22.608]                             next
[08:26:22.608]                           if (!grepl(pattern, name)) 
[08:26:22.608]                             next
[08:26:22.608]                           invokeRestart(restart)
[08:26:22.608]                           muffled <- TRUE
[08:26:22.608]                           break
[08:26:22.608]                         }
[08:26:22.608]                       }
[08:26:22.608]                     }
[08:26:22.608]                     invisible(muffled)
[08:26:22.608]                   }
[08:26:22.608]                   muffleCondition(cond)
[08:26:22.608]                 })
[08:26:22.608]             }))
[08:26:22.608]             future::FutureResult(value = ...future.value$value, 
[08:26:22.608]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:22.608]                   ...future.rng), globalenv = if (FALSE) 
[08:26:22.608]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:22.608]                     ...future.globalenv.names))
[08:26:22.608]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:22.608]         }, condition = base::local({
[08:26:22.608]             c <- base::c
[08:26:22.608]             inherits <- base::inherits
[08:26:22.608]             invokeRestart <- base::invokeRestart
[08:26:22.608]             length <- base::length
[08:26:22.608]             list <- base::list
[08:26:22.608]             seq.int <- base::seq.int
[08:26:22.608]             signalCondition <- base::signalCondition
[08:26:22.608]             sys.calls <- base::sys.calls
[08:26:22.608]             `[[` <- base::`[[`
[08:26:22.608]             `+` <- base::`+`
[08:26:22.608]             `<<-` <- base::`<<-`
[08:26:22.608]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:22.608]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:22.608]                   3L)]
[08:26:22.608]             }
[08:26:22.608]             function(cond) {
[08:26:22.608]                 is_error <- inherits(cond, "error")
[08:26:22.608]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:22.608]                   NULL)
[08:26:22.608]                 if (is_error) {
[08:26:22.608]                   sessionInformation <- function() {
[08:26:22.608]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:22.608]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:22.608]                       search = base::search(), system = base::Sys.info())
[08:26:22.608]                   }
[08:26:22.608]                   ...future.conditions[[length(...future.conditions) + 
[08:26:22.608]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:22.608]                     cond$call), session = sessionInformation(), 
[08:26:22.608]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:22.608]                   signalCondition(cond)
[08:26:22.608]                 }
[08:26:22.608]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:22.608]                 "immediateCondition"))) {
[08:26:22.608]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:22.608]                   ...future.conditions[[length(...future.conditions) + 
[08:26:22.608]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:22.608]                   if (TRUE && !signal) {
[08:26:22.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:22.608]                     {
[08:26:22.608]                       inherits <- base::inherits
[08:26:22.608]                       invokeRestart <- base::invokeRestart
[08:26:22.608]                       is.null <- base::is.null
[08:26:22.608]                       muffled <- FALSE
[08:26:22.608]                       if (inherits(cond, "message")) {
[08:26:22.608]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:22.608]                         if (muffled) 
[08:26:22.608]                           invokeRestart("muffleMessage")
[08:26:22.608]                       }
[08:26:22.608]                       else if (inherits(cond, "warning")) {
[08:26:22.608]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:22.608]                         if (muffled) 
[08:26:22.608]                           invokeRestart("muffleWarning")
[08:26:22.608]                       }
[08:26:22.608]                       else if (inherits(cond, "condition")) {
[08:26:22.608]                         if (!is.null(pattern)) {
[08:26:22.608]                           computeRestarts <- base::computeRestarts
[08:26:22.608]                           grepl <- base::grepl
[08:26:22.608]                           restarts <- computeRestarts(cond)
[08:26:22.608]                           for (restart in restarts) {
[08:26:22.608]                             name <- restart$name
[08:26:22.608]                             if (is.null(name)) 
[08:26:22.608]                               next
[08:26:22.608]                             if (!grepl(pattern, name)) 
[08:26:22.608]                               next
[08:26:22.608]                             invokeRestart(restart)
[08:26:22.608]                             muffled <- TRUE
[08:26:22.608]                             break
[08:26:22.608]                           }
[08:26:22.608]                         }
[08:26:22.608]                       }
[08:26:22.608]                       invisible(muffled)
[08:26:22.608]                     }
[08:26:22.608]                     muffleCondition(cond, pattern = "^muffle")
[08:26:22.608]                   }
[08:26:22.608]                 }
[08:26:22.608]                 else {
[08:26:22.608]                   if (TRUE) {
[08:26:22.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:22.608]                     {
[08:26:22.608]                       inherits <- base::inherits
[08:26:22.608]                       invokeRestart <- base::invokeRestart
[08:26:22.608]                       is.null <- base::is.null
[08:26:22.608]                       muffled <- FALSE
[08:26:22.608]                       if (inherits(cond, "message")) {
[08:26:22.608]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:22.608]                         if (muffled) 
[08:26:22.608]                           invokeRestart("muffleMessage")
[08:26:22.608]                       }
[08:26:22.608]                       else if (inherits(cond, "warning")) {
[08:26:22.608]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:22.608]                         if (muffled) 
[08:26:22.608]                           invokeRestart("muffleWarning")
[08:26:22.608]                       }
[08:26:22.608]                       else if (inherits(cond, "condition")) {
[08:26:22.608]                         if (!is.null(pattern)) {
[08:26:22.608]                           computeRestarts <- base::computeRestarts
[08:26:22.608]                           grepl <- base::grepl
[08:26:22.608]                           restarts <- computeRestarts(cond)
[08:26:22.608]                           for (restart in restarts) {
[08:26:22.608]                             name <- restart$name
[08:26:22.608]                             if (is.null(name)) 
[08:26:22.608]                               next
[08:26:22.608]                             if (!grepl(pattern, name)) 
[08:26:22.608]                               next
[08:26:22.608]                             invokeRestart(restart)
[08:26:22.608]                             muffled <- TRUE
[08:26:22.608]                             break
[08:26:22.608]                           }
[08:26:22.608]                         }
[08:26:22.608]                       }
[08:26:22.608]                       invisible(muffled)
[08:26:22.608]                     }
[08:26:22.608]                     muffleCondition(cond, pattern = "^muffle")
[08:26:22.608]                   }
[08:26:22.608]                 }
[08:26:22.608]             }
[08:26:22.608]         }))
[08:26:22.608]     }, error = function(ex) {
[08:26:22.608]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:22.608]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:22.608]                 ...future.rng), started = ...future.startTime, 
[08:26:22.608]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:22.608]             version = "1.8"), class = "FutureResult")
[08:26:22.608]     }, finally = {
[08:26:22.608]         if (!identical(...future.workdir, getwd())) 
[08:26:22.608]             setwd(...future.workdir)
[08:26:22.608]         {
[08:26:22.608]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:22.608]                 ...future.oldOptions$nwarnings <- NULL
[08:26:22.608]             }
[08:26:22.608]             base::options(...future.oldOptions)
[08:26:22.608]             if (.Platform$OS.type == "windows") {
[08:26:22.608]                 old_names <- names(...future.oldEnvVars)
[08:26:22.608]                 envs <- base::Sys.getenv()
[08:26:22.608]                 names <- names(envs)
[08:26:22.608]                 common <- intersect(names, old_names)
[08:26:22.608]                 added <- setdiff(names, old_names)
[08:26:22.608]                 removed <- setdiff(old_names, names)
[08:26:22.608]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:22.608]                   envs[common]]
[08:26:22.608]                 NAMES <- toupper(changed)
[08:26:22.608]                 args <- list()
[08:26:22.608]                 for (kk in seq_along(NAMES)) {
[08:26:22.608]                   name <- changed[[kk]]
[08:26:22.608]                   NAME <- NAMES[[kk]]
[08:26:22.608]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:22.608]                     next
[08:26:22.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:22.608]                 }
[08:26:22.608]                 NAMES <- toupper(added)
[08:26:22.608]                 for (kk in seq_along(NAMES)) {
[08:26:22.608]                   name <- added[[kk]]
[08:26:22.608]                   NAME <- NAMES[[kk]]
[08:26:22.608]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:22.608]                     next
[08:26:22.608]                   args[[name]] <- ""
[08:26:22.608]                 }
[08:26:22.608]                 NAMES <- toupper(removed)
[08:26:22.608]                 for (kk in seq_along(NAMES)) {
[08:26:22.608]                   name <- removed[[kk]]
[08:26:22.608]                   NAME <- NAMES[[kk]]
[08:26:22.608]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:22.608]                     next
[08:26:22.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:22.608]                 }
[08:26:22.608]                 if (length(args) > 0) 
[08:26:22.608]                   base::do.call(base::Sys.setenv, args = args)
[08:26:22.608]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:22.608]             }
[08:26:22.608]             else {
[08:26:22.608]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:22.608]             }
[08:26:22.608]             {
[08:26:22.608]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:22.608]                   0L) {
[08:26:22.608]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:22.608]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:22.608]                   base::options(opts)
[08:26:22.608]                 }
[08:26:22.608]                 {
[08:26:22.608]                   {
[08:26:22.608]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:22.608]                     NULL
[08:26:22.608]                   }
[08:26:22.608]                   options(future.plan = NULL)
[08:26:22.608]                   if (is.na(NA_character_)) 
[08:26:22.608]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:22.608]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:22.608]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:22.608]                     .init = FALSE)
[08:26:22.608]                 }
[08:26:22.608]             }
[08:26:22.608]         }
[08:26:22.608]     })
[08:26:22.608]     if (TRUE) {
[08:26:22.608]         base::sink(type = "output", split = FALSE)
[08:26:22.608]         if (TRUE) {
[08:26:22.608]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:22.608]         }
[08:26:22.608]         else {
[08:26:22.608]             ...future.result["stdout"] <- base::list(NULL)
[08:26:22.608]         }
[08:26:22.608]         base::close(...future.stdout)
[08:26:22.608]         ...future.stdout <- NULL
[08:26:22.608]     }
[08:26:22.608]     ...future.result$conditions <- ...future.conditions
[08:26:22.608]     ...future.result$finished <- base::Sys.time()
[08:26:22.608]     ...future.result
[08:26:22.608] }
[08:26:22.662] Exporting 11 global objects (12.54 KiB) to cluster node #2 ...
[08:26:22.663] Exporting ‘...future.FUN’ (4.02 KiB) to cluster node #2 ...
[08:26:22.667] Exporting ‘...future.FUN’ (4.02 KiB) to cluster node #2 ... DONE
[08:26:22.667] Exporting ‘x_FUN’ (36 bytes) to cluster node #2 ...
[08:26:22.668] Exporting ‘x_FUN’ (36 bytes) to cluster node #2 ... DONE
[08:26:22.668] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[08:26:22.668] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[08:26:22.669] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[08:26:22.710] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[08:26:22.710] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[08:26:22.752] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[08:26:22.752] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[08:26:22.752] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[08:26:22.753] Exporting ‘valid_types’ (48 bytes) to cluster node #2 ...
[08:26:22.753] Exporting ‘valid_types’ (48 bytes) to cluster node #2 ... DONE
[08:26:22.753] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:26:22.754] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:26:22.754] Exporting ‘...future.elements_ii’ (171 bytes) to cluster node #2 ...
[08:26:22.754] Exporting ‘...future.elements_ii’ (171 bytes) to cluster node #2 ... DONE
[08:26:22.754] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:26:22.755] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:26:22.755] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:26:22.755] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:26:22.755] Exporting 11 global objects (12.54 KiB) to cluster node #2 ... DONE
[08:26:22.756] MultisessionFuture started
[08:26:22.756] - Launch lazy future ... done
[08:26:22.756] run() for ‘MultisessionFuture’ ... done
[08:26:22.757] Created future:
[08:26:22.757] MultisessionFuture:
[08:26:22.757] Label: ‘future_vapply-2’
[08:26:22.757] Expression:
[08:26:22.757] {
[08:26:22.757]     do.call(function(...) {
[08:26:22.757]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:22.757]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:22.757]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:22.757]             on.exit(options(oopts), add = TRUE)
[08:26:22.757]         }
[08:26:22.757]         {
[08:26:22.757]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:22.757]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:22.757]                 ...future.FUN(...future.X_jj, ...)
[08:26:22.757]             })
[08:26:22.757]         }
[08:26:22.757]     }, args = future.call.arguments)
[08:26:22.757] }
[08:26:22.757] Lazy evaluation: FALSE
[08:26:22.757] Asynchronous evaluation: TRUE
[08:26:22.757] Local evaluation: TRUE
[08:26:22.757] Environment: R_GlobalEnv
[08:26:22.757] Capture standard output: TRUE
[08:26:22.757] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:22.757] Globals: 11 objects totaling 12.32 KiB (function ‘...future.FUN’ of 4.02 KiB, function ‘x_FUN’ of 36 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:22.757] Packages: 1 packages (‘future.apply’)
[08:26:22.757] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:22.757] Resolved: FALSE
[08:26:22.757] Value: <not collected>
[08:26:22.757] Conditions captured: <none>
[08:26:22.757] Early signaling: FALSE
[08:26:22.757] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:22.757] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:22.769] Chunk #2 of 2 ... DONE
[08:26:22.769] Launching 2 futures (chunks) ... DONE
[08:26:22.769] Resolving 2 futures (chunks) ...
[08:26:22.769] resolve() on list ...
[08:26:22.769]  recursive: 0
[08:26:22.769]  length: 2
[08:26:22.769] 
[08:26:22.770] receiveMessageFromWorker() for ClusterFuture ...
[08:26:22.770] - Validating connection of MultisessionFuture
[08:26:22.770] - received message: FutureResult
[08:26:22.771] - Received FutureResult
[08:26:22.771] - Erased future from FutureRegistry
[08:26:22.771] result() for ClusterFuture ...
[08:26:22.771] - result already collected: FutureResult
[08:26:22.771] result() for ClusterFuture ... done
[08:26:22.771] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:22.771] Future #1
[08:26:22.771] result() for ClusterFuture ...
[08:26:22.772] - result already collected: FutureResult
[08:26:22.772] result() for ClusterFuture ... done
[08:26:22.772] result() for ClusterFuture ...
[08:26:22.772] - result already collected: FutureResult
[08:26:22.772] result() for ClusterFuture ... done
[08:26:22.772] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:26:22.772] - nx: 2
[08:26:22.772] - relay: TRUE
[08:26:22.772] - stdout: TRUE
[08:26:22.772] - signal: TRUE
[08:26:22.773] - resignal: FALSE
[08:26:22.773] - force: TRUE
[08:26:22.773] - relayed: [n=2] FALSE, FALSE
[08:26:22.773] - queued futures: [n=2] FALSE, FALSE
[08:26:22.773]  - until=1
[08:26:22.773]  - relaying element #1
[08:26:22.773] result() for ClusterFuture ...
[08:26:22.773] - result already collected: FutureResult
[08:26:22.773] result() for ClusterFuture ... done
[08:26:22.774] result() for ClusterFuture ...
[08:26:22.774] - result already collected: FutureResult
[08:26:22.774] result() for ClusterFuture ... done
[08:26:22.774] result() for ClusterFuture ...
[08:26:22.774] - result already collected: FutureResult
[08:26:22.774] result() for ClusterFuture ... done
[08:26:22.774] result() for ClusterFuture ...
[08:26:22.774] - result already collected: FutureResult
[08:26:22.774] result() for ClusterFuture ... done
[08:26:22.774] - relayed: [n=2] TRUE, FALSE
[08:26:22.775] - queued futures: [n=2] TRUE, FALSE
[08:26:22.775] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:26:22.775]  length: 1 (resolved future 1)
[08:26:22.840] receiveMessageFromWorker() for ClusterFuture ...
[08:26:22.840] - Validating connection of MultisessionFuture
[08:26:22.841] - received message: FutureResult
[08:26:22.841] - Received FutureResult
[08:26:22.841] - Erased future from FutureRegistry
[08:26:22.841] result() for ClusterFuture ...
[08:26:22.841] - result already collected: FutureResult
[08:26:22.841] result() for ClusterFuture ... done
[08:26:22.841] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:22.841] Future #2
[08:26:22.842] result() for ClusterFuture ...
[08:26:22.842] - result already collected: FutureResult
[08:26:22.842] result() for ClusterFuture ... done
[08:26:22.842] result() for ClusterFuture ...
[08:26:22.842] - result already collected: FutureResult
[08:26:22.842] result() for ClusterFuture ... done
[08:26:22.842] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:26:22.842] - nx: 2
[08:26:22.842] - relay: TRUE
[08:26:22.843] - stdout: TRUE
[08:26:22.843] - signal: TRUE
[08:26:22.843] - resignal: FALSE
[08:26:22.843] - force: TRUE
[08:26:22.843] - relayed: [n=2] TRUE, FALSE
[08:26:22.843] - queued futures: [n=2] TRUE, FALSE
[08:26:22.843]  - until=2
[08:26:22.843]  - relaying element #2
[08:26:22.843] result() for ClusterFuture ...
[08:26:22.844] - result already collected: FutureResult
[08:26:22.844] result() for ClusterFuture ... done
[08:26:22.844] result() for ClusterFuture ...
[08:26:22.844] - result already collected: FutureResult
[08:26:22.844] result() for ClusterFuture ... done
[08:26:22.844] result() for ClusterFuture ...
[08:26:22.844] - result already collected: FutureResult
[08:26:22.844] result() for ClusterFuture ... done
[08:26:22.844] result() for ClusterFuture ...
[08:26:22.845] - result already collected: FutureResult
[08:26:22.845] result() for ClusterFuture ... done
[08:26:22.845] - relayed: [n=2] TRUE, TRUE
[08:26:22.845] - queued futures: [n=2] TRUE, TRUE
[08:26:22.845] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:26:22.845]  length: 0 (resolved future 2)
[08:26:22.845] Relaying remaining futures
[08:26:22.845] signalConditionsASAP(NULL, pos=0) ...
[08:26:22.845] - nx: 2
[08:26:22.845] - relay: TRUE
[08:26:22.846] - stdout: TRUE
[08:26:22.846] - signal: TRUE
[08:26:22.846] - resignal: FALSE
[08:26:22.846] - force: TRUE
[08:26:22.846] - relayed: [n=2] TRUE, TRUE
[08:26:22.846] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:22.846] - relayed: [n=2] TRUE, TRUE
[08:26:22.846] - queued futures: [n=2] TRUE, TRUE
[08:26:22.846] signalConditionsASAP(NULL, pos=0) ... done
[08:26:22.847] resolve() on list ... DONE
[08:26:22.847] result() for ClusterFuture ...
[08:26:22.847] - result already collected: FutureResult
[08:26:22.847] result() for ClusterFuture ... done
[08:26:22.847] result() for ClusterFuture ...
[08:26:22.847] - result already collected: FutureResult
[08:26:22.847] result() for ClusterFuture ... done
[08:26:22.847] result() for ClusterFuture ...
[08:26:22.847] - result already collected: FutureResult
[08:26:22.848] result() for ClusterFuture ... done
[08:26:22.848] result() for ClusterFuture ...
[08:26:22.848] - result already collected: FutureResult
[08:26:22.848] result() for ClusterFuture ... done
[08:26:22.848]  - Number of value chunks collected: 2
[08:26:22.848] Resolving 2 futures (chunks) ... DONE
[08:26:22.848] Reducing values from 2 chunks ...
[08:26:22.848]  - Number of values collected after concatenation: 2
[08:26:22.848]  - Number of values expected: 2
[08:26:22.849] Reducing values from 2 chunks ... DONE
[08:26:22.849] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[08:26:22.850] future_lapply() ...
[08:26:22.854] Number of chunks: 2
[08:26:22.854] getGlobalsAndPackagesXApply() ...
[08:26:22.854]  - future.globals: TRUE
[08:26:22.854] getGlobalsAndPackages() ...
[08:26:22.855] Searching for globals...
[08:26:22.859] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[08:26:22.859] Searching for globals ... DONE
[08:26:22.859] Resolving globals: FALSE
[08:26:22.860] The total size of the 7 globals is 12.77 KiB (13081 bytes)
[08:26:22.861] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.77 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:22.861] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:22.861] - packages: [1] ‘future.apply’
[08:26:22.861] getGlobalsAndPackages() ... DONE
[08:26:22.864]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:22.864]  - needed namespaces: [n=1] ‘future.apply’
[08:26:22.864] Finding globals ... DONE
[08:26:22.864]  - use_args: TRUE
[08:26:22.864]  - Getting '...' globals ...
[08:26:22.865] resolve() on list ...
[08:26:22.865]  recursive: 0
[08:26:22.865]  length: 1
[08:26:22.865]  elements: ‘...’
[08:26:22.865]  length: 0 (resolved future 1)
[08:26:22.865] resolve() on list ... DONE
[08:26:22.865]    - '...' content: [n=0] 
[08:26:22.865] List of 1
[08:26:22.865]  $ ...: list()
[08:26:22.865]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:22.865]  - attr(*, "where")=List of 1
[08:26:22.865]   ..$ ...:<environment: 0x562caaa1b410> 
[08:26:22.865]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:22.865]  - attr(*, "resolved")= logi TRUE
[08:26:22.865]  - attr(*, "total_size")= num NA
[08:26:22.868]  - Getting '...' globals ... DONE
[08:26:22.868] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:22.868] List of 8
[08:26:22.868]  $ ...future.FUN:function (x, ...)  
[08:26:22.868]  $ x_FUN        :function (x)  
[08:26:22.868]  $ times        : int 0
[08:26:22.868]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:22.868]  $ stop_if_not  :function (...)  
[08:26:22.868]  $ dim          : NULL
[08:26:22.868]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:22.868]  $ ...          : list()
[08:26:22.868]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:22.868]  - attr(*, "where")=List of 8
[08:26:22.868]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:22.868]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:22.868]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:22.868]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:22.868]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:22.868]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:22.868]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:22.868]   ..$ ...          :<environment: 0x562caaa1b410> 
[08:26:22.868]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:22.868]  - attr(*, "resolved")= logi FALSE
[08:26:22.868]  - attr(*, "total_size")= num 23490
[08:26:22.873] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:22.873] getGlobalsAndPackagesXApply() ... DONE
[08:26:22.873] Number of futures (= number of chunks): 2
[08:26:22.874] Launching 2 futures (chunks) ...
[08:26:22.874] Chunk #1 of 2 ...
[08:26:22.874]  - Finding globals in 'X' for chunk #1 ...
[08:26:22.874] getGlobalsAndPackages() ...
[08:26:22.874] Searching for globals...
[08:26:22.874] 
[08:26:22.874] Searching for globals ... DONE
[08:26:22.874] - globals: [0] <none>
[08:26:22.874] getGlobalsAndPackages() ... DONE
[08:26:22.875]    + additional globals found: [n=0] 
[08:26:22.875]    + additional namespaces needed: [n=0] 
[08:26:22.875]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:22.875]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:22.875]  - seeds: <none>
[08:26:22.875]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:22.875] getGlobalsAndPackages() ...
[08:26:22.875] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:22.875] Resolving globals: FALSE
[08:26:22.875] Tweak future expression to call with '...' arguments ...
[08:26:22.875] {
[08:26:22.875]     do.call(function(...) {
[08:26:22.875]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:22.875]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:22.875]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:22.875]             on.exit(options(oopts), add = TRUE)
[08:26:22.875]         }
[08:26:22.875]         {
[08:26:22.875]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:22.875]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:22.875]                 ...future.FUN(...future.X_jj, ...)
[08:26:22.875]             })
[08:26:22.875]         }
[08:26:22.875]     }, args = future.call.arguments)
[08:26:22.875] }
[08:26:22.876] Tweak future expression to call with '...' arguments ... DONE
[08:26:22.876] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:22.876] - packages: [1] ‘future.apply’
[08:26:22.876] getGlobalsAndPackages() ... DONE
[08:26:22.877] run() for ‘Future’ ...
[08:26:22.877] - state: ‘created’
[08:26:22.877] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:22.892] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:22.892] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:22.892]   - Field: ‘node’
[08:26:22.892]   - Field: ‘label’
[08:26:22.892]   - Field: ‘local’
[08:26:22.893]   - Field: ‘owner’
[08:26:22.893]   - Field: ‘envir’
[08:26:22.893]   - Field: ‘workers’
[08:26:22.893]   - Field: ‘packages’
[08:26:22.893]   - Field: ‘gc’
[08:26:22.893]   - Field: ‘conditions’
[08:26:22.893]   - Field: ‘persistent’
[08:26:22.893]   - Field: ‘expr’
[08:26:22.893]   - Field: ‘uuid’
[08:26:22.893]   - Field: ‘seed’
[08:26:22.893]   - Field: ‘version’
[08:26:22.894]   - Field: ‘result’
[08:26:22.894]   - Field: ‘asynchronous’
[08:26:22.894]   - Field: ‘calls’
[08:26:22.894]   - Field: ‘globals’
[08:26:22.894]   - Field: ‘stdout’
[08:26:22.894]   - Field: ‘earlySignal’
[08:26:22.894]   - Field: ‘lazy’
[08:26:22.894]   - Field: ‘state’
[08:26:22.894] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:22.894] - Launch lazy future ...
[08:26:22.895] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:22.895] Packages needed by future strategies (n = 0): <none>
[08:26:22.895] {
[08:26:22.895]     {
[08:26:22.895]         {
[08:26:22.895]             ...future.startTime <- base::Sys.time()
[08:26:22.895]             {
[08:26:22.895]                 {
[08:26:22.895]                   {
[08:26:22.895]                     {
[08:26:22.895]                       {
[08:26:22.895]                         base::local({
[08:26:22.895]                           has_future <- base::requireNamespace("future", 
[08:26:22.895]                             quietly = TRUE)
[08:26:22.895]                           if (has_future) {
[08:26:22.895]                             ns <- base::getNamespace("future")
[08:26:22.895]                             version <- ns[[".package"]][["version"]]
[08:26:22.895]                             if (is.null(version)) 
[08:26:22.895]                               version <- utils::packageVersion("future")
[08:26:22.895]                           }
[08:26:22.895]                           else {
[08:26:22.895]                             version <- NULL
[08:26:22.895]                           }
[08:26:22.895]                           if (!has_future || version < "1.8.0") {
[08:26:22.895]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:22.895]                               "", base::R.version$version.string), 
[08:26:22.895]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:22.895]                                 base::R.version$platform, 8 * 
[08:26:22.895]                                   base::.Machine$sizeof.pointer), 
[08:26:22.895]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:22.895]                                 "release", "version")], collapse = " "), 
[08:26:22.895]                               hostname = base::Sys.info()[["nodename"]])
[08:26:22.895]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:22.895]                               info)
[08:26:22.895]                             info <- base::paste(info, collapse = "; ")
[08:26:22.895]                             if (!has_future) {
[08:26:22.895]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:22.895]                                 info)
[08:26:22.895]                             }
[08:26:22.895]                             else {
[08:26:22.895]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:22.895]                                 info, version)
[08:26:22.895]                             }
[08:26:22.895]                             base::stop(msg)
[08:26:22.895]                           }
[08:26:22.895]                         })
[08:26:22.895]                       }
[08:26:22.895]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:22.895]                       base::options(mc.cores = 1L)
[08:26:22.895]                     }
[08:26:22.895]                     base::local({
[08:26:22.895]                       for (pkg in "future.apply") {
[08:26:22.895]                         base::loadNamespace(pkg)
[08:26:22.895]                         base::library(pkg, character.only = TRUE)
[08:26:22.895]                       }
[08:26:22.895]                     })
[08:26:22.895]                   }
[08:26:22.895]                   ...future.strategy.old <- future::plan("list")
[08:26:22.895]                   options(future.plan = NULL)
[08:26:22.895]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:22.895]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:22.895]                 }
[08:26:22.895]                 ...future.workdir <- getwd()
[08:26:22.895]             }
[08:26:22.895]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:22.895]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:22.895]         }
[08:26:22.895]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:22.895]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:22.895]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:22.895]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:22.895]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:22.895]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:22.895]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:22.895]             base::names(...future.oldOptions))
[08:26:22.895]     }
[08:26:22.895]     if (FALSE) {
[08:26:22.895]     }
[08:26:22.895]     else {
[08:26:22.895]         if (TRUE) {
[08:26:22.895]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:22.895]                 open = "w")
[08:26:22.895]         }
[08:26:22.895]         else {
[08:26:22.895]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:22.895]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:22.895]         }
[08:26:22.895]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:22.895]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:22.895]             base::sink(type = "output", split = FALSE)
[08:26:22.895]             base::close(...future.stdout)
[08:26:22.895]         }, add = TRUE)
[08:26:22.895]     }
[08:26:22.895]     ...future.frame <- base::sys.nframe()
[08:26:22.895]     ...future.conditions <- base::list()
[08:26:22.895]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:22.895]     if (FALSE) {
[08:26:22.895]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:22.895]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:22.895]     }
[08:26:22.895]     ...future.result <- base::tryCatch({
[08:26:22.895]         base::withCallingHandlers({
[08:26:22.895]             ...future.value <- base::withVisible(base::local({
[08:26:22.895]                 ...future.makeSendCondition <- base::local({
[08:26:22.895]                   sendCondition <- NULL
[08:26:22.895]                   function(frame = 1L) {
[08:26:22.895]                     if (is.function(sendCondition)) 
[08:26:22.895]                       return(sendCondition)
[08:26:22.895]                     ns <- getNamespace("parallel")
[08:26:22.895]                     if (exists("sendData", mode = "function", 
[08:26:22.895]                       envir = ns)) {
[08:26:22.895]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:22.895]                         envir = ns)
[08:26:22.895]                       envir <- sys.frame(frame)
[08:26:22.895]                       master <- NULL
[08:26:22.895]                       while (!identical(envir, .GlobalEnv) && 
[08:26:22.895]                         !identical(envir, emptyenv())) {
[08:26:22.895]                         if (exists("master", mode = "list", envir = envir, 
[08:26:22.895]                           inherits = FALSE)) {
[08:26:22.895]                           master <- get("master", mode = "list", 
[08:26:22.895]                             envir = envir, inherits = FALSE)
[08:26:22.895]                           if (inherits(master, c("SOCKnode", 
[08:26:22.895]                             "SOCK0node"))) {
[08:26:22.895]                             sendCondition <<- function(cond) {
[08:26:22.895]                               data <- list(type = "VALUE", value = cond, 
[08:26:22.895]                                 success = TRUE)
[08:26:22.895]                               parallel_sendData(master, data)
[08:26:22.895]                             }
[08:26:22.895]                             return(sendCondition)
[08:26:22.895]                           }
[08:26:22.895]                         }
[08:26:22.895]                         frame <- frame + 1L
[08:26:22.895]                         envir <- sys.frame(frame)
[08:26:22.895]                       }
[08:26:22.895]                     }
[08:26:22.895]                     sendCondition <<- function(cond) NULL
[08:26:22.895]                   }
[08:26:22.895]                 })
[08:26:22.895]                 withCallingHandlers({
[08:26:22.895]                   {
[08:26:22.895]                     do.call(function(...) {
[08:26:22.895]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:22.895]                       if (!identical(...future.globals.maxSize.org, 
[08:26:22.895]                         ...future.globals.maxSize)) {
[08:26:22.895]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:22.895]                         on.exit(options(oopts), add = TRUE)
[08:26:22.895]                       }
[08:26:22.895]                       {
[08:26:22.895]                         lapply(seq_along(...future.elements_ii), 
[08:26:22.895]                           FUN = function(jj) {
[08:26:22.895]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:22.895]                             ...future.FUN(...future.X_jj, ...)
[08:26:22.895]                           })
[08:26:22.895]                       }
[08:26:22.895]                     }, args = future.call.arguments)
[08:26:22.895]                   }
[08:26:22.895]                 }, immediateCondition = function(cond) {
[08:26:22.895]                   sendCondition <- ...future.makeSendCondition()
[08:26:22.895]                   sendCondition(cond)
[08:26:22.895]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:22.895]                   {
[08:26:22.895]                     inherits <- base::inherits
[08:26:22.895]                     invokeRestart <- base::invokeRestart
[08:26:22.895]                     is.null <- base::is.null
[08:26:22.895]                     muffled <- FALSE
[08:26:22.895]                     if (inherits(cond, "message")) {
[08:26:22.895]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:22.895]                       if (muffled) 
[08:26:22.895]                         invokeRestart("muffleMessage")
[08:26:22.895]                     }
[08:26:22.895]                     else if (inherits(cond, "warning")) {
[08:26:22.895]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:22.895]                       if (muffled) 
[08:26:22.895]                         invokeRestart("muffleWarning")
[08:26:22.895]                     }
[08:26:22.895]                     else if (inherits(cond, "condition")) {
[08:26:22.895]                       if (!is.null(pattern)) {
[08:26:22.895]                         computeRestarts <- base::computeRestarts
[08:26:22.895]                         grepl <- base::grepl
[08:26:22.895]                         restarts <- computeRestarts(cond)
[08:26:22.895]                         for (restart in restarts) {
[08:26:22.895]                           name <- restart$name
[08:26:22.895]                           if (is.null(name)) 
[08:26:22.895]                             next
[08:26:22.895]                           if (!grepl(pattern, name)) 
[08:26:22.895]                             next
[08:26:22.895]                           invokeRestart(restart)
[08:26:22.895]                           muffled <- TRUE
[08:26:22.895]                           break
[08:26:22.895]                         }
[08:26:22.895]                       }
[08:26:22.895]                     }
[08:26:22.895]                     invisible(muffled)
[08:26:22.895]                   }
[08:26:22.895]                   muffleCondition(cond)
[08:26:22.895]                 })
[08:26:22.895]             }))
[08:26:22.895]             future::FutureResult(value = ...future.value$value, 
[08:26:22.895]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:22.895]                   ...future.rng), globalenv = if (FALSE) 
[08:26:22.895]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:22.895]                     ...future.globalenv.names))
[08:26:22.895]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:22.895]         }, condition = base::local({
[08:26:22.895]             c <- base::c
[08:26:22.895]             inherits <- base::inherits
[08:26:22.895]             invokeRestart <- base::invokeRestart
[08:26:22.895]             length <- base::length
[08:26:22.895]             list <- base::list
[08:26:22.895]             seq.int <- base::seq.int
[08:26:22.895]             signalCondition <- base::signalCondition
[08:26:22.895]             sys.calls <- base::sys.calls
[08:26:22.895]             `[[` <- base::`[[`
[08:26:22.895]             `+` <- base::`+`
[08:26:22.895]             `<<-` <- base::`<<-`
[08:26:22.895]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:22.895]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:22.895]                   3L)]
[08:26:22.895]             }
[08:26:22.895]             function(cond) {
[08:26:22.895]                 is_error <- inherits(cond, "error")
[08:26:22.895]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:22.895]                   NULL)
[08:26:22.895]                 if (is_error) {
[08:26:22.895]                   sessionInformation <- function() {
[08:26:22.895]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:22.895]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:22.895]                       search = base::search(), system = base::Sys.info())
[08:26:22.895]                   }
[08:26:22.895]                   ...future.conditions[[length(...future.conditions) + 
[08:26:22.895]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:22.895]                     cond$call), session = sessionInformation(), 
[08:26:22.895]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:22.895]                   signalCondition(cond)
[08:26:22.895]                 }
[08:26:22.895]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:22.895]                 "immediateCondition"))) {
[08:26:22.895]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:22.895]                   ...future.conditions[[length(...future.conditions) + 
[08:26:22.895]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:22.895]                   if (TRUE && !signal) {
[08:26:22.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:22.895]                     {
[08:26:22.895]                       inherits <- base::inherits
[08:26:22.895]                       invokeRestart <- base::invokeRestart
[08:26:22.895]                       is.null <- base::is.null
[08:26:22.895]                       muffled <- FALSE
[08:26:22.895]                       if (inherits(cond, "message")) {
[08:26:22.895]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:22.895]                         if (muffled) 
[08:26:22.895]                           invokeRestart("muffleMessage")
[08:26:22.895]                       }
[08:26:22.895]                       else if (inherits(cond, "warning")) {
[08:26:22.895]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:22.895]                         if (muffled) 
[08:26:22.895]                           invokeRestart("muffleWarning")
[08:26:22.895]                       }
[08:26:22.895]                       else if (inherits(cond, "condition")) {
[08:26:22.895]                         if (!is.null(pattern)) {
[08:26:22.895]                           computeRestarts <- base::computeRestarts
[08:26:22.895]                           grepl <- base::grepl
[08:26:22.895]                           restarts <- computeRestarts(cond)
[08:26:22.895]                           for (restart in restarts) {
[08:26:22.895]                             name <- restart$name
[08:26:22.895]                             if (is.null(name)) 
[08:26:22.895]                               next
[08:26:22.895]                             if (!grepl(pattern, name)) 
[08:26:22.895]                               next
[08:26:22.895]                             invokeRestart(restart)
[08:26:22.895]                             muffled <- TRUE
[08:26:22.895]                             break
[08:26:22.895]                           }
[08:26:22.895]                         }
[08:26:22.895]                       }
[08:26:22.895]                       invisible(muffled)
[08:26:22.895]                     }
[08:26:22.895]                     muffleCondition(cond, pattern = "^muffle")
[08:26:22.895]                   }
[08:26:22.895]                 }
[08:26:22.895]                 else {
[08:26:22.895]                   if (TRUE) {
[08:26:22.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:22.895]                     {
[08:26:22.895]                       inherits <- base::inherits
[08:26:22.895]                       invokeRestart <- base::invokeRestart
[08:26:22.895]                       is.null <- base::is.null
[08:26:22.895]                       muffled <- FALSE
[08:26:22.895]                       if (inherits(cond, "message")) {
[08:26:22.895]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:22.895]                         if (muffled) 
[08:26:22.895]                           invokeRestart("muffleMessage")
[08:26:22.895]                       }
[08:26:22.895]                       else if (inherits(cond, "warning")) {
[08:26:22.895]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:22.895]                         if (muffled) 
[08:26:22.895]                           invokeRestart("muffleWarning")
[08:26:22.895]                       }
[08:26:22.895]                       else if (inherits(cond, "condition")) {
[08:26:22.895]                         if (!is.null(pattern)) {
[08:26:22.895]                           computeRestarts <- base::computeRestarts
[08:26:22.895]                           grepl <- base::grepl
[08:26:22.895]                           restarts <- computeRestarts(cond)
[08:26:22.895]                           for (restart in restarts) {
[08:26:22.895]                             name <- restart$name
[08:26:22.895]                             if (is.null(name)) 
[08:26:22.895]                               next
[08:26:22.895]                             if (!grepl(pattern, name)) 
[08:26:22.895]                               next
[08:26:22.895]                             invokeRestart(restart)
[08:26:22.895]                             muffled <- TRUE
[08:26:22.895]                             break
[08:26:22.895]                           }
[08:26:22.895]                         }
[08:26:22.895]                       }
[08:26:22.895]                       invisible(muffled)
[08:26:22.895]                     }
[08:26:22.895]                     muffleCondition(cond, pattern = "^muffle")
[08:26:22.895]                   }
[08:26:22.895]                 }
[08:26:22.895]             }
[08:26:22.895]         }))
[08:26:22.895]     }, error = function(ex) {
[08:26:22.895]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:22.895]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:22.895]                 ...future.rng), started = ...future.startTime, 
[08:26:22.895]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:22.895]             version = "1.8"), class = "FutureResult")
[08:26:22.895]     }, finally = {
[08:26:22.895]         if (!identical(...future.workdir, getwd())) 
[08:26:22.895]             setwd(...future.workdir)
[08:26:22.895]         {
[08:26:22.895]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:22.895]                 ...future.oldOptions$nwarnings <- NULL
[08:26:22.895]             }
[08:26:22.895]             base::options(...future.oldOptions)
[08:26:22.895]             if (.Platform$OS.type == "windows") {
[08:26:22.895]                 old_names <- names(...future.oldEnvVars)
[08:26:22.895]                 envs <- base::Sys.getenv()
[08:26:22.895]                 names <- names(envs)
[08:26:22.895]                 common <- intersect(names, old_names)
[08:26:22.895]                 added <- setdiff(names, old_names)
[08:26:22.895]                 removed <- setdiff(old_names, names)
[08:26:22.895]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:22.895]                   envs[common]]
[08:26:22.895]                 NAMES <- toupper(changed)
[08:26:22.895]                 args <- list()
[08:26:22.895]                 for (kk in seq_along(NAMES)) {
[08:26:22.895]                   name <- changed[[kk]]
[08:26:22.895]                   NAME <- NAMES[[kk]]
[08:26:22.895]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:22.895]                     next
[08:26:22.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:22.895]                 }
[08:26:22.895]                 NAMES <- toupper(added)
[08:26:22.895]                 for (kk in seq_along(NAMES)) {
[08:26:22.895]                   name <- added[[kk]]
[08:26:22.895]                   NAME <- NAMES[[kk]]
[08:26:22.895]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:22.895]                     next
[08:26:22.895]                   args[[name]] <- ""
[08:26:22.895]                 }
[08:26:22.895]                 NAMES <- toupper(removed)
[08:26:22.895]                 for (kk in seq_along(NAMES)) {
[08:26:22.895]                   name <- removed[[kk]]
[08:26:22.895]                   NAME <- NAMES[[kk]]
[08:26:22.895]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:22.895]                     next
[08:26:22.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:22.895]                 }
[08:26:22.895]                 if (length(args) > 0) 
[08:26:22.895]                   base::do.call(base::Sys.setenv, args = args)
[08:26:22.895]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:22.895]             }
[08:26:22.895]             else {
[08:26:22.895]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:22.895]             }
[08:26:22.895]             {
[08:26:22.895]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:22.895]                   0L) {
[08:26:22.895]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:22.895]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:22.895]                   base::options(opts)
[08:26:22.895]                 }
[08:26:22.895]                 {
[08:26:22.895]                   {
[08:26:22.895]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:22.895]                     NULL
[08:26:22.895]                   }
[08:26:22.895]                   options(future.plan = NULL)
[08:26:22.895]                   if (is.na(NA_character_)) 
[08:26:22.895]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:22.895]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:22.895]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:22.895]                     .init = FALSE)
[08:26:22.895]                 }
[08:26:22.895]             }
[08:26:22.895]         }
[08:26:22.895]     })
[08:26:22.895]     if (TRUE) {
[08:26:22.895]         base::sink(type = "output", split = FALSE)
[08:26:22.895]         if (TRUE) {
[08:26:22.895]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:22.895]         }
[08:26:22.895]         else {
[08:26:22.895]             ...future.result["stdout"] <- base::list(NULL)
[08:26:22.895]         }
[08:26:22.895]         base::close(...future.stdout)
[08:26:22.895]         ...future.stdout <- NULL
[08:26:22.895]     }
[08:26:22.895]     ...future.result$conditions <- ...future.conditions
[08:26:22.895]     ...future.result$finished <- base::Sys.time()
[08:26:22.895]     ...future.result
[08:26:22.895] }
[08:26:22.898] Exporting 11 global objects (13.22 KiB) to cluster node #1 ...
[08:26:22.898] Exporting ‘...future.FUN’ (4.50 KiB) to cluster node #1 ...
[08:26:22.940] Exporting ‘...future.FUN’ (4.50 KiB) to cluster node #1 ... DONE
[08:26:22.940] Exporting ‘x_FUN’ (295 bytes) to cluster node #1 ...
[08:26:22.940] Exporting ‘x_FUN’ (295 bytes) to cluster node #1 ... DONE
[08:26:22.941] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[08:26:22.941] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[08:26:22.941] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[08:26:22.983] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[08:26:22.983] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[08:26:23.025] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[08:26:23.025] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[08:26:23.025] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[08:26:23.025] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[08:26:23.026] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[08:26:23.026] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:26:23.026] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:26:23.026] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ...
[08:26:23.027] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ... DONE
[08:26:23.027] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:26:23.027] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:26:23.027] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:26:23.028] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:26:23.028] Exporting 11 global objects (13.22 KiB) to cluster node #1 ... DONE
[08:26:23.028] MultisessionFuture started
[08:26:23.029] - Launch lazy future ... done
[08:26:23.029] run() for ‘MultisessionFuture’ ... done
[08:26:23.029] Created future:
[08:26:23.029] MultisessionFuture:
[08:26:23.029] Label: ‘future_vapply-1’
[08:26:23.029] Expression:
[08:26:23.029] {
[08:26:23.029]     do.call(function(...) {
[08:26:23.029]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:23.029]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:23.029]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:23.029]             on.exit(options(oopts), add = TRUE)
[08:26:23.029]         }
[08:26:23.029]         {
[08:26:23.029]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:23.029]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:23.029]                 ...future.FUN(...future.X_jj, ...)
[08:26:23.029]             })
[08:26:23.029]         }
[08:26:23.029]     }, args = future.call.arguments)
[08:26:23.029] }
[08:26:23.029] Lazy evaluation: FALSE
[08:26:23.029] Asynchronous evaluation: TRUE
[08:26:23.029] Local evaluation: TRUE
[08:26:23.029] Environment: R_GlobalEnv
[08:26:23.029] Capture standard output: TRUE
[08:26:23.029] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:23.029] Globals: 11 objects totaling 13.01 KiB (function ‘...future.FUN’ of 4.50 KiB, function ‘x_FUN’ of 295 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:23.029] Packages: 1 packages (‘future.apply’)
[08:26:23.029] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:23.029] Resolved: FALSE
[08:26:23.029] Value: <not collected>
[08:26:23.029] Conditions captured: <none>
[08:26:23.029] Early signaling: FALSE
[08:26:23.029] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:23.029] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:23.041] Chunk #1 of 2 ... DONE
[08:26:23.041] Chunk #2 of 2 ...
[08:26:23.041]  - Finding globals in 'X' for chunk #2 ...
[08:26:23.041] getGlobalsAndPackages() ...
[08:26:23.041] Searching for globals...
[08:26:23.041] 
[08:26:23.042] Searching for globals ... DONE
[08:26:23.042] - globals: [0] <none>
[08:26:23.042] getGlobalsAndPackages() ... DONE
[08:26:23.042]    + additional globals found: [n=0] 
[08:26:23.042]    + additional namespaces needed: [n=0] 
[08:26:23.042]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:23.042]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:23.042]  - seeds: <none>
[08:26:23.042]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:23.042] getGlobalsAndPackages() ...
[08:26:23.042] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:23.043] Resolving globals: FALSE
[08:26:23.043] Tweak future expression to call with '...' arguments ...
[08:26:23.043] {
[08:26:23.043]     do.call(function(...) {
[08:26:23.043]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:23.043]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:23.043]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:23.043]             on.exit(options(oopts), add = TRUE)
[08:26:23.043]         }
[08:26:23.043]         {
[08:26:23.043]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:23.043]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:23.043]                 ...future.FUN(...future.X_jj, ...)
[08:26:23.043]             })
[08:26:23.043]         }
[08:26:23.043]     }, args = future.call.arguments)
[08:26:23.043] }
[08:26:23.043] Tweak future expression to call with '...' arguments ... DONE
[08:26:23.044] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:23.044] - packages: [1] ‘future.apply’
[08:26:23.044] getGlobalsAndPackages() ... DONE
[08:26:23.044] run() for ‘Future’ ...
[08:26:23.044] - state: ‘created’
[08:26:23.044] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:23.059] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:23.059] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:23.059]   - Field: ‘node’
[08:26:23.060]   - Field: ‘label’
[08:26:23.060]   - Field: ‘local’
[08:26:23.060]   - Field: ‘owner’
[08:26:23.060]   - Field: ‘envir’
[08:26:23.060]   - Field: ‘workers’
[08:26:23.060]   - Field: ‘packages’
[08:26:23.060]   - Field: ‘gc’
[08:26:23.060]   - Field: ‘conditions’
[08:26:23.060]   - Field: ‘persistent’
[08:26:23.060]   - Field: ‘expr’
[08:26:23.061]   - Field: ‘uuid’
[08:26:23.061]   - Field: ‘seed’
[08:26:23.061]   - Field: ‘version’
[08:26:23.061]   - Field: ‘result’
[08:26:23.061]   - Field: ‘asynchronous’
[08:26:23.061]   - Field: ‘calls’
[08:26:23.061]   - Field: ‘globals’
[08:26:23.061]   - Field: ‘stdout’
[08:26:23.061]   - Field: ‘earlySignal’
[08:26:23.061]   - Field: ‘lazy’
[08:26:23.061]   - Field: ‘state’
[08:26:23.061] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:23.062] - Launch lazy future ...
[08:26:23.062] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:23.062] Packages needed by future strategies (n = 0): <none>
[08:26:23.063] {
[08:26:23.063]     {
[08:26:23.063]         {
[08:26:23.063]             ...future.startTime <- base::Sys.time()
[08:26:23.063]             {
[08:26:23.063]                 {
[08:26:23.063]                   {
[08:26:23.063]                     {
[08:26:23.063]                       {
[08:26:23.063]                         base::local({
[08:26:23.063]                           has_future <- base::requireNamespace("future", 
[08:26:23.063]                             quietly = TRUE)
[08:26:23.063]                           if (has_future) {
[08:26:23.063]                             ns <- base::getNamespace("future")
[08:26:23.063]                             version <- ns[[".package"]][["version"]]
[08:26:23.063]                             if (is.null(version)) 
[08:26:23.063]                               version <- utils::packageVersion("future")
[08:26:23.063]                           }
[08:26:23.063]                           else {
[08:26:23.063]                             version <- NULL
[08:26:23.063]                           }
[08:26:23.063]                           if (!has_future || version < "1.8.0") {
[08:26:23.063]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:23.063]                               "", base::R.version$version.string), 
[08:26:23.063]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:23.063]                                 base::R.version$platform, 8 * 
[08:26:23.063]                                   base::.Machine$sizeof.pointer), 
[08:26:23.063]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:23.063]                                 "release", "version")], collapse = " "), 
[08:26:23.063]                               hostname = base::Sys.info()[["nodename"]])
[08:26:23.063]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:23.063]                               info)
[08:26:23.063]                             info <- base::paste(info, collapse = "; ")
[08:26:23.063]                             if (!has_future) {
[08:26:23.063]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:23.063]                                 info)
[08:26:23.063]                             }
[08:26:23.063]                             else {
[08:26:23.063]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:23.063]                                 info, version)
[08:26:23.063]                             }
[08:26:23.063]                             base::stop(msg)
[08:26:23.063]                           }
[08:26:23.063]                         })
[08:26:23.063]                       }
[08:26:23.063]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:23.063]                       base::options(mc.cores = 1L)
[08:26:23.063]                     }
[08:26:23.063]                     base::local({
[08:26:23.063]                       for (pkg in "future.apply") {
[08:26:23.063]                         base::loadNamespace(pkg)
[08:26:23.063]                         base::library(pkg, character.only = TRUE)
[08:26:23.063]                       }
[08:26:23.063]                     })
[08:26:23.063]                   }
[08:26:23.063]                   ...future.strategy.old <- future::plan("list")
[08:26:23.063]                   options(future.plan = NULL)
[08:26:23.063]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:23.063]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:23.063]                 }
[08:26:23.063]                 ...future.workdir <- getwd()
[08:26:23.063]             }
[08:26:23.063]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:23.063]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:23.063]         }
[08:26:23.063]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:23.063]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:23.063]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:23.063]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:23.063]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:23.063]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:23.063]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:23.063]             base::names(...future.oldOptions))
[08:26:23.063]     }
[08:26:23.063]     if (FALSE) {
[08:26:23.063]     }
[08:26:23.063]     else {
[08:26:23.063]         if (TRUE) {
[08:26:23.063]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:23.063]                 open = "w")
[08:26:23.063]         }
[08:26:23.063]         else {
[08:26:23.063]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:23.063]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:23.063]         }
[08:26:23.063]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:23.063]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:23.063]             base::sink(type = "output", split = FALSE)
[08:26:23.063]             base::close(...future.stdout)
[08:26:23.063]         }, add = TRUE)
[08:26:23.063]     }
[08:26:23.063]     ...future.frame <- base::sys.nframe()
[08:26:23.063]     ...future.conditions <- base::list()
[08:26:23.063]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:23.063]     if (FALSE) {
[08:26:23.063]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:23.063]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:23.063]     }
[08:26:23.063]     ...future.result <- base::tryCatch({
[08:26:23.063]         base::withCallingHandlers({
[08:26:23.063]             ...future.value <- base::withVisible(base::local({
[08:26:23.063]                 ...future.makeSendCondition <- base::local({
[08:26:23.063]                   sendCondition <- NULL
[08:26:23.063]                   function(frame = 1L) {
[08:26:23.063]                     if (is.function(sendCondition)) 
[08:26:23.063]                       return(sendCondition)
[08:26:23.063]                     ns <- getNamespace("parallel")
[08:26:23.063]                     if (exists("sendData", mode = "function", 
[08:26:23.063]                       envir = ns)) {
[08:26:23.063]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:23.063]                         envir = ns)
[08:26:23.063]                       envir <- sys.frame(frame)
[08:26:23.063]                       master <- NULL
[08:26:23.063]                       while (!identical(envir, .GlobalEnv) && 
[08:26:23.063]                         !identical(envir, emptyenv())) {
[08:26:23.063]                         if (exists("master", mode = "list", envir = envir, 
[08:26:23.063]                           inherits = FALSE)) {
[08:26:23.063]                           master <- get("master", mode = "list", 
[08:26:23.063]                             envir = envir, inherits = FALSE)
[08:26:23.063]                           if (inherits(master, c("SOCKnode", 
[08:26:23.063]                             "SOCK0node"))) {
[08:26:23.063]                             sendCondition <<- function(cond) {
[08:26:23.063]                               data <- list(type = "VALUE", value = cond, 
[08:26:23.063]                                 success = TRUE)
[08:26:23.063]                               parallel_sendData(master, data)
[08:26:23.063]                             }
[08:26:23.063]                             return(sendCondition)
[08:26:23.063]                           }
[08:26:23.063]                         }
[08:26:23.063]                         frame <- frame + 1L
[08:26:23.063]                         envir <- sys.frame(frame)
[08:26:23.063]                       }
[08:26:23.063]                     }
[08:26:23.063]                     sendCondition <<- function(cond) NULL
[08:26:23.063]                   }
[08:26:23.063]                 })
[08:26:23.063]                 withCallingHandlers({
[08:26:23.063]                   {
[08:26:23.063]                     do.call(function(...) {
[08:26:23.063]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:23.063]                       if (!identical(...future.globals.maxSize.org, 
[08:26:23.063]                         ...future.globals.maxSize)) {
[08:26:23.063]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:23.063]                         on.exit(options(oopts), add = TRUE)
[08:26:23.063]                       }
[08:26:23.063]                       {
[08:26:23.063]                         lapply(seq_along(...future.elements_ii), 
[08:26:23.063]                           FUN = function(jj) {
[08:26:23.063]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:23.063]                             ...future.FUN(...future.X_jj, ...)
[08:26:23.063]                           })
[08:26:23.063]                       }
[08:26:23.063]                     }, args = future.call.arguments)
[08:26:23.063]                   }
[08:26:23.063]                 }, immediateCondition = function(cond) {
[08:26:23.063]                   sendCondition <- ...future.makeSendCondition()
[08:26:23.063]                   sendCondition(cond)
[08:26:23.063]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:23.063]                   {
[08:26:23.063]                     inherits <- base::inherits
[08:26:23.063]                     invokeRestart <- base::invokeRestart
[08:26:23.063]                     is.null <- base::is.null
[08:26:23.063]                     muffled <- FALSE
[08:26:23.063]                     if (inherits(cond, "message")) {
[08:26:23.063]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:23.063]                       if (muffled) 
[08:26:23.063]                         invokeRestart("muffleMessage")
[08:26:23.063]                     }
[08:26:23.063]                     else if (inherits(cond, "warning")) {
[08:26:23.063]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:23.063]                       if (muffled) 
[08:26:23.063]                         invokeRestart("muffleWarning")
[08:26:23.063]                     }
[08:26:23.063]                     else if (inherits(cond, "condition")) {
[08:26:23.063]                       if (!is.null(pattern)) {
[08:26:23.063]                         computeRestarts <- base::computeRestarts
[08:26:23.063]                         grepl <- base::grepl
[08:26:23.063]                         restarts <- computeRestarts(cond)
[08:26:23.063]                         for (restart in restarts) {
[08:26:23.063]                           name <- restart$name
[08:26:23.063]                           if (is.null(name)) 
[08:26:23.063]                             next
[08:26:23.063]                           if (!grepl(pattern, name)) 
[08:26:23.063]                             next
[08:26:23.063]                           invokeRestart(restart)
[08:26:23.063]                           muffled <- TRUE
[08:26:23.063]                           break
[08:26:23.063]                         }
[08:26:23.063]                       }
[08:26:23.063]                     }
[08:26:23.063]                     invisible(muffled)
[08:26:23.063]                   }
[08:26:23.063]                   muffleCondition(cond)
[08:26:23.063]                 })
[08:26:23.063]             }))
[08:26:23.063]             future::FutureResult(value = ...future.value$value, 
[08:26:23.063]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:23.063]                   ...future.rng), globalenv = if (FALSE) 
[08:26:23.063]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:23.063]                     ...future.globalenv.names))
[08:26:23.063]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:23.063]         }, condition = base::local({
[08:26:23.063]             c <- base::c
[08:26:23.063]             inherits <- base::inherits
[08:26:23.063]             invokeRestart <- base::invokeRestart
[08:26:23.063]             length <- base::length
[08:26:23.063]             list <- base::list
[08:26:23.063]             seq.int <- base::seq.int
[08:26:23.063]             signalCondition <- base::signalCondition
[08:26:23.063]             sys.calls <- base::sys.calls
[08:26:23.063]             `[[` <- base::`[[`
[08:26:23.063]             `+` <- base::`+`
[08:26:23.063]             `<<-` <- base::`<<-`
[08:26:23.063]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:23.063]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:23.063]                   3L)]
[08:26:23.063]             }
[08:26:23.063]             function(cond) {
[08:26:23.063]                 is_error <- inherits(cond, "error")
[08:26:23.063]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:23.063]                   NULL)
[08:26:23.063]                 if (is_error) {
[08:26:23.063]                   sessionInformation <- function() {
[08:26:23.063]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:23.063]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:23.063]                       search = base::search(), system = base::Sys.info())
[08:26:23.063]                   }
[08:26:23.063]                   ...future.conditions[[length(...future.conditions) + 
[08:26:23.063]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:23.063]                     cond$call), session = sessionInformation(), 
[08:26:23.063]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:23.063]                   signalCondition(cond)
[08:26:23.063]                 }
[08:26:23.063]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:23.063]                 "immediateCondition"))) {
[08:26:23.063]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:23.063]                   ...future.conditions[[length(...future.conditions) + 
[08:26:23.063]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:23.063]                   if (TRUE && !signal) {
[08:26:23.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:23.063]                     {
[08:26:23.063]                       inherits <- base::inherits
[08:26:23.063]                       invokeRestart <- base::invokeRestart
[08:26:23.063]                       is.null <- base::is.null
[08:26:23.063]                       muffled <- FALSE
[08:26:23.063]                       if (inherits(cond, "message")) {
[08:26:23.063]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:23.063]                         if (muffled) 
[08:26:23.063]                           invokeRestart("muffleMessage")
[08:26:23.063]                       }
[08:26:23.063]                       else if (inherits(cond, "warning")) {
[08:26:23.063]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:23.063]                         if (muffled) 
[08:26:23.063]                           invokeRestart("muffleWarning")
[08:26:23.063]                       }
[08:26:23.063]                       else if (inherits(cond, "condition")) {
[08:26:23.063]                         if (!is.null(pattern)) {
[08:26:23.063]                           computeRestarts <- base::computeRestarts
[08:26:23.063]                           grepl <- base::grepl
[08:26:23.063]                           restarts <- computeRestarts(cond)
[08:26:23.063]                           for (restart in restarts) {
[08:26:23.063]                             name <- restart$name
[08:26:23.063]                             if (is.null(name)) 
[08:26:23.063]                               next
[08:26:23.063]                             if (!grepl(pattern, name)) 
[08:26:23.063]                               next
[08:26:23.063]                             invokeRestart(restart)
[08:26:23.063]                             muffled <- TRUE
[08:26:23.063]                             break
[08:26:23.063]                           }
[08:26:23.063]                         }
[08:26:23.063]                       }
[08:26:23.063]                       invisible(muffled)
[08:26:23.063]                     }
[08:26:23.063]                     muffleCondition(cond, pattern = "^muffle")
[08:26:23.063]                   }
[08:26:23.063]                 }
[08:26:23.063]                 else {
[08:26:23.063]                   if (TRUE) {
[08:26:23.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:23.063]                     {
[08:26:23.063]                       inherits <- base::inherits
[08:26:23.063]                       invokeRestart <- base::invokeRestart
[08:26:23.063]                       is.null <- base::is.null
[08:26:23.063]                       muffled <- FALSE
[08:26:23.063]                       if (inherits(cond, "message")) {
[08:26:23.063]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:23.063]                         if (muffled) 
[08:26:23.063]                           invokeRestart("muffleMessage")
[08:26:23.063]                       }
[08:26:23.063]                       else if (inherits(cond, "warning")) {
[08:26:23.063]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:23.063]                         if (muffled) 
[08:26:23.063]                           invokeRestart("muffleWarning")
[08:26:23.063]                       }
[08:26:23.063]                       else if (inherits(cond, "condition")) {
[08:26:23.063]                         if (!is.null(pattern)) {
[08:26:23.063]                           computeRestarts <- base::computeRestarts
[08:26:23.063]                           grepl <- base::grepl
[08:26:23.063]                           restarts <- computeRestarts(cond)
[08:26:23.063]                           for (restart in restarts) {
[08:26:23.063]                             name <- restart$name
[08:26:23.063]                             if (is.null(name)) 
[08:26:23.063]                               next
[08:26:23.063]                             if (!grepl(pattern, name)) 
[08:26:23.063]                               next
[08:26:23.063]                             invokeRestart(restart)
[08:26:23.063]                             muffled <- TRUE
[08:26:23.063]                             break
[08:26:23.063]                           }
[08:26:23.063]                         }
[08:26:23.063]                       }
[08:26:23.063]                       invisible(muffled)
[08:26:23.063]                     }
[08:26:23.063]                     muffleCondition(cond, pattern = "^muffle")
[08:26:23.063]                   }
[08:26:23.063]                 }
[08:26:23.063]             }
[08:26:23.063]         }))
[08:26:23.063]     }, error = function(ex) {
[08:26:23.063]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:23.063]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:23.063]                 ...future.rng), started = ...future.startTime, 
[08:26:23.063]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:23.063]             version = "1.8"), class = "FutureResult")
[08:26:23.063]     }, finally = {
[08:26:23.063]         if (!identical(...future.workdir, getwd())) 
[08:26:23.063]             setwd(...future.workdir)
[08:26:23.063]         {
[08:26:23.063]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:23.063]                 ...future.oldOptions$nwarnings <- NULL
[08:26:23.063]             }
[08:26:23.063]             base::options(...future.oldOptions)
[08:26:23.063]             if (.Platform$OS.type == "windows") {
[08:26:23.063]                 old_names <- names(...future.oldEnvVars)
[08:26:23.063]                 envs <- base::Sys.getenv()
[08:26:23.063]                 names <- names(envs)
[08:26:23.063]                 common <- intersect(names, old_names)
[08:26:23.063]                 added <- setdiff(names, old_names)
[08:26:23.063]                 removed <- setdiff(old_names, names)
[08:26:23.063]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:23.063]                   envs[common]]
[08:26:23.063]                 NAMES <- toupper(changed)
[08:26:23.063]                 args <- list()
[08:26:23.063]                 for (kk in seq_along(NAMES)) {
[08:26:23.063]                   name <- changed[[kk]]
[08:26:23.063]                   NAME <- NAMES[[kk]]
[08:26:23.063]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:23.063]                     next
[08:26:23.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:23.063]                 }
[08:26:23.063]                 NAMES <- toupper(added)
[08:26:23.063]                 for (kk in seq_along(NAMES)) {
[08:26:23.063]                   name <- added[[kk]]
[08:26:23.063]                   NAME <- NAMES[[kk]]
[08:26:23.063]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:23.063]                     next
[08:26:23.063]                   args[[name]] <- ""
[08:26:23.063]                 }
[08:26:23.063]                 NAMES <- toupper(removed)
[08:26:23.063]                 for (kk in seq_along(NAMES)) {
[08:26:23.063]                   name <- removed[[kk]]
[08:26:23.063]                   NAME <- NAMES[[kk]]
[08:26:23.063]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:23.063]                     next
[08:26:23.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:23.063]                 }
[08:26:23.063]                 if (length(args) > 0) 
[08:26:23.063]                   base::do.call(base::Sys.setenv, args = args)
[08:26:23.063]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:23.063]             }
[08:26:23.063]             else {
[08:26:23.063]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:23.063]             }
[08:26:23.063]             {
[08:26:23.063]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:23.063]                   0L) {
[08:26:23.063]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:23.063]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:23.063]                   base::options(opts)
[08:26:23.063]                 }
[08:26:23.063]                 {
[08:26:23.063]                   {
[08:26:23.063]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:23.063]                     NULL
[08:26:23.063]                   }
[08:26:23.063]                   options(future.plan = NULL)
[08:26:23.063]                   if (is.na(NA_character_)) 
[08:26:23.063]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:23.063]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:23.063]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:23.063]                     .init = FALSE)
[08:26:23.063]                 }
[08:26:23.063]             }
[08:26:23.063]         }
[08:26:23.063]     })
[08:26:23.063]     if (TRUE) {
[08:26:23.063]         base::sink(type = "output", split = FALSE)
[08:26:23.063]         if (TRUE) {
[08:26:23.063]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:23.063]         }
[08:26:23.063]         else {
[08:26:23.063]             ...future.result["stdout"] <- base::list(NULL)
[08:26:23.063]         }
[08:26:23.063]         base::close(...future.stdout)
[08:26:23.063]         ...future.stdout <- NULL
[08:26:23.063]     }
[08:26:23.063]     ...future.result$conditions <- ...future.conditions
[08:26:23.063]     ...future.result$finished <- base::Sys.time()
[08:26:23.063]     ...future.result
[08:26:23.063] }
[08:26:23.066] Exporting 11 global objects (13.22 KiB) to cluster node #2 ...
[08:26:23.066] Exporting ‘...future.FUN’ (4.50 KiB) to cluster node #2 ...
[08:26:23.107] Exporting ‘...future.FUN’ (4.50 KiB) to cluster node #2 ... DONE
[08:26:23.107] Exporting ‘x_FUN’ (295 bytes) to cluster node #2 ...
[08:26:23.107] Exporting ‘x_FUN’ (295 bytes) to cluster node #2 ... DONE
[08:26:23.108] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[08:26:23.108] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[08:26:23.108] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[08:26:23.149] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[08:26:23.150] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[08:26:23.191] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[08:26:23.191] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[08:26:23.191] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[08:26:23.191] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[08:26:23.192] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[08:26:23.192] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:26:23.192] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:26:23.192] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ...
[08:26:23.193] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ... DONE
[08:26:23.193] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:26:23.193] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:26:23.193] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:26:23.194] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:26:23.194] Exporting 11 global objects (13.22 KiB) to cluster node #2 ... DONE
[08:26:23.194] MultisessionFuture started
[08:26:23.195] - Launch lazy future ... done
[08:26:23.195] run() for ‘MultisessionFuture’ ... done
[08:26:23.195] Created future:
[08:26:23.195] MultisessionFuture:
[08:26:23.195] Label: ‘future_vapply-2’
[08:26:23.195] Expression:
[08:26:23.195] {
[08:26:23.195]     do.call(function(...) {
[08:26:23.195]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:23.195]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:23.195]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:23.195]             on.exit(options(oopts), add = TRUE)
[08:26:23.195]         }
[08:26:23.195]         {
[08:26:23.195]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:23.195]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:23.195]                 ...future.FUN(...future.X_jj, ...)
[08:26:23.195]             })
[08:26:23.195]         }
[08:26:23.195]     }, args = future.call.arguments)
[08:26:23.195] }
[08:26:23.195] Lazy evaluation: FALSE
[08:26:23.195] Asynchronous evaluation: TRUE
[08:26:23.195] Local evaluation: TRUE
[08:26:23.195] Environment: R_GlobalEnv
[08:26:23.195] Capture standard output: TRUE
[08:26:23.195] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:23.195] Globals: 11 objects totaling 13.01 KiB (function ‘...future.FUN’ of 4.50 KiB, function ‘x_FUN’ of 295 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:23.195] Packages: 1 packages (‘future.apply’)
[08:26:23.195] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:23.195] Resolved: FALSE
[08:26:23.195] Value: <not collected>
[08:26:23.195] Conditions captured: <none>
[08:26:23.195] Early signaling: FALSE
[08:26:23.195] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:23.195] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:23.206] Chunk #2 of 2 ... DONE
[08:26:23.207] Launching 2 futures (chunks) ... DONE
[08:26:23.207] Resolving 2 futures (chunks) ...
[08:26:23.207] resolve() on list ...
[08:26:23.207]  recursive: 0
[08:26:23.207]  length: 2
[08:26:23.207] 
[08:26:23.208] receiveMessageFromWorker() for ClusterFuture ...
[08:26:23.208] - Validating connection of MultisessionFuture
[08:26:23.208] - received message: FutureResult
[08:26:23.208] - Received FutureResult
[08:26:23.208] - Erased future from FutureRegistry
[08:26:23.208] result() for ClusterFuture ...
[08:26:23.208] - result already collected: FutureResult
[08:26:23.208] result() for ClusterFuture ... done
[08:26:23.208] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:23.208] Future #1
[08:26:23.209] result() for ClusterFuture ...
[08:26:23.209] - result already collected: FutureResult
[08:26:23.209] result() for ClusterFuture ... done
[08:26:23.209] result() for ClusterFuture ...
[08:26:23.209] - result already collected: FutureResult
[08:26:23.209] result() for ClusterFuture ... done
[08:26:23.209] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:26:23.209] - nx: 2
[08:26:23.209] - relay: TRUE
[08:26:23.209] - stdout: TRUE
[08:26:23.209] - signal: TRUE
[08:26:23.209] - resignal: FALSE
[08:26:23.210] - force: TRUE
[08:26:23.210] - relayed: [n=2] FALSE, FALSE
[08:26:23.210] - queued futures: [n=2] FALSE, FALSE
[08:26:23.210]  - until=1
[08:26:23.210]  - relaying element #1
[08:26:23.210] result() for ClusterFuture ...
[08:26:23.210] - result already collected: FutureResult
[08:26:23.210] result() for ClusterFuture ... done
[08:26:23.210] result() for ClusterFuture ...
[08:26:23.210] - result already collected: FutureResult
[08:26:23.210] result() for ClusterFuture ... done
[08:26:23.211] result() for ClusterFuture ...
[08:26:23.211] - result already collected: FutureResult
[08:26:23.211] result() for ClusterFuture ... done
[08:26:23.211] result() for ClusterFuture ...
[08:26:23.211] - result already collected: FutureResult
[08:26:23.211] result() for ClusterFuture ... done
[08:26:23.211] - relayed: [n=2] TRUE, FALSE
[08:26:23.211] - queued futures: [n=2] TRUE, FALSE
[08:26:23.211] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:26:23.211]  length: 1 (resolved future 1)
[08:26:23.236] receiveMessageFromWorker() for ClusterFuture ...
[08:26:23.237] - Validating connection of MultisessionFuture
[08:26:23.237] - received message: FutureResult
[08:26:23.237] - Received FutureResult
[08:26:23.237] - Erased future from FutureRegistry
[08:26:23.237] result() for ClusterFuture ...
[08:26:23.237] - result already collected: FutureResult
[08:26:23.237] result() for ClusterFuture ... done
[08:26:23.237] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:23.237] Future #2
[08:26:23.238] result() for ClusterFuture ...
[08:26:23.238] - result already collected: FutureResult
[08:26:23.238] result() for ClusterFuture ... done
[08:26:23.238] result() for ClusterFuture ...
[08:26:23.238] - result already collected: FutureResult
[08:26:23.238] result() for ClusterFuture ... done
[08:26:23.238] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:26:23.238] - nx: 2
[08:26:23.238] - relay: TRUE
[08:26:23.238] - stdout: TRUE
[08:26:23.238] - signal: TRUE
[08:26:23.238] - resignal: FALSE
[08:26:23.239] - force: TRUE
[08:26:23.239] - relayed: [n=2] TRUE, FALSE
[08:26:23.239] - queued futures: [n=2] TRUE, FALSE
[08:26:23.239]  - until=2
[08:26:23.239]  - relaying element #2
[08:26:23.239] result() for ClusterFuture ...
[08:26:23.239] - result already collected: FutureResult
[08:26:23.239] result() for ClusterFuture ... done
[08:26:23.239] result() for ClusterFuture ...
[08:26:23.239] - result already collected: FutureResult
[08:26:23.239] result() for ClusterFuture ... done
[08:26:23.240] result() for ClusterFuture ...
[08:26:23.240] - result already collected: FutureResult
[08:26:23.240] result() for ClusterFuture ... done
[08:26:23.240] result() for ClusterFuture ...
[08:26:23.240] - result already collected: FutureResult
[08:26:23.240] result() for ClusterFuture ... done
[08:26:23.240] - relayed: [n=2] TRUE, TRUE
[08:26:23.240] - queued futures: [n=2] TRUE, TRUE
[08:26:23.240] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:26:23.240]  length: 0 (resolved future 2)
[08:26:23.240] Relaying remaining futures
[08:26:23.240] signalConditionsASAP(NULL, pos=0) ...
[08:26:23.240] - nx: 2
[08:26:23.241] - relay: TRUE
[08:26:23.241] - stdout: TRUE
[08:26:23.241] - signal: TRUE
[08:26:23.241] - resignal: FALSE
[08:26:23.241] - force: TRUE
[08:26:23.241] - relayed: [n=2] TRUE, TRUE
[08:26:23.241] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:23.241] - relayed: [n=2] TRUE, TRUE
[08:26:23.241] - queued futures: [n=2] TRUE, TRUE
[08:26:23.241] signalConditionsASAP(NULL, pos=0) ... done
[08:26:23.241] resolve() on list ... DONE
[08:26:23.242] result() for ClusterFuture ...
[08:26:23.242] - result already collected: FutureResult
[08:26:23.242] result() for ClusterFuture ... done
[08:26:23.242] result() for ClusterFuture ...
[08:26:23.242] - result already collected: FutureResult
[08:26:23.242] result() for ClusterFuture ... done
[08:26:23.242] result() for ClusterFuture ...
[08:26:23.242] - result already collected: FutureResult
[08:26:23.242] result() for ClusterFuture ... done
[08:26:23.242] result() for ClusterFuture ...
[08:26:23.242] - result already collected: FutureResult
[08:26:23.242] result() for ClusterFuture ... done
[08:26:23.243]  - Number of value chunks collected: 2
[08:26:23.243] Resolving 2 futures (chunks) ... DONE
[08:26:23.243] Reducing values from 2 chunks ...
[08:26:23.243]  - Number of values collected after concatenation: 10
[08:26:23.243]  - Number of values expected: 10
[08:26:23.243] Reducing values from 2 chunks ... DONE
[08:26:23.243] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[08:26:23.244] future_lapply() ...
[08:26:23.247] Number of chunks: 2
[08:26:23.247] getGlobalsAndPackagesXApply() ...
[08:26:23.247]  - future.globals: TRUE
[08:26:23.248] getGlobalsAndPackages() ...
[08:26:23.248] Searching for globals...
[08:26:23.251] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[08:26:23.251] Searching for globals ... DONE
[08:26:23.251] Resolving globals: FALSE
[08:26:23.252] The total size of the 7 globals is 12.75 KiB (13056 bytes)
[08:26:23.252] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.50 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:23.253] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:23.253] - packages: [1] ‘future.apply’
[08:26:23.253] getGlobalsAndPackages() ... DONE
[08:26:23.253]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:23.253]  - needed namespaces: [n=1] ‘future.apply’
[08:26:23.253] Finding globals ... DONE
[08:26:23.253]  - use_args: TRUE
[08:26:23.253]  - Getting '...' globals ...
[08:26:23.254] resolve() on list ...
[08:26:23.254]  recursive: 0
[08:26:23.254]  length: 1
[08:26:23.254]  elements: ‘...’
[08:26:23.254]  length: 0 (resolved future 1)
[08:26:23.254] resolve() on list ... DONE
[08:26:23.254]    - '...' content: [n=0] 
[08:26:23.254] List of 1
[08:26:23.254]  $ ...: list()
[08:26:23.254]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:23.254]  - attr(*, "where")=List of 1
[08:26:23.254]   ..$ ...:<environment: 0x562ca9f0bfe8> 
[08:26:23.254]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:23.254]  - attr(*, "resolved")= logi TRUE
[08:26:23.254]  - attr(*, "total_size")= num NA
[08:26:23.257]  - Getting '...' globals ... DONE
[08:26:23.257] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:23.257] List of 8
[08:26:23.257]  $ ...future.FUN:function (x, ...)  
[08:26:23.257]  $ x_FUN        :function (x)  
[08:26:23.257]  $ times        : int 0
[08:26:23.257]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:23.257]  $ stop_if_not  :function (...)  
[08:26:23.257]  $ dim          : NULL
[08:26:23.257]  $ valid_types  : chr [1:2] "logical" "integer"
[08:26:23.257]  $ ...          : list()
[08:26:23.257]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:23.257]  - attr(*, "where")=List of 8
[08:26:23.257]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:23.257]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:23.257]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:23.257]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:23.257]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:23.257]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:23.257]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:23.257]   ..$ ...          :<environment: 0x562ca9f0bfe8> 
[08:26:23.257]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:23.257]  - attr(*, "resolved")= logi FALSE
[08:26:23.257]  - attr(*, "total_size")= num 23453
[08:26:23.262] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:23.262] getGlobalsAndPackagesXApply() ... DONE
[08:26:23.262] Number of futures (= number of chunks): 2
[08:26:23.262] Launching 2 futures (chunks) ...
[08:26:23.263] Chunk #1 of 2 ...
[08:26:23.263]  - Finding globals in 'X' for chunk #1 ...
[08:26:23.263] getGlobalsAndPackages() ...
[08:26:23.263] Searching for globals...
[08:26:23.263] 
[08:26:23.263] Searching for globals ... DONE
[08:26:23.263] - globals: [0] <none>
[08:26:23.263] getGlobalsAndPackages() ... DONE
[08:26:23.263]    + additional globals found: [n=0] 
[08:26:23.264]    + additional namespaces needed: [n=0] 
[08:26:23.264]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:23.264]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:23.264]  - seeds: <none>
[08:26:23.264]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:23.264] getGlobalsAndPackages() ...
[08:26:23.264] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:23.264] Resolving globals: FALSE
[08:26:23.264] Tweak future expression to call with '...' arguments ...
[08:26:23.264] {
[08:26:23.264]     do.call(function(...) {
[08:26:23.264]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:23.264]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:23.264]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:23.264]             on.exit(options(oopts), add = TRUE)
[08:26:23.264]         }
[08:26:23.264]         {
[08:26:23.264]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:23.264]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:23.264]                 ...future.FUN(...future.X_jj, ...)
[08:26:23.264]             })
[08:26:23.264]         }
[08:26:23.264]     }, args = future.call.arguments)
[08:26:23.264] }
[08:26:23.265] Tweak future expression to call with '...' arguments ... DONE
[08:26:23.265] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:23.265] - packages: [1] ‘future.apply’
[08:26:23.265] getGlobalsAndPackages() ... DONE
[08:26:23.266] run() for ‘Future’ ...
[08:26:23.266] - state: ‘created’
[08:26:23.266] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:23.280] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:23.280] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:23.281]   - Field: ‘node’
[08:26:23.281]   - Field: ‘label’
[08:26:23.281]   - Field: ‘local’
[08:26:23.281]   - Field: ‘owner’
[08:26:23.281]   - Field: ‘envir’
[08:26:23.281]   - Field: ‘workers’
[08:26:23.281]   - Field: ‘packages’
[08:26:23.281]   - Field: ‘gc’
[08:26:23.281]   - Field: ‘conditions’
[08:26:23.281]   - Field: ‘persistent’
[08:26:23.281]   - Field: ‘expr’
[08:26:23.281]   - Field: ‘uuid’
[08:26:23.282]   - Field: ‘seed’
[08:26:23.282]   - Field: ‘version’
[08:26:23.282]   - Field: ‘result’
[08:26:23.282]   - Field: ‘asynchronous’
[08:26:23.282]   - Field: ‘calls’
[08:26:23.282]   - Field: ‘globals’
[08:26:23.282]   - Field: ‘stdout’
[08:26:23.282]   - Field: ‘earlySignal’
[08:26:23.282]   - Field: ‘lazy’
[08:26:23.282]   - Field: ‘state’
[08:26:23.282] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:23.282] - Launch lazy future ...
[08:26:23.283] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:23.283] Packages needed by future strategies (n = 0): <none>
[08:26:23.283] {
[08:26:23.283]     {
[08:26:23.283]         {
[08:26:23.283]             ...future.startTime <- base::Sys.time()
[08:26:23.283]             {
[08:26:23.283]                 {
[08:26:23.283]                   {
[08:26:23.283]                     {
[08:26:23.283]                       {
[08:26:23.283]                         base::local({
[08:26:23.283]                           has_future <- base::requireNamespace("future", 
[08:26:23.283]                             quietly = TRUE)
[08:26:23.283]                           if (has_future) {
[08:26:23.283]                             ns <- base::getNamespace("future")
[08:26:23.283]                             version <- ns[[".package"]][["version"]]
[08:26:23.283]                             if (is.null(version)) 
[08:26:23.283]                               version <- utils::packageVersion("future")
[08:26:23.283]                           }
[08:26:23.283]                           else {
[08:26:23.283]                             version <- NULL
[08:26:23.283]                           }
[08:26:23.283]                           if (!has_future || version < "1.8.0") {
[08:26:23.283]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:23.283]                               "", base::R.version$version.string), 
[08:26:23.283]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:23.283]                                 base::R.version$platform, 8 * 
[08:26:23.283]                                   base::.Machine$sizeof.pointer), 
[08:26:23.283]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:23.283]                                 "release", "version")], collapse = " "), 
[08:26:23.283]                               hostname = base::Sys.info()[["nodename"]])
[08:26:23.283]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:23.283]                               info)
[08:26:23.283]                             info <- base::paste(info, collapse = "; ")
[08:26:23.283]                             if (!has_future) {
[08:26:23.283]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:23.283]                                 info)
[08:26:23.283]                             }
[08:26:23.283]                             else {
[08:26:23.283]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:23.283]                                 info, version)
[08:26:23.283]                             }
[08:26:23.283]                             base::stop(msg)
[08:26:23.283]                           }
[08:26:23.283]                         })
[08:26:23.283]                       }
[08:26:23.283]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:23.283]                       base::options(mc.cores = 1L)
[08:26:23.283]                     }
[08:26:23.283]                     base::local({
[08:26:23.283]                       for (pkg in "future.apply") {
[08:26:23.283]                         base::loadNamespace(pkg)
[08:26:23.283]                         base::library(pkg, character.only = TRUE)
[08:26:23.283]                       }
[08:26:23.283]                     })
[08:26:23.283]                   }
[08:26:23.283]                   ...future.strategy.old <- future::plan("list")
[08:26:23.283]                   options(future.plan = NULL)
[08:26:23.283]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:23.283]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:23.283]                 }
[08:26:23.283]                 ...future.workdir <- getwd()
[08:26:23.283]             }
[08:26:23.283]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:23.283]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:23.283]         }
[08:26:23.283]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:23.283]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:23.283]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:23.283]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:23.283]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:23.283]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:23.283]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:23.283]             base::names(...future.oldOptions))
[08:26:23.283]     }
[08:26:23.283]     if (FALSE) {
[08:26:23.283]     }
[08:26:23.283]     else {
[08:26:23.283]         if (TRUE) {
[08:26:23.283]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:23.283]                 open = "w")
[08:26:23.283]         }
[08:26:23.283]         else {
[08:26:23.283]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:23.283]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:23.283]         }
[08:26:23.283]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:23.283]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:23.283]             base::sink(type = "output", split = FALSE)
[08:26:23.283]             base::close(...future.stdout)
[08:26:23.283]         }, add = TRUE)
[08:26:23.283]     }
[08:26:23.283]     ...future.frame <- base::sys.nframe()
[08:26:23.283]     ...future.conditions <- base::list()
[08:26:23.283]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:23.283]     if (FALSE) {
[08:26:23.283]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:23.283]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:23.283]     }
[08:26:23.283]     ...future.result <- base::tryCatch({
[08:26:23.283]         base::withCallingHandlers({
[08:26:23.283]             ...future.value <- base::withVisible(base::local({
[08:26:23.283]                 ...future.makeSendCondition <- base::local({
[08:26:23.283]                   sendCondition <- NULL
[08:26:23.283]                   function(frame = 1L) {
[08:26:23.283]                     if (is.function(sendCondition)) 
[08:26:23.283]                       return(sendCondition)
[08:26:23.283]                     ns <- getNamespace("parallel")
[08:26:23.283]                     if (exists("sendData", mode = "function", 
[08:26:23.283]                       envir = ns)) {
[08:26:23.283]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:23.283]                         envir = ns)
[08:26:23.283]                       envir <- sys.frame(frame)
[08:26:23.283]                       master <- NULL
[08:26:23.283]                       while (!identical(envir, .GlobalEnv) && 
[08:26:23.283]                         !identical(envir, emptyenv())) {
[08:26:23.283]                         if (exists("master", mode = "list", envir = envir, 
[08:26:23.283]                           inherits = FALSE)) {
[08:26:23.283]                           master <- get("master", mode = "list", 
[08:26:23.283]                             envir = envir, inherits = FALSE)
[08:26:23.283]                           if (inherits(master, c("SOCKnode", 
[08:26:23.283]                             "SOCK0node"))) {
[08:26:23.283]                             sendCondition <<- function(cond) {
[08:26:23.283]                               data <- list(type = "VALUE", value = cond, 
[08:26:23.283]                                 success = TRUE)
[08:26:23.283]                               parallel_sendData(master, data)
[08:26:23.283]                             }
[08:26:23.283]                             return(sendCondition)
[08:26:23.283]                           }
[08:26:23.283]                         }
[08:26:23.283]                         frame <- frame + 1L
[08:26:23.283]                         envir <- sys.frame(frame)
[08:26:23.283]                       }
[08:26:23.283]                     }
[08:26:23.283]                     sendCondition <<- function(cond) NULL
[08:26:23.283]                   }
[08:26:23.283]                 })
[08:26:23.283]                 withCallingHandlers({
[08:26:23.283]                   {
[08:26:23.283]                     do.call(function(...) {
[08:26:23.283]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:23.283]                       if (!identical(...future.globals.maxSize.org, 
[08:26:23.283]                         ...future.globals.maxSize)) {
[08:26:23.283]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:23.283]                         on.exit(options(oopts), add = TRUE)
[08:26:23.283]                       }
[08:26:23.283]                       {
[08:26:23.283]                         lapply(seq_along(...future.elements_ii), 
[08:26:23.283]                           FUN = function(jj) {
[08:26:23.283]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:23.283]                             ...future.FUN(...future.X_jj, ...)
[08:26:23.283]                           })
[08:26:23.283]                       }
[08:26:23.283]                     }, args = future.call.arguments)
[08:26:23.283]                   }
[08:26:23.283]                 }, immediateCondition = function(cond) {
[08:26:23.283]                   sendCondition <- ...future.makeSendCondition()
[08:26:23.283]                   sendCondition(cond)
[08:26:23.283]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:23.283]                   {
[08:26:23.283]                     inherits <- base::inherits
[08:26:23.283]                     invokeRestart <- base::invokeRestart
[08:26:23.283]                     is.null <- base::is.null
[08:26:23.283]                     muffled <- FALSE
[08:26:23.283]                     if (inherits(cond, "message")) {
[08:26:23.283]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:23.283]                       if (muffled) 
[08:26:23.283]                         invokeRestart("muffleMessage")
[08:26:23.283]                     }
[08:26:23.283]                     else if (inherits(cond, "warning")) {
[08:26:23.283]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:23.283]                       if (muffled) 
[08:26:23.283]                         invokeRestart("muffleWarning")
[08:26:23.283]                     }
[08:26:23.283]                     else if (inherits(cond, "condition")) {
[08:26:23.283]                       if (!is.null(pattern)) {
[08:26:23.283]                         computeRestarts <- base::computeRestarts
[08:26:23.283]                         grepl <- base::grepl
[08:26:23.283]                         restarts <- computeRestarts(cond)
[08:26:23.283]                         for (restart in restarts) {
[08:26:23.283]                           name <- restart$name
[08:26:23.283]                           if (is.null(name)) 
[08:26:23.283]                             next
[08:26:23.283]                           if (!grepl(pattern, name)) 
[08:26:23.283]                             next
[08:26:23.283]                           invokeRestart(restart)
[08:26:23.283]                           muffled <- TRUE
[08:26:23.283]                           break
[08:26:23.283]                         }
[08:26:23.283]                       }
[08:26:23.283]                     }
[08:26:23.283]                     invisible(muffled)
[08:26:23.283]                   }
[08:26:23.283]                   muffleCondition(cond)
[08:26:23.283]                 })
[08:26:23.283]             }))
[08:26:23.283]             future::FutureResult(value = ...future.value$value, 
[08:26:23.283]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:23.283]                   ...future.rng), globalenv = if (FALSE) 
[08:26:23.283]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:23.283]                     ...future.globalenv.names))
[08:26:23.283]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:23.283]         }, condition = base::local({
[08:26:23.283]             c <- base::c
[08:26:23.283]             inherits <- base::inherits
[08:26:23.283]             invokeRestart <- base::invokeRestart
[08:26:23.283]             length <- base::length
[08:26:23.283]             list <- base::list
[08:26:23.283]             seq.int <- base::seq.int
[08:26:23.283]             signalCondition <- base::signalCondition
[08:26:23.283]             sys.calls <- base::sys.calls
[08:26:23.283]             `[[` <- base::`[[`
[08:26:23.283]             `+` <- base::`+`
[08:26:23.283]             `<<-` <- base::`<<-`
[08:26:23.283]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:23.283]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:23.283]                   3L)]
[08:26:23.283]             }
[08:26:23.283]             function(cond) {
[08:26:23.283]                 is_error <- inherits(cond, "error")
[08:26:23.283]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:23.283]                   NULL)
[08:26:23.283]                 if (is_error) {
[08:26:23.283]                   sessionInformation <- function() {
[08:26:23.283]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:23.283]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:23.283]                       search = base::search(), system = base::Sys.info())
[08:26:23.283]                   }
[08:26:23.283]                   ...future.conditions[[length(...future.conditions) + 
[08:26:23.283]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:23.283]                     cond$call), session = sessionInformation(), 
[08:26:23.283]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:23.283]                   signalCondition(cond)
[08:26:23.283]                 }
[08:26:23.283]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:23.283]                 "immediateCondition"))) {
[08:26:23.283]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:23.283]                   ...future.conditions[[length(...future.conditions) + 
[08:26:23.283]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:23.283]                   if (TRUE && !signal) {
[08:26:23.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:23.283]                     {
[08:26:23.283]                       inherits <- base::inherits
[08:26:23.283]                       invokeRestart <- base::invokeRestart
[08:26:23.283]                       is.null <- base::is.null
[08:26:23.283]                       muffled <- FALSE
[08:26:23.283]                       if (inherits(cond, "message")) {
[08:26:23.283]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:23.283]                         if (muffled) 
[08:26:23.283]                           invokeRestart("muffleMessage")
[08:26:23.283]                       }
[08:26:23.283]                       else if (inherits(cond, "warning")) {
[08:26:23.283]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:23.283]                         if (muffled) 
[08:26:23.283]                           invokeRestart("muffleWarning")
[08:26:23.283]                       }
[08:26:23.283]                       else if (inherits(cond, "condition")) {
[08:26:23.283]                         if (!is.null(pattern)) {
[08:26:23.283]                           computeRestarts <- base::computeRestarts
[08:26:23.283]                           grepl <- base::grepl
[08:26:23.283]                           restarts <- computeRestarts(cond)
[08:26:23.283]                           for (restart in restarts) {
[08:26:23.283]                             name <- restart$name
[08:26:23.283]                             if (is.null(name)) 
[08:26:23.283]                               next
[08:26:23.283]                             if (!grepl(pattern, name)) 
[08:26:23.283]                               next
[08:26:23.283]                             invokeRestart(restart)
[08:26:23.283]                             muffled <- TRUE
[08:26:23.283]                             break
[08:26:23.283]                           }
[08:26:23.283]                         }
[08:26:23.283]                       }
[08:26:23.283]                       invisible(muffled)
[08:26:23.283]                     }
[08:26:23.283]                     muffleCondition(cond, pattern = "^muffle")
[08:26:23.283]                   }
[08:26:23.283]                 }
[08:26:23.283]                 else {
[08:26:23.283]                   if (TRUE) {
[08:26:23.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:23.283]                     {
[08:26:23.283]                       inherits <- base::inherits
[08:26:23.283]                       invokeRestart <- base::invokeRestart
[08:26:23.283]                       is.null <- base::is.null
[08:26:23.283]                       muffled <- FALSE
[08:26:23.283]                       if (inherits(cond, "message")) {
[08:26:23.283]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:23.283]                         if (muffled) 
[08:26:23.283]                           invokeRestart("muffleMessage")
[08:26:23.283]                       }
[08:26:23.283]                       else if (inherits(cond, "warning")) {
[08:26:23.283]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:23.283]                         if (muffled) 
[08:26:23.283]                           invokeRestart("muffleWarning")
[08:26:23.283]                       }
[08:26:23.283]                       else if (inherits(cond, "condition")) {
[08:26:23.283]                         if (!is.null(pattern)) {
[08:26:23.283]                           computeRestarts <- base::computeRestarts
[08:26:23.283]                           grepl <- base::grepl
[08:26:23.283]                           restarts <- computeRestarts(cond)
[08:26:23.283]                           for (restart in restarts) {
[08:26:23.283]                             name <- restart$name
[08:26:23.283]                             if (is.null(name)) 
[08:26:23.283]                               next
[08:26:23.283]                             if (!grepl(pattern, name)) 
[08:26:23.283]                               next
[08:26:23.283]                             invokeRestart(restart)
[08:26:23.283]                             muffled <- TRUE
[08:26:23.283]                             break
[08:26:23.283]                           }
[08:26:23.283]                         }
[08:26:23.283]                       }
[08:26:23.283]                       invisible(muffled)
[08:26:23.283]                     }
[08:26:23.283]                     muffleCondition(cond, pattern = "^muffle")
[08:26:23.283]                   }
[08:26:23.283]                 }
[08:26:23.283]             }
[08:26:23.283]         }))
[08:26:23.283]     }, error = function(ex) {
[08:26:23.283]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:23.283]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:23.283]                 ...future.rng), started = ...future.startTime, 
[08:26:23.283]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:23.283]             version = "1.8"), class = "FutureResult")
[08:26:23.283]     }, finally = {
[08:26:23.283]         if (!identical(...future.workdir, getwd())) 
[08:26:23.283]             setwd(...future.workdir)
[08:26:23.283]         {
[08:26:23.283]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:23.283]                 ...future.oldOptions$nwarnings <- NULL
[08:26:23.283]             }
[08:26:23.283]             base::options(...future.oldOptions)
[08:26:23.283]             if (.Platform$OS.type == "windows") {
[08:26:23.283]                 old_names <- names(...future.oldEnvVars)
[08:26:23.283]                 envs <- base::Sys.getenv()
[08:26:23.283]                 names <- names(envs)
[08:26:23.283]                 common <- intersect(names, old_names)
[08:26:23.283]                 added <- setdiff(names, old_names)
[08:26:23.283]                 removed <- setdiff(old_names, names)
[08:26:23.283]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:23.283]                   envs[common]]
[08:26:23.283]                 NAMES <- toupper(changed)
[08:26:23.283]                 args <- list()
[08:26:23.283]                 for (kk in seq_along(NAMES)) {
[08:26:23.283]                   name <- changed[[kk]]
[08:26:23.283]                   NAME <- NAMES[[kk]]
[08:26:23.283]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:23.283]                     next
[08:26:23.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:23.283]                 }
[08:26:23.283]                 NAMES <- toupper(added)
[08:26:23.283]                 for (kk in seq_along(NAMES)) {
[08:26:23.283]                   name <- added[[kk]]
[08:26:23.283]                   NAME <- NAMES[[kk]]
[08:26:23.283]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:23.283]                     next
[08:26:23.283]                   args[[name]] <- ""
[08:26:23.283]                 }
[08:26:23.283]                 NAMES <- toupper(removed)
[08:26:23.283]                 for (kk in seq_along(NAMES)) {
[08:26:23.283]                   name <- removed[[kk]]
[08:26:23.283]                   NAME <- NAMES[[kk]]
[08:26:23.283]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:23.283]                     next
[08:26:23.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:23.283]                 }
[08:26:23.283]                 if (length(args) > 0) 
[08:26:23.283]                   base::do.call(base::Sys.setenv, args = args)
[08:26:23.283]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:23.283]             }
[08:26:23.283]             else {
[08:26:23.283]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:23.283]             }
[08:26:23.283]             {
[08:26:23.283]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:23.283]                   0L) {
[08:26:23.283]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:23.283]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:23.283]                   base::options(opts)
[08:26:23.283]                 }
[08:26:23.283]                 {
[08:26:23.283]                   {
[08:26:23.283]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:23.283]                     NULL
[08:26:23.283]                   }
[08:26:23.283]                   options(future.plan = NULL)
[08:26:23.283]                   if (is.na(NA_character_)) 
[08:26:23.283]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:23.283]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:23.283]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:23.283]                     .init = FALSE)
[08:26:23.283]                 }
[08:26:23.283]             }
[08:26:23.283]         }
[08:26:23.283]     })
[08:26:23.283]     if (TRUE) {
[08:26:23.283]         base::sink(type = "output", split = FALSE)
[08:26:23.283]         if (TRUE) {
[08:26:23.283]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:23.283]         }
[08:26:23.283]         else {
[08:26:23.283]             ...future.result["stdout"] <- base::list(NULL)
[08:26:23.283]         }
[08:26:23.283]         base::close(...future.stdout)
[08:26:23.283]         ...future.stdout <- NULL
[08:26:23.283]     }
[08:26:23.283]     ...future.result$conditions <- ...future.conditions
[08:26:23.283]     ...future.result$finished <- base::Sys.time()
[08:26:23.283]     ...future.result
[08:26:23.283] }
[08:26:23.286] Exporting 11 global objects (13.20 KiB) to cluster node #1 ...
[08:26:23.287] Exporting ‘...future.FUN’ (4.49 KiB) to cluster node #1 ...
[08:26:23.328] Exporting ‘...future.FUN’ (4.49 KiB) to cluster node #1 ... DONE
[08:26:23.328] Exporting ‘x_FUN’ (296 bytes) to cluster node #1 ...
[08:26:23.328] Exporting ‘x_FUN’ (296 bytes) to cluster node #1 ... DONE
[08:26:23.328] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[08:26:23.329] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[08:26:23.331] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[08:26:23.373] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[08:26:23.373] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[08:26:23.415] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[08:26:23.415] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[08:26:23.415] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[08:26:23.415] Exporting ‘valid_types’ (61 bytes) to cluster node #1 ...
[08:26:23.416] Exporting ‘valid_types’ (61 bytes) to cluster node #1 ... DONE
[08:26:23.416] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:26:23.416] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:26:23.416] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ...
[08:26:23.416] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ... DONE
[08:26:23.417] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:26:23.417] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:26:23.417] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:26:23.417] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:26:23.417] Exporting 11 global objects (13.20 KiB) to cluster node #1 ... DONE
[08:26:23.418] MultisessionFuture started
[08:26:23.418] - Launch lazy future ... done
[08:26:23.418] run() for ‘MultisessionFuture’ ... done
[08:26:23.418] Created future:
[08:26:23.418] MultisessionFuture:
[08:26:23.418] Label: ‘future_vapply-1’
[08:26:23.418] Expression:
[08:26:23.418] {
[08:26:23.418]     do.call(function(...) {
[08:26:23.418]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:23.418]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:23.418]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:23.418]             on.exit(options(oopts), add = TRUE)
[08:26:23.418]         }
[08:26:23.418]         {
[08:26:23.418]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:23.418]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:23.418]                 ...future.FUN(...future.X_jj, ...)
[08:26:23.418]             })
[08:26:23.418]         }
[08:26:23.418]     }, args = future.call.arguments)
[08:26:23.418] }
[08:26:23.418] Lazy evaluation: FALSE
[08:26:23.418] Asynchronous evaluation: TRUE
[08:26:23.418] Local evaluation: TRUE
[08:26:23.418] Environment: R_GlobalEnv
[08:26:23.418] Capture standard output: TRUE
[08:26:23.418] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:23.418] Globals: 11 objects totaling 12.98 KiB (function ‘...future.FUN’ of 4.49 KiB, function ‘x_FUN’ of 296 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:23.418] Packages: 1 packages (‘future.apply’)
[08:26:23.418] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:23.418] Resolved: FALSE
[08:26:23.418] Value: <not collected>
[08:26:23.418] Conditions captured: <none>
[08:26:23.418] Early signaling: FALSE
[08:26:23.418] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:23.418] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:23.430] Chunk #1 of 2 ... DONE
[08:26:23.430] Chunk #2 of 2 ...
[08:26:23.430]  - Finding globals in 'X' for chunk #2 ...
[08:26:23.430] getGlobalsAndPackages() ...
[08:26:23.430] Searching for globals...
[08:26:23.431] 
[08:26:23.431] Searching for globals ... DONE
[08:26:23.431] - globals: [0] <none>
[08:26:23.431] getGlobalsAndPackages() ... DONE
[08:26:23.431]    + additional globals found: [n=0] 
[08:26:23.431]    + additional namespaces needed: [n=0] 
[08:26:23.431]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:23.431]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:23.431]  - seeds: <none>
[08:26:23.431]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:23.432] getGlobalsAndPackages() ...
[08:26:23.432] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:23.432] Resolving globals: FALSE
[08:26:23.432] Tweak future expression to call with '...' arguments ...
[08:26:23.432] {
[08:26:23.432]     do.call(function(...) {
[08:26:23.432]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:23.432]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:23.432]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:23.432]             on.exit(options(oopts), add = TRUE)
[08:26:23.432]         }
[08:26:23.432]         {
[08:26:23.432]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:23.432]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:23.432]                 ...future.FUN(...future.X_jj, ...)
[08:26:23.432]             })
[08:26:23.432]         }
[08:26:23.432]     }, args = future.call.arguments)
[08:26:23.432] }
[08:26:23.432] Tweak future expression to call with '...' arguments ... DONE
[08:26:23.433] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:23.433] - packages: [1] ‘future.apply’
[08:26:23.433] getGlobalsAndPackages() ... DONE
[08:26:23.433] run() for ‘Future’ ...
[08:26:23.433] - state: ‘created’
[08:26:23.434] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:23.448] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:23.448] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:23.448]   - Field: ‘node’
[08:26:23.448]   - Field: ‘label’
[08:26:23.448]   - Field: ‘local’
[08:26:23.448]   - Field: ‘owner’
[08:26:23.448]   - Field: ‘envir’
[08:26:23.448]   - Field: ‘workers’
[08:26:23.448]   - Field: ‘packages’
[08:26:23.449]   - Field: ‘gc’
[08:26:23.449]   - Field: ‘conditions’
[08:26:23.449]   - Field: ‘persistent’
[08:26:23.449]   - Field: ‘expr’
[08:26:23.449]   - Field: ‘uuid’
[08:26:23.449]   - Field: ‘seed’
[08:26:23.449]   - Field: ‘version’
[08:26:23.449]   - Field: ‘result’
[08:26:23.449]   - Field: ‘asynchronous’
[08:26:23.449]   - Field: ‘calls’
[08:26:23.449]   - Field: ‘globals’
[08:26:23.449]   - Field: ‘stdout’
[08:26:23.450]   - Field: ‘earlySignal’
[08:26:23.450]   - Field: ‘lazy’
[08:26:23.450]   - Field: ‘state’
[08:26:23.450] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:23.450] - Launch lazy future ...
[08:26:23.450] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:23.450] Packages needed by future strategies (n = 0): <none>
[08:26:23.451] {
[08:26:23.451]     {
[08:26:23.451]         {
[08:26:23.451]             ...future.startTime <- base::Sys.time()
[08:26:23.451]             {
[08:26:23.451]                 {
[08:26:23.451]                   {
[08:26:23.451]                     {
[08:26:23.451]                       {
[08:26:23.451]                         base::local({
[08:26:23.451]                           has_future <- base::requireNamespace("future", 
[08:26:23.451]                             quietly = TRUE)
[08:26:23.451]                           if (has_future) {
[08:26:23.451]                             ns <- base::getNamespace("future")
[08:26:23.451]                             version <- ns[[".package"]][["version"]]
[08:26:23.451]                             if (is.null(version)) 
[08:26:23.451]                               version <- utils::packageVersion("future")
[08:26:23.451]                           }
[08:26:23.451]                           else {
[08:26:23.451]                             version <- NULL
[08:26:23.451]                           }
[08:26:23.451]                           if (!has_future || version < "1.8.0") {
[08:26:23.451]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:23.451]                               "", base::R.version$version.string), 
[08:26:23.451]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:23.451]                                 base::R.version$platform, 8 * 
[08:26:23.451]                                   base::.Machine$sizeof.pointer), 
[08:26:23.451]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:23.451]                                 "release", "version")], collapse = " "), 
[08:26:23.451]                               hostname = base::Sys.info()[["nodename"]])
[08:26:23.451]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:23.451]                               info)
[08:26:23.451]                             info <- base::paste(info, collapse = "; ")
[08:26:23.451]                             if (!has_future) {
[08:26:23.451]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:23.451]                                 info)
[08:26:23.451]                             }
[08:26:23.451]                             else {
[08:26:23.451]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:23.451]                                 info, version)
[08:26:23.451]                             }
[08:26:23.451]                             base::stop(msg)
[08:26:23.451]                           }
[08:26:23.451]                         })
[08:26:23.451]                       }
[08:26:23.451]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:23.451]                       base::options(mc.cores = 1L)
[08:26:23.451]                     }
[08:26:23.451]                     base::local({
[08:26:23.451]                       for (pkg in "future.apply") {
[08:26:23.451]                         base::loadNamespace(pkg)
[08:26:23.451]                         base::library(pkg, character.only = TRUE)
[08:26:23.451]                       }
[08:26:23.451]                     })
[08:26:23.451]                   }
[08:26:23.451]                   ...future.strategy.old <- future::plan("list")
[08:26:23.451]                   options(future.plan = NULL)
[08:26:23.451]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:23.451]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:23.451]                 }
[08:26:23.451]                 ...future.workdir <- getwd()
[08:26:23.451]             }
[08:26:23.451]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:23.451]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:23.451]         }
[08:26:23.451]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:23.451]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:23.451]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:23.451]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:23.451]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:23.451]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:23.451]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:23.451]             base::names(...future.oldOptions))
[08:26:23.451]     }
[08:26:23.451]     if (FALSE) {
[08:26:23.451]     }
[08:26:23.451]     else {
[08:26:23.451]         if (TRUE) {
[08:26:23.451]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:23.451]                 open = "w")
[08:26:23.451]         }
[08:26:23.451]         else {
[08:26:23.451]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:23.451]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:23.451]         }
[08:26:23.451]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:23.451]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:23.451]             base::sink(type = "output", split = FALSE)
[08:26:23.451]             base::close(...future.stdout)
[08:26:23.451]         }, add = TRUE)
[08:26:23.451]     }
[08:26:23.451]     ...future.frame <- base::sys.nframe()
[08:26:23.451]     ...future.conditions <- base::list()
[08:26:23.451]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:23.451]     if (FALSE) {
[08:26:23.451]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:23.451]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:23.451]     }
[08:26:23.451]     ...future.result <- base::tryCatch({
[08:26:23.451]         base::withCallingHandlers({
[08:26:23.451]             ...future.value <- base::withVisible(base::local({
[08:26:23.451]                 ...future.makeSendCondition <- base::local({
[08:26:23.451]                   sendCondition <- NULL
[08:26:23.451]                   function(frame = 1L) {
[08:26:23.451]                     if (is.function(sendCondition)) 
[08:26:23.451]                       return(sendCondition)
[08:26:23.451]                     ns <- getNamespace("parallel")
[08:26:23.451]                     if (exists("sendData", mode = "function", 
[08:26:23.451]                       envir = ns)) {
[08:26:23.451]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:23.451]                         envir = ns)
[08:26:23.451]                       envir <- sys.frame(frame)
[08:26:23.451]                       master <- NULL
[08:26:23.451]                       while (!identical(envir, .GlobalEnv) && 
[08:26:23.451]                         !identical(envir, emptyenv())) {
[08:26:23.451]                         if (exists("master", mode = "list", envir = envir, 
[08:26:23.451]                           inherits = FALSE)) {
[08:26:23.451]                           master <- get("master", mode = "list", 
[08:26:23.451]                             envir = envir, inherits = FALSE)
[08:26:23.451]                           if (inherits(master, c("SOCKnode", 
[08:26:23.451]                             "SOCK0node"))) {
[08:26:23.451]                             sendCondition <<- function(cond) {
[08:26:23.451]                               data <- list(type = "VALUE", value = cond, 
[08:26:23.451]                                 success = TRUE)
[08:26:23.451]                               parallel_sendData(master, data)
[08:26:23.451]                             }
[08:26:23.451]                             return(sendCondition)
[08:26:23.451]                           }
[08:26:23.451]                         }
[08:26:23.451]                         frame <- frame + 1L
[08:26:23.451]                         envir <- sys.frame(frame)
[08:26:23.451]                       }
[08:26:23.451]                     }
[08:26:23.451]                     sendCondition <<- function(cond) NULL
[08:26:23.451]                   }
[08:26:23.451]                 })
[08:26:23.451]                 withCallingHandlers({
[08:26:23.451]                   {
[08:26:23.451]                     do.call(function(...) {
[08:26:23.451]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:23.451]                       if (!identical(...future.globals.maxSize.org, 
[08:26:23.451]                         ...future.globals.maxSize)) {
[08:26:23.451]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:23.451]                         on.exit(options(oopts), add = TRUE)
[08:26:23.451]                       }
[08:26:23.451]                       {
[08:26:23.451]                         lapply(seq_along(...future.elements_ii), 
[08:26:23.451]                           FUN = function(jj) {
[08:26:23.451]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:23.451]                             ...future.FUN(...future.X_jj, ...)
[08:26:23.451]                           })
[08:26:23.451]                       }
[08:26:23.451]                     }, args = future.call.arguments)
[08:26:23.451]                   }
[08:26:23.451]                 }, immediateCondition = function(cond) {
[08:26:23.451]                   sendCondition <- ...future.makeSendCondition()
[08:26:23.451]                   sendCondition(cond)
[08:26:23.451]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:23.451]                   {
[08:26:23.451]                     inherits <- base::inherits
[08:26:23.451]                     invokeRestart <- base::invokeRestart
[08:26:23.451]                     is.null <- base::is.null
[08:26:23.451]                     muffled <- FALSE
[08:26:23.451]                     if (inherits(cond, "message")) {
[08:26:23.451]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:23.451]                       if (muffled) 
[08:26:23.451]                         invokeRestart("muffleMessage")
[08:26:23.451]                     }
[08:26:23.451]                     else if (inherits(cond, "warning")) {
[08:26:23.451]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:23.451]                       if (muffled) 
[08:26:23.451]                         invokeRestart("muffleWarning")
[08:26:23.451]                     }
[08:26:23.451]                     else if (inherits(cond, "condition")) {
[08:26:23.451]                       if (!is.null(pattern)) {
[08:26:23.451]                         computeRestarts <- base::computeRestarts
[08:26:23.451]                         grepl <- base::grepl
[08:26:23.451]                         restarts <- computeRestarts(cond)
[08:26:23.451]                         for (restart in restarts) {
[08:26:23.451]                           name <- restart$name
[08:26:23.451]                           if (is.null(name)) 
[08:26:23.451]                             next
[08:26:23.451]                           if (!grepl(pattern, name)) 
[08:26:23.451]                             next
[08:26:23.451]                           invokeRestart(restart)
[08:26:23.451]                           muffled <- TRUE
[08:26:23.451]                           break
[08:26:23.451]                         }
[08:26:23.451]                       }
[08:26:23.451]                     }
[08:26:23.451]                     invisible(muffled)
[08:26:23.451]                   }
[08:26:23.451]                   muffleCondition(cond)
[08:26:23.451]                 })
[08:26:23.451]             }))
[08:26:23.451]             future::FutureResult(value = ...future.value$value, 
[08:26:23.451]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:23.451]                   ...future.rng), globalenv = if (FALSE) 
[08:26:23.451]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:23.451]                     ...future.globalenv.names))
[08:26:23.451]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:23.451]         }, condition = base::local({
[08:26:23.451]             c <- base::c
[08:26:23.451]             inherits <- base::inherits
[08:26:23.451]             invokeRestart <- base::invokeRestart
[08:26:23.451]             length <- base::length
[08:26:23.451]             list <- base::list
[08:26:23.451]             seq.int <- base::seq.int
[08:26:23.451]             signalCondition <- base::signalCondition
[08:26:23.451]             sys.calls <- base::sys.calls
[08:26:23.451]             `[[` <- base::`[[`
[08:26:23.451]             `+` <- base::`+`
[08:26:23.451]             `<<-` <- base::`<<-`
[08:26:23.451]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:23.451]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:23.451]                   3L)]
[08:26:23.451]             }
[08:26:23.451]             function(cond) {
[08:26:23.451]                 is_error <- inherits(cond, "error")
[08:26:23.451]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:23.451]                   NULL)
[08:26:23.451]                 if (is_error) {
[08:26:23.451]                   sessionInformation <- function() {
[08:26:23.451]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:23.451]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:23.451]                       search = base::search(), system = base::Sys.info())
[08:26:23.451]                   }
[08:26:23.451]                   ...future.conditions[[length(...future.conditions) + 
[08:26:23.451]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:23.451]                     cond$call), session = sessionInformation(), 
[08:26:23.451]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:23.451]                   signalCondition(cond)
[08:26:23.451]                 }
[08:26:23.451]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:23.451]                 "immediateCondition"))) {
[08:26:23.451]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:23.451]                   ...future.conditions[[length(...future.conditions) + 
[08:26:23.451]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:23.451]                   if (TRUE && !signal) {
[08:26:23.451]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:23.451]                     {
[08:26:23.451]                       inherits <- base::inherits
[08:26:23.451]                       invokeRestart <- base::invokeRestart
[08:26:23.451]                       is.null <- base::is.null
[08:26:23.451]                       muffled <- FALSE
[08:26:23.451]                       if (inherits(cond, "message")) {
[08:26:23.451]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:23.451]                         if (muffled) 
[08:26:23.451]                           invokeRestart("muffleMessage")
[08:26:23.451]                       }
[08:26:23.451]                       else if (inherits(cond, "warning")) {
[08:26:23.451]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:23.451]                         if (muffled) 
[08:26:23.451]                           invokeRestart("muffleWarning")
[08:26:23.451]                       }
[08:26:23.451]                       else if (inherits(cond, "condition")) {
[08:26:23.451]                         if (!is.null(pattern)) {
[08:26:23.451]                           computeRestarts <- base::computeRestarts
[08:26:23.451]                           grepl <- base::grepl
[08:26:23.451]                           restarts <- computeRestarts(cond)
[08:26:23.451]                           for (restart in restarts) {
[08:26:23.451]                             name <- restart$name
[08:26:23.451]                             if (is.null(name)) 
[08:26:23.451]                               next
[08:26:23.451]                             if (!grepl(pattern, name)) 
[08:26:23.451]                               next
[08:26:23.451]                             invokeRestart(restart)
[08:26:23.451]                             muffled <- TRUE
[08:26:23.451]                             break
[08:26:23.451]                           }
[08:26:23.451]                         }
[08:26:23.451]                       }
[08:26:23.451]                       invisible(muffled)
[08:26:23.451]                     }
[08:26:23.451]                     muffleCondition(cond, pattern = "^muffle")
[08:26:23.451]                   }
[08:26:23.451]                 }
[08:26:23.451]                 else {
[08:26:23.451]                   if (TRUE) {
[08:26:23.451]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:23.451]                     {
[08:26:23.451]                       inherits <- base::inherits
[08:26:23.451]                       invokeRestart <- base::invokeRestart
[08:26:23.451]                       is.null <- base::is.null
[08:26:23.451]                       muffled <- FALSE
[08:26:23.451]                       if (inherits(cond, "message")) {
[08:26:23.451]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:23.451]                         if (muffled) 
[08:26:23.451]                           invokeRestart("muffleMessage")
[08:26:23.451]                       }
[08:26:23.451]                       else if (inherits(cond, "warning")) {
[08:26:23.451]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:23.451]                         if (muffled) 
[08:26:23.451]                           invokeRestart("muffleWarning")
[08:26:23.451]                       }
[08:26:23.451]                       else if (inherits(cond, "condition")) {
[08:26:23.451]                         if (!is.null(pattern)) {
[08:26:23.451]                           computeRestarts <- base::computeRestarts
[08:26:23.451]                           grepl <- base::grepl
[08:26:23.451]                           restarts <- computeRestarts(cond)
[08:26:23.451]                           for (restart in restarts) {
[08:26:23.451]                             name <- restart$name
[08:26:23.451]                             if (is.null(name)) 
[08:26:23.451]                               next
[08:26:23.451]                             if (!grepl(pattern, name)) 
[08:26:23.451]                               next
[08:26:23.451]                             invokeRestart(restart)
[08:26:23.451]                             muffled <- TRUE
[08:26:23.451]                             break
[08:26:23.451]                           }
[08:26:23.451]                         }
[08:26:23.451]                       }
[08:26:23.451]                       invisible(muffled)
[08:26:23.451]                     }
[08:26:23.451]                     muffleCondition(cond, pattern = "^muffle")
[08:26:23.451]                   }
[08:26:23.451]                 }
[08:26:23.451]             }
[08:26:23.451]         }))
[08:26:23.451]     }, error = function(ex) {
[08:26:23.451]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:23.451]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:23.451]                 ...future.rng), started = ...future.startTime, 
[08:26:23.451]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:23.451]             version = "1.8"), class = "FutureResult")
[08:26:23.451]     }, finally = {
[08:26:23.451]         if (!identical(...future.workdir, getwd())) 
[08:26:23.451]             setwd(...future.workdir)
[08:26:23.451]         {
[08:26:23.451]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:23.451]                 ...future.oldOptions$nwarnings <- NULL
[08:26:23.451]             }
[08:26:23.451]             base::options(...future.oldOptions)
[08:26:23.451]             if (.Platform$OS.type == "windows") {
[08:26:23.451]                 old_names <- names(...future.oldEnvVars)
[08:26:23.451]                 envs <- base::Sys.getenv()
[08:26:23.451]                 names <- names(envs)
[08:26:23.451]                 common <- intersect(names, old_names)
[08:26:23.451]                 added <- setdiff(names, old_names)
[08:26:23.451]                 removed <- setdiff(old_names, names)
[08:26:23.451]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:23.451]                   envs[common]]
[08:26:23.451]                 NAMES <- toupper(changed)
[08:26:23.451]                 args <- list()
[08:26:23.451]                 for (kk in seq_along(NAMES)) {
[08:26:23.451]                   name <- changed[[kk]]
[08:26:23.451]                   NAME <- NAMES[[kk]]
[08:26:23.451]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:23.451]                     next
[08:26:23.451]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:23.451]                 }
[08:26:23.451]                 NAMES <- toupper(added)
[08:26:23.451]                 for (kk in seq_along(NAMES)) {
[08:26:23.451]                   name <- added[[kk]]
[08:26:23.451]                   NAME <- NAMES[[kk]]
[08:26:23.451]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:23.451]                     next
[08:26:23.451]                   args[[name]] <- ""
[08:26:23.451]                 }
[08:26:23.451]                 NAMES <- toupper(removed)
[08:26:23.451]                 for (kk in seq_along(NAMES)) {
[08:26:23.451]                   name <- removed[[kk]]
[08:26:23.451]                   NAME <- NAMES[[kk]]
[08:26:23.451]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:23.451]                     next
[08:26:23.451]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:23.451]                 }
[08:26:23.451]                 if (length(args) > 0) 
[08:26:23.451]                   base::do.call(base::Sys.setenv, args = args)
[08:26:23.451]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:23.451]             }
[08:26:23.451]             else {
[08:26:23.451]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:23.451]             }
[08:26:23.451]             {
[08:26:23.451]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:23.451]                   0L) {
[08:26:23.451]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:23.451]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:23.451]                   base::options(opts)
[08:26:23.451]                 }
[08:26:23.451]                 {
[08:26:23.451]                   {
[08:26:23.451]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:23.451]                     NULL
[08:26:23.451]                   }
[08:26:23.451]                   options(future.plan = NULL)
[08:26:23.451]                   if (is.na(NA_character_)) 
[08:26:23.451]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:23.451]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:23.451]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:23.451]                     .init = FALSE)
[08:26:23.451]                 }
[08:26:23.451]             }
[08:26:23.451]         }
[08:26:23.451]     })
[08:26:23.451]     if (TRUE) {
[08:26:23.451]         base::sink(type = "output", split = FALSE)
[08:26:23.451]         if (TRUE) {
[08:26:23.451]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:23.451]         }
[08:26:23.451]         else {
[08:26:23.451]             ...future.result["stdout"] <- base::list(NULL)
[08:26:23.451]         }
[08:26:23.451]         base::close(...future.stdout)
[08:26:23.451]         ...future.stdout <- NULL
[08:26:23.451]     }
[08:26:23.451]     ...future.result$conditions <- ...future.conditions
[08:26:23.451]     ...future.result$finished <- base::Sys.time()
[08:26:23.451]     ...future.result
[08:26:23.451] }
[08:26:23.454] Exporting 11 global objects (13.20 KiB) to cluster node #2 ...
[08:26:23.454] Exporting ‘...future.FUN’ (4.49 KiB) to cluster node #2 ...
[08:26:23.496] Exporting ‘...future.FUN’ (4.49 KiB) to cluster node #2 ... DONE
[08:26:23.496] Exporting ‘x_FUN’ (296 bytes) to cluster node #2 ...
[08:26:23.496] Exporting ‘x_FUN’ (296 bytes) to cluster node #2 ... DONE
[08:26:23.497] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[08:26:23.497] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[08:26:23.497] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[08:26:23.539] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[08:26:23.539] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[08:26:23.581] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[08:26:23.581] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[08:26:23.581] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[08:26:23.581] Exporting ‘valid_types’ (61 bytes) to cluster node #2 ...
[08:26:23.582] Exporting ‘valid_types’ (61 bytes) to cluster node #2 ... DONE
[08:26:23.582] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:26:23.582] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:26:23.582] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ...
[08:26:23.583] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ... DONE
[08:26:23.583] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:26:23.583] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:26:23.583] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:26:23.584] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:26:23.584] Exporting 11 global objects (13.20 KiB) to cluster node #2 ... DONE
[08:26:23.584] MultisessionFuture started
[08:26:23.585] - Launch lazy future ... done
[08:26:23.585] run() for ‘MultisessionFuture’ ... done
[08:26:23.585] Created future:
[08:26:23.585] MultisessionFuture:
[08:26:23.585] Label: ‘future_vapply-2’
[08:26:23.585] Expression:
[08:26:23.585] {
[08:26:23.585]     do.call(function(...) {
[08:26:23.585]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:23.585]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:23.585]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:23.585]             on.exit(options(oopts), add = TRUE)
[08:26:23.585]         }
[08:26:23.585]         {
[08:26:23.585]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:23.585]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:23.585]                 ...future.FUN(...future.X_jj, ...)
[08:26:23.585]             })
[08:26:23.585]         }
[08:26:23.585]     }, args = future.call.arguments)
[08:26:23.585] }
[08:26:23.585] Lazy evaluation: FALSE
[08:26:23.585] Asynchronous evaluation: TRUE
[08:26:23.585] Local evaluation: TRUE
[08:26:23.585] Environment: R_GlobalEnv
[08:26:23.585] Capture standard output: TRUE
[08:26:23.585] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:23.585] Globals: 11 objects totaling 12.98 KiB (function ‘...future.FUN’ of 4.49 KiB, function ‘x_FUN’ of 296 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:23.585] Packages: 1 packages (‘future.apply’)
[08:26:23.585] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:23.585] Resolved: FALSE
[08:26:23.585] Value: <not collected>
[08:26:23.585] Conditions captured: <none>
[08:26:23.585] Early signaling: FALSE
[08:26:23.585] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:23.585] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:23.597] Chunk #2 of 2 ... DONE
[08:26:23.597] Launching 2 futures (chunks) ... DONE
[08:26:23.597] Resolving 2 futures (chunks) ...
[08:26:23.597] resolve() on list ...
[08:26:23.597]  recursive: 0
[08:26:23.597]  length: 2
[08:26:23.597] 
[08:26:23.598] receiveMessageFromWorker() for ClusterFuture ...
[08:26:23.598] - Validating connection of MultisessionFuture
[08:26:23.598] - received message: FutureResult
[08:26:23.598] - Received FutureResult
[08:26:23.598] - Erased future from FutureRegistry
[08:26:23.598] result() for ClusterFuture ...
[08:26:23.599] - result already collected: FutureResult
[08:26:23.599] result() for ClusterFuture ... done
[08:26:23.599] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:23.599] Future #1
[08:26:23.599] result() for ClusterFuture ...
[08:26:23.599] - result already collected: FutureResult
[08:26:23.599] result() for ClusterFuture ... done
[08:26:23.599] result() for ClusterFuture ...
[08:26:23.599] - result already collected: FutureResult
[08:26:23.599] result() for ClusterFuture ... done
[08:26:23.599] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:26:23.599] - nx: 2
[08:26:23.600] - relay: TRUE
[08:26:23.600] - stdout: TRUE
[08:26:23.600] - signal: TRUE
[08:26:23.600] - resignal: FALSE
[08:26:23.600] - force: TRUE
[08:26:23.600] - relayed: [n=2] FALSE, FALSE
[08:26:23.600] - queued futures: [n=2] FALSE, FALSE
[08:26:23.600]  - until=1
[08:26:23.600]  - relaying element #1
[08:26:23.600] result() for ClusterFuture ...
[08:26:23.600] - result already collected: FutureResult
[08:26:23.600] result() for ClusterFuture ... done
[08:26:23.601] result() for ClusterFuture ...
[08:26:23.601] - result already collected: FutureResult
[08:26:23.601] result() for ClusterFuture ... done
[08:26:23.601] result() for ClusterFuture ...
[08:26:23.601] - result already collected: FutureResult
[08:26:23.601] result() for ClusterFuture ... done
[08:26:23.601] result() for ClusterFuture ...
[08:26:23.601] - result already collected: FutureResult
[08:26:23.601] result() for ClusterFuture ... done
[08:26:23.601] - relayed: [n=2] TRUE, FALSE
[08:26:23.601] - queued futures: [n=2] TRUE, FALSE
[08:26:23.601] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:26:23.602]  length: 1 (resolved future 1)
[08:26:23.627] receiveMessageFromWorker() for ClusterFuture ...
[08:26:23.628] - Validating connection of MultisessionFuture
[08:26:23.628] - received message: FutureResult
[08:26:23.628] - Received FutureResult
[08:26:23.628] - Erased future from FutureRegistry
[08:26:23.628] result() for ClusterFuture ...
[08:26:23.628] - result already collected: FutureResult
[08:26:23.628] result() for ClusterFuture ... done
[08:26:23.628] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:23.629] Future #2
[08:26:23.629] result() for ClusterFuture ...
[08:26:23.629] - result already collected: FutureResult
[08:26:23.629] result() for ClusterFuture ... done
[08:26:23.629] result() for ClusterFuture ...
[08:26:23.629] - result already collected: FutureResult
[08:26:23.629] result() for ClusterFuture ... done
[08:26:23.629] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:26:23.629] - nx: 2
[08:26:23.629] - relay: TRUE
[08:26:23.629] - stdout: TRUE
[08:26:23.630] - signal: TRUE
[08:26:23.630] - resignal: FALSE
[08:26:23.630] - force: TRUE
[08:26:23.630] - relayed: [n=2] TRUE, FALSE
[08:26:23.630] - queued futures: [n=2] TRUE, FALSE
[08:26:23.630]  - until=2
[08:26:23.630]  - relaying element #2
[08:26:23.630] result() for ClusterFuture ...
[08:26:23.630] - result already collected: FutureResult
[08:26:23.630] result() for ClusterFuture ... done
[08:26:23.630] result() for ClusterFuture ...
[08:26:23.630] - result already collected: FutureResult
[08:26:23.631] result() for ClusterFuture ... done
[08:26:23.631] result() for ClusterFuture ...
[08:26:23.631] - result already collected: FutureResult
[08:26:23.631] result() for ClusterFuture ... done
[08:26:23.631] result() for ClusterFuture ...
[08:26:23.631] - result already collected: FutureResult
[08:26:23.631] result() for ClusterFuture ... done
[08:26:23.631] - relayed: [n=2] TRUE, TRUE
[08:26:23.631] - queued futures: [n=2] TRUE, TRUE
[08:26:23.631] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:26:23.631]  length: 0 (resolved future 2)
[08:26:23.632] Relaying remaining futures
[08:26:23.632] signalConditionsASAP(NULL, pos=0) ...
[08:26:23.632] - nx: 2
[08:26:23.632] - relay: TRUE
[08:26:23.632] - stdout: TRUE
[08:26:23.632] - signal: TRUE
[08:26:23.632] - resignal: FALSE
[08:26:23.632] - force: TRUE
[08:26:23.632] - relayed: [n=2] TRUE, TRUE
[08:26:23.632] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:23.632] - relayed: [n=2] TRUE, TRUE
[08:26:23.632] - queued futures: [n=2] TRUE, TRUE
[08:26:23.633] signalConditionsASAP(NULL, pos=0) ... done
[08:26:23.633] resolve() on list ... DONE
[08:26:23.633] result() for ClusterFuture ...
[08:26:23.633] - result already collected: FutureResult
[08:26:23.633] result() for ClusterFuture ... done
[08:26:23.633] result() for ClusterFuture ...
[08:26:23.633] - result already collected: FutureResult
[08:26:23.633] result() for ClusterFuture ... done
[08:26:23.633] result() for ClusterFuture ...
[08:26:23.633] - result already collected: FutureResult
[08:26:23.633] result() for ClusterFuture ... done
[08:26:23.633] result() for ClusterFuture ...
[08:26:23.634] - result already collected: FutureResult
[08:26:23.634] result() for ClusterFuture ... done
[08:26:23.634]  - Number of value chunks collected: 2
[08:26:23.634] Resolving 2 futures (chunks) ... DONE
[08:26:23.634] Reducing values from 2 chunks ...
[08:26:23.634]  - Number of values collected after concatenation: 10
[08:26:23.634]  - Number of values expected: 10
[08:26:23.634] Reducing values from 2 chunks ... DONE
[08:26:23.634] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[08:26:23.635] future_lapply() ...
[08:26:23.639] Number of chunks: 2
[08:26:23.639] getGlobalsAndPackagesXApply() ...
[08:26:23.639]  - future.globals: TRUE
[08:26:23.639] getGlobalsAndPackages() ...
[08:26:23.639] Searching for globals...
[08:26:23.642] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[08:26:23.642] Searching for globals ... DONE
[08:26:23.642] Resolving globals: FALSE
[08:26:23.643] The total size of the 7 globals is 12.08 KiB (12367 bytes)
[08:26:23.644] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.07 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:23.644] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:23.644] - packages: [1] ‘future.apply’
[08:26:23.644] getGlobalsAndPackages() ... DONE
[08:26:23.644]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:23.644]  - needed namespaces: [n=1] ‘future.apply’
[08:26:23.644] Finding globals ... DONE
[08:26:23.644]  - use_args: TRUE
[08:26:23.644]  - Getting '...' globals ...
[08:26:23.645] resolve() on list ...
[08:26:23.645]  recursive: 0
[08:26:23.645]  length: 1
[08:26:23.645]  elements: ‘...’
[08:26:23.645]  length: 0 (resolved future 1)
[08:26:23.645] resolve() on list ... DONE
[08:26:23.645]    - '...' content: [n=0] 
[08:26:23.645] List of 1
[08:26:23.645]  $ ...: list()
[08:26:23.645]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:23.645]  - attr(*, "where")=List of 1
[08:26:23.645]   ..$ ...:<environment: 0x562ca9393620> 
[08:26:23.645]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:23.645]  - attr(*, "resolved")= logi TRUE
[08:26:23.645]  - attr(*, "total_size")= num NA
[08:26:23.648]  - Getting '...' globals ... DONE
[08:26:23.648] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:23.648] List of 8
[08:26:23.648]  $ ...future.FUN:function (x, ...)  
[08:26:23.648]  $ x_FUN        :function (x)  
[08:26:23.648]  $ times        : int 1
[08:26:23.648]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:23.648]  $ stop_if_not  :function (...)  
[08:26:23.648]  $ dim          : NULL
[08:26:23.648]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:23.648]  $ ...          : list()
[08:26:23.648]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:23.648]  - attr(*, "where")=List of 8
[08:26:23.648]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:23.648]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:23.648]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:23.648]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:23.648]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:23.648]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:23.648]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:23.648]   ..$ ...          :<environment: 0x562ca9393620> 
[08:26:23.648]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:23.648]  - attr(*, "resolved")= logi FALSE
[08:26:23.648]  - attr(*, "total_size")= num 22322
[08:26:23.654] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:23.654] getGlobalsAndPackagesXApply() ... DONE
[08:26:23.654] Number of futures (= number of chunks): 2
[08:26:23.654] Launching 2 futures (chunks) ...
[08:26:23.654] Chunk #1 of 2 ...
[08:26:23.654]  - Finding globals in 'X' for chunk #1 ...
[08:26:23.654] getGlobalsAndPackages() ...
[08:26:23.654] Searching for globals...
[08:26:23.655] 
[08:26:23.655] Searching for globals ... DONE
[08:26:23.655] - globals: [0] <none>
[08:26:23.655] getGlobalsAndPackages() ... DONE
[08:26:23.655]    + additional globals found: [n=0] 
[08:26:23.655]    + additional namespaces needed: [n=0] 
[08:26:23.655]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:23.655]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:23.655]  - seeds: <none>
[08:26:23.655]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:23.656] getGlobalsAndPackages() ...
[08:26:23.656] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:23.656] Resolving globals: FALSE
[08:26:23.656] Tweak future expression to call with '...' arguments ...
[08:26:23.656] {
[08:26:23.656]     do.call(function(...) {
[08:26:23.656]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:23.656]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:23.656]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:23.656]             on.exit(options(oopts), add = TRUE)
[08:26:23.656]         }
[08:26:23.656]         {
[08:26:23.656]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:23.656]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:23.656]                 ...future.FUN(...future.X_jj, ...)
[08:26:23.656]             })
[08:26:23.656]         }
[08:26:23.656]     }, args = future.call.arguments)
[08:26:23.656] }
[08:26:23.656] Tweak future expression to call with '...' arguments ... DONE
[08:26:23.657] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:23.657] - packages: [1] ‘future.apply’
[08:26:23.657] getGlobalsAndPackages() ... DONE
[08:26:23.657] run() for ‘Future’ ...
[08:26:23.657] - state: ‘created’
[08:26:23.658] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:23.672] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:23.672] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:23.672]   - Field: ‘node’
[08:26:23.672]   - Field: ‘label’
[08:26:23.672]   - Field: ‘local’
[08:26:23.673]   - Field: ‘owner’
[08:26:23.673]   - Field: ‘envir’
[08:26:23.673]   - Field: ‘workers’
[08:26:23.673]   - Field: ‘packages’
[08:26:23.673]   - Field: ‘gc’
[08:26:23.673]   - Field: ‘conditions’
[08:26:23.673]   - Field: ‘persistent’
[08:26:23.673]   - Field: ‘expr’
[08:26:23.673]   - Field: ‘uuid’
[08:26:23.673]   - Field: ‘seed’
[08:26:23.673]   - Field: ‘version’
[08:26:23.674]   - Field: ‘result’
[08:26:23.674]   - Field: ‘asynchronous’
[08:26:23.674]   - Field: ‘calls’
[08:26:23.674]   - Field: ‘globals’
[08:26:23.674]   - Field: ‘stdout’
[08:26:23.674]   - Field: ‘earlySignal’
[08:26:23.674]   - Field: ‘lazy’
[08:26:23.674]   - Field: ‘state’
[08:26:23.674] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:23.674] - Launch lazy future ...
[08:26:23.675] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:23.675] Packages needed by future strategies (n = 0): <none>
[08:26:23.675] {
[08:26:23.675]     {
[08:26:23.675]         {
[08:26:23.675]             ...future.startTime <- base::Sys.time()
[08:26:23.675]             {
[08:26:23.675]                 {
[08:26:23.675]                   {
[08:26:23.675]                     {
[08:26:23.675]                       {
[08:26:23.675]                         base::local({
[08:26:23.675]                           has_future <- base::requireNamespace("future", 
[08:26:23.675]                             quietly = TRUE)
[08:26:23.675]                           if (has_future) {
[08:26:23.675]                             ns <- base::getNamespace("future")
[08:26:23.675]                             version <- ns[[".package"]][["version"]]
[08:26:23.675]                             if (is.null(version)) 
[08:26:23.675]                               version <- utils::packageVersion("future")
[08:26:23.675]                           }
[08:26:23.675]                           else {
[08:26:23.675]                             version <- NULL
[08:26:23.675]                           }
[08:26:23.675]                           if (!has_future || version < "1.8.0") {
[08:26:23.675]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:23.675]                               "", base::R.version$version.string), 
[08:26:23.675]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:23.675]                                 base::R.version$platform, 8 * 
[08:26:23.675]                                   base::.Machine$sizeof.pointer), 
[08:26:23.675]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:23.675]                                 "release", "version")], collapse = " "), 
[08:26:23.675]                               hostname = base::Sys.info()[["nodename"]])
[08:26:23.675]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:23.675]                               info)
[08:26:23.675]                             info <- base::paste(info, collapse = "; ")
[08:26:23.675]                             if (!has_future) {
[08:26:23.675]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:23.675]                                 info)
[08:26:23.675]                             }
[08:26:23.675]                             else {
[08:26:23.675]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:23.675]                                 info, version)
[08:26:23.675]                             }
[08:26:23.675]                             base::stop(msg)
[08:26:23.675]                           }
[08:26:23.675]                         })
[08:26:23.675]                       }
[08:26:23.675]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:23.675]                       base::options(mc.cores = 1L)
[08:26:23.675]                     }
[08:26:23.675]                     base::local({
[08:26:23.675]                       for (pkg in "future.apply") {
[08:26:23.675]                         base::loadNamespace(pkg)
[08:26:23.675]                         base::library(pkg, character.only = TRUE)
[08:26:23.675]                       }
[08:26:23.675]                     })
[08:26:23.675]                   }
[08:26:23.675]                   ...future.strategy.old <- future::plan("list")
[08:26:23.675]                   options(future.plan = NULL)
[08:26:23.675]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:23.675]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:23.675]                 }
[08:26:23.675]                 ...future.workdir <- getwd()
[08:26:23.675]             }
[08:26:23.675]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:23.675]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:23.675]         }
[08:26:23.675]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:23.675]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:23.675]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:23.675]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:23.675]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:23.675]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:23.675]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:23.675]             base::names(...future.oldOptions))
[08:26:23.675]     }
[08:26:23.675]     if (FALSE) {
[08:26:23.675]     }
[08:26:23.675]     else {
[08:26:23.675]         if (TRUE) {
[08:26:23.675]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:23.675]                 open = "w")
[08:26:23.675]         }
[08:26:23.675]         else {
[08:26:23.675]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:23.675]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:23.675]         }
[08:26:23.675]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:23.675]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:23.675]             base::sink(type = "output", split = FALSE)
[08:26:23.675]             base::close(...future.stdout)
[08:26:23.675]         }, add = TRUE)
[08:26:23.675]     }
[08:26:23.675]     ...future.frame <- base::sys.nframe()
[08:26:23.675]     ...future.conditions <- base::list()
[08:26:23.675]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:23.675]     if (FALSE) {
[08:26:23.675]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:23.675]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:23.675]     }
[08:26:23.675]     ...future.result <- base::tryCatch({
[08:26:23.675]         base::withCallingHandlers({
[08:26:23.675]             ...future.value <- base::withVisible(base::local({
[08:26:23.675]                 ...future.makeSendCondition <- base::local({
[08:26:23.675]                   sendCondition <- NULL
[08:26:23.675]                   function(frame = 1L) {
[08:26:23.675]                     if (is.function(sendCondition)) 
[08:26:23.675]                       return(sendCondition)
[08:26:23.675]                     ns <- getNamespace("parallel")
[08:26:23.675]                     if (exists("sendData", mode = "function", 
[08:26:23.675]                       envir = ns)) {
[08:26:23.675]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:23.675]                         envir = ns)
[08:26:23.675]                       envir <- sys.frame(frame)
[08:26:23.675]                       master <- NULL
[08:26:23.675]                       while (!identical(envir, .GlobalEnv) && 
[08:26:23.675]                         !identical(envir, emptyenv())) {
[08:26:23.675]                         if (exists("master", mode = "list", envir = envir, 
[08:26:23.675]                           inherits = FALSE)) {
[08:26:23.675]                           master <- get("master", mode = "list", 
[08:26:23.675]                             envir = envir, inherits = FALSE)
[08:26:23.675]                           if (inherits(master, c("SOCKnode", 
[08:26:23.675]                             "SOCK0node"))) {
[08:26:23.675]                             sendCondition <<- function(cond) {
[08:26:23.675]                               data <- list(type = "VALUE", value = cond, 
[08:26:23.675]                                 success = TRUE)
[08:26:23.675]                               parallel_sendData(master, data)
[08:26:23.675]                             }
[08:26:23.675]                             return(sendCondition)
[08:26:23.675]                           }
[08:26:23.675]                         }
[08:26:23.675]                         frame <- frame + 1L
[08:26:23.675]                         envir <- sys.frame(frame)
[08:26:23.675]                       }
[08:26:23.675]                     }
[08:26:23.675]                     sendCondition <<- function(cond) NULL
[08:26:23.675]                   }
[08:26:23.675]                 })
[08:26:23.675]                 withCallingHandlers({
[08:26:23.675]                   {
[08:26:23.675]                     do.call(function(...) {
[08:26:23.675]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:23.675]                       if (!identical(...future.globals.maxSize.org, 
[08:26:23.675]                         ...future.globals.maxSize)) {
[08:26:23.675]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:23.675]                         on.exit(options(oopts), add = TRUE)
[08:26:23.675]                       }
[08:26:23.675]                       {
[08:26:23.675]                         lapply(seq_along(...future.elements_ii), 
[08:26:23.675]                           FUN = function(jj) {
[08:26:23.675]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:23.675]                             ...future.FUN(...future.X_jj, ...)
[08:26:23.675]                           })
[08:26:23.675]                       }
[08:26:23.675]                     }, args = future.call.arguments)
[08:26:23.675]                   }
[08:26:23.675]                 }, immediateCondition = function(cond) {
[08:26:23.675]                   sendCondition <- ...future.makeSendCondition()
[08:26:23.675]                   sendCondition(cond)
[08:26:23.675]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:23.675]                   {
[08:26:23.675]                     inherits <- base::inherits
[08:26:23.675]                     invokeRestart <- base::invokeRestart
[08:26:23.675]                     is.null <- base::is.null
[08:26:23.675]                     muffled <- FALSE
[08:26:23.675]                     if (inherits(cond, "message")) {
[08:26:23.675]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:23.675]                       if (muffled) 
[08:26:23.675]                         invokeRestart("muffleMessage")
[08:26:23.675]                     }
[08:26:23.675]                     else if (inherits(cond, "warning")) {
[08:26:23.675]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:23.675]                       if (muffled) 
[08:26:23.675]                         invokeRestart("muffleWarning")
[08:26:23.675]                     }
[08:26:23.675]                     else if (inherits(cond, "condition")) {
[08:26:23.675]                       if (!is.null(pattern)) {
[08:26:23.675]                         computeRestarts <- base::computeRestarts
[08:26:23.675]                         grepl <- base::grepl
[08:26:23.675]                         restarts <- computeRestarts(cond)
[08:26:23.675]                         for (restart in restarts) {
[08:26:23.675]                           name <- restart$name
[08:26:23.675]                           if (is.null(name)) 
[08:26:23.675]                             next
[08:26:23.675]                           if (!grepl(pattern, name)) 
[08:26:23.675]                             next
[08:26:23.675]                           invokeRestart(restart)
[08:26:23.675]                           muffled <- TRUE
[08:26:23.675]                           break
[08:26:23.675]                         }
[08:26:23.675]                       }
[08:26:23.675]                     }
[08:26:23.675]                     invisible(muffled)
[08:26:23.675]                   }
[08:26:23.675]                   muffleCondition(cond)
[08:26:23.675]                 })
[08:26:23.675]             }))
[08:26:23.675]             future::FutureResult(value = ...future.value$value, 
[08:26:23.675]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:23.675]                   ...future.rng), globalenv = if (FALSE) 
[08:26:23.675]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:23.675]                     ...future.globalenv.names))
[08:26:23.675]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:23.675]         }, condition = base::local({
[08:26:23.675]             c <- base::c
[08:26:23.675]             inherits <- base::inherits
[08:26:23.675]             invokeRestart <- base::invokeRestart
[08:26:23.675]             length <- base::length
[08:26:23.675]             list <- base::list
[08:26:23.675]             seq.int <- base::seq.int
[08:26:23.675]             signalCondition <- base::signalCondition
[08:26:23.675]             sys.calls <- base::sys.calls
[08:26:23.675]             `[[` <- base::`[[`
[08:26:23.675]             `+` <- base::`+`
[08:26:23.675]             `<<-` <- base::`<<-`
[08:26:23.675]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:23.675]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:23.675]                   3L)]
[08:26:23.675]             }
[08:26:23.675]             function(cond) {
[08:26:23.675]                 is_error <- inherits(cond, "error")
[08:26:23.675]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:23.675]                   NULL)
[08:26:23.675]                 if (is_error) {
[08:26:23.675]                   sessionInformation <- function() {
[08:26:23.675]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:23.675]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:23.675]                       search = base::search(), system = base::Sys.info())
[08:26:23.675]                   }
[08:26:23.675]                   ...future.conditions[[length(...future.conditions) + 
[08:26:23.675]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:23.675]                     cond$call), session = sessionInformation(), 
[08:26:23.675]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:23.675]                   signalCondition(cond)
[08:26:23.675]                 }
[08:26:23.675]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:23.675]                 "immediateCondition"))) {
[08:26:23.675]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:23.675]                   ...future.conditions[[length(...future.conditions) + 
[08:26:23.675]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:23.675]                   if (TRUE && !signal) {
[08:26:23.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:23.675]                     {
[08:26:23.675]                       inherits <- base::inherits
[08:26:23.675]                       invokeRestart <- base::invokeRestart
[08:26:23.675]                       is.null <- base::is.null
[08:26:23.675]                       muffled <- FALSE
[08:26:23.675]                       if (inherits(cond, "message")) {
[08:26:23.675]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:23.675]                         if (muffled) 
[08:26:23.675]                           invokeRestart("muffleMessage")
[08:26:23.675]                       }
[08:26:23.675]                       else if (inherits(cond, "warning")) {
[08:26:23.675]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:23.675]                         if (muffled) 
[08:26:23.675]                           invokeRestart("muffleWarning")
[08:26:23.675]                       }
[08:26:23.675]                       else if (inherits(cond, "condition")) {
[08:26:23.675]                         if (!is.null(pattern)) {
[08:26:23.675]                           computeRestarts <- base::computeRestarts
[08:26:23.675]                           grepl <- base::grepl
[08:26:23.675]                           restarts <- computeRestarts(cond)
[08:26:23.675]                           for (restart in restarts) {
[08:26:23.675]                             name <- restart$name
[08:26:23.675]                             if (is.null(name)) 
[08:26:23.675]                               next
[08:26:23.675]                             if (!grepl(pattern, name)) 
[08:26:23.675]                               next
[08:26:23.675]                             invokeRestart(restart)
[08:26:23.675]                             muffled <- TRUE
[08:26:23.675]                             break
[08:26:23.675]                           }
[08:26:23.675]                         }
[08:26:23.675]                       }
[08:26:23.675]                       invisible(muffled)
[08:26:23.675]                     }
[08:26:23.675]                     muffleCondition(cond, pattern = "^muffle")
[08:26:23.675]                   }
[08:26:23.675]                 }
[08:26:23.675]                 else {
[08:26:23.675]                   if (TRUE) {
[08:26:23.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:23.675]                     {
[08:26:23.675]                       inherits <- base::inherits
[08:26:23.675]                       invokeRestart <- base::invokeRestart
[08:26:23.675]                       is.null <- base::is.null
[08:26:23.675]                       muffled <- FALSE
[08:26:23.675]                       if (inherits(cond, "message")) {
[08:26:23.675]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:23.675]                         if (muffled) 
[08:26:23.675]                           invokeRestart("muffleMessage")
[08:26:23.675]                       }
[08:26:23.675]                       else if (inherits(cond, "warning")) {
[08:26:23.675]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:23.675]                         if (muffled) 
[08:26:23.675]                           invokeRestart("muffleWarning")
[08:26:23.675]                       }
[08:26:23.675]                       else if (inherits(cond, "condition")) {
[08:26:23.675]                         if (!is.null(pattern)) {
[08:26:23.675]                           computeRestarts <- base::computeRestarts
[08:26:23.675]                           grepl <- base::grepl
[08:26:23.675]                           restarts <- computeRestarts(cond)
[08:26:23.675]                           for (restart in restarts) {
[08:26:23.675]                             name <- restart$name
[08:26:23.675]                             if (is.null(name)) 
[08:26:23.675]                               next
[08:26:23.675]                             if (!grepl(pattern, name)) 
[08:26:23.675]                               next
[08:26:23.675]                             invokeRestart(restart)
[08:26:23.675]                             muffled <- TRUE
[08:26:23.675]                             break
[08:26:23.675]                           }
[08:26:23.675]                         }
[08:26:23.675]                       }
[08:26:23.675]                       invisible(muffled)
[08:26:23.675]                     }
[08:26:23.675]                     muffleCondition(cond, pattern = "^muffle")
[08:26:23.675]                   }
[08:26:23.675]                 }
[08:26:23.675]             }
[08:26:23.675]         }))
[08:26:23.675]     }, error = function(ex) {
[08:26:23.675]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:23.675]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:23.675]                 ...future.rng), started = ...future.startTime, 
[08:26:23.675]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:23.675]             version = "1.8"), class = "FutureResult")
[08:26:23.675]     }, finally = {
[08:26:23.675]         if (!identical(...future.workdir, getwd())) 
[08:26:23.675]             setwd(...future.workdir)
[08:26:23.675]         {
[08:26:23.675]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:23.675]                 ...future.oldOptions$nwarnings <- NULL
[08:26:23.675]             }
[08:26:23.675]             base::options(...future.oldOptions)
[08:26:23.675]             if (.Platform$OS.type == "windows") {
[08:26:23.675]                 old_names <- names(...future.oldEnvVars)
[08:26:23.675]                 envs <- base::Sys.getenv()
[08:26:23.675]                 names <- names(envs)
[08:26:23.675]                 common <- intersect(names, old_names)
[08:26:23.675]                 added <- setdiff(names, old_names)
[08:26:23.675]                 removed <- setdiff(old_names, names)
[08:26:23.675]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:23.675]                   envs[common]]
[08:26:23.675]                 NAMES <- toupper(changed)
[08:26:23.675]                 args <- list()
[08:26:23.675]                 for (kk in seq_along(NAMES)) {
[08:26:23.675]                   name <- changed[[kk]]
[08:26:23.675]                   NAME <- NAMES[[kk]]
[08:26:23.675]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:23.675]                     next
[08:26:23.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:23.675]                 }
[08:26:23.675]                 NAMES <- toupper(added)
[08:26:23.675]                 for (kk in seq_along(NAMES)) {
[08:26:23.675]                   name <- added[[kk]]
[08:26:23.675]                   NAME <- NAMES[[kk]]
[08:26:23.675]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:23.675]                     next
[08:26:23.675]                   args[[name]] <- ""
[08:26:23.675]                 }
[08:26:23.675]                 NAMES <- toupper(removed)
[08:26:23.675]                 for (kk in seq_along(NAMES)) {
[08:26:23.675]                   name <- removed[[kk]]
[08:26:23.675]                   NAME <- NAMES[[kk]]
[08:26:23.675]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:23.675]                     next
[08:26:23.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:23.675]                 }
[08:26:23.675]                 if (length(args) > 0) 
[08:26:23.675]                   base::do.call(base::Sys.setenv, args = args)
[08:26:23.675]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:23.675]             }
[08:26:23.675]             else {
[08:26:23.675]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:23.675]             }
[08:26:23.675]             {
[08:26:23.675]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:23.675]                   0L) {
[08:26:23.675]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:23.675]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:23.675]                   base::options(opts)
[08:26:23.675]                 }
[08:26:23.675]                 {
[08:26:23.675]                   {
[08:26:23.675]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:23.675]                     NULL
[08:26:23.675]                   }
[08:26:23.675]                   options(future.plan = NULL)
[08:26:23.675]                   if (is.na(NA_character_)) 
[08:26:23.675]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:23.675]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:23.675]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:23.675]                     .init = FALSE)
[08:26:23.675]                 }
[08:26:23.675]             }
[08:26:23.675]         }
[08:26:23.675]     })
[08:26:23.675]     if (TRUE) {
[08:26:23.675]         base::sink(type = "output", split = FALSE)
[08:26:23.675]         if (TRUE) {
[08:26:23.675]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:23.675]         }
[08:26:23.675]         else {
[08:26:23.675]             ...future.result["stdout"] <- base::list(NULL)
[08:26:23.675]         }
[08:26:23.675]         base::close(...future.stdout)
[08:26:23.675]         ...future.stdout <- NULL
[08:26:23.675]     }
[08:26:23.675]     ...future.result$conditions <- ...future.conditions
[08:26:23.675]     ...future.result$finished <- base::Sys.time()
[08:26:23.675]     ...future.result
[08:26:23.675] }
[08:26:23.678] Exporting 11 global objects (12.56 KiB) to cluster node #1 ...
[08:26:23.678] Exporting ‘...future.FUN’ (4.06 KiB) to cluster node #1 ...
[08:26:23.720] Exporting ‘...future.FUN’ (4.06 KiB) to cluster node #1 ... DONE
[08:26:23.720] Exporting ‘x_FUN’ (35 bytes) to cluster node #1 ...
[08:26:23.720] Exporting ‘x_FUN’ (35 bytes) to cluster node #1 ... DONE
[08:26:23.720] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[08:26:23.721] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[08:26:23.721] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[08:26:23.762] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[08:26:23.763] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[08:26:23.804] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[08:26:23.804] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[08:26:23.804] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[08:26:23.804] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[08:26:23.805] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[08:26:23.805] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:26:23.805] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:26:23.805] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ...
[08:26:23.806] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ... DONE
[08:26:23.806] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:26:23.806] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:26:23.806] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:26:23.807] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:26:23.807] Exporting 11 global objects (12.56 KiB) to cluster node #1 ... DONE
[08:26:23.807] MultisessionFuture started
[08:26:23.808] - Launch lazy future ... done
[08:26:23.808] run() for ‘MultisessionFuture’ ... done
[08:26:23.808] Created future:
[08:26:23.808] MultisessionFuture:
[08:26:23.808] Label: ‘future_vapply-1’
[08:26:23.808] Expression:
[08:26:23.808] {
[08:26:23.808]     do.call(function(...) {
[08:26:23.808]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:23.808]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:23.808]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:23.808]             on.exit(options(oopts), add = TRUE)
[08:26:23.808]         }
[08:26:23.808]         {
[08:26:23.808]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:23.808]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:23.808]                 ...future.FUN(...future.X_jj, ...)
[08:26:23.808]             })
[08:26:23.808]         }
[08:26:23.808]     }, args = future.call.arguments)
[08:26:23.808] }
[08:26:23.808] Lazy evaluation: FALSE
[08:26:23.808] Asynchronous evaluation: TRUE
[08:26:23.808] Local evaluation: TRUE
[08:26:23.808] Environment: R_GlobalEnv
[08:26:23.808] Capture standard output: TRUE
[08:26:23.808] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:23.808] Globals: 11 objects totaling 12.31 KiB (function ‘...future.FUN’ of 4.06 KiB, function ‘x_FUN’ of 35 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:23.808] Packages: 1 packages (‘future.apply’)
[08:26:23.808] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:23.808] Resolved: FALSE
[08:26:23.808] Value: <not collected>
[08:26:23.808] Conditions captured: <none>
[08:26:23.808] Early signaling: FALSE
[08:26:23.808] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:23.808] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:23.819] Chunk #1 of 2 ... DONE
[08:26:23.820] Chunk #2 of 2 ...
[08:26:23.820]  - Finding globals in 'X' for chunk #2 ...
[08:26:23.820] getGlobalsAndPackages() ...
[08:26:23.820] Searching for globals...
[08:26:23.820] 
[08:26:23.820] Searching for globals ... DONE
[08:26:23.820] - globals: [0] <none>
[08:26:23.821] getGlobalsAndPackages() ... DONE
[08:26:23.821]    + additional globals found: [n=0] 
[08:26:23.821]    + additional namespaces needed: [n=0] 
[08:26:23.821]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:23.821]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:23.821]  - seeds: <none>
[08:26:23.821]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:23.821] getGlobalsAndPackages() ...
[08:26:23.821] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:23.821] Resolving globals: FALSE
[08:26:23.821] Tweak future expression to call with '...' arguments ...
[08:26:23.822] {
[08:26:23.822]     do.call(function(...) {
[08:26:23.822]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:23.822]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:23.822]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:23.822]             on.exit(options(oopts), add = TRUE)
[08:26:23.822]         }
[08:26:23.822]         {
[08:26:23.822]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:23.822]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:23.822]                 ...future.FUN(...future.X_jj, ...)
[08:26:23.822]             })
[08:26:23.822]         }
[08:26:23.822]     }, args = future.call.arguments)
[08:26:23.822] }
[08:26:23.822] Tweak future expression to call with '...' arguments ... DONE
[08:26:23.822] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:23.823] - packages: [1] ‘future.apply’
[08:26:23.823] getGlobalsAndPackages() ... DONE
[08:26:23.823] run() for ‘Future’ ...
[08:26:23.823] - state: ‘created’
[08:26:23.823] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:23.838] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:23.838] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:23.838]   - Field: ‘node’
[08:26:23.838]   - Field: ‘label’
[08:26:23.838]   - Field: ‘local’
[08:26:23.838]   - Field: ‘owner’
[08:26:23.838]   - Field: ‘envir’
[08:26:23.838]   - Field: ‘workers’
[08:26:23.839]   - Field: ‘packages’
[08:26:23.839]   - Field: ‘gc’
[08:26:23.839]   - Field: ‘conditions’
[08:26:23.839]   - Field: ‘persistent’
[08:26:23.839]   - Field: ‘expr’
[08:26:23.839]   - Field: ‘uuid’
[08:26:23.839]   - Field: ‘seed’
[08:26:23.839]   - Field: ‘version’
[08:26:23.839]   - Field: ‘result’
[08:26:23.839]   - Field: ‘asynchronous’
[08:26:23.839]   - Field: ‘calls’
[08:26:23.839]   - Field: ‘globals’
[08:26:23.840]   - Field: ‘stdout’
[08:26:23.840]   - Field: ‘earlySignal’
[08:26:23.840]   - Field: ‘lazy’
[08:26:23.840]   - Field: ‘state’
[08:26:23.840] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:23.840] - Launch lazy future ...
[08:26:23.840] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:23.840] Packages needed by future strategies (n = 0): <none>
[08:26:23.841] {
[08:26:23.841]     {
[08:26:23.841]         {
[08:26:23.841]             ...future.startTime <- base::Sys.time()
[08:26:23.841]             {
[08:26:23.841]                 {
[08:26:23.841]                   {
[08:26:23.841]                     {
[08:26:23.841]                       {
[08:26:23.841]                         base::local({
[08:26:23.841]                           has_future <- base::requireNamespace("future", 
[08:26:23.841]                             quietly = TRUE)
[08:26:23.841]                           if (has_future) {
[08:26:23.841]                             ns <- base::getNamespace("future")
[08:26:23.841]                             version <- ns[[".package"]][["version"]]
[08:26:23.841]                             if (is.null(version)) 
[08:26:23.841]                               version <- utils::packageVersion("future")
[08:26:23.841]                           }
[08:26:23.841]                           else {
[08:26:23.841]                             version <- NULL
[08:26:23.841]                           }
[08:26:23.841]                           if (!has_future || version < "1.8.0") {
[08:26:23.841]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:23.841]                               "", base::R.version$version.string), 
[08:26:23.841]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:23.841]                                 base::R.version$platform, 8 * 
[08:26:23.841]                                   base::.Machine$sizeof.pointer), 
[08:26:23.841]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:23.841]                                 "release", "version")], collapse = " "), 
[08:26:23.841]                               hostname = base::Sys.info()[["nodename"]])
[08:26:23.841]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:23.841]                               info)
[08:26:23.841]                             info <- base::paste(info, collapse = "; ")
[08:26:23.841]                             if (!has_future) {
[08:26:23.841]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:23.841]                                 info)
[08:26:23.841]                             }
[08:26:23.841]                             else {
[08:26:23.841]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:23.841]                                 info, version)
[08:26:23.841]                             }
[08:26:23.841]                             base::stop(msg)
[08:26:23.841]                           }
[08:26:23.841]                         })
[08:26:23.841]                       }
[08:26:23.841]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:23.841]                       base::options(mc.cores = 1L)
[08:26:23.841]                     }
[08:26:23.841]                     base::local({
[08:26:23.841]                       for (pkg in "future.apply") {
[08:26:23.841]                         base::loadNamespace(pkg)
[08:26:23.841]                         base::library(pkg, character.only = TRUE)
[08:26:23.841]                       }
[08:26:23.841]                     })
[08:26:23.841]                   }
[08:26:23.841]                   ...future.strategy.old <- future::plan("list")
[08:26:23.841]                   options(future.plan = NULL)
[08:26:23.841]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:23.841]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:23.841]                 }
[08:26:23.841]                 ...future.workdir <- getwd()
[08:26:23.841]             }
[08:26:23.841]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:23.841]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:23.841]         }
[08:26:23.841]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:23.841]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:23.841]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:23.841]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:23.841]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:23.841]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:23.841]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:23.841]             base::names(...future.oldOptions))
[08:26:23.841]     }
[08:26:23.841]     if (FALSE) {
[08:26:23.841]     }
[08:26:23.841]     else {
[08:26:23.841]         if (TRUE) {
[08:26:23.841]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:23.841]                 open = "w")
[08:26:23.841]         }
[08:26:23.841]         else {
[08:26:23.841]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:23.841]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:23.841]         }
[08:26:23.841]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:23.841]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:23.841]             base::sink(type = "output", split = FALSE)
[08:26:23.841]             base::close(...future.stdout)
[08:26:23.841]         }, add = TRUE)
[08:26:23.841]     }
[08:26:23.841]     ...future.frame <- base::sys.nframe()
[08:26:23.841]     ...future.conditions <- base::list()
[08:26:23.841]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:23.841]     if (FALSE) {
[08:26:23.841]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:23.841]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:23.841]     }
[08:26:23.841]     ...future.result <- base::tryCatch({
[08:26:23.841]         base::withCallingHandlers({
[08:26:23.841]             ...future.value <- base::withVisible(base::local({
[08:26:23.841]                 ...future.makeSendCondition <- base::local({
[08:26:23.841]                   sendCondition <- NULL
[08:26:23.841]                   function(frame = 1L) {
[08:26:23.841]                     if (is.function(sendCondition)) 
[08:26:23.841]                       return(sendCondition)
[08:26:23.841]                     ns <- getNamespace("parallel")
[08:26:23.841]                     if (exists("sendData", mode = "function", 
[08:26:23.841]                       envir = ns)) {
[08:26:23.841]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:23.841]                         envir = ns)
[08:26:23.841]                       envir <- sys.frame(frame)
[08:26:23.841]                       master <- NULL
[08:26:23.841]                       while (!identical(envir, .GlobalEnv) && 
[08:26:23.841]                         !identical(envir, emptyenv())) {
[08:26:23.841]                         if (exists("master", mode = "list", envir = envir, 
[08:26:23.841]                           inherits = FALSE)) {
[08:26:23.841]                           master <- get("master", mode = "list", 
[08:26:23.841]                             envir = envir, inherits = FALSE)
[08:26:23.841]                           if (inherits(master, c("SOCKnode", 
[08:26:23.841]                             "SOCK0node"))) {
[08:26:23.841]                             sendCondition <<- function(cond) {
[08:26:23.841]                               data <- list(type = "VALUE", value = cond, 
[08:26:23.841]                                 success = TRUE)
[08:26:23.841]                               parallel_sendData(master, data)
[08:26:23.841]                             }
[08:26:23.841]                             return(sendCondition)
[08:26:23.841]                           }
[08:26:23.841]                         }
[08:26:23.841]                         frame <- frame + 1L
[08:26:23.841]                         envir <- sys.frame(frame)
[08:26:23.841]                       }
[08:26:23.841]                     }
[08:26:23.841]                     sendCondition <<- function(cond) NULL
[08:26:23.841]                   }
[08:26:23.841]                 })
[08:26:23.841]                 withCallingHandlers({
[08:26:23.841]                   {
[08:26:23.841]                     do.call(function(...) {
[08:26:23.841]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:23.841]                       if (!identical(...future.globals.maxSize.org, 
[08:26:23.841]                         ...future.globals.maxSize)) {
[08:26:23.841]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:23.841]                         on.exit(options(oopts), add = TRUE)
[08:26:23.841]                       }
[08:26:23.841]                       {
[08:26:23.841]                         lapply(seq_along(...future.elements_ii), 
[08:26:23.841]                           FUN = function(jj) {
[08:26:23.841]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:23.841]                             ...future.FUN(...future.X_jj, ...)
[08:26:23.841]                           })
[08:26:23.841]                       }
[08:26:23.841]                     }, args = future.call.arguments)
[08:26:23.841]                   }
[08:26:23.841]                 }, immediateCondition = function(cond) {
[08:26:23.841]                   sendCondition <- ...future.makeSendCondition()
[08:26:23.841]                   sendCondition(cond)
[08:26:23.841]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:23.841]                   {
[08:26:23.841]                     inherits <- base::inherits
[08:26:23.841]                     invokeRestart <- base::invokeRestart
[08:26:23.841]                     is.null <- base::is.null
[08:26:23.841]                     muffled <- FALSE
[08:26:23.841]                     if (inherits(cond, "message")) {
[08:26:23.841]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:23.841]                       if (muffled) 
[08:26:23.841]                         invokeRestart("muffleMessage")
[08:26:23.841]                     }
[08:26:23.841]                     else if (inherits(cond, "warning")) {
[08:26:23.841]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:23.841]                       if (muffled) 
[08:26:23.841]                         invokeRestart("muffleWarning")
[08:26:23.841]                     }
[08:26:23.841]                     else if (inherits(cond, "condition")) {
[08:26:23.841]                       if (!is.null(pattern)) {
[08:26:23.841]                         computeRestarts <- base::computeRestarts
[08:26:23.841]                         grepl <- base::grepl
[08:26:23.841]                         restarts <- computeRestarts(cond)
[08:26:23.841]                         for (restart in restarts) {
[08:26:23.841]                           name <- restart$name
[08:26:23.841]                           if (is.null(name)) 
[08:26:23.841]                             next
[08:26:23.841]                           if (!grepl(pattern, name)) 
[08:26:23.841]                             next
[08:26:23.841]                           invokeRestart(restart)
[08:26:23.841]                           muffled <- TRUE
[08:26:23.841]                           break
[08:26:23.841]                         }
[08:26:23.841]                       }
[08:26:23.841]                     }
[08:26:23.841]                     invisible(muffled)
[08:26:23.841]                   }
[08:26:23.841]                   muffleCondition(cond)
[08:26:23.841]                 })
[08:26:23.841]             }))
[08:26:23.841]             future::FutureResult(value = ...future.value$value, 
[08:26:23.841]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:23.841]                   ...future.rng), globalenv = if (FALSE) 
[08:26:23.841]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:23.841]                     ...future.globalenv.names))
[08:26:23.841]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:23.841]         }, condition = base::local({
[08:26:23.841]             c <- base::c
[08:26:23.841]             inherits <- base::inherits
[08:26:23.841]             invokeRestart <- base::invokeRestart
[08:26:23.841]             length <- base::length
[08:26:23.841]             list <- base::list
[08:26:23.841]             seq.int <- base::seq.int
[08:26:23.841]             signalCondition <- base::signalCondition
[08:26:23.841]             sys.calls <- base::sys.calls
[08:26:23.841]             `[[` <- base::`[[`
[08:26:23.841]             `+` <- base::`+`
[08:26:23.841]             `<<-` <- base::`<<-`
[08:26:23.841]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:23.841]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:23.841]                   3L)]
[08:26:23.841]             }
[08:26:23.841]             function(cond) {
[08:26:23.841]                 is_error <- inherits(cond, "error")
[08:26:23.841]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:23.841]                   NULL)
[08:26:23.841]                 if (is_error) {
[08:26:23.841]                   sessionInformation <- function() {
[08:26:23.841]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:23.841]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:23.841]                       search = base::search(), system = base::Sys.info())
[08:26:23.841]                   }
[08:26:23.841]                   ...future.conditions[[length(...future.conditions) + 
[08:26:23.841]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:23.841]                     cond$call), session = sessionInformation(), 
[08:26:23.841]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:23.841]                   signalCondition(cond)
[08:26:23.841]                 }
[08:26:23.841]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:23.841]                 "immediateCondition"))) {
[08:26:23.841]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:23.841]                   ...future.conditions[[length(...future.conditions) + 
[08:26:23.841]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:23.841]                   if (TRUE && !signal) {
[08:26:23.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:23.841]                     {
[08:26:23.841]                       inherits <- base::inherits
[08:26:23.841]                       invokeRestart <- base::invokeRestart
[08:26:23.841]                       is.null <- base::is.null
[08:26:23.841]                       muffled <- FALSE
[08:26:23.841]                       if (inherits(cond, "message")) {
[08:26:23.841]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:23.841]                         if (muffled) 
[08:26:23.841]                           invokeRestart("muffleMessage")
[08:26:23.841]                       }
[08:26:23.841]                       else if (inherits(cond, "warning")) {
[08:26:23.841]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:23.841]                         if (muffled) 
[08:26:23.841]                           invokeRestart("muffleWarning")
[08:26:23.841]                       }
[08:26:23.841]                       else if (inherits(cond, "condition")) {
[08:26:23.841]                         if (!is.null(pattern)) {
[08:26:23.841]                           computeRestarts <- base::computeRestarts
[08:26:23.841]                           grepl <- base::grepl
[08:26:23.841]                           restarts <- computeRestarts(cond)
[08:26:23.841]                           for (restart in restarts) {
[08:26:23.841]                             name <- restart$name
[08:26:23.841]                             if (is.null(name)) 
[08:26:23.841]                               next
[08:26:23.841]                             if (!grepl(pattern, name)) 
[08:26:23.841]                               next
[08:26:23.841]                             invokeRestart(restart)
[08:26:23.841]                             muffled <- TRUE
[08:26:23.841]                             break
[08:26:23.841]                           }
[08:26:23.841]                         }
[08:26:23.841]                       }
[08:26:23.841]                       invisible(muffled)
[08:26:23.841]                     }
[08:26:23.841]                     muffleCondition(cond, pattern = "^muffle")
[08:26:23.841]                   }
[08:26:23.841]                 }
[08:26:23.841]                 else {
[08:26:23.841]                   if (TRUE) {
[08:26:23.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:23.841]                     {
[08:26:23.841]                       inherits <- base::inherits
[08:26:23.841]                       invokeRestart <- base::invokeRestart
[08:26:23.841]                       is.null <- base::is.null
[08:26:23.841]                       muffled <- FALSE
[08:26:23.841]                       if (inherits(cond, "message")) {
[08:26:23.841]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:23.841]                         if (muffled) 
[08:26:23.841]                           invokeRestart("muffleMessage")
[08:26:23.841]                       }
[08:26:23.841]                       else if (inherits(cond, "warning")) {
[08:26:23.841]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:23.841]                         if (muffled) 
[08:26:23.841]                           invokeRestart("muffleWarning")
[08:26:23.841]                       }
[08:26:23.841]                       else if (inherits(cond, "condition")) {
[08:26:23.841]                         if (!is.null(pattern)) {
[08:26:23.841]                           computeRestarts <- base::computeRestarts
[08:26:23.841]                           grepl <- base::grepl
[08:26:23.841]                           restarts <- computeRestarts(cond)
[08:26:23.841]                           for (restart in restarts) {
[08:26:23.841]                             name <- restart$name
[08:26:23.841]                             if (is.null(name)) 
[08:26:23.841]                               next
[08:26:23.841]                             if (!grepl(pattern, name)) 
[08:26:23.841]                               next
[08:26:23.841]                             invokeRestart(restart)
[08:26:23.841]                             muffled <- TRUE
[08:26:23.841]                             break
[08:26:23.841]                           }
[08:26:23.841]                         }
[08:26:23.841]                       }
[08:26:23.841]                       invisible(muffled)
[08:26:23.841]                     }
[08:26:23.841]                     muffleCondition(cond, pattern = "^muffle")
[08:26:23.841]                   }
[08:26:23.841]                 }
[08:26:23.841]             }
[08:26:23.841]         }))
[08:26:23.841]     }, error = function(ex) {
[08:26:23.841]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:23.841]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:23.841]                 ...future.rng), started = ...future.startTime, 
[08:26:23.841]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:23.841]             version = "1.8"), class = "FutureResult")
[08:26:23.841]     }, finally = {
[08:26:23.841]         if (!identical(...future.workdir, getwd())) 
[08:26:23.841]             setwd(...future.workdir)
[08:26:23.841]         {
[08:26:23.841]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:23.841]                 ...future.oldOptions$nwarnings <- NULL
[08:26:23.841]             }
[08:26:23.841]             base::options(...future.oldOptions)
[08:26:23.841]             if (.Platform$OS.type == "windows") {
[08:26:23.841]                 old_names <- names(...future.oldEnvVars)
[08:26:23.841]                 envs <- base::Sys.getenv()
[08:26:23.841]                 names <- names(envs)
[08:26:23.841]                 common <- intersect(names, old_names)
[08:26:23.841]                 added <- setdiff(names, old_names)
[08:26:23.841]                 removed <- setdiff(old_names, names)
[08:26:23.841]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:23.841]                   envs[common]]
[08:26:23.841]                 NAMES <- toupper(changed)
[08:26:23.841]                 args <- list()
[08:26:23.841]                 for (kk in seq_along(NAMES)) {
[08:26:23.841]                   name <- changed[[kk]]
[08:26:23.841]                   NAME <- NAMES[[kk]]
[08:26:23.841]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:23.841]                     next
[08:26:23.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:23.841]                 }
[08:26:23.841]                 NAMES <- toupper(added)
[08:26:23.841]                 for (kk in seq_along(NAMES)) {
[08:26:23.841]                   name <- added[[kk]]
[08:26:23.841]                   NAME <- NAMES[[kk]]
[08:26:23.841]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:23.841]                     next
[08:26:23.841]                   args[[name]] <- ""
[08:26:23.841]                 }
[08:26:23.841]                 NAMES <- toupper(removed)
[08:26:23.841]                 for (kk in seq_along(NAMES)) {
[08:26:23.841]                   name <- removed[[kk]]
[08:26:23.841]                   NAME <- NAMES[[kk]]
[08:26:23.841]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:23.841]                     next
[08:26:23.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:23.841]                 }
[08:26:23.841]                 if (length(args) > 0) 
[08:26:23.841]                   base::do.call(base::Sys.setenv, args = args)
[08:26:23.841]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:23.841]             }
[08:26:23.841]             else {
[08:26:23.841]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:23.841]             }
[08:26:23.841]             {
[08:26:23.841]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:23.841]                   0L) {
[08:26:23.841]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:23.841]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:23.841]                   base::options(opts)
[08:26:23.841]                 }
[08:26:23.841]                 {
[08:26:23.841]                   {
[08:26:23.841]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:23.841]                     NULL
[08:26:23.841]                   }
[08:26:23.841]                   options(future.plan = NULL)
[08:26:23.841]                   if (is.na(NA_character_)) 
[08:26:23.841]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:23.841]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:23.841]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:23.841]                     .init = FALSE)
[08:26:23.841]                 }
[08:26:23.841]             }
[08:26:23.841]         }
[08:26:23.841]     })
[08:26:23.841]     if (TRUE) {
[08:26:23.841]         base::sink(type = "output", split = FALSE)
[08:26:23.841]         if (TRUE) {
[08:26:23.841]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:23.841]         }
[08:26:23.841]         else {
[08:26:23.841]             ...future.result["stdout"] <- base::list(NULL)
[08:26:23.841]         }
[08:26:23.841]         base::close(...future.stdout)
[08:26:23.841]         ...future.stdout <- NULL
[08:26:23.841]     }
[08:26:23.841]     ...future.result$conditions <- ...future.conditions
[08:26:23.841]     ...future.result$finished <- base::Sys.time()
[08:26:23.841]     ...future.result
[08:26:23.841] }
[08:26:23.844] Exporting 11 global objects (12.56 KiB) to cluster node #2 ...
[08:26:23.844] Exporting ‘...future.FUN’ (4.06 KiB) to cluster node #2 ...
[08:26:23.886] Exporting ‘...future.FUN’ (4.06 KiB) to cluster node #2 ... DONE
[08:26:23.886] Exporting ‘x_FUN’ (35 bytes) to cluster node #2 ...
[08:26:23.886] Exporting ‘x_FUN’ (35 bytes) to cluster node #2 ... DONE
[08:26:23.886] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[08:26:23.887] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[08:26:23.887] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[08:26:23.928] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[08:26:23.929] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[08:26:23.970] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[08:26:23.970] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[08:26:23.970] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[08:26:23.970] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[08:26:23.971] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[08:26:23.971] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:26:23.971] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:26:23.971] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ...
[08:26:23.972] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ... DONE
[08:26:23.972] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:26:23.972] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:26:23.972] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:26:23.973] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:26:23.973] Exporting 11 global objects (12.56 KiB) to cluster node #2 ... DONE
[08:26:23.974] MultisessionFuture started
[08:26:23.974] - Launch lazy future ... done
[08:26:23.974] run() for ‘MultisessionFuture’ ... done
[08:26:23.974] Created future:
[08:26:23.974] MultisessionFuture:
[08:26:23.974] Label: ‘future_vapply-2’
[08:26:23.974] Expression:
[08:26:23.974] {
[08:26:23.974]     do.call(function(...) {
[08:26:23.974]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:23.974]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:23.974]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:23.974]             on.exit(options(oopts), add = TRUE)
[08:26:23.974]         }
[08:26:23.974]         {
[08:26:23.974]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:23.974]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:23.974]                 ...future.FUN(...future.X_jj, ...)
[08:26:23.974]             })
[08:26:23.974]         }
[08:26:23.974]     }, args = future.call.arguments)
[08:26:23.974] }
[08:26:23.974] Lazy evaluation: FALSE
[08:26:23.974] Asynchronous evaluation: TRUE
[08:26:23.974] Local evaluation: TRUE
[08:26:23.974] Environment: R_GlobalEnv
[08:26:23.974] Capture standard output: TRUE
[08:26:23.974] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:23.974] Globals: 11 objects totaling 12.31 KiB (function ‘...future.FUN’ of 4.06 KiB, function ‘x_FUN’ of 35 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:23.974] Packages: 1 packages (‘future.apply’)
[08:26:23.974] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:23.974] Resolved: FALSE
[08:26:23.974] Value: <not collected>
[08:26:23.974] Conditions captured: <none>
[08:26:23.974] Early signaling: FALSE
[08:26:23.974] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:23.974] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:23.986] Chunk #2 of 2 ... DONE
[08:26:23.986] Launching 2 futures (chunks) ... DONE
[08:26:23.986] Resolving 2 futures (chunks) ...
[08:26:23.986] resolve() on list ...
[08:26:23.986]  recursive: 0
[08:26:23.986]  length: 2
[08:26:23.986] 
[08:26:23.987] receiveMessageFromWorker() for ClusterFuture ...
[08:26:23.987] - Validating connection of MultisessionFuture
[08:26:23.987] - received message: FutureResult
[08:26:23.987] - Received FutureResult
[08:26:23.987] - Erased future from FutureRegistry
[08:26:23.988] result() for ClusterFuture ...
[08:26:23.988] - result already collected: FutureResult
[08:26:23.988] result() for ClusterFuture ... done
[08:26:23.988] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:23.988] Future #1
[08:26:23.988] result() for ClusterFuture ...
[08:26:23.988] - result already collected: FutureResult
[08:26:23.988] result() for ClusterFuture ... done
[08:26:23.988] result() for ClusterFuture ...
[08:26:23.988] - result already collected: FutureResult
[08:26:23.988] result() for ClusterFuture ... done
[08:26:23.989] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:26:23.989] - nx: 2
[08:26:23.989] - relay: TRUE
[08:26:23.989] - stdout: TRUE
[08:26:23.991] - signal: TRUE
[08:26:23.991] - resignal: FALSE
[08:26:23.991] - force: TRUE
[08:26:23.991] - relayed: [n=2] FALSE, FALSE
[08:26:23.991] - queued futures: [n=2] FALSE, FALSE
[08:26:23.991]  - until=1
[08:26:23.992]  - relaying element #1
[08:26:23.992] result() for ClusterFuture ...
[08:26:23.992] - result already collected: FutureResult
[08:26:23.992] result() for ClusterFuture ... done
[08:26:23.992] result() for ClusterFuture ...
[08:26:23.992] - result already collected: FutureResult
[08:26:23.992] result() for ClusterFuture ... done
[08:26:23.992] result() for ClusterFuture ...
[08:26:23.992] - result already collected: FutureResult
[08:26:23.992] result() for ClusterFuture ... done
[08:26:23.992] result() for ClusterFuture ...
[08:26:23.992] - result already collected: FutureResult
[08:26:23.993] result() for ClusterFuture ... done
[08:26:23.993] - relayed: [n=2] TRUE, FALSE
[08:26:23.993] - queued futures: [n=2] TRUE, FALSE
[08:26:23.993] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:26:23.993]  length: 1 (resolved future 1)
[08:26:24.016] receiveMessageFromWorker() for ClusterFuture ...
[08:26:24.016] - Validating connection of MultisessionFuture
[08:26:24.017] - received message: FutureResult
[08:26:24.017] - Received FutureResult
[08:26:24.017] - Erased future from FutureRegistry
[08:26:24.017] result() for ClusterFuture ...
[08:26:24.017] - result already collected: FutureResult
[08:26:24.017] result() for ClusterFuture ... done
[08:26:24.017] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:24.017] Future #2
[08:26:24.017] result() for ClusterFuture ...
[08:26:24.018] - result already collected: FutureResult
[08:26:24.018] result() for ClusterFuture ... done
[08:26:24.018] result() for ClusterFuture ...
[08:26:24.018] - result already collected: FutureResult
[08:26:24.018] result() for ClusterFuture ... done
[08:26:24.018] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:26:24.018] - nx: 2
[08:26:24.018] - relay: TRUE
[08:26:24.018] - stdout: TRUE
[08:26:24.018] - signal: TRUE
[08:26:24.018] - resignal: FALSE
[08:26:24.018] - force: TRUE
[08:26:24.019] - relayed: [n=2] TRUE, FALSE
[08:26:24.019] - queued futures: [n=2] TRUE, FALSE
[08:26:24.019]  - until=2
[08:26:24.019]  - relaying element #2
[08:26:24.019] result() for ClusterFuture ...
[08:26:24.019] - result already collected: FutureResult
[08:26:24.019] result() for ClusterFuture ... done
[08:26:24.019] result() for ClusterFuture ...
[08:26:24.019] - result already collected: FutureResult
[08:26:24.019] result() for ClusterFuture ... done
[08:26:24.019] result() for ClusterFuture ...
[08:26:24.019] - result already collected: FutureResult
[08:26:24.020] result() for ClusterFuture ... done
[08:26:24.020] result() for ClusterFuture ...
[08:26:24.020] - result already collected: FutureResult
[08:26:24.020] result() for ClusterFuture ... done
[08:26:24.020] - relayed: [n=2] TRUE, TRUE
[08:26:24.020] - queued futures: [n=2] TRUE, TRUE
[08:26:24.020] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:26:24.020]  length: 0 (resolved future 2)
[08:26:24.020] Relaying remaining futures
[08:26:24.020] signalConditionsASAP(NULL, pos=0) ...
[08:26:24.020] - nx: 2
[08:26:24.020] - relay: TRUE
[08:26:24.021] - stdout: TRUE
[08:26:24.021] - signal: TRUE
[08:26:24.021] - resignal: FALSE
[08:26:24.021] - force: TRUE
[08:26:24.021] - relayed: [n=2] TRUE, TRUE
[08:26:24.021] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:24.021] - relayed: [n=2] TRUE, TRUE
[08:26:24.021] - queued futures: [n=2] TRUE, TRUE
[08:26:24.021] signalConditionsASAP(NULL, pos=0) ... done
[08:26:24.021] resolve() on list ... DONE
[08:26:24.021] result() for ClusterFuture ...
[08:26:24.022] - result already collected: FutureResult
[08:26:24.022] result() for ClusterFuture ... done
[08:26:24.022] result() for ClusterFuture ...
[08:26:24.022] - result already collected: FutureResult
[08:26:24.022] result() for ClusterFuture ... done
[08:26:24.022] result() for ClusterFuture ...
[08:26:24.022] - result already collected: FutureResult
[08:26:24.022] result() for ClusterFuture ... done
[08:26:24.022] result() for ClusterFuture ...
[08:26:24.022] - result already collected: FutureResult
[08:26:24.022] result() for ClusterFuture ... done
[08:26:24.022]  - Number of value chunks collected: 2
[08:26:24.023] Resolving 2 futures (chunks) ... DONE
[08:26:24.023] Reducing values from 2 chunks ...
[08:26:24.023]  - Number of values collected after concatenation: 10
[08:26:24.023]  - Number of values expected: 10
[08:26:24.023] Reducing values from 2 chunks ... DONE
[08:26:24.023] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[08:26:24.024] future_lapply() ...
[08:26:24.027] Number of chunks: 2
[08:26:24.027] getGlobalsAndPackagesXApply() ...
[08:26:24.027]  - future.globals: TRUE
[08:26:24.027] getGlobalsAndPackages() ...
[08:26:24.028] Searching for globals...
[08:26:24.031] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[08:26:24.031] Searching for globals ... DONE
[08:26:24.031] Resolving globals: FALSE
[08:26:24.032] The total size of the 7 globals is 13.34 KiB (13657 bytes)
[08:26:24.033] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.89 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:24.033] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:24.033] - packages: [1] ‘future.apply’
[08:26:24.033] getGlobalsAndPackages() ... DONE
[08:26:24.033]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:24.033]  - needed namespaces: [n=1] ‘future.apply’
[08:26:24.033] Finding globals ... DONE
[08:26:24.033]  - use_args: TRUE
[08:26:24.034]  - Getting '...' globals ...
[08:26:24.034] resolve() on list ...
[08:26:24.034]  recursive: 0
[08:26:24.034]  length: 1
[08:26:24.034]  elements: ‘...’
[08:26:24.034]  length: 0 (resolved future 1)
[08:26:24.034] resolve() on list ... DONE
[08:26:24.035]    - '...' content: [n=0] 
[08:26:24.035] List of 1
[08:26:24.035]  $ ...: list()
[08:26:24.035]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:24.035]  - attr(*, "where")=List of 1
[08:26:24.035]   ..$ ...:<environment: 0x562ca7bf19e8> 
[08:26:24.035]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:24.035]  - attr(*, "resolved")= logi TRUE
[08:26:24.035]  - attr(*, "total_size")= num NA
[08:26:24.037]  - Getting '...' globals ... DONE
[08:26:24.037] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:24.037] List of 8
[08:26:24.037]  $ ...future.FUN:function (x, ...)  
[08:26:24.037]  $ x_FUN        :function (x)  
[08:26:24.037]  $ times        : int 2
[08:26:24.037]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:24.037]  $ stop_if_not  :function (...)  
[08:26:24.037]  $ dim          : NULL
[08:26:24.037]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:24.037]  $ ...          : list()
[08:26:24.037]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:24.037]  - attr(*, "where")=List of 8
[08:26:24.037]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:24.037]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:24.037]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:24.037]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:24.037]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:24.037]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:24.037]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:24.037]   ..$ ...          :<environment: 0x562ca7bf19e8> 
[08:26:24.037]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:24.037]  - attr(*, "resolved")= logi FALSE
[08:26:24.037]  - attr(*, "total_size")= num 24454
[08:26:24.042] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:24.043] getGlobalsAndPackagesXApply() ... DONE
[08:26:24.043] Number of futures (= number of chunks): 2
[08:26:24.043] Launching 2 futures (chunks) ...
[08:26:24.043] Chunk #1 of 2 ...
[08:26:24.043]  - Finding globals in 'X' for chunk #1 ...
[08:26:24.043] getGlobalsAndPackages() ...
[08:26:24.043] Searching for globals...
[08:26:24.044] 
[08:26:24.044] Searching for globals ... DONE
[08:26:24.044] - globals: [0] <none>
[08:26:24.044] getGlobalsAndPackages() ... DONE
[08:26:24.044]    + additional globals found: [n=0] 
[08:26:24.044]    + additional namespaces needed: [n=0] 
[08:26:24.044]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:24.044]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:24.044]  - seeds: <none>
[08:26:24.044]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:24.044] getGlobalsAndPackages() ...
[08:26:24.044] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:24.045] Resolving globals: FALSE
[08:26:24.045] Tweak future expression to call with '...' arguments ...
[08:26:24.045] {
[08:26:24.045]     do.call(function(...) {
[08:26:24.045]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:24.045]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:24.045]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:24.045]             on.exit(options(oopts), add = TRUE)
[08:26:24.045]         }
[08:26:24.045]         {
[08:26:24.045]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:24.045]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:24.045]                 ...future.FUN(...future.X_jj, ...)
[08:26:24.045]             })
[08:26:24.045]         }
[08:26:24.045]     }, args = future.call.arguments)
[08:26:24.045] }
[08:26:24.045] Tweak future expression to call with '...' arguments ... DONE
[08:26:24.046] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:24.046] - packages: [1] ‘future.apply’
[08:26:24.046] getGlobalsAndPackages() ... DONE
[08:26:24.046] run() for ‘Future’ ...
[08:26:24.046] - state: ‘created’
[08:26:24.046] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:24.061] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:24.061] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:24.061]   - Field: ‘node’
[08:26:24.061]   - Field: ‘label’
[08:26:24.061]   - Field: ‘local’
[08:26:24.061]   - Field: ‘owner’
[08:26:24.061]   - Field: ‘envir’
[08:26:24.061]   - Field: ‘workers’
[08:26:24.061]   - Field: ‘packages’
[08:26:24.062]   - Field: ‘gc’
[08:26:24.062]   - Field: ‘conditions’
[08:26:24.062]   - Field: ‘persistent’
[08:26:24.062]   - Field: ‘expr’
[08:26:24.062]   - Field: ‘uuid’
[08:26:24.062]   - Field: ‘seed’
[08:26:24.062]   - Field: ‘version’
[08:26:24.062]   - Field: ‘result’
[08:26:24.062]   - Field: ‘asynchronous’
[08:26:24.062]   - Field: ‘calls’
[08:26:24.062]   - Field: ‘globals’
[08:26:24.062]   - Field: ‘stdout’
[08:26:24.063]   - Field: ‘earlySignal’
[08:26:24.063]   - Field: ‘lazy’
[08:26:24.063]   - Field: ‘state’
[08:26:24.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:24.063] - Launch lazy future ...
[08:26:24.063] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:24.063] Packages needed by future strategies (n = 0): <none>
[08:26:24.064] {
[08:26:24.064]     {
[08:26:24.064]         {
[08:26:24.064]             ...future.startTime <- base::Sys.time()
[08:26:24.064]             {
[08:26:24.064]                 {
[08:26:24.064]                   {
[08:26:24.064]                     {
[08:26:24.064]                       {
[08:26:24.064]                         base::local({
[08:26:24.064]                           has_future <- base::requireNamespace("future", 
[08:26:24.064]                             quietly = TRUE)
[08:26:24.064]                           if (has_future) {
[08:26:24.064]                             ns <- base::getNamespace("future")
[08:26:24.064]                             version <- ns[[".package"]][["version"]]
[08:26:24.064]                             if (is.null(version)) 
[08:26:24.064]                               version <- utils::packageVersion("future")
[08:26:24.064]                           }
[08:26:24.064]                           else {
[08:26:24.064]                             version <- NULL
[08:26:24.064]                           }
[08:26:24.064]                           if (!has_future || version < "1.8.0") {
[08:26:24.064]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:24.064]                               "", base::R.version$version.string), 
[08:26:24.064]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:24.064]                                 base::R.version$platform, 8 * 
[08:26:24.064]                                   base::.Machine$sizeof.pointer), 
[08:26:24.064]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:24.064]                                 "release", "version")], collapse = " "), 
[08:26:24.064]                               hostname = base::Sys.info()[["nodename"]])
[08:26:24.064]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:24.064]                               info)
[08:26:24.064]                             info <- base::paste(info, collapse = "; ")
[08:26:24.064]                             if (!has_future) {
[08:26:24.064]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:24.064]                                 info)
[08:26:24.064]                             }
[08:26:24.064]                             else {
[08:26:24.064]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:24.064]                                 info, version)
[08:26:24.064]                             }
[08:26:24.064]                             base::stop(msg)
[08:26:24.064]                           }
[08:26:24.064]                         })
[08:26:24.064]                       }
[08:26:24.064]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:24.064]                       base::options(mc.cores = 1L)
[08:26:24.064]                     }
[08:26:24.064]                     base::local({
[08:26:24.064]                       for (pkg in "future.apply") {
[08:26:24.064]                         base::loadNamespace(pkg)
[08:26:24.064]                         base::library(pkg, character.only = TRUE)
[08:26:24.064]                       }
[08:26:24.064]                     })
[08:26:24.064]                   }
[08:26:24.064]                   ...future.strategy.old <- future::plan("list")
[08:26:24.064]                   options(future.plan = NULL)
[08:26:24.064]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:24.064]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:24.064]                 }
[08:26:24.064]                 ...future.workdir <- getwd()
[08:26:24.064]             }
[08:26:24.064]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:24.064]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:24.064]         }
[08:26:24.064]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:24.064]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:24.064]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:24.064]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:24.064]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:24.064]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:24.064]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:24.064]             base::names(...future.oldOptions))
[08:26:24.064]     }
[08:26:24.064]     if (FALSE) {
[08:26:24.064]     }
[08:26:24.064]     else {
[08:26:24.064]         if (TRUE) {
[08:26:24.064]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:24.064]                 open = "w")
[08:26:24.064]         }
[08:26:24.064]         else {
[08:26:24.064]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:24.064]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:24.064]         }
[08:26:24.064]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:24.064]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:24.064]             base::sink(type = "output", split = FALSE)
[08:26:24.064]             base::close(...future.stdout)
[08:26:24.064]         }, add = TRUE)
[08:26:24.064]     }
[08:26:24.064]     ...future.frame <- base::sys.nframe()
[08:26:24.064]     ...future.conditions <- base::list()
[08:26:24.064]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:24.064]     if (FALSE) {
[08:26:24.064]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:24.064]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:24.064]     }
[08:26:24.064]     ...future.result <- base::tryCatch({
[08:26:24.064]         base::withCallingHandlers({
[08:26:24.064]             ...future.value <- base::withVisible(base::local({
[08:26:24.064]                 ...future.makeSendCondition <- base::local({
[08:26:24.064]                   sendCondition <- NULL
[08:26:24.064]                   function(frame = 1L) {
[08:26:24.064]                     if (is.function(sendCondition)) 
[08:26:24.064]                       return(sendCondition)
[08:26:24.064]                     ns <- getNamespace("parallel")
[08:26:24.064]                     if (exists("sendData", mode = "function", 
[08:26:24.064]                       envir = ns)) {
[08:26:24.064]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:24.064]                         envir = ns)
[08:26:24.064]                       envir <- sys.frame(frame)
[08:26:24.064]                       master <- NULL
[08:26:24.064]                       while (!identical(envir, .GlobalEnv) && 
[08:26:24.064]                         !identical(envir, emptyenv())) {
[08:26:24.064]                         if (exists("master", mode = "list", envir = envir, 
[08:26:24.064]                           inherits = FALSE)) {
[08:26:24.064]                           master <- get("master", mode = "list", 
[08:26:24.064]                             envir = envir, inherits = FALSE)
[08:26:24.064]                           if (inherits(master, c("SOCKnode", 
[08:26:24.064]                             "SOCK0node"))) {
[08:26:24.064]                             sendCondition <<- function(cond) {
[08:26:24.064]                               data <- list(type = "VALUE", value = cond, 
[08:26:24.064]                                 success = TRUE)
[08:26:24.064]                               parallel_sendData(master, data)
[08:26:24.064]                             }
[08:26:24.064]                             return(sendCondition)
[08:26:24.064]                           }
[08:26:24.064]                         }
[08:26:24.064]                         frame <- frame + 1L
[08:26:24.064]                         envir <- sys.frame(frame)
[08:26:24.064]                       }
[08:26:24.064]                     }
[08:26:24.064]                     sendCondition <<- function(cond) NULL
[08:26:24.064]                   }
[08:26:24.064]                 })
[08:26:24.064]                 withCallingHandlers({
[08:26:24.064]                   {
[08:26:24.064]                     do.call(function(...) {
[08:26:24.064]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:24.064]                       if (!identical(...future.globals.maxSize.org, 
[08:26:24.064]                         ...future.globals.maxSize)) {
[08:26:24.064]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:24.064]                         on.exit(options(oopts), add = TRUE)
[08:26:24.064]                       }
[08:26:24.064]                       {
[08:26:24.064]                         lapply(seq_along(...future.elements_ii), 
[08:26:24.064]                           FUN = function(jj) {
[08:26:24.064]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:24.064]                             ...future.FUN(...future.X_jj, ...)
[08:26:24.064]                           })
[08:26:24.064]                       }
[08:26:24.064]                     }, args = future.call.arguments)
[08:26:24.064]                   }
[08:26:24.064]                 }, immediateCondition = function(cond) {
[08:26:24.064]                   sendCondition <- ...future.makeSendCondition()
[08:26:24.064]                   sendCondition(cond)
[08:26:24.064]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:24.064]                   {
[08:26:24.064]                     inherits <- base::inherits
[08:26:24.064]                     invokeRestart <- base::invokeRestart
[08:26:24.064]                     is.null <- base::is.null
[08:26:24.064]                     muffled <- FALSE
[08:26:24.064]                     if (inherits(cond, "message")) {
[08:26:24.064]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:24.064]                       if (muffled) 
[08:26:24.064]                         invokeRestart("muffleMessage")
[08:26:24.064]                     }
[08:26:24.064]                     else if (inherits(cond, "warning")) {
[08:26:24.064]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:24.064]                       if (muffled) 
[08:26:24.064]                         invokeRestart("muffleWarning")
[08:26:24.064]                     }
[08:26:24.064]                     else if (inherits(cond, "condition")) {
[08:26:24.064]                       if (!is.null(pattern)) {
[08:26:24.064]                         computeRestarts <- base::computeRestarts
[08:26:24.064]                         grepl <- base::grepl
[08:26:24.064]                         restarts <- computeRestarts(cond)
[08:26:24.064]                         for (restart in restarts) {
[08:26:24.064]                           name <- restart$name
[08:26:24.064]                           if (is.null(name)) 
[08:26:24.064]                             next
[08:26:24.064]                           if (!grepl(pattern, name)) 
[08:26:24.064]                             next
[08:26:24.064]                           invokeRestart(restart)
[08:26:24.064]                           muffled <- TRUE
[08:26:24.064]                           break
[08:26:24.064]                         }
[08:26:24.064]                       }
[08:26:24.064]                     }
[08:26:24.064]                     invisible(muffled)
[08:26:24.064]                   }
[08:26:24.064]                   muffleCondition(cond)
[08:26:24.064]                 })
[08:26:24.064]             }))
[08:26:24.064]             future::FutureResult(value = ...future.value$value, 
[08:26:24.064]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:24.064]                   ...future.rng), globalenv = if (FALSE) 
[08:26:24.064]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:24.064]                     ...future.globalenv.names))
[08:26:24.064]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:24.064]         }, condition = base::local({
[08:26:24.064]             c <- base::c
[08:26:24.064]             inherits <- base::inherits
[08:26:24.064]             invokeRestart <- base::invokeRestart
[08:26:24.064]             length <- base::length
[08:26:24.064]             list <- base::list
[08:26:24.064]             seq.int <- base::seq.int
[08:26:24.064]             signalCondition <- base::signalCondition
[08:26:24.064]             sys.calls <- base::sys.calls
[08:26:24.064]             `[[` <- base::`[[`
[08:26:24.064]             `+` <- base::`+`
[08:26:24.064]             `<<-` <- base::`<<-`
[08:26:24.064]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:24.064]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:24.064]                   3L)]
[08:26:24.064]             }
[08:26:24.064]             function(cond) {
[08:26:24.064]                 is_error <- inherits(cond, "error")
[08:26:24.064]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:24.064]                   NULL)
[08:26:24.064]                 if (is_error) {
[08:26:24.064]                   sessionInformation <- function() {
[08:26:24.064]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:24.064]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:24.064]                       search = base::search(), system = base::Sys.info())
[08:26:24.064]                   }
[08:26:24.064]                   ...future.conditions[[length(...future.conditions) + 
[08:26:24.064]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:24.064]                     cond$call), session = sessionInformation(), 
[08:26:24.064]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:24.064]                   signalCondition(cond)
[08:26:24.064]                 }
[08:26:24.064]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:24.064]                 "immediateCondition"))) {
[08:26:24.064]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:24.064]                   ...future.conditions[[length(...future.conditions) + 
[08:26:24.064]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:24.064]                   if (TRUE && !signal) {
[08:26:24.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:24.064]                     {
[08:26:24.064]                       inherits <- base::inherits
[08:26:24.064]                       invokeRestart <- base::invokeRestart
[08:26:24.064]                       is.null <- base::is.null
[08:26:24.064]                       muffled <- FALSE
[08:26:24.064]                       if (inherits(cond, "message")) {
[08:26:24.064]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:24.064]                         if (muffled) 
[08:26:24.064]                           invokeRestart("muffleMessage")
[08:26:24.064]                       }
[08:26:24.064]                       else if (inherits(cond, "warning")) {
[08:26:24.064]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:24.064]                         if (muffled) 
[08:26:24.064]                           invokeRestart("muffleWarning")
[08:26:24.064]                       }
[08:26:24.064]                       else if (inherits(cond, "condition")) {
[08:26:24.064]                         if (!is.null(pattern)) {
[08:26:24.064]                           computeRestarts <- base::computeRestarts
[08:26:24.064]                           grepl <- base::grepl
[08:26:24.064]                           restarts <- computeRestarts(cond)
[08:26:24.064]                           for (restart in restarts) {
[08:26:24.064]                             name <- restart$name
[08:26:24.064]                             if (is.null(name)) 
[08:26:24.064]                               next
[08:26:24.064]                             if (!grepl(pattern, name)) 
[08:26:24.064]                               next
[08:26:24.064]                             invokeRestart(restart)
[08:26:24.064]                             muffled <- TRUE
[08:26:24.064]                             break
[08:26:24.064]                           }
[08:26:24.064]                         }
[08:26:24.064]                       }
[08:26:24.064]                       invisible(muffled)
[08:26:24.064]                     }
[08:26:24.064]                     muffleCondition(cond, pattern = "^muffle")
[08:26:24.064]                   }
[08:26:24.064]                 }
[08:26:24.064]                 else {
[08:26:24.064]                   if (TRUE) {
[08:26:24.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:24.064]                     {
[08:26:24.064]                       inherits <- base::inherits
[08:26:24.064]                       invokeRestart <- base::invokeRestart
[08:26:24.064]                       is.null <- base::is.null
[08:26:24.064]                       muffled <- FALSE
[08:26:24.064]                       if (inherits(cond, "message")) {
[08:26:24.064]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:24.064]                         if (muffled) 
[08:26:24.064]                           invokeRestart("muffleMessage")
[08:26:24.064]                       }
[08:26:24.064]                       else if (inherits(cond, "warning")) {
[08:26:24.064]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:24.064]                         if (muffled) 
[08:26:24.064]                           invokeRestart("muffleWarning")
[08:26:24.064]                       }
[08:26:24.064]                       else if (inherits(cond, "condition")) {
[08:26:24.064]                         if (!is.null(pattern)) {
[08:26:24.064]                           computeRestarts <- base::computeRestarts
[08:26:24.064]                           grepl <- base::grepl
[08:26:24.064]                           restarts <- computeRestarts(cond)
[08:26:24.064]                           for (restart in restarts) {
[08:26:24.064]                             name <- restart$name
[08:26:24.064]                             if (is.null(name)) 
[08:26:24.064]                               next
[08:26:24.064]                             if (!grepl(pattern, name)) 
[08:26:24.064]                               next
[08:26:24.064]                             invokeRestart(restart)
[08:26:24.064]                             muffled <- TRUE
[08:26:24.064]                             break
[08:26:24.064]                           }
[08:26:24.064]                         }
[08:26:24.064]                       }
[08:26:24.064]                       invisible(muffled)
[08:26:24.064]                     }
[08:26:24.064]                     muffleCondition(cond, pattern = "^muffle")
[08:26:24.064]                   }
[08:26:24.064]                 }
[08:26:24.064]             }
[08:26:24.064]         }))
[08:26:24.064]     }, error = function(ex) {
[08:26:24.064]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:24.064]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:24.064]                 ...future.rng), started = ...future.startTime, 
[08:26:24.064]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:24.064]             version = "1.8"), class = "FutureResult")
[08:26:24.064]     }, finally = {
[08:26:24.064]         if (!identical(...future.workdir, getwd())) 
[08:26:24.064]             setwd(...future.workdir)
[08:26:24.064]         {
[08:26:24.064]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:24.064]                 ...future.oldOptions$nwarnings <- NULL
[08:26:24.064]             }
[08:26:24.064]             base::options(...future.oldOptions)
[08:26:24.064]             if (.Platform$OS.type == "windows") {
[08:26:24.064]                 old_names <- names(...future.oldEnvVars)
[08:26:24.064]                 envs <- base::Sys.getenv()
[08:26:24.064]                 names <- names(envs)
[08:26:24.064]                 common <- intersect(names, old_names)
[08:26:24.064]                 added <- setdiff(names, old_names)
[08:26:24.064]                 removed <- setdiff(old_names, names)
[08:26:24.064]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:24.064]                   envs[common]]
[08:26:24.064]                 NAMES <- toupper(changed)
[08:26:24.064]                 args <- list()
[08:26:24.064]                 for (kk in seq_along(NAMES)) {
[08:26:24.064]                   name <- changed[[kk]]
[08:26:24.064]                   NAME <- NAMES[[kk]]
[08:26:24.064]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:24.064]                     next
[08:26:24.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:24.064]                 }
[08:26:24.064]                 NAMES <- toupper(added)
[08:26:24.064]                 for (kk in seq_along(NAMES)) {
[08:26:24.064]                   name <- added[[kk]]
[08:26:24.064]                   NAME <- NAMES[[kk]]
[08:26:24.064]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:24.064]                     next
[08:26:24.064]                   args[[name]] <- ""
[08:26:24.064]                 }
[08:26:24.064]                 NAMES <- toupper(removed)
[08:26:24.064]                 for (kk in seq_along(NAMES)) {
[08:26:24.064]                   name <- removed[[kk]]
[08:26:24.064]                   NAME <- NAMES[[kk]]
[08:26:24.064]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:24.064]                     next
[08:26:24.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:24.064]                 }
[08:26:24.064]                 if (length(args) > 0) 
[08:26:24.064]                   base::do.call(base::Sys.setenv, args = args)
[08:26:24.064]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:24.064]             }
[08:26:24.064]             else {
[08:26:24.064]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:24.064]             }
[08:26:24.064]             {
[08:26:24.064]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:24.064]                   0L) {
[08:26:24.064]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:24.064]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:24.064]                   base::options(opts)
[08:26:24.064]                 }
[08:26:24.064]                 {
[08:26:24.064]                   {
[08:26:24.064]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:24.064]                     NULL
[08:26:24.064]                   }
[08:26:24.064]                   options(future.plan = NULL)
[08:26:24.064]                   if (is.na(NA_character_)) 
[08:26:24.064]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:24.064]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:24.064]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:24.064]                     .init = FALSE)
[08:26:24.064]                 }
[08:26:24.064]             }
[08:26:24.064]         }
[08:26:24.064]     })
[08:26:24.064]     if (TRUE) {
[08:26:24.064]         base::sink(type = "output", split = FALSE)
[08:26:24.064]         if (TRUE) {
[08:26:24.064]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:24.064]         }
[08:26:24.064]         else {
[08:26:24.064]             ...future.result["stdout"] <- base::list(NULL)
[08:26:24.064]         }
[08:26:24.064]         base::close(...future.stdout)
[08:26:24.064]         ...future.stdout <- NULL
[08:26:24.064]     }
[08:26:24.064]     ...future.result$conditions <- ...future.conditions
[08:26:24.064]     ...future.result$finished <- base::Sys.time()
[08:26:24.064]     ...future.result
[08:26:24.064] }
[08:26:24.067] Exporting 11 global objects (13.78 KiB) to cluster node #1 ...
[08:26:24.067] Exporting ‘...future.FUN’ (4.88 KiB) to cluster node #1 ...
[08:26:24.109] Exporting ‘...future.FUN’ (4.88 KiB) to cluster node #1 ... DONE
[08:26:24.109] Exporting ‘x_FUN’ (483 bytes) to cluster node #1 ...
[08:26:24.109] Exporting ‘x_FUN’ (483 bytes) to cluster node #1 ... DONE
[08:26:24.109] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[08:26:24.110] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[08:26:24.110] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[08:26:24.151] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[08:26:24.152] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[08:26:24.193] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[08:26:24.193] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[08:26:24.193] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[08:26:24.193] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[08:26:24.194] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[08:26:24.194] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:26:24.194] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:26:24.194] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ...
[08:26:24.195] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ... DONE
[08:26:24.195] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:26:24.195] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:26:24.195] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:26:24.196] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:26:24.196] Exporting 11 global objects (13.78 KiB) to cluster node #1 ... DONE
[08:26:24.196] MultisessionFuture started
[08:26:24.196] - Launch lazy future ... done
[08:26:24.197] run() for ‘MultisessionFuture’ ... done
[08:26:24.197] Created future:
[08:26:24.197] MultisessionFuture:
[08:26:24.197] Label: ‘future_vapply-1’
[08:26:24.197] Expression:
[08:26:24.197] {
[08:26:24.197]     do.call(function(...) {
[08:26:24.197]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:24.197]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:24.197]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:24.197]             on.exit(options(oopts), add = TRUE)
[08:26:24.197]         }
[08:26:24.197]         {
[08:26:24.197]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:24.197]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:24.197]                 ...future.FUN(...future.X_jj, ...)
[08:26:24.197]             })
[08:26:24.197]         }
[08:26:24.197]     }, args = future.call.arguments)
[08:26:24.197] }
[08:26:24.197] Lazy evaluation: FALSE
[08:26:24.197] Asynchronous evaluation: TRUE
[08:26:24.197] Local evaluation: TRUE
[08:26:24.197] Environment: R_GlobalEnv
[08:26:24.197] Capture standard output: TRUE
[08:26:24.197] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:24.197] Globals: 11 objects totaling 13.57 KiB (function ‘...future.FUN’ of 4.88 KiB, function ‘x_FUN’ of 483 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:24.197] Packages: 1 packages (‘future.apply’)
[08:26:24.197] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:24.197] Resolved: FALSE
[08:26:24.197] Value: <not collected>
[08:26:24.197] Conditions captured: <none>
[08:26:24.197] Early signaling: FALSE
[08:26:24.197] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:24.197] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:24.208] Chunk #1 of 2 ... DONE
[08:26:24.208] Chunk #2 of 2 ...
[08:26:24.209]  - Finding globals in 'X' for chunk #2 ...
[08:26:24.209] getGlobalsAndPackages() ...
[08:26:24.209] Searching for globals...
[08:26:24.209] 
[08:26:24.209] Searching for globals ... DONE
[08:26:24.209] - globals: [0] <none>
[08:26:24.209] getGlobalsAndPackages() ... DONE
[08:26:24.209]    + additional globals found: [n=0] 
[08:26:24.210]    + additional namespaces needed: [n=0] 
[08:26:24.210]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:24.210]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:24.210]  - seeds: <none>
[08:26:24.210]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:24.210] getGlobalsAndPackages() ...
[08:26:24.210] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:24.210] Resolving globals: FALSE
[08:26:24.210] Tweak future expression to call with '...' arguments ...
[08:26:24.210] {
[08:26:24.210]     do.call(function(...) {
[08:26:24.210]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:24.210]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:24.210]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:24.210]             on.exit(options(oopts), add = TRUE)
[08:26:24.210]         }
[08:26:24.210]         {
[08:26:24.210]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:24.210]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:24.210]                 ...future.FUN(...future.X_jj, ...)
[08:26:24.210]             })
[08:26:24.210]         }
[08:26:24.210]     }, args = future.call.arguments)
[08:26:24.210] }
[08:26:24.211] Tweak future expression to call with '...' arguments ... DONE
[08:26:24.211] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:24.211] - packages: [1] ‘future.apply’
[08:26:24.211] getGlobalsAndPackages() ... DONE
[08:26:24.212] run() for ‘Future’ ...
[08:26:24.212] - state: ‘created’
[08:26:24.212] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:24.226] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:24.226] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:24.226]   - Field: ‘node’
[08:26:24.226]   - Field: ‘label’
[08:26:24.227]   - Field: ‘local’
[08:26:24.227]   - Field: ‘owner’
[08:26:24.227]   - Field: ‘envir’
[08:26:24.227]   - Field: ‘workers’
[08:26:24.227]   - Field: ‘packages’
[08:26:24.227]   - Field: ‘gc’
[08:26:24.227]   - Field: ‘conditions’
[08:26:24.227]   - Field: ‘persistent’
[08:26:24.227]   - Field: ‘expr’
[08:26:24.227]   - Field: ‘uuid’
[08:26:24.227]   - Field: ‘seed’
[08:26:24.228]   - Field: ‘version’
[08:26:24.228]   - Field: ‘result’
[08:26:24.228]   - Field: ‘asynchronous’
[08:26:24.228]   - Field: ‘calls’
[08:26:24.228]   - Field: ‘globals’
[08:26:24.228]   - Field: ‘stdout’
[08:26:24.228]   - Field: ‘earlySignal’
[08:26:24.228]   - Field: ‘lazy’
[08:26:24.228]   - Field: ‘state’
[08:26:24.228] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:24.228] - Launch lazy future ...
[08:26:24.229] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:24.229] Packages needed by future strategies (n = 0): <none>
[08:26:24.229] {
[08:26:24.229]     {
[08:26:24.229]         {
[08:26:24.229]             ...future.startTime <- base::Sys.time()
[08:26:24.229]             {
[08:26:24.229]                 {
[08:26:24.229]                   {
[08:26:24.229]                     {
[08:26:24.229]                       {
[08:26:24.229]                         base::local({
[08:26:24.229]                           has_future <- base::requireNamespace("future", 
[08:26:24.229]                             quietly = TRUE)
[08:26:24.229]                           if (has_future) {
[08:26:24.229]                             ns <- base::getNamespace("future")
[08:26:24.229]                             version <- ns[[".package"]][["version"]]
[08:26:24.229]                             if (is.null(version)) 
[08:26:24.229]                               version <- utils::packageVersion("future")
[08:26:24.229]                           }
[08:26:24.229]                           else {
[08:26:24.229]                             version <- NULL
[08:26:24.229]                           }
[08:26:24.229]                           if (!has_future || version < "1.8.0") {
[08:26:24.229]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:24.229]                               "", base::R.version$version.string), 
[08:26:24.229]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:24.229]                                 base::R.version$platform, 8 * 
[08:26:24.229]                                   base::.Machine$sizeof.pointer), 
[08:26:24.229]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:24.229]                                 "release", "version")], collapse = " "), 
[08:26:24.229]                               hostname = base::Sys.info()[["nodename"]])
[08:26:24.229]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:24.229]                               info)
[08:26:24.229]                             info <- base::paste(info, collapse = "; ")
[08:26:24.229]                             if (!has_future) {
[08:26:24.229]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:24.229]                                 info)
[08:26:24.229]                             }
[08:26:24.229]                             else {
[08:26:24.229]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:24.229]                                 info, version)
[08:26:24.229]                             }
[08:26:24.229]                             base::stop(msg)
[08:26:24.229]                           }
[08:26:24.229]                         })
[08:26:24.229]                       }
[08:26:24.229]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:24.229]                       base::options(mc.cores = 1L)
[08:26:24.229]                     }
[08:26:24.229]                     base::local({
[08:26:24.229]                       for (pkg in "future.apply") {
[08:26:24.229]                         base::loadNamespace(pkg)
[08:26:24.229]                         base::library(pkg, character.only = TRUE)
[08:26:24.229]                       }
[08:26:24.229]                     })
[08:26:24.229]                   }
[08:26:24.229]                   ...future.strategy.old <- future::plan("list")
[08:26:24.229]                   options(future.plan = NULL)
[08:26:24.229]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:24.229]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:24.229]                 }
[08:26:24.229]                 ...future.workdir <- getwd()
[08:26:24.229]             }
[08:26:24.229]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:24.229]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:24.229]         }
[08:26:24.229]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:24.229]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:24.229]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:24.229]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:24.229]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:24.229]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:24.229]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:24.229]             base::names(...future.oldOptions))
[08:26:24.229]     }
[08:26:24.229]     if (FALSE) {
[08:26:24.229]     }
[08:26:24.229]     else {
[08:26:24.229]         if (TRUE) {
[08:26:24.229]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:24.229]                 open = "w")
[08:26:24.229]         }
[08:26:24.229]         else {
[08:26:24.229]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:24.229]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:24.229]         }
[08:26:24.229]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:24.229]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:24.229]             base::sink(type = "output", split = FALSE)
[08:26:24.229]             base::close(...future.stdout)
[08:26:24.229]         }, add = TRUE)
[08:26:24.229]     }
[08:26:24.229]     ...future.frame <- base::sys.nframe()
[08:26:24.229]     ...future.conditions <- base::list()
[08:26:24.229]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:24.229]     if (FALSE) {
[08:26:24.229]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:24.229]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:24.229]     }
[08:26:24.229]     ...future.result <- base::tryCatch({
[08:26:24.229]         base::withCallingHandlers({
[08:26:24.229]             ...future.value <- base::withVisible(base::local({
[08:26:24.229]                 ...future.makeSendCondition <- base::local({
[08:26:24.229]                   sendCondition <- NULL
[08:26:24.229]                   function(frame = 1L) {
[08:26:24.229]                     if (is.function(sendCondition)) 
[08:26:24.229]                       return(sendCondition)
[08:26:24.229]                     ns <- getNamespace("parallel")
[08:26:24.229]                     if (exists("sendData", mode = "function", 
[08:26:24.229]                       envir = ns)) {
[08:26:24.229]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:24.229]                         envir = ns)
[08:26:24.229]                       envir <- sys.frame(frame)
[08:26:24.229]                       master <- NULL
[08:26:24.229]                       while (!identical(envir, .GlobalEnv) && 
[08:26:24.229]                         !identical(envir, emptyenv())) {
[08:26:24.229]                         if (exists("master", mode = "list", envir = envir, 
[08:26:24.229]                           inherits = FALSE)) {
[08:26:24.229]                           master <- get("master", mode = "list", 
[08:26:24.229]                             envir = envir, inherits = FALSE)
[08:26:24.229]                           if (inherits(master, c("SOCKnode", 
[08:26:24.229]                             "SOCK0node"))) {
[08:26:24.229]                             sendCondition <<- function(cond) {
[08:26:24.229]                               data <- list(type = "VALUE", value = cond, 
[08:26:24.229]                                 success = TRUE)
[08:26:24.229]                               parallel_sendData(master, data)
[08:26:24.229]                             }
[08:26:24.229]                             return(sendCondition)
[08:26:24.229]                           }
[08:26:24.229]                         }
[08:26:24.229]                         frame <- frame + 1L
[08:26:24.229]                         envir <- sys.frame(frame)
[08:26:24.229]                       }
[08:26:24.229]                     }
[08:26:24.229]                     sendCondition <<- function(cond) NULL
[08:26:24.229]                   }
[08:26:24.229]                 })
[08:26:24.229]                 withCallingHandlers({
[08:26:24.229]                   {
[08:26:24.229]                     do.call(function(...) {
[08:26:24.229]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:24.229]                       if (!identical(...future.globals.maxSize.org, 
[08:26:24.229]                         ...future.globals.maxSize)) {
[08:26:24.229]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:24.229]                         on.exit(options(oopts), add = TRUE)
[08:26:24.229]                       }
[08:26:24.229]                       {
[08:26:24.229]                         lapply(seq_along(...future.elements_ii), 
[08:26:24.229]                           FUN = function(jj) {
[08:26:24.229]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:24.229]                             ...future.FUN(...future.X_jj, ...)
[08:26:24.229]                           })
[08:26:24.229]                       }
[08:26:24.229]                     }, args = future.call.arguments)
[08:26:24.229]                   }
[08:26:24.229]                 }, immediateCondition = function(cond) {
[08:26:24.229]                   sendCondition <- ...future.makeSendCondition()
[08:26:24.229]                   sendCondition(cond)
[08:26:24.229]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:24.229]                   {
[08:26:24.229]                     inherits <- base::inherits
[08:26:24.229]                     invokeRestart <- base::invokeRestart
[08:26:24.229]                     is.null <- base::is.null
[08:26:24.229]                     muffled <- FALSE
[08:26:24.229]                     if (inherits(cond, "message")) {
[08:26:24.229]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:24.229]                       if (muffled) 
[08:26:24.229]                         invokeRestart("muffleMessage")
[08:26:24.229]                     }
[08:26:24.229]                     else if (inherits(cond, "warning")) {
[08:26:24.229]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:24.229]                       if (muffled) 
[08:26:24.229]                         invokeRestart("muffleWarning")
[08:26:24.229]                     }
[08:26:24.229]                     else if (inherits(cond, "condition")) {
[08:26:24.229]                       if (!is.null(pattern)) {
[08:26:24.229]                         computeRestarts <- base::computeRestarts
[08:26:24.229]                         grepl <- base::grepl
[08:26:24.229]                         restarts <- computeRestarts(cond)
[08:26:24.229]                         for (restart in restarts) {
[08:26:24.229]                           name <- restart$name
[08:26:24.229]                           if (is.null(name)) 
[08:26:24.229]                             next
[08:26:24.229]                           if (!grepl(pattern, name)) 
[08:26:24.229]                             next
[08:26:24.229]                           invokeRestart(restart)
[08:26:24.229]                           muffled <- TRUE
[08:26:24.229]                           break
[08:26:24.229]                         }
[08:26:24.229]                       }
[08:26:24.229]                     }
[08:26:24.229]                     invisible(muffled)
[08:26:24.229]                   }
[08:26:24.229]                   muffleCondition(cond)
[08:26:24.229]                 })
[08:26:24.229]             }))
[08:26:24.229]             future::FutureResult(value = ...future.value$value, 
[08:26:24.229]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:24.229]                   ...future.rng), globalenv = if (FALSE) 
[08:26:24.229]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:24.229]                     ...future.globalenv.names))
[08:26:24.229]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:24.229]         }, condition = base::local({
[08:26:24.229]             c <- base::c
[08:26:24.229]             inherits <- base::inherits
[08:26:24.229]             invokeRestart <- base::invokeRestart
[08:26:24.229]             length <- base::length
[08:26:24.229]             list <- base::list
[08:26:24.229]             seq.int <- base::seq.int
[08:26:24.229]             signalCondition <- base::signalCondition
[08:26:24.229]             sys.calls <- base::sys.calls
[08:26:24.229]             `[[` <- base::`[[`
[08:26:24.229]             `+` <- base::`+`
[08:26:24.229]             `<<-` <- base::`<<-`
[08:26:24.229]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:24.229]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:24.229]                   3L)]
[08:26:24.229]             }
[08:26:24.229]             function(cond) {
[08:26:24.229]                 is_error <- inherits(cond, "error")
[08:26:24.229]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:24.229]                   NULL)
[08:26:24.229]                 if (is_error) {
[08:26:24.229]                   sessionInformation <- function() {
[08:26:24.229]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:24.229]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:24.229]                       search = base::search(), system = base::Sys.info())
[08:26:24.229]                   }
[08:26:24.229]                   ...future.conditions[[length(...future.conditions) + 
[08:26:24.229]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:24.229]                     cond$call), session = sessionInformation(), 
[08:26:24.229]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:24.229]                   signalCondition(cond)
[08:26:24.229]                 }
[08:26:24.229]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:24.229]                 "immediateCondition"))) {
[08:26:24.229]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:24.229]                   ...future.conditions[[length(...future.conditions) + 
[08:26:24.229]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:24.229]                   if (TRUE && !signal) {
[08:26:24.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:24.229]                     {
[08:26:24.229]                       inherits <- base::inherits
[08:26:24.229]                       invokeRestart <- base::invokeRestart
[08:26:24.229]                       is.null <- base::is.null
[08:26:24.229]                       muffled <- FALSE
[08:26:24.229]                       if (inherits(cond, "message")) {
[08:26:24.229]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:24.229]                         if (muffled) 
[08:26:24.229]                           invokeRestart("muffleMessage")
[08:26:24.229]                       }
[08:26:24.229]                       else if (inherits(cond, "warning")) {
[08:26:24.229]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:24.229]                         if (muffled) 
[08:26:24.229]                           invokeRestart("muffleWarning")
[08:26:24.229]                       }
[08:26:24.229]                       else if (inherits(cond, "condition")) {
[08:26:24.229]                         if (!is.null(pattern)) {
[08:26:24.229]                           computeRestarts <- base::computeRestarts
[08:26:24.229]                           grepl <- base::grepl
[08:26:24.229]                           restarts <- computeRestarts(cond)
[08:26:24.229]                           for (restart in restarts) {
[08:26:24.229]                             name <- restart$name
[08:26:24.229]                             if (is.null(name)) 
[08:26:24.229]                               next
[08:26:24.229]                             if (!grepl(pattern, name)) 
[08:26:24.229]                               next
[08:26:24.229]                             invokeRestart(restart)
[08:26:24.229]                             muffled <- TRUE
[08:26:24.229]                             break
[08:26:24.229]                           }
[08:26:24.229]                         }
[08:26:24.229]                       }
[08:26:24.229]                       invisible(muffled)
[08:26:24.229]                     }
[08:26:24.229]                     muffleCondition(cond, pattern = "^muffle")
[08:26:24.229]                   }
[08:26:24.229]                 }
[08:26:24.229]                 else {
[08:26:24.229]                   if (TRUE) {
[08:26:24.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:24.229]                     {
[08:26:24.229]                       inherits <- base::inherits
[08:26:24.229]                       invokeRestart <- base::invokeRestart
[08:26:24.229]                       is.null <- base::is.null
[08:26:24.229]                       muffled <- FALSE
[08:26:24.229]                       if (inherits(cond, "message")) {
[08:26:24.229]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:24.229]                         if (muffled) 
[08:26:24.229]                           invokeRestart("muffleMessage")
[08:26:24.229]                       }
[08:26:24.229]                       else if (inherits(cond, "warning")) {
[08:26:24.229]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:24.229]                         if (muffled) 
[08:26:24.229]                           invokeRestart("muffleWarning")
[08:26:24.229]                       }
[08:26:24.229]                       else if (inherits(cond, "condition")) {
[08:26:24.229]                         if (!is.null(pattern)) {
[08:26:24.229]                           computeRestarts <- base::computeRestarts
[08:26:24.229]                           grepl <- base::grepl
[08:26:24.229]                           restarts <- computeRestarts(cond)
[08:26:24.229]                           for (restart in restarts) {
[08:26:24.229]                             name <- restart$name
[08:26:24.229]                             if (is.null(name)) 
[08:26:24.229]                               next
[08:26:24.229]                             if (!grepl(pattern, name)) 
[08:26:24.229]                               next
[08:26:24.229]                             invokeRestart(restart)
[08:26:24.229]                             muffled <- TRUE
[08:26:24.229]                             break
[08:26:24.229]                           }
[08:26:24.229]                         }
[08:26:24.229]                       }
[08:26:24.229]                       invisible(muffled)
[08:26:24.229]                     }
[08:26:24.229]                     muffleCondition(cond, pattern = "^muffle")
[08:26:24.229]                   }
[08:26:24.229]                 }
[08:26:24.229]             }
[08:26:24.229]         }))
[08:26:24.229]     }, error = function(ex) {
[08:26:24.229]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:24.229]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:24.229]                 ...future.rng), started = ...future.startTime, 
[08:26:24.229]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:24.229]             version = "1.8"), class = "FutureResult")
[08:26:24.229]     }, finally = {
[08:26:24.229]         if (!identical(...future.workdir, getwd())) 
[08:26:24.229]             setwd(...future.workdir)
[08:26:24.229]         {
[08:26:24.229]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:24.229]                 ...future.oldOptions$nwarnings <- NULL
[08:26:24.229]             }
[08:26:24.229]             base::options(...future.oldOptions)
[08:26:24.229]             if (.Platform$OS.type == "windows") {
[08:26:24.229]                 old_names <- names(...future.oldEnvVars)
[08:26:24.229]                 envs <- base::Sys.getenv()
[08:26:24.229]                 names <- names(envs)
[08:26:24.229]                 common <- intersect(names, old_names)
[08:26:24.229]                 added <- setdiff(names, old_names)
[08:26:24.229]                 removed <- setdiff(old_names, names)
[08:26:24.229]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:24.229]                   envs[common]]
[08:26:24.229]                 NAMES <- toupper(changed)
[08:26:24.229]                 args <- list()
[08:26:24.229]                 for (kk in seq_along(NAMES)) {
[08:26:24.229]                   name <- changed[[kk]]
[08:26:24.229]                   NAME <- NAMES[[kk]]
[08:26:24.229]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:24.229]                     next
[08:26:24.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:24.229]                 }
[08:26:24.229]                 NAMES <- toupper(added)
[08:26:24.229]                 for (kk in seq_along(NAMES)) {
[08:26:24.229]                   name <- added[[kk]]
[08:26:24.229]                   NAME <- NAMES[[kk]]
[08:26:24.229]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:24.229]                     next
[08:26:24.229]                   args[[name]] <- ""
[08:26:24.229]                 }
[08:26:24.229]                 NAMES <- toupper(removed)
[08:26:24.229]                 for (kk in seq_along(NAMES)) {
[08:26:24.229]                   name <- removed[[kk]]
[08:26:24.229]                   NAME <- NAMES[[kk]]
[08:26:24.229]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:24.229]                     next
[08:26:24.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:24.229]                 }
[08:26:24.229]                 if (length(args) > 0) 
[08:26:24.229]                   base::do.call(base::Sys.setenv, args = args)
[08:26:24.229]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:24.229]             }
[08:26:24.229]             else {
[08:26:24.229]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:24.229]             }
[08:26:24.229]             {
[08:26:24.229]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:24.229]                   0L) {
[08:26:24.229]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:24.229]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:24.229]                   base::options(opts)
[08:26:24.229]                 }
[08:26:24.229]                 {
[08:26:24.229]                   {
[08:26:24.229]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:24.229]                     NULL
[08:26:24.229]                   }
[08:26:24.229]                   options(future.plan = NULL)
[08:26:24.229]                   if (is.na(NA_character_)) 
[08:26:24.229]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:24.229]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:24.229]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:24.229]                     .init = FALSE)
[08:26:24.229]                 }
[08:26:24.229]             }
[08:26:24.229]         }
[08:26:24.229]     })
[08:26:24.229]     if (TRUE) {
[08:26:24.229]         base::sink(type = "output", split = FALSE)
[08:26:24.229]         if (TRUE) {
[08:26:24.229]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:24.229]         }
[08:26:24.229]         else {
[08:26:24.229]             ...future.result["stdout"] <- base::list(NULL)
[08:26:24.229]         }
[08:26:24.229]         base::close(...future.stdout)
[08:26:24.229]         ...future.stdout <- NULL
[08:26:24.229]     }
[08:26:24.229]     ...future.result$conditions <- ...future.conditions
[08:26:24.229]     ...future.result$finished <- base::Sys.time()
[08:26:24.229]     ...future.result
[08:26:24.229] }
[08:26:24.232] Exporting 11 global objects (13.78 KiB) to cluster node #2 ...
[08:26:24.233] Exporting ‘...future.FUN’ (4.88 KiB) to cluster node #2 ...
[08:26:24.274] Exporting ‘...future.FUN’ (4.88 KiB) to cluster node #2 ... DONE
[08:26:24.274] Exporting ‘x_FUN’ (483 bytes) to cluster node #2 ...
[08:26:24.274] Exporting ‘x_FUN’ (483 bytes) to cluster node #2 ... DONE
[08:26:24.274] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[08:26:24.275] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[08:26:24.275] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[08:26:24.317] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[08:26:24.317] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[08:26:24.358] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[08:26:24.358] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[08:26:24.358] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[08:26:24.358] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[08:26:24.359] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[08:26:24.359] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:26:24.359] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:26:24.359] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ...
[08:26:24.360] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ... DONE
[08:26:24.360] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:26:24.360] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:26:24.360] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:26:24.361] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:26:24.361] Exporting 11 global objects (13.78 KiB) to cluster node #2 ... DONE
[08:26:24.361] MultisessionFuture started
[08:26:24.361] - Launch lazy future ... done
[08:26:24.362] run() for ‘MultisessionFuture’ ... done
[08:26:24.362] Created future:
[08:26:24.362] MultisessionFuture:
[08:26:24.362] Label: ‘future_vapply-2’
[08:26:24.362] Expression:
[08:26:24.362] {
[08:26:24.362]     do.call(function(...) {
[08:26:24.362]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:24.362]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:24.362]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:24.362]             on.exit(options(oopts), add = TRUE)
[08:26:24.362]         }
[08:26:24.362]         {
[08:26:24.362]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:24.362]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:24.362]                 ...future.FUN(...future.X_jj, ...)
[08:26:24.362]             })
[08:26:24.362]         }
[08:26:24.362]     }, args = future.call.arguments)
[08:26:24.362] }
[08:26:24.362] Lazy evaluation: FALSE
[08:26:24.362] Asynchronous evaluation: TRUE
[08:26:24.362] Local evaluation: TRUE
[08:26:24.362] Environment: R_GlobalEnv
[08:26:24.362] Capture standard output: TRUE
[08:26:24.362] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:24.362] Globals: 11 objects totaling 13.57 KiB (function ‘...future.FUN’ of 4.88 KiB, function ‘x_FUN’ of 483 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:24.362] Packages: 1 packages (‘future.apply’)
[08:26:24.362] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:24.362] Resolved: FALSE
[08:26:24.362] Value: <not collected>
[08:26:24.362] Conditions captured: <none>
[08:26:24.362] Early signaling: FALSE
[08:26:24.362] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:24.362] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:24.373] Chunk #2 of 2 ... DONE
[08:26:24.374] Launching 2 futures (chunks) ... DONE
[08:26:24.374] Resolving 2 futures (chunks) ...
[08:26:24.374] resolve() on list ...
[08:26:24.374]  recursive: 0
[08:26:24.374]  length: 2
[08:26:24.374] 
[08:26:24.375] receiveMessageFromWorker() for ClusterFuture ...
[08:26:24.375] - Validating connection of MultisessionFuture
[08:26:24.375] - received message: FutureResult
[08:26:24.375] - Received FutureResult
[08:26:24.375] - Erased future from FutureRegistry
[08:26:24.375] result() for ClusterFuture ...
[08:26:24.375] - result already collected: FutureResult
[08:26:24.375] result() for ClusterFuture ... done
[08:26:24.375] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:24.375] Future #1
[08:26:24.376] result() for ClusterFuture ...
[08:26:24.376] - result already collected: FutureResult
[08:26:24.376] result() for ClusterFuture ... done
[08:26:24.376] result() for ClusterFuture ...
[08:26:24.376] - result already collected: FutureResult
[08:26:24.376] result() for ClusterFuture ... done
[08:26:24.376] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:26:24.376] - nx: 2
[08:26:24.376] - relay: TRUE
[08:26:24.376] - stdout: TRUE
[08:26:24.376] - signal: TRUE
[08:26:24.376] - resignal: FALSE
[08:26:24.377] - force: TRUE
[08:26:24.377] - relayed: [n=2] FALSE, FALSE
[08:26:24.377] - queued futures: [n=2] FALSE, FALSE
[08:26:24.377]  - until=1
[08:26:24.377]  - relaying element #1
[08:26:24.377] result() for ClusterFuture ...
[08:26:24.377] - result already collected: FutureResult
[08:26:24.377] result() for ClusterFuture ... done
[08:26:24.377] result() for ClusterFuture ...
[08:26:24.377] - result already collected: FutureResult
[08:26:24.377] result() for ClusterFuture ... done
[08:26:24.378] result() for ClusterFuture ...
[08:26:24.378] - result already collected: FutureResult
[08:26:24.378] result() for ClusterFuture ... done
[08:26:24.378] result() for ClusterFuture ...
[08:26:24.378] - result already collected: FutureResult
[08:26:24.378] result() for ClusterFuture ... done
[08:26:24.378] - relayed: [n=2] TRUE, FALSE
[08:26:24.378] - queued futures: [n=2] TRUE, FALSE
[08:26:24.378] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:26:24.378]  length: 1 (resolved future 1)
[08:26:24.403] receiveMessageFromWorker() for ClusterFuture ...
[08:26:24.403] - Validating connection of MultisessionFuture
[08:26:24.404] - received message: FutureResult
[08:26:24.404] - Received FutureResult
[08:26:24.404] - Erased future from FutureRegistry
[08:26:24.404] result() for ClusterFuture ...
[08:26:24.404] - result already collected: FutureResult
[08:26:24.404] result() for ClusterFuture ... done
[08:26:24.404] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:24.404] Future #2
[08:26:24.404] result() for ClusterFuture ...
[08:26:24.404] - result already collected: FutureResult
[08:26:24.404] result() for ClusterFuture ... done
[08:26:24.405] result() for ClusterFuture ...
[08:26:24.405] - result already collected: FutureResult
[08:26:24.405] result() for ClusterFuture ... done
[08:26:24.405] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:26:24.405] - nx: 2
[08:26:24.405] - relay: TRUE
[08:26:24.405] - stdout: TRUE
[08:26:24.405] - signal: TRUE
[08:26:24.405] - resignal: FALSE
[08:26:24.405] - force: TRUE
[08:26:24.405] - relayed: [n=2] TRUE, FALSE
[08:26:24.405] - queued futures: [n=2] TRUE, FALSE
[08:26:24.406]  - until=2
[08:26:24.406]  - relaying element #2
[08:26:24.406] result() for ClusterFuture ...
[08:26:24.406] - result already collected: FutureResult
[08:26:24.406] result() for ClusterFuture ... done
[08:26:24.406] result() for ClusterFuture ...
[08:26:24.406] - result already collected: FutureResult
[08:26:24.406] result() for ClusterFuture ... done
[08:26:24.406] result() for ClusterFuture ...
[08:26:24.406] - result already collected: FutureResult
[08:26:24.406] result() for ClusterFuture ... done
[08:26:24.406] result() for ClusterFuture ...
[08:26:24.407] - result already collected: FutureResult
[08:26:24.407] result() for ClusterFuture ... done
[08:26:24.407] - relayed: [n=2] TRUE, TRUE
[08:26:24.407] - queued futures: [n=2] TRUE, TRUE
[08:26:24.407] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:26:24.407]  length: 0 (resolved future 2)
[08:26:24.407] Relaying remaining futures
[08:26:24.407] signalConditionsASAP(NULL, pos=0) ...
[08:26:24.407] - nx: 2
[08:26:24.407] - relay: TRUE
[08:26:24.407] - stdout: TRUE
[08:26:24.407] - signal: TRUE
[08:26:24.407] - resignal: FALSE
[08:26:24.408] - force: TRUE
[08:26:24.408] - relayed: [n=2] TRUE, TRUE
[08:26:24.408] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:24.408] - relayed: [n=2] TRUE, TRUE
[08:26:24.408] - queued futures: [n=2] TRUE, TRUE
[08:26:24.408] signalConditionsASAP(NULL, pos=0) ... done
[08:26:24.408] resolve() on list ... DONE
[08:26:24.408] result() for ClusterFuture ...
[08:26:24.408] - result already collected: FutureResult
[08:26:24.408] result() for ClusterFuture ... done
[08:26:24.408] result() for ClusterFuture ...
[08:26:24.409] - result already collected: FutureResult
[08:26:24.409] result() for ClusterFuture ... done
[08:26:24.409] result() for ClusterFuture ...
[08:26:24.409] - result already collected: FutureResult
[08:26:24.409] result() for ClusterFuture ... done
[08:26:24.409] result() for ClusterFuture ...
[08:26:24.409] - result already collected: FutureResult
[08:26:24.409] result() for ClusterFuture ... done
[08:26:24.409]  - Number of value chunks collected: 2
[08:26:24.409] Resolving 2 futures (chunks) ... DONE
[08:26:24.409] Reducing values from 2 chunks ...
[08:26:24.409]  - Number of values collected after concatenation: 10
[08:26:24.410]  - Number of values expected: 10
[08:26:24.410] Reducing values from 2 chunks ... DONE
[08:26:24.410] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[08:26:24.411] future_lapply() ...
[08:26:24.414] Number of chunks: 2
[08:26:24.414] getGlobalsAndPackagesXApply() ...
[08:26:24.414]  - future.globals: TRUE
[08:26:24.414] getGlobalsAndPackages() ...
[08:26:24.414] Searching for globals...
[08:26:24.418] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[08:26:24.418] Searching for globals ... DONE
[08:26:24.418] Resolving globals: FALSE
[08:26:24.419] The total size of the 7 globals is 13.59 KiB (13914 bytes)
[08:26:24.419] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.59 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.06 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:24.419] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:24.419] - packages: [1] ‘future.apply’
[08:26:24.419] getGlobalsAndPackages() ... DONE
[08:26:24.420]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:24.420]  - needed namespaces: [n=1] ‘future.apply’
[08:26:24.420] Finding globals ... DONE
[08:26:24.420]  - use_args: TRUE
[08:26:24.420]  - Getting '...' globals ...
[08:26:24.422] resolve() on list ...
[08:26:24.422]  recursive: 0
[08:26:24.422]  length: 1
[08:26:24.422]  elements: ‘...’
[08:26:24.423]  length: 0 (resolved future 1)
[08:26:24.423] resolve() on list ... DONE
[08:26:24.423]    - '...' content: [n=0] 
[08:26:24.423] List of 1
[08:26:24.423]  $ ...: list()
[08:26:24.423]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:24.423]  - attr(*, "where")=List of 1
[08:26:24.423]   ..$ ...:<environment: 0x562caa979f18> 
[08:26:24.423]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:24.423]  - attr(*, "resolved")= logi TRUE
[08:26:24.423]  - attr(*, "total_size")= num NA
[08:26:24.425]  - Getting '...' globals ... DONE
[08:26:24.425] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:24.425] List of 8
[08:26:24.425]  $ ...future.FUN:function (x, ...)  
[08:26:24.425]  $ x_FUN        :function (x)  
[08:26:24.425]  $ times        : int 4
[08:26:24.425]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:24.425]  $ stop_if_not  :function (...)  
[08:26:24.425]  $ dim          : int [1:2] 2 2
[08:26:24.425]  $ valid_types  : chr [1:2] "logical" "integer"
[08:26:24.425]  $ ...          : list()
[08:26:24.425]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:24.425]  - attr(*, "where")=List of 8
[08:26:24.425]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:24.425]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:24.425]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:24.425]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:24.425]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:24.425]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:24.425]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:24.425]   ..$ ...          :<environment: 0x562caa979f18> 
[08:26:24.425]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:24.425]  - attr(*, "resolved")= logi FALSE
[08:26:24.425]  - attr(*, "total_size")= num 24886
[08:26:24.431] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:24.431] getGlobalsAndPackagesXApply() ... DONE
[08:26:24.431] Number of futures (= number of chunks): 2
[08:26:24.431] Launching 2 futures (chunks) ...
[08:26:24.431] Chunk #1 of 2 ...
[08:26:24.431]  - Finding globals in 'X' for chunk #1 ...
[08:26:24.431] getGlobalsAndPackages() ...
[08:26:24.431] Searching for globals...
[08:26:24.432] 
[08:26:24.432] Searching for globals ... DONE
[08:26:24.432] - globals: [0] <none>
[08:26:24.432] getGlobalsAndPackages() ... DONE
[08:26:24.432]    + additional globals found: [n=0] 
[08:26:24.432]    + additional namespaces needed: [n=0] 
[08:26:24.432]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:24.432]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:24.432]  - seeds: <none>
[08:26:24.432]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:24.433] getGlobalsAndPackages() ...
[08:26:24.433] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:24.433] Resolving globals: FALSE
[08:26:24.433] Tweak future expression to call with '...' arguments ...
[08:26:24.433] {
[08:26:24.433]     do.call(function(...) {
[08:26:24.433]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:24.433]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:24.433]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:24.433]             on.exit(options(oopts), add = TRUE)
[08:26:24.433]         }
[08:26:24.433]         {
[08:26:24.433]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:24.433]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:24.433]                 ...future.FUN(...future.X_jj, ...)
[08:26:24.433]             })
[08:26:24.433]         }
[08:26:24.433]     }, args = future.call.arguments)
[08:26:24.433] }
[08:26:24.433] Tweak future expression to call with '...' arguments ... DONE
[08:26:24.434] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:24.434] - packages: [1] ‘future.apply’
[08:26:24.434] getGlobalsAndPackages() ... DONE
[08:26:24.434] run() for ‘Future’ ...
[08:26:24.434] - state: ‘created’
[08:26:24.434] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:24.452] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:24.452] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:24.453]   - Field: ‘node’
[08:26:24.453]   - Field: ‘label’
[08:26:24.453]   - Field: ‘local’
[08:26:24.453]   - Field: ‘owner’
[08:26:24.453]   - Field: ‘envir’
[08:26:24.453]   - Field: ‘workers’
[08:26:24.453]   - Field: ‘packages’
[08:26:24.453]   - Field: ‘gc’
[08:26:24.453]   - Field: ‘conditions’
[08:26:24.453]   - Field: ‘persistent’
[08:26:24.453]   - Field: ‘expr’
[08:26:24.454]   - Field: ‘uuid’
[08:26:24.454]   - Field: ‘seed’
[08:26:24.454]   - Field: ‘version’
[08:26:24.454]   - Field: ‘result’
[08:26:24.454]   - Field: ‘asynchronous’
[08:26:24.454]   - Field: ‘calls’
[08:26:24.454]   - Field: ‘globals’
[08:26:24.454]   - Field: ‘stdout’
[08:26:24.454]   - Field: ‘earlySignal’
[08:26:24.454]   - Field: ‘lazy’
[08:26:24.454]   - Field: ‘state’
[08:26:24.455] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:24.455] - Launch lazy future ...
[08:26:24.455] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:24.455] Packages needed by future strategies (n = 0): <none>
[08:26:24.456] {
[08:26:24.456]     {
[08:26:24.456]         {
[08:26:24.456]             ...future.startTime <- base::Sys.time()
[08:26:24.456]             {
[08:26:24.456]                 {
[08:26:24.456]                   {
[08:26:24.456]                     {
[08:26:24.456]                       {
[08:26:24.456]                         base::local({
[08:26:24.456]                           has_future <- base::requireNamespace("future", 
[08:26:24.456]                             quietly = TRUE)
[08:26:24.456]                           if (has_future) {
[08:26:24.456]                             ns <- base::getNamespace("future")
[08:26:24.456]                             version <- ns[[".package"]][["version"]]
[08:26:24.456]                             if (is.null(version)) 
[08:26:24.456]                               version <- utils::packageVersion("future")
[08:26:24.456]                           }
[08:26:24.456]                           else {
[08:26:24.456]                             version <- NULL
[08:26:24.456]                           }
[08:26:24.456]                           if (!has_future || version < "1.8.0") {
[08:26:24.456]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:24.456]                               "", base::R.version$version.string), 
[08:26:24.456]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:24.456]                                 base::R.version$platform, 8 * 
[08:26:24.456]                                   base::.Machine$sizeof.pointer), 
[08:26:24.456]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:24.456]                                 "release", "version")], collapse = " "), 
[08:26:24.456]                               hostname = base::Sys.info()[["nodename"]])
[08:26:24.456]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:24.456]                               info)
[08:26:24.456]                             info <- base::paste(info, collapse = "; ")
[08:26:24.456]                             if (!has_future) {
[08:26:24.456]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:24.456]                                 info)
[08:26:24.456]                             }
[08:26:24.456]                             else {
[08:26:24.456]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:24.456]                                 info, version)
[08:26:24.456]                             }
[08:26:24.456]                             base::stop(msg)
[08:26:24.456]                           }
[08:26:24.456]                         })
[08:26:24.456]                       }
[08:26:24.456]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:24.456]                       base::options(mc.cores = 1L)
[08:26:24.456]                     }
[08:26:24.456]                     base::local({
[08:26:24.456]                       for (pkg in "future.apply") {
[08:26:24.456]                         base::loadNamespace(pkg)
[08:26:24.456]                         base::library(pkg, character.only = TRUE)
[08:26:24.456]                       }
[08:26:24.456]                     })
[08:26:24.456]                   }
[08:26:24.456]                   ...future.strategy.old <- future::plan("list")
[08:26:24.456]                   options(future.plan = NULL)
[08:26:24.456]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:24.456]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:24.456]                 }
[08:26:24.456]                 ...future.workdir <- getwd()
[08:26:24.456]             }
[08:26:24.456]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:24.456]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:24.456]         }
[08:26:24.456]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:24.456]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:24.456]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:24.456]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:24.456]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:24.456]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:24.456]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:24.456]             base::names(...future.oldOptions))
[08:26:24.456]     }
[08:26:24.456]     if (FALSE) {
[08:26:24.456]     }
[08:26:24.456]     else {
[08:26:24.456]         if (TRUE) {
[08:26:24.456]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:24.456]                 open = "w")
[08:26:24.456]         }
[08:26:24.456]         else {
[08:26:24.456]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:24.456]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:24.456]         }
[08:26:24.456]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:24.456]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:24.456]             base::sink(type = "output", split = FALSE)
[08:26:24.456]             base::close(...future.stdout)
[08:26:24.456]         }, add = TRUE)
[08:26:24.456]     }
[08:26:24.456]     ...future.frame <- base::sys.nframe()
[08:26:24.456]     ...future.conditions <- base::list()
[08:26:24.456]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:24.456]     if (FALSE) {
[08:26:24.456]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:24.456]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:24.456]     }
[08:26:24.456]     ...future.result <- base::tryCatch({
[08:26:24.456]         base::withCallingHandlers({
[08:26:24.456]             ...future.value <- base::withVisible(base::local({
[08:26:24.456]                 ...future.makeSendCondition <- base::local({
[08:26:24.456]                   sendCondition <- NULL
[08:26:24.456]                   function(frame = 1L) {
[08:26:24.456]                     if (is.function(sendCondition)) 
[08:26:24.456]                       return(sendCondition)
[08:26:24.456]                     ns <- getNamespace("parallel")
[08:26:24.456]                     if (exists("sendData", mode = "function", 
[08:26:24.456]                       envir = ns)) {
[08:26:24.456]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:24.456]                         envir = ns)
[08:26:24.456]                       envir <- sys.frame(frame)
[08:26:24.456]                       master <- NULL
[08:26:24.456]                       while (!identical(envir, .GlobalEnv) && 
[08:26:24.456]                         !identical(envir, emptyenv())) {
[08:26:24.456]                         if (exists("master", mode = "list", envir = envir, 
[08:26:24.456]                           inherits = FALSE)) {
[08:26:24.456]                           master <- get("master", mode = "list", 
[08:26:24.456]                             envir = envir, inherits = FALSE)
[08:26:24.456]                           if (inherits(master, c("SOCKnode", 
[08:26:24.456]                             "SOCK0node"))) {
[08:26:24.456]                             sendCondition <<- function(cond) {
[08:26:24.456]                               data <- list(type = "VALUE", value = cond, 
[08:26:24.456]                                 success = TRUE)
[08:26:24.456]                               parallel_sendData(master, data)
[08:26:24.456]                             }
[08:26:24.456]                             return(sendCondition)
[08:26:24.456]                           }
[08:26:24.456]                         }
[08:26:24.456]                         frame <- frame + 1L
[08:26:24.456]                         envir <- sys.frame(frame)
[08:26:24.456]                       }
[08:26:24.456]                     }
[08:26:24.456]                     sendCondition <<- function(cond) NULL
[08:26:24.456]                   }
[08:26:24.456]                 })
[08:26:24.456]                 withCallingHandlers({
[08:26:24.456]                   {
[08:26:24.456]                     do.call(function(...) {
[08:26:24.456]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:24.456]                       if (!identical(...future.globals.maxSize.org, 
[08:26:24.456]                         ...future.globals.maxSize)) {
[08:26:24.456]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:24.456]                         on.exit(options(oopts), add = TRUE)
[08:26:24.456]                       }
[08:26:24.456]                       {
[08:26:24.456]                         lapply(seq_along(...future.elements_ii), 
[08:26:24.456]                           FUN = function(jj) {
[08:26:24.456]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:24.456]                             ...future.FUN(...future.X_jj, ...)
[08:26:24.456]                           })
[08:26:24.456]                       }
[08:26:24.456]                     }, args = future.call.arguments)
[08:26:24.456]                   }
[08:26:24.456]                 }, immediateCondition = function(cond) {
[08:26:24.456]                   sendCondition <- ...future.makeSendCondition()
[08:26:24.456]                   sendCondition(cond)
[08:26:24.456]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:24.456]                   {
[08:26:24.456]                     inherits <- base::inherits
[08:26:24.456]                     invokeRestart <- base::invokeRestart
[08:26:24.456]                     is.null <- base::is.null
[08:26:24.456]                     muffled <- FALSE
[08:26:24.456]                     if (inherits(cond, "message")) {
[08:26:24.456]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:24.456]                       if (muffled) 
[08:26:24.456]                         invokeRestart("muffleMessage")
[08:26:24.456]                     }
[08:26:24.456]                     else if (inherits(cond, "warning")) {
[08:26:24.456]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:24.456]                       if (muffled) 
[08:26:24.456]                         invokeRestart("muffleWarning")
[08:26:24.456]                     }
[08:26:24.456]                     else if (inherits(cond, "condition")) {
[08:26:24.456]                       if (!is.null(pattern)) {
[08:26:24.456]                         computeRestarts <- base::computeRestarts
[08:26:24.456]                         grepl <- base::grepl
[08:26:24.456]                         restarts <- computeRestarts(cond)
[08:26:24.456]                         for (restart in restarts) {
[08:26:24.456]                           name <- restart$name
[08:26:24.456]                           if (is.null(name)) 
[08:26:24.456]                             next
[08:26:24.456]                           if (!grepl(pattern, name)) 
[08:26:24.456]                             next
[08:26:24.456]                           invokeRestart(restart)
[08:26:24.456]                           muffled <- TRUE
[08:26:24.456]                           break
[08:26:24.456]                         }
[08:26:24.456]                       }
[08:26:24.456]                     }
[08:26:24.456]                     invisible(muffled)
[08:26:24.456]                   }
[08:26:24.456]                   muffleCondition(cond)
[08:26:24.456]                 })
[08:26:24.456]             }))
[08:26:24.456]             future::FutureResult(value = ...future.value$value, 
[08:26:24.456]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:24.456]                   ...future.rng), globalenv = if (FALSE) 
[08:26:24.456]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:24.456]                     ...future.globalenv.names))
[08:26:24.456]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:24.456]         }, condition = base::local({
[08:26:24.456]             c <- base::c
[08:26:24.456]             inherits <- base::inherits
[08:26:24.456]             invokeRestart <- base::invokeRestart
[08:26:24.456]             length <- base::length
[08:26:24.456]             list <- base::list
[08:26:24.456]             seq.int <- base::seq.int
[08:26:24.456]             signalCondition <- base::signalCondition
[08:26:24.456]             sys.calls <- base::sys.calls
[08:26:24.456]             `[[` <- base::`[[`
[08:26:24.456]             `+` <- base::`+`
[08:26:24.456]             `<<-` <- base::`<<-`
[08:26:24.456]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:24.456]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:24.456]                   3L)]
[08:26:24.456]             }
[08:26:24.456]             function(cond) {
[08:26:24.456]                 is_error <- inherits(cond, "error")
[08:26:24.456]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:24.456]                   NULL)
[08:26:24.456]                 if (is_error) {
[08:26:24.456]                   sessionInformation <- function() {
[08:26:24.456]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:24.456]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:24.456]                       search = base::search(), system = base::Sys.info())
[08:26:24.456]                   }
[08:26:24.456]                   ...future.conditions[[length(...future.conditions) + 
[08:26:24.456]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:24.456]                     cond$call), session = sessionInformation(), 
[08:26:24.456]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:24.456]                   signalCondition(cond)
[08:26:24.456]                 }
[08:26:24.456]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:24.456]                 "immediateCondition"))) {
[08:26:24.456]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:24.456]                   ...future.conditions[[length(...future.conditions) + 
[08:26:24.456]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:24.456]                   if (TRUE && !signal) {
[08:26:24.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:24.456]                     {
[08:26:24.456]                       inherits <- base::inherits
[08:26:24.456]                       invokeRestart <- base::invokeRestart
[08:26:24.456]                       is.null <- base::is.null
[08:26:24.456]                       muffled <- FALSE
[08:26:24.456]                       if (inherits(cond, "message")) {
[08:26:24.456]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:24.456]                         if (muffled) 
[08:26:24.456]                           invokeRestart("muffleMessage")
[08:26:24.456]                       }
[08:26:24.456]                       else if (inherits(cond, "warning")) {
[08:26:24.456]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:24.456]                         if (muffled) 
[08:26:24.456]                           invokeRestart("muffleWarning")
[08:26:24.456]                       }
[08:26:24.456]                       else if (inherits(cond, "condition")) {
[08:26:24.456]                         if (!is.null(pattern)) {
[08:26:24.456]                           computeRestarts <- base::computeRestarts
[08:26:24.456]                           grepl <- base::grepl
[08:26:24.456]                           restarts <- computeRestarts(cond)
[08:26:24.456]                           for (restart in restarts) {
[08:26:24.456]                             name <- restart$name
[08:26:24.456]                             if (is.null(name)) 
[08:26:24.456]                               next
[08:26:24.456]                             if (!grepl(pattern, name)) 
[08:26:24.456]                               next
[08:26:24.456]                             invokeRestart(restart)
[08:26:24.456]                             muffled <- TRUE
[08:26:24.456]                             break
[08:26:24.456]                           }
[08:26:24.456]                         }
[08:26:24.456]                       }
[08:26:24.456]                       invisible(muffled)
[08:26:24.456]                     }
[08:26:24.456]                     muffleCondition(cond, pattern = "^muffle")
[08:26:24.456]                   }
[08:26:24.456]                 }
[08:26:24.456]                 else {
[08:26:24.456]                   if (TRUE) {
[08:26:24.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:24.456]                     {
[08:26:24.456]                       inherits <- base::inherits
[08:26:24.456]                       invokeRestart <- base::invokeRestart
[08:26:24.456]                       is.null <- base::is.null
[08:26:24.456]                       muffled <- FALSE
[08:26:24.456]                       if (inherits(cond, "message")) {
[08:26:24.456]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:24.456]                         if (muffled) 
[08:26:24.456]                           invokeRestart("muffleMessage")
[08:26:24.456]                       }
[08:26:24.456]                       else if (inherits(cond, "warning")) {
[08:26:24.456]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:24.456]                         if (muffled) 
[08:26:24.456]                           invokeRestart("muffleWarning")
[08:26:24.456]                       }
[08:26:24.456]                       else if (inherits(cond, "condition")) {
[08:26:24.456]                         if (!is.null(pattern)) {
[08:26:24.456]                           computeRestarts <- base::computeRestarts
[08:26:24.456]                           grepl <- base::grepl
[08:26:24.456]                           restarts <- computeRestarts(cond)
[08:26:24.456]                           for (restart in restarts) {
[08:26:24.456]                             name <- restart$name
[08:26:24.456]                             if (is.null(name)) 
[08:26:24.456]                               next
[08:26:24.456]                             if (!grepl(pattern, name)) 
[08:26:24.456]                               next
[08:26:24.456]                             invokeRestart(restart)
[08:26:24.456]                             muffled <- TRUE
[08:26:24.456]                             break
[08:26:24.456]                           }
[08:26:24.456]                         }
[08:26:24.456]                       }
[08:26:24.456]                       invisible(muffled)
[08:26:24.456]                     }
[08:26:24.456]                     muffleCondition(cond, pattern = "^muffle")
[08:26:24.456]                   }
[08:26:24.456]                 }
[08:26:24.456]             }
[08:26:24.456]         }))
[08:26:24.456]     }, error = function(ex) {
[08:26:24.456]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:24.456]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:24.456]                 ...future.rng), started = ...future.startTime, 
[08:26:24.456]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:24.456]             version = "1.8"), class = "FutureResult")
[08:26:24.456]     }, finally = {
[08:26:24.456]         if (!identical(...future.workdir, getwd())) 
[08:26:24.456]             setwd(...future.workdir)
[08:26:24.456]         {
[08:26:24.456]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:24.456]                 ...future.oldOptions$nwarnings <- NULL
[08:26:24.456]             }
[08:26:24.456]             base::options(...future.oldOptions)
[08:26:24.456]             if (.Platform$OS.type == "windows") {
[08:26:24.456]                 old_names <- names(...future.oldEnvVars)
[08:26:24.456]                 envs <- base::Sys.getenv()
[08:26:24.456]                 names <- names(envs)
[08:26:24.456]                 common <- intersect(names, old_names)
[08:26:24.456]                 added <- setdiff(names, old_names)
[08:26:24.456]                 removed <- setdiff(old_names, names)
[08:26:24.456]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:24.456]                   envs[common]]
[08:26:24.456]                 NAMES <- toupper(changed)
[08:26:24.456]                 args <- list()
[08:26:24.456]                 for (kk in seq_along(NAMES)) {
[08:26:24.456]                   name <- changed[[kk]]
[08:26:24.456]                   NAME <- NAMES[[kk]]
[08:26:24.456]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:24.456]                     next
[08:26:24.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:24.456]                 }
[08:26:24.456]                 NAMES <- toupper(added)
[08:26:24.456]                 for (kk in seq_along(NAMES)) {
[08:26:24.456]                   name <- added[[kk]]
[08:26:24.456]                   NAME <- NAMES[[kk]]
[08:26:24.456]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:24.456]                     next
[08:26:24.456]                   args[[name]] <- ""
[08:26:24.456]                 }
[08:26:24.456]                 NAMES <- toupper(removed)
[08:26:24.456]                 for (kk in seq_along(NAMES)) {
[08:26:24.456]                   name <- removed[[kk]]
[08:26:24.456]                   NAME <- NAMES[[kk]]
[08:26:24.456]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:24.456]                     next
[08:26:24.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:24.456]                 }
[08:26:24.456]                 if (length(args) > 0) 
[08:26:24.456]                   base::do.call(base::Sys.setenv, args = args)
[08:26:24.456]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:24.456]             }
[08:26:24.456]             else {
[08:26:24.456]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:24.456]             }
[08:26:24.456]             {
[08:26:24.456]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:24.456]                   0L) {
[08:26:24.456]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:24.456]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:24.456]                   base::options(opts)
[08:26:24.456]                 }
[08:26:24.456]                 {
[08:26:24.456]                   {
[08:26:24.456]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:24.456]                     NULL
[08:26:24.456]                   }
[08:26:24.456]                   options(future.plan = NULL)
[08:26:24.456]                   if (is.na(NA_character_)) 
[08:26:24.456]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:24.456]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:24.456]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:24.456]                     .init = FALSE)
[08:26:24.456]                 }
[08:26:24.456]             }
[08:26:24.456]         }
[08:26:24.456]     })
[08:26:24.456]     if (TRUE) {
[08:26:24.456]         base::sink(type = "output", split = FALSE)
[08:26:24.456]         if (TRUE) {
[08:26:24.456]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:24.456]         }
[08:26:24.456]         else {
[08:26:24.456]             ...future.result["stdout"] <- base::list(NULL)
[08:26:24.456]         }
[08:26:24.456]         base::close(...future.stdout)
[08:26:24.456]         ...future.stdout <- NULL
[08:26:24.456]     }
[08:26:24.456]     ...future.result$conditions <- ...future.conditions
[08:26:24.456]     ...future.result$finished <- base::Sys.time()
[08:26:24.456]     ...future.result
[08:26:24.456] }
[08:26:24.459] Exporting 11 global objects (14.01 KiB) to cluster node #1 ...
[08:26:24.459] Exporting ‘...future.FUN’ (5.05 KiB) to cluster node #1 ...
[08:26:24.500] Exporting ‘...future.FUN’ (5.05 KiB) to cluster node #1 ... DONE
[08:26:24.500] Exporting ‘x_FUN’ (567 bytes) to cluster node #1 ...
[08:26:24.500] Exporting ‘x_FUN’ (567 bytes) to cluster node #1 ... DONE
[08:26:24.500] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[08:26:24.501] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[08:26:24.501] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[08:26:24.543] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[08:26:24.543] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[08:26:24.585] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[08:26:24.585] Exporting ‘dim’ (39 bytes) to cluster node #1 ...
[08:26:24.585] Exporting ‘dim’ (39 bytes) to cluster node #1 ... DONE
[08:26:24.585] Exporting ‘valid_types’ (61 bytes) to cluster node #1 ...
[08:26:24.586] Exporting ‘valid_types’ (61 bytes) to cluster node #1 ... DONE
[08:26:24.586] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:26:24.586] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:26:24.586] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ...
[08:26:24.587] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ... DONE
[08:26:24.587] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:26:24.587] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:26:24.587] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:26:24.588] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:26:24.588] Exporting 11 global objects (14.01 KiB) to cluster node #1 ... DONE
[08:26:24.588] MultisessionFuture started
[08:26:24.588] - Launch lazy future ... done
[08:26:24.588] run() for ‘MultisessionFuture’ ... done
[08:26:24.589] Created future:
[08:26:24.589] MultisessionFuture:
[08:26:24.589] Label: ‘future_vapply-1’
[08:26:24.589] Expression:
[08:26:24.589] {
[08:26:24.589]     do.call(function(...) {
[08:26:24.589]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:24.589]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:24.589]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:24.589]             on.exit(options(oopts), add = TRUE)
[08:26:24.589]         }
[08:26:24.589]         {
[08:26:24.589]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:24.589]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:24.589]                 ...future.FUN(...future.X_jj, ...)
[08:26:24.589]             })
[08:26:24.589]         }
[08:26:24.589]     }, args = future.call.arguments)
[08:26:24.589] }
[08:26:24.589] Lazy evaluation: FALSE
[08:26:24.589] Asynchronous evaluation: TRUE
[08:26:24.589] Local evaluation: TRUE
[08:26:24.589] Environment: R_GlobalEnv
[08:26:24.589] Capture standard output: TRUE
[08:26:24.589] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:24.589] Globals: 11 objects totaling 13.82 KiB (function ‘...future.FUN’ of 5.05 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:24.589] Packages: 1 packages (‘future.apply’)
[08:26:24.589] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:24.589] Resolved: FALSE
[08:26:24.589] Value: <not collected>
[08:26:24.589] Conditions captured: <none>
[08:26:24.589] Early signaling: FALSE
[08:26:24.589] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:24.589] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:24.600] Chunk #1 of 2 ... DONE
[08:26:24.600] Chunk #2 of 2 ...
[08:26:24.601]  - Finding globals in 'X' for chunk #2 ...
[08:26:24.601] getGlobalsAndPackages() ...
[08:26:24.601] Searching for globals...
[08:26:24.601] 
[08:26:24.601] Searching for globals ... DONE
[08:26:24.601] - globals: [0] <none>
[08:26:24.601] getGlobalsAndPackages() ... DONE
[08:26:24.601]    + additional globals found: [n=0] 
[08:26:24.601]    + additional namespaces needed: [n=0] 
[08:26:24.602]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:24.602]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:24.602]  - seeds: <none>
[08:26:24.602]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:24.602] getGlobalsAndPackages() ...
[08:26:24.602] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:24.602] Resolving globals: FALSE
[08:26:24.602] Tweak future expression to call with '...' arguments ...
[08:26:24.602] {
[08:26:24.602]     do.call(function(...) {
[08:26:24.602]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:24.602]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:24.602]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:24.602]             on.exit(options(oopts), add = TRUE)
[08:26:24.602]         }
[08:26:24.602]         {
[08:26:24.602]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:24.602]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:24.602]                 ...future.FUN(...future.X_jj, ...)
[08:26:24.602]             })
[08:26:24.602]         }
[08:26:24.602]     }, args = future.call.arguments)
[08:26:24.602] }
[08:26:24.603] Tweak future expression to call with '...' arguments ... DONE
[08:26:24.603] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:24.603] - packages: [1] ‘future.apply’
[08:26:24.603] getGlobalsAndPackages() ... DONE
[08:26:24.604] run() for ‘Future’ ...
[08:26:24.604] - state: ‘created’
[08:26:24.604] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:24.618] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:24.618] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:24.618]   - Field: ‘node’
[08:26:24.619]   - Field: ‘label’
[08:26:24.619]   - Field: ‘local’
[08:26:24.619]   - Field: ‘owner’
[08:26:24.619]   - Field: ‘envir’
[08:26:24.619]   - Field: ‘workers’
[08:26:24.619]   - Field: ‘packages’
[08:26:24.619]   - Field: ‘gc’
[08:26:24.619]   - Field: ‘conditions’
[08:26:24.619]   - Field: ‘persistent’
[08:26:24.620]   - Field: ‘expr’
[08:26:24.620]   - Field: ‘uuid’
[08:26:24.620]   - Field: ‘seed’
[08:26:24.620]   - Field: ‘version’
[08:26:24.620]   - Field: ‘result’
[08:26:24.620]   - Field: ‘asynchronous’
[08:26:24.620]   - Field: ‘calls’
[08:26:24.620]   - Field: ‘globals’
[08:26:24.620]   - Field: ‘stdout’
[08:26:24.620]   - Field: ‘earlySignal’
[08:26:24.620]   - Field: ‘lazy’
[08:26:24.621]   - Field: ‘state’
[08:26:24.621] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:24.621] - Launch lazy future ...
[08:26:24.621] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:24.621] Packages needed by future strategies (n = 0): <none>
[08:26:24.622] {
[08:26:24.622]     {
[08:26:24.622]         {
[08:26:24.622]             ...future.startTime <- base::Sys.time()
[08:26:24.622]             {
[08:26:24.622]                 {
[08:26:24.622]                   {
[08:26:24.622]                     {
[08:26:24.622]                       {
[08:26:24.622]                         base::local({
[08:26:24.622]                           has_future <- base::requireNamespace("future", 
[08:26:24.622]                             quietly = TRUE)
[08:26:24.622]                           if (has_future) {
[08:26:24.622]                             ns <- base::getNamespace("future")
[08:26:24.622]                             version <- ns[[".package"]][["version"]]
[08:26:24.622]                             if (is.null(version)) 
[08:26:24.622]                               version <- utils::packageVersion("future")
[08:26:24.622]                           }
[08:26:24.622]                           else {
[08:26:24.622]                             version <- NULL
[08:26:24.622]                           }
[08:26:24.622]                           if (!has_future || version < "1.8.0") {
[08:26:24.622]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:24.622]                               "", base::R.version$version.string), 
[08:26:24.622]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:24.622]                                 base::R.version$platform, 8 * 
[08:26:24.622]                                   base::.Machine$sizeof.pointer), 
[08:26:24.622]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:24.622]                                 "release", "version")], collapse = " "), 
[08:26:24.622]                               hostname = base::Sys.info()[["nodename"]])
[08:26:24.622]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:24.622]                               info)
[08:26:24.622]                             info <- base::paste(info, collapse = "; ")
[08:26:24.622]                             if (!has_future) {
[08:26:24.622]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:24.622]                                 info)
[08:26:24.622]                             }
[08:26:24.622]                             else {
[08:26:24.622]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:24.622]                                 info, version)
[08:26:24.622]                             }
[08:26:24.622]                             base::stop(msg)
[08:26:24.622]                           }
[08:26:24.622]                         })
[08:26:24.622]                       }
[08:26:24.622]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:24.622]                       base::options(mc.cores = 1L)
[08:26:24.622]                     }
[08:26:24.622]                     base::local({
[08:26:24.622]                       for (pkg in "future.apply") {
[08:26:24.622]                         base::loadNamespace(pkg)
[08:26:24.622]                         base::library(pkg, character.only = TRUE)
[08:26:24.622]                       }
[08:26:24.622]                     })
[08:26:24.622]                   }
[08:26:24.622]                   ...future.strategy.old <- future::plan("list")
[08:26:24.622]                   options(future.plan = NULL)
[08:26:24.622]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:24.622]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:24.622]                 }
[08:26:24.622]                 ...future.workdir <- getwd()
[08:26:24.622]             }
[08:26:24.622]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:24.622]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:24.622]         }
[08:26:24.622]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:24.622]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:24.622]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:24.622]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:24.622]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:24.622]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:24.622]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:24.622]             base::names(...future.oldOptions))
[08:26:24.622]     }
[08:26:24.622]     if (FALSE) {
[08:26:24.622]     }
[08:26:24.622]     else {
[08:26:24.622]         if (TRUE) {
[08:26:24.622]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:24.622]                 open = "w")
[08:26:24.622]         }
[08:26:24.622]         else {
[08:26:24.622]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:24.622]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:24.622]         }
[08:26:24.622]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:24.622]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:24.622]             base::sink(type = "output", split = FALSE)
[08:26:24.622]             base::close(...future.stdout)
[08:26:24.622]         }, add = TRUE)
[08:26:24.622]     }
[08:26:24.622]     ...future.frame <- base::sys.nframe()
[08:26:24.622]     ...future.conditions <- base::list()
[08:26:24.622]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:24.622]     if (FALSE) {
[08:26:24.622]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:24.622]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:24.622]     }
[08:26:24.622]     ...future.result <- base::tryCatch({
[08:26:24.622]         base::withCallingHandlers({
[08:26:24.622]             ...future.value <- base::withVisible(base::local({
[08:26:24.622]                 ...future.makeSendCondition <- base::local({
[08:26:24.622]                   sendCondition <- NULL
[08:26:24.622]                   function(frame = 1L) {
[08:26:24.622]                     if (is.function(sendCondition)) 
[08:26:24.622]                       return(sendCondition)
[08:26:24.622]                     ns <- getNamespace("parallel")
[08:26:24.622]                     if (exists("sendData", mode = "function", 
[08:26:24.622]                       envir = ns)) {
[08:26:24.622]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:24.622]                         envir = ns)
[08:26:24.622]                       envir <- sys.frame(frame)
[08:26:24.622]                       master <- NULL
[08:26:24.622]                       while (!identical(envir, .GlobalEnv) && 
[08:26:24.622]                         !identical(envir, emptyenv())) {
[08:26:24.622]                         if (exists("master", mode = "list", envir = envir, 
[08:26:24.622]                           inherits = FALSE)) {
[08:26:24.622]                           master <- get("master", mode = "list", 
[08:26:24.622]                             envir = envir, inherits = FALSE)
[08:26:24.622]                           if (inherits(master, c("SOCKnode", 
[08:26:24.622]                             "SOCK0node"))) {
[08:26:24.622]                             sendCondition <<- function(cond) {
[08:26:24.622]                               data <- list(type = "VALUE", value = cond, 
[08:26:24.622]                                 success = TRUE)
[08:26:24.622]                               parallel_sendData(master, data)
[08:26:24.622]                             }
[08:26:24.622]                             return(sendCondition)
[08:26:24.622]                           }
[08:26:24.622]                         }
[08:26:24.622]                         frame <- frame + 1L
[08:26:24.622]                         envir <- sys.frame(frame)
[08:26:24.622]                       }
[08:26:24.622]                     }
[08:26:24.622]                     sendCondition <<- function(cond) NULL
[08:26:24.622]                   }
[08:26:24.622]                 })
[08:26:24.622]                 withCallingHandlers({
[08:26:24.622]                   {
[08:26:24.622]                     do.call(function(...) {
[08:26:24.622]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:24.622]                       if (!identical(...future.globals.maxSize.org, 
[08:26:24.622]                         ...future.globals.maxSize)) {
[08:26:24.622]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:24.622]                         on.exit(options(oopts), add = TRUE)
[08:26:24.622]                       }
[08:26:24.622]                       {
[08:26:24.622]                         lapply(seq_along(...future.elements_ii), 
[08:26:24.622]                           FUN = function(jj) {
[08:26:24.622]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:24.622]                             ...future.FUN(...future.X_jj, ...)
[08:26:24.622]                           })
[08:26:24.622]                       }
[08:26:24.622]                     }, args = future.call.arguments)
[08:26:24.622]                   }
[08:26:24.622]                 }, immediateCondition = function(cond) {
[08:26:24.622]                   sendCondition <- ...future.makeSendCondition()
[08:26:24.622]                   sendCondition(cond)
[08:26:24.622]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:24.622]                   {
[08:26:24.622]                     inherits <- base::inherits
[08:26:24.622]                     invokeRestart <- base::invokeRestart
[08:26:24.622]                     is.null <- base::is.null
[08:26:24.622]                     muffled <- FALSE
[08:26:24.622]                     if (inherits(cond, "message")) {
[08:26:24.622]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:24.622]                       if (muffled) 
[08:26:24.622]                         invokeRestart("muffleMessage")
[08:26:24.622]                     }
[08:26:24.622]                     else if (inherits(cond, "warning")) {
[08:26:24.622]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:24.622]                       if (muffled) 
[08:26:24.622]                         invokeRestart("muffleWarning")
[08:26:24.622]                     }
[08:26:24.622]                     else if (inherits(cond, "condition")) {
[08:26:24.622]                       if (!is.null(pattern)) {
[08:26:24.622]                         computeRestarts <- base::computeRestarts
[08:26:24.622]                         grepl <- base::grepl
[08:26:24.622]                         restarts <- computeRestarts(cond)
[08:26:24.622]                         for (restart in restarts) {
[08:26:24.622]                           name <- restart$name
[08:26:24.622]                           if (is.null(name)) 
[08:26:24.622]                             next
[08:26:24.622]                           if (!grepl(pattern, name)) 
[08:26:24.622]                             next
[08:26:24.622]                           invokeRestart(restart)
[08:26:24.622]                           muffled <- TRUE
[08:26:24.622]                           break
[08:26:24.622]                         }
[08:26:24.622]                       }
[08:26:24.622]                     }
[08:26:24.622]                     invisible(muffled)
[08:26:24.622]                   }
[08:26:24.622]                   muffleCondition(cond)
[08:26:24.622]                 })
[08:26:24.622]             }))
[08:26:24.622]             future::FutureResult(value = ...future.value$value, 
[08:26:24.622]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:24.622]                   ...future.rng), globalenv = if (FALSE) 
[08:26:24.622]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:24.622]                     ...future.globalenv.names))
[08:26:24.622]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:24.622]         }, condition = base::local({
[08:26:24.622]             c <- base::c
[08:26:24.622]             inherits <- base::inherits
[08:26:24.622]             invokeRestart <- base::invokeRestart
[08:26:24.622]             length <- base::length
[08:26:24.622]             list <- base::list
[08:26:24.622]             seq.int <- base::seq.int
[08:26:24.622]             signalCondition <- base::signalCondition
[08:26:24.622]             sys.calls <- base::sys.calls
[08:26:24.622]             `[[` <- base::`[[`
[08:26:24.622]             `+` <- base::`+`
[08:26:24.622]             `<<-` <- base::`<<-`
[08:26:24.622]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:24.622]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:24.622]                   3L)]
[08:26:24.622]             }
[08:26:24.622]             function(cond) {
[08:26:24.622]                 is_error <- inherits(cond, "error")
[08:26:24.622]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:24.622]                   NULL)
[08:26:24.622]                 if (is_error) {
[08:26:24.622]                   sessionInformation <- function() {
[08:26:24.622]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:24.622]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:24.622]                       search = base::search(), system = base::Sys.info())
[08:26:24.622]                   }
[08:26:24.622]                   ...future.conditions[[length(...future.conditions) + 
[08:26:24.622]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:24.622]                     cond$call), session = sessionInformation(), 
[08:26:24.622]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:24.622]                   signalCondition(cond)
[08:26:24.622]                 }
[08:26:24.622]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:24.622]                 "immediateCondition"))) {
[08:26:24.622]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:24.622]                   ...future.conditions[[length(...future.conditions) + 
[08:26:24.622]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:24.622]                   if (TRUE && !signal) {
[08:26:24.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:24.622]                     {
[08:26:24.622]                       inherits <- base::inherits
[08:26:24.622]                       invokeRestart <- base::invokeRestart
[08:26:24.622]                       is.null <- base::is.null
[08:26:24.622]                       muffled <- FALSE
[08:26:24.622]                       if (inherits(cond, "message")) {
[08:26:24.622]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:24.622]                         if (muffled) 
[08:26:24.622]                           invokeRestart("muffleMessage")
[08:26:24.622]                       }
[08:26:24.622]                       else if (inherits(cond, "warning")) {
[08:26:24.622]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:24.622]                         if (muffled) 
[08:26:24.622]                           invokeRestart("muffleWarning")
[08:26:24.622]                       }
[08:26:24.622]                       else if (inherits(cond, "condition")) {
[08:26:24.622]                         if (!is.null(pattern)) {
[08:26:24.622]                           computeRestarts <- base::computeRestarts
[08:26:24.622]                           grepl <- base::grepl
[08:26:24.622]                           restarts <- computeRestarts(cond)
[08:26:24.622]                           for (restart in restarts) {
[08:26:24.622]                             name <- restart$name
[08:26:24.622]                             if (is.null(name)) 
[08:26:24.622]                               next
[08:26:24.622]                             if (!grepl(pattern, name)) 
[08:26:24.622]                               next
[08:26:24.622]                             invokeRestart(restart)
[08:26:24.622]                             muffled <- TRUE
[08:26:24.622]                             break
[08:26:24.622]                           }
[08:26:24.622]                         }
[08:26:24.622]                       }
[08:26:24.622]                       invisible(muffled)
[08:26:24.622]                     }
[08:26:24.622]                     muffleCondition(cond, pattern = "^muffle")
[08:26:24.622]                   }
[08:26:24.622]                 }
[08:26:24.622]                 else {
[08:26:24.622]                   if (TRUE) {
[08:26:24.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:24.622]                     {
[08:26:24.622]                       inherits <- base::inherits
[08:26:24.622]                       invokeRestart <- base::invokeRestart
[08:26:24.622]                       is.null <- base::is.null
[08:26:24.622]                       muffled <- FALSE
[08:26:24.622]                       if (inherits(cond, "message")) {
[08:26:24.622]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:24.622]                         if (muffled) 
[08:26:24.622]                           invokeRestart("muffleMessage")
[08:26:24.622]                       }
[08:26:24.622]                       else if (inherits(cond, "warning")) {
[08:26:24.622]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:24.622]                         if (muffled) 
[08:26:24.622]                           invokeRestart("muffleWarning")
[08:26:24.622]                       }
[08:26:24.622]                       else if (inherits(cond, "condition")) {
[08:26:24.622]                         if (!is.null(pattern)) {
[08:26:24.622]                           computeRestarts <- base::computeRestarts
[08:26:24.622]                           grepl <- base::grepl
[08:26:24.622]                           restarts <- computeRestarts(cond)
[08:26:24.622]                           for (restart in restarts) {
[08:26:24.622]                             name <- restart$name
[08:26:24.622]                             if (is.null(name)) 
[08:26:24.622]                               next
[08:26:24.622]                             if (!grepl(pattern, name)) 
[08:26:24.622]                               next
[08:26:24.622]                             invokeRestart(restart)
[08:26:24.622]                             muffled <- TRUE
[08:26:24.622]                             break
[08:26:24.622]                           }
[08:26:24.622]                         }
[08:26:24.622]                       }
[08:26:24.622]                       invisible(muffled)
[08:26:24.622]                     }
[08:26:24.622]                     muffleCondition(cond, pattern = "^muffle")
[08:26:24.622]                   }
[08:26:24.622]                 }
[08:26:24.622]             }
[08:26:24.622]         }))
[08:26:24.622]     }, error = function(ex) {
[08:26:24.622]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:24.622]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:24.622]                 ...future.rng), started = ...future.startTime, 
[08:26:24.622]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:24.622]             version = "1.8"), class = "FutureResult")
[08:26:24.622]     }, finally = {
[08:26:24.622]         if (!identical(...future.workdir, getwd())) 
[08:26:24.622]             setwd(...future.workdir)
[08:26:24.622]         {
[08:26:24.622]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:24.622]                 ...future.oldOptions$nwarnings <- NULL
[08:26:24.622]             }
[08:26:24.622]             base::options(...future.oldOptions)
[08:26:24.622]             if (.Platform$OS.type == "windows") {
[08:26:24.622]                 old_names <- names(...future.oldEnvVars)
[08:26:24.622]                 envs <- base::Sys.getenv()
[08:26:24.622]                 names <- names(envs)
[08:26:24.622]                 common <- intersect(names, old_names)
[08:26:24.622]                 added <- setdiff(names, old_names)
[08:26:24.622]                 removed <- setdiff(old_names, names)
[08:26:24.622]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:24.622]                   envs[common]]
[08:26:24.622]                 NAMES <- toupper(changed)
[08:26:24.622]                 args <- list()
[08:26:24.622]                 for (kk in seq_along(NAMES)) {
[08:26:24.622]                   name <- changed[[kk]]
[08:26:24.622]                   NAME <- NAMES[[kk]]
[08:26:24.622]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:24.622]                     next
[08:26:24.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:24.622]                 }
[08:26:24.622]                 NAMES <- toupper(added)
[08:26:24.622]                 for (kk in seq_along(NAMES)) {
[08:26:24.622]                   name <- added[[kk]]
[08:26:24.622]                   NAME <- NAMES[[kk]]
[08:26:24.622]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:24.622]                     next
[08:26:24.622]                   args[[name]] <- ""
[08:26:24.622]                 }
[08:26:24.622]                 NAMES <- toupper(removed)
[08:26:24.622]                 for (kk in seq_along(NAMES)) {
[08:26:24.622]                   name <- removed[[kk]]
[08:26:24.622]                   NAME <- NAMES[[kk]]
[08:26:24.622]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:24.622]                     next
[08:26:24.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:24.622]                 }
[08:26:24.622]                 if (length(args) > 0) 
[08:26:24.622]                   base::do.call(base::Sys.setenv, args = args)
[08:26:24.622]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:24.622]             }
[08:26:24.622]             else {
[08:26:24.622]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:24.622]             }
[08:26:24.622]             {
[08:26:24.622]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:24.622]                   0L) {
[08:26:24.622]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:24.622]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:24.622]                   base::options(opts)
[08:26:24.622]                 }
[08:26:24.622]                 {
[08:26:24.622]                   {
[08:26:24.622]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:24.622]                     NULL
[08:26:24.622]                   }
[08:26:24.622]                   options(future.plan = NULL)
[08:26:24.622]                   if (is.na(NA_character_)) 
[08:26:24.622]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:24.622]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:24.622]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:24.622]                     .init = FALSE)
[08:26:24.622]                 }
[08:26:24.622]             }
[08:26:24.622]         }
[08:26:24.622]     })
[08:26:24.622]     if (TRUE) {
[08:26:24.622]         base::sink(type = "output", split = FALSE)
[08:26:24.622]         if (TRUE) {
[08:26:24.622]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:24.622]         }
[08:26:24.622]         else {
[08:26:24.622]             ...future.result["stdout"] <- base::list(NULL)
[08:26:24.622]         }
[08:26:24.622]         base::close(...future.stdout)
[08:26:24.622]         ...future.stdout <- NULL
[08:26:24.622]     }
[08:26:24.622]     ...future.result$conditions <- ...future.conditions
[08:26:24.622]     ...future.result$finished <- base::Sys.time()
[08:26:24.622]     ...future.result
[08:26:24.622] }
[08:26:24.625] Exporting 11 global objects (14.01 KiB) to cluster node #2 ...
[08:26:24.625] Exporting ‘...future.FUN’ (5.05 KiB) to cluster node #2 ...
[08:26:24.667] Exporting ‘...future.FUN’ (5.05 KiB) to cluster node #2 ... DONE
[08:26:24.667] Exporting ‘x_FUN’ (567 bytes) to cluster node #2 ...
[08:26:24.668] Exporting ‘x_FUN’ (567 bytes) to cluster node #2 ... DONE
[08:26:24.668] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[08:26:24.668] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[08:26:24.668] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[08:26:24.709] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[08:26:24.710] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[08:26:24.750] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[08:26:24.751] Exporting ‘dim’ (39 bytes) to cluster node #2 ...
[08:26:24.751] Exporting ‘dim’ (39 bytes) to cluster node #2 ... DONE
[08:26:24.751] Exporting ‘valid_types’ (61 bytes) to cluster node #2 ...
[08:26:24.752] Exporting ‘valid_types’ (61 bytes) to cluster node #2 ... DONE
[08:26:24.752] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:26:24.752] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:26:24.752] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ...
[08:26:24.753] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ... DONE
[08:26:24.753] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:26:24.753] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:26:24.753] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:26:24.754] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:26:24.754] Exporting 11 global objects (14.01 KiB) to cluster node #2 ... DONE
[08:26:24.754] MultisessionFuture started
[08:26:24.754] - Launch lazy future ... done
[08:26:24.755] run() for ‘MultisessionFuture’ ... done
[08:26:24.755] Created future:
[08:26:24.755] MultisessionFuture:
[08:26:24.755] Label: ‘future_vapply-2’
[08:26:24.755] Expression:
[08:26:24.755] {
[08:26:24.755]     do.call(function(...) {
[08:26:24.755]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:24.755]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:24.755]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:24.755]             on.exit(options(oopts), add = TRUE)
[08:26:24.755]         }
[08:26:24.755]         {
[08:26:24.755]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:24.755]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:24.755]                 ...future.FUN(...future.X_jj, ...)
[08:26:24.755]             })
[08:26:24.755]         }
[08:26:24.755]     }, args = future.call.arguments)
[08:26:24.755] }
[08:26:24.755] Lazy evaluation: FALSE
[08:26:24.755] Asynchronous evaluation: TRUE
[08:26:24.755] Local evaluation: TRUE
[08:26:24.755] Environment: R_GlobalEnv
[08:26:24.755] Capture standard output: TRUE
[08:26:24.755] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:24.755] Globals: 11 objects totaling 13.82 KiB (function ‘...future.FUN’ of 5.05 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:24.755] Packages: 1 packages (‘future.apply’)
[08:26:24.755] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:24.755] Resolved: FALSE
[08:26:24.755] Value: <not collected>
[08:26:24.755] Conditions captured: <none>
[08:26:24.755] Early signaling: FALSE
[08:26:24.755] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:24.755] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:24.766] Chunk #2 of 2 ... DONE
[08:26:24.767] Launching 2 futures (chunks) ... DONE
[08:26:24.767] Resolving 2 futures (chunks) ...
[08:26:24.767] resolve() on list ...
[08:26:24.767]  recursive: 0
[08:26:24.767]  length: 2
[08:26:24.767] 
[08:26:24.767] receiveMessageFromWorker() for ClusterFuture ...
[08:26:24.768] - Validating connection of MultisessionFuture
[08:26:24.768] - received message: FutureResult
[08:26:24.768] - Received FutureResult
[08:26:24.768] - Erased future from FutureRegistry
[08:26:24.768] result() for ClusterFuture ...
[08:26:24.768] - result already collected: FutureResult
[08:26:24.768] result() for ClusterFuture ... done
[08:26:24.768] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:24.768] Future #1
[08:26:24.769] result() for ClusterFuture ...
[08:26:24.769] - result already collected: FutureResult
[08:26:24.769] result() for ClusterFuture ... done
[08:26:24.769] result() for ClusterFuture ...
[08:26:24.769] - result already collected: FutureResult
[08:26:24.769] result() for ClusterFuture ... done
[08:26:24.769] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:26:24.769] - nx: 2
[08:26:24.769] - relay: TRUE
[08:26:24.769] - stdout: TRUE
[08:26:24.769] - signal: TRUE
[08:26:24.769] - resignal: FALSE
[08:26:24.770] - force: TRUE
[08:26:24.770] - relayed: [n=2] FALSE, FALSE
[08:26:24.770] - queued futures: [n=2] FALSE, FALSE
[08:26:24.770]  - until=1
[08:26:24.770]  - relaying element #1
[08:26:24.770] result() for ClusterFuture ...
[08:26:24.770] - result already collected: FutureResult
[08:26:24.770] result() for ClusterFuture ... done
[08:26:24.770] result() for ClusterFuture ...
[08:26:24.770] - result already collected: FutureResult
[08:26:24.770] result() for ClusterFuture ... done
[08:26:24.770] result() for ClusterFuture ...
[08:26:24.771] - result already collected: FutureResult
[08:26:24.771] result() for ClusterFuture ... done
[08:26:24.771] result() for ClusterFuture ...
[08:26:24.771] - result already collected: FutureResult
[08:26:24.771] result() for ClusterFuture ... done
[08:26:24.771] - relayed: [n=2] TRUE, FALSE
[08:26:24.771] - queued futures: [n=2] TRUE, FALSE
[08:26:24.771] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:26:24.771]  length: 1 (resolved future 1)
[08:26:24.796] receiveMessageFromWorker() for ClusterFuture ...
[08:26:24.797] - Validating connection of MultisessionFuture
[08:26:24.797] - received message: FutureResult
[08:26:24.797] - Received FutureResult
[08:26:24.797] - Erased future from FutureRegistry
[08:26:24.797] result() for ClusterFuture ...
[08:26:24.797] - result already collected: FutureResult
[08:26:24.797] result() for ClusterFuture ... done
[08:26:24.797] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:24.797] Future #2
[08:26:24.798] result() for ClusterFuture ...
[08:26:24.798] - result already collected: FutureResult
[08:26:24.798] result() for ClusterFuture ... done
[08:26:24.798] result() for ClusterFuture ...
[08:26:24.798] - result already collected: FutureResult
[08:26:24.798] result() for ClusterFuture ... done
[08:26:24.798] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:26:24.798] - nx: 2
[08:26:24.798] - relay: TRUE
[08:26:24.798] - stdout: TRUE
[08:26:24.798] - signal: TRUE
[08:26:24.798] - resignal: FALSE
[08:26:24.799] - force: TRUE
[08:26:24.799] - relayed: [n=2] TRUE, FALSE
[08:26:24.799] - queued futures: [n=2] TRUE, FALSE
[08:26:24.799]  - until=2
[08:26:24.799]  - relaying element #2
[08:26:24.799] result() for ClusterFuture ...
[08:26:24.799] - result already collected: FutureResult
[08:26:24.799] result() for ClusterFuture ... done
[08:26:24.799] result() for ClusterFuture ...
[08:26:24.799] - result already collected: FutureResult
[08:26:24.799] result() for ClusterFuture ... done
[08:26:24.799] result() for ClusterFuture ...
[08:26:24.800] - result already collected: FutureResult
[08:26:24.800] result() for ClusterFuture ... done
[08:26:24.800] result() for ClusterFuture ...
[08:26:24.800] - result already collected: FutureResult
[08:26:24.800] result() for ClusterFuture ... done
[08:26:24.800] - relayed: [n=2] TRUE, TRUE
[08:26:24.800] - queued futures: [n=2] TRUE, TRUE
[08:26:24.800] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:26:24.800]  length: 0 (resolved future 2)
[08:26:24.800] Relaying remaining futures
[08:26:24.800] signalConditionsASAP(NULL, pos=0) ...
[08:26:24.800] - nx: 2
[08:26:24.801] - relay: TRUE
[08:26:24.801] - stdout: TRUE
[08:26:24.801] - signal: TRUE
[08:26:24.801] - resignal: FALSE
[08:26:24.801] - force: TRUE
[08:26:24.801] - relayed: [n=2] TRUE, TRUE
[08:26:24.801] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:24.801] - relayed: [n=2] TRUE, TRUE
[08:26:24.801] - queued futures: [n=2] TRUE, TRUE
[08:26:24.801] signalConditionsASAP(NULL, pos=0) ... done
[08:26:24.801] resolve() on list ... DONE
[08:26:24.801] result() for ClusterFuture ...
[08:26:24.802] - result already collected: FutureResult
[08:26:24.802] result() for ClusterFuture ... done
[08:26:24.802] result() for ClusterFuture ...
[08:26:24.802] - result already collected: FutureResult
[08:26:24.802] result() for ClusterFuture ... done
[08:26:24.802] result() for ClusterFuture ...
[08:26:24.802] - result already collected: FutureResult
[08:26:24.802] result() for ClusterFuture ... done
[08:26:24.802] result() for ClusterFuture ...
[08:26:24.802] - result already collected: FutureResult
[08:26:24.802] result() for ClusterFuture ... done
[08:26:24.802]  - Number of value chunks collected: 2
[08:26:24.803] Resolving 2 futures (chunks) ... DONE
[08:26:24.803] Reducing values from 2 chunks ...
[08:26:24.803]  - Number of values collected after concatenation: 10
[08:26:24.803]  - Number of values expected: 10
[08:26:24.803] Reducing values from 2 chunks ... DONE
[08:26:24.803] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[08:26:24.804] future_lapply() ...
[08:26:24.807] Number of chunks: 2
[08:26:24.807] getGlobalsAndPackagesXApply() ...
[08:26:24.807]  - future.globals: TRUE
[08:26:24.808] getGlobalsAndPackages() ...
[08:26:24.808] Searching for globals...
[08:26:24.811] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[08:26:24.811] Searching for globals ... DONE
[08:26:24.811] Resolving globals: FALSE
[08:26:24.812] The total size of the 7 globals is 13.63 KiB (13957 bytes)
[08:26:24.812] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.63 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.09 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:24.813] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:24.813] - packages: [1] ‘future.apply’
[08:26:24.813] getGlobalsAndPackages() ... DONE
[08:26:24.813]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:24.813]  - needed namespaces: [n=1] ‘future.apply’
[08:26:24.813] Finding globals ... DONE
[08:26:24.813]  - use_args: TRUE
[08:26:24.813]  - Getting '...' globals ...
[08:26:24.814] resolve() on list ...
[08:26:24.814]  recursive: 0
[08:26:24.814]  length: 1
[08:26:24.814]  elements: ‘...’
[08:26:24.814]  length: 0 (resolved future 1)
[08:26:24.814] resolve() on list ... DONE
[08:26:24.814]    - '...' content: [n=0] 
[08:26:24.814] List of 1
[08:26:24.814]  $ ...: list()
[08:26:24.814]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:24.814]  - attr(*, "where")=List of 1
[08:26:24.814]   ..$ ...:<environment: 0x562ca9eea1e0> 
[08:26:24.814]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:24.814]  - attr(*, "resolved")= logi TRUE
[08:26:24.814]  - attr(*, "total_size")= num NA
[08:26:24.817]  - Getting '...' globals ... DONE
[08:26:24.817] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:24.817] List of 8
[08:26:24.817]  $ ...future.FUN:function (x, ...)  
[08:26:24.817]  $ x_FUN        :function (x)  
[08:26:24.817]  $ times        : int 4
[08:26:24.817]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:24.817]  $ stop_if_not  :function (...)  
[08:26:24.817]  $ dim          : int [1:2] 2 2
[08:26:24.817]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:24.817]  $ ...          : list()
[08:26:24.817]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:24.817]  - attr(*, "where")=List of 8
[08:26:24.817]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:24.817]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:24.817]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:24.817]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:24.817]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:24.817]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:24.817]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:24.817]   ..$ ...          :<environment: 0x562ca9eea1e0> 
[08:26:24.817]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:24.817]  - attr(*, "resolved")= logi FALSE
[08:26:24.817]  - attr(*, "total_size")= num 24958
[08:26:24.822] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:24.822] getGlobalsAndPackagesXApply() ... DONE
[08:26:24.822] Number of futures (= number of chunks): 2
[08:26:24.823] Launching 2 futures (chunks) ...
[08:26:24.823] Chunk #1 of 2 ...
[08:26:24.823]  - Finding globals in 'X' for chunk #1 ...
[08:26:24.823] getGlobalsAndPackages() ...
[08:26:24.823] Searching for globals...
[08:26:24.823] 
[08:26:24.823] Searching for globals ... DONE
[08:26:24.823] - globals: [0] <none>
[08:26:24.824] getGlobalsAndPackages() ... DONE
[08:26:24.824]    + additional globals found: [n=0] 
[08:26:24.824]    + additional namespaces needed: [n=0] 
[08:26:24.824]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:24.824]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:24.824]  - seeds: <none>
[08:26:24.824]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:24.824] getGlobalsAndPackages() ...
[08:26:24.824] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:24.824] Resolving globals: FALSE
[08:26:24.824] Tweak future expression to call with '...' arguments ...
[08:26:24.825] {
[08:26:24.825]     do.call(function(...) {
[08:26:24.825]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:24.825]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:24.825]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:24.825]             on.exit(options(oopts), add = TRUE)
[08:26:24.825]         }
[08:26:24.825]         {
[08:26:24.825]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:24.825]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:24.825]                 ...future.FUN(...future.X_jj, ...)
[08:26:24.825]             })
[08:26:24.825]         }
[08:26:24.825]     }, args = future.call.arguments)
[08:26:24.825] }
[08:26:24.825] Tweak future expression to call with '...' arguments ... DONE
[08:26:24.825] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:24.825] - packages: [1] ‘future.apply’
[08:26:24.826] getGlobalsAndPackages() ... DONE
[08:26:24.826] run() for ‘Future’ ...
[08:26:24.826] - state: ‘created’
[08:26:24.826] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:24.840] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:24.840] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:24.841]   - Field: ‘node’
[08:26:24.841]   - Field: ‘label’
[08:26:24.841]   - Field: ‘local’
[08:26:24.841]   - Field: ‘owner’
[08:26:24.841]   - Field: ‘envir’
[08:26:24.841]   - Field: ‘workers’
[08:26:24.841]   - Field: ‘packages’
[08:26:24.841]   - Field: ‘gc’
[08:26:24.841]   - Field: ‘conditions’
[08:26:24.841]   - Field: ‘persistent’
[08:26:24.842]   - Field: ‘expr’
[08:26:24.842]   - Field: ‘uuid’
[08:26:24.842]   - Field: ‘seed’
[08:26:24.842]   - Field: ‘version’
[08:26:24.842]   - Field: ‘result’
[08:26:24.842]   - Field: ‘asynchronous’
[08:26:24.842]   - Field: ‘calls’
[08:26:24.842]   - Field: ‘globals’
[08:26:24.842]   - Field: ‘stdout’
[08:26:24.842]   - Field: ‘earlySignal’
[08:26:24.842]   - Field: ‘lazy’
[08:26:24.842]   - Field: ‘state’
[08:26:24.842] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:24.843] - Launch lazy future ...
[08:26:24.843] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:24.843] Packages needed by future strategies (n = 0): <none>
[08:26:24.844] {
[08:26:24.844]     {
[08:26:24.844]         {
[08:26:24.844]             ...future.startTime <- base::Sys.time()
[08:26:24.844]             {
[08:26:24.844]                 {
[08:26:24.844]                   {
[08:26:24.844]                     {
[08:26:24.844]                       {
[08:26:24.844]                         base::local({
[08:26:24.844]                           has_future <- base::requireNamespace("future", 
[08:26:24.844]                             quietly = TRUE)
[08:26:24.844]                           if (has_future) {
[08:26:24.844]                             ns <- base::getNamespace("future")
[08:26:24.844]                             version <- ns[[".package"]][["version"]]
[08:26:24.844]                             if (is.null(version)) 
[08:26:24.844]                               version <- utils::packageVersion("future")
[08:26:24.844]                           }
[08:26:24.844]                           else {
[08:26:24.844]                             version <- NULL
[08:26:24.844]                           }
[08:26:24.844]                           if (!has_future || version < "1.8.0") {
[08:26:24.844]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:24.844]                               "", base::R.version$version.string), 
[08:26:24.844]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:24.844]                                 base::R.version$platform, 8 * 
[08:26:24.844]                                   base::.Machine$sizeof.pointer), 
[08:26:24.844]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:24.844]                                 "release", "version")], collapse = " "), 
[08:26:24.844]                               hostname = base::Sys.info()[["nodename"]])
[08:26:24.844]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:24.844]                               info)
[08:26:24.844]                             info <- base::paste(info, collapse = "; ")
[08:26:24.844]                             if (!has_future) {
[08:26:24.844]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:24.844]                                 info)
[08:26:24.844]                             }
[08:26:24.844]                             else {
[08:26:24.844]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:24.844]                                 info, version)
[08:26:24.844]                             }
[08:26:24.844]                             base::stop(msg)
[08:26:24.844]                           }
[08:26:24.844]                         })
[08:26:24.844]                       }
[08:26:24.844]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:24.844]                       base::options(mc.cores = 1L)
[08:26:24.844]                     }
[08:26:24.844]                     base::local({
[08:26:24.844]                       for (pkg in "future.apply") {
[08:26:24.844]                         base::loadNamespace(pkg)
[08:26:24.844]                         base::library(pkg, character.only = TRUE)
[08:26:24.844]                       }
[08:26:24.844]                     })
[08:26:24.844]                   }
[08:26:24.844]                   ...future.strategy.old <- future::plan("list")
[08:26:24.844]                   options(future.plan = NULL)
[08:26:24.844]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:24.844]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:24.844]                 }
[08:26:24.844]                 ...future.workdir <- getwd()
[08:26:24.844]             }
[08:26:24.844]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:24.844]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:24.844]         }
[08:26:24.844]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:24.844]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:24.844]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:24.844]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:24.844]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:24.844]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:24.844]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:24.844]             base::names(...future.oldOptions))
[08:26:24.844]     }
[08:26:24.844]     if (FALSE) {
[08:26:24.844]     }
[08:26:24.844]     else {
[08:26:24.844]         if (TRUE) {
[08:26:24.844]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:24.844]                 open = "w")
[08:26:24.844]         }
[08:26:24.844]         else {
[08:26:24.844]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:24.844]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:24.844]         }
[08:26:24.844]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:24.844]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:24.844]             base::sink(type = "output", split = FALSE)
[08:26:24.844]             base::close(...future.stdout)
[08:26:24.844]         }, add = TRUE)
[08:26:24.844]     }
[08:26:24.844]     ...future.frame <- base::sys.nframe()
[08:26:24.844]     ...future.conditions <- base::list()
[08:26:24.844]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:24.844]     if (FALSE) {
[08:26:24.844]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:24.844]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:24.844]     }
[08:26:24.844]     ...future.result <- base::tryCatch({
[08:26:24.844]         base::withCallingHandlers({
[08:26:24.844]             ...future.value <- base::withVisible(base::local({
[08:26:24.844]                 ...future.makeSendCondition <- base::local({
[08:26:24.844]                   sendCondition <- NULL
[08:26:24.844]                   function(frame = 1L) {
[08:26:24.844]                     if (is.function(sendCondition)) 
[08:26:24.844]                       return(sendCondition)
[08:26:24.844]                     ns <- getNamespace("parallel")
[08:26:24.844]                     if (exists("sendData", mode = "function", 
[08:26:24.844]                       envir = ns)) {
[08:26:24.844]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:24.844]                         envir = ns)
[08:26:24.844]                       envir <- sys.frame(frame)
[08:26:24.844]                       master <- NULL
[08:26:24.844]                       while (!identical(envir, .GlobalEnv) && 
[08:26:24.844]                         !identical(envir, emptyenv())) {
[08:26:24.844]                         if (exists("master", mode = "list", envir = envir, 
[08:26:24.844]                           inherits = FALSE)) {
[08:26:24.844]                           master <- get("master", mode = "list", 
[08:26:24.844]                             envir = envir, inherits = FALSE)
[08:26:24.844]                           if (inherits(master, c("SOCKnode", 
[08:26:24.844]                             "SOCK0node"))) {
[08:26:24.844]                             sendCondition <<- function(cond) {
[08:26:24.844]                               data <- list(type = "VALUE", value = cond, 
[08:26:24.844]                                 success = TRUE)
[08:26:24.844]                               parallel_sendData(master, data)
[08:26:24.844]                             }
[08:26:24.844]                             return(sendCondition)
[08:26:24.844]                           }
[08:26:24.844]                         }
[08:26:24.844]                         frame <- frame + 1L
[08:26:24.844]                         envir <- sys.frame(frame)
[08:26:24.844]                       }
[08:26:24.844]                     }
[08:26:24.844]                     sendCondition <<- function(cond) NULL
[08:26:24.844]                   }
[08:26:24.844]                 })
[08:26:24.844]                 withCallingHandlers({
[08:26:24.844]                   {
[08:26:24.844]                     do.call(function(...) {
[08:26:24.844]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:24.844]                       if (!identical(...future.globals.maxSize.org, 
[08:26:24.844]                         ...future.globals.maxSize)) {
[08:26:24.844]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:24.844]                         on.exit(options(oopts), add = TRUE)
[08:26:24.844]                       }
[08:26:24.844]                       {
[08:26:24.844]                         lapply(seq_along(...future.elements_ii), 
[08:26:24.844]                           FUN = function(jj) {
[08:26:24.844]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:24.844]                             ...future.FUN(...future.X_jj, ...)
[08:26:24.844]                           })
[08:26:24.844]                       }
[08:26:24.844]                     }, args = future.call.arguments)
[08:26:24.844]                   }
[08:26:24.844]                 }, immediateCondition = function(cond) {
[08:26:24.844]                   sendCondition <- ...future.makeSendCondition()
[08:26:24.844]                   sendCondition(cond)
[08:26:24.844]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:24.844]                   {
[08:26:24.844]                     inherits <- base::inherits
[08:26:24.844]                     invokeRestart <- base::invokeRestart
[08:26:24.844]                     is.null <- base::is.null
[08:26:24.844]                     muffled <- FALSE
[08:26:24.844]                     if (inherits(cond, "message")) {
[08:26:24.844]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:24.844]                       if (muffled) 
[08:26:24.844]                         invokeRestart("muffleMessage")
[08:26:24.844]                     }
[08:26:24.844]                     else if (inherits(cond, "warning")) {
[08:26:24.844]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:24.844]                       if (muffled) 
[08:26:24.844]                         invokeRestart("muffleWarning")
[08:26:24.844]                     }
[08:26:24.844]                     else if (inherits(cond, "condition")) {
[08:26:24.844]                       if (!is.null(pattern)) {
[08:26:24.844]                         computeRestarts <- base::computeRestarts
[08:26:24.844]                         grepl <- base::grepl
[08:26:24.844]                         restarts <- computeRestarts(cond)
[08:26:24.844]                         for (restart in restarts) {
[08:26:24.844]                           name <- restart$name
[08:26:24.844]                           if (is.null(name)) 
[08:26:24.844]                             next
[08:26:24.844]                           if (!grepl(pattern, name)) 
[08:26:24.844]                             next
[08:26:24.844]                           invokeRestart(restart)
[08:26:24.844]                           muffled <- TRUE
[08:26:24.844]                           break
[08:26:24.844]                         }
[08:26:24.844]                       }
[08:26:24.844]                     }
[08:26:24.844]                     invisible(muffled)
[08:26:24.844]                   }
[08:26:24.844]                   muffleCondition(cond)
[08:26:24.844]                 })
[08:26:24.844]             }))
[08:26:24.844]             future::FutureResult(value = ...future.value$value, 
[08:26:24.844]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:24.844]                   ...future.rng), globalenv = if (FALSE) 
[08:26:24.844]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:24.844]                     ...future.globalenv.names))
[08:26:24.844]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:24.844]         }, condition = base::local({
[08:26:24.844]             c <- base::c
[08:26:24.844]             inherits <- base::inherits
[08:26:24.844]             invokeRestart <- base::invokeRestart
[08:26:24.844]             length <- base::length
[08:26:24.844]             list <- base::list
[08:26:24.844]             seq.int <- base::seq.int
[08:26:24.844]             signalCondition <- base::signalCondition
[08:26:24.844]             sys.calls <- base::sys.calls
[08:26:24.844]             `[[` <- base::`[[`
[08:26:24.844]             `+` <- base::`+`
[08:26:24.844]             `<<-` <- base::`<<-`
[08:26:24.844]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:24.844]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:24.844]                   3L)]
[08:26:24.844]             }
[08:26:24.844]             function(cond) {
[08:26:24.844]                 is_error <- inherits(cond, "error")
[08:26:24.844]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:24.844]                   NULL)
[08:26:24.844]                 if (is_error) {
[08:26:24.844]                   sessionInformation <- function() {
[08:26:24.844]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:24.844]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:24.844]                       search = base::search(), system = base::Sys.info())
[08:26:24.844]                   }
[08:26:24.844]                   ...future.conditions[[length(...future.conditions) + 
[08:26:24.844]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:24.844]                     cond$call), session = sessionInformation(), 
[08:26:24.844]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:24.844]                   signalCondition(cond)
[08:26:24.844]                 }
[08:26:24.844]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:24.844]                 "immediateCondition"))) {
[08:26:24.844]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:24.844]                   ...future.conditions[[length(...future.conditions) + 
[08:26:24.844]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:24.844]                   if (TRUE && !signal) {
[08:26:24.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:24.844]                     {
[08:26:24.844]                       inherits <- base::inherits
[08:26:24.844]                       invokeRestart <- base::invokeRestart
[08:26:24.844]                       is.null <- base::is.null
[08:26:24.844]                       muffled <- FALSE
[08:26:24.844]                       if (inherits(cond, "message")) {
[08:26:24.844]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:24.844]                         if (muffled) 
[08:26:24.844]                           invokeRestart("muffleMessage")
[08:26:24.844]                       }
[08:26:24.844]                       else if (inherits(cond, "warning")) {
[08:26:24.844]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:24.844]                         if (muffled) 
[08:26:24.844]                           invokeRestart("muffleWarning")
[08:26:24.844]                       }
[08:26:24.844]                       else if (inherits(cond, "condition")) {
[08:26:24.844]                         if (!is.null(pattern)) {
[08:26:24.844]                           computeRestarts <- base::computeRestarts
[08:26:24.844]                           grepl <- base::grepl
[08:26:24.844]                           restarts <- computeRestarts(cond)
[08:26:24.844]                           for (restart in restarts) {
[08:26:24.844]                             name <- restart$name
[08:26:24.844]                             if (is.null(name)) 
[08:26:24.844]                               next
[08:26:24.844]                             if (!grepl(pattern, name)) 
[08:26:24.844]                               next
[08:26:24.844]                             invokeRestart(restart)
[08:26:24.844]                             muffled <- TRUE
[08:26:24.844]                             break
[08:26:24.844]                           }
[08:26:24.844]                         }
[08:26:24.844]                       }
[08:26:24.844]                       invisible(muffled)
[08:26:24.844]                     }
[08:26:24.844]                     muffleCondition(cond, pattern = "^muffle")
[08:26:24.844]                   }
[08:26:24.844]                 }
[08:26:24.844]                 else {
[08:26:24.844]                   if (TRUE) {
[08:26:24.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:24.844]                     {
[08:26:24.844]                       inherits <- base::inherits
[08:26:24.844]                       invokeRestart <- base::invokeRestart
[08:26:24.844]                       is.null <- base::is.null
[08:26:24.844]                       muffled <- FALSE
[08:26:24.844]                       if (inherits(cond, "message")) {
[08:26:24.844]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:24.844]                         if (muffled) 
[08:26:24.844]                           invokeRestart("muffleMessage")
[08:26:24.844]                       }
[08:26:24.844]                       else if (inherits(cond, "warning")) {
[08:26:24.844]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:24.844]                         if (muffled) 
[08:26:24.844]                           invokeRestart("muffleWarning")
[08:26:24.844]                       }
[08:26:24.844]                       else if (inherits(cond, "condition")) {
[08:26:24.844]                         if (!is.null(pattern)) {
[08:26:24.844]                           computeRestarts <- base::computeRestarts
[08:26:24.844]                           grepl <- base::grepl
[08:26:24.844]                           restarts <- computeRestarts(cond)
[08:26:24.844]                           for (restart in restarts) {
[08:26:24.844]                             name <- restart$name
[08:26:24.844]                             if (is.null(name)) 
[08:26:24.844]                               next
[08:26:24.844]                             if (!grepl(pattern, name)) 
[08:26:24.844]                               next
[08:26:24.844]                             invokeRestart(restart)
[08:26:24.844]                             muffled <- TRUE
[08:26:24.844]                             break
[08:26:24.844]                           }
[08:26:24.844]                         }
[08:26:24.844]                       }
[08:26:24.844]                       invisible(muffled)
[08:26:24.844]                     }
[08:26:24.844]                     muffleCondition(cond, pattern = "^muffle")
[08:26:24.844]                   }
[08:26:24.844]                 }
[08:26:24.844]             }
[08:26:24.844]         }))
[08:26:24.844]     }, error = function(ex) {
[08:26:24.844]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:24.844]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:24.844]                 ...future.rng), started = ...future.startTime, 
[08:26:24.844]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:24.844]             version = "1.8"), class = "FutureResult")
[08:26:24.844]     }, finally = {
[08:26:24.844]         if (!identical(...future.workdir, getwd())) 
[08:26:24.844]             setwd(...future.workdir)
[08:26:24.844]         {
[08:26:24.844]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:24.844]                 ...future.oldOptions$nwarnings <- NULL
[08:26:24.844]             }
[08:26:24.844]             base::options(...future.oldOptions)
[08:26:24.844]             if (.Platform$OS.type == "windows") {
[08:26:24.844]                 old_names <- names(...future.oldEnvVars)
[08:26:24.844]                 envs <- base::Sys.getenv()
[08:26:24.844]                 names <- names(envs)
[08:26:24.844]                 common <- intersect(names, old_names)
[08:26:24.844]                 added <- setdiff(names, old_names)
[08:26:24.844]                 removed <- setdiff(old_names, names)
[08:26:24.844]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:24.844]                   envs[common]]
[08:26:24.844]                 NAMES <- toupper(changed)
[08:26:24.844]                 args <- list()
[08:26:24.844]                 for (kk in seq_along(NAMES)) {
[08:26:24.844]                   name <- changed[[kk]]
[08:26:24.844]                   NAME <- NAMES[[kk]]
[08:26:24.844]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:24.844]                     next
[08:26:24.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:24.844]                 }
[08:26:24.844]                 NAMES <- toupper(added)
[08:26:24.844]                 for (kk in seq_along(NAMES)) {
[08:26:24.844]                   name <- added[[kk]]
[08:26:24.844]                   NAME <- NAMES[[kk]]
[08:26:24.844]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:24.844]                     next
[08:26:24.844]                   args[[name]] <- ""
[08:26:24.844]                 }
[08:26:24.844]                 NAMES <- toupper(removed)
[08:26:24.844]                 for (kk in seq_along(NAMES)) {
[08:26:24.844]                   name <- removed[[kk]]
[08:26:24.844]                   NAME <- NAMES[[kk]]
[08:26:24.844]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:24.844]                     next
[08:26:24.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:24.844]                 }
[08:26:24.844]                 if (length(args) > 0) 
[08:26:24.844]                   base::do.call(base::Sys.setenv, args = args)
[08:26:24.844]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:24.844]             }
[08:26:24.844]             else {
[08:26:24.844]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:24.844]             }
[08:26:24.844]             {
[08:26:24.844]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:24.844]                   0L) {
[08:26:24.844]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:24.844]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:24.844]                   base::options(opts)
[08:26:24.844]                 }
[08:26:24.844]                 {
[08:26:24.844]                   {
[08:26:24.844]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:24.844]                     NULL
[08:26:24.844]                   }
[08:26:24.844]                   options(future.plan = NULL)
[08:26:24.844]                   if (is.na(NA_character_)) 
[08:26:24.844]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:24.844]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:24.844]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:24.844]                     .init = FALSE)
[08:26:24.844]                 }
[08:26:24.844]             }
[08:26:24.844]         }
[08:26:24.844]     })
[08:26:24.844]     if (TRUE) {
[08:26:24.844]         base::sink(type = "output", split = FALSE)
[08:26:24.844]         if (TRUE) {
[08:26:24.844]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:24.844]         }
[08:26:24.844]         else {
[08:26:24.844]             ...future.result["stdout"] <- base::list(NULL)
[08:26:24.844]         }
[08:26:24.844]         base::close(...future.stdout)
[08:26:24.844]         ...future.stdout <- NULL
[08:26:24.844]     }
[08:26:24.844]     ...future.result$conditions <- ...future.conditions
[08:26:24.844]     ...future.result$finished <- base::Sys.time()
[08:26:24.844]     ...future.result
[08:26:24.844] }
[08:26:24.847] Exporting 11 global objects (14.06 KiB) to cluster node #1 ...
[08:26:24.847] Exporting ‘...future.FUN’ (5.08 KiB) to cluster node #1 ...
[08:26:24.891] Exporting ‘...future.FUN’ (5.08 KiB) to cluster node #1 ... DONE
[08:26:24.891] Exporting ‘x_FUN’ (567 bytes) to cluster node #1 ...
[08:26:24.891] Exporting ‘x_FUN’ (567 bytes) to cluster node #1 ... DONE
[08:26:24.892] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[08:26:24.892] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[08:26:24.892] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[08:26:24.934] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[08:26:24.934] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[08:26:24.975] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[08:26:24.975] Exporting ‘dim’ (39 bytes) to cluster node #1 ...
[08:26:24.975] Exporting ‘dim’ (39 bytes) to cluster node #1 ... DONE
[08:26:24.976] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[08:26:24.976] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[08:26:24.976] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:26:24.976] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:26:24.977] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ...
[08:26:24.977] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ... DONE
[08:26:24.977] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:26:24.977] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:26:24.977] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:26:24.978] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:26:24.978] Exporting 11 global objects (14.06 KiB) to cluster node #1 ... DONE
[08:26:24.978] MultisessionFuture started
[08:26:24.979] - Launch lazy future ... done
[08:26:24.979] run() for ‘MultisessionFuture’ ... done
[08:26:24.979] Created future:
[08:26:24.979] MultisessionFuture:
[08:26:24.979] Label: ‘future_vapply-1’
[08:26:24.979] Expression:
[08:26:24.979] {
[08:26:24.979]     do.call(function(...) {
[08:26:24.979]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:24.979]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:24.979]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:24.979]             on.exit(options(oopts), add = TRUE)
[08:26:24.979]         }
[08:26:24.979]         {
[08:26:24.979]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:24.979]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:24.979]                 ...future.FUN(...future.X_jj, ...)
[08:26:24.979]             })
[08:26:24.979]         }
[08:26:24.979]     }, args = future.call.arguments)
[08:26:24.979] }
[08:26:24.979] Lazy evaluation: FALSE
[08:26:24.979] Asynchronous evaluation: TRUE
[08:26:24.979] Local evaluation: TRUE
[08:26:24.979] Environment: R_GlobalEnv
[08:26:24.979] Capture standard output: TRUE
[08:26:24.979] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:24.979] Globals: 11 objects totaling 13.86 KiB (function ‘...future.FUN’ of 5.08 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:24.979] Packages: 1 packages (‘future.apply’)
[08:26:24.979] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:24.979] Resolved: FALSE
[08:26:24.979] Value: <not collected>
[08:26:24.979] Conditions captured: <none>
[08:26:24.979] Early signaling: FALSE
[08:26:24.979] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:24.979] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:24.991] Chunk #1 of 2 ... DONE
[08:26:24.991] Chunk #2 of 2 ...
[08:26:24.991]  - Finding globals in 'X' for chunk #2 ...
[08:26:24.991] getGlobalsAndPackages() ...
[08:26:24.991] Searching for globals...
[08:26:24.991] 
[08:26:24.991] Searching for globals ... DONE
[08:26:24.992] - globals: [0] <none>
[08:26:24.992] getGlobalsAndPackages() ... DONE
[08:26:24.992]    + additional globals found: [n=0] 
[08:26:24.992]    + additional namespaces needed: [n=0] 
[08:26:24.992]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:24.992]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:24.992]  - seeds: <none>
[08:26:24.992]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:24.992] getGlobalsAndPackages() ...
[08:26:24.992] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:24.992] Resolving globals: FALSE
[08:26:24.993] Tweak future expression to call with '...' arguments ...
[08:26:24.993] {
[08:26:24.993]     do.call(function(...) {
[08:26:24.993]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:24.993]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:24.993]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:24.993]             on.exit(options(oopts), add = TRUE)
[08:26:24.993]         }
[08:26:24.993]         {
[08:26:24.993]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:24.993]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:24.993]                 ...future.FUN(...future.X_jj, ...)
[08:26:24.993]             })
[08:26:24.993]         }
[08:26:24.993]     }, args = future.call.arguments)
[08:26:24.993] }
[08:26:24.993] Tweak future expression to call with '...' arguments ... DONE
[08:26:24.993] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:24.994] - packages: [1] ‘future.apply’
[08:26:24.994] getGlobalsAndPackages() ... DONE
[08:26:24.994] run() for ‘Future’ ...
[08:26:24.994] - state: ‘created’
[08:26:24.994] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:25.008] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:25.009] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:25.009]   - Field: ‘node’
[08:26:25.009]   - Field: ‘label’
[08:26:25.009]   - Field: ‘local’
[08:26:25.009]   - Field: ‘owner’
[08:26:25.009]   - Field: ‘envir’
[08:26:25.009]   - Field: ‘workers’
[08:26:25.009]   - Field: ‘packages’
[08:26:25.009]   - Field: ‘gc’
[08:26:25.010]   - Field: ‘conditions’
[08:26:25.010]   - Field: ‘persistent’
[08:26:25.010]   - Field: ‘expr’
[08:26:25.010]   - Field: ‘uuid’
[08:26:25.010]   - Field: ‘seed’
[08:26:25.010]   - Field: ‘version’
[08:26:25.010]   - Field: ‘result’
[08:26:25.010]   - Field: ‘asynchronous’
[08:26:25.010]   - Field: ‘calls’
[08:26:25.010]   - Field: ‘globals’
[08:26:25.010]   - Field: ‘stdout’
[08:26:25.010]   - Field: ‘earlySignal’
[08:26:25.011]   - Field: ‘lazy’
[08:26:25.011]   - Field: ‘state’
[08:26:25.011] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:25.011] - Launch lazy future ...
[08:26:25.011] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:25.011] Packages needed by future strategies (n = 0): <none>
[08:26:25.012] {
[08:26:25.012]     {
[08:26:25.012]         {
[08:26:25.012]             ...future.startTime <- base::Sys.time()
[08:26:25.012]             {
[08:26:25.012]                 {
[08:26:25.012]                   {
[08:26:25.012]                     {
[08:26:25.012]                       {
[08:26:25.012]                         base::local({
[08:26:25.012]                           has_future <- base::requireNamespace("future", 
[08:26:25.012]                             quietly = TRUE)
[08:26:25.012]                           if (has_future) {
[08:26:25.012]                             ns <- base::getNamespace("future")
[08:26:25.012]                             version <- ns[[".package"]][["version"]]
[08:26:25.012]                             if (is.null(version)) 
[08:26:25.012]                               version <- utils::packageVersion("future")
[08:26:25.012]                           }
[08:26:25.012]                           else {
[08:26:25.012]                             version <- NULL
[08:26:25.012]                           }
[08:26:25.012]                           if (!has_future || version < "1.8.0") {
[08:26:25.012]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:25.012]                               "", base::R.version$version.string), 
[08:26:25.012]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:25.012]                                 base::R.version$platform, 8 * 
[08:26:25.012]                                   base::.Machine$sizeof.pointer), 
[08:26:25.012]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:25.012]                                 "release", "version")], collapse = " "), 
[08:26:25.012]                               hostname = base::Sys.info()[["nodename"]])
[08:26:25.012]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:25.012]                               info)
[08:26:25.012]                             info <- base::paste(info, collapse = "; ")
[08:26:25.012]                             if (!has_future) {
[08:26:25.012]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:25.012]                                 info)
[08:26:25.012]                             }
[08:26:25.012]                             else {
[08:26:25.012]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:25.012]                                 info, version)
[08:26:25.012]                             }
[08:26:25.012]                             base::stop(msg)
[08:26:25.012]                           }
[08:26:25.012]                         })
[08:26:25.012]                       }
[08:26:25.012]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:25.012]                       base::options(mc.cores = 1L)
[08:26:25.012]                     }
[08:26:25.012]                     base::local({
[08:26:25.012]                       for (pkg in "future.apply") {
[08:26:25.012]                         base::loadNamespace(pkg)
[08:26:25.012]                         base::library(pkg, character.only = TRUE)
[08:26:25.012]                       }
[08:26:25.012]                     })
[08:26:25.012]                   }
[08:26:25.012]                   ...future.strategy.old <- future::plan("list")
[08:26:25.012]                   options(future.plan = NULL)
[08:26:25.012]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:25.012]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:25.012]                 }
[08:26:25.012]                 ...future.workdir <- getwd()
[08:26:25.012]             }
[08:26:25.012]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:25.012]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:25.012]         }
[08:26:25.012]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:25.012]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:25.012]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:25.012]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:25.012]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:25.012]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:25.012]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:25.012]             base::names(...future.oldOptions))
[08:26:25.012]     }
[08:26:25.012]     if (FALSE) {
[08:26:25.012]     }
[08:26:25.012]     else {
[08:26:25.012]         if (TRUE) {
[08:26:25.012]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:25.012]                 open = "w")
[08:26:25.012]         }
[08:26:25.012]         else {
[08:26:25.012]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:25.012]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:25.012]         }
[08:26:25.012]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:25.012]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:25.012]             base::sink(type = "output", split = FALSE)
[08:26:25.012]             base::close(...future.stdout)
[08:26:25.012]         }, add = TRUE)
[08:26:25.012]     }
[08:26:25.012]     ...future.frame <- base::sys.nframe()
[08:26:25.012]     ...future.conditions <- base::list()
[08:26:25.012]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:25.012]     if (FALSE) {
[08:26:25.012]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:25.012]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:25.012]     }
[08:26:25.012]     ...future.result <- base::tryCatch({
[08:26:25.012]         base::withCallingHandlers({
[08:26:25.012]             ...future.value <- base::withVisible(base::local({
[08:26:25.012]                 ...future.makeSendCondition <- base::local({
[08:26:25.012]                   sendCondition <- NULL
[08:26:25.012]                   function(frame = 1L) {
[08:26:25.012]                     if (is.function(sendCondition)) 
[08:26:25.012]                       return(sendCondition)
[08:26:25.012]                     ns <- getNamespace("parallel")
[08:26:25.012]                     if (exists("sendData", mode = "function", 
[08:26:25.012]                       envir = ns)) {
[08:26:25.012]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:25.012]                         envir = ns)
[08:26:25.012]                       envir <- sys.frame(frame)
[08:26:25.012]                       master <- NULL
[08:26:25.012]                       while (!identical(envir, .GlobalEnv) && 
[08:26:25.012]                         !identical(envir, emptyenv())) {
[08:26:25.012]                         if (exists("master", mode = "list", envir = envir, 
[08:26:25.012]                           inherits = FALSE)) {
[08:26:25.012]                           master <- get("master", mode = "list", 
[08:26:25.012]                             envir = envir, inherits = FALSE)
[08:26:25.012]                           if (inherits(master, c("SOCKnode", 
[08:26:25.012]                             "SOCK0node"))) {
[08:26:25.012]                             sendCondition <<- function(cond) {
[08:26:25.012]                               data <- list(type = "VALUE", value = cond, 
[08:26:25.012]                                 success = TRUE)
[08:26:25.012]                               parallel_sendData(master, data)
[08:26:25.012]                             }
[08:26:25.012]                             return(sendCondition)
[08:26:25.012]                           }
[08:26:25.012]                         }
[08:26:25.012]                         frame <- frame + 1L
[08:26:25.012]                         envir <- sys.frame(frame)
[08:26:25.012]                       }
[08:26:25.012]                     }
[08:26:25.012]                     sendCondition <<- function(cond) NULL
[08:26:25.012]                   }
[08:26:25.012]                 })
[08:26:25.012]                 withCallingHandlers({
[08:26:25.012]                   {
[08:26:25.012]                     do.call(function(...) {
[08:26:25.012]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:25.012]                       if (!identical(...future.globals.maxSize.org, 
[08:26:25.012]                         ...future.globals.maxSize)) {
[08:26:25.012]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:25.012]                         on.exit(options(oopts), add = TRUE)
[08:26:25.012]                       }
[08:26:25.012]                       {
[08:26:25.012]                         lapply(seq_along(...future.elements_ii), 
[08:26:25.012]                           FUN = function(jj) {
[08:26:25.012]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:25.012]                             ...future.FUN(...future.X_jj, ...)
[08:26:25.012]                           })
[08:26:25.012]                       }
[08:26:25.012]                     }, args = future.call.arguments)
[08:26:25.012]                   }
[08:26:25.012]                 }, immediateCondition = function(cond) {
[08:26:25.012]                   sendCondition <- ...future.makeSendCondition()
[08:26:25.012]                   sendCondition(cond)
[08:26:25.012]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:25.012]                   {
[08:26:25.012]                     inherits <- base::inherits
[08:26:25.012]                     invokeRestart <- base::invokeRestart
[08:26:25.012]                     is.null <- base::is.null
[08:26:25.012]                     muffled <- FALSE
[08:26:25.012]                     if (inherits(cond, "message")) {
[08:26:25.012]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:25.012]                       if (muffled) 
[08:26:25.012]                         invokeRestart("muffleMessage")
[08:26:25.012]                     }
[08:26:25.012]                     else if (inherits(cond, "warning")) {
[08:26:25.012]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:25.012]                       if (muffled) 
[08:26:25.012]                         invokeRestart("muffleWarning")
[08:26:25.012]                     }
[08:26:25.012]                     else if (inherits(cond, "condition")) {
[08:26:25.012]                       if (!is.null(pattern)) {
[08:26:25.012]                         computeRestarts <- base::computeRestarts
[08:26:25.012]                         grepl <- base::grepl
[08:26:25.012]                         restarts <- computeRestarts(cond)
[08:26:25.012]                         for (restart in restarts) {
[08:26:25.012]                           name <- restart$name
[08:26:25.012]                           if (is.null(name)) 
[08:26:25.012]                             next
[08:26:25.012]                           if (!grepl(pattern, name)) 
[08:26:25.012]                             next
[08:26:25.012]                           invokeRestart(restart)
[08:26:25.012]                           muffled <- TRUE
[08:26:25.012]                           break
[08:26:25.012]                         }
[08:26:25.012]                       }
[08:26:25.012]                     }
[08:26:25.012]                     invisible(muffled)
[08:26:25.012]                   }
[08:26:25.012]                   muffleCondition(cond)
[08:26:25.012]                 })
[08:26:25.012]             }))
[08:26:25.012]             future::FutureResult(value = ...future.value$value, 
[08:26:25.012]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:25.012]                   ...future.rng), globalenv = if (FALSE) 
[08:26:25.012]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:25.012]                     ...future.globalenv.names))
[08:26:25.012]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:25.012]         }, condition = base::local({
[08:26:25.012]             c <- base::c
[08:26:25.012]             inherits <- base::inherits
[08:26:25.012]             invokeRestart <- base::invokeRestart
[08:26:25.012]             length <- base::length
[08:26:25.012]             list <- base::list
[08:26:25.012]             seq.int <- base::seq.int
[08:26:25.012]             signalCondition <- base::signalCondition
[08:26:25.012]             sys.calls <- base::sys.calls
[08:26:25.012]             `[[` <- base::`[[`
[08:26:25.012]             `+` <- base::`+`
[08:26:25.012]             `<<-` <- base::`<<-`
[08:26:25.012]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:25.012]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:25.012]                   3L)]
[08:26:25.012]             }
[08:26:25.012]             function(cond) {
[08:26:25.012]                 is_error <- inherits(cond, "error")
[08:26:25.012]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:25.012]                   NULL)
[08:26:25.012]                 if (is_error) {
[08:26:25.012]                   sessionInformation <- function() {
[08:26:25.012]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:25.012]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:25.012]                       search = base::search(), system = base::Sys.info())
[08:26:25.012]                   }
[08:26:25.012]                   ...future.conditions[[length(...future.conditions) + 
[08:26:25.012]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:25.012]                     cond$call), session = sessionInformation(), 
[08:26:25.012]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:25.012]                   signalCondition(cond)
[08:26:25.012]                 }
[08:26:25.012]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:25.012]                 "immediateCondition"))) {
[08:26:25.012]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:25.012]                   ...future.conditions[[length(...future.conditions) + 
[08:26:25.012]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:25.012]                   if (TRUE && !signal) {
[08:26:25.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:25.012]                     {
[08:26:25.012]                       inherits <- base::inherits
[08:26:25.012]                       invokeRestart <- base::invokeRestart
[08:26:25.012]                       is.null <- base::is.null
[08:26:25.012]                       muffled <- FALSE
[08:26:25.012]                       if (inherits(cond, "message")) {
[08:26:25.012]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:25.012]                         if (muffled) 
[08:26:25.012]                           invokeRestart("muffleMessage")
[08:26:25.012]                       }
[08:26:25.012]                       else if (inherits(cond, "warning")) {
[08:26:25.012]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:25.012]                         if (muffled) 
[08:26:25.012]                           invokeRestart("muffleWarning")
[08:26:25.012]                       }
[08:26:25.012]                       else if (inherits(cond, "condition")) {
[08:26:25.012]                         if (!is.null(pattern)) {
[08:26:25.012]                           computeRestarts <- base::computeRestarts
[08:26:25.012]                           grepl <- base::grepl
[08:26:25.012]                           restarts <- computeRestarts(cond)
[08:26:25.012]                           for (restart in restarts) {
[08:26:25.012]                             name <- restart$name
[08:26:25.012]                             if (is.null(name)) 
[08:26:25.012]                               next
[08:26:25.012]                             if (!grepl(pattern, name)) 
[08:26:25.012]                               next
[08:26:25.012]                             invokeRestart(restart)
[08:26:25.012]                             muffled <- TRUE
[08:26:25.012]                             break
[08:26:25.012]                           }
[08:26:25.012]                         }
[08:26:25.012]                       }
[08:26:25.012]                       invisible(muffled)
[08:26:25.012]                     }
[08:26:25.012]                     muffleCondition(cond, pattern = "^muffle")
[08:26:25.012]                   }
[08:26:25.012]                 }
[08:26:25.012]                 else {
[08:26:25.012]                   if (TRUE) {
[08:26:25.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:25.012]                     {
[08:26:25.012]                       inherits <- base::inherits
[08:26:25.012]                       invokeRestart <- base::invokeRestart
[08:26:25.012]                       is.null <- base::is.null
[08:26:25.012]                       muffled <- FALSE
[08:26:25.012]                       if (inherits(cond, "message")) {
[08:26:25.012]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:25.012]                         if (muffled) 
[08:26:25.012]                           invokeRestart("muffleMessage")
[08:26:25.012]                       }
[08:26:25.012]                       else if (inherits(cond, "warning")) {
[08:26:25.012]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:25.012]                         if (muffled) 
[08:26:25.012]                           invokeRestart("muffleWarning")
[08:26:25.012]                       }
[08:26:25.012]                       else if (inherits(cond, "condition")) {
[08:26:25.012]                         if (!is.null(pattern)) {
[08:26:25.012]                           computeRestarts <- base::computeRestarts
[08:26:25.012]                           grepl <- base::grepl
[08:26:25.012]                           restarts <- computeRestarts(cond)
[08:26:25.012]                           for (restart in restarts) {
[08:26:25.012]                             name <- restart$name
[08:26:25.012]                             if (is.null(name)) 
[08:26:25.012]                               next
[08:26:25.012]                             if (!grepl(pattern, name)) 
[08:26:25.012]                               next
[08:26:25.012]                             invokeRestart(restart)
[08:26:25.012]                             muffled <- TRUE
[08:26:25.012]                             break
[08:26:25.012]                           }
[08:26:25.012]                         }
[08:26:25.012]                       }
[08:26:25.012]                       invisible(muffled)
[08:26:25.012]                     }
[08:26:25.012]                     muffleCondition(cond, pattern = "^muffle")
[08:26:25.012]                   }
[08:26:25.012]                 }
[08:26:25.012]             }
[08:26:25.012]         }))
[08:26:25.012]     }, error = function(ex) {
[08:26:25.012]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:25.012]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:25.012]                 ...future.rng), started = ...future.startTime, 
[08:26:25.012]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:25.012]             version = "1.8"), class = "FutureResult")
[08:26:25.012]     }, finally = {
[08:26:25.012]         if (!identical(...future.workdir, getwd())) 
[08:26:25.012]             setwd(...future.workdir)
[08:26:25.012]         {
[08:26:25.012]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:25.012]                 ...future.oldOptions$nwarnings <- NULL
[08:26:25.012]             }
[08:26:25.012]             base::options(...future.oldOptions)
[08:26:25.012]             if (.Platform$OS.type == "windows") {
[08:26:25.012]                 old_names <- names(...future.oldEnvVars)
[08:26:25.012]                 envs <- base::Sys.getenv()
[08:26:25.012]                 names <- names(envs)
[08:26:25.012]                 common <- intersect(names, old_names)
[08:26:25.012]                 added <- setdiff(names, old_names)
[08:26:25.012]                 removed <- setdiff(old_names, names)
[08:26:25.012]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:25.012]                   envs[common]]
[08:26:25.012]                 NAMES <- toupper(changed)
[08:26:25.012]                 args <- list()
[08:26:25.012]                 for (kk in seq_along(NAMES)) {
[08:26:25.012]                   name <- changed[[kk]]
[08:26:25.012]                   NAME <- NAMES[[kk]]
[08:26:25.012]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:25.012]                     next
[08:26:25.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:25.012]                 }
[08:26:25.012]                 NAMES <- toupper(added)
[08:26:25.012]                 for (kk in seq_along(NAMES)) {
[08:26:25.012]                   name <- added[[kk]]
[08:26:25.012]                   NAME <- NAMES[[kk]]
[08:26:25.012]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:25.012]                     next
[08:26:25.012]                   args[[name]] <- ""
[08:26:25.012]                 }
[08:26:25.012]                 NAMES <- toupper(removed)
[08:26:25.012]                 for (kk in seq_along(NAMES)) {
[08:26:25.012]                   name <- removed[[kk]]
[08:26:25.012]                   NAME <- NAMES[[kk]]
[08:26:25.012]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:25.012]                     next
[08:26:25.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:25.012]                 }
[08:26:25.012]                 if (length(args) > 0) 
[08:26:25.012]                   base::do.call(base::Sys.setenv, args = args)
[08:26:25.012]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:25.012]             }
[08:26:25.012]             else {
[08:26:25.012]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:25.012]             }
[08:26:25.012]             {
[08:26:25.012]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:25.012]                   0L) {
[08:26:25.012]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:25.012]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:25.012]                   base::options(opts)
[08:26:25.012]                 }
[08:26:25.012]                 {
[08:26:25.012]                   {
[08:26:25.012]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:25.012]                     NULL
[08:26:25.012]                   }
[08:26:25.012]                   options(future.plan = NULL)
[08:26:25.012]                   if (is.na(NA_character_)) 
[08:26:25.012]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:25.012]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:25.012]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:25.012]                     .init = FALSE)
[08:26:25.012]                 }
[08:26:25.012]             }
[08:26:25.012]         }
[08:26:25.012]     })
[08:26:25.012]     if (TRUE) {
[08:26:25.012]         base::sink(type = "output", split = FALSE)
[08:26:25.012]         if (TRUE) {
[08:26:25.012]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:25.012]         }
[08:26:25.012]         else {
[08:26:25.012]             ...future.result["stdout"] <- base::list(NULL)
[08:26:25.012]         }
[08:26:25.012]         base::close(...future.stdout)
[08:26:25.012]         ...future.stdout <- NULL
[08:26:25.012]     }
[08:26:25.012]     ...future.result$conditions <- ...future.conditions
[08:26:25.012]     ...future.result$finished <- base::Sys.time()
[08:26:25.012]     ...future.result
[08:26:25.012] }
[08:26:25.015] Exporting 11 global objects (14.06 KiB) to cluster node #2 ...
[08:26:25.015] Exporting ‘...future.FUN’ (5.08 KiB) to cluster node #2 ...
[08:26:25.057] Exporting ‘...future.FUN’ (5.08 KiB) to cluster node #2 ... DONE
[08:26:25.057] Exporting ‘x_FUN’ (567 bytes) to cluster node #2 ...
[08:26:25.057] Exporting ‘x_FUN’ (567 bytes) to cluster node #2 ... DONE
[08:26:25.057] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[08:26:25.058] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[08:26:25.058] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[08:26:25.100] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[08:26:25.100] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[08:26:25.142] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[08:26:25.142] Exporting ‘dim’ (39 bytes) to cluster node #2 ...
[08:26:25.142] Exporting ‘dim’ (39 bytes) to cluster node #2 ... DONE
[08:26:25.142] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[08:26:25.143] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[08:26:25.143] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:26:25.143] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:26:25.143] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ...
[08:26:25.144] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ... DONE
[08:26:25.144] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:26:25.144] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:26:25.144] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:26:25.145] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:26:25.145] Exporting 11 global objects (14.06 KiB) to cluster node #2 ... DONE
[08:26:25.145] MultisessionFuture started
[08:26:25.146] - Launch lazy future ... done
[08:26:25.146] run() for ‘MultisessionFuture’ ... done
[08:26:25.146] Created future:
[08:26:25.146] MultisessionFuture:
[08:26:25.146] Label: ‘future_vapply-2’
[08:26:25.146] Expression:
[08:26:25.146] {
[08:26:25.146]     do.call(function(...) {
[08:26:25.146]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:25.146]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:25.146]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:25.146]             on.exit(options(oopts), add = TRUE)
[08:26:25.146]         }
[08:26:25.146]         {
[08:26:25.146]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:25.146]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:25.146]                 ...future.FUN(...future.X_jj, ...)
[08:26:25.146]             })
[08:26:25.146]         }
[08:26:25.146]     }, args = future.call.arguments)
[08:26:25.146] }
[08:26:25.146] Lazy evaluation: FALSE
[08:26:25.146] Asynchronous evaluation: TRUE
[08:26:25.146] Local evaluation: TRUE
[08:26:25.146] Environment: R_GlobalEnv
[08:26:25.146] Capture standard output: TRUE
[08:26:25.146] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:25.146] Globals: 11 objects totaling 13.86 KiB (function ‘...future.FUN’ of 5.08 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:25.146] Packages: 1 packages (‘future.apply’)
[08:26:25.146] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:25.146] Resolved: FALSE
[08:26:25.146] Value: <not collected>
[08:26:25.146] Conditions captured: <none>
[08:26:25.146] Early signaling: FALSE
[08:26:25.146] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:25.146] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:25.158] Chunk #2 of 2 ... DONE
[08:26:25.158] Launching 2 futures (chunks) ... DONE
[08:26:25.158] Resolving 2 futures (chunks) ...
[08:26:25.158] resolve() on list ...
[08:26:25.158]  recursive: 0
[08:26:25.158]  length: 2
[08:26:25.158] 
[08:26:25.159] receiveMessageFromWorker() for ClusterFuture ...
[08:26:25.159] - Validating connection of MultisessionFuture
[08:26:25.159] - received message: FutureResult
[08:26:25.159] - Received FutureResult
[08:26:25.160] - Erased future from FutureRegistry
[08:26:25.160] result() for ClusterFuture ...
[08:26:25.160] - result already collected: FutureResult
[08:26:25.160] result() for ClusterFuture ... done
[08:26:25.160] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:25.160] Future #1
[08:26:25.160] result() for ClusterFuture ...
[08:26:25.160] - result already collected: FutureResult
[08:26:25.160] result() for ClusterFuture ... done
[08:26:25.160] result() for ClusterFuture ...
[08:26:25.160] - result already collected: FutureResult
[08:26:25.160] result() for ClusterFuture ... done
[08:26:25.161] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:26:25.161] - nx: 2
[08:26:25.161] - relay: TRUE
[08:26:25.161] - stdout: TRUE
[08:26:25.161] - signal: TRUE
[08:26:25.161] - resignal: FALSE
[08:26:25.161] - force: TRUE
[08:26:25.161] - relayed: [n=2] FALSE, FALSE
[08:26:25.161] - queued futures: [n=2] FALSE, FALSE
[08:26:25.161]  - until=1
[08:26:25.161]  - relaying element #1
[08:26:25.161] result() for ClusterFuture ...
[08:26:25.162] - result already collected: FutureResult
[08:26:25.162] result() for ClusterFuture ... done
[08:26:25.162] result() for ClusterFuture ...
[08:26:25.162] - result already collected: FutureResult
[08:26:25.162] result() for ClusterFuture ... done
[08:26:25.162] result() for ClusterFuture ...
[08:26:25.162] - result already collected: FutureResult
[08:26:25.162] result() for ClusterFuture ... done
[08:26:25.162] result() for ClusterFuture ...
[08:26:25.162] - result already collected: FutureResult
[08:26:25.162] result() for ClusterFuture ... done
[08:26:25.162] - relayed: [n=2] TRUE, FALSE
[08:26:25.163] - queued futures: [n=2] TRUE, FALSE
[08:26:25.163] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:26:25.163]  length: 1 (resolved future 1)
[08:26:25.187] receiveMessageFromWorker() for ClusterFuture ...
[08:26:25.188] - Validating connection of MultisessionFuture
[08:26:25.188] - received message: FutureResult
[08:26:25.188] - Received FutureResult
[08:26:25.188] - Erased future from FutureRegistry
[08:26:25.188] result() for ClusterFuture ...
[08:26:25.188] - result already collected: FutureResult
[08:26:25.188] result() for ClusterFuture ... done
[08:26:25.188] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:25.189] Future #2
[08:26:25.189] result() for ClusterFuture ...
[08:26:25.189] - result already collected: FutureResult
[08:26:25.189] result() for ClusterFuture ... done
[08:26:25.189] result() for ClusterFuture ...
[08:26:25.189] - result already collected: FutureResult
[08:26:25.189] result() for ClusterFuture ... done
[08:26:25.189] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:26:25.189] - nx: 2
[08:26:25.189] - relay: TRUE
[08:26:25.189] - stdout: TRUE
[08:26:25.190] - signal: TRUE
[08:26:25.190] - resignal: FALSE
[08:26:25.190] - force: TRUE
[08:26:25.190] - relayed: [n=2] TRUE, FALSE
[08:26:25.190] - queued futures: [n=2] TRUE, FALSE
[08:26:25.190]  - until=2
[08:26:25.190]  - relaying element #2
[08:26:25.190] result() for ClusterFuture ...
[08:26:25.190] - result already collected: FutureResult
[08:26:25.190] result() for ClusterFuture ... done
[08:26:25.190] result() for ClusterFuture ...
[08:26:25.190] - result already collected: FutureResult
[08:26:25.191] result() for ClusterFuture ... done
[08:26:25.191] result() for ClusterFuture ...
[08:26:25.191] - result already collected: FutureResult
[08:26:25.191] result() for ClusterFuture ... done
[08:26:25.191] result() for ClusterFuture ...
[08:26:25.191] - result already collected: FutureResult
[08:26:25.191] result() for ClusterFuture ... done
[08:26:25.191] - relayed: [n=2] TRUE, TRUE
[08:26:25.191] - queued futures: [n=2] TRUE, TRUE
[08:26:25.191] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:26:25.191]  length: 0 (resolved future 2)
[08:26:25.192] Relaying remaining futures
[08:26:25.192] signalConditionsASAP(NULL, pos=0) ...
[08:26:25.192] - nx: 2
[08:26:25.192] - relay: TRUE
[08:26:25.192] - stdout: TRUE
[08:26:25.192] - signal: TRUE
[08:26:25.192] - resignal: FALSE
[08:26:25.192] - force: TRUE
[08:26:25.192] - relayed: [n=2] TRUE, TRUE
[08:26:25.192] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:25.192] - relayed: [n=2] TRUE, TRUE
[08:26:25.192] - queued futures: [n=2] TRUE, TRUE
[08:26:25.193] signalConditionsASAP(NULL, pos=0) ... done
[08:26:25.193] resolve() on list ... DONE
[08:26:25.193] result() for ClusterFuture ...
[08:26:25.193] - result already collected: FutureResult
[08:26:25.193] result() for ClusterFuture ... done
[08:26:25.193] result() for ClusterFuture ...
[08:26:25.193] - result already collected: FutureResult
[08:26:25.193] result() for ClusterFuture ... done
[08:26:25.193] result() for ClusterFuture ...
[08:26:25.193] - result already collected: FutureResult
[08:26:25.193] result() for ClusterFuture ... done
[08:26:25.194] result() for ClusterFuture ...
[08:26:25.194] - result already collected: FutureResult
[08:26:25.194] result() for ClusterFuture ... done
[08:26:25.194]  - Number of value chunks collected: 2
[08:26:25.194] Resolving 2 futures (chunks) ... DONE
[08:26:25.194] Reducing values from 2 chunks ...
[08:26:25.194]  - Number of values collected after concatenation: 10
[08:26:25.194]  - Number of values expected: 10
[08:26:25.194] Reducing values from 2 chunks ... DONE
[08:26:25.194] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[08:26:25.196] future_lapply() ...
[08:26:25.200] Number of chunks: 2
[08:26:25.200] getGlobalsAndPackagesXApply() ...
[08:26:25.200]  - future.globals: TRUE
[08:26:25.200] getGlobalsAndPackages() ...
[08:26:25.200] Searching for globals...
[08:26:25.204] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[08:26:25.204] Searching for globals ... DONE
[08:26:25.204] Resolving globals: FALSE
[08:26:25.205] The total size of the 7 globals is 16.05 KiB (16436 bytes)
[08:26:25.205] The total size of the 7 globals exported for future expression (‘FUN()’) is 16.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (6.71 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:25.206] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:25.206] - packages: [1] ‘future.apply’
[08:26:25.206] getGlobalsAndPackages() ... DONE
[08:26:25.206]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:25.206]  - needed namespaces: [n=1] ‘future.apply’
[08:26:25.206] Finding globals ... DONE
[08:26:25.206]  - use_args: TRUE
[08:26:25.206]  - Getting '...' globals ...
[08:26:25.207] resolve() on list ...
[08:26:25.207]  recursive: 0
[08:26:25.207]  length: 1
[08:26:25.207]  elements: ‘...’
[08:26:25.207]  length: 0 (resolved future 1)
[08:26:25.207] resolve() on list ... DONE
[08:26:25.207]    - '...' content: [n=0] 
[08:26:25.207] List of 1
[08:26:25.207]  $ ...: list()
[08:26:25.207]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:25.207]  - attr(*, "where")=List of 1
[08:26:25.207]   ..$ ...:<environment: 0x562ca94757e8> 
[08:26:25.207]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:25.207]  - attr(*, "resolved")= logi TRUE
[08:26:25.207]  - attr(*, "total_size")= num NA
[08:26:25.210]  - Getting '...' globals ... DONE
[08:26:25.210] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:25.210] List of 8
[08:26:25.210]  $ ...future.FUN:function (x, ...)  
[08:26:25.210]  $ x_FUN        :function (x)  
[08:26:25.210]  $ times        : int 4
[08:26:25.210]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:25.210]  $ stop_if_not  :function (...)  
[08:26:25.210]  $ dim          : int [1:2] 2 2
[08:26:25.210]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:25.210]  $ ...          : list()
[08:26:25.210]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:25.210]  - attr(*, "where")=List of 8
[08:26:25.210]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:25.210]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:25.210]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:25.210]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:25.210]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:25.210]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:25.210]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:25.210]   ..$ ...          :<environment: 0x562ca94757e8> 
[08:26:25.210]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:25.210]  - attr(*, "resolved")= logi FALSE
[08:26:25.210]  - attr(*, "total_size")= num 29094
[08:26:25.215] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:25.215] getGlobalsAndPackagesXApply() ... DONE
[08:26:25.216] Number of futures (= number of chunks): 2
[08:26:25.216] Launching 2 futures (chunks) ...
[08:26:25.216] Chunk #1 of 2 ...
[08:26:25.216]  - Finding globals in 'X' for chunk #1 ...
[08:26:25.216] getGlobalsAndPackages() ...
[08:26:25.216] Searching for globals...
[08:26:25.216] 
[08:26:25.217] Searching for globals ... DONE
[08:26:25.217] - globals: [0] <none>
[08:26:25.217] getGlobalsAndPackages() ... DONE
[08:26:25.217]    + additional globals found: [n=0] 
[08:26:25.217]    + additional namespaces needed: [n=0] 
[08:26:25.217]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:25.217]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:25.217]  - seeds: <none>
[08:26:25.217]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:25.217] getGlobalsAndPackages() ...
[08:26:25.217] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:25.218] Resolving globals: FALSE
[08:26:25.218] Tweak future expression to call with '...' arguments ...
[08:26:25.218] {
[08:26:25.218]     do.call(function(...) {
[08:26:25.218]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:25.218]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:25.218]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:25.218]             on.exit(options(oopts), add = TRUE)
[08:26:25.218]         }
[08:26:25.218]         {
[08:26:25.218]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:25.218]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:25.218]                 ...future.FUN(...future.X_jj, ...)
[08:26:25.218]             })
[08:26:25.218]         }
[08:26:25.218]     }, args = future.call.arguments)
[08:26:25.218] }
[08:26:25.218] Tweak future expression to call with '...' arguments ... DONE
[08:26:25.219] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:25.219] - packages: [1] ‘future.apply’
[08:26:25.219] getGlobalsAndPackages() ... DONE
[08:26:25.219] run() for ‘Future’ ...
[08:26:25.219] - state: ‘created’
[08:26:25.219] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:25.234] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:25.234] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:25.234]   - Field: ‘node’
[08:26:25.234]   - Field: ‘label’
[08:26:25.234]   - Field: ‘local’
[08:26:25.234]   - Field: ‘owner’
[08:26:25.234]   - Field: ‘envir’
[08:26:25.234]   - Field: ‘workers’
[08:26:25.235]   - Field: ‘packages’
[08:26:25.235]   - Field: ‘gc’
[08:26:25.235]   - Field: ‘conditions’
[08:26:25.235]   - Field: ‘persistent’
[08:26:25.235]   - Field: ‘expr’
[08:26:25.235]   - Field: ‘uuid’
[08:26:25.235]   - Field: ‘seed’
[08:26:25.235]   - Field: ‘version’
[08:26:25.235]   - Field: ‘result’
[08:26:25.235]   - Field: ‘asynchronous’
[08:26:25.235]   - Field: ‘calls’
[08:26:25.236]   - Field: ‘globals’
[08:26:25.236]   - Field: ‘stdout’
[08:26:25.236]   - Field: ‘earlySignal’
[08:26:25.236]   - Field: ‘lazy’
[08:26:25.236]   - Field: ‘state’
[08:26:25.236] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:25.236] - Launch lazy future ...
[08:26:25.236] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:25.236] Packages needed by future strategies (n = 0): <none>
[08:26:25.237] {
[08:26:25.237]     {
[08:26:25.237]         {
[08:26:25.237]             ...future.startTime <- base::Sys.time()
[08:26:25.237]             {
[08:26:25.237]                 {
[08:26:25.237]                   {
[08:26:25.237]                     {
[08:26:25.237]                       {
[08:26:25.237]                         base::local({
[08:26:25.237]                           has_future <- base::requireNamespace("future", 
[08:26:25.237]                             quietly = TRUE)
[08:26:25.237]                           if (has_future) {
[08:26:25.237]                             ns <- base::getNamespace("future")
[08:26:25.237]                             version <- ns[[".package"]][["version"]]
[08:26:25.237]                             if (is.null(version)) 
[08:26:25.237]                               version <- utils::packageVersion("future")
[08:26:25.237]                           }
[08:26:25.237]                           else {
[08:26:25.237]                             version <- NULL
[08:26:25.237]                           }
[08:26:25.237]                           if (!has_future || version < "1.8.0") {
[08:26:25.237]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:25.237]                               "", base::R.version$version.string), 
[08:26:25.237]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:25.237]                                 base::R.version$platform, 8 * 
[08:26:25.237]                                   base::.Machine$sizeof.pointer), 
[08:26:25.237]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:25.237]                                 "release", "version")], collapse = " "), 
[08:26:25.237]                               hostname = base::Sys.info()[["nodename"]])
[08:26:25.237]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:25.237]                               info)
[08:26:25.237]                             info <- base::paste(info, collapse = "; ")
[08:26:25.237]                             if (!has_future) {
[08:26:25.237]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:25.237]                                 info)
[08:26:25.237]                             }
[08:26:25.237]                             else {
[08:26:25.237]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:25.237]                                 info, version)
[08:26:25.237]                             }
[08:26:25.237]                             base::stop(msg)
[08:26:25.237]                           }
[08:26:25.237]                         })
[08:26:25.237]                       }
[08:26:25.237]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:25.237]                       base::options(mc.cores = 1L)
[08:26:25.237]                     }
[08:26:25.237]                     base::local({
[08:26:25.237]                       for (pkg in "future.apply") {
[08:26:25.237]                         base::loadNamespace(pkg)
[08:26:25.237]                         base::library(pkg, character.only = TRUE)
[08:26:25.237]                       }
[08:26:25.237]                     })
[08:26:25.237]                   }
[08:26:25.237]                   ...future.strategy.old <- future::plan("list")
[08:26:25.237]                   options(future.plan = NULL)
[08:26:25.237]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:25.237]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:25.237]                 }
[08:26:25.237]                 ...future.workdir <- getwd()
[08:26:25.237]             }
[08:26:25.237]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:25.237]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:25.237]         }
[08:26:25.237]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:25.237]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:25.237]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:25.237]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:25.237]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:25.237]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:25.237]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:25.237]             base::names(...future.oldOptions))
[08:26:25.237]     }
[08:26:25.237]     if (FALSE) {
[08:26:25.237]     }
[08:26:25.237]     else {
[08:26:25.237]         if (TRUE) {
[08:26:25.237]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:25.237]                 open = "w")
[08:26:25.237]         }
[08:26:25.237]         else {
[08:26:25.237]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:25.237]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:25.237]         }
[08:26:25.237]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:25.237]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:25.237]             base::sink(type = "output", split = FALSE)
[08:26:25.237]             base::close(...future.stdout)
[08:26:25.237]         }, add = TRUE)
[08:26:25.237]     }
[08:26:25.237]     ...future.frame <- base::sys.nframe()
[08:26:25.237]     ...future.conditions <- base::list()
[08:26:25.237]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:25.237]     if (FALSE) {
[08:26:25.237]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:25.237]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:25.237]     }
[08:26:25.237]     ...future.result <- base::tryCatch({
[08:26:25.237]         base::withCallingHandlers({
[08:26:25.237]             ...future.value <- base::withVisible(base::local({
[08:26:25.237]                 ...future.makeSendCondition <- base::local({
[08:26:25.237]                   sendCondition <- NULL
[08:26:25.237]                   function(frame = 1L) {
[08:26:25.237]                     if (is.function(sendCondition)) 
[08:26:25.237]                       return(sendCondition)
[08:26:25.237]                     ns <- getNamespace("parallel")
[08:26:25.237]                     if (exists("sendData", mode = "function", 
[08:26:25.237]                       envir = ns)) {
[08:26:25.237]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:25.237]                         envir = ns)
[08:26:25.237]                       envir <- sys.frame(frame)
[08:26:25.237]                       master <- NULL
[08:26:25.237]                       while (!identical(envir, .GlobalEnv) && 
[08:26:25.237]                         !identical(envir, emptyenv())) {
[08:26:25.237]                         if (exists("master", mode = "list", envir = envir, 
[08:26:25.237]                           inherits = FALSE)) {
[08:26:25.237]                           master <- get("master", mode = "list", 
[08:26:25.237]                             envir = envir, inherits = FALSE)
[08:26:25.237]                           if (inherits(master, c("SOCKnode", 
[08:26:25.237]                             "SOCK0node"))) {
[08:26:25.237]                             sendCondition <<- function(cond) {
[08:26:25.237]                               data <- list(type = "VALUE", value = cond, 
[08:26:25.237]                                 success = TRUE)
[08:26:25.237]                               parallel_sendData(master, data)
[08:26:25.237]                             }
[08:26:25.237]                             return(sendCondition)
[08:26:25.237]                           }
[08:26:25.237]                         }
[08:26:25.237]                         frame <- frame + 1L
[08:26:25.237]                         envir <- sys.frame(frame)
[08:26:25.237]                       }
[08:26:25.237]                     }
[08:26:25.237]                     sendCondition <<- function(cond) NULL
[08:26:25.237]                   }
[08:26:25.237]                 })
[08:26:25.237]                 withCallingHandlers({
[08:26:25.237]                   {
[08:26:25.237]                     do.call(function(...) {
[08:26:25.237]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:25.237]                       if (!identical(...future.globals.maxSize.org, 
[08:26:25.237]                         ...future.globals.maxSize)) {
[08:26:25.237]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:25.237]                         on.exit(options(oopts), add = TRUE)
[08:26:25.237]                       }
[08:26:25.237]                       {
[08:26:25.237]                         lapply(seq_along(...future.elements_ii), 
[08:26:25.237]                           FUN = function(jj) {
[08:26:25.237]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:25.237]                             ...future.FUN(...future.X_jj, ...)
[08:26:25.237]                           })
[08:26:25.237]                       }
[08:26:25.237]                     }, args = future.call.arguments)
[08:26:25.237]                   }
[08:26:25.237]                 }, immediateCondition = function(cond) {
[08:26:25.237]                   sendCondition <- ...future.makeSendCondition()
[08:26:25.237]                   sendCondition(cond)
[08:26:25.237]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:25.237]                   {
[08:26:25.237]                     inherits <- base::inherits
[08:26:25.237]                     invokeRestart <- base::invokeRestart
[08:26:25.237]                     is.null <- base::is.null
[08:26:25.237]                     muffled <- FALSE
[08:26:25.237]                     if (inherits(cond, "message")) {
[08:26:25.237]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:25.237]                       if (muffled) 
[08:26:25.237]                         invokeRestart("muffleMessage")
[08:26:25.237]                     }
[08:26:25.237]                     else if (inherits(cond, "warning")) {
[08:26:25.237]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:25.237]                       if (muffled) 
[08:26:25.237]                         invokeRestart("muffleWarning")
[08:26:25.237]                     }
[08:26:25.237]                     else if (inherits(cond, "condition")) {
[08:26:25.237]                       if (!is.null(pattern)) {
[08:26:25.237]                         computeRestarts <- base::computeRestarts
[08:26:25.237]                         grepl <- base::grepl
[08:26:25.237]                         restarts <- computeRestarts(cond)
[08:26:25.237]                         for (restart in restarts) {
[08:26:25.237]                           name <- restart$name
[08:26:25.237]                           if (is.null(name)) 
[08:26:25.237]                             next
[08:26:25.237]                           if (!grepl(pattern, name)) 
[08:26:25.237]                             next
[08:26:25.237]                           invokeRestart(restart)
[08:26:25.237]                           muffled <- TRUE
[08:26:25.237]                           break
[08:26:25.237]                         }
[08:26:25.237]                       }
[08:26:25.237]                     }
[08:26:25.237]                     invisible(muffled)
[08:26:25.237]                   }
[08:26:25.237]                   muffleCondition(cond)
[08:26:25.237]                 })
[08:26:25.237]             }))
[08:26:25.237]             future::FutureResult(value = ...future.value$value, 
[08:26:25.237]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:25.237]                   ...future.rng), globalenv = if (FALSE) 
[08:26:25.237]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:25.237]                     ...future.globalenv.names))
[08:26:25.237]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:25.237]         }, condition = base::local({
[08:26:25.237]             c <- base::c
[08:26:25.237]             inherits <- base::inherits
[08:26:25.237]             invokeRestart <- base::invokeRestart
[08:26:25.237]             length <- base::length
[08:26:25.237]             list <- base::list
[08:26:25.237]             seq.int <- base::seq.int
[08:26:25.237]             signalCondition <- base::signalCondition
[08:26:25.237]             sys.calls <- base::sys.calls
[08:26:25.237]             `[[` <- base::`[[`
[08:26:25.237]             `+` <- base::`+`
[08:26:25.237]             `<<-` <- base::`<<-`
[08:26:25.237]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:25.237]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:25.237]                   3L)]
[08:26:25.237]             }
[08:26:25.237]             function(cond) {
[08:26:25.237]                 is_error <- inherits(cond, "error")
[08:26:25.237]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:25.237]                   NULL)
[08:26:25.237]                 if (is_error) {
[08:26:25.237]                   sessionInformation <- function() {
[08:26:25.237]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:25.237]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:25.237]                       search = base::search(), system = base::Sys.info())
[08:26:25.237]                   }
[08:26:25.237]                   ...future.conditions[[length(...future.conditions) + 
[08:26:25.237]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:25.237]                     cond$call), session = sessionInformation(), 
[08:26:25.237]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:25.237]                   signalCondition(cond)
[08:26:25.237]                 }
[08:26:25.237]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:25.237]                 "immediateCondition"))) {
[08:26:25.237]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:25.237]                   ...future.conditions[[length(...future.conditions) + 
[08:26:25.237]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:25.237]                   if (TRUE && !signal) {
[08:26:25.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:25.237]                     {
[08:26:25.237]                       inherits <- base::inherits
[08:26:25.237]                       invokeRestart <- base::invokeRestart
[08:26:25.237]                       is.null <- base::is.null
[08:26:25.237]                       muffled <- FALSE
[08:26:25.237]                       if (inherits(cond, "message")) {
[08:26:25.237]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:25.237]                         if (muffled) 
[08:26:25.237]                           invokeRestart("muffleMessage")
[08:26:25.237]                       }
[08:26:25.237]                       else if (inherits(cond, "warning")) {
[08:26:25.237]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:25.237]                         if (muffled) 
[08:26:25.237]                           invokeRestart("muffleWarning")
[08:26:25.237]                       }
[08:26:25.237]                       else if (inherits(cond, "condition")) {
[08:26:25.237]                         if (!is.null(pattern)) {
[08:26:25.237]                           computeRestarts <- base::computeRestarts
[08:26:25.237]                           grepl <- base::grepl
[08:26:25.237]                           restarts <- computeRestarts(cond)
[08:26:25.237]                           for (restart in restarts) {
[08:26:25.237]                             name <- restart$name
[08:26:25.237]                             if (is.null(name)) 
[08:26:25.237]                               next
[08:26:25.237]                             if (!grepl(pattern, name)) 
[08:26:25.237]                               next
[08:26:25.237]                             invokeRestart(restart)
[08:26:25.237]                             muffled <- TRUE
[08:26:25.237]                             break
[08:26:25.237]                           }
[08:26:25.237]                         }
[08:26:25.237]                       }
[08:26:25.237]                       invisible(muffled)
[08:26:25.237]                     }
[08:26:25.237]                     muffleCondition(cond, pattern = "^muffle")
[08:26:25.237]                   }
[08:26:25.237]                 }
[08:26:25.237]                 else {
[08:26:25.237]                   if (TRUE) {
[08:26:25.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:25.237]                     {
[08:26:25.237]                       inherits <- base::inherits
[08:26:25.237]                       invokeRestart <- base::invokeRestart
[08:26:25.237]                       is.null <- base::is.null
[08:26:25.237]                       muffled <- FALSE
[08:26:25.237]                       if (inherits(cond, "message")) {
[08:26:25.237]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:25.237]                         if (muffled) 
[08:26:25.237]                           invokeRestart("muffleMessage")
[08:26:25.237]                       }
[08:26:25.237]                       else if (inherits(cond, "warning")) {
[08:26:25.237]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:25.237]                         if (muffled) 
[08:26:25.237]                           invokeRestart("muffleWarning")
[08:26:25.237]                       }
[08:26:25.237]                       else if (inherits(cond, "condition")) {
[08:26:25.237]                         if (!is.null(pattern)) {
[08:26:25.237]                           computeRestarts <- base::computeRestarts
[08:26:25.237]                           grepl <- base::grepl
[08:26:25.237]                           restarts <- computeRestarts(cond)
[08:26:25.237]                           for (restart in restarts) {
[08:26:25.237]                             name <- restart$name
[08:26:25.237]                             if (is.null(name)) 
[08:26:25.237]                               next
[08:26:25.237]                             if (!grepl(pattern, name)) 
[08:26:25.237]                               next
[08:26:25.237]                             invokeRestart(restart)
[08:26:25.237]                             muffled <- TRUE
[08:26:25.237]                             break
[08:26:25.237]                           }
[08:26:25.237]                         }
[08:26:25.237]                       }
[08:26:25.237]                       invisible(muffled)
[08:26:25.237]                     }
[08:26:25.237]                     muffleCondition(cond, pattern = "^muffle")
[08:26:25.237]                   }
[08:26:25.237]                 }
[08:26:25.237]             }
[08:26:25.237]         }))
[08:26:25.237]     }, error = function(ex) {
[08:26:25.237]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:25.237]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:25.237]                 ...future.rng), started = ...future.startTime, 
[08:26:25.237]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:25.237]             version = "1.8"), class = "FutureResult")
[08:26:25.237]     }, finally = {
[08:26:25.237]         if (!identical(...future.workdir, getwd())) 
[08:26:25.237]             setwd(...future.workdir)
[08:26:25.237]         {
[08:26:25.237]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:25.237]                 ...future.oldOptions$nwarnings <- NULL
[08:26:25.237]             }
[08:26:25.237]             base::options(...future.oldOptions)
[08:26:25.237]             if (.Platform$OS.type == "windows") {
[08:26:25.237]                 old_names <- names(...future.oldEnvVars)
[08:26:25.237]                 envs <- base::Sys.getenv()
[08:26:25.237]                 names <- names(envs)
[08:26:25.237]                 common <- intersect(names, old_names)
[08:26:25.237]                 added <- setdiff(names, old_names)
[08:26:25.237]                 removed <- setdiff(old_names, names)
[08:26:25.237]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:25.237]                   envs[common]]
[08:26:25.237]                 NAMES <- toupper(changed)
[08:26:25.237]                 args <- list()
[08:26:25.237]                 for (kk in seq_along(NAMES)) {
[08:26:25.237]                   name <- changed[[kk]]
[08:26:25.237]                   NAME <- NAMES[[kk]]
[08:26:25.237]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:25.237]                     next
[08:26:25.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:25.237]                 }
[08:26:25.237]                 NAMES <- toupper(added)
[08:26:25.237]                 for (kk in seq_along(NAMES)) {
[08:26:25.237]                   name <- added[[kk]]
[08:26:25.237]                   NAME <- NAMES[[kk]]
[08:26:25.237]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:25.237]                     next
[08:26:25.237]                   args[[name]] <- ""
[08:26:25.237]                 }
[08:26:25.237]                 NAMES <- toupper(removed)
[08:26:25.237]                 for (kk in seq_along(NAMES)) {
[08:26:25.237]                   name <- removed[[kk]]
[08:26:25.237]                   NAME <- NAMES[[kk]]
[08:26:25.237]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:25.237]                     next
[08:26:25.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:25.237]                 }
[08:26:25.237]                 if (length(args) > 0) 
[08:26:25.237]                   base::do.call(base::Sys.setenv, args = args)
[08:26:25.237]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:25.237]             }
[08:26:25.237]             else {
[08:26:25.237]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:25.237]             }
[08:26:25.237]             {
[08:26:25.237]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:25.237]                   0L) {
[08:26:25.237]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:25.237]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:25.237]                   base::options(opts)
[08:26:25.237]                 }
[08:26:25.237]                 {
[08:26:25.237]                   {
[08:26:25.237]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:25.237]                     NULL
[08:26:25.237]                   }
[08:26:25.237]                   options(future.plan = NULL)
[08:26:25.237]                   if (is.na(NA_character_)) 
[08:26:25.237]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:25.237]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:25.237]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:25.237]                     .init = FALSE)
[08:26:25.237]                 }
[08:26:25.237]             }
[08:26:25.237]         }
[08:26:25.237]     })
[08:26:25.237]     if (TRUE) {
[08:26:25.237]         base::sink(type = "output", split = FALSE)
[08:26:25.237]         if (TRUE) {
[08:26:25.237]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:25.237]         }
[08:26:25.237]         else {
[08:26:25.237]             ...future.result["stdout"] <- base::list(NULL)
[08:26:25.237]         }
[08:26:25.237]         base::close(...future.stdout)
[08:26:25.237]         ...future.stdout <- NULL
[08:26:25.237]     }
[08:26:25.237]     ...future.result$conditions <- ...future.conditions
[08:26:25.237]     ...future.result$finished <- base::Sys.time()
[08:26:25.237]     ...future.result
[08:26:25.237] }
[08:26:25.240] Exporting 11 global objects (16.42 KiB) to cluster node #1 ...
[08:26:25.240] Exporting ‘...future.FUN’ (6.70 KiB) to cluster node #1 ...
[08:26:25.282] Exporting ‘...future.FUN’ (6.70 KiB) to cluster node #1 ... DONE
[08:26:25.282] Exporting ‘x_FUN’ (1.36 KiB) to cluster node #1 ...
[08:26:25.282] Exporting ‘x_FUN’ (1.36 KiB) to cluster node #1 ... DONE
[08:26:25.283] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[08:26:25.283] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[08:26:25.283] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[08:26:25.325] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[08:26:25.325] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[08:26:25.367] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[08:26:25.367] Exporting ‘dim’ (39 bytes) to cluster node #1 ...
[08:26:25.367] Exporting ‘dim’ (39 bytes) to cluster node #1 ... DONE
[08:26:25.367] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[08:26:25.368] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[08:26:25.368] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:26:25.368] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:26:25.368] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ...
[08:26:25.369] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ... DONE
[08:26:25.369] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:26:25.369] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:26:25.369] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:26:25.370] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:26:25.370] Exporting 11 global objects (16.42 KiB) to cluster node #1 ... DONE
[08:26:25.370] MultisessionFuture started
[08:26:25.370] - Launch lazy future ... done
[08:26:25.370] run() for ‘MultisessionFuture’ ... done
[08:26:25.371] Created future:
[08:26:25.371] MultisessionFuture:
[08:26:25.371] Label: ‘future_vapply-1’
[08:26:25.371] Expression:
[08:26:25.371] {
[08:26:25.371]     do.call(function(...) {
[08:26:25.371]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:25.371]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:25.371]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:25.371]             on.exit(options(oopts), add = TRUE)
[08:26:25.371]         }
[08:26:25.371]         {
[08:26:25.371]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:25.371]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:25.371]                 ...future.FUN(...future.X_jj, ...)
[08:26:25.371]             })
[08:26:25.371]         }
[08:26:25.371]     }, args = future.call.arguments)
[08:26:25.371] }
[08:26:25.371] Lazy evaluation: FALSE
[08:26:25.371] Asynchronous evaluation: TRUE
[08:26:25.371] Local evaluation: TRUE
[08:26:25.371] Environment: R_GlobalEnv
[08:26:25.371] Capture standard output: TRUE
[08:26:25.371] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:25.371] Globals: 11 objects totaling 16.28 KiB (function ‘...future.FUN’ of 6.70 KiB, function ‘x_FUN’ of 1.36 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:25.371] Packages: 1 packages (‘future.apply’)
[08:26:25.371] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:25.371] Resolved: FALSE
[08:26:25.371] Value: <not collected>
[08:26:25.371] Conditions captured: <none>
[08:26:25.371] Early signaling: FALSE
[08:26:25.371] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:25.371] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:25.382] Chunk #1 of 2 ... DONE
[08:26:25.382] Chunk #2 of 2 ...
[08:26:25.383]  - Finding globals in 'X' for chunk #2 ...
[08:26:25.383] getGlobalsAndPackages() ...
[08:26:25.383] Searching for globals...
[08:26:25.383] 
[08:26:25.383] Searching for globals ... DONE
[08:26:25.383] - globals: [0] <none>
[08:26:25.383] getGlobalsAndPackages() ... DONE
[08:26:25.384]    + additional globals found: [n=0] 
[08:26:25.384]    + additional namespaces needed: [n=0] 
[08:26:25.384]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:25.384]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:25.384]  - seeds: <none>
[08:26:25.384]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:25.384] getGlobalsAndPackages() ...
[08:26:25.384] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:25.384] Resolving globals: FALSE
[08:26:25.384] Tweak future expression to call with '...' arguments ...
[08:26:25.384] {
[08:26:25.384]     do.call(function(...) {
[08:26:25.384]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:25.384]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:25.384]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:25.384]             on.exit(options(oopts), add = TRUE)
[08:26:25.384]         }
[08:26:25.384]         {
[08:26:25.384]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:25.384]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:25.384]                 ...future.FUN(...future.X_jj, ...)
[08:26:25.384]             })
[08:26:25.384]         }
[08:26:25.384]     }, args = future.call.arguments)
[08:26:25.384] }
[08:26:25.385] Tweak future expression to call with '...' arguments ... DONE
[08:26:25.385] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:25.385] - packages: [1] ‘future.apply’
[08:26:25.386] getGlobalsAndPackages() ... DONE
[08:26:25.386] run() for ‘Future’ ...
[08:26:25.386] - state: ‘created’
[08:26:25.386] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:25.400] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:25.400] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:25.401]   - Field: ‘node’
[08:26:25.401]   - Field: ‘label’
[08:26:25.401]   - Field: ‘local’
[08:26:25.401]   - Field: ‘owner’
[08:26:25.401]   - Field: ‘envir’
[08:26:25.401]   - Field: ‘workers’
[08:26:25.401]   - Field: ‘packages’
[08:26:25.401]   - Field: ‘gc’
[08:26:25.401]   - Field: ‘conditions’
[08:26:25.401]   - Field: ‘persistent’
[08:26:25.402]   - Field: ‘expr’
[08:26:25.402]   - Field: ‘uuid’
[08:26:25.402]   - Field: ‘seed’
[08:26:25.402]   - Field: ‘version’
[08:26:25.402]   - Field: ‘result’
[08:26:25.402]   - Field: ‘asynchronous’
[08:26:25.402]   - Field: ‘calls’
[08:26:25.402]   - Field: ‘globals’
[08:26:25.402]   - Field: ‘stdout’
[08:26:25.402]   - Field: ‘earlySignal’
[08:26:25.402]   - Field: ‘lazy’
[08:26:25.402]   - Field: ‘state’
[08:26:25.403] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:25.403] - Launch lazy future ...
[08:26:25.403] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:25.403] Packages needed by future strategies (n = 0): <none>
[08:26:25.404] {
[08:26:25.404]     {
[08:26:25.404]         {
[08:26:25.404]             ...future.startTime <- base::Sys.time()
[08:26:25.404]             {
[08:26:25.404]                 {
[08:26:25.404]                   {
[08:26:25.404]                     {
[08:26:25.404]                       {
[08:26:25.404]                         base::local({
[08:26:25.404]                           has_future <- base::requireNamespace("future", 
[08:26:25.404]                             quietly = TRUE)
[08:26:25.404]                           if (has_future) {
[08:26:25.404]                             ns <- base::getNamespace("future")
[08:26:25.404]                             version <- ns[[".package"]][["version"]]
[08:26:25.404]                             if (is.null(version)) 
[08:26:25.404]                               version <- utils::packageVersion("future")
[08:26:25.404]                           }
[08:26:25.404]                           else {
[08:26:25.404]                             version <- NULL
[08:26:25.404]                           }
[08:26:25.404]                           if (!has_future || version < "1.8.0") {
[08:26:25.404]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:25.404]                               "", base::R.version$version.string), 
[08:26:25.404]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:25.404]                                 base::R.version$platform, 8 * 
[08:26:25.404]                                   base::.Machine$sizeof.pointer), 
[08:26:25.404]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:25.404]                                 "release", "version")], collapse = " "), 
[08:26:25.404]                               hostname = base::Sys.info()[["nodename"]])
[08:26:25.404]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:25.404]                               info)
[08:26:25.404]                             info <- base::paste(info, collapse = "; ")
[08:26:25.404]                             if (!has_future) {
[08:26:25.404]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:25.404]                                 info)
[08:26:25.404]                             }
[08:26:25.404]                             else {
[08:26:25.404]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:25.404]                                 info, version)
[08:26:25.404]                             }
[08:26:25.404]                             base::stop(msg)
[08:26:25.404]                           }
[08:26:25.404]                         })
[08:26:25.404]                       }
[08:26:25.404]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:25.404]                       base::options(mc.cores = 1L)
[08:26:25.404]                     }
[08:26:25.404]                     base::local({
[08:26:25.404]                       for (pkg in "future.apply") {
[08:26:25.404]                         base::loadNamespace(pkg)
[08:26:25.404]                         base::library(pkg, character.only = TRUE)
[08:26:25.404]                       }
[08:26:25.404]                     })
[08:26:25.404]                   }
[08:26:25.404]                   ...future.strategy.old <- future::plan("list")
[08:26:25.404]                   options(future.plan = NULL)
[08:26:25.404]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:25.404]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:25.404]                 }
[08:26:25.404]                 ...future.workdir <- getwd()
[08:26:25.404]             }
[08:26:25.404]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:25.404]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:25.404]         }
[08:26:25.404]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:25.404]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:25.404]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:25.404]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:25.404]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:25.404]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:25.404]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:25.404]             base::names(...future.oldOptions))
[08:26:25.404]     }
[08:26:25.404]     if (FALSE) {
[08:26:25.404]     }
[08:26:25.404]     else {
[08:26:25.404]         if (TRUE) {
[08:26:25.404]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:25.404]                 open = "w")
[08:26:25.404]         }
[08:26:25.404]         else {
[08:26:25.404]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:25.404]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:25.404]         }
[08:26:25.404]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:25.404]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:25.404]             base::sink(type = "output", split = FALSE)
[08:26:25.404]             base::close(...future.stdout)
[08:26:25.404]         }, add = TRUE)
[08:26:25.404]     }
[08:26:25.404]     ...future.frame <- base::sys.nframe()
[08:26:25.404]     ...future.conditions <- base::list()
[08:26:25.404]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:25.404]     if (FALSE) {
[08:26:25.404]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:25.404]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:25.404]     }
[08:26:25.404]     ...future.result <- base::tryCatch({
[08:26:25.404]         base::withCallingHandlers({
[08:26:25.404]             ...future.value <- base::withVisible(base::local({
[08:26:25.404]                 ...future.makeSendCondition <- base::local({
[08:26:25.404]                   sendCondition <- NULL
[08:26:25.404]                   function(frame = 1L) {
[08:26:25.404]                     if (is.function(sendCondition)) 
[08:26:25.404]                       return(sendCondition)
[08:26:25.404]                     ns <- getNamespace("parallel")
[08:26:25.404]                     if (exists("sendData", mode = "function", 
[08:26:25.404]                       envir = ns)) {
[08:26:25.404]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:25.404]                         envir = ns)
[08:26:25.404]                       envir <- sys.frame(frame)
[08:26:25.404]                       master <- NULL
[08:26:25.404]                       while (!identical(envir, .GlobalEnv) && 
[08:26:25.404]                         !identical(envir, emptyenv())) {
[08:26:25.404]                         if (exists("master", mode = "list", envir = envir, 
[08:26:25.404]                           inherits = FALSE)) {
[08:26:25.404]                           master <- get("master", mode = "list", 
[08:26:25.404]                             envir = envir, inherits = FALSE)
[08:26:25.404]                           if (inherits(master, c("SOCKnode", 
[08:26:25.404]                             "SOCK0node"))) {
[08:26:25.404]                             sendCondition <<- function(cond) {
[08:26:25.404]                               data <- list(type = "VALUE", value = cond, 
[08:26:25.404]                                 success = TRUE)
[08:26:25.404]                               parallel_sendData(master, data)
[08:26:25.404]                             }
[08:26:25.404]                             return(sendCondition)
[08:26:25.404]                           }
[08:26:25.404]                         }
[08:26:25.404]                         frame <- frame + 1L
[08:26:25.404]                         envir <- sys.frame(frame)
[08:26:25.404]                       }
[08:26:25.404]                     }
[08:26:25.404]                     sendCondition <<- function(cond) NULL
[08:26:25.404]                   }
[08:26:25.404]                 })
[08:26:25.404]                 withCallingHandlers({
[08:26:25.404]                   {
[08:26:25.404]                     do.call(function(...) {
[08:26:25.404]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:25.404]                       if (!identical(...future.globals.maxSize.org, 
[08:26:25.404]                         ...future.globals.maxSize)) {
[08:26:25.404]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:25.404]                         on.exit(options(oopts), add = TRUE)
[08:26:25.404]                       }
[08:26:25.404]                       {
[08:26:25.404]                         lapply(seq_along(...future.elements_ii), 
[08:26:25.404]                           FUN = function(jj) {
[08:26:25.404]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:25.404]                             ...future.FUN(...future.X_jj, ...)
[08:26:25.404]                           })
[08:26:25.404]                       }
[08:26:25.404]                     }, args = future.call.arguments)
[08:26:25.404]                   }
[08:26:25.404]                 }, immediateCondition = function(cond) {
[08:26:25.404]                   sendCondition <- ...future.makeSendCondition()
[08:26:25.404]                   sendCondition(cond)
[08:26:25.404]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:25.404]                   {
[08:26:25.404]                     inherits <- base::inherits
[08:26:25.404]                     invokeRestart <- base::invokeRestart
[08:26:25.404]                     is.null <- base::is.null
[08:26:25.404]                     muffled <- FALSE
[08:26:25.404]                     if (inherits(cond, "message")) {
[08:26:25.404]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:25.404]                       if (muffled) 
[08:26:25.404]                         invokeRestart("muffleMessage")
[08:26:25.404]                     }
[08:26:25.404]                     else if (inherits(cond, "warning")) {
[08:26:25.404]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:25.404]                       if (muffled) 
[08:26:25.404]                         invokeRestart("muffleWarning")
[08:26:25.404]                     }
[08:26:25.404]                     else if (inherits(cond, "condition")) {
[08:26:25.404]                       if (!is.null(pattern)) {
[08:26:25.404]                         computeRestarts <- base::computeRestarts
[08:26:25.404]                         grepl <- base::grepl
[08:26:25.404]                         restarts <- computeRestarts(cond)
[08:26:25.404]                         for (restart in restarts) {
[08:26:25.404]                           name <- restart$name
[08:26:25.404]                           if (is.null(name)) 
[08:26:25.404]                             next
[08:26:25.404]                           if (!grepl(pattern, name)) 
[08:26:25.404]                             next
[08:26:25.404]                           invokeRestart(restart)
[08:26:25.404]                           muffled <- TRUE
[08:26:25.404]                           break
[08:26:25.404]                         }
[08:26:25.404]                       }
[08:26:25.404]                     }
[08:26:25.404]                     invisible(muffled)
[08:26:25.404]                   }
[08:26:25.404]                   muffleCondition(cond)
[08:26:25.404]                 })
[08:26:25.404]             }))
[08:26:25.404]             future::FutureResult(value = ...future.value$value, 
[08:26:25.404]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:25.404]                   ...future.rng), globalenv = if (FALSE) 
[08:26:25.404]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:25.404]                     ...future.globalenv.names))
[08:26:25.404]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:25.404]         }, condition = base::local({
[08:26:25.404]             c <- base::c
[08:26:25.404]             inherits <- base::inherits
[08:26:25.404]             invokeRestart <- base::invokeRestart
[08:26:25.404]             length <- base::length
[08:26:25.404]             list <- base::list
[08:26:25.404]             seq.int <- base::seq.int
[08:26:25.404]             signalCondition <- base::signalCondition
[08:26:25.404]             sys.calls <- base::sys.calls
[08:26:25.404]             `[[` <- base::`[[`
[08:26:25.404]             `+` <- base::`+`
[08:26:25.404]             `<<-` <- base::`<<-`
[08:26:25.404]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:25.404]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:25.404]                   3L)]
[08:26:25.404]             }
[08:26:25.404]             function(cond) {
[08:26:25.404]                 is_error <- inherits(cond, "error")
[08:26:25.404]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:25.404]                   NULL)
[08:26:25.404]                 if (is_error) {
[08:26:25.404]                   sessionInformation <- function() {
[08:26:25.404]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:25.404]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:25.404]                       search = base::search(), system = base::Sys.info())
[08:26:25.404]                   }
[08:26:25.404]                   ...future.conditions[[length(...future.conditions) + 
[08:26:25.404]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:25.404]                     cond$call), session = sessionInformation(), 
[08:26:25.404]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:25.404]                   signalCondition(cond)
[08:26:25.404]                 }
[08:26:25.404]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:25.404]                 "immediateCondition"))) {
[08:26:25.404]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:25.404]                   ...future.conditions[[length(...future.conditions) + 
[08:26:25.404]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:25.404]                   if (TRUE && !signal) {
[08:26:25.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:25.404]                     {
[08:26:25.404]                       inherits <- base::inherits
[08:26:25.404]                       invokeRestart <- base::invokeRestart
[08:26:25.404]                       is.null <- base::is.null
[08:26:25.404]                       muffled <- FALSE
[08:26:25.404]                       if (inherits(cond, "message")) {
[08:26:25.404]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:25.404]                         if (muffled) 
[08:26:25.404]                           invokeRestart("muffleMessage")
[08:26:25.404]                       }
[08:26:25.404]                       else if (inherits(cond, "warning")) {
[08:26:25.404]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:25.404]                         if (muffled) 
[08:26:25.404]                           invokeRestart("muffleWarning")
[08:26:25.404]                       }
[08:26:25.404]                       else if (inherits(cond, "condition")) {
[08:26:25.404]                         if (!is.null(pattern)) {
[08:26:25.404]                           computeRestarts <- base::computeRestarts
[08:26:25.404]                           grepl <- base::grepl
[08:26:25.404]                           restarts <- computeRestarts(cond)
[08:26:25.404]                           for (restart in restarts) {
[08:26:25.404]                             name <- restart$name
[08:26:25.404]                             if (is.null(name)) 
[08:26:25.404]                               next
[08:26:25.404]                             if (!grepl(pattern, name)) 
[08:26:25.404]                               next
[08:26:25.404]                             invokeRestart(restart)
[08:26:25.404]                             muffled <- TRUE
[08:26:25.404]                             break
[08:26:25.404]                           }
[08:26:25.404]                         }
[08:26:25.404]                       }
[08:26:25.404]                       invisible(muffled)
[08:26:25.404]                     }
[08:26:25.404]                     muffleCondition(cond, pattern = "^muffle")
[08:26:25.404]                   }
[08:26:25.404]                 }
[08:26:25.404]                 else {
[08:26:25.404]                   if (TRUE) {
[08:26:25.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:25.404]                     {
[08:26:25.404]                       inherits <- base::inherits
[08:26:25.404]                       invokeRestart <- base::invokeRestart
[08:26:25.404]                       is.null <- base::is.null
[08:26:25.404]                       muffled <- FALSE
[08:26:25.404]                       if (inherits(cond, "message")) {
[08:26:25.404]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:25.404]                         if (muffled) 
[08:26:25.404]                           invokeRestart("muffleMessage")
[08:26:25.404]                       }
[08:26:25.404]                       else if (inherits(cond, "warning")) {
[08:26:25.404]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:25.404]                         if (muffled) 
[08:26:25.404]                           invokeRestart("muffleWarning")
[08:26:25.404]                       }
[08:26:25.404]                       else if (inherits(cond, "condition")) {
[08:26:25.404]                         if (!is.null(pattern)) {
[08:26:25.404]                           computeRestarts <- base::computeRestarts
[08:26:25.404]                           grepl <- base::grepl
[08:26:25.404]                           restarts <- computeRestarts(cond)
[08:26:25.404]                           for (restart in restarts) {
[08:26:25.404]                             name <- restart$name
[08:26:25.404]                             if (is.null(name)) 
[08:26:25.404]                               next
[08:26:25.404]                             if (!grepl(pattern, name)) 
[08:26:25.404]                               next
[08:26:25.404]                             invokeRestart(restart)
[08:26:25.404]                             muffled <- TRUE
[08:26:25.404]                             break
[08:26:25.404]                           }
[08:26:25.404]                         }
[08:26:25.404]                       }
[08:26:25.404]                       invisible(muffled)
[08:26:25.404]                     }
[08:26:25.404]                     muffleCondition(cond, pattern = "^muffle")
[08:26:25.404]                   }
[08:26:25.404]                 }
[08:26:25.404]             }
[08:26:25.404]         }))
[08:26:25.404]     }, error = function(ex) {
[08:26:25.404]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:25.404]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:25.404]                 ...future.rng), started = ...future.startTime, 
[08:26:25.404]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:25.404]             version = "1.8"), class = "FutureResult")
[08:26:25.404]     }, finally = {
[08:26:25.404]         if (!identical(...future.workdir, getwd())) 
[08:26:25.404]             setwd(...future.workdir)
[08:26:25.404]         {
[08:26:25.404]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:25.404]                 ...future.oldOptions$nwarnings <- NULL
[08:26:25.404]             }
[08:26:25.404]             base::options(...future.oldOptions)
[08:26:25.404]             if (.Platform$OS.type == "windows") {
[08:26:25.404]                 old_names <- names(...future.oldEnvVars)
[08:26:25.404]                 envs <- base::Sys.getenv()
[08:26:25.404]                 names <- names(envs)
[08:26:25.404]                 common <- intersect(names, old_names)
[08:26:25.404]                 added <- setdiff(names, old_names)
[08:26:25.404]                 removed <- setdiff(old_names, names)
[08:26:25.404]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:25.404]                   envs[common]]
[08:26:25.404]                 NAMES <- toupper(changed)
[08:26:25.404]                 args <- list()
[08:26:25.404]                 for (kk in seq_along(NAMES)) {
[08:26:25.404]                   name <- changed[[kk]]
[08:26:25.404]                   NAME <- NAMES[[kk]]
[08:26:25.404]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:25.404]                     next
[08:26:25.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:25.404]                 }
[08:26:25.404]                 NAMES <- toupper(added)
[08:26:25.404]                 for (kk in seq_along(NAMES)) {
[08:26:25.404]                   name <- added[[kk]]
[08:26:25.404]                   NAME <- NAMES[[kk]]
[08:26:25.404]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:25.404]                     next
[08:26:25.404]                   args[[name]] <- ""
[08:26:25.404]                 }
[08:26:25.404]                 NAMES <- toupper(removed)
[08:26:25.404]                 for (kk in seq_along(NAMES)) {
[08:26:25.404]                   name <- removed[[kk]]
[08:26:25.404]                   NAME <- NAMES[[kk]]
[08:26:25.404]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:25.404]                     next
[08:26:25.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:25.404]                 }
[08:26:25.404]                 if (length(args) > 0) 
[08:26:25.404]                   base::do.call(base::Sys.setenv, args = args)
[08:26:25.404]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:25.404]             }
[08:26:25.404]             else {
[08:26:25.404]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:25.404]             }
[08:26:25.404]             {
[08:26:25.404]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:25.404]                   0L) {
[08:26:25.404]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:25.404]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:25.404]                   base::options(opts)
[08:26:25.404]                 }
[08:26:25.404]                 {
[08:26:25.404]                   {
[08:26:25.404]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:25.404]                     NULL
[08:26:25.404]                   }
[08:26:25.404]                   options(future.plan = NULL)
[08:26:25.404]                   if (is.na(NA_character_)) 
[08:26:25.404]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:25.404]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:25.404]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:25.404]                     .init = FALSE)
[08:26:25.404]                 }
[08:26:25.404]             }
[08:26:25.404]         }
[08:26:25.404]     })
[08:26:25.404]     if (TRUE) {
[08:26:25.404]         base::sink(type = "output", split = FALSE)
[08:26:25.404]         if (TRUE) {
[08:26:25.404]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:25.404]         }
[08:26:25.404]         else {
[08:26:25.404]             ...future.result["stdout"] <- base::list(NULL)
[08:26:25.404]         }
[08:26:25.404]         base::close(...future.stdout)
[08:26:25.404]         ...future.stdout <- NULL
[08:26:25.404]     }
[08:26:25.404]     ...future.result$conditions <- ...future.conditions
[08:26:25.404]     ...future.result$finished <- base::Sys.time()
[08:26:25.404]     ...future.result
[08:26:25.404] }
[08:26:25.407] Exporting 11 global objects (16.42 KiB) to cluster node #2 ...
[08:26:25.407] Exporting ‘...future.FUN’ (6.70 KiB) to cluster node #2 ...
[08:26:25.449] Exporting ‘...future.FUN’ (6.70 KiB) to cluster node #2 ... DONE
[08:26:25.449] Exporting ‘x_FUN’ (1.36 KiB) to cluster node #2 ...
[08:26:25.449] Exporting ‘x_FUN’ (1.36 KiB) to cluster node #2 ... DONE
[08:26:25.450] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[08:26:25.450] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[08:26:25.450] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[08:26:25.491] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[08:26:25.492] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[08:26:25.533] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[08:26:25.533] Exporting ‘dim’ (39 bytes) to cluster node #2 ...
[08:26:25.533] Exporting ‘dim’ (39 bytes) to cluster node #2 ... DONE
[08:26:25.533] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[08:26:25.534] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[08:26:25.534] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:26:25.534] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:26:25.534] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ...
[08:26:25.535] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ... DONE
[08:26:25.535] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:26:25.535] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:26:25.535] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:26:25.536] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:26:25.536] Exporting 11 global objects (16.42 KiB) to cluster node #2 ... DONE
[08:26:25.539] MultisessionFuture started
[08:26:25.539] - Launch lazy future ... done
[08:26:25.539] run() for ‘MultisessionFuture’ ... done
[08:26:25.539] Created future:
[08:26:25.539] MultisessionFuture:
[08:26:25.539] Label: ‘future_vapply-2’
[08:26:25.539] Expression:
[08:26:25.539] {
[08:26:25.539]     do.call(function(...) {
[08:26:25.539]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:25.539]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:25.539]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:25.539]             on.exit(options(oopts), add = TRUE)
[08:26:25.539]         }
[08:26:25.539]         {
[08:26:25.539]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:25.539]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:25.539]                 ...future.FUN(...future.X_jj, ...)
[08:26:25.539]             })
[08:26:25.539]         }
[08:26:25.539]     }, args = future.call.arguments)
[08:26:25.539] }
[08:26:25.539] Lazy evaluation: FALSE
[08:26:25.539] Asynchronous evaluation: TRUE
[08:26:25.539] Local evaluation: TRUE
[08:26:25.539] Environment: R_GlobalEnv
[08:26:25.539] Capture standard output: TRUE
[08:26:25.539] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:25.539] Globals: 11 objects totaling 16.28 KiB (function ‘...future.FUN’ of 6.70 KiB, function ‘x_FUN’ of 1.36 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:25.539] Packages: 1 packages (‘future.apply’)
[08:26:25.539] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:25.539] Resolved: FALSE
[08:26:25.539] Value: <not collected>
[08:26:25.539] Conditions captured: <none>
[08:26:25.539] Early signaling: FALSE
[08:26:25.539] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:25.539] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:25.551] Chunk #2 of 2 ... DONE
[08:26:25.551] Launching 2 futures (chunks) ... DONE
[08:26:25.551] Resolving 2 futures (chunks) ...
[08:26:25.551] resolve() on list ...
[08:26:25.551]  recursive: 0
[08:26:25.551]  length: 2
[08:26:25.551] 
[08:26:25.552] receiveMessageFromWorker() for ClusterFuture ...
[08:26:25.552] - Validating connection of MultisessionFuture
[08:26:25.552] - received message: FutureResult
[08:26:25.552] - Received FutureResult
[08:26:25.553] - Erased future from FutureRegistry
[08:26:25.553] result() for ClusterFuture ...
[08:26:25.553] - result already collected: FutureResult
[08:26:25.553] result() for ClusterFuture ... done
[08:26:25.553] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:25.553] Future #1
[08:26:25.553] result() for ClusterFuture ...
[08:26:25.553] - result already collected: FutureResult
[08:26:25.553] result() for ClusterFuture ... done
[08:26:25.553] result() for ClusterFuture ...
[08:26:25.553] - result already collected: FutureResult
[08:26:25.553] result() for ClusterFuture ... done
[08:26:25.554] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:26:25.554] - nx: 2
[08:26:25.554] - relay: TRUE
[08:26:25.554] - stdout: TRUE
[08:26:25.554] - signal: TRUE
[08:26:25.554] - resignal: FALSE
[08:26:25.554] - force: TRUE
[08:26:25.554] - relayed: [n=2] FALSE, FALSE
[08:26:25.554] - queued futures: [n=2] FALSE, FALSE
[08:26:25.554]  - until=1
[08:26:25.554]  - relaying element #1
[08:26:25.554] result() for ClusterFuture ...
[08:26:25.555] - result already collected: FutureResult
[08:26:25.555] result() for ClusterFuture ... done
[08:26:25.555] result() for ClusterFuture ...
[08:26:25.555] - result already collected: FutureResult
[08:26:25.555] result() for ClusterFuture ... done
[08:26:25.555] result() for ClusterFuture ...
[08:26:25.555] - result already collected: FutureResult
[08:26:25.555] result() for ClusterFuture ... done
[08:26:25.555] result() for ClusterFuture ...
[08:26:25.555] - result already collected: FutureResult
[08:26:25.555] result() for ClusterFuture ... done
[08:26:25.555] - relayed: [n=2] TRUE, FALSE
[08:26:25.556] - queued futures: [n=2] TRUE, FALSE
[08:26:25.556] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:26:25.556]  length: 1 (resolved future 1)
[08:26:25.581] receiveMessageFromWorker() for ClusterFuture ...
[08:26:25.582] - Validating connection of MultisessionFuture
[08:26:25.582] - received message: FutureResult
[08:26:25.582] - Received FutureResult
[08:26:25.582] - Erased future from FutureRegistry
[08:26:25.582] result() for ClusterFuture ...
[08:26:25.582] - result already collected: FutureResult
[08:26:25.582] result() for ClusterFuture ... done
[08:26:25.582] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:25.583] Future #2
[08:26:25.583] result() for ClusterFuture ...
[08:26:25.583] - result already collected: FutureResult
[08:26:25.583] result() for ClusterFuture ... done
[08:26:25.583] result() for ClusterFuture ...
[08:26:25.583] - result already collected: FutureResult
[08:26:25.583] result() for ClusterFuture ... done
[08:26:25.583] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:26:25.583] - nx: 2
[08:26:25.583] - relay: TRUE
[08:26:25.583] - stdout: TRUE
[08:26:25.583] - signal: TRUE
[08:26:25.584] - resignal: FALSE
[08:26:25.584] - force: TRUE
[08:26:25.584] - relayed: [n=2] TRUE, FALSE
[08:26:25.584] - queued futures: [n=2] TRUE, FALSE
[08:26:25.584]  - until=2
[08:26:25.584]  - relaying element #2
[08:26:25.584] result() for ClusterFuture ...
[08:26:25.584] - result already collected: FutureResult
[08:26:25.584] result() for ClusterFuture ... done
[08:26:25.584] result() for ClusterFuture ...
[08:26:25.584] - result already collected: FutureResult
[08:26:25.584] result() for ClusterFuture ... done
[08:26:25.585] result() for ClusterFuture ...
[08:26:25.585] - result already collected: FutureResult
[08:26:25.585] result() for ClusterFuture ... done
[08:26:25.585] result() for ClusterFuture ...
[08:26:25.585] - result already collected: FutureResult
[08:26:25.585] result() for ClusterFuture ... done
[08:26:25.585] - relayed: [n=2] TRUE, TRUE
[08:26:25.585] - queued futures: [n=2] TRUE, TRUE
[08:26:25.585] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:26:25.585]  length: 0 (resolved future 2)
[08:26:25.585] Relaying remaining futures
[08:26:25.585] signalConditionsASAP(NULL, pos=0) ...
[08:26:25.586] - nx: 2
[08:26:25.586] - relay: TRUE
[08:26:25.586] - stdout: TRUE
[08:26:25.586] - signal: TRUE
[08:26:25.586] - resignal: FALSE
[08:26:25.586] - force: TRUE
[08:26:25.586] - relayed: [n=2] TRUE, TRUE
[08:26:25.586] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:25.586] - relayed: [n=2] TRUE, TRUE
[08:26:25.586] - queued futures: [n=2] TRUE, TRUE
[08:26:25.586] signalConditionsASAP(NULL, pos=0) ... done
[08:26:25.587] resolve() on list ... DONE
[08:26:25.587] result() for ClusterFuture ...
[08:26:25.587] - result already collected: FutureResult
[08:26:25.587] result() for ClusterFuture ... done
[08:26:25.587] result() for ClusterFuture ...
[08:26:25.587] - result already collected: FutureResult
[08:26:25.587] result() for ClusterFuture ... done
[08:26:25.587] result() for ClusterFuture ...
[08:26:25.587] - result already collected: FutureResult
[08:26:25.587] result() for ClusterFuture ... done
[08:26:25.587] result() for ClusterFuture ...
[08:26:25.587] - result already collected: FutureResult
[08:26:25.588] result() for ClusterFuture ... done
[08:26:25.588]  - Number of value chunks collected: 2
[08:26:25.588] Resolving 2 futures (chunks) ... DONE
[08:26:25.588] Reducing values from 2 chunks ...
[08:26:25.588]  - Number of values collected after concatenation: 10
[08:26:25.588]  - Number of values expected: 10
[08:26:25.588] Reducing values from 2 chunks ... DONE
[08:26:25.588] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[08:26:25.591] future_lapply() ...
[08:26:25.594] Number of chunks: 2
[08:26:25.594] getGlobalsAndPackagesXApply() ...
[08:26:25.594]  - future.globals: TRUE
[08:26:25.594] getGlobalsAndPackages() ...
[08:26:25.594] Searching for globals...
[08:26:25.598] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[08:26:25.598] Searching for globals ... DONE
[08:26:25.598] Resolving globals: FALSE
[08:26:25.599] The total size of the 7 globals is 13.03 KiB (13339 bytes)
[08:26:25.599] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.03 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.75 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:25.599] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:25.599] - packages: [2] ‘stats’, ‘future.apply’
[08:26:25.600] getGlobalsAndPackages() ... DONE
[08:26:25.600]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:25.600]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[08:26:25.600] Finding globals ... DONE
[08:26:25.600]  - use_args: TRUE
[08:26:25.600]  - Getting '...' globals ...
[08:26:25.600] resolve() on list ...
[08:26:25.600]  recursive: 0
[08:26:25.600]  length: 1
[08:26:25.601]  elements: ‘...’
[08:26:25.601]  length: 0 (resolved future 1)
[08:26:25.601] resolve() on list ... DONE
[08:26:25.601]    - '...' content: [n=0] 
[08:26:25.601] List of 1
[08:26:25.601]  $ ...: list()
[08:26:25.601]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:25.601]  - attr(*, "where")=List of 1
[08:26:25.601]   ..$ ...:<environment: 0x562ca6f3c680> 
[08:26:25.601]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:25.601]  - attr(*, "resolved")= logi TRUE
[08:26:25.601]  - attr(*, "total_size")= num NA
[08:26:25.603]  - Getting '...' globals ... DONE
[08:26:25.603] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:25.604] List of 8
[08:26:25.604]  $ ...future.FUN:function (x, ...)  
[08:26:25.604]  $ x_FUN        :function (x, ...)  
[08:26:25.604]  $ times        : int 5
[08:26:25.604]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:25.604]  $ stop_if_not  :function (...)  
[08:26:25.604]  $ dim          : NULL
[08:26:25.604]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:25.604]  $ ...          : list()
[08:26:25.604]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:25.604]  - attr(*, "where")=List of 8
[08:26:25.604]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:25.604]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:25.604]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:25.604]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:25.604]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:25.604]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:25.604]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:25.604]   ..$ ...          :<environment: 0x562ca6f3c680> 
[08:26:25.604]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:25.604]  - attr(*, "resolved")= logi FALSE
[08:26:25.604]  - attr(*, "total_size")= num 24127
[08:26:25.609] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[08:26:25.609] getGlobalsAndPackagesXApply() ... DONE
[08:26:25.609] Number of futures (= number of chunks): 2
[08:26:25.609] Launching 2 futures (chunks) ...
[08:26:25.609] Chunk #1 of 2 ...
[08:26:25.609]  - Finding globals in 'X' for chunk #1 ...
[08:26:25.609] getGlobalsAndPackages() ...
[08:26:25.610] Searching for globals...
[08:26:25.610] 
[08:26:25.610] Searching for globals ... DONE
[08:26:25.610] - globals: [0] <none>
[08:26:25.610] getGlobalsAndPackages() ... DONE
[08:26:25.610]    + additional globals found: [n=0] 
[08:26:25.610]    + additional namespaces needed: [n=0] 
[08:26:25.610]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:25.610]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:25.610]  - seeds: <none>
[08:26:25.611]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:25.611] getGlobalsAndPackages() ...
[08:26:25.611] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:25.611] Resolving globals: FALSE
[08:26:25.611] Tweak future expression to call with '...' arguments ...
[08:26:25.611] {
[08:26:25.611]     do.call(function(...) {
[08:26:25.611]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:25.611]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:25.611]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:25.611]             on.exit(options(oopts), add = TRUE)
[08:26:25.611]         }
[08:26:25.611]         {
[08:26:25.611]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:25.611]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:25.611]                 ...future.FUN(...future.X_jj, ...)
[08:26:25.611]             })
[08:26:25.611]         }
[08:26:25.611]     }, args = future.call.arguments)
[08:26:25.611] }
[08:26:25.611] Tweak future expression to call with '...' arguments ... DONE
[08:26:25.612] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:25.612] - packages: [2] ‘stats’, ‘future.apply’
[08:26:25.612] getGlobalsAndPackages() ... DONE
[08:26:25.612] run() for ‘Future’ ...
[08:26:25.612] - state: ‘created’
[08:26:25.613] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:25.627] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:25.627] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:25.627]   - Field: ‘node’
[08:26:25.627]   - Field: ‘label’
[08:26:25.627]   - Field: ‘local’
[08:26:25.627]   - Field: ‘owner’
[08:26:25.628]   - Field: ‘envir’
[08:26:25.628]   - Field: ‘workers’
[08:26:25.628]   - Field: ‘packages’
[08:26:25.628]   - Field: ‘gc’
[08:26:25.628]   - Field: ‘conditions’
[08:26:25.628]   - Field: ‘persistent’
[08:26:25.628]   - Field: ‘expr’
[08:26:25.628]   - Field: ‘uuid’
[08:26:25.628]   - Field: ‘seed’
[08:26:25.628]   - Field: ‘version’
[08:26:25.628]   - Field: ‘result’
[08:26:25.629]   - Field: ‘asynchronous’
[08:26:25.629]   - Field: ‘calls’
[08:26:25.629]   - Field: ‘globals’
[08:26:25.629]   - Field: ‘stdout’
[08:26:25.629]   - Field: ‘earlySignal’
[08:26:25.629]   - Field: ‘lazy’
[08:26:25.629]   - Field: ‘state’
[08:26:25.629] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:25.629] - Launch lazy future ...
[08:26:25.630] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[08:26:25.630] Packages needed by future strategies (n = 0): <none>
[08:26:25.630] {
[08:26:25.630]     {
[08:26:25.630]         {
[08:26:25.630]             ...future.startTime <- base::Sys.time()
[08:26:25.630]             {
[08:26:25.630]                 {
[08:26:25.630]                   {
[08:26:25.630]                     {
[08:26:25.630]                       {
[08:26:25.630]                         base::local({
[08:26:25.630]                           has_future <- base::requireNamespace("future", 
[08:26:25.630]                             quietly = TRUE)
[08:26:25.630]                           if (has_future) {
[08:26:25.630]                             ns <- base::getNamespace("future")
[08:26:25.630]                             version <- ns[[".package"]][["version"]]
[08:26:25.630]                             if (is.null(version)) 
[08:26:25.630]                               version <- utils::packageVersion("future")
[08:26:25.630]                           }
[08:26:25.630]                           else {
[08:26:25.630]                             version <- NULL
[08:26:25.630]                           }
[08:26:25.630]                           if (!has_future || version < "1.8.0") {
[08:26:25.630]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:25.630]                               "", base::R.version$version.string), 
[08:26:25.630]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:25.630]                                 base::R.version$platform, 8 * 
[08:26:25.630]                                   base::.Machine$sizeof.pointer), 
[08:26:25.630]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:25.630]                                 "release", "version")], collapse = " "), 
[08:26:25.630]                               hostname = base::Sys.info()[["nodename"]])
[08:26:25.630]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:25.630]                               info)
[08:26:25.630]                             info <- base::paste(info, collapse = "; ")
[08:26:25.630]                             if (!has_future) {
[08:26:25.630]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:25.630]                                 info)
[08:26:25.630]                             }
[08:26:25.630]                             else {
[08:26:25.630]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:25.630]                                 info, version)
[08:26:25.630]                             }
[08:26:25.630]                             base::stop(msg)
[08:26:25.630]                           }
[08:26:25.630]                         })
[08:26:25.630]                       }
[08:26:25.630]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:25.630]                       base::options(mc.cores = 1L)
[08:26:25.630]                     }
[08:26:25.630]                     base::local({
[08:26:25.630]                       for (pkg in c("stats", "future.apply")) {
[08:26:25.630]                         base::loadNamespace(pkg)
[08:26:25.630]                         base::library(pkg, character.only = TRUE)
[08:26:25.630]                       }
[08:26:25.630]                     })
[08:26:25.630]                   }
[08:26:25.630]                   ...future.strategy.old <- future::plan("list")
[08:26:25.630]                   options(future.plan = NULL)
[08:26:25.630]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:25.630]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:25.630]                 }
[08:26:25.630]                 ...future.workdir <- getwd()
[08:26:25.630]             }
[08:26:25.630]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:25.630]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:25.630]         }
[08:26:25.630]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:25.630]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:25.630]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:25.630]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:25.630]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:25.630]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:25.630]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:25.630]             base::names(...future.oldOptions))
[08:26:25.630]     }
[08:26:25.630]     if (FALSE) {
[08:26:25.630]     }
[08:26:25.630]     else {
[08:26:25.630]         if (TRUE) {
[08:26:25.630]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:25.630]                 open = "w")
[08:26:25.630]         }
[08:26:25.630]         else {
[08:26:25.630]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:25.630]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:25.630]         }
[08:26:25.630]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:25.630]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:25.630]             base::sink(type = "output", split = FALSE)
[08:26:25.630]             base::close(...future.stdout)
[08:26:25.630]         }, add = TRUE)
[08:26:25.630]     }
[08:26:25.630]     ...future.frame <- base::sys.nframe()
[08:26:25.630]     ...future.conditions <- base::list()
[08:26:25.630]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:25.630]     if (FALSE) {
[08:26:25.630]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:25.630]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:25.630]     }
[08:26:25.630]     ...future.result <- base::tryCatch({
[08:26:25.630]         base::withCallingHandlers({
[08:26:25.630]             ...future.value <- base::withVisible(base::local({
[08:26:25.630]                 ...future.makeSendCondition <- base::local({
[08:26:25.630]                   sendCondition <- NULL
[08:26:25.630]                   function(frame = 1L) {
[08:26:25.630]                     if (is.function(sendCondition)) 
[08:26:25.630]                       return(sendCondition)
[08:26:25.630]                     ns <- getNamespace("parallel")
[08:26:25.630]                     if (exists("sendData", mode = "function", 
[08:26:25.630]                       envir = ns)) {
[08:26:25.630]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:25.630]                         envir = ns)
[08:26:25.630]                       envir <- sys.frame(frame)
[08:26:25.630]                       master <- NULL
[08:26:25.630]                       while (!identical(envir, .GlobalEnv) && 
[08:26:25.630]                         !identical(envir, emptyenv())) {
[08:26:25.630]                         if (exists("master", mode = "list", envir = envir, 
[08:26:25.630]                           inherits = FALSE)) {
[08:26:25.630]                           master <- get("master", mode = "list", 
[08:26:25.630]                             envir = envir, inherits = FALSE)
[08:26:25.630]                           if (inherits(master, c("SOCKnode", 
[08:26:25.630]                             "SOCK0node"))) {
[08:26:25.630]                             sendCondition <<- function(cond) {
[08:26:25.630]                               data <- list(type = "VALUE", value = cond, 
[08:26:25.630]                                 success = TRUE)
[08:26:25.630]                               parallel_sendData(master, data)
[08:26:25.630]                             }
[08:26:25.630]                             return(sendCondition)
[08:26:25.630]                           }
[08:26:25.630]                         }
[08:26:25.630]                         frame <- frame + 1L
[08:26:25.630]                         envir <- sys.frame(frame)
[08:26:25.630]                       }
[08:26:25.630]                     }
[08:26:25.630]                     sendCondition <<- function(cond) NULL
[08:26:25.630]                   }
[08:26:25.630]                 })
[08:26:25.630]                 withCallingHandlers({
[08:26:25.630]                   {
[08:26:25.630]                     do.call(function(...) {
[08:26:25.630]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:25.630]                       if (!identical(...future.globals.maxSize.org, 
[08:26:25.630]                         ...future.globals.maxSize)) {
[08:26:25.630]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:25.630]                         on.exit(options(oopts), add = TRUE)
[08:26:25.630]                       }
[08:26:25.630]                       {
[08:26:25.630]                         lapply(seq_along(...future.elements_ii), 
[08:26:25.630]                           FUN = function(jj) {
[08:26:25.630]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:25.630]                             ...future.FUN(...future.X_jj, ...)
[08:26:25.630]                           })
[08:26:25.630]                       }
[08:26:25.630]                     }, args = future.call.arguments)
[08:26:25.630]                   }
[08:26:25.630]                 }, immediateCondition = function(cond) {
[08:26:25.630]                   sendCondition <- ...future.makeSendCondition()
[08:26:25.630]                   sendCondition(cond)
[08:26:25.630]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:25.630]                   {
[08:26:25.630]                     inherits <- base::inherits
[08:26:25.630]                     invokeRestart <- base::invokeRestart
[08:26:25.630]                     is.null <- base::is.null
[08:26:25.630]                     muffled <- FALSE
[08:26:25.630]                     if (inherits(cond, "message")) {
[08:26:25.630]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:25.630]                       if (muffled) 
[08:26:25.630]                         invokeRestart("muffleMessage")
[08:26:25.630]                     }
[08:26:25.630]                     else if (inherits(cond, "warning")) {
[08:26:25.630]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:25.630]                       if (muffled) 
[08:26:25.630]                         invokeRestart("muffleWarning")
[08:26:25.630]                     }
[08:26:25.630]                     else if (inherits(cond, "condition")) {
[08:26:25.630]                       if (!is.null(pattern)) {
[08:26:25.630]                         computeRestarts <- base::computeRestarts
[08:26:25.630]                         grepl <- base::grepl
[08:26:25.630]                         restarts <- computeRestarts(cond)
[08:26:25.630]                         for (restart in restarts) {
[08:26:25.630]                           name <- restart$name
[08:26:25.630]                           if (is.null(name)) 
[08:26:25.630]                             next
[08:26:25.630]                           if (!grepl(pattern, name)) 
[08:26:25.630]                             next
[08:26:25.630]                           invokeRestart(restart)
[08:26:25.630]                           muffled <- TRUE
[08:26:25.630]                           break
[08:26:25.630]                         }
[08:26:25.630]                       }
[08:26:25.630]                     }
[08:26:25.630]                     invisible(muffled)
[08:26:25.630]                   }
[08:26:25.630]                   muffleCondition(cond)
[08:26:25.630]                 })
[08:26:25.630]             }))
[08:26:25.630]             future::FutureResult(value = ...future.value$value, 
[08:26:25.630]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:25.630]                   ...future.rng), globalenv = if (FALSE) 
[08:26:25.630]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:25.630]                     ...future.globalenv.names))
[08:26:25.630]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:25.630]         }, condition = base::local({
[08:26:25.630]             c <- base::c
[08:26:25.630]             inherits <- base::inherits
[08:26:25.630]             invokeRestart <- base::invokeRestart
[08:26:25.630]             length <- base::length
[08:26:25.630]             list <- base::list
[08:26:25.630]             seq.int <- base::seq.int
[08:26:25.630]             signalCondition <- base::signalCondition
[08:26:25.630]             sys.calls <- base::sys.calls
[08:26:25.630]             `[[` <- base::`[[`
[08:26:25.630]             `+` <- base::`+`
[08:26:25.630]             `<<-` <- base::`<<-`
[08:26:25.630]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:25.630]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:25.630]                   3L)]
[08:26:25.630]             }
[08:26:25.630]             function(cond) {
[08:26:25.630]                 is_error <- inherits(cond, "error")
[08:26:25.630]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:25.630]                   NULL)
[08:26:25.630]                 if (is_error) {
[08:26:25.630]                   sessionInformation <- function() {
[08:26:25.630]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:25.630]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:25.630]                       search = base::search(), system = base::Sys.info())
[08:26:25.630]                   }
[08:26:25.630]                   ...future.conditions[[length(...future.conditions) + 
[08:26:25.630]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:25.630]                     cond$call), session = sessionInformation(), 
[08:26:25.630]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:25.630]                   signalCondition(cond)
[08:26:25.630]                 }
[08:26:25.630]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:25.630]                 "immediateCondition"))) {
[08:26:25.630]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:25.630]                   ...future.conditions[[length(...future.conditions) + 
[08:26:25.630]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:25.630]                   if (TRUE && !signal) {
[08:26:25.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:25.630]                     {
[08:26:25.630]                       inherits <- base::inherits
[08:26:25.630]                       invokeRestart <- base::invokeRestart
[08:26:25.630]                       is.null <- base::is.null
[08:26:25.630]                       muffled <- FALSE
[08:26:25.630]                       if (inherits(cond, "message")) {
[08:26:25.630]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:25.630]                         if (muffled) 
[08:26:25.630]                           invokeRestart("muffleMessage")
[08:26:25.630]                       }
[08:26:25.630]                       else if (inherits(cond, "warning")) {
[08:26:25.630]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:25.630]                         if (muffled) 
[08:26:25.630]                           invokeRestart("muffleWarning")
[08:26:25.630]                       }
[08:26:25.630]                       else if (inherits(cond, "condition")) {
[08:26:25.630]                         if (!is.null(pattern)) {
[08:26:25.630]                           computeRestarts <- base::computeRestarts
[08:26:25.630]                           grepl <- base::grepl
[08:26:25.630]                           restarts <- computeRestarts(cond)
[08:26:25.630]                           for (restart in restarts) {
[08:26:25.630]                             name <- restart$name
[08:26:25.630]                             if (is.null(name)) 
[08:26:25.630]                               next
[08:26:25.630]                             if (!grepl(pattern, name)) 
[08:26:25.630]                               next
[08:26:25.630]                             invokeRestart(restart)
[08:26:25.630]                             muffled <- TRUE
[08:26:25.630]                             break
[08:26:25.630]                           }
[08:26:25.630]                         }
[08:26:25.630]                       }
[08:26:25.630]                       invisible(muffled)
[08:26:25.630]                     }
[08:26:25.630]                     muffleCondition(cond, pattern = "^muffle")
[08:26:25.630]                   }
[08:26:25.630]                 }
[08:26:25.630]                 else {
[08:26:25.630]                   if (TRUE) {
[08:26:25.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:25.630]                     {
[08:26:25.630]                       inherits <- base::inherits
[08:26:25.630]                       invokeRestart <- base::invokeRestart
[08:26:25.630]                       is.null <- base::is.null
[08:26:25.630]                       muffled <- FALSE
[08:26:25.630]                       if (inherits(cond, "message")) {
[08:26:25.630]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:25.630]                         if (muffled) 
[08:26:25.630]                           invokeRestart("muffleMessage")
[08:26:25.630]                       }
[08:26:25.630]                       else if (inherits(cond, "warning")) {
[08:26:25.630]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:25.630]                         if (muffled) 
[08:26:25.630]                           invokeRestart("muffleWarning")
[08:26:25.630]                       }
[08:26:25.630]                       else if (inherits(cond, "condition")) {
[08:26:25.630]                         if (!is.null(pattern)) {
[08:26:25.630]                           computeRestarts <- base::computeRestarts
[08:26:25.630]                           grepl <- base::grepl
[08:26:25.630]                           restarts <- computeRestarts(cond)
[08:26:25.630]                           for (restart in restarts) {
[08:26:25.630]                             name <- restart$name
[08:26:25.630]                             if (is.null(name)) 
[08:26:25.630]                               next
[08:26:25.630]                             if (!grepl(pattern, name)) 
[08:26:25.630]                               next
[08:26:25.630]                             invokeRestart(restart)
[08:26:25.630]                             muffled <- TRUE
[08:26:25.630]                             break
[08:26:25.630]                           }
[08:26:25.630]                         }
[08:26:25.630]                       }
[08:26:25.630]                       invisible(muffled)
[08:26:25.630]                     }
[08:26:25.630]                     muffleCondition(cond, pattern = "^muffle")
[08:26:25.630]                   }
[08:26:25.630]                 }
[08:26:25.630]             }
[08:26:25.630]         }))
[08:26:25.630]     }, error = function(ex) {
[08:26:25.630]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:25.630]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:25.630]                 ...future.rng), started = ...future.startTime, 
[08:26:25.630]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:25.630]             version = "1.8"), class = "FutureResult")
[08:26:25.630]     }, finally = {
[08:26:25.630]         if (!identical(...future.workdir, getwd())) 
[08:26:25.630]             setwd(...future.workdir)
[08:26:25.630]         {
[08:26:25.630]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:25.630]                 ...future.oldOptions$nwarnings <- NULL
[08:26:25.630]             }
[08:26:25.630]             base::options(...future.oldOptions)
[08:26:25.630]             if (.Platform$OS.type == "windows") {
[08:26:25.630]                 old_names <- names(...future.oldEnvVars)
[08:26:25.630]                 envs <- base::Sys.getenv()
[08:26:25.630]                 names <- names(envs)
[08:26:25.630]                 common <- intersect(names, old_names)
[08:26:25.630]                 added <- setdiff(names, old_names)
[08:26:25.630]                 removed <- setdiff(old_names, names)
[08:26:25.630]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:25.630]                   envs[common]]
[08:26:25.630]                 NAMES <- toupper(changed)
[08:26:25.630]                 args <- list()
[08:26:25.630]                 for (kk in seq_along(NAMES)) {
[08:26:25.630]                   name <- changed[[kk]]
[08:26:25.630]                   NAME <- NAMES[[kk]]
[08:26:25.630]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:25.630]                     next
[08:26:25.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:25.630]                 }
[08:26:25.630]                 NAMES <- toupper(added)
[08:26:25.630]                 for (kk in seq_along(NAMES)) {
[08:26:25.630]                   name <- added[[kk]]
[08:26:25.630]                   NAME <- NAMES[[kk]]
[08:26:25.630]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:25.630]                     next
[08:26:25.630]                   args[[name]] <- ""
[08:26:25.630]                 }
[08:26:25.630]                 NAMES <- toupper(removed)
[08:26:25.630]                 for (kk in seq_along(NAMES)) {
[08:26:25.630]                   name <- removed[[kk]]
[08:26:25.630]                   NAME <- NAMES[[kk]]
[08:26:25.630]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:25.630]                     next
[08:26:25.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:25.630]                 }
[08:26:25.630]                 if (length(args) > 0) 
[08:26:25.630]                   base::do.call(base::Sys.setenv, args = args)
[08:26:25.630]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:25.630]             }
[08:26:25.630]             else {
[08:26:25.630]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:25.630]             }
[08:26:25.630]             {
[08:26:25.630]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:25.630]                   0L) {
[08:26:25.630]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:25.630]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:25.630]                   base::options(opts)
[08:26:25.630]                 }
[08:26:25.630]                 {
[08:26:25.630]                   {
[08:26:25.630]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:25.630]                     NULL
[08:26:25.630]                   }
[08:26:25.630]                   options(future.plan = NULL)
[08:26:25.630]                   if (is.na(NA_character_)) 
[08:26:25.630]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:25.630]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:25.630]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:25.630]                     .init = FALSE)
[08:26:25.630]                 }
[08:26:25.630]             }
[08:26:25.630]         }
[08:26:25.630]     })
[08:26:25.630]     if (TRUE) {
[08:26:25.630]         base::sink(type = "output", split = FALSE)
[08:26:25.630]         if (TRUE) {
[08:26:25.630]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:25.630]         }
[08:26:25.630]         else {
[08:26:25.630]             ...future.result["stdout"] <- base::list(NULL)
[08:26:25.630]         }
[08:26:25.630]         base::close(...future.stdout)
[08:26:25.630]         ...future.stdout <- NULL
[08:26:25.630]     }
[08:26:25.630]     ...future.result$conditions <- ...future.conditions
[08:26:25.630]     ...future.result$finished <- base::Sys.time()
[08:26:25.630]     ...future.result
[08:26:25.630] }
[08:26:25.633] Exporting 11 global objects (13.46 KiB) to cluster node #1 ...
[08:26:25.633] Exporting ‘...future.FUN’ (4.74 KiB) to cluster node #1 ...
[08:26:25.675] Exporting ‘...future.FUN’ (4.74 KiB) to cluster node #1 ... DONE
[08:26:25.675] Exporting ‘x_FUN’ (311 bytes) to cluster node #1 ...
[08:26:25.675] Exporting ‘x_FUN’ (311 bytes) to cluster node #1 ... DONE
[08:26:25.675] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[08:26:25.676] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[08:26:25.676] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[08:26:25.717] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[08:26:25.718] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[08:26:25.759] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[08:26:25.759] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[08:26:25.759] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[08:26:25.759] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[08:26:25.760] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[08:26:25.760] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:26:25.760] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:26:25.760] Exporting ‘...future.elements_ii’ (183 bytes) to cluster node #1 ...
[08:26:25.761] Exporting ‘...future.elements_ii’ (183 bytes) to cluster node #1 ... DONE
[08:26:25.761] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:26:25.761] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:26:25.761] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:26:25.762] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:26:25.762] Exporting 11 global objects (13.46 KiB) to cluster node #1 ... DONE
[08:26:25.762] MultisessionFuture started
[08:26:25.763] - Launch lazy future ... done
[08:26:25.763] run() for ‘MultisessionFuture’ ... done
[08:26:25.763] Created future:
[08:26:25.763] MultisessionFuture:
[08:26:25.763] Label: ‘future_vapply-1’
[08:26:25.763] Expression:
[08:26:25.763] {
[08:26:25.763]     do.call(function(...) {
[08:26:25.763]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:25.763]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:25.763]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:25.763]             on.exit(options(oopts), add = TRUE)
[08:26:25.763]         }
[08:26:25.763]         {
[08:26:25.763]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:25.763]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:25.763]                 ...future.FUN(...future.X_jj, ...)
[08:26:25.763]             })
[08:26:25.763]         }
[08:26:25.763]     }, args = future.call.arguments)
[08:26:25.763] }
[08:26:25.763] Lazy evaluation: FALSE
[08:26:25.763] Asynchronous evaluation: TRUE
[08:26:25.763] Local evaluation: TRUE
[08:26:25.763] Environment: R_GlobalEnv
[08:26:25.763] Capture standard output: TRUE
[08:26:25.763] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:25.763] Globals: 11 objects totaling 13.35 KiB (function ‘...future.FUN’ of 4.74 KiB, function ‘x_FUN’ of 311 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:25.763] Packages: 2 packages (‘stats’, ‘future.apply’)
[08:26:25.763] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:25.763] Resolved: FALSE
[08:26:25.763] Value: <not collected>
[08:26:25.763] Conditions captured: <none>
[08:26:25.763] Early signaling: FALSE
[08:26:25.763] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:25.763] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:25.774] Chunk #1 of 2 ... DONE
[08:26:25.775] Chunk #2 of 2 ...
[08:26:25.775]  - Finding globals in 'X' for chunk #2 ...
[08:26:25.775] getGlobalsAndPackages() ...
[08:26:25.775] Searching for globals...
[08:26:25.775] 
[08:26:25.775] Searching for globals ... DONE
[08:26:25.776] - globals: [0] <none>
[08:26:25.776] getGlobalsAndPackages() ... DONE
[08:26:25.776]    + additional globals found: [n=0] 
[08:26:25.776]    + additional namespaces needed: [n=0] 
[08:26:25.776]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:25.776]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:25.776]  - seeds: <none>
[08:26:25.776]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:25.776] getGlobalsAndPackages() ...
[08:26:25.776] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:25.776] Resolving globals: FALSE
[08:26:25.777] Tweak future expression to call with '...' arguments ...
[08:26:25.777] {
[08:26:25.777]     do.call(function(...) {
[08:26:25.777]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:25.777]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:25.777]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:25.777]             on.exit(options(oopts), add = TRUE)
[08:26:25.777]         }
[08:26:25.777]         {
[08:26:25.777]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:25.777]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:25.777]                 ...future.FUN(...future.X_jj, ...)
[08:26:25.777]             })
[08:26:25.777]         }
[08:26:25.777]     }, args = future.call.arguments)
[08:26:25.777] }
[08:26:25.777] Tweak future expression to call with '...' arguments ... DONE
[08:26:25.777] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:25.778] - packages: [2] ‘stats’, ‘future.apply’
[08:26:25.778] getGlobalsAndPackages() ... DONE
[08:26:25.778] run() for ‘Future’ ...
[08:26:25.778] - state: ‘created’
[08:26:25.778] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:25.792] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:25.793] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:25.793]   - Field: ‘node’
[08:26:25.793]   - Field: ‘label’
[08:26:25.793]   - Field: ‘local’
[08:26:25.793]   - Field: ‘owner’
[08:26:25.793]   - Field: ‘envir’
[08:26:25.793]   - Field: ‘workers’
[08:26:25.793]   - Field: ‘packages’
[08:26:25.793]   - Field: ‘gc’
[08:26:25.793]   - Field: ‘conditions’
[08:26:25.794]   - Field: ‘persistent’
[08:26:25.794]   - Field: ‘expr’
[08:26:25.794]   - Field: ‘uuid’
[08:26:25.794]   - Field: ‘seed’
[08:26:25.794]   - Field: ‘version’
[08:26:25.794]   - Field: ‘result’
[08:26:25.794]   - Field: ‘asynchronous’
[08:26:25.794]   - Field: ‘calls’
[08:26:25.794]   - Field: ‘globals’
[08:26:25.794]   - Field: ‘stdout’
[08:26:25.794]   - Field: ‘earlySignal’
[08:26:25.794]   - Field: ‘lazy’
[08:26:25.795]   - Field: ‘state’
[08:26:25.795] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:25.795] - Launch lazy future ...
[08:26:25.795] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[08:26:25.795] Packages needed by future strategies (n = 0): <none>
[08:26:25.796] {
[08:26:25.796]     {
[08:26:25.796]         {
[08:26:25.796]             ...future.startTime <- base::Sys.time()
[08:26:25.796]             {
[08:26:25.796]                 {
[08:26:25.796]                   {
[08:26:25.796]                     {
[08:26:25.796]                       {
[08:26:25.796]                         base::local({
[08:26:25.796]                           has_future <- base::requireNamespace("future", 
[08:26:25.796]                             quietly = TRUE)
[08:26:25.796]                           if (has_future) {
[08:26:25.796]                             ns <- base::getNamespace("future")
[08:26:25.796]                             version <- ns[[".package"]][["version"]]
[08:26:25.796]                             if (is.null(version)) 
[08:26:25.796]                               version <- utils::packageVersion("future")
[08:26:25.796]                           }
[08:26:25.796]                           else {
[08:26:25.796]                             version <- NULL
[08:26:25.796]                           }
[08:26:25.796]                           if (!has_future || version < "1.8.0") {
[08:26:25.796]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:25.796]                               "", base::R.version$version.string), 
[08:26:25.796]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:25.796]                                 base::R.version$platform, 8 * 
[08:26:25.796]                                   base::.Machine$sizeof.pointer), 
[08:26:25.796]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:25.796]                                 "release", "version")], collapse = " "), 
[08:26:25.796]                               hostname = base::Sys.info()[["nodename"]])
[08:26:25.796]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:25.796]                               info)
[08:26:25.796]                             info <- base::paste(info, collapse = "; ")
[08:26:25.796]                             if (!has_future) {
[08:26:25.796]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:25.796]                                 info)
[08:26:25.796]                             }
[08:26:25.796]                             else {
[08:26:25.796]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:25.796]                                 info, version)
[08:26:25.796]                             }
[08:26:25.796]                             base::stop(msg)
[08:26:25.796]                           }
[08:26:25.796]                         })
[08:26:25.796]                       }
[08:26:25.796]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:25.796]                       base::options(mc.cores = 1L)
[08:26:25.796]                     }
[08:26:25.796]                     base::local({
[08:26:25.796]                       for (pkg in c("stats", "future.apply")) {
[08:26:25.796]                         base::loadNamespace(pkg)
[08:26:25.796]                         base::library(pkg, character.only = TRUE)
[08:26:25.796]                       }
[08:26:25.796]                     })
[08:26:25.796]                   }
[08:26:25.796]                   ...future.strategy.old <- future::plan("list")
[08:26:25.796]                   options(future.plan = NULL)
[08:26:25.796]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:25.796]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:25.796]                 }
[08:26:25.796]                 ...future.workdir <- getwd()
[08:26:25.796]             }
[08:26:25.796]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:25.796]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:25.796]         }
[08:26:25.796]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:25.796]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:25.796]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:25.796]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:25.796]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:25.796]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:25.796]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:25.796]             base::names(...future.oldOptions))
[08:26:25.796]     }
[08:26:25.796]     if (FALSE) {
[08:26:25.796]     }
[08:26:25.796]     else {
[08:26:25.796]         if (TRUE) {
[08:26:25.796]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:25.796]                 open = "w")
[08:26:25.796]         }
[08:26:25.796]         else {
[08:26:25.796]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:25.796]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:25.796]         }
[08:26:25.796]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:25.796]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:25.796]             base::sink(type = "output", split = FALSE)
[08:26:25.796]             base::close(...future.stdout)
[08:26:25.796]         }, add = TRUE)
[08:26:25.796]     }
[08:26:25.796]     ...future.frame <- base::sys.nframe()
[08:26:25.796]     ...future.conditions <- base::list()
[08:26:25.796]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:25.796]     if (FALSE) {
[08:26:25.796]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:25.796]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:25.796]     }
[08:26:25.796]     ...future.result <- base::tryCatch({
[08:26:25.796]         base::withCallingHandlers({
[08:26:25.796]             ...future.value <- base::withVisible(base::local({
[08:26:25.796]                 ...future.makeSendCondition <- base::local({
[08:26:25.796]                   sendCondition <- NULL
[08:26:25.796]                   function(frame = 1L) {
[08:26:25.796]                     if (is.function(sendCondition)) 
[08:26:25.796]                       return(sendCondition)
[08:26:25.796]                     ns <- getNamespace("parallel")
[08:26:25.796]                     if (exists("sendData", mode = "function", 
[08:26:25.796]                       envir = ns)) {
[08:26:25.796]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:25.796]                         envir = ns)
[08:26:25.796]                       envir <- sys.frame(frame)
[08:26:25.796]                       master <- NULL
[08:26:25.796]                       while (!identical(envir, .GlobalEnv) && 
[08:26:25.796]                         !identical(envir, emptyenv())) {
[08:26:25.796]                         if (exists("master", mode = "list", envir = envir, 
[08:26:25.796]                           inherits = FALSE)) {
[08:26:25.796]                           master <- get("master", mode = "list", 
[08:26:25.796]                             envir = envir, inherits = FALSE)
[08:26:25.796]                           if (inherits(master, c("SOCKnode", 
[08:26:25.796]                             "SOCK0node"))) {
[08:26:25.796]                             sendCondition <<- function(cond) {
[08:26:25.796]                               data <- list(type = "VALUE", value = cond, 
[08:26:25.796]                                 success = TRUE)
[08:26:25.796]                               parallel_sendData(master, data)
[08:26:25.796]                             }
[08:26:25.796]                             return(sendCondition)
[08:26:25.796]                           }
[08:26:25.796]                         }
[08:26:25.796]                         frame <- frame + 1L
[08:26:25.796]                         envir <- sys.frame(frame)
[08:26:25.796]                       }
[08:26:25.796]                     }
[08:26:25.796]                     sendCondition <<- function(cond) NULL
[08:26:25.796]                   }
[08:26:25.796]                 })
[08:26:25.796]                 withCallingHandlers({
[08:26:25.796]                   {
[08:26:25.796]                     do.call(function(...) {
[08:26:25.796]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:25.796]                       if (!identical(...future.globals.maxSize.org, 
[08:26:25.796]                         ...future.globals.maxSize)) {
[08:26:25.796]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:25.796]                         on.exit(options(oopts), add = TRUE)
[08:26:25.796]                       }
[08:26:25.796]                       {
[08:26:25.796]                         lapply(seq_along(...future.elements_ii), 
[08:26:25.796]                           FUN = function(jj) {
[08:26:25.796]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:25.796]                             ...future.FUN(...future.X_jj, ...)
[08:26:25.796]                           })
[08:26:25.796]                       }
[08:26:25.796]                     }, args = future.call.arguments)
[08:26:25.796]                   }
[08:26:25.796]                 }, immediateCondition = function(cond) {
[08:26:25.796]                   sendCondition <- ...future.makeSendCondition()
[08:26:25.796]                   sendCondition(cond)
[08:26:25.796]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:25.796]                   {
[08:26:25.796]                     inherits <- base::inherits
[08:26:25.796]                     invokeRestart <- base::invokeRestart
[08:26:25.796]                     is.null <- base::is.null
[08:26:25.796]                     muffled <- FALSE
[08:26:25.796]                     if (inherits(cond, "message")) {
[08:26:25.796]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:25.796]                       if (muffled) 
[08:26:25.796]                         invokeRestart("muffleMessage")
[08:26:25.796]                     }
[08:26:25.796]                     else if (inherits(cond, "warning")) {
[08:26:25.796]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:25.796]                       if (muffled) 
[08:26:25.796]                         invokeRestart("muffleWarning")
[08:26:25.796]                     }
[08:26:25.796]                     else if (inherits(cond, "condition")) {
[08:26:25.796]                       if (!is.null(pattern)) {
[08:26:25.796]                         computeRestarts <- base::computeRestarts
[08:26:25.796]                         grepl <- base::grepl
[08:26:25.796]                         restarts <- computeRestarts(cond)
[08:26:25.796]                         for (restart in restarts) {
[08:26:25.796]                           name <- restart$name
[08:26:25.796]                           if (is.null(name)) 
[08:26:25.796]                             next
[08:26:25.796]                           if (!grepl(pattern, name)) 
[08:26:25.796]                             next
[08:26:25.796]                           invokeRestart(restart)
[08:26:25.796]                           muffled <- TRUE
[08:26:25.796]                           break
[08:26:25.796]                         }
[08:26:25.796]                       }
[08:26:25.796]                     }
[08:26:25.796]                     invisible(muffled)
[08:26:25.796]                   }
[08:26:25.796]                   muffleCondition(cond)
[08:26:25.796]                 })
[08:26:25.796]             }))
[08:26:25.796]             future::FutureResult(value = ...future.value$value, 
[08:26:25.796]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:25.796]                   ...future.rng), globalenv = if (FALSE) 
[08:26:25.796]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:25.796]                     ...future.globalenv.names))
[08:26:25.796]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:25.796]         }, condition = base::local({
[08:26:25.796]             c <- base::c
[08:26:25.796]             inherits <- base::inherits
[08:26:25.796]             invokeRestart <- base::invokeRestart
[08:26:25.796]             length <- base::length
[08:26:25.796]             list <- base::list
[08:26:25.796]             seq.int <- base::seq.int
[08:26:25.796]             signalCondition <- base::signalCondition
[08:26:25.796]             sys.calls <- base::sys.calls
[08:26:25.796]             `[[` <- base::`[[`
[08:26:25.796]             `+` <- base::`+`
[08:26:25.796]             `<<-` <- base::`<<-`
[08:26:25.796]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:25.796]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:25.796]                   3L)]
[08:26:25.796]             }
[08:26:25.796]             function(cond) {
[08:26:25.796]                 is_error <- inherits(cond, "error")
[08:26:25.796]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:25.796]                   NULL)
[08:26:25.796]                 if (is_error) {
[08:26:25.796]                   sessionInformation <- function() {
[08:26:25.796]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:25.796]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:25.796]                       search = base::search(), system = base::Sys.info())
[08:26:25.796]                   }
[08:26:25.796]                   ...future.conditions[[length(...future.conditions) + 
[08:26:25.796]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:25.796]                     cond$call), session = sessionInformation(), 
[08:26:25.796]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:25.796]                   signalCondition(cond)
[08:26:25.796]                 }
[08:26:25.796]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:25.796]                 "immediateCondition"))) {
[08:26:25.796]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:25.796]                   ...future.conditions[[length(...future.conditions) + 
[08:26:25.796]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:25.796]                   if (TRUE && !signal) {
[08:26:25.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:25.796]                     {
[08:26:25.796]                       inherits <- base::inherits
[08:26:25.796]                       invokeRestart <- base::invokeRestart
[08:26:25.796]                       is.null <- base::is.null
[08:26:25.796]                       muffled <- FALSE
[08:26:25.796]                       if (inherits(cond, "message")) {
[08:26:25.796]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:25.796]                         if (muffled) 
[08:26:25.796]                           invokeRestart("muffleMessage")
[08:26:25.796]                       }
[08:26:25.796]                       else if (inherits(cond, "warning")) {
[08:26:25.796]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:25.796]                         if (muffled) 
[08:26:25.796]                           invokeRestart("muffleWarning")
[08:26:25.796]                       }
[08:26:25.796]                       else if (inherits(cond, "condition")) {
[08:26:25.796]                         if (!is.null(pattern)) {
[08:26:25.796]                           computeRestarts <- base::computeRestarts
[08:26:25.796]                           grepl <- base::grepl
[08:26:25.796]                           restarts <- computeRestarts(cond)
[08:26:25.796]                           for (restart in restarts) {
[08:26:25.796]                             name <- restart$name
[08:26:25.796]                             if (is.null(name)) 
[08:26:25.796]                               next
[08:26:25.796]                             if (!grepl(pattern, name)) 
[08:26:25.796]                               next
[08:26:25.796]                             invokeRestart(restart)
[08:26:25.796]                             muffled <- TRUE
[08:26:25.796]                             break
[08:26:25.796]                           }
[08:26:25.796]                         }
[08:26:25.796]                       }
[08:26:25.796]                       invisible(muffled)
[08:26:25.796]                     }
[08:26:25.796]                     muffleCondition(cond, pattern = "^muffle")
[08:26:25.796]                   }
[08:26:25.796]                 }
[08:26:25.796]                 else {
[08:26:25.796]                   if (TRUE) {
[08:26:25.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:25.796]                     {
[08:26:25.796]                       inherits <- base::inherits
[08:26:25.796]                       invokeRestart <- base::invokeRestart
[08:26:25.796]                       is.null <- base::is.null
[08:26:25.796]                       muffled <- FALSE
[08:26:25.796]                       if (inherits(cond, "message")) {
[08:26:25.796]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:25.796]                         if (muffled) 
[08:26:25.796]                           invokeRestart("muffleMessage")
[08:26:25.796]                       }
[08:26:25.796]                       else if (inherits(cond, "warning")) {
[08:26:25.796]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:25.796]                         if (muffled) 
[08:26:25.796]                           invokeRestart("muffleWarning")
[08:26:25.796]                       }
[08:26:25.796]                       else if (inherits(cond, "condition")) {
[08:26:25.796]                         if (!is.null(pattern)) {
[08:26:25.796]                           computeRestarts <- base::computeRestarts
[08:26:25.796]                           grepl <- base::grepl
[08:26:25.796]                           restarts <- computeRestarts(cond)
[08:26:25.796]                           for (restart in restarts) {
[08:26:25.796]                             name <- restart$name
[08:26:25.796]                             if (is.null(name)) 
[08:26:25.796]                               next
[08:26:25.796]                             if (!grepl(pattern, name)) 
[08:26:25.796]                               next
[08:26:25.796]                             invokeRestart(restart)
[08:26:25.796]                             muffled <- TRUE
[08:26:25.796]                             break
[08:26:25.796]                           }
[08:26:25.796]                         }
[08:26:25.796]                       }
[08:26:25.796]                       invisible(muffled)
[08:26:25.796]                     }
[08:26:25.796]                     muffleCondition(cond, pattern = "^muffle")
[08:26:25.796]                   }
[08:26:25.796]                 }
[08:26:25.796]             }
[08:26:25.796]         }))
[08:26:25.796]     }, error = function(ex) {
[08:26:25.796]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:25.796]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:25.796]                 ...future.rng), started = ...future.startTime, 
[08:26:25.796]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:25.796]             version = "1.8"), class = "FutureResult")
[08:26:25.796]     }, finally = {
[08:26:25.796]         if (!identical(...future.workdir, getwd())) 
[08:26:25.796]             setwd(...future.workdir)
[08:26:25.796]         {
[08:26:25.796]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:25.796]                 ...future.oldOptions$nwarnings <- NULL
[08:26:25.796]             }
[08:26:25.796]             base::options(...future.oldOptions)
[08:26:25.796]             if (.Platform$OS.type == "windows") {
[08:26:25.796]                 old_names <- names(...future.oldEnvVars)
[08:26:25.796]                 envs <- base::Sys.getenv()
[08:26:25.796]                 names <- names(envs)
[08:26:25.796]                 common <- intersect(names, old_names)
[08:26:25.796]                 added <- setdiff(names, old_names)
[08:26:25.796]                 removed <- setdiff(old_names, names)
[08:26:25.796]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:25.796]                   envs[common]]
[08:26:25.796]                 NAMES <- toupper(changed)
[08:26:25.796]                 args <- list()
[08:26:25.796]                 for (kk in seq_along(NAMES)) {
[08:26:25.796]                   name <- changed[[kk]]
[08:26:25.796]                   NAME <- NAMES[[kk]]
[08:26:25.796]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:25.796]                     next
[08:26:25.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:25.796]                 }
[08:26:25.796]                 NAMES <- toupper(added)
[08:26:25.796]                 for (kk in seq_along(NAMES)) {
[08:26:25.796]                   name <- added[[kk]]
[08:26:25.796]                   NAME <- NAMES[[kk]]
[08:26:25.796]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:25.796]                     next
[08:26:25.796]                   args[[name]] <- ""
[08:26:25.796]                 }
[08:26:25.796]                 NAMES <- toupper(removed)
[08:26:25.796]                 for (kk in seq_along(NAMES)) {
[08:26:25.796]                   name <- removed[[kk]]
[08:26:25.796]                   NAME <- NAMES[[kk]]
[08:26:25.796]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:25.796]                     next
[08:26:25.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:25.796]                 }
[08:26:25.796]                 if (length(args) > 0) 
[08:26:25.796]                   base::do.call(base::Sys.setenv, args = args)
[08:26:25.796]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:25.796]             }
[08:26:25.796]             else {
[08:26:25.796]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:25.796]             }
[08:26:25.796]             {
[08:26:25.796]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:25.796]                   0L) {
[08:26:25.796]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:25.796]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:25.796]                   base::options(opts)
[08:26:25.796]                 }
[08:26:25.796]                 {
[08:26:25.796]                   {
[08:26:25.796]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:25.796]                     NULL
[08:26:25.796]                   }
[08:26:25.796]                   options(future.plan = NULL)
[08:26:25.796]                   if (is.na(NA_character_)) 
[08:26:25.796]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:25.796]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:25.796]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:25.796]                     .init = FALSE)
[08:26:25.796]                 }
[08:26:25.796]             }
[08:26:25.796]         }
[08:26:25.796]     })
[08:26:25.796]     if (TRUE) {
[08:26:25.796]         base::sink(type = "output", split = FALSE)
[08:26:25.796]         if (TRUE) {
[08:26:25.796]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:25.796]         }
[08:26:25.796]         else {
[08:26:25.796]             ...future.result["stdout"] <- base::list(NULL)
[08:26:25.796]         }
[08:26:25.796]         base::close(...future.stdout)
[08:26:25.796]         ...future.stdout <- NULL
[08:26:25.796]     }
[08:26:25.796]     ...future.result$conditions <- ...future.conditions
[08:26:25.796]     ...future.result$finished <- base::Sys.time()
[08:26:25.796]     ...future.result
[08:26:25.796] }
[08:26:25.799] Exporting 11 global objects (13.49 KiB) to cluster node #2 ...
[08:26:25.799] Exporting ‘...future.FUN’ (4.74 KiB) to cluster node #2 ...
[08:26:25.841] Exporting ‘...future.FUN’ (4.74 KiB) to cluster node #2 ... DONE
[08:26:25.841] Exporting ‘x_FUN’ (311 bytes) to cluster node #2 ...
[08:26:25.841] Exporting ‘x_FUN’ (311 bytes) to cluster node #2 ... DONE
[08:26:25.842] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[08:26:25.842] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[08:26:25.842] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[08:26:25.883] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[08:26:25.884] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[08:26:25.925] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[08:26:25.925] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[08:26:25.925] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[08:26:25.925] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[08:26:25.926] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[08:26:25.926] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:26:25.926] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:26:25.926] Exporting ‘...future.elements_ii’ (177 bytes) to cluster node #2 ...
[08:26:25.927] Exporting ‘...future.elements_ii’ (177 bytes) to cluster node #2 ... DONE
[08:26:25.927] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:26:25.927] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:26:25.927] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:26:25.928] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:26:25.928] Exporting 11 global objects (13.49 KiB) to cluster node #2 ... DONE
[08:26:25.928] MultisessionFuture started
[08:26:25.929] - Launch lazy future ... done
[08:26:25.929] run() for ‘MultisessionFuture’ ... done
[08:26:25.929] Created future:
[08:26:25.929] MultisessionFuture:
[08:26:25.929] Label: ‘future_vapply-2’
[08:26:25.929] Expression:
[08:26:25.929] {
[08:26:25.929]     do.call(function(...) {
[08:26:25.929]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:25.929]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:25.929]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:25.929]             on.exit(options(oopts), add = TRUE)
[08:26:25.929]         }
[08:26:25.929]         {
[08:26:25.929]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:25.929]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:25.929]                 ...future.FUN(...future.X_jj, ...)
[08:26:25.929]             })
[08:26:25.929]         }
[08:26:25.929]     }, args = future.call.arguments)
[08:26:25.929] }
[08:26:25.929] Lazy evaluation: FALSE
[08:26:25.929] Asynchronous evaluation: TRUE
[08:26:25.929] Local evaluation: TRUE
[08:26:25.929] Environment: R_GlobalEnv
[08:26:25.929] Capture standard output: TRUE
[08:26:25.929] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:25.929] Globals: 11 objects totaling 13.34 KiB (function ‘...future.FUN’ of 4.74 KiB, function ‘x_FUN’ of 311 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:25.929] Packages: 2 packages (‘stats’, ‘future.apply’)
[08:26:25.929] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:25.929] Resolved: FALSE
[08:26:25.929] Value: <not collected>
[08:26:25.929] Conditions captured: <none>
[08:26:25.929] Early signaling: FALSE
[08:26:25.929] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:25.929] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:25.941] Chunk #2 of 2 ... DONE
[08:26:25.941] Launching 2 futures (chunks) ... DONE
[08:26:25.941] Resolving 2 futures (chunks) ...
[08:26:25.941] resolve() on list ...
[08:26:25.941]  recursive: 0
[08:26:25.941]  length: 2
[08:26:25.941] 
[08:26:25.942] receiveMessageFromWorker() for ClusterFuture ...
[08:26:25.942] - Validating connection of MultisessionFuture
[08:26:25.942] - received message: FutureResult
[08:26:25.942] - Received FutureResult
[08:26:25.942] - Erased future from FutureRegistry
[08:26:25.942] result() for ClusterFuture ...
[08:26:25.942] - result already collected: FutureResult
[08:26:25.943] result() for ClusterFuture ... done
[08:26:25.943] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:25.943] Future #1
[08:26:25.943] result() for ClusterFuture ...
[08:26:25.943] - result already collected: FutureResult
[08:26:25.943] result() for ClusterFuture ... done
[08:26:25.943] result() for ClusterFuture ...
[08:26:25.943] - result already collected: FutureResult
[08:26:25.943] result() for ClusterFuture ... done
[08:26:25.943] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:26:25.943] - nx: 2
[08:26:25.943] - relay: TRUE
[08:26:25.944] - stdout: TRUE
[08:26:25.944] - signal: TRUE
[08:26:25.944] - resignal: FALSE
[08:26:25.944] - force: TRUE
[08:26:25.944] - relayed: [n=2] FALSE, FALSE
[08:26:25.944] - queued futures: [n=2] FALSE, FALSE
[08:26:25.944]  - until=1
[08:26:25.944]  - relaying element #1
[08:26:25.944] result() for ClusterFuture ...
[08:26:25.944] - result already collected: FutureResult
[08:26:25.944] result() for ClusterFuture ... done
[08:26:25.944] result() for ClusterFuture ...
[08:26:25.945] - result already collected: FutureResult
[08:26:25.945] result() for ClusterFuture ... done
[08:26:25.945] result() for ClusterFuture ...
[08:26:25.945] - result already collected: FutureResult
[08:26:25.945] result() for ClusterFuture ... done
[08:26:25.945] result() for ClusterFuture ...
[08:26:25.945] - result already collected: FutureResult
[08:26:25.945] result() for ClusterFuture ... done
[08:26:25.945] - relayed: [n=2] TRUE, FALSE
[08:26:25.945] - queued futures: [n=2] TRUE, FALSE
[08:26:25.945] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:26:25.946]  length: 1 (resolved future 1)
[08:26:25.972] receiveMessageFromWorker() for ClusterFuture ...
[08:26:25.972] - Validating connection of MultisessionFuture
[08:26:25.972] - received message: FutureResult
[08:26:25.973] - Received FutureResult
[08:26:25.973] - Erased future from FutureRegistry
[08:26:25.973] result() for ClusterFuture ...
[08:26:25.973] - result already collected: FutureResult
[08:26:25.973] result() for ClusterFuture ... done
[08:26:25.973] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:25.973] Future #2
[08:26:25.973] result() for ClusterFuture ...
[08:26:25.973] - result already collected: FutureResult
[08:26:25.973] result() for ClusterFuture ... done
[08:26:25.973] result() for ClusterFuture ...
[08:26:25.974] - result already collected: FutureResult
[08:26:25.974] result() for ClusterFuture ... done
[08:26:25.974] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:26:25.974] - nx: 2
[08:26:25.974] - relay: TRUE
[08:26:25.974] - stdout: TRUE
[08:26:25.974] - signal: TRUE
[08:26:25.974] - resignal: FALSE
[08:26:25.974] - force: TRUE
[08:26:25.974] - relayed: [n=2] TRUE, FALSE
[08:26:25.974] - queued futures: [n=2] TRUE, FALSE
[08:26:25.974]  - until=2
[08:26:25.975]  - relaying element #2
[08:26:25.975] result() for ClusterFuture ...
[08:26:25.975] - result already collected: FutureResult
[08:26:25.975] result() for ClusterFuture ... done
[08:26:25.975] result() for ClusterFuture ...
[08:26:25.975] - result already collected: FutureResult
[08:26:25.975] result() for ClusterFuture ... done
[08:26:25.975] result() for ClusterFuture ...
[08:26:25.975] - result already collected: FutureResult
[08:26:25.975] result() for ClusterFuture ... done
[08:26:25.975] result() for ClusterFuture ...
[08:26:25.976] - result already collected: FutureResult
[08:26:25.976] result() for ClusterFuture ... done
[08:26:25.976] - relayed: [n=2] TRUE, TRUE
[08:26:25.976] - queued futures: [n=2] TRUE, TRUE
[08:26:25.976] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:26:25.976]  length: 0 (resolved future 2)
[08:26:25.976] Relaying remaining futures
[08:26:25.976] signalConditionsASAP(NULL, pos=0) ...
[08:26:25.976] - nx: 2
[08:26:25.976] - relay: TRUE
[08:26:25.976] - stdout: TRUE
[08:26:25.976] - signal: TRUE
[08:26:25.976] - resignal: FALSE
[08:26:25.977] - force: TRUE
[08:26:25.977] - relayed: [n=2] TRUE, TRUE
[08:26:25.977] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:25.977] - relayed: [n=2] TRUE, TRUE
[08:26:25.977] - queued futures: [n=2] TRUE, TRUE
[08:26:25.977] signalConditionsASAP(NULL, pos=0) ... done
[08:26:25.977] resolve() on list ... DONE
[08:26:25.977] result() for ClusterFuture ...
[08:26:25.977] - result already collected: FutureResult
[08:26:25.977] result() for ClusterFuture ... done
[08:26:25.977] result() for ClusterFuture ...
[08:26:25.978] - result already collected: FutureResult
[08:26:25.978] result() for ClusterFuture ... done
[08:26:25.978] result() for ClusterFuture ...
[08:26:25.978] - result already collected: FutureResult
[08:26:25.978] result() for ClusterFuture ... done
[08:26:25.978] result() for ClusterFuture ...
[08:26:25.978] - result already collected: FutureResult
[08:26:25.978] result() for ClusterFuture ... done
[08:26:25.978]  - Number of value chunks collected: 2
[08:26:25.978] Resolving 2 futures (chunks) ... DONE
[08:26:25.978] Reducing values from 2 chunks ...
[08:26:25.978]  - Number of values collected after concatenation: 3
[08:26:25.979]  - Number of values expected: 3
[08:26:25.979] Reducing values from 2 chunks ... DONE
[08:26:25.979] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[08:26:25.980] future_lapply() ...
[08:26:25.993] Number of chunks: 2
[08:26:25.994] getGlobalsAndPackagesXApply() ...
[08:26:25.994]  - future.globals: TRUE
[08:26:25.994] getGlobalsAndPackages() ...
[08:26:25.994] Searching for globals...
[08:26:25.998] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[08:26:25.999] Searching for globals ... DONE
[08:26:25.999] Resolving globals: FALSE
[08:26:26.000] The total size of the 1 globals is 4.67 KiB (4777 bytes)
[08:26:26.000] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.67 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.67 KiB of class ‘function’)
[08:26:26.000] - globals: [1] ‘FUN’
[08:26:26.000] - packages: [1] ‘stats’
[08:26:26.000] getGlobalsAndPackages() ... DONE
[08:26:26.000]  - globals found/used: [n=1] ‘FUN’
[08:26:26.000]  - needed namespaces: [n=1] ‘stats’
[08:26:26.001] Finding globals ... DONE
[08:26:26.001]  - use_args: TRUE
[08:26:26.001]  - Getting '...' globals ...
[08:26:26.001] resolve() on list ...
[08:26:26.001]  recursive: 0
[08:26:26.001]  length: 1
[08:26:26.001]  elements: ‘...’
[08:26:26.001]  length: 0 (resolved future 1)
[08:26:26.001] resolve() on list ... DONE
[08:26:26.002]    - '...' content: [n=0] 
[08:26:26.002] List of 1
[08:26:26.002]  $ ...: list()
[08:26:26.002]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:26.002]  - attr(*, "where")=List of 1
[08:26:26.002]   ..$ ...:<environment: 0x562caac78ac0> 
[08:26:26.002]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:26.002]  - attr(*, "resolved")= logi TRUE
[08:26:26.002]  - attr(*, "total_size")= num NA
[08:26:26.004]  - Getting '...' globals ... DONE
[08:26:26.004] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:26:26.005] List of 2
[08:26:26.005]  $ ...future.FUN:function (x, na.rm = TRUE)  
[08:26:26.005]  $ ...          : list()
[08:26:26.005]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:26.005]  - attr(*, "where")=List of 2
[08:26:26.005]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:26.005]   ..$ ...          :<environment: 0x562caac78ac0> 
[08:26:26.005]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:26.005]  - attr(*, "resolved")= logi FALSE
[08:26:26.005]  - attr(*, "total_size")= num 18895
[08:26:26.007] Packages to be attached in all futures: [n=1] ‘stats’
[08:26:26.007] getGlobalsAndPackagesXApply() ... DONE
[08:26:26.008] Number of futures (= number of chunks): 2
[08:26:26.008] Launching 2 futures (chunks) ...
[08:26:26.008] Chunk #1 of 2 ...
[08:26:26.008]  - Finding globals in 'X' for chunk #1 ...
[08:26:26.008] getGlobalsAndPackages() ...
[08:26:26.008] Searching for globals...
[08:26:26.008] 
[08:26:26.008] Searching for globals ... DONE
[08:26:26.009] - globals: [0] <none>
[08:26:26.009] getGlobalsAndPackages() ... DONE
[08:26:26.009]    + additional globals found: [n=0] 
[08:26:26.009]    + additional namespaces needed: [n=0] 
[08:26:26.009]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:26.009]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:26.009]  - seeds: <none>
[08:26:26.009]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.009] getGlobalsAndPackages() ...
[08:26:26.009] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.009] Resolving globals: FALSE
[08:26:26.010] Tweak future expression to call with '...' arguments ...
[08:26:26.010] {
[08:26:26.010]     do.call(function(...) {
[08:26:26.010]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:26.010]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:26.010]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:26.010]             on.exit(options(oopts), add = TRUE)
[08:26:26.010]         }
[08:26:26.010]         {
[08:26:26.010]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:26.010]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:26.010]                 ...future.FUN(...future.X_jj, ...)
[08:26:26.010]             })
[08:26:26.010]         }
[08:26:26.010]     }, args = future.call.arguments)
[08:26:26.010] }
[08:26:26.010] Tweak future expression to call with '...' arguments ... DONE
[08:26:26.010] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.010] - packages: [1] ‘stats’
[08:26:26.010] getGlobalsAndPackages() ... DONE
[08:26:26.011] run() for ‘Future’ ...
[08:26:26.011] - state: ‘created’
[08:26:26.011] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:26.025] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:26.026] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:26.026]   - Field: ‘node’
[08:26:26.026]   - Field: ‘label’
[08:26:26.026]   - Field: ‘local’
[08:26:26.026]   - Field: ‘owner’
[08:26:26.026]   - Field: ‘envir’
[08:26:26.026]   - Field: ‘workers’
[08:26:26.026]   - Field: ‘packages’
[08:26:26.026]   - Field: ‘gc’
[08:26:26.026]   - Field: ‘conditions’
[08:26:26.026]   - Field: ‘persistent’
[08:26:26.027]   - Field: ‘expr’
[08:26:26.027]   - Field: ‘uuid’
[08:26:26.027]   - Field: ‘seed’
[08:26:26.027]   - Field: ‘version’
[08:26:26.027]   - Field: ‘result’
[08:26:26.027]   - Field: ‘asynchronous’
[08:26:26.027]   - Field: ‘calls’
[08:26:26.027]   - Field: ‘globals’
[08:26:26.027]   - Field: ‘stdout’
[08:26:26.027]   - Field: ‘earlySignal’
[08:26:26.027]   - Field: ‘lazy’
[08:26:26.027]   - Field: ‘state’
[08:26:26.028] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:26.028] - Launch lazy future ...
[08:26:26.028] Packages needed by the future expression (n = 1): ‘stats’
[08:26:26.028] Packages needed by future strategies (n = 0): <none>
[08:26:26.029] {
[08:26:26.029]     {
[08:26:26.029]         {
[08:26:26.029]             ...future.startTime <- base::Sys.time()
[08:26:26.029]             {
[08:26:26.029]                 {
[08:26:26.029]                   {
[08:26:26.029]                     {
[08:26:26.029]                       {
[08:26:26.029]                         base::local({
[08:26:26.029]                           has_future <- base::requireNamespace("future", 
[08:26:26.029]                             quietly = TRUE)
[08:26:26.029]                           if (has_future) {
[08:26:26.029]                             ns <- base::getNamespace("future")
[08:26:26.029]                             version <- ns[[".package"]][["version"]]
[08:26:26.029]                             if (is.null(version)) 
[08:26:26.029]                               version <- utils::packageVersion("future")
[08:26:26.029]                           }
[08:26:26.029]                           else {
[08:26:26.029]                             version <- NULL
[08:26:26.029]                           }
[08:26:26.029]                           if (!has_future || version < "1.8.0") {
[08:26:26.029]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:26.029]                               "", base::R.version$version.string), 
[08:26:26.029]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:26.029]                                 base::R.version$platform, 8 * 
[08:26:26.029]                                   base::.Machine$sizeof.pointer), 
[08:26:26.029]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:26.029]                                 "release", "version")], collapse = " "), 
[08:26:26.029]                               hostname = base::Sys.info()[["nodename"]])
[08:26:26.029]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:26.029]                               info)
[08:26:26.029]                             info <- base::paste(info, collapse = "; ")
[08:26:26.029]                             if (!has_future) {
[08:26:26.029]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:26.029]                                 info)
[08:26:26.029]                             }
[08:26:26.029]                             else {
[08:26:26.029]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:26.029]                                 info, version)
[08:26:26.029]                             }
[08:26:26.029]                             base::stop(msg)
[08:26:26.029]                           }
[08:26:26.029]                         })
[08:26:26.029]                       }
[08:26:26.029]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:26.029]                       base::options(mc.cores = 1L)
[08:26:26.029]                     }
[08:26:26.029]                     base::local({
[08:26:26.029]                       for (pkg in "stats") {
[08:26:26.029]                         base::loadNamespace(pkg)
[08:26:26.029]                         base::library(pkg, character.only = TRUE)
[08:26:26.029]                       }
[08:26:26.029]                     })
[08:26:26.029]                   }
[08:26:26.029]                   ...future.strategy.old <- future::plan("list")
[08:26:26.029]                   options(future.plan = NULL)
[08:26:26.029]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:26.029]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:26.029]                 }
[08:26:26.029]                 ...future.workdir <- getwd()
[08:26:26.029]             }
[08:26:26.029]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:26.029]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:26.029]         }
[08:26:26.029]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:26.029]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:26.029]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:26.029]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:26.029]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:26.029]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:26.029]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:26.029]             base::names(...future.oldOptions))
[08:26:26.029]     }
[08:26:26.029]     if (FALSE) {
[08:26:26.029]     }
[08:26:26.029]     else {
[08:26:26.029]         if (TRUE) {
[08:26:26.029]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:26.029]                 open = "w")
[08:26:26.029]         }
[08:26:26.029]         else {
[08:26:26.029]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:26.029]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:26.029]         }
[08:26:26.029]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:26.029]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:26.029]             base::sink(type = "output", split = FALSE)
[08:26:26.029]             base::close(...future.stdout)
[08:26:26.029]         }, add = TRUE)
[08:26:26.029]     }
[08:26:26.029]     ...future.frame <- base::sys.nframe()
[08:26:26.029]     ...future.conditions <- base::list()
[08:26:26.029]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:26.029]     if (FALSE) {
[08:26:26.029]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:26.029]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:26.029]     }
[08:26:26.029]     ...future.result <- base::tryCatch({
[08:26:26.029]         base::withCallingHandlers({
[08:26:26.029]             ...future.value <- base::withVisible(base::local({
[08:26:26.029]                 ...future.makeSendCondition <- base::local({
[08:26:26.029]                   sendCondition <- NULL
[08:26:26.029]                   function(frame = 1L) {
[08:26:26.029]                     if (is.function(sendCondition)) 
[08:26:26.029]                       return(sendCondition)
[08:26:26.029]                     ns <- getNamespace("parallel")
[08:26:26.029]                     if (exists("sendData", mode = "function", 
[08:26:26.029]                       envir = ns)) {
[08:26:26.029]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:26.029]                         envir = ns)
[08:26:26.029]                       envir <- sys.frame(frame)
[08:26:26.029]                       master <- NULL
[08:26:26.029]                       while (!identical(envir, .GlobalEnv) && 
[08:26:26.029]                         !identical(envir, emptyenv())) {
[08:26:26.029]                         if (exists("master", mode = "list", envir = envir, 
[08:26:26.029]                           inherits = FALSE)) {
[08:26:26.029]                           master <- get("master", mode = "list", 
[08:26:26.029]                             envir = envir, inherits = FALSE)
[08:26:26.029]                           if (inherits(master, c("SOCKnode", 
[08:26:26.029]                             "SOCK0node"))) {
[08:26:26.029]                             sendCondition <<- function(cond) {
[08:26:26.029]                               data <- list(type = "VALUE", value = cond, 
[08:26:26.029]                                 success = TRUE)
[08:26:26.029]                               parallel_sendData(master, data)
[08:26:26.029]                             }
[08:26:26.029]                             return(sendCondition)
[08:26:26.029]                           }
[08:26:26.029]                         }
[08:26:26.029]                         frame <- frame + 1L
[08:26:26.029]                         envir <- sys.frame(frame)
[08:26:26.029]                       }
[08:26:26.029]                     }
[08:26:26.029]                     sendCondition <<- function(cond) NULL
[08:26:26.029]                   }
[08:26:26.029]                 })
[08:26:26.029]                 withCallingHandlers({
[08:26:26.029]                   {
[08:26:26.029]                     do.call(function(...) {
[08:26:26.029]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:26.029]                       if (!identical(...future.globals.maxSize.org, 
[08:26:26.029]                         ...future.globals.maxSize)) {
[08:26:26.029]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:26.029]                         on.exit(options(oopts), add = TRUE)
[08:26:26.029]                       }
[08:26:26.029]                       {
[08:26:26.029]                         lapply(seq_along(...future.elements_ii), 
[08:26:26.029]                           FUN = function(jj) {
[08:26:26.029]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:26.029]                             ...future.FUN(...future.X_jj, ...)
[08:26:26.029]                           })
[08:26:26.029]                       }
[08:26:26.029]                     }, args = future.call.arguments)
[08:26:26.029]                   }
[08:26:26.029]                 }, immediateCondition = function(cond) {
[08:26:26.029]                   sendCondition <- ...future.makeSendCondition()
[08:26:26.029]                   sendCondition(cond)
[08:26:26.029]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:26.029]                   {
[08:26:26.029]                     inherits <- base::inherits
[08:26:26.029]                     invokeRestart <- base::invokeRestart
[08:26:26.029]                     is.null <- base::is.null
[08:26:26.029]                     muffled <- FALSE
[08:26:26.029]                     if (inherits(cond, "message")) {
[08:26:26.029]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:26.029]                       if (muffled) 
[08:26:26.029]                         invokeRestart("muffleMessage")
[08:26:26.029]                     }
[08:26:26.029]                     else if (inherits(cond, "warning")) {
[08:26:26.029]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:26.029]                       if (muffled) 
[08:26:26.029]                         invokeRestart("muffleWarning")
[08:26:26.029]                     }
[08:26:26.029]                     else if (inherits(cond, "condition")) {
[08:26:26.029]                       if (!is.null(pattern)) {
[08:26:26.029]                         computeRestarts <- base::computeRestarts
[08:26:26.029]                         grepl <- base::grepl
[08:26:26.029]                         restarts <- computeRestarts(cond)
[08:26:26.029]                         for (restart in restarts) {
[08:26:26.029]                           name <- restart$name
[08:26:26.029]                           if (is.null(name)) 
[08:26:26.029]                             next
[08:26:26.029]                           if (!grepl(pattern, name)) 
[08:26:26.029]                             next
[08:26:26.029]                           invokeRestart(restart)
[08:26:26.029]                           muffled <- TRUE
[08:26:26.029]                           break
[08:26:26.029]                         }
[08:26:26.029]                       }
[08:26:26.029]                     }
[08:26:26.029]                     invisible(muffled)
[08:26:26.029]                   }
[08:26:26.029]                   muffleCondition(cond)
[08:26:26.029]                 })
[08:26:26.029]             }))
[08:26:26.029]             future::FutureResult(value = ...future.value$value, 
[08:26:26.029]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:26.029]                   ...future.rng), globalenv = if (FALSE) 
[08:26:26.029]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:26.029]                     ...future.globalenv.names))
[08:26:26.029]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:26.029]         }, condition = base::local({
[08:26:26.029]             c <- base::c
[08:26:26.029]             inherits <- base::inherits
[08:26:26.029]             invokeRestart <- base::invokeRestart
[08:26:26.029]             length <- base::length
[08:26:26.029]             list <- base::list
[08:26:26.029]             seq.int <- base::seq.int
[08:26:26.029]             signalCondition <- base::signalCondition
[08:26:26.029]             sys.calls <- base::sys.calls
[08:26:26.029]             `[[` <- base::`[[`
[08:26:26.029]             `+` <- base::`+`
[08:26:26.029]             `<<-` <- base::`<<-`
[08:26:26.029]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:26.029]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:26.029]                   3L)]
[08:26:26.029]             }
[08:26:26.029]             function(cond) {
[08:26:26.029]                 is_error <- inherits(cond, "error")
[08:26:26.029]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:26.029]                   NULL)
[08:26:26.029]                 if (is_error) {
[08:26:26.029]                   sessionInformation <- function() {
[08:26:26.029]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:26.029]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:26.029]                       search = base::search(), system = base::Sys.info())
[08:26:26.029]                   }
[08:26:26.029]                   ...future.conditions[[length(...future.conditions) + 
[08:26:26.029]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:26.029]                     cond$call), session = sessionInformation(), 
[08:26:26.029]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:26.029]                   signalCondition(cond)
[08:26:26.029]                 }
[08:26:26.029]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:26.029]                 "immediateCondition"))) {
[08:26:26.029]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:26.029]                   ...future.conditions[[length(...future.conditions) + 
[08:26:26.029]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:26.029]                   if (TRUE && !signal) {
[08:26:26.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:26.029]                     {
[08:26:26.029]                       inherits <- base::inherits
[08:26:26.029]                       invokeRestart <- base::invokeRestart
[08:26:26.029]                       is.null <- base::is.null
[08:26:26.029]                       muffled <- FALSE
[08:26:26.029]                       if (inherits(cond, "message")) {
[08:26:26.029]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:26.029]                         if (muffled) 
[08:26:26.029]                           invokeRestart("muffleMessage")
[08:26:26.029]                       }
[08:26:26.029]                       else if (inherits(cond, "warning")) {
[08:26:26.029]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:26.029]                         if (muffled) 
[08:26:26.029]                           invokeRestart("muffleWarning")
[08:26:26.029]                       }
[08:26:26.029]                       else if (inherits(cond, "condition")) {
[08:26:26.029]                         if (!is.null(pattern)) {
[08:26:26.029]                           computeRestarts <- base::computeRestarts
[08:26:26.029]                           grepl <- base::grepl
[08:26:26.029]                           restarts <- computeRestarts(cond)
[08:26:26.029]                           for (restart in restarts) {
[08:26:26.029]                             name <- restart$name
[08:26:26.029]                             if (is.null(name)) 
[08:26:26.029]                               next
[08:26:26.029]                             if (!grepl(pattern, name)) 
[08:26:26.029]                               next
[08:26:26.029]                             invokeRestart(restart)
[08:26:26.029]                             muffled <- TRUE
[08:26:26.029]                             break
[08:26:26.029]                           }
[08:26:26.029]                         }
[08:26:26.029]                       }
[08:26:26.029]                       invisible(muffled)
[08:26:26.029]                     }
[08:26:26.029]                     muffleCondition(cond, pattern = "^muffle")
[08:26:26.029]                   }
[08:26:26.029]                 }
[08:26:26.029]                 else {
[08:26:26.029]                   if (TRUE) {
[08:26:26.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:26.029]                     {
[08:26:26.029]                       inherits <- base::inherits
[08:26:26.029]                       invokeRestart <- base::invokeRestart
[08:26:26.029]                       is.null <- base::is.null
[08:26:26.029]                       muffled <- FALSE
[08:26:26.029]                       if (inherits(cond, "message")) {
[08:26:26.029]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:26.029]                         if (muffled) 
[08:26:26.029]                           invokeRestart("muffleMessage")
[08:26:26.029]                       }
[08:26:26.029]                       else if (inherits(cond, "warning")) {
[08:26:26.029]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:26.029]                         if (muffled) 
[08:26:26.029]                           invokeRestart("muffleWarning")
[08:26:26.029]                       }
[08:26:26.029]                       else if (inherits(cond, "condition")) {
[08:26:26.029]                         if (!is.null(pattern)) {
[08:26:26.029]                           computeRestarts <- base::computeRestarts
[08:26:26.029]                           grepl <- base::grepl
[08:26:26.029]                           restarts <- computeRestarts(cond)
[08:26:26.029]                           for (restart in restarts) {
[08:26:26.029]                             name <- restart$name
[08:26:26.029]                             if (is.null(name)) 
[08:26:26.029]                               next
[08:26:26.029]                             if (!grepl(pattern, name)) 
[08:26:26.029]                               next
[08:26:26.029]                             invokeRestart(restart)
[08:26:26.029]                             muffled <- TRUE
[08:26:26.029]                             break
[08:26:26.029]                           }
[08:26:26.029]                         }
[08:26:26.029]                       }
[08:26:26.029]                       invisible(muffled)
[08:26:26.029]                     }
[08:26:26.029]                     muffleCondition(cond, pattern = "^muffle")
[08:26:26.029]                   }
[08:26:26.029]                 }
[08:26:26.029]             }
[08:26:26.029]         }))
[08:26:26.029]     }, error = function(ex) {
[08:26:26.029]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:26.029]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:26.029]                 ...future.rng), started = ...future.startTime, 
[08:26:26.029]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:26.029]             version = "1.8"), class = "FutureResult")
[08:26:26.029]     }, finally = {
[08:26:26.029]         if (!identical(...future.workdir, getwd())) 
[08:26:26.029]             setwd(...future.workdir)
[08:26:26.029]         {
[08:26:26.029]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:26.029]                 ...future.oldOptions$nwarnings <- NULL
[08:26:26.029]             }
[08:26:26.029]             base::options(...future.oldOptions)
[08:26:26.029]             if (.Platform$OS.type == "windows") {
[08:26:26.029]                 old_names <- names(...future.oldEnvVars)
[08:26:26.029]                 envs <- base::Sys.getenv()
[08:26:26.029]                 names <- names(envs)
[08:26:26.029]                 common <- intersect(names, old_names)
[08:26:26.029]                 added <- setdiff(names, old_names)
[08:26:26.029]                 removed <- setdiff(old_names, names)
[08:26:26.029]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:26.029]                   envs[common]]
[08:26:26.029]                 NAMES <- toupper(changed)
[08:26:26.029]                 args <- list()
[08:26:26.029]                 for (kk in seq_along(NAMES)) {
[08:26:26.029]                   name <- changed[[kk]]
[08:26:26.029]                   NAME <- NAMES[[kk]]
[08:26:26.029]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:26.029]                     next
[08:26:26.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:26.029]                 }
[08:26:26.029]                 NAMES <- toupper(added)
[08:26:26.029]                 for (kk in seq_along(NAMES)) {
[08:26:26.029]                   name <- added[[kk]]
[08:26:26.029]                   NAME <- NAMES[[kk]]
[08:26:26.029]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:26.029]                     next
[08:26:26.029]                   args[[name]] <- ""
[08:26:26.029]                 }
[08:26:26.029]                 NAMES <- toupper(removed)
[08:26:26.029]                 for (kk in seq_along(NAMES)) {
[08:26:26.029]                   name <- removed[[kk]]
[08:26:26.029]                   NAME <- NAMES[[kk]]
[08:26:26.029]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:26.029]                     next
[08:26:26.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:26.029]                 }
[08:26:26.029]                 if (length(args) > 0) 
[08:26:26.029]                   base::do.call(base::Sys.setenv, args = args)
[08:26:26.029]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:26.029]             }
[08:26:26.029]             else {
[08:26:26.029]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:26.029]             }
[08:26:26.029]             {
[08:26:26.029]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:26.029]                   0L) {
[08:26:26.029]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:26.029]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:26.029]                   base::options(opts)
[08:26:26.029]                 }
[08:26:26.029]                 {
[08:26:26.029]                   {
[08:26:26.029]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:26.029]                     NULL
[08:26:26.029]                   }
[08:26:26.029]                   options(future.plan = NULL)
[08:26:26.029]                   if (is.na(NA_character_)) 
[08:26:26.029]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:26.029]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:26.029]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:26.029]                     .init = FALSE)
[08:26:26.029]                 }
[08:26:26.029]             }
[08:26:26.029]         }
[08:26:26.029]     })
[08:26:26.029]     if (TRUE) {
[08:26:26.029]         base::sink(type = "output", split = FALSE)
[08:26:26.029]         if (TRUE) {
[08:26:26.029]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:26.029]         }
[08:26:26.029]         else {
[08:26:26.029]             ...future.result["stdout"] <- base::list(NULL)
[08:26:26.029]         }
[08:26:26.029]         base::close(...future.stdout)
[08:26:26.029]         ...future.stdout <- NULL
[08:26:26.029]     }
[08:26:26.029]     ...future.result$conditions <- ...future.conditions
[08:26:26.029]     ...future.result$finished <- base::Sys.time()
[08:26:26.029]     ...future.result
[08:26:26.029] }
[08:26:26.032] Exporting 5 global objects (5.62 KiB) to cluster node #1 ...
[08:26:26.032] Exporting ‘...future.FUN’ (4.67 KiB) to cluster node #1 ...
[08:26:26.073] Exporting ‘...future.FUN’ (4.67 KiB) to cluster node #1 ... DONE
[08:26:26.073] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:26:26.073] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:26:26.074] Exporting ‘...future.elements_ii’ (369 bytes) to cluster node #1 ...
[08:26:26.074] Exporting ‘...future.elements_ii’ (369 bytes) to cluster node #1 ... DONE
[08:26:26.074] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:26:26.074] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:26:26.075] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:26:26.075] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:26:26.075] Exporting 5 global objects (5.62 KiB) to cluster node #1 ... DONE
[08:26:26.076] MultisessionFuture started
[08:26:26.076] - Launch lazy future ... done
[08:26:26.076] run() for ‘MultisessionFuture’ ... done
[08:26:26.076] Created future:
[08:26:26.076] MultisessionFuture:
[08:26:26.076] Label: ‘future_sapply-1’
[08:26:26.076] Expression:
[08:26:26.076] {
[08:26:26.076]     do.call(function(...) {
[08:26:26.076]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:26.076]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:26.076]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:26.076]             on.exit(options(oopts), add = TRUE)
[08:26:26.076]         }
[08:26:26.076]         {
[08:26:26.076]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:26.076]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:26.076]                 ...future.FUN(...future.X_jj, ...)
[08:26:26.076]             })
[08:26:26.076]         }
[08:26:26.076]     }, args = future.call.arguments)
[08:26:26.076] }
[08:26:26.076] Lazy evaluation: FALSE
[08:26:26.076] Asynchronous evaluation: TRUE
[08:26:26.076] Local evaluation: TRUE
[08:26:26.076] Environment: R_GlobalEnv
[08:26:26.076] Capture standard output: TRUE
[08:26:26.076] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:26.076] Globals: 5 objects totaling 5.17 KiB (function ‘...future.FUN’ of 4.67 KiB, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 369 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:26.076] Packages: 1 packages (‘stats’)
[08:26:26.076] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:26.076] Resolved: FALSE
[08:26:26.076] Value: <not collected>
[08:26:26.076] Conditions captured: <none>
[08:26:26.076] Early signaling: FALSE
[08:26:26.076] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:26.076] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:26.088] Chunk #1 of 2 ... DONE
[08:26:26.088] Chunk #2 of 2 ...
[08:26:26.088]  - Finding globals in 'X' for chunk #2 ...
[08:26:26.088] getGlobalsAndPackages() ...
[08:26:26.088] Searching for globals...
[08:26:26.088] 
[08:26:26.089] Searching for globals ... DONE
[08:26:26.089] - globals: [0] <none>
[08:26:26.089] getGlobalsAndPackages() ... DONE
[08:26:26.089]    + additional globals found: [n=0] 
[08:26:26.089]    + additional namespaces needed: [n=0] 
[08:26:26.089]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:26.089]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:26.089]  - seeds: <none>
[08:26:26.089]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.089] getGlobalsAndPackages() ...
[08:26:26.089] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.090] Resolving globals: FALSE
[08:26:26.090] Tweak future expression to call with '...' arguments ...
[08:26:26.090] {
[08:26:26.090]     do.call(function(...) {
[08:26:26.090]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:26.090]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:26.090]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:26.090]             on.exit(options(oopts), add = TRUE)
[08:26:26.090]         }
[08:26:26.090]         {
[08:26:26.090]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:26.090]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:26.090]                 ...future.FUN(...future.X_jj, ...)
[08:26:26.090]             })
[08:26:26.090]         }
[08:26:26.090]     }, args = future.call.arguments)
[08:26:26.090] }
[08:26:26.090] Tweak future expression to call with '...' arguments ... DONE
[08:26:26.090] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.091] - packages: [1] ‘stats’
[08:26:26.091] getGlobalsAndPackages() ... DONE
[08:26:26.091] run() for ‘Future’ ...
[08:26:26.091] - state: ‘created’
[08:26:26.091] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:26.105] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:26.106] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:26.106]   - Field: ‘node’
[08:26:26.106]   - Field: ‘label’
[08:26:26.106]   - Field: ‘local’
[08:26:26.106]   - Field: ‘owner’
[08:26:26.106]   - Field: ‘envir’
[08:26:26.106]   - Field: ‘workers’
[08:26:26.106]   - Field: ‘packages’
[08:26:26.106]   - Field: ‘gc’
[08:26:26.106]   - Field: ‘conditions’
[08:26:26.107]   - Field: ‘persistent’
[08:26:26.107]   - Field: ‘expr’
[08:26:26.107]   - Field: ‘uuid’
[08:26:26.107]   - Field: ‘seed’
[08:26:26.107]   - Field: ‘version’
[08:26:26.107]   - Field: ‘result’
[08:26:26.107]   - Field: ‘asynchronous’
[08:26:26.107]   - Field: ‘calls’
[08:26:26.107]   - Field: ‘globals’
[08:26:26.107]   - Field: ‘stdout’
[08:26:26.107]   - Field: ‘earlySignal’
[08:26:26.108]   - Field: ‘lazy’
[08:26:26.108]   - Field: ‘state’
[08:26:26.108] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:26.108] - Launch lazy future ...
[08:26:26.108] Packages needed by the future expression (n = 1): ‘stats’
[08:26:26.108] Packages needed by future strategies (n = 0): <none>
[08:26:26.109] {
[08:26:26.109]     {
[08:26:26.109]         {
[08:26:26.109]             ...future.startTime <- base::Sys.time()
[08:26:26.109]             {
[08:26:26.109]                 {
[08:26:26.109]                   {
[08:26:26.109]                     {
[08:26:26.109]                       {
[08:26:26.109]                         base::local({
[08:26:26.109]                           has_future <- base::requireNamespace("future", 
[08:26:26.109]                             quietly = TRUE)
[08:26:26.109]                           if (has_future) {
[08:26:26.109]                             ns <- base::getNamespace("future")
[08:26:26.109]                             version <- ns[[".package"]][["version"]]
[08:26:26.109]                             if (is.null(version)) 
[08:26:26.109]                               version <- utils::packageVersion("future")
[08:26:26.109]                           }
[08:26:26.109]                           else {
[08:26:26.109]                             version <- NULL
[08:26:26.109]                           }
[08:26:26.109]                           if (!has_future || version < "1.8.0") {
[08:26:26.109]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:26.109]                               "", base::R.version$version.string), 
[08:26:26.109]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:26.109]                                 base::R.version$platform, 8 * 
[08:26:26.109]                                   base::.Machine$sizeof.pointer), 
[08:26:26.109]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:26.109]                                 "release", "version")], collapse = " "), 
[08:26:26.109]                               hostname = base::Sys.info()[["nodename"]])
[08:26:26.109]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:26.109]                               info)
[08:26:26.109]                             info <- base::paste(info, collapse = "; ")
[08:26:26.109]                             if (!has_future) {
[08:26:26.109]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:26.109]                                 info)
[08:26:26.109]                             }
[08:26:26.109]                             else {
[08:26:26.109]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:26.109]                                 info, version)
[08:26:26.109]                             }
[08:26:26.109]                             base::stop(msg)
[08:26:26.109]                           }
[08:26:26.109]                         })
[08:26:26.109]                       }
[08:26:26.109]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:26.109]                       base::options(mc.cores = 1L)
[08:26:26.109]                     }
[08:26:26.109]                     base::local({
[08:26:26.109]                       for (pkg in "stats") {
[08:26:26.109]                         base::loadNamespace(pkg)
[08:26:26.109]                         base::library(pkg, character.only = TRUE)
[08:26:26.109]                       }
[08:26:26.109]                     })
[08:26:26.109]                   }
[08:26:26.109]                   ...future.strategy.old <- future::plan("list")
[08:26:26.109]                   options(future.plan = NULL)
[08:26:26.109]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:26.109]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:26.109]                 }
[08:26:26.109]                 ...future.workdir <- getwd()
[08:26:26.109]             }
[08:26:26.109]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:26.109]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:26.109]         }
[08:26:26.109]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:26.109]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:26.109]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:26.109]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:26.109]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:26.109]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:26.109]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:26.109]             base::names(...future.oldOptions))
[08:26:26.109]     }
[08:26:26.109]     if (FALSE) {
[08:26:26.109]     }
[08:26:26.109]     else {
[08:26:26.109]         if (TRUE) {
[08:26:26.109]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:26.109]                 open = "w")
[08:26:26.109]         }
[08:26:26.109]         else {
[08:26:26.109]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:26.109]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:26.109]         }
[08:26:26.109]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:26.109]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:26.109]             base::sink(type = "output", split = FALSE)
[08:26:26.109]             base::close(...future.stdout)
[08:26:26.109]         }, add = TRUE)
[08:26:26.109]     }
[08:26:26.109]     ...future.frame <- base::sys.nframe()
[08:26:26.109]     ...future.conditions <- base::list()
[08:26:26.109]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:26.109]     if (FALSE) {
[08:26:26.109]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:26.109]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:26.109]     }
[08:26:26.109]     ...future.result <- base::tryCatch({
[08:26:26.109]         base::withCallingHandlers({
[08:26:26.109]             ...future.value <- base::withVisible(base::local({
[08:26:26.109]                 ...future.makeSendCondition <- base::local({
[08:26:26.109]                   sendCondition <- NULL
[08:26:26.109]                   function(frame = 1L) {
[08:26:26.109]                     if (is.function(sendCondition)) 
[08:26:26.109]                       return(sendCondition)
[08:26:26.109]                     ns <- getNamespace("parallel")
[08:26:26.109]                     if (exists("sendData", mode = "function", 
[08:26:26.109]                       envir = ns)) {
[08:26:26.109]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:26.109]                         envir = ns)
[08:26:26.109]                       envir <- sys.frame(frame)
[08:26:26.109]                       master <- NULL
[08:26:26.109]                       while (!identical(envir, .GlobalEnv) && 
[08:26:26.109]                         !identical(envir, emptyenv())) {
[08:26:26.109]                         if (exists("master", mode = "list", envir = envir, 
[08:26:26.109]                           inherits = FALSE)) {
[08:26:26.109]                           master <- get("master", mode = "list", 
[08:26:26.109]                             envir = envir, inherits = FALSE)
[08:26:26.109]                           if (inherits(master, c("SOCKnode", 
[08:26:26.109]                             "SOCK0node"))) {
[08:26:26.109]                             sendCondition <<- function(cond) {
[08:26:26.109]                               data <- list(type = "VALUE", value = cond, 
[08:26:26.109]                                 success = TRUE)
[08:26:26.109]                               parallel_sendData(master, data)
[08:26:26.109]                             }
[08:26:26.109]                             return(sendCondition)
[08:26:26.109]                           }
[08:26:26.109]                         }
[08:26:26.109]                         frame <- frame + 1L
[08:26:26.109]                         envir <- sys.frame(frame)
[08:26:26.109]                       }
[08:26:26.109]                     }
[08:26:26.109]                     sendCondition <<- function(cond) NULL
[08:26:26.109]                   }
[08:26:26.109]                 })
[08:26:26.109]                 withCallingHandlers({
[08:26:26.109]                   {
[08:26:26.109]                     do.call(function(...) {
[08:26:26.109]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:26.109]                       if (!identical(...future.globals.maxSize.org, 
[08:26:26.109]                         ...future.globals.maxSize)) {
[08:26:26.109]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:26.109]                         on.exit(options(oopts), add = TRUE)
[08:26:26.109]                       }
[08:26:26.109]                       {
[08:26:26.109]                         lapply(seq_along(...future.elements_ii), 
[08:26:26.109]                           FUN = function(jj) {
[08:26:26.109]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:26.109]                             ...future.FUN(...future.X_jj, ...)
[08:26:26.109]                           })
[08:26:26.109]                       }
[08:26:26.109]                     }, args = future.call.arguments)
[08:26:26.109]                   }
[08:26:26.109]                 }, immediateCondition = function(cond) {
[08:26:26.109]                   sendCondition <- ...future.makeSendCondition()
[08:26:26.109]                   sendCondition(cond)
[08:26:26.109]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:26.109]                   {
[08:26:26.109]                     inherits <- base::inherits
[08:26:26.109]                     invokeRestart <- base::invokeRestart
[08:26:26.109]                     is.null <- base::is.null
[08:26:26.109]                     muffled <- FALSE
[08:26:26.109]                     if (inherits(cond, "message")) {
[08:26:26.109]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:26.109]                       if (muffled) 
[08:26:26.109]                         invokeRestart("muffleMessage")
[08:26:26.109]                     }
[08:26:26.109]                     else if (inherits(cond, "warning")) {
[08:26:26.109]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:26.109]                       if (muffled) 
[08:26:26.109]                         invokeRestart("muffleWarning")
[08:26:26.109]                     }
[08:26:26.109]                     else if (inherits(cond, "condition")) {
[08:26:26.109]                       if (!is.null(pattern)) {
[08:26:26.109]                         computeRestarts <- base::computeRestarts
[08:26:26.109]                         grepl <- base::grepl
[08:26:26.109]                         restarts <- computeRestarts(cond)
[08:26:26.109]                         for (restart in restarts) {
[08:26:26.109]                           name <- restart$name
[08:26:26.109]                           if (is.null(name)) 
[08:26:26.109]                             next
[08:26:26.109]                           if (!grepl(pattern, name)) 
[08:26:26.109]                             next
[08:26:26.109]                           invokeRestart(restart)
[08:26:26.109]                           muffled <- TRUE
[08:26:26.109]                           break
[08:26:26.109]                         }
[08:26:26.109]                       }
[08:26:26.109]                     }
[08:26:26.109]                     invisible(muffled)
[08:26:26.109]                   }
[08:26:26.109]                   muffleCondition(cond)
[08:26:26.109]                 })
[08:26:26.109]             }))
[08:26:26.109]             future::FutureResult(value = ...future.value$value, 
[08:26:26.109]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:26.109]                   ...future.rng), globalenv = if (FALSE) 
[08:26:26.109]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:26.109]                     ...future.globalenv.names))
[08:26:26.109]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:26.109]         }, condition = base::local({
[08:26:26.109]             c <- base::c
[08:26:26.109]             inherits <- base::inherits
[08:26:26.109]             invokeRestart <- base::invokeRestart
[08:26:26.109]             length <- base::length
[08:26:26.109]             list <- base::list
[08:26:26.109]             seq.int <- base::seq.int
[08:26:26.109]             signalCondition <- base::signalCondition
[08:26:26.109]             sys.calls <- base::sys.calls
[08:26:26.109]             `[[` <- base::`[[`
[08:26:26.109]             `+` <- base::`+`
[08:26:26.109]             `<<-` <- base::`<<-`
[08:26:26.109]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:26.109]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:26.109]                   3L)]
[08:26:26.109]             }
[08:26:26.109]             function(cond) {
[08:26:26.109]                 is_error <- inherits(cond, "error")
[08:26:26.109]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:26.109]                   NULL)
[08:26:26.109]                 if (is_error) {
[08:26:26.109]                   sessionInformation <- function() {
[08:26:26.109]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:26.109]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:26.109]                       search = base::search(), system = base::Sys.info())
[08:26:26.109]                   }
[08:26:26.109]                   ...future.conditions[[length(...future.conditions) + 
[08:26:26.109]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:26.109]                     cond$call), session = sessionInformation(), 
[08:26:26.109]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:26.109]                   signalCondition(cond)
[08:26:26.109]                 }
[08:26:26.109]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:26.109]                 "immediateCondition"))) {
[08:26:26.109]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:26.109]                   ...future.conditions[[length(...future.conditions) + 
[08:26:26.109]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:26.109]                   if (TRUE && !signal) {
[08:26:26.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:26.109]                     {
[08:26:26.109]                       inherits <- base::inherits
[08:26:26.109]                       invokeRestart <- base::invokeRestart
[08:26:26.109]                       is.null <- base::is.null
[08:26:26.109]                       muffled <- FALSE
[08:26:26.109]                       if (inherits(cond, "message")) {
[08:26:26.109]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:26.109]                         if (muffled) 
[08:26:26.109]                           invokeRestart("muffleMessage")
[08:26:26.109]                       }
[08:26:26.109]                       else if (inherits(cond, "warning")) {
[08:26:26.109]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:26.109]                         if (muffled) 
[08:26:26.109]                           invokeRestart("muffleWarning")
[08:26:26.109]                       }
[08:26:26.109]                       else if (inherits(cond, "condition")) {
[08:26:26.109]                         if (!is.null(pattern)) {
[08:26:26.109]                           computeRestarts <- base::computeRestarts
[08:26:26.109]                           grepl <- base::grepl
[08:26:26.109]                           restarts <- computeRestarts(cond)
[08:26:26.109]                           for (restart in restarts) {
[08:26:26.109]                             name <- restart$name
[08:26:26.109]                             if (is.null(name)) 
[08:26:26.109]                               next
[08:26:26.109]                             if (!grepl(pattern, name)) 
[08:26:26.109]                               next
[08:26:26.109]                             invokeRestart(restart)
[08:26:26.109]                             muffled <- TRUE
[08:26:26.109]                             break
[08:26:26.109]                           }
[08:26:26.109]                         }
[08:26:26.109]                       }
[08:26:26.109]                       invisible(muffled)
[08:26:26.109]                     }
[08:26:26.109]                     muffleCondition(cond, pattern = "^muffle")
[08:26:26.109]                   }
[08:26:26.109]                 }
[08:26:26.109]                 else {
[08:26:26.109]                   if (TRUE) {
[08:26:26.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:26.109]                     {
[08:26:26.109]                       inherits <- base::inherits
[08:26:26.109]                       invokeRestart <- base::invokeRestart
[08:26:26.109]                       is.null <- base::is.null
[08:26:26.109]                       muffled <- FALSE
[08:26:26.109]                       if (inherits(cond, "message")) {
[08:26:26.109]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:26.109]                         if (muffled) 
[08:26:26.109]                           invokeRestart("muffleMessage")
[08:26:26.109]                       }
[08:26:26.109]                       else if (inherits(cond, "warning")) {
[08:26:26.109]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:26.109]                         if (muffled) 
[08:26:26.109]                           invokeRestart("muffleWarning")
[08:26:26.109]                       }
[08:26:26.109]                       else if (inherits(cond, "condition")) {
[08:26:26.109]                         if (!is.null(pattern)) {
[08:26:26.109]                           computeRestarts <- base::computeRestarts
[08:26:26.109]                           grepl <- base::grepl
[08:26:26.109]                           restarts <- computeRestarts(cond)
[08:26:26.109]                           for (restart in restarts) {
[08:26:26.109]                             name <- restart$name
[08:26:26.109]                             if (is.null(name)) 
[08:26:26.109]                               next
[08:26:26.109]                             if (!grepl(pattern, name)) 
[08:26:26.109]                               next
[08:26:26.109]                             invokeRestart(restart)
[08:26:26.109]                             muffled <- TRUE
[08:26:26.109]                             break
[08:26:26.109]                           }
[08:26:26.109]                         }
[08:26:26.109]                       }
[08:26:26.109]                       invisible(muffled)
[08:26:26.109]                     }
[08:26:26.109]                     muffleCondition(cond, pattern = "^muffle")
[08:26:26.109]                   }
[08:26:26.109]                 }
[08:26:26.109]             }
[08:26:26.109]         }))
[08:26:26.109]     }, error = function(ex) {
[08:26:26.109]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:26.109]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:26.109]                 ...future.rng), started = ...future.startTime, 
[08:26:26.109]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:26.109]             version = "1.8"), class = "FutureResult")
[08:26:26.109]     }, finally = {
[08:26:26.109]         if (!identical(...future.workdir, getwd())) 
[08:26:26.109]             setwd(...future.workdir)
[08:26:26.109]         {
[08:26:26.109]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:26.109]                 ...future.oldOptions$nwarnings <- NULL
[08:26:26.109]             }
[08:26:26.109]             base::options(...future.oldOptions)
[08:26:26.109]             if (.Platform$OS.type == "windows") {
[08:26:26.109]                 old_names <- names(...future.oldEnvVars)
[08:26:26.109]                 envs <- base::Sys.getenv()
[08:26:26.109]                 names <- names(envs)
[08:26:26.109]                 common <- intersect(names, old_names)
[08:26:26.109]                 added <- setdiff(names, old_names)
[08:26:26.109]                 removed <- setdiff(old_names, names)
[08:26:26.109]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:26.109]                   envs[common]]
[08:26:26.109]                 NAMES <- toupper(changed)
[08:26:26.109]                 args <- list()
[08:26:26.109]                 for (kk in seq_along(NAMES)) {
[08:26:26.109]                   name <- changed[[kk]]
[08:26:26.109]                   NAME <- NAMES[[kk]]
[08:26:26.109]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:26.109]                     next
[08:26:26.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:26.109]                 }
[08:26:26.109]                 NAMES <- toupper(added)
[08:26:26.109]                 for (kk in seq_along(NAMES)) {
[08:26:26.109]                   name <- added[[kk]]
[08:26:26.109]                   NAME <- NAMES[[kk]]
[08:26:26.109]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:26.109]                     next
[08:26:26.109]                   args[[name]] <- ""
[08:26:26.109]                 }
[08:26:26.109]                 NAMES <- toupper(removed)
[08:26:26.109]                 for (kk in seq_along(NAMES)) {
[08:26:26.109]                   name <- removed[[kk]]
[08:26:26.109]                   NAME <- NAMES[[kk]]
[08:26:26.109]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:26.109]                     next
[08:26:26.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:26.109]                 }
[08:26:26.109]                 if (length(args) > 0) 
[08:26:26.109]                   base::do.call(base::Sys.setenv, args = args)
[08:26:26.109]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:26.109]             }
[08:26:26.109]             else {
[08:26:26.109]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:26.109]             }
[08:26:26.109]             {
[08:26:26.109]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:26.109]                   0L) {
[08:26:26.109]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:26.109]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:26.109]                   base::options(opts)
[08:26:26.109]                 }
[08:26:26.109]                 {
[08:26:26.109]                   {
[08:26:26.109]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:26.109]                     NULL
[08:26:26.109]                   }
[08:26:26.109]                   options(future.plan = NULL)
[08:26:26.109]                   if (is.na(NA_character_)) 
[08:26:26.109]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:26.109]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:26.109]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:26.109]                     .init = FALSE)
[08:26:26.109]                 }
[08:26:26.109]             }
[08:26:26.109]         }
[08:26:26.109]     })
[08:26:26.109]     if (TRUE) {
[08:26:26.109]         base::sink(type = "output", split = FALSE)
[08:26:26.109]         if (TRUE) {
[08:26:26.109]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:26.109]         }
[08:26:26.109]         else {
[08:26:26.109]             ...future.result["stdout"] <- base::list(NULL)
[08:26:26.109]         }
[08:26:26.109]         base::close(...future.stdout)
[08:26:26.109]         ...future.stdout <- NULL
[08:26:26.109]     }
[08:26:26.109]     ...future.result$conditions <- ...future.conditions
[08:26:26.109]     ...future.result$finished <- base::Sys.time()
[08:26:26.109]     ...future.result
[08:26:26.109] }
[08:26:26.112] Exporting 5 global objects (5.55 KiB) to cluster node #2 ...
[08:26:26.112] Exporting ‘...future.FUN’ (4.67 KiB) to cluster node #2 ...
[08:26:26.153] Exporting ‘...future.FUN’ (4.67 KiB) to cluster node #2 ... DONE
[08:26:26.153] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:26:26.153] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:26:26.154] Exporting ‘...future.elements_ii’ (293 bytes) to cluster node #2 ...
[08:26:26.154] Exporting ‘...future.elements_ii’ (293 bytes) to cluster node #2 ... DONE
[08:26:26.154] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:26:26.154] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:26:26.155] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:26:26.155] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:26:26.155] Exporting 5 global objects (5.55 KiB) to cluster node #2 ... DONE
[08:26:26.156] MultisessionFuture started
[08:26:26.156] - Launch lazy future ... done
[08:26:26.156] run() for ‘MultisessionFuture’ ... done
[08:26:26.156] Created future:
[08:26:26.156] MultisessionFuture:
[08:26:26.156] Label: ‘future_sapply-2’
[08:26:26.156] Expression:
[08:26:26.156] {
[08:26:26.156]     do.call(function(...) {
[08:26:26.156]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:26.156]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:26.156]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:26.156]             on.exit(options(oopts), add = TRUE)
[08:26:26.156]         }
[08:26:26.156]         {
[08:26:26.156]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:26.156]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:26.156]                 ...future.FUN(...future.X_jj, ...)
[08:26:26.156]             })
[08:26:26.156]         }
[08:26:26.156]     }, args = future.call.arguments)
[08:26:26.156] }
[08:26:26.156] Lazy evaluation: FALSE
[08:26:26.156] Asynchronous evaluation: TRUE
[08:26:26.156] Local evaluation: TRUE
[08:26:26.156] Environment: R_GlobalEnv
[08:26:26.156] Capture standard output: TRUE
[08:26:26.156] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:26.156] Globals: 5 objects totaling 5.10 KiB (function ‘...future.FUN’ of 4.67 KiB, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 293 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:26.156] Packages: 1 packages (‘stats’)
[08:26:26.156] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:26.156] Resolved: FALSE
[08:26:26.156] Value: <not collected>
[08:26:26.156] Conditions captured: <none>
[08:26:26.156] Early signaling: FALSE
[08:26:26.156] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:26.156] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:26.168] Chunk #2 of 2 ... DONE
[08:26:26.168] Launching 2 futures (chunks) ... DONE
[08:26:26.168] Resolving 2 futures (chunks) ...
[08:26:26.168] resolve() on list ...
[08:26:26.168]  recursive: 0
[08:26:26.168]  length: 2
[08:26:26.169] 
[08:26:26.169] receiveMessageFromWorker() for ClusterFuture ...
[08:26:26.169] - Validating connection of MultisessionFuture
[08:26:26.169] - received message: FutureResult
[08:26:26.170] - Received FutureResult
[08:26:26.170] - Erased future from FutureRegistry
[08:26:26.170] result() for ClusterFuture ...
[08:26:26.170] - result already collected: FutureResult
[08:26:26.170] result() for ClusterFuture ... done
[08:26:26.170] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:26.170] Future #1
[08:26:26.170] result() for ClusterFuture ...
[08:26:26.170] - result already collected: FutureResult
[08:26:26.170] result() for ClusterFuture ... done
[08:26:26.170] result() for ClusterFuture ...
[08:26:26.170] - result already collected: FutureResult
[08:26:26.171] result() for ClusterFuture ... done
[08:26:26.171] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:26:26.171] - nx: 2
[08:26:26.171] - relay: TRUE
[08:26:26.171] - stdout: TRUE
[08:26:26.171] - signal: TRUE
[08:26:26.171] - resignal: FALSE
[08:26:26.171] - force: TRUE
[08:26:26.171] - relayed: [n=2] FALSE, FALSE
[08:26:26.171] - queued futures: [n=2] FALSE, FALSE
[08:26:26.171]  - until=1
[08:26:26.172]  - relaying element #1
[08:26:26.172] result() for ClusterFuture ...
[08:26:26.172] - result already collected: FutureResult
[08:26:26.172] result() for ClusterFuture ... done
[08:26:26.172] result() for ClusterFuture ...
[08:26:26.172] - result already collected: FutureResult
[08:26:26.172] result() for ClusterFuture ... done
[08:26:26.172] result() for ClusterFuture ...
[08:26:26.172] - result already collected: FutureResult
[08:26:26.172] result() for ClusterFuture ... done
[08:26:26.172] result() for ClusterFuture ...
[08:26:26.172] - result already collected: FutureResult
[08:26:26.173] result() for ClusterFuture ... done
[08:26:26.173] - relayed: [n=2] TRUE, FALSE
[08:26:26.173] - queued futures: [n=2] TRUE, FALSE
[08:26:26.173] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:26:26.173]  length: 1 (resolved future 1)
[08:26:26.198] receiveMessageFromWorker() for ClusterFuture ...
[08:26:26.199] - Validating connection of MultisessionFuture
[08:26:26.199] - received message: FutureResult
[08:26:26.199] - Received FutureResult
[08:26:26.199] - Erased future from FutureRegistry
[08:26:26.199] result() for ClusterFuture ...
[08:26:26.199] - result already collected: FutureResult
[08:26:26.199] result() for ClusterFuture ... done
[08:26:26.199] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:26.199] Future #2
[08:26:26.200] result() for ClusterFuture ...
[08:26:26.200] - result already collected: FutureResult
[08:26:26.200] result() for ClusterFuture ... done
[08:26:26.200] result() for ClusterFuture ...
[08:26:26.200] - result already collected: FutureResult
[08:26:26.200] result() for ClusterFuture ... done
[08:26:26.200] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:26:26.200] - nx: 2
[08:26:26.200] - relay: TRUE
[08:26:26.200] - stdout: TRUE
[08:26:26.200] - signal: TRUE
[08:26:26.200] - resignal: FALSE
[08:26:26.201] - force: TRUE
[08:26:26.201] - relayed: [n=2] TRUE, FALSE
[08:26:26.201] - queued futures: [n=2] TRUE, FALSE
[08:26:26.201]  - until=2
[08:26:26.201]  - relaying element #2
[08:26:26.201] result() for ClusterFuture ...
[08:26:26.201] - result already collected: FutureResult
[08:26:26.201] result() for ClusterFuture ... done
[08:26:26.201] result() for ClusterFuture ...
[08:26:26.201] - result already collected: FutureResult
[08:26:26.201] result() for ClusterFuture ... done
[08:26:26.202] result() for ClusterFuture ...
[08:26:26.202] - result already collected: FutureResult
[08:26:26.202] result() for ClusterFuture ... done
[08:26:26.202] result() for ClusterFuture ...
[08:26:26.202] - result already collected: FutureResult
[08:26:26.202] result() for ClusterFuture ... done
[08:26:26.202] - relayed: [n=2] TRUE, TRUE
[08:26:26.202] - queued futures: [n=2] TRUE, TRUE
[08:26:26.202] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:26:26.202]  length: 0 (resolved future 2)
[08:26:26.202] Relaying remaining futures
[08:26:26.202] signalConditionsASAP(NULL, pos=0) ...
[08:26:26.203] - nx: 2
[08:26:26.203] - relay: TRUE
[08:26:26.203] - stdout: TRUE
[08:26:26.203] - signal: TRUE
[08:26:26.203] - resignal: FALSE
[08:26:26.203] - force: TRUE
[08:26:26.203] - relayed: [n=2] TRUE, TRUE
[08:26:26.203] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:26.203] - relayed: [n=2] TRUE, TRUE
[08:26:26.203] - queued futures: [n=2] TRUE, TRUE
[08:26:26.203] signalConditionsASAP(NULL, pos=0) ... done
[08:26:26.203] resolve() on list ... DONE
[08:26:26.204] result() for ClusterFuture ...
[08:26:26.204] - result already collected: FutureResult
[08:26:26.204] result() for ClusterFuture ... done
[08:26:26.204] result() for ClusterFuture ...
[08:26:26.204] - result already collected: FutureResult
[08:26:26.204] result() for ClusterFuture ... done
[08:26:26.204] result() for ClusterFuture ...
[08:26:26.204] - result already collected: FutureResult
[08:26:26.204] result() for ClusterFuture ... done
[08:26:26.204] result() for ClusterFuture ...
[08:26:26.204] - result already collected: FutureResult
[08:26:26.204] result() for ClusterFuture ... done
[08:26:26.205]  - Number of value chunks collected: 2
[08:26:26.205] Resolving 2 futures (chunks) ... DONE
[08:26:26.205] Reducing values from 2 chunks ...
[08:26:26.205]  - Number of values collected after concatenation: 7
[08:26:26.205]  - Number of values expected: 7
[08:26:26.205] Reducing values from 2 chunks ... DONE
[08:26:26.205] future_lapply() ... DONE
[08:26:26.206] future_lapply() ...
[08:26:26.209] Number of chunks: 2
[08:26:26.209] getGlobalsAndPackagesXApply() ...
[08:26:26.209]  - future.globals: TRUE
[08:26:26.209] getGlobalsAndPackages() ...
[08:26:26.209] Searching for globals...
[08:26:26.216] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[08:26:26.217] Searching for globals ... DONE
[08:26:26.217] Resolving globals: FALSE
[08:26:26.218] The total size of the 7 globals is 26.71 KiB (27354 bytes)
[08:26:26.218] The total size of the 7 globals exported for future expression (‘FUN()’) is 26.71 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (14.07 KiB of class ‘function’), ‘x_FUN’ (4.67 KiB of class ‘function’) and ‘stop_if_not’ (4.51 KiB of class ‘function’)
[08:26:26.218] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:26.219] - packages: [2] ‘stats’, ‘future.apply’
[08:26:26.219] getGlobalsAndPackages() ... DONE
[08:26:26.219]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:26.219]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[08:26:26.219] Finding globals ... DONE
[08:26:26.219]  - use_args: TRUE
[08:26:26.219]  - Getting '...' globals ...
[08:26:26.219] resolve() on list ...
[08:26:26.219]  recursive: 0
[08:26:26.220]  length: 1
[08:26:26.220]  elements: ‘...’
[08:26:26.220]  length: 0 (resolved future 1)
[08:26:26.220] resolve() on list ... DONE
[08:26:26.220]    - '...' content: [n=0] 
[08:26:26.220] List of 1
[08:26:26.220]  $ ...: list()
[08:26:26.220]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:26.220]  - attr(*, "where")=List of 1
[08:26:26.220]   ..$ ...:<environment: 0x562caad6b678> 
[08:26:26.220]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:26.220]  - attr(*, "resolved")= logi TRUE
[08:26:26.220]  - attr(*, "total_size")= num NA
[08:26:26.222]  - Getting '...' globals ... DONE
[08:26:26.223] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:26.223] List of 8
[08:26:26.223]  $ ...future.FUN:function (x, ...)  
[08:26:26.223]  $ x_FUN        :function (x, na.rm = TRUE)  
[08:26:26.223]  $ times        : int 5
[08:26:26.223]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:26.223]  $ stop_if_not  :function (...)  
[08:26:26.223]  $ dim          : NULL
[08:26:26.223]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:26.223]  $ ...          : list()
[08:26:26.223]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:26.223]  - attr(*, "where")=List of 8
[08:26:26.223]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:26.223]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:26.223]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:26.223]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:26.223]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:26.223]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:26.223]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:26.223]   ..$ ...          :<environment: 0x562caad6b678> 
[08:26:26.223]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:26.223]  - attr(*, "resolved")= logi FALSE
[08:26:26.223]  - attr(*, "total_size")= num 48005
[08:26:26.228] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[08:26:26.228] getGlobalsAndPackagesXApply() ... DONE
[08:26:26.230] Number of futures (= number of chunks): 2
[08:26:26.231] Launching 2 futures (chunks) ...
[08:26:26.231] Chunk #1 of 2 ...
[08:26:26.231]  - Finding globals in 'X' for chunk #1 ...
[08:26:26.231] getGlobalsAndPackages() ...
[08:26:26.231] Searching for globals...
[08:26:26.231] 
[08:26:26.231] Searching for globals ... DONE
[08:26:26.231] - globals: [0] <none>
[08:26:26.232] getGlobalsAndPackages() ... DONE
[08:26:26.232]    + additional globals found: [n=0] 
[08:26:26.232]    + additional namespaces needed: [n=0] 
[08:26:26.232]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:26.232]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:26.232]  - seeds: <none>
[08:26:26.232]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.232] getGlobalsAndPackages() ...
[08:26:26.232] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.232] Resolving globals: FALSE
[08:26:26.232] Tweak future expression to call with '...' arguments ...
[08:26:26.233] {
[08:26:26.233]     do.call(function(...) {
[08:26:26.233]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:26.233]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:26.233]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:26.233]             on.exit(options(oopts), add = TRUE)
[08:26:26.233]         }
[08:26:26.233]         {
[08:26:26.233]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:26.233]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:26.233]                 ...future.FUN(...future.X_jj, ...)
[08:26:26.233]             })
[08:26:26.233]         }
[08:26:26.233]     }, args = future.call.arguments)
[08:26:26.233] }
[08:26:26.233] Tweak future expression to call with '...' arguments ... DONE
[08:26:26.233] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.233] - packages: [2] ‘stats’, ‘future.apply’
[08:26:26.234] getGlobalsAndPackages() ... DONE
[08:26:26.234] run() for ‘Future’ ...
[08:26:26.234] - state: ‘created’
[08:26:26.234] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:26.249] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:26.249] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:26.249]   - Field: ‘node’
[08:26:26.249]   - Field: ‘label’
[08:26:26.249]   - Field: ‘local’
[08:26:26.249]   - Field: ‘owner’
[08:26:26.249]   - Field: ‘envir’
[08:26:26.250]   - Field: ‘workers’
[08:26:26.250]   - Field: ‘packages’
[08:26:26.250]   - Field: ‘gc’
[08:26:26.250]   - Field: ‘conditions’
[08:26:26.250]   - Field: ‘persistent’
[08:26:26.250]   - Field: ‘expr’
[08:26:26.250]   - Field: ‘uuid’
[08:26:26.250]   - Field: ‘seed’
[08:26:26.250]   - Field: ‘version’
[08:26:26.250]   - Field: ‘result’
[08:26:26.250]   - Field: ‘asynchronous’
[08:26:26.251]   - Field: ‘calls’
[08:26:26.251]   - Field: ‘globals’
[08:26:26.251]   - Field: ‘stdout’
[08:26:26.251]   - Field: ‘earlySignal’
[08:26:26.251]   - Field: ‘lazy’
[08:26:26.251]   - Field: ‘state’
[08:26:26.251] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:26.251] - Launch lazy future ...
[08:26:26.251] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[08:26:26.252] Packages needed by future strategies (n = 0): <none>
[08:26:26.252] {
[08:26:26.252]     {
[08:26:26.252]         {
[08:26:26.252]             ...future.startTime <- base::Sys.time()
[08:26:26.252]             {
[08:26:26.252]                 {
[08:26:26.252]                   {
[08:26:26.252]                     {
[08:26:26.252]                       {
[08:26:26.252]                         base::local({
[08:26:26.252]                           has_future <- base::requireNamespace("future", 
[08:26:26.252]                             quietly = TRUE)
[08:26:26.252]                           if (has_future) {
[08:26:26.252]                             ns <- base::getNamespace("future")
[08:26:26.252]                             version <- ns[[".package"]][["version"]]
[08:26:26.252]                             if (is.null(version)) 
[08:26:26.252]                               version <- utils::packageVersion("future")
[08:26:26.252]                           }
[08:26:26.252]                           else {
[08:26:26.252]                             version <- NULL
[08:26:26.252]                           }
[08:26:26.252]                           if (!has_future || version < "1.8.0") {
[08:26:26.252]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:26.252]                               "", base::R.version$version.string), 
[08:26:26.252]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:26.252]                                 base::R.version$platform, 8 * 
[08:26:26.252]                                   base::.Machine$sizeof.pointer), 
[08:26:26.252]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:26.252]                                 "release", "version")], collapse = " "), 
[08:26:26.252]                               hostname = base::Sys.info()[["nodename"]])
[08:26:26.252]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:26.252]                               info)
[08:26:26.252]                             info <- base::paste(info, collapse = "; ")
[08:26:26.252]                             if (!has_future) {
[08:26:26.252]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:26.252]                                 info)
[08:26:26.252]                             }
[08:26:26.252]                             else {
[08:26:26.252]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:26.252]                                 info, version)
[08:26:26.252]                             }
[08:26:26.252]                             base::stop(msg)
[08:26:26.252]                           }
[08:26:26.252]                         })
[08:26:26.252]                       }
[08:26:26.252]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:26.252]                       base::options(mc.cores = 1L)
[08:26:26.252]                     }
[08:26:26.252]                     base::local({
[08:26:26.252]                       for (pkg in c("stats", "future.apply")) {
[08:26:26.252]                         base::loadNamespace(pkg)
[08:26:26.252]                         base::library(pkg, character.only = TRUE)
[08:26:26.252]                       }
[08:26:26.252]                     })
[08:26:26.252]                   }
[08:26:26.252]                   ...future.strategy.old <- future::plan("list")
[08:26:26.252]                   options(future.plan = NULL)
[08:26:26.252]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:26.252]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:26.252]                 }
[08:26:26.252]                 ...future.workdir <- getwd()
[08:26:26.252]             }
[08:26:26.252]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:26.252]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:26.252]         }
[08:26:26.252]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:26.252]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:26.252]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:26.252]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:26.252]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:26.252]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:26.252]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:26.252]             base::names(...future.oldOptions))
[08:26:26.252]     }
[08:26:26.252]     if (FALSE) {
[08:26:26.252]     }
[08:26:26.252]     else {
[08:26:26.252]         if (TRUE) {
[08:26:26.252]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:26.252]                 open = "w")
[08:26:26.252]         }
[08:26:26.252]         else {
[08:26:26.252]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:26.252]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:26.252]         }
[08:26:26.252]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:26.252]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:26.252]             base::sink(type = "output", split = FALSE)
[08:26:26.252]             base::close(...future.stdout)
[08:26:26.252]         }, add = TRUE)
[08:26:26.252]     }
[08:26:26.252]     ...future.frame <- base::sys.nframe()
[08:26:26.252]     ...future.conditions <- base::list()
[08:26:26.252]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:26.252]     if (FALSE) {
[08:26:26.252]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:26.252]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:26.252]     }
[08:26:26.252]     ...future.result <- base::tryCatch({
[08:26:26.252]         base::withCallingHandlers({
[08:26:26.252]             ...future.value <- base::withVisible(base::local({
[08:26:26.252]                 ...future.makeSendCondition <- base::local({
[08:26:26.252]                   sendCondition <- NULL
[08:26:26.252]                   function(frame = 1L) {
[08:26:26.252]                     if (is.function(sendCondition)) 
[08:26:26.252]                       return(sendCondition)
[08:26:26.252]                     ns <- getNamespace("parallel")
[08:26:26.252]                     if (exists("sendData", mode = "function", 
[08:26:26.252]                       envir = ns)) {
[08:26:26.252]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:26.252]                         envir = ns)
[08:26:26.252]                       envir <- sys.frame(frame)
[08:26:26.252]                       master <- NULL
[08:26:26.252]                       while (!identical(envir, .GlobalEnv) && 
[08:26:26.252]                         !identical(envir, emptyenv())) {
[08:26:26.252]                         if (exists("master", mode = "list", envir = envir, 
[08:26:26.252]                           inherits = FALSE)) {
[08:26:26.252]                           master <- get("master", mode = "list", 
[08:26:26.252]                             envir = envir, inherits = FALSE)
[08:26:26.252]                           if (inherits(master, c("SOCKnode", 
[08:26:26.252]                             "SOCK0node"))) {
[08:26:26.252]                             sendCondition <<- function(cond) {
[08:26:26.252]                               data <- list(type = "VALUE", value = cond, 
[08:26:26.252]                                 success = TRUE)
[08:26:26.252]                               parallel_sendData(master, data)
[08:26:26.252]                             }
[08:26:26.252]                             return(sendCondition)
[08:26:26.252]                           }
[08:26:26.252]                         }
[08:26:26.252]                         frame <- frame + 1L
[08:26:26.252]                         envir <- sys.frame(frame)
[08:26:26.252]                       }
[08:26:26.252]                     }
[08:26:26.252]                     sendCondition <<- function(cond) NULL
[08:26:26.252]                   }
[08:26:26.252]                 })
[08:26:26.252]                 withCallingHandlers({
[08:26:26.252]                   {
[08:26:26.252]                     do.call(function(...) {
[08:26:26.252]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:26.252]                       if (!identical(...future.globals.maxSize.org, 
[08:26:26.252]                         ...future.globals.maxSize)) {
[08:26:26.252]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:26.252]                         on.exit(options(oopts), add = TRUE)
[08:26:26.252]                       }
[08:26:26.252]                       {
[08:26:26.252]                         lapply(seq_along(...future.elements_ii), 
[08:26:26.252]                           FUN = function(jj) {
[08:26:26.252]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:26.252]                             ...future.FUN(...future.X_jj, ...)
[08:26:26.252]                           })
[08:26:26.252]                       }
[08:26:26.252]                     }, args = future.call.arguments)
[08:26:26.252]                   }
[08:26:26.252]                 }, immediateCondition = function(cond) {
[08:26:26.252]                   sendCondition <- ...future.makeSendCondition()
[08:26:26.252]                   sendCondition(cond)
[08:26:26.252]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:26.252]                   {
[08:26:26.252]                     inherits <- base::inherits
[08:26:26.252]                     invokeRestart <- base::invokeRestart
[08:26:26.252]                     is.null <- base::is.null
[08:26:26.252]                     muffled <- FALSE
[08:26:26.252]                     if (inherits(cond, "message")) {
[08:26:26.252]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:26.252]                       if (muffled) 
[08:26:26.252]                         invokeRestart("muffleMessage")
[08:26:26.252]                     }
[08:26:26.252]                     else if (inherits(cond, "warning")) {
[08:26:26.252]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:26.252]                       if (muffled) 
[08:26:26.252]                         invokeRestart("muffleWarning")
[08:26:26.252]                     }
[08:26:26.252]                     else if (inherits(cond, "condition")) {
[08:26:26.252]                       if (!is.null(pattern)) {
[08:26:26.252]                         computeRestarts <- base::computeRestarts
[08:26:26.252]                         grepl <- base::grepl
[08:26:26.252]                         restarts <- computeRestarts(cond)
[08:26:26.252]                         for (restart in restarts) {
[08:26:26.252]                           name <- restart$name
[08:26:26.252]                           if (is.null(name)) 
[08:26:26.252]                             next
[08:26:26.252]                           if (!grepl(pattern, name)) 
[08:26:26.252]                             next
[08:26:26.252]                           invokeRestart(restart)
[08:26:26.252]                           muffled <- TRUE
[08:26:26.252]                           break
[08:26:26.252]                         }
[08:26:26.252]                       }
[08:26:26.252]                     }
[08:26:26.252]                     invisible(muffled)
[08:26:26.252]                   }
[08:26:26.252]                   muffleCondition(cond)
[08:26:26.252]                 })
[08:26:26.252]             }))
[08:26:26.252]             future::FutureResult(value = ...future.value$value, 
[08:26:26.252]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:26.252]                   ...future.rng), globalenv = if (FALSE) 
[08:26:26.252]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:26.252]                     ...future.globalenv.names))
[08:26:26.252]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:26.252]         }, condition = base::local({
[08:26:26.252]             c <- base::c
[08:26:26.252]             inherits <- base::inherits
[08:26:26.252]             invokeRestart <- base::invokeRestart
[08:26:26.252]             length <- base::length
[08:26:26.252]             list <- base::list
[08:26:26.252]             seq.int <- base::seq.int
[08:26:26.252]             signalCondition <- base::signalCondition
[08:26:26.252]             sys.calls <- base::sys.calls
[08:26:26.252]             `[[` <- base::`[[`
[08:26:26.252]             `+` <- base::`+`
[08:26:26.252]             `<<-` <- base::`<<-`
[08:26:26.252]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:26.252]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:26.252]                   3L)]
[08:26:26.252]             }
[08:26:26.252]             function(cond) {
[08:26:26.252]                 is_error <- inherits(cond, "error")
[08:26:26.252]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:26.252]                   NULL)
[08:26:26.252]                 if (is_error) {
[08:26:26.252]                   sessionInformation <- function() {
[08:26:26.252]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:26.252]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:26.252]                       search = base::search(), system = base::Sys.info())
[08:26:26.252]                   }
[08:26:26.252]                   ...future.conditions[[length(...future.conditions) + 
[08:26:26.252]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:26.252]                     cond$call), session = sessionInformation(), 
[08:26:26.252]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:26.252]                   signalCondition(cond)
[08:26:26.252]                 }
[08:26:26.252]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:26.252]                 "immediateCondition"))) {
[08:26:26.252]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:26.252]                   ...future.conditions[[length(...future.conditions) + 
[08:26:26.252]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:26.252]                   if (TRUE && !signal) {
[08:26:26.252]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:26.252]                     {
[08:26:26.252]                       inherits <- base::inherits
[08:26:26.252]                       invokeRestart <- base::invokeRestart
[08:26:26.252]                       is.null <- base::is.null
[08:26:26.252]                       muffled <- FALSE
[08:26:26.252]                       if (inherits(cond, "message")) {
[08:26:26.252]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:26.252]                         if (muffled) 
[08:26:26.252]                           invokeRestart("muffleMessage")
[08:26:26.252]                       }
[08:26:26.252]                       else if (inherits(cond, "warning")) {
[08:26:26.252]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:26.252]                         if (muffled) 
[08:26:26.252]                           invokeRestart("muffleWarning")
[08:26:26.252]                       }
[08:26:26.252]                       else if (inherits(cond, "condition")) {
[08:26:26.252]                         if (!is.null(pattern)) {
[08:26:26.252]                           computeRestarts <- base::computeRestarts
[08:26:26.252]                           grepl <- base::grepl
[08:26:26.252]                           restarts <- computeRestarts(cond)
[08:26:26.252]                           for (restart in restarts) {
[08:26:26.252]                             name <- restart$name
[08:26:26.252]                             if (is.null(name)) 
[08:26:26.252]                               next
[08:26:26.252]                             if (!grepl(pattern, name)) 
[08:26:26.252]                               next
[08:26:26.252]                             invokeRestart(restart)
[08:26:26.252]                             muffled <- TRUE
[08:26:26.252]                             break
[08:26:26.252]                           }
[08:26:26.252]                         }
[08:26:26.252]                       }
[08:26:26.252]                       invisible(muffled)
[08:26:26.252]                     }
[08:26:26.252]                     muffleCondition(cond, pattern = "^muffle")
[08:26:26.252]                   }
[08:26:26.252]                 }
[08:26:26.252]                 else {
[08:26:26.252]                   if (TRUE) {
[08:26:26.252]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:26.252]                     {
[08:26:26.252]                       inherits <- base::inherits
[08:26:26.252]                       invokeRestart <- base::invokeRestart
[08:26:26.252]                       is.null <- base::is.null
[08:26:26.252]                       muffled <- FALSE
[08:26:26.252]                       if (inherits(cond, "message")) {
[08:26:26.252]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:26.252]                         if (muffled) 
[08:26:26.252]                           invokeRestart("muffleMessage")
[08:26:26.252]                       }
[08:26:26.252]                       else if (inherits(cond, "warning")) {
[08:26:26.252]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:26.252]                         if (muffled) 
[08:26:26.252]                           invokeRestart("muffleWarning")
[08:26:26.252]                       }
[08:26:26.252]                       else if (inherits(cond, "condition")) {
[08:26:26.252]                         if (!is.null(pattern)) {
[08:26:26.252]                           computeRestarts <- base::computeRestarts
[08:26:26.252]                           grepl <- base::grepl
[08:26:26.252]                           restarts <- computeRestarts(cond)
[08:26:26.252]                           for (restart in restarts) {
[08:26:26.252]                             name <- restart$name
[08:26:26.252]                             if (is.null(name)) 
[08:26:26.252]                               next
[08:26:26.252]                             if (!grepl(pattern, name)) 
[08:26:26.252]                               next
[08:26:26.252]                             invokeRestart(restart)
[08:26:26.252]                             muffled <- TRUE
[08:26:26.252]                             break
[08:26:26.252]                           }
[08:26:26.252]                         }
[08:26:26.252]                       }
[08:26:26.252]                       invisible(muffled)
[08:26:26.252]                     }
[08:26:26.252]                     muffleCondition(cond, pattern = "^muffle")
[08:26:26.252]                   }
[08:26:26.252]                 }
[08:26:26.252]             }
[08:26:26.252]         }))
[08:26:26.252]     }, error = function(ex) {
[08:26:26.252]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:26.252]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:26.252]                 ...future.rng), started = ...future.startTime, 
[08:26:26.252]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:26.252]             version = "1.8"), class = "FutureResult")
[08:26:26.252]     }, finally = {
[08:26:26.252]         if (!identical(...future.workdir, getwd())) 
[08:26:26.252]             setwd(...future.workdir)
[08:26:26.252]         {
[08:26:26.252]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:26.252]                 ...future.oldOptions$nwarnings <- NULL
[08:26:26.252]             }
[08:26:26.252]             base::options(...future.oldOptions)
[08:26:26.252]             if (.Platform$OS.type == "windows") {
[08:26:26.252]                 old_names <- names(...future.oldEnvVars)
[08:26:26.252]                 envs <- base::Sys.getenv()
[08:26:26.252]                 names <- names(envs)
[08:26:26.252]                 common <- intersect(names, old_names)
[08:26:26.252]                 added <- setdiff(names, old_names)
[08:26:26.252]                 removed <- setdiff(old_names, names)
[08:26:26.252]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:26.252]                   envs[common]]
[08:26:26.252]                 NAMES <- toupper(changed)
[08:26:26.252]                 args <- list()
[08:26:26.252]                 for (kk in seq_along(NAMES)) {
[08:26:26.252]                   name <- changed[[kk]]
[08:26:26.252]                   NAME <- NAMES[[kk]]
[08:26:26.252]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:26.252]                     next
[08:26:26.252]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:26.252]                 }
[08:26:26.252]                 NAMES <- toupper(added)
[08:26:26.252]                 for (kk in seq_along(NAMES)) {
[08:26:26.252]                   name <- added[[kk]]
[08:26:26.252]                   NAME <- NAMES[[kk]]
[08:26:26.252]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:26.252]                     next
[08:26:26.252]                   args[[name]] <- ""
[08:26:26.252]                 }
[08:26:26.252]                 NAMES <- toupper(removed)
[08:26:26.252]                 for (kk in seq_along(NAMES)) {
[08:26:26.252]                   name <- removed[[kk]]
[08:26:26.252]                   NAME <- NAMES[[kk]]
[08:26:26.252]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:26.252]                     next
[08:26:26.252]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:26.252]                 }
[08:26:26.252]                 if (length(args) > 0) 
[08:26:26.252]                   base::do.call(base::Sys.setenv, args = args)
[08:26:26.252]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:26.252]             }
[08:26:26.252]             else {
[08:26:26.252]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:26.252]             }
[08:26:26.252]             {
[08:26:26.252]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:26.252]                   0L) {
[08:26:26.252]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:26.252]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:26.252]                   base::options(opts)
[08:26:26.252]                 }
[08:26:26.252]                 {
[08:26:26.252]                   {
[08:26:26.252]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:26.252]                     NULL
[08:26:26.252]                   }
[08:26:26.252]                   options(future.plan = NULL)
[08:26:26.252]                   if (is.na(NA_character_)) 
[08:26:26.252]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:26.252]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:26.252]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:26.252]                     .init = FALSE)
[08:26:26.252]                 }
[08:26:26.252]             }
[08:26:26.252]         }
[08:26:26.252]     })
[08:26:26.252]     if (TRUE) {
[08:26:26.252]         base::sink(type = "output", split = FALSE)
[08:26:26.252]         if (TRUE) {
[08:26:26.252]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:26.252]         }
[08:26:26.252]         else {
[08:26:26.252]             ...future.result["stdout"] <- base::list(NULL)
[08:26:26.252]         }
[08:26:26.252]         base::close(...future.stdout)
[08:26:26.252]         ...future.stdout <- NULL
[08:26:26.252]     }
[08:26:26.252]     ...future.result$conditions <- ...future.conditions
[08:26:26.252]     ...future.result$finished <- base::Sys.time()
[08:26:26.252]     ...future.result
[08:26:26.252] }
[08:26:26.255] Exporting 11 global objects (27.06 KiB) to cluster node #1 ...
[08:26:26.255] Exporting ‘...future.FUN’ (14.07 KiB) to cluster node #1 ...
[08:26:26.297] Exporting ‘...future.FUN’ (14.07 KiB) to cluster node #1 ... DONE
[08:26:26.297] Exporting ‘x_FUN’ (4.67 KiB) to cluster node #1 ...
[08:26:26.339] Exporting ‘x_FUN’ (4.67 KiB) to cluster node #1 ... DONE
[08:26:26.339] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[08:26:26.339] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[08:26:26.339] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[08:26:26.380] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[08:26:26.381] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[08:26:26.422] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[08:26:26.422] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[08:26:26.422] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[08:26:26.422] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[08:26:26.423] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[08:26:26.423] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:26:26.423] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:26:26.423] Exporting ‘...future.elements_ii’ (369 bytes) to cluster node #1 ...
[08:26:26.424] Exporting ‘...future.elements_ii’ (369 bytes) to cluster node #1 ... DONE
[08:26:26.424] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:26:26.424] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:26:26.424] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:26:26.424] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:26:26.424] Exporting 11 global objects (27.06 KiB) to cluster node #1 ... DONE
[08:26:26.425] MultisessionFuture started
[08:26:26.425] - Launch lazy future ... done
[08:26:26.425] run() for ‘MultisessionFuture’ ... done
[08:26:26.425] Created future:
[08:26:26.425] MultisessionFuture:
[08:26:26.425] Label: ‘future_vapply-1’
[08:26:26.425] Expression:
[08:26:26.425] {
[08:26:26.425]     do.call(function(...) {
[08:26:26.425]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:26.425]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:26.425]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:26.425]             on.exit(options(oopts), add = TRUE)
[08:26:26.425]         }
[08:26:26.425]         {
[08:26:26.425]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:26.425]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:26.425]                 ...future.FUN(...future.X_jj, ...)
[08:26:26.425]             })
[08:26:26.425]         }
[08:26:26.425]     }, args = future.call.arguments)
[08:26:26.425] }
[08:26:26.425] Lazy evaluation: FALSE
[08:26:26.425] Asynchronous evaluation: TRUE
[08:26:26.425] Local evaluation: TRUE
[08:26:26.425] Environment: R_GlobalEnv
[08:26:26.425] Capture standard output: TRUE
[08:26:26.425] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:26.425] Globals: 11 objects totaling 27.22 KiB (function ‘...future.FUN’ of 14.07 KiB, function ‘x_FUN’ of 4.67 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:26.425] Packages: 2 packages (‘stats’, ‘future.apply’)
[08:26:26.425] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:26.425] Resolved: FALSE
[08:26:26.425] Value: <not collected>
[08:26:26.425] Conditions captured: <none>
[08:26:26.425] Early signaling: FALSE
[08:26:26.425] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:26.425] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:26.437] Chunk #1 of 2 ... DONE
[08:26:26.437] Chunk #2 of 2 ...
[08:26:26.438]  - Finding globals in 'X' for chunk #2 ...
[08:26:26.438] getGlobalsAndPackages() ...
[08:26:26.438] Searching for globals...
[08:26:26.438] 
[08:26:26.438] Searching for globals ... DONE
[08:26:26.438] - globals: [0] <none>
[08:26:26.438] getGlobalsAndPackages() ... DONE
[08:26:26.438]    + additional globals found: [n=0] 
[08:26:26.439]    + additional namespaces needed: [n=0] 
[08:26:26.439]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:26.439]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:26.439]  - seeds: <none>
[08:26:26.439]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.439] getGlobalsAndPackages() ...
[08:26:26.439] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.439] Resolving globals: FALSE
[08:26:26.439] Tweak future expression to call with '...' arguments ...
[08:26:26.439] {
[08:26:26.439]     do.call(function(...) {
[08:26:26.439]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:26.439]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:26.439]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:26.439]             on.exit(options(oopts), add = TRUE)
[08:26:26.439]         }
[08:26:26.439]         {
[08:26:26.439]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:26.439]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:26.439]                 ...future.FUN(...future.X_jj, ...)
[08:26:26.439]             })
[08:26:26.439]         }
[08:26:26.439]     }, args = future.call.arguments)
[08:26:26.439] }
[08:26:26.440] Tweak future expression to call with '...' arguments ... DONE
[08:26:26.440] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.440] - packages: [2] ‘stats’, ‘future.apply’
[08:26:26.441] getGlobalsAndPackages() ... DONE
[08:26:26.441] run() for ‘Future’ ...
[08:26:26.441] - state: ‘created’
[08:26:26.441] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:26.455] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:26.456] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:26.456]   - Field: ‘node’
[08:26:26.456]   - Field: ‘label’
[08:26:26.456]   - Field: ‘local’
[08:26:26.456]   - Field: ‘owner’
[08:26:26.456]   - Field: ‘envir’
[08:26:26.456]   - Field: ‘workers’
[08:26:26.456]   - Field: ‘packages’
[08:26:26.456]   - Field: ‘gc’
[08:26:26.456]   - Field: ‘conditions’
[08:26:26.457]   - Field: ‘persistent’
[08:26:26.457]   - Field: ‘expr’
[08:26:26.457]   - Field: ‘uuid’
[08:26:26.457]   - Field: ‘seed’
[08:26:26.457]   - Field: ‘version’
[08:26:26.457]   - Field: ‘result’
[08:26:26.457]   - Field: ‘asynchronous’
[08:26:26.457]   - Field: ‘calls’
[08:26:26.457]   - Field: ‘globals’
[08:26:26.457]   - Field: ‘stdout’
[08:26:26.457]   - Field: ‘earlySignal’
[08:26:26.458]   - Field: ‘lazy’
[08:26:26.458]   - Field: ‘state’
[08:26:26.458] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:26.458] - Launch lazy future ...
[08:26:26.458] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[08:26:26.458] Packages needed by future strategies (n = 0): <none>
[08:26:26.459] {
[08:26:26.459]     {
[08:26:26.459]         {
[08:26:26.459]             ...future.startTime <- base::Sys.time()
[08:26:26.459]             {
[08:26:26.459]                 {
[08:26:26.459]                   {
[08:26:26.459]                     {
[08:26:26.459]                       {
[08:26:26.459]                         base::local({
[08:26:26.459]                           has_future <- base::requireNamespace("future", 
[08:26:26.459]                             quietly = TRUE)
[08:26:26.459]                           if (has_future) {
[08:26:26.459]                             ns <- base::getNamespace("future")
[08:26:26.459]                             version <- ns[[".package"]][["version"]]
[08:26:26.459]                             if (is.null(version)) 
[08:26:26.459]                               version <- utils::packageVersion("future")
[08:26:26.459]                           }
[08:26:26.459]                           else {
[08:26:26.459]                             version <- NULL
[08:26:26.459]                           }
[08:26:26.459]                           if (!has_future || version < "1.8.0") {
[08:26:26.459]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:26.459]                               "", base::R.version$version.string), 
[08:26:26.459]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:26.459]                                 base::R.version$platform, 8 * 
[08:26:26.459]                                   base::.Machine$sizeof.pointer), 
[08:26:26.459]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:26.459]                                 "release", "version")], collapse = " "), 
[08:26:26.459]                               hostname = base::Sys.info()[["nodename"]])
[08:26:26.459]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:26.459]                               info)
[08:26:26.459]                             info <- base::paste(info, collapse = "; ")
[08:26:26.459]                             if (!has_future) {
[08:26:26.459]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:26.459]                                 info)
[08:26:26.459]                             }
[08:26:26.459]                             else {
[08:26:26.459]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:26.459]                                 info, version)
[08:26:26.459]                             }
[08:26:26.459]                             base::stop(msg)
[08:26:26.459]                           }
[08:26:26.459]                         })
[08:26:26.459]                       }
[08:26:26.459]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:26.459]                       base::options(mc.cores = 1L)
[08:26:26.459]                     }
[08:26:26.459]                     base::local({
[08:26:26.459]                       for (pkg in c("stats", "future.apply")) {
[08:26:26.459]                         base::loadNamespace(pkg)
[08:26:26.459]                         base::library(pkg, character.only = TRUE)
[08:26:26.459]                       }
[08:26:26.459]                     })
[08:26:26.459]                   }
[08:26:26.459]                   ...future.strategy.old <- future::plan("list")
[08:26:26.459]                   options(future.plan = NULL)
[08:26:26.459]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:26.459]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:26.459]                 }
[08:26:26.459]                 ...future.workdir <- getwd()
[08:26:26.459]             }
[08:26:26.459]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:26.459]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:26.459]         }
[08:26:26.459]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:26.459]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:26.459]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:26.459]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:26.459]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:26.459]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:26.459]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:26.459]             base::names(...future.oldOptions))
[08:26:26.459]     }
[08:26:26.459]     if (FALSE) {
[08:26:26.459]     }
[08:26:26.459]     else {
[08:26:26.459]         if (TRUE) {
[08:26:26.459]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:26.459]                 open = "w")
[08:26:26.459]         }
[08:26:26.459]         else {
[08:26:26.459]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:26.459]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:26.459]         }
[08:26:26.459]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:26.459]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:26.459]             base::sink(type = "output", split = FALSE)
[08:26:26.459]             base::close(...future.stdout)
[08:26:26.459]         }, add = TRUE)
[08:26:26.459]     }
[08:26:26.459]     ...future.frame <- base::sys.nframe()
[08:26:26.459]     ...future.conditions <- base::list()
[08:26:26.459]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:26.459]     if (FALSE) {
[08:26:26.459]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:26.459]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:26.459]     }
[08:26:26.459]     ...future.result <- base::tryCatch({
[08:26:26.459]         base::withCallingHandlers({
[08:26:26.459]             ...future.value <- base::withVisible(base::local({
[08:26:26.459]                 ...future.makeSendCondition <- base::local({
[08:26:26.459]                   sendCondition <- NULL
[08:26:26.459]                   function(frame = 1L) {
[08:26:26.459]                     if (is.function(sendCondition)) 
[08:26:26.459]                       return(sendCondition)
[08:26:26.459]                     ns <- getNamespace("parallel")
[08:26:26.459]                     if (exists("sendData", mode = "function", 
[08:26:26.459]                       envir = ns)) {
[08:26:26.459]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:26.459]                         envir = ns)
[08:26:26.459]                       envir <- sys.frame(frame)
[08:26:26.459]                       master <- NULL
[08:26:26.459]                       while (!identical(envir, .GlobalEnv) && 
[08:26:26.459]                         !identical(envir, emptyenv())) {
[08:26:26.459]                         if (exists("master", mode = "list", envir = envir, 
[08:26:26.459]                           inherits = FALSE)) {
[08:26:26.459]                           master <- get("master", mode = "list", 
[08:26:26.459]                             envir = envir, inherits = FALSE)
[08:26:26.459]                           if (inherits(master, c("SOCKnode", 
[08:26:26.459]                             "SOCK0node"))) {
[08:26:26.459]                             sendCondition <<- function(cond) {
[08:26:26.459]                               data <- list(type = "VALUE", value = cond, 
[08:26:26.459]                                 success = TRUE)
[08:26:26.459]                               parallel_sendData(master, data)
[08:26:26.459]                             }
[08:26:26.459]                             return(sendCondition)
[08:26:26.459]                           }
[08:26:26.459]                         }
[08:26:26.459]                         frame <- frame + 1L
[08:26:26.459]                         envir <- sys.frame(frame)
[08:26:26.459]                       }
[08:26:26.459]                     }
[08:26:26.459]                     sendCondition <<- function(cond) NULL
[08:26:26.459]                   }
[08:26:26.459]                 })
[08:26:26.459]                 withCallingHandlers({
[08:26:26.459]                   {
[08:26:26.459]                     do.call(function(...) {
[08:26:26.459]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:26.459]                       if (!identical(...future.globals.maxSize.org, 
[08:26:26.459]                         ...future.globals.maxSize)) {
[08:26:26.459]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:26.459]                         on.exit(options(oopts), add = TRUE)
[08:26:26.459]                       }
[08:26:26.459]                       {
[08:26:26.459]                         lapply(seq_along(...future.elements_ii), 
[08:26:26.459]                           FUN = function(jj) {
[08:26:26.459]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:26.459]                             ...future.FUN(...future.X_jj, ...)
[08:26:26.459]                           })
[08:26:26.459]                       }
[08:26:26.459]                     }, args = future.call.arguments)
[08:26:26.459]                   }
[08:26:26.459]                 }, immediateCondition = function(cond) {
[08:26:26.459]                   sendCondition <- ...future.makeSendCondition()
[08:26:26.459]                   sendCondition(cond)
[08:26:26.459]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:26.459]                   {
[08:26:26.459]                     inherits <- base::inherits
[08:26:26.459]                     invokeRestart <- base::invokeRestart
[08:26:26.459]                     is.null <- base::is.null
[08:26:26.459]                     muffled <- FALSE
[08:26:26.459]                     if (inherits(cond, "message")) {
[08:26:26.459]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:26.459]                       if (muffled) 
[08:26:26.459]                         invokeRestart("muffleMessage")
[08:26:26.459]                     }
[08:26:26.459]                     else if (inherits(cond, "warning")) {
[08:26:26.459]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:26.459]                       if (muffled) 
[08:26:26.459]                         invokeRestart("muffleWarning")
[08:26:26.459]                     }
[08:26:26.459]                     else if (inherits(cond, "condition")) {
[08:26:26.459]                       if (!is.null(pattern)) {
[08:26:26.459]                         computeRestarts <- base::computeRestarts
[08:26:26.459]                         grepl <- base::grepl
[08:26:26.459]                         restarts <- computeRestarts(cond)
[08:26:26.459]                         for (restart in restarts) {
[08:26:26.459]                           name <- restart$name
[08:26:26.459]                           if (is.null(name)) 
[08:26:26.459]                             next
[08:26:26.459]                           if (!grepl(pattern, name)) 
[08:26:26.459]                             next
[08:26:26.459]                           invokeRestart(restart)
[08:26:26.459]                           muffled <- TRUE
[08:26:26.459]                           break
[08:26:26.459]                         }
[08:26:26.459]                       }
[08:26:26.459]                     }
[08:26:26.459]                     invisible(muffled)
[08:26:26.459]                   }
[08:26:26.459]                   muffleCondition(cond)
[08:26:26.459]                 })
[08:26:26.459]             }))
[08:26:26.459]             future::FutureResult(value = ...future.value$value, 
[08:26:26.459]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:26.459]                   ...future.rng), globalenv = if (FALSE) 
[08:26:26.459]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:26.459]                     ...future.globalenv.names))
[08:26:26.459]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:26.459]         }, condition = base::local({
[08:26:26.459]             c <- base::c
[08:26:26.459]             inherits <- base::inherits
[08:26:26.459]             invokeRestart <- base::invokeRestart
[08:26:26.459]             length <- base::length
[08:26:26.459]             list <- base::list
[08:26:26.459]             seq.int <- base::seq.int
[08:26:26.459]             signalCondition <- base::signalCondition
[08:26:26.459]             sys.calls <- base::sys.calls
[08:26:26.459]             `[[` <- base::`[[`
[08:26:26.459]             `+` <- base::`+`
[08:26:26.459]             `<<-` <- base::`<<-`
[08:26:26.459]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:26.459]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:26.459]                   3L)]
[08:26:26.459]             }
[08:26:26.459]             function(cond) {
[08:26:26.459]                 is_error <- inherits(cond, "error")
[08:26:26.459]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:26.459]                   NULL)
[08:26:26.459]                 if (is_error) {
[08:26:26.459]                   sessionInformation <- function() {
[08:26:26.459]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:26.459]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:26.459]                       search = base::search(), system = base::Sys.info())
[08:26:26.459]                   }
[08:26:26.459]                   ...future.conditions[[length(...future.conditions) + 
[08:26:26.459]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:26.459]                     cond$call), session = sessionInformation(), 
[08:26:26.459]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:26.459]                   signalCondition(cond)
[08:26:26.459]                 }
[08:26:26.459]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:26.459]                 "immediateCondition"))) {
[08:26:26.459]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:26.459]                   ...future.conditions[[length(...future.conditions) + 
[08:26:26.459]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:26.459]                   if (TRUE && !signal) {
[08:26:26.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:26.459]                     {
[08:26:26.459]                       inherits <- base::inherits
[08:26:26.459]                       invokeRestart <- base::invokeRestart
[08:26:26.459]                       is.null <- base::is.null
[08:26:26.459]                       muffled <- FALSE
[08:26:26.459]                       if (inherits(cond, "message")) {
[08:26:26.459]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:26.459]                         if (muffled) 
[08:26:26.459]                           invokeRestart("muffleMessage")
[08:26:26.459]                       }
[08:26:26.459]                       else if (inherits(cond, "warning")) {
[08:26:26.459]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:26.459]                         if (muffled) 
[08:26:26.459]                           invokeRestart("muffleWarning")
[08:26:26.459]                       }
[08:26:26.459]                       else if (inherits(cond, "condition")) {
[08:26:26.459]                         if (!is.null(pattern)) {
[08:26:26.459]                           computeRestarts <- base::computeRestarts
[08:26:26.459]                           grepl <- base::grepl
[08:26:26.459]                           restarts <- computeRestarts(cond)
[08:26:26.459]                           for (restart in restarts) {
[08:26:26.459]                             name <- restart$name
[08:26:26.459]                             if (is.null(name)) 
[08:26:26.459]                               next
[08:26:26.459]                             if (!grepl(pattern, name)) 
[08:26:26.459]                               next
[08:26:26.459]                             invokeRestart(restart)
[08:26:26.459]                             muffled <- TRUE
[08:26:26.459]                             break
[08:26:26.459]                           }
[08:26:26.459]                         }
[08:26:26.459]                       }
[08:26:26.459]                       invisible(muffled)
[08:26:26.459]                     }
[08:26:26.459]                     muffleCondition(cond, pattern = "^muffle")
[08:26:26.459]                   }
[08:26:26.459]                 }
[08:26:26.459]                 else {
[08:26:26.459]                   if (TRUE) {
[08:26:26.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:26.459]                     {
[08:26:26.459]                       inherits <- base::inherits
[08:26:26.459]                       invokeRestart <- base::invokeRestart
[08:26:26.459]                       is.null <- base::is.null
[08:26:26.459]                       muffled <- FALSE
[08:26:26.459]                       if (inherits(cond, "message")) {
[08:26:26.459]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:26.459]                         if (muffled) 
[08:26:26.459]                           invokeRestart("muffleMessage")
[08:26:26.459]                       }
[08:26:26.459]                       else if (inherits(cond, "warning")) {
[08:26:26.459]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:26.459]                         if (muffled) 
[08:26:26.459]                           invokeRestart("muffleWarning")
[08:26:26.459]                       }
[08:26:26.459]                       else if (inherits(cond, "condition")) {
[08:26:26.459]                         if (!is.null(pattern)) {
[08:26:26.459]                           computeRestarts <- base::computeRestarts
[08:26:26.459]                           grepl <- base::grepl
[08:26:26.459]                           restarts <- computeRestarts(cond)
[08:26:26.459]                           for (restart in restarts) {
[08:26:26.459]                             name <- restart$name
[08:26:26.459]                             if (is.null(name)) 
[08:26:26.459]                               next
[08:26:26.459]                             if (!grepl(pattern, name)) 
[08:26:26.459]                               next
[08:26:26.459]                             invokeRestart(restart)
[08:26:26.459]                             muffled <- TRUE
[08:26:26.459]                             break
[08:26:26.459]                           }
[08:26:26.459]                         }
[08:26:26.459]                       }
[08:26:26.459]                       invisible(muffled)
[08:26:26.459]                     }
[08:26:26.459]                     muffleCondition(cond, pattern = "^muffle")
[08:26:26.459]                   }
[08:26:26.459]                 }
[08:26:26.459]             }
[08:26:26.459]         }))
[08:26:26.459]     }, error = function(ex) {
[08:26:26.459]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:26.459]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:26.459]                 ...future.rng), started = ...future.startTime, 
[08:26:26.459]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:26.459]             version = "1.8"), class = "FutureResult")
[08:26:26.459]     }, finally = {
[08:26:26.459]         if (!identical(...future.workdir, getwd())) 
[08:26:26.459]             setwd(...future.workdir)
[08:26:26.459]         {
[08:26:26.459]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:26.459]                 ...future.oldOptions$nwarnings <- NULL
[08:26:26.459]             }
[08:26:26.459]             base::options(...future.oldOptions)
[08:26:26.459]             if (.Platform$OS.type == "windows") {
[08:26:26.459]                 old_names <- names(...future.oldEnvVars)
[08:26:26.459]                 envs <- base::Sys.getenv()
[08:26:26.459]                 names <- names(envs)
[08:26:26.459]                 common <- intersect(names, old_names)
[08:26:26.459]                 added <- setdiff(names, old_names)
[08:26:26.459]                 removed <- setdiff(old_names, names)
[08:26:26.459]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:26.459]                   envs[common]]
[08:26:26.459]                 NAMES <- toupper(changed)
[08:26:26.459]                 args <- list()
[08:26:26.459]                 for (kk in seq_along(NAMES)) {
[08:26:26.459]                   name <- changed[[kk]]
[08:26:26.459]                   NAME <- NAMES[[kk]]
[08:26:26.459]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:26.459]                     next
[08:26:26.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:26.459]                 }
[08:26:26.459]                 NAMES <- toupper(added)
[08:26:26.459]                 for (kk in seq_along(NAMES)) {
[08:26:26.459]                   name <- added[[kk]]
[08:26:26.459]                   NAME <- NAMES[[kk]]
[08:26:26.459]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:26.459]                     next
[08:26:26.459]                   args[[name]] <- ""
[08:26:26.459]                 }
[08:26:26.459]                 NAMES <- toupper(removed)
[08:26:26.459]                 for (kk in seq_along(NAMES)) {
[08:26:26.459]                   name <- removed[[kk]]
[08:26:26.459]                   NAME <- NAMES[[kk]]
[08:26:26.459]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:26.459]                     next
[08:26:26.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:26.459]                 }
[08:26:26.459]                 if (length(args) > 0) 
[08:26:26.459]                   base::do.call(base::Sys.setenv, args = args)
[08:26:26.459]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:26.459]             }
[08:26:26.459]             else {
[08:26:26.459]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:26.459]             }
[08:26:26.459]             {
[08:26:26.459]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:26.459]                   0L) {
[08:26:26.459]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:26.459]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:26.459]                   base::options(opts)
[08:26:26.459]                 }
[08:26:26.459]                 {
[08:26:26.459]                   {
[08:26:26.459]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:26.459]                     NULL
[08:26:26.459]                   }
[08:26:26.459]                   options(future.plan = NULL)
[08:26:26.459]                   if (is.na(NA_character_)) 
[08:26:26.459]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:26.459]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:26.459]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:26.459]                     .init = FALSE)
[08:26:26.459]                 }
[08:26:26.459]             }
[08:26:26.459]         }
[08:26:26.459]     })
[08:26:26.459]     if (TRUE) {
[08:26:26.459]         base::sink(type = "output", split = FALSE)
[08:26:26.459]         if (TRUE) {
[08:26:26.459]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:26.459]         }
[08:26:26.459]         else {
[08:26:26.459]             ...future.result["stdout"] <- base::list(NULL)
[08:26:26.459]         }
[08:26:26.459]         base::close(...future.stdout)
[08:26:26.459]         ...future.stdout <- NULL
[08:26:26.459]     }
[08:26:26.459]     ...future.result$conditions <- ...future.conditions
[08:26:26.459]     ...future.result$finished <- base::Sys.time()
[08:26:26.459]     ...future.result
[08:26:26.459] }
[08:26:26.462] Exporting 11 global objects (26.98 KiB) to cluster node #2 ...
[08:26:26.462] Exporting ‘...future.FUN’ (14.07 KiB) to cluster node #2 ...
[08:26:26.504] Exporting ‘...future.FUN’ (14.07 KiB) to cluster node #2 ... DONE
[08:26:26.504] Exporting ‘x_FUN’ (4.67 KiB) to cluster node #2 ...
[08:26:26.545] Exporting ‘x_FUN’ (4.67 KiB) to cluster node #2 ... DONE
[08:26:26.546] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[08:26:26.546] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[08:26:26.546] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[08:26:26.587] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[08:26:26.588] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[08:26:26.629] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[08:26:26.629] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[08:26:26.629] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[08:26:26.630] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[08:26:26.630] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[08:26:26.630] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:26:26.630] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:26:26.631] Exporting ‘...future.elements_ii’ (293 bytes) to cluster node #2 ...
[08:26:26.631] Exporting ‘...future.elements_ii’ (293 bytes) to cluster node #2 ... DONE
[08:26:26.631] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:26:26.631] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:26:26.632] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:26:26.632] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:26:26.632] Exporting 11 global objects (26.98 KiB) to cluster node #2 ... DONE
[08:26:26.633] MultisessionFuture started
[08:26:26.633] - Launch lazy future ... done
[08:26:26.633] run() for ‘MultisessionFuture’ ... done
[08:26:26.633] Created future:
[08:26:26.633] MultisessionFuture:
[08:26:26.633] Label: ‘future_vapply-2’
[08:26:26.633] Expression:
[08:26:26.633] {
[08:26:26.633]     do.call(function(...) {
[08:26:26.633]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:26.633]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:26.633]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:26.633]             on.exit(options(oopts), add = TRUE)
[08:26:26.633]         }
[08:26:26.633]         {
[08:26:26.633]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:26.633]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:26.633]                 ...future.FUN(...future.X_jj, ...)
[08:26:26.633]             })
[08:26:26.633]         }
[08:26:26.633]     }, args = future.call.arguments)
[08:26:26.633] }
[08:26:26.633] Lazy evaluation: FALSE
[08:26:26.633] Asynchronous evaluation: TRUE
[08:26:26.633] Local evaluation: TRUE
[08:26:26.633] Environment: R_GlobalEnv
[08:26:26.633] Capture standard output: TRUE
[08:26:26.633] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:26.633] Globals: 11 objects totaling 27.14 KiB (function ‘...future.FUN’ of 14.07 KiB, function ‘x_FUN’ of 4.67 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:26.633] Packages: 2 packages (‘stats’, ‘future.apply’)
[08:26:26.633] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:26.633] Resolved: FALSE
[08:26:26.633] Value: <not collected>
[08:26:26.633] Conditions captured: <none>
[08:26:26.633] Early signaling: FALSE
[08:26:26.633] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:26.633] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:26.645] Chunk #2 of 2 ... DONE
[08:26:26.645] Launching 2 futures (chunks) ... DONE
[08:26:26.645] Resolving 2 futures (chunks) ...
[08:26:26.645] resolve() on list ...
[08:26:26.645]  recursive: 0
[08:26:26.645]  length: 2
[08:26:26.645] 
[08:26:26.646] receiveMessageFromWorker() for ClusterFuture ...
[08:26:26.646] - Validating connection of MultisessionFuture
[08:26:26.646] - received message: FutureResult
[08:26:26.646] - Received FutureResult
[08:26:26.647] - Erased future from FutureRegistry
[08:26:26.647] result() for ClusterFuture ...
[08:26:26.647] - result already collected: FutureResult
[08:26:26.647] result() for ClusterFuture ... done
[08:26:26.647] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:26.647] Future #1
[08:26:26.647] result() for ClusterFuture ...
[08:26:26.647] - result already collected: FutureResult
[08:26:26.647] result() for ClusterFuture ... done
[08:26:26.647] result() for ClusterFuture ...
[08:26:26.647] - result already collected: FutureResult
[08:26:26.647] result() for ClusterFuture ... done
[08:26:26.648] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:26:26.648] - nx: 2
[08:26:26.648] - relay: TRUE
[08:26:26.648] - stdout: TRUE
[08:26:26.648] - signal: TRUE
[08:26:26.648] - resignal: FALSE
[08:26:26.648] - force: TRUE
[08:26:26.648] - relayed: [n=2] FALSE, FALSE
[08:26:26.648] - queued futures: [n=2] FALSE, FALSE
[08:26:26.648]  - until=1
[08:26:26.648]  - relaying element #1
[08:26:26.648] result() for ClusterFuture ...
[08:26:26.648] - result already collected: FutureResult
[08:26:26.649] result() for ClusterFuture ... done
[08:26:26.649] result() for ClusterFuture ...
[08:26:26.649] - result already collected: FutureResult
[08:26:26.649] result() for ClusterFuture ... done
[08:26:26.649] result() for ClusterFuture ...
[08:26:26.649] - result already collected: FutureResult
[08:26:26.649] result() for ClusterFuture ... done
[08:26:26.649] result() for ClusterFuture ...
[08:26:26.649] - result already collected: FutureResult
[08:26:26.649] result() for ClusterFuture ... done
[08:26:26.649] - relayed: [n=2] TRUE, FALSE
[08:26:26.650] - queued futures: [n=2] TRUE, FALSE
[08:26:26.650] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:26:26.650]  length: 1 (resolved future 1)
[08:26:26.675] receiveMessageFromWorker() for ClusterFuture ...
[08:26:26.676] - Validating connection of MultisessionFuture
[08:26:26.676] - received message: FutureResult
[08:26:26.676] - Received FutureResult
[08:26:26.676] - Erased future from FutureRegistry
[08:26:26.676] result() for ClusterFuture ...
[08:26:26.676] - result already collected: FutureResult
[08:26:26.676] result() for ClusterFuture ... done
[08:26:26.676] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:26.677] Future #2
[08:26:26.677] result() for ClusterFuture ...
[08:26:26.677] - result already collected: FutureResult
[08:26:26.677] result() for ClusterFuture ... done
[08:26:26.677] result() for ClusterFuture ...
[08:26:26.677] - result already collected: FutureResult
[08:26:26.677] result() for ClusterFuture ... done
[08:26:26.677] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:26:26.677] - nx: 2
[08:26:26.677] - relay: TRUE
[08:26:26.677] - stdout: TRUE
[08:26:26.677] - signal: TRUE
[08:26:26.678] - resignal: FALSE
[08:26:26.678] - force: TRUE
[08:26:26.678] - relayed: [n=2] TRUE, FALSE
[08:26:26.678] - queued futures: [n=2] TRUE, FALSE
[08:26:26.678]  - until=2
[08:26:26.678]  - relaying element #2
[08:26:26.678] result() for ClusterFuture ...
[08:26:26.678] - result already collected: FutureResult
[08:26:26.678] result() for ClusterFuture ... done
[08:26:26.678] result() for ClusterFuture ...
[08:26:26.678] - result already collected: FutureResult
[08:26:26.678] result() for ClusterFuture ... done
[08:26:26.679] result() for ClusterFuture ...
[08:26:26.679] - result already collected: FutureResult
[08:26:26.679] result() for ClusterFuture ... done
[08:26:26.679] result() for ClusterFuture ...
[08:26:26.679] - result already collected: FutureResult
[08:26:26.679] result() for ClusterFuture ... done
[08:26:26.679] - relayed: [n=2] TRUE, TRUE
[08:26:26.679] - queued futures: [n=2] TRUE, TRUE
[08:26:26.679] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:26:26.679]  length: 0 (resolved future 2)
[08:26:26.679] Relaying remaining futures
[08:26:26.680] signalConditionsASAP(NULL, pos=0) ...
[08:26:26.680] - nx: 2
[08:26:26.680] - relay: TRUE
[08:26:26.680] - stdout: TRUE
[08:26:26.680] - signal: TRUE
[08:26:26.680] - resignal: FALSE
[08:26:26.680] - force: TRUE
[08:26:26.680] - relayed: [n=2] TRUE, TRUE
[08:26:26.680] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:26.680] - relayed: [n=2] TRUE, TRUE
[08:26:26.680] - queued futures: [n=2] TRUE, TRUE
[08:26:26.680] signalConditionsASAP(NULL, pos=0) ... done
[08:26:26.680] resolve() on list ... DONE
[08:26:26.681] result() for ClusterFuture ...
[08:26:26.681] - result already collected: FutureResult
[08:26:26.681] result() for ClusterFuture ... done
[08:26:26.681] result() for ClusterFuture ...
[08:26:26.681] - result already collected: FutureResult
[08:26:26.681] result() for ClusterFuture ... done
[08:26:26.681] result() for ClusterFuture ...
[08:26:26.681] - result already collected: FutureResult
[08:26:26.681] result() for ClusterFuture ... done
[08:26:26.681] result() for ClusterFuture ...
[08:26:26.681] - result already collected: FutureResult
[08:26:26.681] result() for ClusterFuture ... done
[08:26:26.682]  - Number of value chunks collected: 2
[08:26:26.682] Resolving 2 futures (chunks) ... DONE
[08:26:26.682] Reducing values from 2 chunks ...
[08:26:26.682]  - Number of values collected after concatenation: 7
[08:26:26.682]  - Number of values expected: 7
[08:26:26.682] Reducing values from 2 chunks ... DONE
[08:26:26.682] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[08:26:26.684] future_lapply() ...
[08:26:26.686] Number of chunks: 2
[08:26:26.686] getGlobalsAndPackagesXApply() ...
[08:26:26.686]  - future.globals: TRUE
[08:26:26.686] getGlobalsAndPackages() ...
[08:26:26.686] Searching for globals...
[08:26:26.687] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[08:26:26.688] Searching for globals ... DONE
[08:26:26.688] Resolving globals: FALSE
[08:26:26.688] The total size of the 1 globals is 680 bytes (680 bytes)
[08:26:26.688] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 680 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (680 bytes of class ‘function’)
[08:26:26.689] - globals: [1] ‘FUN’
[08:26:26.689] 
[08:26:26.689] getGlobalsAndPackages() ... DONE
[08:26:26.689]  - globals found/used: [n=1] ‘FUN’
[08:26:26.689]  - needed namespaces: [n=0] 
[08:26:26.689] Finding globals ... DONE
[08:26:26.689]  - use_args: TRUE
[08:26:26.689]  - Getting '...' globals ...
[08:26:26.689] resolve() on list ...
[08:26:26.690]  recursive: 0
[08:26:26.690]  length: 1
[08:26:26.690]  elements: ‘...’
[08:26:26.690]  length: 0 (resolved future 1)
[08:26:26.690] resolve() on list ... DONE
[08:26:26.690]    - '...' content: [n=1] ‘y’
[08:26:26.690] List of 1
[08:26:26.690]  $ ...:List of 1
[08:26:26.690]   ..$ y: num [1:5] 2 4 6 8 10
[08:26:26.690]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:26.690]  - attr(*, "where")=List of 1
[08:26:26.690]   ..$ ...:<environment: 0x562caa620178> 
[08:26:26.690]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:26.690]  - attr(*, "resolved")= logi TRUE
[08:26:26.690]  - attr(*, "total_size")= num NA
[08:26:26.693]  - Getting '...' globals ... DONE
[08:26:26.693] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:26:26.693] List of 2
[08:26:26.693]  $ ...future.FUN:function (x, y)  
[08:26:26.693]  $ ...          :List of 1
[08:26:26.693]   ..$ y: num [1:5] 2 4 6 8 10
[08:26:26.693]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:26.693]  - attr(*, "where")=List of 2
[08:26:26.693]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:26.693]   ..$ ...          :<environment: 0x562caa620178> 
[08:26:26.693]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:26.693]  - attr(*, "resolved")= logi FALSE
[08:26:26.693]  - attr(*, "total_size")= num 7318
[08:26:26.696] Packages to be attached in all futures: [n=0] 
[08:26:26.696] getGlobalsAndPackagesXApply() ... DONE
[08:26:26.696] Number of futures (= number of chunks): 2
[08:26:26.697] Launching 2 futures (chunks) ...
[08:26:26.697] Chunk #1 of 2 ...
[08:26:26.697]  - Finding globals in 'X' for chunk #1 ...
[08:26:26.697] getGlobalsAndPackages() ...
[08:26:26.697] Searching for globals...
[08:26:26.697] 
[08:26:26.697] Searching for globals ... DONE
[08:26:26.697] - globals: [0] <none>
[08:26:26.697] getGlobalsAndPackages() ... DONE
[08:26:26.697]    + additional globals found: [n=0] 
[08:26:26.698]    + additional namespaces needed: [n=0] 
[08:26:26.698]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:26.698]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:26.698]  - seeds: <none>
[08:26:26.698]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.698] getGlobalsAndPackages() ...
[08:26:26.698] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.698] Resolving globals: FALSE
[08:26:26.698] Tweak future expression to call with '...' arguments ...
[08:26:26.698] {
[08:26:26.698]     do.call(function(...) {
[08:26:26.698]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:26.698]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:26.698]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:26.698]             on.exit(options(oopts), add = TRUE)
[08:26:26.698]         }
[08:26:26.698]         {
[08:26:26.698]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:26.698]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:26.698]                 ...future.FUN(...future.X_jj, ...)
[08:26:26.698]             })
[08:26:26.698]         }
[08:26:26.698]     }, args = future.call.arguments)
[08:26:26.698] }
[08:26:26.699] Tweak future expression to call with '...' arguments ... DONE
[08:26:26.699] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.699] 
[08:26:26.699] getGlobalsAndPackages() ... DONE
[08:26:26.699] run() for ‘Future’ ...
[08:26:26.700] - state: ‘created’
[08:26:26.700] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:26.714] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:26.714] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:26.714]   - Field: ‘node’
[08:26:26.714]   - Field: ‘label’
[08:26:26.714]   - Field: ‘local’
[08:26:26.714]   - Field: ‘owner’
[08:26:26.714]   - Field: ‘envir’
[08:26:26.715]   - Field: ‘workers’
[08:26:26.715]   - Field: ‘packages’
[08:26:26.715]   - Field: ‘gc’
[08:26:26.715]   - Field: ‘conditions’
[08:26:26.715]   - Field: ‘persistent’
[08:26:26.715]   - Field: ‘expr’
[08:26:26.715]   - Field: ‘uuid’
[08:26:26.715]   - Field: ‘seed’
[08:26:26.715]   - Field: ‘version’
[08:26:26.715]   - Field: ‘result’
[08:26:26.715]   - Field: ‘asynchronous’
[08:26:26.716]   - Field: ‘calls’
[08:26:26.716]   - Field: ‘globals’
[08:26:26.716]   - Field: ‘stdout’
[08:26:26.716]   - Field: ‘earlySignal’
[08:26:26.716]   - Field: ‘lazy’
[08:26:26.716]   - Field: ‘state’
[08:26:26.716] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:26.716] - Launch lazy future ...
[08:26:26.717] Packages needed by the future expression (n = 0): <none>
[08:26:26.717] Packages needed by future strategies (n = 0): <none>
[08:26:26.717] {
[08:26:26.717]     {
[08:26:26.717]         {
[08:26:26.717]             ...future.startTime <- base::Sys.time()
[08:26:26.717]             {
[08:26:26.717]                 {
[08:26:26.717]                   {
[08:26:26.717]                     {
[08:26:26.717]                       base::local({
[08:26:26.717]                         has_future <- base::requireNamespace("future", 
[08:26:26.717]                           quietly = TRUE)
[08:26:26.717]                         if (has_future) {
[08:26:26.717]                           ns <- base::getNamespace("future")
[08:26:26.717]                           version <- ns[[".package"]][["version"]]
[08:26:26.717]                           if (is.null(version)) 
[08:26:26.717]                             version <- utils::packageVersion("future")
[08:26:26.717]                         }
[08:26:26.717]                         else {
[08:26:26.717]                           version <- NULL
[08:26:26.717]                         }
[08:26:26.717]                         if (!has_future || version < "1.8.0") {
[08:26:26.717]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:26.717]                             "", base::R.version$version.string), 
[08:26:26.717]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:26.717]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:26.717]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:26.717]                               "release", "version")], collapse = " "), 
[08:26:26.717]                             hostname = base::Sys.info()[["nodename"]])
[08:26:26.717]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:26.717]                             info)
[08:26:26.717]                           info <- base::paste(info, collapse = "; ")
[08:26:26.717]                           if (!has_future) {
[08:26:26.717]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:26.717]                               info)
[08:26:26.717]                           }
[08:26:26.717]                           else {
[08:26:26.717]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:26.717]                               info, version)
[08:26:26.717]                           }
[08:26:26.717]                           base::stop(msg)
[08:26:26.717]                         }
[08:26:26.717]                       })
[08:26:26.717]                     }
[08:26:26.717]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:26.717]                     base::options(mc.cores = 1L)
[08:26:26.717]                   }
[08:26:26.717]                   ...future.strategy.old <- future::plan("list")
[08:26:26.717]                   options(future.plan = NULL)
[08:26:26.717]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:26.717]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:26.717]                 }
[08:26:26.717]                 ...future.workdir <- getwd()
[08:26:26.717]             }
[08:26:26.717]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:26.717]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:26.717]         }
[08:26:26.717]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:26.717]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:26.717]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:26.717]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:26.717]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:26.717]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:26.717]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:26.717]             base::names(...future.oldOptions))
[08:26:26.717]     }
[08:26:26.717]     if (FALSE) {
[08:26:26.717]     }
[08:26:26.717]     else {
[08:26:26.717]         if (TRUE) {
[08:26:26.717]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:26.717]                 open = "w")
[08:26:26.717]         }
[08:26:26.717]         else {
[08:26:26.717]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:26.717]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:26.717]         }
[08:26:26.717]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:26.717]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:26.717]             base::sink(type = "output", split = FALSE)
[08:26:26.717]             base::close(...future.stdout)
[08:26:26.717]         }, add = TRUE)
[08:26:26.717]     }
[08:26:26.717]     ...future.frame <- base::sys.nframe()
[08:26:26.717]     ...future.conditions <- base::list()
[08:26:26.717]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:26.717]     if (FALSE) {
[08:26:26.717]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:26.717]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:26.717]     }
[08:26:26.717]     ...future.result <- base::tryCatch({
[08:26:26.717]         base::withCallingHandlers({
[08:26:26.717]             ...future.value <- base::withVisible(base::local({
[08:26:26.717]                 ...future.makeSendCondition <- base::local({
[08:26:26.717]                   sendCondition <- NULL
[08:26:26.717]                   function(frame = 1L) {
[08:26:26.717]                     if (is.function(sendCondition)) 
[08:26:26.717]                       return(sendCondition)
[08:26:26.717]                     ns <- getNamespace("parallel")
[08:26:26.717]                     if (exists("sendData", mode = "function", 
[08:26:26.717]                       envir = ns)) {
[08:26:26.717]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:26.717]                         envir = ns)
[08:26:26.717]                       envir <- sys.frame(frame)
[08:26:26.717]                       master <- NULL
[08:26:26.717]                       while (!identical(envir, .GlobalEnv) && 
[08:26:26.717]                         !identical(envir, emptyenv())) {
[08:26:26.717]                         if (exists("master", mode = "list", envir = envir, 
[08:26:26.717]                           inherits = FALSE)) {
[08:26:26.717]                           master <- get("master", mode = "list", 
[08:26:26.717]                             envir = envir, inherits = FALSE)
[08:26:26.717]                           if (inherits(master, c("SOCKnode", 
[08:26:26.717]                             "SOCK0node"))) {
[08:26:26.717]                             sendCondition <<- function(cond) {
[08:26:26.717]                               data <- list(type = "VALUE", value = cond, 
[08:26:26.717]                                 success = TRUE)
[08:26:26.717]                               parallel_sendData(master, data)
[08:26:26.717]                             }
[08:26:26.717]                             return(sendCondition)
[08:26:26.717]                           }
[08:26:26.717]                         }
[08:26:26.717]                         frame <- frame + 1L
[08:26:26.717]                         envir <- sys.frame(frame)
[08:26:26.717]                       }
[08:26:26.717]                     }
[08:26:26.717]                     sendCondition <<- function(cond) NULL
[08:26:26.717]                   }
[08:26:26.717]                 })
[08:26:26.717]                 withCallingHandlers({
[08:26:26.717]                   {
[08:26:26.717]                     do.call(function(...) {
[08:26:26.717]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:26.717]                       if (!identical(...future.globals.maxSize.org, 
[08:26:26.717]                         ...future.globals.maxSize)) {
[08:26:26.717]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:26.717]                         on.exit(options(oopts), add = TRUE)
[08:26:26.717]                       }
[08:26:26.717]                       {
[08:26:26.717]                         lapply(seq_along(...future.elements_ii), 
[08:26:26.717]                           FUN = function(jj) {
[08:26:26.717]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:26.717]                             ...future.FUN(...future.X_jj, ...)
[08:26:26.717]                           })
[08:26:26.717]                       }
[08:26:26.717]                     }, args = future.call.arguments)
[08:26:26.717]                   }
[08:26:26.717]                 }, immediateCondition = function(cond) {
[08:26:26.717]                   sendCondition <- ...future.makeSendCondition()
[08:26:26.717]                   sendCondition(cond)
[08:26:26.717]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:26.717]                   {
[08:26:26.717]                     inherits <- base::inherits
[08:26:26.717]                     invokeRestart <- base::invokeRestart
[08:26:26.717]                     is.null <- base::is.null
[08:26:26.717]                     muffled <- FALSE
[08:26:26.717]                     if (inherits(cond, "message")) {
[08:26:26.717]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:26.717]                       if (muffled) 
[08:26:26.717]                         invokeRestart("muffleMessage")
[08:26:26.717]                     }
[08:26:26.717]                     else if (inherits(cond, "warning")) {
[08:26:26.717]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:26.717]                       if (muffled) 
[08:26:26.717]                         invokeRestart("muffleWarning")
[08:26:26.717]                     }
[08:26:26.717]                     else if (inherits(cond, "condition")) {
[08:26:26.717]                       if (!is.null(pattern)) {
[08:26:26.717]                         computeRestarts <- base::computeRestarts
[08:26:26.717]                         grepl <- base::grepl
[08:26:26.717]                         restarts <- computeRestarts(cond)
[08:26:26.717]                         for (restart in restarts) {
[08:26:26.717]                           name <- restart$name
[08:26:26.717]                           if (is.null(name)) 
[08:26:26.717]                             next
[08:26:26.717]                           if (!grepl(pattern, name)) 
[08:26:26.717]                             next
[08:26:26.717]                           invokeRestart(restart)
[08:26:26.717]                           muffled <- TRUE
[08:26:26.717]                           break
[08:26:26.717]                         }
[08:26:26.717]                       }
[08:26:26.717]                     }
[08:26:26.717]                     invisible(muffled)
[08:26:26.717]                   }
[08:26:26.717]                   muffleCondition(cond)
[08:26:26.717]                 })
[08:26:26.717]             }))
[08:26:26.717]             future::FutureResult(value = ...future.value$value, 
[08:26:26.717]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:26.717]                   ...future.rng), globalenv = if (FALSE) 
[08:26:26.717]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:26.717]                     ...future.globalenv.names))
[08:26:26.717]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:26.717]         }, condition = base::local({
[08:26:26.717]             c <- base::c
[08:26:26.717]             inherits <- base::inherits
[08:26:26.717]             invokeRestart <- base::invokeRestart
[08:26:26.717]             length <- base::length
[08:26:26.717]             list <- base::list
[08:26:26.717]             seq.int <- base::seq.int
[08:26:26.717]             signalCondition <- base::signalCondition
[08:26:26.717]             sys.calls <- base::sys.calls
[08:26:26.717]             `[[` <- base::`[[`
[08:26:26.717]             `+` <- base::`+`
[08:26:26.717]             `<<-` <- base::`<<-`
[08:26:26.717]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:26.717]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:26.717]                   3L)]
[08:26:26.717]             }
[08:26:26.717]             function(cond) {
[08:26:26.717]                 is_error <- inherits(cond, "error")
[08:26:26.717]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:26.717]                   NULL)
[08:26:26.717]                 if (is_error) {
[08:26:26.717]                   sessionInformation <- function() {
[08:26:26.717]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:26.717]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:26.717]                       search = base::search(), system = base::Sys.info())
[08:26:26.717]                   }
[08:26:26.717]                   ...future.conditions[[length(...future.conditions) + 
[08:26:26.717]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:26.717]                     cond$call), session = sessionInformation(), 
[08:26:26.717]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:26.717]                   signalCondition(cond)
[08:26:26.717]                 }
[08:26:26.717]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:26.717]                 "immediateCondition"))) {
[08:26:26.717]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:26.717]                   ...future.conditions[[length(...future.conditions) + 
[08:26:26.717]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:26.717]                   if (TRUE && !signal) {
[08:26:26.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:26.717]                     {
[08:26:26.717]                       inherits <- base::inherits
[08:26:26.717]                       invokeRestart <- base::invokeRestart
[08:26:26.717]                       is.null <- base::is.null
[08:26:26.717]                       muffled <- FALSE
[08:26:26.717]                       if (inherits(cond, "message")) {
[08:26:26.717]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:26.717]                         if (muffled) 
[08:26:26.717]                           invokeRestart("muffleMessage")
[08:26:26.717]                       }
[08:26:26.717]                       else if (inherits(cond, "warning")) {
[08:26:26.717]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:26.717]                         if (muffled) 
[08:26:26.717]                           invokeRestart("muffleWarning")
[08:26:26.717]                       }
[08:26:26.717]                       else if (inherits(cond, "condition")) {
[08:26:26.717]                         if (!is.null(pattern)) {
[08:26:26.717]                           computeRestarts <- base::computeRestarts
[08:26:26.717]                           grepl <- base::grepl
[08:26:26.717]                           restarts <- computeRestarts(cond)
[08:26:26.717]                           for (restart in restarts) {
[08:26:26.717]                             name <- restart$name
[08:26:26.717]                             if (is.null(name)) 
[08:26:26.717]                               next
[08:26:26.717]                             if (!grepl(pattern, name)) 
[08:26:26.717]                               next
[08:26:26.717]                             invokeRestart(restart)
[08:26:26.717]                             muffled <- TRUE
[08:26:26.717]                             break
[08:26:26.717]                           }
[08:26:26.717]                         }
[08:26:26.717]                       }
[08:26:26.717]                       invisible(muffled)
[08:26:26.717]                     }
[08:26:26.717]                     muffleCondition(cond, pattern = "^muffle")
[08:26:26.717]                   }
[08:26:26.717]                 }
[08:26:26.717]                 else {
[08:26:26.717]                   if (TRUE) {
[08:26:26.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:26.717]                     {
[08:26:26.717]                       inherits <- base::inherits
[08:26:26.717]                       invokeRestart <- base::invokeRestart
[08:26:26.717]                       is.null <- base::is.null
[08:26:26.717]                       muffled <- FALSE
[08:26:26.717]                       if (inherits(cond, "message")) {
[08:26:26.717]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:26.717]                         if (muffled) 
[08:26:26.717]                           invokeRestart("muffleMessage")
[08:26:26.717]                       }
[08:26:26.717]                       else if (inherits(cond, "warning")) {
[08:26:26.717]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:26.717]                         if (muffled) 
[08:26:26.717]                           invokeRestart("muffleWarning")
[08:26:26.717]                       }
[08:26:26.717]                       else if (inherits(cond, "condition")) {
[08:26:26.717]                         if (!is.null(pattern)) {
[08:26:26.717]                           computeRestarts <- base::computeRestarts
[08:26:26.717]                           grepl <- base::grepl
[08:26:26.717]                           restarts <- computeRestarts(cond)
[08:26:26.717]                           for (restart in restarts) {
[08:26:26.717]                             name <- restart$name
[08:26:26.717]                             if (is.null(name)) 
[08:26:26.717]                               next
[08:26:26.717]                             if (!grepl(pattern, name)) 
[08:26:26.717]                               next
[08:26:26.717]                             invokeRestart(restart)
[08:26:26.717]                             muffled <- TRUE
[08:26:26.717]                             break
[08:26:26.717]                           }
[08:26:26.717]                         }
[08:26:26.717]                       }
[08:26:26.717]                       invisible(muffled)
[08:26:26.717]                     }
[08:26:26.717]                     muffleCondition(cond, pattern = "^muffle")
[08:26:26.717]                   }
[08:26:26.717]                 }
[08:26:26.717]             }
[08:26:26.717]         }))
[08:26:26.717]     }, error = function(ex) {
[08:26:26.717]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:26.717]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:26.717]                 ...future.rng), started = ...future.startTime, 
[08:26:26.717]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:26.717]             version = "1.8"), class = "FutureResult")
[08:26:26.717]     }, finally = {
[08:26:26.717]         if (!identical(...future.workdir, getwd())) 
[08:26:26.717]             setwd(...future.workdir)
[08:26:26.717]         {
[08:26:26.717]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:26.717]                 ...future.oldOptions$nwarnings <- NULL
[08:26:26.717]             }
[08:26:26.717]             base::options(...future.oldOptions)
[08:26:26.717]             if (.Platform$OS.type == "windows") {
[08:26:26.717]                 old_names <- names(...future.oldEnvVars)
[08:26:26.717]                 envs <- base::Sys.getenv()
[08:26:26.717]                 names <- names(envs)
[08:26:26.717]                 common <- intersect(names, old_names)
[08:26:26.717]                 added <- setdiff(names, old_names)
[08:26:26.717]                 removed <- setdiff(old_names, names)
[08:26:26.717]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:26.717]                   envs[common]]
[08:26:26.717]                 NAMES <- toupper(changed)
[08:26:26.717]                 args <- list()
[08:26:26.717]                 for (kk in seq_along(NAMES)) {
[08:26:26.717]                   name <- changed[[kk]]
[08:26:26.717]                   NAME <- NAMES[[kk]]
[08:26:26.717]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:26.717]                     next
[08:26:26.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:26.717]                 }
[08:26:26.717]                 NAMES <- toupper(added)
[08:26:26.717]                 for (kk in seq_along(NAMES)) {
[08:26:26.717]                   name <- added[[kk]]
[08:26:26.717]                   NAME <- NAMES[[kk]]
[08:26:26.717]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:26.717]                     next
[08:26:26.717]                   args[[name]] <- ""
[08:26:26.717]                 }
[08:26:26.717]                 NAMES <- toupper(removed)
[08:26:26.717]                 for (kk in seq_along(NAMES)) {
[08:26:26.717]                   name <- removed[[kk]]
[08:26:26.717]                   NAME <- NAMES[[kk]]
[08:26:26.717]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:26.717]                     next
[08:26:26.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:26.717]                 }
[08:26:26.717]                 if (length(args) > 0) 
[08:26:26.717]                   base::do.call(base::Sys.setenv, args = args)
[08:26:26.717]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:26.717]             }
[08:26:26.717]             else {
[08:26:26.717]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:26.717]             }
[08:26:26.717]             {
[08:26:26.717]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:26.717]                   0L) {
[08:26:26.717]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:26.717]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:26.717]                   base::options(opts)
[08:26:26.717]                 }
[08:26:26.717]                 {
[08:26:26.717]                   {
[08:26:26.717]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:26.717]                     NULL
[08:26:26.717]                   }
[08:26:26.717]                   options(future.plan = NULL)
[08:26:26.717]                   if (is.na(NA_character_)) 
[08:26:26.717]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:26.717]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:26.717]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:26.717]                     .init = FALSE)
[08:26:26.717]                 }
[08:26:26.717]             }
[08:26:26.717]         }
[08:26:26.717]     })
[08:26:26.717]     if (TRUE) {
[08:26:26.717]         base::sink(type = "output", split = FALSE)
[08:26:26.717]         if (TRUE) {
[08:26:26.717]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:26.717]         }
[08:26:26.717]         else {
[08:26:26.717]             ...future.result["stdout"] <- base::list(NULL)
[08:26:26.717]         }
[08:26:26.717]         base::close(...future.stdout)
[08:26:26.717]         ...future.stdout <- NULL
[08:26:26.717]     }
[08:26:26.717]     ...future.result$conditions <- ...future.conditions
[08:26:26.717]     ...future.result$finished <- base::Sys.time()
[08:26:26.717]     ...future.result
[08:26:26.717] }
[08:26:26.720] Exporting 5 global objects (1.43 KiB) to cluster node #1 ...
[08:26:26.720] Exporting ‘...future.FUN’ (680 bytes) to cluster node #1 ...
[08:26:26.721] Exporting ‘...future.FUN’ (680 bytes) to cluster node #1 ... DONE
[08:26:26.721] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #1 ...
[08:26:26.721] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #1 ... DONE
[08:26:26.721] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #1 ...
[08:26:26.722] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #1 ... DONE
[08:26:26.722] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:26:26.722] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:26:26.722] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:26:26.723] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:26:26.723] Exporting 5 global objects (1.43 KiB) to cluster node #1 ... DONE
[08:26:26.723] MultisessionFuture started
[08:26:26.723] - Launch lazy future ... done
[08:26:26.723] run() for ‘MultisessionFuture’ ... done
[08:26:26.723] Created future:
[08:26:26.724] MultisessionFuture:
[08:26:26.724] Label: ‘future_sapply-1’
[08:26:26.724] Expression:
[08:26:26.724] {
[08:26:26.724]     do.call(function(...) {
[08:26:26.724]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:26.724]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:26.724]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:26.724]             on.exit(options(oopts), add = TRUE)
[08:26:26.724]         }
[08:26:26.724]         {
[08:26:26.724]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:26.724]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:26.724]                 ...future.FUN(...future.X_jj, ...)
[08:26:26.724]             })
[08:26:26.724]         }
[08:26:26.724]     }, args = future.call.arguments)
[08:26:26.724] }
[08:26:26.724] Lazy evaluation: FALSE
[08:26:26.724] Asynchronous evaluation: TRUE
[08:26:26.724] Local evaluation: TRUE
[08:26:26.724] Environment: R_GlobalEnv
[08:26:26.724] Capture standard output: TRUE
[08:26:26.724] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:26.724] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 680 bytes, DotDotDotList ‘future.call.arguments’ of 183 bytes, list ‘...future.elements_ii’ of 114 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:26.724] Packages: <none>
[08:26:26.724] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:26.724] Resolved: FALSE
[08:26:26.724] Value: <not collected>
[08:26:26.724] Conditions captured: <none>
[08:26:26.724] Early signaling: FALSE
[08:26:26.724] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:26.724] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:26.735] Chunk #1 of 2 ... DONE
[08:26:26.735] Chunk #2 of 2 ...
[08:26:26.735]  - Finding globals in 'X' for chunk #2 ...
[08:26:26.735] getGlobalsAndPackages() ...
[08:26:26.735] Searching for globals...
[08:26:26.736] 
[08:26:26.736] Searching for globals ... DONE
[08:26:26.736] - globals: [0] <none>
[08:26:26.736] getGlobalsAndPackages() ... DONE
[08:26:26.736]    + additional globals found: [n=0] 
[08:26:26.736]    + additional namespaces needed: [n=0] 
[08:26:26.736]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:26.736]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:26.736]  - seeds: <none>
[08:26:26.737]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.737] getGlobalsAndPackages() ...
[08:26:26.737] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.737] Resolving globals: FALSE
[08:26:26.737] Tweak future expression to call with '...' arguments ...
[08:26:26.737] {
[08:26:26.737]     do.call(function(...) {
[08:26:26.737]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:26.737]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:26.737]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:26.737]             on.exit(options(oopts), add = TRUE)
[08:26:26.737]         }
[08:26:26.737]         {
[08:26:26.737]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:26.737]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:26.737]                 ...future.FUN(...future.X_jj, ...)
[08:26:26.737]             })
[08:26:26.737]         }
[08:26:26.737]     }, args = future.call.arguments)
[08:26:26.737] }
[08:26:26.737] Tweak future expression to call with '...' arguments ... DONE
[08:26:26.738] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.738] 
[08:26:26.738] getGlobalsAndPackages() ... DONE
[08:26:26.738] run() for ‘Future’ ...
[08:26:26.738] - state: ‘created’
[08:26:26.738] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:26.753] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:26.753] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:26.753]   - Field: ‘node’
[08:26:26.753]   - Field: ‘label’
[08:26:26.753]   - Field: ‘local’
[08:26:26.753]   - Field: ‘owner’
[08:26:26.753]   - Field: ‘envir’
[08:26:26.753]   - Field: ‘workers’
[08:26:26.753]   - Field: ‘packages’
[08:26:26.753]   - Field: ‘gc’
[08:26:26.754]   - Field: ‘conditions’
[08:26:26.754]   - Field: ‘persistent’
[08:26:26.754]   - Field: ‘expr’
[08:26:26.754]   - Field: ‘uuid’
[08:26:26.754]   - Field: ‘seed’
[08:26:26.754]   - Field: ‘version’
[08:26:26.754]   - Field: ‘result’
[08:26:26.754]   - Field: ‘asynchronous’
[08:26:26.754]   - Field: ‘calls’
[08:26:26.754]   - Field: ‘globals’
[08:26:26.754]   - Field: ‘stdout’
[08:26:26.754]   - Field: ‘earlySignal’
[08:26:26.755]   - Field: ‘lazy’
[08:26:26.755]   - Field: ‘state’
[08:26:26.755] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:26.755] - Launch lazy future ...
[08:26:26.755] Packages needed by the future expression (n = 0): <none>
[08:26:26.755] Packages needed by future strategies (n = 0): <none>
[08:26:26.756] {
[08:26:26.756]     {
[08:26:26.756]         {
[08:26:26.756]             ...future.startTime <- base::Sys.time()
[08:26:26.756]             {
[08:26:26.756]                 {
[08:26:26.756]                   {
[08:26:26.756]                     {
[08:26:26.756]                       base::local({
[08:26:26.756]                         has_future <- base::requireNamespace("future", 
[08:26:26.756]                           quietly = TRUE)
[08:26:26.756]                         if (has_future) {
[08:26:26.756]                           ns <- base::getNamespace("future")
[08:26:26.756]                           version <- ns[[".package"]][["version"]]
[08:26:26.756]                           if (is.null(version)) 
[08:26:26.756]                             version <- utils::packageVersion("future")
[08:26:26.756]                         }
[08:26:26.756]                         else {
[08:26:26.756]                           version <- NULL
[08:26:26.756]                         }
[08:26:26.756]                         if (!has_future || version < "1.8.0") {
[08:26:26.756]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:26.756]                             "", base::R.version$version.string), 
[08:26:26.756]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:26.756]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:26.756]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:26.756]                               "release", "version")], collapse = " "), 
[08:26:26.756]                             hostname = base::Sys.info()[["nodename"]])
[08:26:26.756]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:26.756]                             info)
[08:26:26.756]                           info <- base::paste(info, collapse = "; ")
[08:26:26.756]                           if (!has_future) {
[08:26:26.756]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:26.756]                               info)
[08:26:26.756]                           }
[08:26:26.756]                           else {
[08:26:26.756]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:26.756]                               info, version)
[08:26:26.756]                           }
[08:26:26.756]                           base::stop(msg)
[08:26:26.756]                         }
[08:26:26.756]                       })
[08:26:26.756]                     }
[08:26:26.756]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:26.756]                     base::options(mc.cores = 1L)
[08:26:26.756]                   }
[08:26:26.756]                   ...future.strategy.old <- future::plan("list")
[08:26:26.756]                   options(future.plan = NULL)
[08:26:26.756]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:26.756]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:26.756]                 }
[08:26:26.756]                 ...future.workdir <- getwd()
[08:26:26.756]             }
[08:26:26.756]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:26.756]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:26.756]         }
[08:26:26.756]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:26.756]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:26.756]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:26.756]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:26.756]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:26.756]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:26.756]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:26.756]             base::names(...future.oldOptions))
[08:26:26.756]     }
[08:26:26.756]     if (FALSE) {
[08:26:26.756]     }
[08:26:26.756]     else {
[08:26:26.756]         if (TRUE) {
[08:26:26.756]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:26.756]                 open = "w")
[08:26:26.756]         }
[08:26:26.756]         else {
[08:26:26.756]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:26.756]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:26.756]         }
[08:26:26.756]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:26.756]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:26.756]             base::sink(type = "output", split = FALSE)
[08:26:26.756]             base::close(...future.stdout)
[08:26:26.756]         }, add = TRUE)
[08:26:26.756]     }
[08:26:26.756]     ...future.frame <- base::sys.nframe()
[08:26:26.756]     ...future.conditions <- base::list()
[08:26:26.756]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:26.756]     if (FALSE) {
[08:26:26.756]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:26.756]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:26.756]     }
[08:26:26.756]     ...future.result <- base::tryCatch({
[08:26:26.756]         base::withCallingHandlers({
[08:26:26.756]             ...future.value <- base::withVisible(base::local({
[08:26:26.756]                 ...future.makeSendCondition <- base::local({
[08:26:26.756]                   sendCondition <- NULL
[08:26:26.756]                   function(frame = 1L) {
[08:26:26.756]                     if (is.function(sendCondition)) 
[08:26:26.756]                       return(sendCondition)
[08:26:26.756]                     ns <- getNamespace("parallel")
[08:26:26.756]                     if (exists("sendData", mode = "function", 
[08:26:26.756]                       envir = ns)) {
[08:26:26.756]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:26.756]                         envir = ns)
[08:26:26.756]                       envir <- sys.frame(frame)
[08:26:26.756]                       master <- NULL
[08:26:26.756]                       while (!identical(envir, .GlobalEnv) && 
[08:26:26.756]                         !identical(envir, emptyenv())) {
[08:26:26.756]                         if (exists("master", mode = "list", envir = envir, 
[08:26:26.756]                           inherits = FALSE)) {
[08:26:26.756]                           master <- get("master", mode = "list", 
[08:26:26.756]                             envir = envir, inherits = FALSE)
[08:26:26.756]                           if (inherits(master, c("SOCKnode", 
[08:26:26.756]                             "SOCK0node"))) {
[08:26:26.756]                             sendCondition <<- function(cond) {
[08:26:26.756]                               data <- list(type = "VALUE", value = cond, 
[08:26:26.756]                                 success = TRUE)
[08:26:26.756]                               parallel_sendData(master, data)
[08:26:26.756]                             }
[08:26:26.756]                             return(sendCondition)
[08:26:26.756]                           }
[08:26:26.756]                         }
[08:26:26.756]                         frame <- frame + 1L
[08:26:26.756]                         envir <- sys.frame(frame)
[08:26:26.756]                       }
[08:26:26.756]                     }
[08:26:26.756]                     sendCondition <<- function(cond) NULL
[08:26:26.756]                   }
[08:26:26.756]                 })
[08:26:26.756]                 withCallingHandlers({
[08:26:26.756]                   {
[08:26:26.756]                     do.call(function(...) {
[08:26:26.756]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:26.756]                       if (!identical(...future.globals.maxSize.org, 
[08:26:26.756]                         ...future.globals.maxSize)) {
[08:26:26.756]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:26.756]                         on.exit(options(oopts), add = TRUE)
[08:26:26.756]                       }
[08:26:26.756]                       {
[08:26:26.756]                         lapply(seq_along(...future.elements_ii), 
[08:26:26.756]                           FUN = function(jj) {
[08:26:26.756]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:26.756]                             ...future.FUN(...future.X_jj, ...)
[08:26:26.756]                           })
[08:26:26.756]                       }
[08:26:26.756]                     }, args = future.call.arguments)
[08:26:26.756]                   }
[08:26:26.756]                 }, immediateCondition = function(cond) {
[08:26:26.756]                   sendCondition <- ...future.makeSendCondition()
[08:26:26.756]                   sendCondition(cond)
[08:26:26.756]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:26.756]                   {
[08:26:26.756]                     inherits <- base::inherits
[08:26:26.756]                     invokeRestart <- base::invokeRestart
[08:26:26.756]                     is.null <- base::is.null
[08:26:26.756]                     muffled <- FALSE
[08:26:26.756]                     if (inherits(cond, "message")) {
[08:26:26.756]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:26.756]                       if (muffled) 
[08:26:26.756]                         invokeRestart("muffleMessage")
[08:26:26.756]                     }
[08:26:26.756]                     else if (inherits(cond, "warning")) {
[08:26:26.756]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:26.756]                       if (muffled) 
[08:26:26.756]                         invokeRestart("muffleWarning")
[08:26:26.756]                     }
[08:26:26.756]                     else if (inherits(cond, "condition")) {
[08:26:26.756]                       if (!is.null(pattern)) {
[08:26:26.756]                         computeRestarts <- base::computeRestarts
[08:26:26.756]                         grepl <- base::grepl
[08:26:26.756]                         restarts <- computeRestarts(cond)
[08:26:26.756]                         for (restart in restarts) {
[08:26:26.756]                           name <- restart$name
[08:26:26.756]                           if (is.null(name)) 
[08:26:26.756]                             next
[08:26:26.756]                           if (!grepl(pattern, name)) 
[08:26:26.756]                             next
[08:26:26.756]                           invokeRestart(restart)
[08:26:26.756]                           muffled <- TRUE
[08:26:26.756]                           break
[08:26:26.756]                         }
[08:26:26.756]                       }
[08:26:26.756]                     }
[08:26:26.756]                     invisible(muffled)
[08:26:26.756]                   }
[08:26:26.756]                   muffleCondition(cond)
[08:26:26.756]                 })
[08:26:26.756]             }))
[08:26:26.756]             future::FutureResult(value = ...future.value$value, 
[08:26:26.756]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:26.756]                   ...future.rng), globalenv = if (FALSE) 
[08:26:26.756]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:26.756]                     ...future.globalenv.names))
[08:26:26.756]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:26.756]         }, condition = base::local({
[08:26:26.756]             c <- base::c
[08:26:26.756]             inherits <- base::inherits
[08:26:26.756]             invokeRestart <- base::invokeRestart
[08:26:26.756]             length <- base::length
[08:26:26.756]             list <- base::list
[08:26:26.756]             seq.int <- base::seq.int
[08:26:26.756]             signalCondition <- base::signalCondition
[08:26:26.756]             sys.calls <- base::sys.calls
[08:26:26.756]             `[[` <- base::`[[`
[08:26:26.756]             `+` <- base::`+`
[08:26:26.756]             `<<-` <- base::`<<-`
[08:26:26.756]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:26.756]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:26.756]                   3L)]
[08:26:26.756]             }
[08:26:26.756]             function(cond) {
[08:26:26.756]                 is_error <- inherits(cond, "error")
[08:26:26.756]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:26.756]                   NULL)
[08:26:26.756]                 if (is_error) {
[08:26:26.756]                   sessionInformation <- function() {
[08:26:26.756]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:26.756]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:26.756]                       search = base::search(), system = base::Sys.info())
[08:26:26.756]                   }
[08:26:26.756]                   ...future.conditions[[length(...future.conditions) + 
[08:26:26.756]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:26.756]                     cond$call), session = sessionInformation(), 
[08:26:26.756]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:26.756]                   signalCondition(cond)
[08:26:26.756]                 }
[08:26:26.756]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:26.756]                 "immediateCondition"))) {
[08:26:26.756]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:26.756]                   ...future.conditions[[length(...future.conditions) + 
[08:26:26.756]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:26.756]                   if (TRUE && !signal) {
[08:26:26.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:26.756]                     {
[08:26:26.756]                       inherits <- base::inherits
[08:26:26.756]                       invokeRestart <- base::invokeRestart
[08:26:26.756]                       is.null <- base::is.null
[08:26:26.756]                       muffled <- FALSE
[08:26:26.756]                       if (inherits(cond, "message")) {
[08:26:26.756]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:26.756]                         if (muffled) 
[08:26:26.756]                           invokeRestart("muffleMessage")
[08:26:26.756]                       }
[08:26:26.756]                       else if (inherits(cond, "warning")) {
[08:26:26.756]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:26.756]                         if (muffled) 
[08:26:26.756]                           invokeRestart("muffleWarning")
[08:26:26.756]                       }
[08:26:26.756]                       else if (inherits(cond, "condition")) {
[08:26:26.756]                         if (!is.null(pattern)) {
[08:26:26.756]                           computeRestarts <- base::computeRestarts
[08:26:26.756]                           grepl <- base::grepl
[08:26:26.756]                           restarts <- computeRestarts(cond)
[08:26:26.756]                           for (restart in restarts) {
[08:26:26.756]                             name <- restart$name
[08:26:26.756]                             if (is.null(name)) 
[08:26:26.756]                               next
[08:26:26.756]                             if (!grepl(pattern, name)) 
[08:26:26.756]                               next
[08:26:26.756]                             invokeRestart(restart)
[08:26:26.756]                             muffled <- TRUE
[08:26:26.756]                             break
[08:26:26.756]                           }
[08:26:26.756]                         }
[08:26:26.756]                       }
[08:26:26.756]                       invisible(muffled)
[08:26:26.756]                     }
[08:26:26.756]                     muffleCondition(cond, pattern = "^muffle")
[08:26:26.756]                   }
[08:26:26.756]                 }
[08:26:26.756]                 else {
[08:26:26.756]                   if (TRUE) {
[08:26:26.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:26.756]                     {
[08:26:26.756]                       inherits <- base::inherits
[08:26:26.756]                       invokeRestart <- base::invokeRestart
[08:26:26.756]                       is.null <- base::is.null
[08:26:26.756]                       muffled <- FALSE
[08:26:26.756]                       if (inherits(cond, "message")) {
[08:26:26.756]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:26.756]                         if (muffled) 
[08:26:26.756]                           invokeRestart("muffleMessage")
[08:26:26.756]                       }
[08:26:26.756]                       else if (inherits(cond, "warning")) {
[08:26:26.756]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:26.756]                         if (muffled) 
[08:26:26.756]                           invokeRestart("muffleWarning")
[08:26:26.756]                       }
[08:26:26.756]                       else if (inherits(cond, "condition")) {
[08:26:26.756]                         if (!is.null(pattern)) {
[08:26:26.756]                           computeRestarts <- base::computeRestarts
[08:26:26.756]                           grepl <- base::grepl
[08:26:26.756]                           restarts <- computeRestarts(cond)
[08:26:26.756]                           for (restart in restarts) {
[08:26:26.756]                             name <- restart$name
[08:26:26.756]                             if (is.null(name)) 
[08:26:26.756]                               next
[08:26:26.756]                             if (!grepl(pattern, name)) 
[08:26:26.756]                               next
[08:26:26.756]                             invokeRestart(restart)
[08:26:26.756]                             muffled <- TRUE
[08:26:26.756]                             break
[08:26:26.756]                           }
[08:26:26.756]                         }
[08:26:26.756]                       }
[08:26:26.756]                       invisible(muffled)
[08:26:26.756]                     }
[08:26:26.756]                     muffleCondition(cond, pattern = "^muffle")
[08:26:26.756]                   }
[08:26:26.756]                 }
[08:26:26.756]             }
[08:26:26.756]         }))
[08:26:26.756]     }, error = function(ex) {
[08:26:26.756]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:26.756]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:26.756]                 ...future.rng), started = ...future.startTime, 
[08:26:26.756]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:26.756]             version = "1.8"), class = "FutureResult")
[08:26:26.756]     }, finally = {
[08:26:26.756]         if (!identical(...future.workdir, getwd())) 
[08:26:26.756]             setwd(...future.workdir)
[08:26:26.756]         {
[08:26:26.756]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:26.756]                 ...future.oldOptions$nwarnings <- NULL
[08:26:26.756]             }
[08:26:26.756]             base::options(...future.oldOptions)
[08:26:26.756]             if (.Platform$OS.type == "windows") {
[08:26:26.756]                 old_names <- names(...future.oldEnvVars)
[08:26:26.756]                 envs <- base::Sys.getenv()
[08:26:26.756]                 names <- names(envs)
[08:26:26.756]                 common <- intersect(names, old_names)
[08:26:26.756]                 added <- setdiff(names, old_names)
[08:26:26.756]                 removed <- setdiff(old_names, names)
[08:26:26.756]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:26.756]                   envs[common]]
[08:26:26.756]                 NAMES <- toupper(changed)
[08:26:26.756]                 args <- list()
[08:26:26.756]                 for (kk in seq_along(NAMES)) {
[08:26:26.756]                   name <- changed[[kk]]
[08:26:26.756]                   NAME <- NAMES[[kk]]
[08:26:26.756]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:26.756]                     next
[08:26:26.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:26.756]                 }
[08:26:26.756]                 NAMES <- toupper(added)
[08:26:26.756]                 for (kk in seq_along(NAMES)) {
[08:26:26.756]                   name <- added[[kk]]
[08:26:26.756]                   NAME <- NAMES[[kk]]
[08:26:26.756]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:26.756]                     next
[08:26:26.756]                   args[[name]] <- ""
[08:26:26.756]                 }
[08:26:26.756]                 NAMES <- toupper(removed)
[08:26:26.756]                 for (kk in seq_along(NAMES)) {
[08:26:26.756]                   name <- removed[[kk]]
[08:26:26.756]                   NAME <- NAMES[[kk]]
[08:26:26.756]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:26.756]                     next
[08:26:26.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:26.756]                 }
[08:26:26.756]                 if (length(args) > 0) 
[08:26:26.756]                   base::do.call(base::Sys.setenv, args = args)
[08:26:26.756]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:26.756]             }
[08:26:26.756]             else {
[08:26:26.756]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:26.756]             }
[08:26:26.756]             {
[08:26:26.756]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:26.756]                   0L) {
[08:26:26.756]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:26.756]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:26.756]                   base::options(opts)
[08:26:26.756]                 }
[08:26:26.756]                 {
[08:26:26.756]                   {
[08:26:26.756]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:26.756]                     NULL
[08:26:26.756]                   }
[08:26:26.756]                   options(future.plan = NULL)
[08:26:26.756]                   if (is.na(NA_character_)) 
[08:26:26.756]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:26.756]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:26.756]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:26.756]                     .init = FALSE)
[08:26:26.756]                 }
[08:26:26.756]             }
[08:26:26.756]         }
[08:26:26.756]     })
[08:26:26.756]     if (TRUE) {
[08:26:26.756]         base::sink(type = "output", split = FALSE)
[08:26:26.756]         if (TRUE) {
[08:26:26.756]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:26.756]         }
[08:26:26.756]         else {
[08:26:26.756]             ...future.result["stdout"] <- base::list(NULL)
[08:26:26.756]         }
[08:26:26.756]         base::close(...future.stdout)
[08:26:26.756]         ...future.stdout <- NULL
[08:26:26.756]     }
[08:26:26.756]     ...future.result$conditions <- ...future.conditions
[08:26:26.756]     ...future.result$finished <- base::Sys.time()
[08:26:26.756]     ...future.result
[08:26:26.756] }
[08:26:26.759] Exporting 5 global objects (1.43 KiB) to cluster node #2 ...
[08:26:26.759] Exporting ‘...future.FUN’ (680 bytes) to cluster node #2 ...
[08:26:26.759] Exporting ‘...future.FUN’ (680 bytes) to cluster node #2 ... DONE
[08:26:26.759] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #2 ...
[08:26:26.760] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #2 ... DONE
[08:26:26.760] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #2 ...
[08:26:26.760] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #2 ... DONE
[08:26:26.760] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:26:26.761] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:26:26.761] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:26:26.761] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:26:26.761] Exporting 5 global objects (1.43 KiB) to cluster node #2 ... DONE
[08:26:26.762] MultisessionFuture started
[08:26:26.762] - Launch lazy future ... done
[08:26:26.762] run() for ‘MultisessionFuture’ ... done
[08:26:26.762] Created future:
[08:26:26.762] MultisessionFuture:
[08:26:26.762] Label: ‘future_sapply-2’
[08:26:26.762] Expression:
[08:26:26.762] {
[08:26:26.762]     do.call(function(...) {
[08:26:26.762]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:26.762]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:26.762]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:26.762]             on.exit(options(oopts), add = TRUE)
[08:26:26.762]         }
[08:26:26.762]         {
[08:26:26.762]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:26.762]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:26.762]                 ...future.FUN(...future.X_jj, ...)
[08:26:26.762]             })
[08:26:26.762]         }
[08:26:26.762]     }, args = future.call.arguments)
[08:26:26.762] }
[08:26:26.762] Lazy evaluation: FALSE
[08:26:26.762] Asynchronous evaluation: TRUE
[08:26:26.762] Local evaluation: TRUE
[08:26:26.762] Environment: R_GlobalEnv
[08:26:26.762] Capture standard output: TRUE
[08:26:26.762] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:26.762] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 680 bytes, DotDotDotList ‘future.call.arguments’ of 183 bytes, list ‘...future.elements_ii’ of 114 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:26.762] Packages: <none>
[08:26:26.762] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:26.762] Resolved: FALSE
[08:26:26.762] Value: <not collected>
[08:26:26.762] Conditions captured: <none>
[08:26:26.762] Early signaling: FALSE
[08:26:26.762] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:26.762] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:26.774] Chunk #2 of 2 ... DONE
[08:26:26.774] Launching 2 futures (chunks) ... DONE
[08:26:26.774] Resolving 2 futures (chunks) ...
[08:26:26.774] resolve() on list ...
[08:26:26.774]  recursive: 0
[08:26:26.775]  length: 2
[08:26:26.777] 
[08:26:26.778] receiveMessageFromWorker() for ClusterFuture ...
[08:26:26.778] - Validating connection of MultisessionFuture
[08:26:26.778] - received message: FutureResult
[08:26:26.778] - Received FutureResult
[08:26:26.778] - Erased future from FutureRegistry
[08:26:26.778] result() for ClusterFuture ...
[08:26:26.779] - result already collected: FutureResult
[08:26:26.779] result() for ClusterFuture ... done
[08:26:26.779] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:26.779] Future #1
[08:26:26.779] result() for ClusterFuture ...
[08:26:26.779] - result already collected: FutureResult
[08:26:26.779] result() for ClusterFuture ... done
[08:26:26.779] result() for ClusterFuture ...
[08:26:26.779] - result already collected: FutureResult
[08:26:26.779] result() for ClusterFuture ... done
[08:26:26.779] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:26:26.780] - nx: 2
[08:26:26.780] - relay: TRUE
[08:26:26.780] - stdout: TRUE
[08:26:26.780] - signal: TRUE
[08:26:26.780] - resignal: FALSE
[08:26:26.780] - force: TRUE
[08:26:26.780] - relayed: [n=2] FALSE, FALSE
[08:26:26.780] - queued futures: [n=2] FALSE, FALSE
[08:26:26.780]  - until=1
[08:26:26.780]  - relaying element #1
[08:26:26.780] result() for ClusterFuture ...
[08:26:26.780] - result already collected: FutureResult
[08:26:26.780] result() for ClusterFuture ... done
[08:26:26.781] result() for ClusterFuture ...
[08:26:26.781] - result already collected: FutureResult
[08:26:26.781] result() for ClusterFuture ... done
[08:26:26.781] result() for ClusterFuture ...
[08:26:26.781] - result already collected: FutureResult
[08:26:26.781] result() for ClusterFuture ... done
[08:26:26.781] result() for ClusterFuture ...
[08:26:26.781] - result already collected: FutureResult
[08:26:26.781] result() for ClusterFuture ... done
[08:26:26.781] - relayed: [n=2] TRUE, FALSE
[08:26:26.781] - queued futures: [n=2] TRUE, FALSE
[08:26:26.781] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:26:26.782]  length: 1 (resolved future 1)
[08:26:26.805] receiveMessageFromWorker() for ClusterFuture ...
[08:26:26.805] - Validating connection of MultisessionFuture
[08:26:26.805] - received message: FutureResult
[08:26:26.805] - Received FutureResult
[08:26:26.805] - Erased future from FutureRegistry
[08:26:26.806] result() for ClusterFuture ...
[08:26:26.806] - result already collected: FutureResult
[08:26:26.806] result() for ClusterFuture ... done
[08:26:26.806] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:26.806] Future #2
[08:26:26.806] result() for ClusterFuture ...
[08:26:26.806] - result already collected: FutureResult
[08:26:26.806] result() for ClusterFuture ... done
[08:26:26.806] result() for ClusterFuture ...
[08:26:26.806] - result already collected: FutureResult
[08:26:26.806] result() for ClusterFuture ... done
[08:26:26.807] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:26:26.807] - nx: 2
[08:26:26.807] - relay: TRUE
[08:26:26.807] - stdout: TRUE
[08:26:26.807] - signal: TRUE
[08:26:26.807] - resignal: FALSE
[08:26:26.807] - force: TRUE
[08:26:26.807] - relayed: [n=2] TRUE, FALSE
[08:26:26.807] - queued futures: [n=2] TRUE, FALSE
[08:26:26.807]  - until=2
[08:26:26.807]  - relaying element #2
[08:26:26.807] result() for ClusterFuture ...
[08:26:26.808] - result already collected: FutureResult
[08:26:26.808] result() for ClusterFuture ... done
[08:26:26.808] result() for ClusterFuture ...
[08:26:26.808] - result already collected: FutureResult
[08:26:26.808] result() for ClusterFuture ... done
[08:26:26.808] result() for ClusterFuture ...
[08:26:26.808] - result already collected: FutureResult
[08:26:26.808] result() for ClusterFuture ... done
[08:26:26.808] result() for ClusterFuture ...
[08:26:26.808] - result already collected: FutureResult
[08:26:26.808] result() for ClusterFuture ... done
[08:26:26.808] - relayed: [n=2] TRUE, TRUE
[08:26:26.809] - queued futures: [n=2] TRUE, TRUE
[08:26:26.809] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:26:26.809]  length: 0 (resolved future 2)
[08:26:26.809] Relaying remaining futures
[08:26:26.809] signalConditionsASAP(NULL, pos=0) ...
[08:26:26.809] - nx: 2
[08:26:26.809] - relay: TRUE
[08:26:26.809] - stdout: TRUE
[08:26:26.809] - signal: TRUE
[08:26:26.809] - resignal: FALSE
[08:26:26.809] - force: TRUE
[08:26:26.809] - relayed: [n=2] TRUE, TRUE
[08:26:26.810] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:26.810] - relayed: [n=2] TRUE, TRUE
[08:26:26.810] - queued futures: [n=2] TRUE, TRUE
[08:26:26.810] signalConditionsASAP(NULL, pos=0) ... done
[08:26:26.810] resolve() on list ... DONE
[08:26:26.810] result() for ClusterFuture ...
[08:26:26.810] - result already collected: FutureResult
[08:26:26.810] result() for ClusterFuture ... done
[08:26:26.810] result() for ClusterFuture ...
[08:26:26.810] - result already collected: FutureResult
[08:26:26.810] result() for ClusterFuture ... done
[08:26:26.811] result() for ClusterFuture ...
[08:26:26.811] - result already collected: FutureResult
[08:26:26.811] result() for ClusterFuture ... done
[08:26:26.811] result() for ClusterFuture ...
[08:26:26.811] - result already collected: FutureResult
[08:26:26.811] result() for ClusterFuture ... done
[08:26:26.811]  - Number of value chunks collected: 2
[08:26:26.811] Resolving 2 futures (chunks) ... DONE
[08:26:26.811] Reducing values from 2 chunks ...
[08:26:26.811]  - Number of values collected after concatenation: 4
[08:26:26.811]  - Number of values expected: 4
[08:26:26.812] Reducing values from 2 chunks ... DONE
[08:26:26.812] future_lapply() ... DONE
[08:26:26.812] future_lapply() ...
[08:26:26.816] Number of chunks: 2
[08:26:26.816] getGlobalsAndPackagesXApply() ...
[08:26:26.816]  - future.globals: TRUE
[08:26:26.816] getGlobalsAndPackages() ...
[08:26:26.816] Searching for globals...
[08:26:26.820] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[08:26:26.820] Searching for globals ... DONE
[08:26:26.820] Resolving globals: FALSE
[08:26:26.821] The total size of the 7 globals is 14.32 KiB (14666 bytes)
[08:26:26.821] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 14.32 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.67 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:26.821] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:26.821] - packages: [1] ‘future.apply’
[08:26:26.821] getGlobalsAndPackages() ... DONE
[08:26:26.822]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:26.822]  - needed namespaces: [n=1] ‘future.apply’
[08:26:26.822] Finding globals ... DONE
[08:26:26.822]  - use_args: TRUE
[08:26:26.822]  - Getting '...' globals ...
[08:26:26.822] resolve() on list ...
[08:26:26.822]  recursive: 0
[08:26:26.822]  length: 1
[08:26:26.822]  elements: ‘...’
[08:26:26.823]  length: 0 (resolved future 1)
[08:26:26.823] resolve() on list ... DONE
[08:26:26.823]    - '...' content: [n=1] ‘y’
[08:26:26.823] List of 1
[08:26:26.823]  $ ...:List of 1
[08:26:26.823]   ..$ y: num [1:5] 2 4 6 8 10
[08:26:26.823]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:26.823]  - attr(*, "where")=List of 1
[08:26:26.823]   ..$ ...:<environment: 0x562ca7a85dc0> 
[08:26:26.823]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:26.823]  - attr(*, "resolved")= logi TRUE
[08:26:26.823]  - attr(*, "total_size")= num NA
[08:26:26.826]  - Getting '...' globals ... DONE
[08:26:26.826] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:26.826] List of 8
[08:26:26.826]  $ ...future.FUN:function (x, ...)  
[08:26:26.826]  $ x_FUN        :function (x, y)  
[08:26:26.826]  $ times        : int 15
[08:26:26.826]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:26.826]  $ stop_if_not  :function (...)  
[08:26:26.826]  $ dim          : int [1:2] 3 5
[08:26:26.826]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:26.826]  $ ...          :List of 1
[08:26:26.826]   ..$ y: num [1:5] 2 4 6 8 10
[08:26:26.826]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:26.826]  - attr(*, "where")=List of 8
[08:26:26.826]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:26.826]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:26.826]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:26.826]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:26.826]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:26.826]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:26.826]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:26.826]   ..$ ...          :<environment: 0x562ca7a85dc0> 
[08:26:26.826]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:26.826]  - attr(*, "resolved")= logi FALSE
[08:26:26.826]  - attr(*, "total_size")= num 26659
[08:26:26.832] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:26.832] getGlobalsAndPackagesXApply() ... DONE
[08:26:26.832] Number of futures (= number of chunks): 2
[08:26:26.832] Launching 2 futures (chunks) ...
[08:26:26.832] Chunk #1 of 2 ...
[08:26:26.832]  - Finding globals in 'X' for chunk #1 ...
[08:26:26.832] getGlobalsAndPackages() ...
[08:26:26.833] Searching for globals...
[08:26:26.833] 
[08:26:26.833] Searching for globals ... DONE
[08:26:26.833] - globals: [0] <none>
[08:26:26.833] getGlobalsAndPackages() ... DONE
[08:26:26.833]    + additional globals found: [n=0] 
[08:26:26.833]    + additional namespaces needed: [n=0] 
[08:26:26.833]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:26.833]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:26.833]  - seeds: <none>
[08:26:26.834]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.834] getGlobalsAndPackages() ...
[08:26:26.834] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.834] Resolving globals: FALSE
[08:26:26.834] Tweak future expression to call with '...' arguments ...
[08:26:26.834] {
[08:26:26.834]     do.call(function(...) {
[08:26:26.834]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:26.834]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:26.834]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:26.834]             on.exit(options(oopts), add = TRUE)
[08:26:26.834]         }
[08:26:26.834]         {
[08:26:26.834]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:26.834]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:26.834]                 ...future.FUN(...future.X_jj, ...)
[08:26:26.834]             })
[08:26:26.834]         }
[08:26:26.834]     }, args = future.call.arguments)
[08:26:26.834] }
[08:26:26.834] Tweak future expression to call with '...' arguments ... DONE
[08:26:26.835] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.835] - packages: [1] ‘future.apply’
[08:26:26.835] getGlobalsAndPackages() ... DONE
[08:26:26.835] run() for ‘Future’ ...
[08:26:26.835] - state: ‘created’
[08:26:26.836] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:26.850] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:26.850] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:26.850]   - Field: ‘node’
[08:26:26.850]   - Field: ‘label’
[08:26:26.851]   - Field: ‘local’
[08:26:26.851]   - Field: ‘owner’
[08:26:26.851]   - Field: ‘envir’
[08:26:26.851]   - Field: ‘workers’
[08:26:26.851]   - Field: ‘packages’
[08:26:26.851]   - Field: ‘gc’
[08:26:26.851]   - Field: ‘conditions’
[08:26:26.851]   - Field: ‘persistent’
[08:26:26.851]   - Field: ‘expr’
[08:26:26.851]   - Field: ‘uuid’
[08:26:26.851]   - Field: ‘seed’
[08:26:26.852]   - Field: ‘version’
[08:26:26.852]   - Field: ‘result’
[08:26:26.852]   - Field: ‘asynchronous’
[08:26:26.852]   - Field: ‘calls’
[08:26:26.852]   - Field: ‘globals’
[08:26:26.852]   - Field: ‘stdout’
[08:26:26.852]   - Field: ‘earlySignal’
[08:26:26.852]   - Field: ‘lazy’
[08:26:26.852]   - Field: ‘state’
[08:26:26.852] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:26.852] - Launch lazy future ...
[08:26:26.853] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:26.853] Packages needed by future strategies (n = 0): <none>
[08:26:26.853] {
[08:26:26.853]     {
[08:26:26.853]         {
[08:26:26.853]             ...future.startTime <- base::Sys.time()
[08:26:26.853]             {
[08:26:26.853]                 {
[08:26:26.853]                   {
[08:26:26.853]                     {
[08:26:26.853]                       {
[08:26:26.853]                         base::local({
[08:26:26.853]                           has_future <- base::requireNamespace("future", 
[08:26:26.853]                             quietly = TRUE)
[08:26:26.853]                           if (has_future) {
[08:26:26.853]                             ns <- base::getNamespace("future")
[08:26:26.853]                             version <- ns[[".package"]][["version"]]
[08:26:26.853]                             if (is.null(version)) 
[08:26:26.853]                               version <- utils::packageVersion("future")
[08:26:26.853]                           }
[08:26:26.853]                           else {
[08:26:26.853]                             version <- NULL
[08:26:26.853]                           }
[08:26:26.853]                           if (!has_future || version < "1.8.0") {
[08:26:26.853]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:26.853]                               "", base::R.version$version.string), 
[08:26:26.853]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:26.853]                                 base::R.version$platform, 8 * 
[08:26:26.853]                                   base::.Machine$sizeof.pointer), 
[08:26:26.853]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:26.853]                                 "release", "version")], collapse = " "), 
[08:26:26.853]                               hostname = base::Sys.info()[["nodename"]])
[08:26:26.853]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:26.853]                               info)
[08:26:26.853]                             info <- base::paste(info, collapse = "; ")
[08:26:26.853]                             if (!has_future) {
[08:26:26.853]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:26.853]                                 info)
[08:26:26.853]                             }
[08:26:26.853]                             else {
[08:26:26.853]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:26.853]                                 info, version)
[08:26:26.853]                             }
[08:26:26.853]                             base::stop(msg)
[08:26:26.853]                           }
[08:26:26.853]                         })
[08:26:26.853]                       }
[08:26:26.853]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:26.853]                       base::options(mc.cores = 1L)
[08:26:26.853]                     }
[08:26:26.853]                     base::local({
[08:26:26.853]                       for (pkg in "future.apply") {
[08:26:26.853]                         base::loadNamespace(pkg)
[08:26:26.853]                         base::library(pkg, character.only = TRUE)
[08:26:26.853]                       }
[08:26:26.853]                     })
[08:26:26.853]                   }
[08:26:26.853]                   ...future.strategy.old <- future::plan("list")
[08:26:26.853]                   options(future.plan = NULL)
[08:26:26.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:26.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:26.853]                 }
[08:26:26.853]                 ...future.workdir <- getwd()
[08:26:26.853]             }
[08:26:26.853]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:26.853]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:26.853]         }
[08:26:26.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:26.853]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:26.853]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:26.853]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:26.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:26.853]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:26.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:26.853]             base::names(...future.oldOptions))
[08:26:26.853]     }
[08:26:26.853]     if (FALSE) {
[08:26:26.853]     }
[08:26:26.853]     else {
[08:26:26.853]         if (TRUE) {
[08:26:26.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:26.853]                 open = "w")
[08:26:26.853]         }
[08:26:26.853]         else {
[08:26:26.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:26.853]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:26.853]         }
[08:26:26.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:26.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:26.853]             base::sink(type = "output", split = FALSE)
[08:26:26.853]             base::close(...future.stdout)
[08:26:26.853]         }, add = TRUE)
[08:26:26.853]     }
[08:26:26.853]     ...future.frame <- base::sys.nframe()
[08:26:26.853]     ...future.conditions <- base::list()
[08:26:26.853]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:26.853]     if (FALSE) {
[08:26:26.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:26.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:26.853]     }
[08:26:26.853]     ...future.result <- base::tryCatch({
[08:26:26.853]         base::withCallingHandlers({
[08:26:26.853]             ...future.value <- base::withVisible(base::local({
[08:26:26.853]                 ...future.makeSendCondition <- base::local({
[08:26:26.853]                   sendCondition <- NULL
[08:26:26.853]                   function(frame = 1L) {
[08:26:26.853]                     if (is.function(sendCondition)) 
[08:26:26.853]                       return(sendCondition)
[08:26:26.853]                     ns <- getNamespace("parallel")
[08:26:26.853]                     if (exists("sendData", mode = "function", 
[08:26:26.853]                       envir = ns)) {
[08:26:26.853]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:26.853]                         envir = ns)
[08:26:26.853]                       envir <- sys.frame(frame)
[08:26:26.853]                       master <- NULL
[08:26:26.853]                       while (!identical(envir, .GlobalEnv) && 
[08:26:26.853]                         !identical(envir, emptyenv())) {
[08:26:26.853]                         if (exists("master", mode = "list", envir = envir, 
[08:26:26.853]                           inherits = FALSE)) {
[08:26:26.853]                           master <- get("master", mode = "list", 
[08:26:26.853]                             envir = envir, inherits = FALSE)
[08:26:26.853]                           if (inherits(master, c("SOCKnode", 
[08:26:26.853]                             "SOCK0node"))) {
[08:26:26.853]                             sendCondition <<- function(cond) {
[08:26:26.853]                               data <- list(type = "VALUE", value = cond, 
[08:26:26.853]                                 success = TRUE)
[08:26:26.853]                               parallel_sendData(master, data)
[08:26:26.853]                             }
[08:26:26.853]                             return(sendCondition)
[08:26:26.853]                           }
[08:26:26.853]                         }
[08:26:26.853]                         frame <- frame + 1L
[08:26:26.853]                         envir <- sys.frame(frame)
[08:26:26.853]                       }
[08:26:26.853]                     }
[08:26:26.853]                     sendCondition <<- function(cond) NULL
[08:26:26.853]                   }
[08:26:26.853]                 })
[08:26:26.853]                 withCallingHandlers({
[08:26:26.853]                   {
[08:26:26.853]                     do.call(function(...) {
[08:26:26.853]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:26.853]                       if (!identical(...future.globals.maxSize.org, 
[08:26:26.853]                         ...future.globals.maxSize)) {
[08:26:26.853]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:26.853]                         on.exit(options(oopts), add = TRUE)
[08:26:26.853]                       }
[08:26:26.853]                       {
[08:26:26.853]                         lapply(seq_along(...future.elements_ii), 
[08:26:26.853]                           FUN = function(jj) {
[08:26:26.853]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:26.853]                             ...future.FUN(...future.X_jj, ...)
[08:26:26.853]                           })
[08:26:26.853]                       }
[08:26:26.853]                     }, args = future.call.arguments)
[08:26:26.853]                   }
[08:26:26.853]                 }, immediateCondition = function(cond) {
[08:26:26.853]                   sendCondition <- ...future.makeSendCondition()
[08:26:26.853]                   sendCondition(cond)
[08:26:26.853]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:26.853]                   {
[08:26:26.853]                     inherits <- base::inherits
[08:26:26.853]                     invokeRestart <- base::invokeRestart
[08:26:26.853]                     is.null <- base::is.null
[08:26:26.853]                     muffled <- FALSE
[08:26:26.853]                     if (inherits(cond, "message")) {
[08:26:26.853]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:26.853]                       if (muffled) 
[08:26:26.853]                         invokeRestart("muffleMessage")
[08:26:26.853]                     }
[08:26:26.853]                     else if (inherits(cond, "warning")) {
[08:26:26.853]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:26.853]                       if (muffled) 
[08:26:26.853]                         invokeRestart("muffleWarning")
[08:26:26.853]                     }
[08:26:26.853]                     else if (inherits(cond, "condition")) {
[08:26:26.853]                       if (!is.null(pattern)) {
[08:26:26.853]                         computeRestarts <- base::computeRestarts
[08:26:26.853]                         grepl <- base::grepl
[08:26:26.853]                         restarts <- computeRestarts(cond)
[08:26:26.853]                         for (restart in restarts) {
[08:26:26.853]                           name <- restart$name
[08:26:26.853]                           if (is.null(name)) 
[08:26:26.853]                             next
[08:26:26.853]                           if (!grepl(pattern, name)) 
[08:26:26.853]                             next
[08:26:26.853]                           invokeRestart(restart)
[08:26:26.853]                           muffled <- TRUE
[08:26:26.853]                           break
[08:26:26.853]                         }
[08:26:26.853]                       }
[08:26:26.853]                     }
[08:26:26.853]                     invisible(muffled)
[08:26:26.853]                   }
[08:26:26.853]                   muffleCondition(cond)
[08:26:26.853]                 })
[08:26:26.853]             }))
[08:26:26.853]             future::FutureResult(value = ...future.value$value, 
[08:26:26.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:26.853]                   ...future.rng), globalenv = if (FALSE) 
[08:26:26.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:26.853]                     ...future.globalenv.names))
[08:26:26.853]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:26.853]         }, condition = base::local({
[08:26:26.853]             c <- base::c
[08:26:26.853]             inherits <- base::inherits
[08:26:26.853]             invokeRestart <- base::invokeRestart
[08:26:26.853]             length <- base::length
[08:26:26.853]             list <- base::list
[08:26:26.853]             seq.int <- base::seq.int
[08:26:26.853]             signalCondition <- base::signalCondition
[08:26:26.853]             sys.calls <- base::sys.calls
[08:26:26.853]             `[[` <- base::`[[`
[08:26:26.853]             `+` <- base::`+`
[08:26:26.853]             `<<-` <- base::`<<-`
[08:26:26.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:26.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:26.853]                   3L)]
[08:26:26.853]             }
[08:26:26.853]             function(cond) {
[08:26:26.853]                 is_error <- inherits(cond, "error")
[08:26:26.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:26.853]                   NULL)
[08:26:26.853]                 if (is_error) {
[08:26:26.853]                   sessionInformation <- function() {
[08:26:26.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:26.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:26.853]                       search = base::search(), system = base::Sys.info())
[08:26:26.853]                   }
[08:26:26.853]                   ...future.conditions[[length(...future.conditions) + 
[08:26:26.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:26.853]                     cond$call), session = sessionInformation(), 
[08:26:26.853]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:26.853]                   signalCondition(cond)
[08:26:26.853]                 }
[08:26:26.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:26.853]                 "immediateCondition"))) {
[08:26:26.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:26.853]                   ...future.conditions[[length(...future.conditions) + 
[08:26:26.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:26.853]                   if (TRUE && !signal) {
[08:26:26.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:26.853]                     {
[08:26:26.853]                       inherits <- base::inherits
[08:26:26.853]                       invokeRestart <- base::invokeRestart
[08:26:26.853]                       is.null <- base::is.null
[08:26:26.853]                       muffled <- FALSE
[08:26:26.853]                       if (inherits(cond, "message")) {
[08:26:26.853]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:26.853]                         if (muffled) 
[08:26:26.853]                           invokeRestart("muffleMessage")
[08:26:26.853]                       }
[08:26:26.853]                       else if (inherits(cond, "warning")) {
[08:26:26.853]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:26.853]                         if (muffled) 
[08:26:26.853]                           invokeRestart("muffleWarning")
[08:26:26.853]                       }
[08:26:26.853]                       else if (inherits(cond, "condition")) {
[08:26:26.853]                         if (!is.null(pattern)) {
[08:26:26.853]                           computeRestarts <- base::computeRestarts
[08:26:26.853]                           grepl <- base::grepl
[08:26:26.853]                           restarts <- computeRestarts(cond)
[08:26:26.853]                           for (restart in restarts) {
[08:26:26.853]                             name <- restart$name
[08:26:26.853]                             if (is.null(name)) 
[08:26:26.853]                               next
[08:26:26.853]                             if (!grepl(pattern, name)) 
[08:26:26.853]                               next
[08:26:26.853]                             invokeRestart(restart)
[08:26:26.853]                             muffled <- TRUE
[08:26:26.853]                             break
[08:26:26.853]                           }
[08:26:26.853]                         }
[08:26:26.853]                       }
[08:26:26.853]                       invisible(muffled)
[08:26:26.853]                     }
[08:26:26.853]                     muffleCondition(cond, pattern = "^muffle")
[08:26:26.853]                   }
[08:26:26.853]                 }
[08:26:26.853]                 else {
[08:26:26.853]                   if (TRUE) {
[08:26:26.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:26.853]                     {
[08:26:26.853]                       inherits <- base::inherits
[08:26:26.853]                       invokeRestart <- base::invokeRestart
[08:26:26.853]                       is.null <- base::is.null
[08:26:26.853]                       muffled <- FALSE
[08:26:26.853]                       if (inherits(cond, "message")) {
[08:26:26.853]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:26.853]                         if (muffled) 
[08:26:26.853]                           invokeRestart("muffleMessage")
[08:26:26.853]                       }
[08:26:26.853]                       else if (inherits(cond, "warning")) {
[08:26:26.853]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:26.853]                         if (muffled) 
[08:26:26.853]                           invokeRestart("muffleWarning")
[08:26:26.853]                       }
[08:26:26.853]                       else if (inherits(cond, "condition")) {
[08:26:26.853]                         if (!is.null(pattern)) {
[08:26:26.853]                           computeRestarts <- base::computeRestarts
[08:26:26.853]                           grepl <- base::grepl
[08:26:26.853]                           restarts <- computeRestarts(cond)
[08:26:26.853]                           for (restart in restarts) {
[08:26:26.853]                             name <- restart$name
[08:26:26.853]                             if (is.null(name)) 
[08:26:26.853]                               next
[08:26:26.853]                             if (!grepl(pattern, name)) 
[08:26:26.853]                               next
[08:26:26.853]                             invokeRestart(restart)
[08:26:26.853]                             muffled <- TRUE
[08:26:26.853]                             break
[08:26:26.853]                           }
[08:26:26.853]                         }
[08:26:26.853]                       }
[08:26:26.853]                       invisible(muffled)
[08:26:26.853]                     }
[08:26:26.853]                     muffleCondition(cond, pattern = "^muffle")
[08:26:26.853]                   }
[08:26:26.853]                 }
[08:26:26.853]             }
[08:26:26.853]         }))
[08:26:26.853]     }, error = function(ex) {
[08:26:26.853]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:26.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:26.853]                 ...future.rng), started = ...future.startTime, 
[08:26:26.853]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:26.853]             version = "1.8"), class = "FutureResult")
[08:26:26.853]     }, finally = {
[08:26:26.853]         if (!identical(...future.workdir, getwd())) 
[08:26:26.853]             setwd(...future.workdir)
[08:26:26.853]         {
[08:26:26.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:26.853]                 ...future.oldOptions$nwarnings <- NULL
[08:26:26.853]             }
[08:26:26.853]             base::options(...future.oldOptions)
[08:26:26.853]             if (.Platform$OS.type == "windows") {
[08:26:26.853]                 old_names <- names(...future.oldEnvVars)
[08:26:26.853]                 envs <- base::Sys.getenv()
[08:26:26.853]                 names <- names(envs)
[08:26:26.853]                 common <- intersect(names, old_names)
[08:26:26.853]                 added <- setdiff(names, old_names)
[08:26:26.853]                 removed <- setdiff(old_names, names)
[08:26:26.853]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:26.853]                   envs[common]]
[08:26:26.853]                 NAMES <- toupper(changed)
[08:26:26.853]                 args <- list()
[08:26:26.853]                 for (kk in seq_along(NAMES)) {
[08:26:26.853]                   name <- changed[[kk]]
[08:26:26.853]                   NAME <- NAMES[[kk]]
[08:26:26.853]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:26.853]                     next
[08:26:26.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:26.853]                 }
[08:26:26.853]                 NAMES <- toupper(added)
[08:26:26.853]                 for (kk in seq_along(NAMES)) {
[08:26:26.853]                   name <- added[[kk]]
[08:26:26.853]                   NAME <- NAMES[[kk]]
[08:26:26.853]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:26.853]                     next
[08:26:26.853]                   args[[name]] <- ""
[08:26:26.853]                 }
[08:26:26.853]                 NAMES <- toupper(removed)
[08:26:26.853]                 for (kk in seq_along(NAMES)) {
[08:26:26.853]                   name <- removed[[kk]]
[08:26:26.853]                   NAME <- NAMES[[kk]]
[08:26:26.853]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:26.853]                     next
[08:26:26.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:26.853]                 }
[08:26:26.853]                 if (length(args) > 0) 
[08:26:26.853]                   base::do.call(base::Sys.setenv, args = args)
[08:26:26.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:26.853]             }
[08:26:26.853]             else {
[08:26:26.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:26.853]             }
[08:26:26.853]             {
[08:26:26.853]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:26.853]                   0L) {
[08:26:26.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:26.853]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:26.853]                   base::options(opts)
[08:26:26.853]                 }
[08:26:26.853]                 {
[08:26:26.853]                   {
[08:26:26.853]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:26.853]                     NULL
[08:26:26.853]                   }
[08:26:26.853]                   options(future.plan = NULL)
[08:26:26.853]                   if (is.na(NA_character_)) 
[08:26:26.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:26.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:26.853]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:26.853]                     .init = FALSE)
[08:26:26.853]                 }
[08:26:26.853]             }
[08:26:26.853]         }
[08:26:26.853]     })
[08:26:26.853]     if (TRUE) {
[08:26:26.853]         base::sink(type = "output", split = FALSE)
[08:26:26.853]         if (TRUE) {
[08:26:26.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:26.853]         }
[08:26:26.853]         else {
[08:26:26.853]             ...future.result["stdout"] <- base::list(NULL)
[08:26:26.853]         }
[08:26:26.853]         base::close(...future.stdout)
[08:26:26.853]         ...future.stdout <- NULL
[08:26:26.853]     }
[08:26:26.853]     ...future.result$conditions <- ...future.conditions
[08:26:26.853]     ...future.result$finished <- base::Sys.time()
[08:26:26.853]     ...future.result
[08:26:26.853] }
[08:26:26.856] Exporting 11 global objects (14.80 KiB) to cluster node #1 ...
[08:26:26.856] Exporting ‘...future.FUN’ (5.67 KiB) to cluster node #1 ...
[08:26:26.898] Exporting ‘...future.FUN’ (5.67 KiB) to cluster node #1 ... DONE
[08:26:26.898] Exporting ‘x_FUN’ (680 bytes) to cluster node #1 ...
[08:26:26.898] Exporting ‘x_FUN’ (680 bytes) to cluster node #1 ... DONE
[08:26:26.898] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[08:26:26.899] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[08:26:26.899] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[08:26:26.940] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[08:26:26.940] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[08:26:26.982] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[08:26:26.982] Exporting ‘dim’ (39 bytes) to cluster node #1 ...
[08:26:26.982] Exporting ‘dim’ (39 bytes) to cluster node #1 ... DONE
[08:26:26.982] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[08:26:26.983] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[08:26:26.983] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #1 ...
[08:26:26.983] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #1 ... DONE
[08:26:26.983] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #1 ...
[08:26:26.984] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #1 ... DONE
[08:26:26.984] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:26:26.984] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:26:26.984] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:26:26.985] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:26:26.985] Exporting 11 global objects (14.80 KiB) to cluster node #1 ... DONE
[08:26:26.985] MultisessionFuture started
[08:26:26.986] - Launch lazy future ... done
[08:26:26.986] run() for ‘MultisessionFuture’ ... done
[08:26:26.986] Created future:
[08:26:26.986] MultisessionFuture:
[08:26:26.986] Label: ‘future_vapply-1’
[08:26:26.986] Expression:
[08:26:26.986] {
[08:26:26.986]     do.call(function(...) {
[08:26:26.986]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:26.986]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:26.986]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:26.986]             on.exit(options(oopts), add = TRUE)
[08:26:26.986]         }
[08:26:26.986]         {
[08:26:26.986]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:26.986]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:26.986]                 ...future.FUN(...future.X_jj, ...)
[08:26:26.986]             })
[08:26:26.986]         }
[08:26:26.986]     }, args = future.call.arguments)
[08:26:26.986] }
[08:26:26.986] Lazy evaluation: FALSE
[08:26:26.986] Asynchronous evaluation: TRUE
[08:26:26.986] Local evaluation: TRUE
[08:26:26.986] Environment: R_GlobalEnv
[08:26:26.986] Capture standard output: TRUE
[08:26:26.986] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:26.986] Globals: 11 objects totaling 14.66 KiB (function ‘...future.FUN’ of 5.67 KiB, function ‘x_FUN’ of 680 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:26.986] Packages: 1 packages (‘future.apply’)
[08:26:26.986] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:26.986] Resolved: FALSE
[08:26:26.986] Value: <not collected>
[08:26:26.986] Conditions captured: <none>
[08:26:26.986] Early signaling: FALSE
[08:26:26.986] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:26.986] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:26.998] Chunk #1 of 2 ... DONE
[08:26:26.998] Chunk #2 of 2 ...
[08:26:26.998]  - Finding globals in 'X' for chunk #2 ...
[08:26:26.998] getGlobalsAndPackages() ...
[08:26:26.998] Searching for globals...
[08:26:26.998] 
[08:26:26.998] Searching for globals ... DONE
[08:26:26.999] - globals: [0] <none>
[08:26:26.999] getGlobalsAndPackages() ... DONE
[08:26:26.999]    + additional globals found: [n=0] 
[08:26:26.999]    + additional namespaces needed: [n=0] 
[08:26:26.999]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:26.999]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:26.999]  - seeds: <none>
[08:26:26.999]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.999] getGlobalsAndPackages() ...
[08:26:26.999] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:26.999] Resolving globals: FALSE
[08:26:27.000] Tweak future expression to call with '...' arguments ...
[08:26:27.000] {
[08:26:27.000]     do.call(function(...) {
[08:26:27.000]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:27.000]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:27.000]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:27.000]             on.exit(options(oopts), add = TRUE)
[08:26:27.000]         }
[08:26:27.000]         {
[08:26:27.000]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:27.000]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:27.000]                 ...future.FUN(...future.X_jj, ...)
[08:26:27.000]             })
[08:26:27.000]         }
[08:26:27.000]     }, args = future.call.arguments)
[08:26:27.000] }
[08:26:27.000] Tweak future expression to call with '...' arguments ... DONE
[08:26:27.000] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:27.001] - packages: [1] ‘future.apply’
[08:26:27.001] getGlobalsAndPackages() ... DONE
[08:26:27.001] run() for ‘Future’ ...
[08:26:27.001] - state: ‘created’
[08:26:27.001] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:27.016] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:27.016] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:27.016]   - Field: ‘node’
[08:26:27.016]   - Field: ‘label’
[08:26:27.016]   - Field: ‘local’
[08:26:27.016]   - Field: ‘owner’
[08:26:27.016]   - Field: ‘envir’
[08:26:27.016]   - Field: ‘workers’
[08:26:27.016]   - Field: ‘packages’
[08:26:27.016]   - Field: ‘gc’
[08:26:27.017]   - Field: ‘conditions’
[08:26:27.017]   - Field: ‘persistent’
[08:26:27.017]   - Field: ‘expr’
[08:26:27.017]   - Field: ‘uuid’
[08:26:27.017]   - Field: ‘seed’
[08:26:27.017]   - Field: ‘version’
[08:26:27.017]   - Field: ‘result’
[08:26:27.017]   - Field: ‘asynchronous’
[08:26:27.017]   - Field: ‘calls’
[08:26:27.017]   - Field: ‘globals’
[08:26:27.017]   - Field: ‘stdout’
[08:26:27.017]   - Field: ‘earlySignal’
[08:26:27.018]   - Field: ‘lazy’
[08:26:27.018]   - Field: ‘state’
[08:26:27.018] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:27.018] - Launch lazy future ...
[08:26:27.018] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:27.018] Packages needed by future strategies (n = 0): <none>
[08:26:27.019] {
[08:26:27.019]     {
[08:26:27.019]         {
[08:26:27.019]             ...future.startTime <- base::Sys.time()
[08:26:27.019]             {
[08:26:27.019]                 {
[08:26:27.019]                   {
[08:26:27.019]                     {
[08:26:27.019]                       {
[08:26:27.019]                         base::local({
[08:26:27.019]                           has_future <- base::requireNamespace("future", 
[08:26:27.019]                             quietly = TRUE)
[08:26:27.019]                           if (has_future) {
[08:26:27.019]                             ns <- base::getNamespace("future")
[08:26:27.019]                             version <- ns[[".package"]][["version"]]
[08:26:27.019]                             if (is.null(version)) 
[08:26:27.019]                               version <- utils::packageVersion("future")
[08:26:27.019]                           }
[08:26:27.019]                           else {
[08:26:27.019]                             version <- NULL
[08:26:27.019]                           }
[08:26:27.019]                           if (!has_future || version < "1.8.0") {
[08:26:27.019]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:27.019]                               "", base::R.version$version.string), 
[08:26:27.019]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:27.019]                                 base::R.version$platform, 8 * 
[08:26:27.019]                                   base::.Machine$sizeof.pointer), 
[08:26:27.019]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:27.019]                                 "release", "version")], collapse = " "), 
[08:26:27.019]                               hostname = base::Sys.info()[["nodename"]])
[08:26:27.019]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:27.019]                               info)
[08:26:27.019]                             info <- base::paste(info, collapse = "; ")
[08:26:27.019]                             if (!has_future) {
[08:26:27.019]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:27.019]                                 info)
[08:26:27.019]                             }
[08:26:27.019]                             else {
[08:26:27.019]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:27.019]                                 info, version)
[08:26:27.019]                             }
[08:26:27.019]                             base::stop(msg)
[08:26:27.019]                           }
[08:26:27.019]                         })
[08:26:27.019]                       }
[08:26:27.019]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:27.019]                       base::options(mc.cores = 1L)
[08:26:27.019]                     }
[08:26:27.019]                     base::local({
[08:26:27.019]                       for (pkg in "future.apply") {
[08:26:27.019]                         base::loadNamespace(pkg)
[08:26:27.019]                         base::library(pkg, character.only = TRUE)
[08:26:27.019]                       }
[08:26:27.019]                     })
[08:26:27.019]                   }
[08:26:27.019]                   ...future.strategy.old <- future::plan("list")
[08:26:27.019]                   options(future.plan = NULL)
[08:26:27.019]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:27.019]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:27.019]                 }
[08:26:27.019]                 ...future.workdir <- getwd()
[08:26:27.019]             }
[08:26:27.019]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:27.019]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:27.019]         }
[08:26:27.019]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:27.019]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:27.019]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:27.019]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:27.019]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:27.019]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:27.019]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:27.019]             base::names(...future.oldOptions))
[08:26:27.019]     }
[08:26:27.019]     if (FALSE) {
[08:26:27.019]     }
[08:26:27.019]     else {
[08:26:27.019]         if (TRUE) {
[08:26:27.019]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:27.019]                 open = "w")
[08:26:27.019]         }
[08:26:27.019]         else {
[08:26:27.019]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:27.019]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:27.019]         }
[08:26:27.019]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:27.019]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:27.019]             base::sink(type = "output", split = FALSE)
[08:26:27.019]             base::close(...future.stdout)
[08:26:27.019]         }, add = TRUE)
[08:26:27.019]     }
[08:26:27.019]     ...future.frame <- base::sys.nframe()
[08:26:27.019]     ...future.conditions <- base::list()
[08:26:27.019]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:27.019]     if (FALSE) {
[08:26:27.019]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:27.019]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:27.019]     }
[08:26:27.019]     ...future.result <- base::tryCatch({
[08:26:27.019]         base::withCallingHandlers({
[08:26:27.019]             ...future.value <- base::withVisible(base::local({
[08:26:27.019]                 ...future.makeSendCondition <- base::local({
[08:26:27.019]                   sendCondition <- NULL
[08:26:27.019]                   function(frame = 1L) {
[08:26:27.019]                     if (is.function(sendCondition)) 
[08:26:27.019]                       return(sendCondition)
[08:26:27.019]                     ns <- getNamespace("parallel")
[08:26:27.019]                     if (exists("sendData", mode = "function", 
[08:26:27.019]                       envir = ns)) {
[08:26:27.019]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:27.019]                         envir = ns)
[08:26:27.019]                       envir <- sys.frame(frame)
[08:26:27.019]                       master <- NULL
[08:26:27.019]                       while (!identical(envir, .GlobalEnv) && 
[08:26:27.019]                         !identical(envir, emptyenv())) {
[08:26:27.019]                         if (exists("master", mode = "list", envir = envir, 
[08:26:27.019]                           inherits = FALSE)) {
[08:26:27.019]                           master <- get("master", mode = "list", 
[08:26:27.019]                             envir = envir, inherits = FALSE)
[08:26:27.019]                           if (inherits(master, c("SOCKnode", 
[08:26:27.019]                             "SOCK0node"))) {
[08:26:27.019]                             sendCondition <<- function(cond) {
[08:26:27.019]                               data <- list(type = "VALUE", value = cond, 
[08:26:27.019]                                 success = TRUE)
[08:26:27.019]                               parallel_sendData(master, data)
[08:26:27.019]                             }
[08:26:27.019]                             return(sendCondition)
[08:26:27.019]                           }
[08:26:27.019]                         }
[08:26:27.019]                         frame <- frame + 1L
[08:26:27.019]                         envir <- sys.frame(frame)
[08:26:27.019]                       }
[08:26:27.019]                     }
[08:26:27.019]                     sendCondition <<- function(cond) NULL
[08:26:27.019]                   }
[08:26:27.019]                 })
[08:26:27.019]                 withCallingHandlers({
[08:26:27.019]                   {
[08:26:27.019]                     do.call(function(...) {
[08:26:27.019]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:27.019]                       if (!identical(...future.globals.maxSize.org, 
[08:26:27.019]                         ...future.globals.maxSize)) {
[08:26:27.019]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:27.019]                         on.exit(options(oopts), add = TRUE)
[08:26:27.019]                       }
[08:26:27.019]                       {
[08:26:27.019]                         lapply(seq_along(...future.elements_ii), 
[08:26:27.019]                           FUN = function(jj) {
[08:26:27.019]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:27.019]                             ...future.FUN(...future.X_jj, ...)
[08:26:27.019]                           })
[08:26:27.019]                       }
[08:26:27.019]                     }, args = future.call.arguments)
[08:26:27.019]                   }
[08:26:27.019]                 }, immediateCondition = function(cond) {
[08:26:27.019]                   sendCondition <- ...future.makeSendCondition()
[08:26:27.019]                   sendCondition(cond)
[08:26:27.019]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:27.019]                   {
[08:26:27.019]                     inherits <- base::inherits
[08:26:27.019]                     invokeRestart <- base::invokeRestart
[08:26:27.019]                     is.null <- base::is.null
[08:26:27.019]                     muffled <- FALSE
[08:26:27.019]                     if (inherits(cond, "message")) {
[08:26:27.019]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:27.019]                       if (muffled) 
[08:26:27.019]                         invokeRestart("muffleMessage")
[08:26:27.019]                     }
[08:26:27.019]                     else if (inherits(cond, "warning")) {
[08:26:27.019]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:27.019]                       if (muffled) 
[08:26:27.019]                         invokeRestart("muffleWarning")
[08:26:27.019]                     }
[08:26:27.019]                     else if (inherits(cond, "condition")) {
[08:26:27.019]                       if (!is.null(pattern)) {
[08:26:27.019]                         computeRestarts <- base::computeRestarts
[08:26:27.019]                         grepl <- base::grepl
[08:26:27.019]                         restarts <- computeRestarts(cond)
[08:26:27.019]                         for (restart in restarts) {
[08:26:27.019]                           name <- restart$name
[08:26:27.019]                           if (is.null(name)) 
[08:26:27.019]                             next
[08:26:27.019]                           if (!grepl(pattern, name)) 
[08:26:27.019]                             next
[08:26:27.019]                           invokeRestart(restart)
[08:26:27.019]                           muffled <- TRUE
[08:26:27.019]                           break
[08:26:27.019]                         }
[08:26:27.019]                       }
[08:26:27.019]                     }
[08:26:27.019]                     invisible(muffled)
[08:26:27.019]                   }
[08:26:27.019]                   muffleCondition(cond)
[08:26:27.019]                 })
[08:26:27.019]             }))
[08:26:27.019]             future::FutureResult(value = ...future.value$value, 
[08:26:27.019]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:27.019]                   ...future.rng), globalenv = if (FALSE) 
[08:26:27.019]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:27.019]                     ...future.globalenv.names))
[08:26:27.019]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:27.019]         }, condition = base::local({
[08:26:27.019]             c <- base::c
[08:26:27.019]             inherits <- base::inherits
[08:26:27.019]             invokeRestart <- base::invokeRestart
[08:26:27.019]             length <- base::length
[08:26:27.019]             list <- base::list
[08:26:27.019]             seq.int <- base::seq.int
[08:26:27.019]             signalCondition <- base::signalCondition
[08:26:27.019]             sys.calls <- base::sys.calls
[08:26:27.019]             `[[` <- base::`[[`
[08:26:27.019]             `+` <- base::`+`
[08:26:27.019]             `<<-` <- base::`<<-`
[08:26:27.019]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:27.019]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:27.019]                   3L)]
[08:26:27.019]             }
[08:26:27.019]             function(cond) {
[08:26:27.019]                 is_error <- inherits(cond, "error")
[08:26:27.019]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:27.019]                   NULL)
[08:26:27.019]                 if (is_error) {
[08:26:27.019]                   sessionInformation <- function() {
[08:26:27.019]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:27.019]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:27.019]                       search = base::search(), system = base::Sys.info())
[08:26:27.019]                   }
[08:26:27.019]                   ...future.conditions[[length(...future.conditions) + 
[08:26:27.019]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:27.019]                     cond$call), session = sessionInformation(), 
[08:26:27.019]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:27.019]                   signalCondition(cond)
[08:26:27.019]                 }
[08:26:27.019]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:27.019]                 "immediateCondition"))) {
[08:26:27.019]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:27.019]                   ...future.conditions[[length(...future.conditions) + 
[08:26:27.019]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:27.019]                   if (TRUE && !signal) {
[08:26:27.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:27.019]                     {
[08:26:27.019]                       inherits <- base::inherits
[08:26:27.019]                       invokeRestart <- base::invokeRestart
[08:26:27.019]                       is.null <- base::is.null
[08:26:27.019]                       muffled <- FALSE
[08:26:27.019]                       if (inherits(cond, "message")) {
[08:26:27.019]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:27.019]                         if (muffled) 
[08:26:27.019]                           invokeRestart("muffleMessage")
[08:26:27.019]                       }
[08:26:27.019]                       else if (inherits(cond, "warning")) {
[08:26:27.019]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:27.019]                         if (muffled) 
[08:26:27.019]                           invokeRestart("muffleWarning")
[08:26:27.019]                       }
[08:26:27.019]                       else if (inherits(cond, "condition")) {
[08:26:27.019]                         if (!is.null(pattern)) {
[08:26:27.019]                           computeRestarts <- base::computeRestarts
[08:26:27.019]                           grepl <- base::grepl
[08:26:27.019]                           restarts <- computeRestarts(cond)
[08:26:27.019]                           for (restart in restarts) {
[08:26:27.019]                             name <- restart$name
[08:26:27.019]                             if (is.null(name)) 
[08:26:27.019]                               next
[08:26:27.019]                             if (!grepl(pattern, name)) 
[08:26:27.019]                               next
[08:26:27.019]                             invokeRestart(restart)
[08:26:27.019]                             muffled <- TRUE
[08:26:27.019]                             break
[08:26:27.019]                           }
[08:26:27.019]                         }
[08:26:27.019]                       }
[08:26:27.019]                       invisible(muffled)
[08:26:27.019]                     }
[08:26:27.019]                     muffleCondition(cond, pattern = "^muffle")
[08:26:27.019]                   }
[08:26:27.019]                 }
[08:26:27.019]                 else {
[08:26:27.019]                   if (TRUE) {
[08:26:27.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:27.019]                     {
[08:26:27.019]                       inherits <- base::inherits
[08:26:27.019]                       invokeRestart <- base::invokeRestart
[08:26:27.019]                       is.null <- base::is.null
[08:26:27.019]                       muffled <- FALSE
[08:26:27.019]                       if (inherits(cond, "message")) {
[08:26:27.019]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:27.019]                         if (muffled) 
[08:26:27.019]                           invokeRestart("muffleMessage")
[08:26:27.019]                       }
[08:26:27.019]                       else if (inherits(cond, "warning")) {
[08:26:27.019]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:27.019]                         if (muffled) 
[08:26:27.019]                           invokeRestart("muffleWarning")
[08:26:27.019]                       }
[08:26:27.019]                       else if (inherits(cond, "condition")) {
[08:26:27.019]                         if (!is.null(pattern)) {
[08:26:27.019]                           computeRestarts <- base::computeRestarts
[08:26:27.019]                           grepl <- base::grepl
[08:26:27.019]                           restarts <- computeRestarts(cond)
[08:26:27.019]                           for (restart in restarts) {
[08:26:27.019]                             name <- restart$name
[08:26:27.019]                             if (is.null(name)) 
[08:26:27.019]                               next
[08:26:27.019]                             if (!grepl(pattern, name)) 
[08:26:27.019]                               next
[08:26:27.019]                             invokeRestart(restart)
[08:26:27.019]                             muffled <- TRUE
[08:26:27.019]                             break
[08:26:27.019]                           }
[08:26:27.019]                         }
[08:26:27.019]                       }
[08:26:27.019]                       invisible(muffled)
[08:26:27.019]                     }
[08:26:27.019]                     muffleCondition(cond, pattern = "^muffle")
[08:26:27.019]                   }
[08:26:27.019]                 }
[08:26:27.019]             }
[08:26:27.019]         }))
[08:26:27.019]     }, error = function(ex) {
[08:26:27.019]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:27.019]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:27.019]                 ...future.rng), started = ...future.startTime, 
[08:26:27.019]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:27.019]             version = "1.8"), class = "FutureResult")
[08:26:27.019]     }, finally = {
[08:26:27.019]         if (!identical(...future.workdir, getwd())) 
[08:26:27.019]             setwd(...future.workdir)
[08:26:27.019]         {
[08:26:27.019]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:27.019]                 ...future.oldOptions$nwarnings <- NULL
[08:26:27.019]             }
[08:26:27.019]             base::options(...future.oldOptions)
[08:26:27.019]             if (.Platform$OS.type == "windows") {
[08:26:27.019]                 old_names <- names(...future.oldEnvVars)
[08:26:27.019]                 envs <- base::Sys.getenv()
[08:26:27.019]                 names <- names(envs)
[08:26:27.019]                 common <- intersect(names, old_names)
[08:26:27.019]                 added <- setdiff(names, old_names)
[08:26:27.019]                 removed <- setdiff(old_names, names)
[08:26:27.019]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:27.019]                   envs[common]]
[08:26:27.019]                 NAMES <- toupper(changed)
[08:26:27.019]                 args <- list()
[08:26:27.019]                 for (kk in seq_along(NAMES)) {
[08:26:27.019]                   name <- changed[[kk]]
[08:26:27.019]                   NAME <- NAMES[[kk]]
[08:26:27.019]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:27.019]                     next
[08:26:27.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:27.019]                 }
[08:26:27.019]                 NAMES <- toupper(added)
[08:26:27.019]                 for (kk in seq_along(NAMES)) {
[08:26:27.019]                   name <- added[[kk]]
[08:26:27.019]                   NAME <- NAMES[[kk]]
[08:26:27.019]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:27.019]                     next
[08:26:27.019]                   args[[name]] <- ""
[08:26:27.019]                 }
[08:26:27.019]                 NAMES <- toupper(removed)
[08:26:27.019]                 for (kk in seq_along(NAMES)) {
[08:26:27.019]                   name <- removed[[kk]]
[08:26:27.019]                   NAME <- NAMES[[kk]]
[08:26:27.019]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:27.019]                     next
[08:26:27.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:27.019]                 }
[08:26:27.019]                 if (length(args) > 0) 
[08:26:27.019]                   base::do.call(base::Sys.setenv, args = args)
[08:26:27.019]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:27.019]             }
[08:26:27.019]             else {
[08:26:27.019]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:27.019]             }
[08:26:27.019]             {
[08:26:27.019]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:27.019]                   0L) {
[08:26:27.019]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:27.019]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:27.019]                   base::options(opts)
[08:26:27.019]                 }
[08:26:27.019]                 {
[08:26:27.019]                   {
[08:26:27.019]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:27.019]                     NULL
[08:26:27.019]                   }
[08:26:27.019]                   options(future.plan = NULL)
[08:26:27.019]                   if (is.na(NA_character_)) 
[08:26:27.019]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:27.019]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:27.019]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:27.019]                     .init = FALSE)
[08:26:27.019]                 }
[08:26:27.019]             }
[08:26:27.019]         }
[08:26:27.019]     })
[08:26:27.019]     if (TRUE) {
[08:26:27.019]         base::sink(type = "output", split = FALSE)
[08:26:27.019]         if (TRUE) {
[08:26:27.019]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:27.019]         }
[08:26:27.019]         else {
[08:26:27.019]             ...future.result["stdout"] <- base::list(NULL)
[08:26:27.019]         }
[08:26:27.019]         base::close(...future.stdout)
[08:26:27.019]         ...future.stdout <- NULL
[08:26:27.019]     }
[08:26:27.019]     ...future.result$conditions <- ...future.conditions
[08:26:27.019]     ...future.result$finished <- base::Sys.time()
[08:26:27.019]     ...future.result
[08:26:27.019] }
[08:26:27.022] Exporting 11 global objects (14.80 KiB) to cluster node #2 ...
[08:26:27.022] Exporting ‘...future.FUN’ (5.67 KiB) to cluster node #2 ...
[08:26:27.064] Exporting ‘...future.FUN’ (5.67 KiB) to cluster node #2 ... DONE
[08:26:27.064] Exporting ‘x_FUN’ (680 bytes) to cluster node #2 ...
[08:26:27.064] Exporting ‘x_FUN’ (680 bytes) to cluster node #2 ... DONE
[08:26:27.065] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[08:26:27.065] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[08:26:27.065] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[08:26:27.106] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[08:26:27.107] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[08:26:27.148] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[08:26:27.148] Exporting ‘dim’ (39 bytes) to cluster node #2 ...
[08:26:27.148] Exporting ‘dim’ (39 bytes) to cluster node #2 ... DONE
[08:26:27.148] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[08:26:27.149] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[08:26:27.149] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #2 ...
[08:26:27.149] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #2 ... DONE
[08:26:27.149] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #2 ...
[08:26:27.150] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #2 ... DONE
[08:26:27.150] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:26:27.150] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:26:27.150] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:26:27.151] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:26:27.151] Exporting 11 global objects (14.80 KiB) to cluster node #2 ... DONE
[08:26:27.151] MultisessionFuture started
[08:26:27.151] - Launch lazy future ... done
[08:26:27.152] run() for ‘MultisessionFuture’ ... done
[08:26:27.152] Created future:
[08:26:27.152] MultisessionFuture:
[08:26:27.152] Label: ‘future_vapply-2’
[08:26:27.152] Expression:
[08:26:27.152] {
[08:26:27.152]     do.call(function(...) {
[08:26:27.152]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:27.152]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:27.152]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:27.152]             on.exit(options(oopts), add = TRUE)
[08:26:27.152]         }
[08:26:27.152]         {
[08:26:27.152]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:27.152]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:27.152]                 ...future.FUN(...future.X_jj, ...)
[08:26:27.152]             })
[08:26:27.152]         }
[08:26:27.152]     }, args = future.call.arguments)
[08:26:27.152] }
[08:26:27.152] Lazy evaluation: FALSE
[08:26:27.152] Asynchronous evaluation: TRUE
[08:26:27.152] Local evaluation: TRUE
[08:26:27.152] Environment: R_GlobalEnv
[08:26:27.152] Capture standard output: TRUE
[08:26:27.152] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:27.152] Globals: 11 objects totaling 14.66 KiB (function ‘...future.FUN’ of 5.67 KiB, function ‘x_FUN’ of 680 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:27.152] Packages: 1 packages (‘future.apply’)
[08:26:27.152] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:27.152] Resolved: FALSE
[08:26:27.152] Value: <not collected>
[08:26:27.152] Conditions captured: <none>
[08:26:27.152] Early signaling: FALSE
[08:26:27.152] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:27.152] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:27.163] Chunk #2 of 2 ... DONE
[08:26:27.164] Launching 2 futures (chunks) ... DONE
[08:26:27.164] Resolving 2 futures (chunks) ...
[08:26:27.164] resolve() on list ...
[08:26:27.164]  recursive: 0
[08:26:27.164]  length: 2
[08:26:27.164] 
[08:26:27.165] receiveMessageFromWorker() for ClusterFuture ...
[08:26:27.165] - Validating connection of MultisessionFuture
[08:26:27.165] - received message: FutureResult
[08:26:27.165] - Received FutureResult
[08:26:27.165] - Erased future from FutureRegistry
[08:26:27.165] result() for ClusterFuture ...
[08:26:27.165] - result already collected: FutureResult
[08:26:27.165] result() for ClusterFuture ... done
[08:26:27.165] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:27.166] Future #1
[08:26:27.166] result() for ClusterFuture ...
[08:26:27.166] - result already collected: FutureResult
[08:26:27.166] result() for ClusterFuture ... done
[08:26:27.166] result() for ClusterFuture ...
[08:26:27.166] - result already collected: FutureResult
[08:26:27.166] result() for ClusterFuture ... done
[08:26:27.166] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:26:27.166] - nx: 2
[08:26:27.166] - relay: TRUE
[08:26:27.166] - stdout: TRUE
[08:26:27.166] - signal: TRUE
[08:26:27.167] - resignal: FALSE
[08:26:27.167] - force: TRUE
[08:26:27.167] - relayed: [n=2] FALSE, FALSE
[08:26:27.167] - queued futures: [n=2] FALSE, FALSE
[08:26:27.167]  - until=1
[08:26:27.167]  - relaying element #1
[08:26:27.167] result() for ClusterFuture ...
[08:26:27.167] - result already collected: FutureResult
[08:26:27.167] result() for ClusterFuture ... done
[08:26:27.167] result() for ClusterFuture ...
[08:26:27.167] - result already collected: FutureResult
[08:26:27.167] result() for ClusterFuture ... done
[08:26:27.168] result() for ClusterFuture ...
[08:26:27.168] - result already collected: FutureResult
[08:26:27.168] result() for ClusterFuture ... done
[08:26:27.168] result() for ClusterFuture ...
[08:26:27.168] - result already collected: FutureResult
[08:26:27.168] result() for ClusterFuture ... done
[08:26:27.168] - relayed: [n=2] TRUE, FALSE
[08:26:27.168] - queued futures: [n=2] TRUE, FALSE
[08:26:27.168] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:26:27.168]  length: 1 (resolved future 1)
[08:26:27.193] receiveMessageFromWorker() for ClusterFuture ...
[08:26:27.194] - Validating connection of MultisessionFuture
[08:26:27.194] - received message: FutureResult
[08:26:27.194] - Received FutureResult
[08:26:27.194] - Erased future from FutureRegistry
[08:26:27.194] result() for ClusterFuture ...
[08:26:27.194] - result already collected: FutureResult
[08:26:27.194] result() for ClusterFuture ... done
[08:26:27.194] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:27.194] Future #2
[08:26:27.195] result() for ClusterFuture ...
[08:26:27.195] - result already collected: FutureResult
[08:26:27.195] result() for ClusterFuture ... done
[08:26:27.195] result() for ClusterFuture ...
[08:26:27.195] - result already collected: FutureResult
[08:26:27.195] result() for ClusterFuture ... done
[08:26:27.195] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:26:27.195] - nx: 2
[08:26:27.195] - relay: TRUE
[08:26:27.195] - stdout: TRUE
[08:26:27.195] - signal: TRUE
[08:26:27.195] - resignal: FALSE
[08:26:27.195] - force: TRUE
[08:26:27.196] - relayed: [n=2] TRUE, FALSE
[08:26:27.196] - queued futures: [n=2] TRUE, FALSE
[08:26:27.196]  - until=2
[08:26:27.196]  - relaying element #2
[08:26:27.196] result() for ClusterFuture ...
[08:26:27.196] - result already collected: FutureResult
[08:26:27.196] result() for ClusterFuture ... done
[08:26:27.196] result() for ClusterFuture ...
[08:26:27.196] - result already collected: FutureResult
[08:26:27.196] result() for ClusterFuture ... done
[08:26:27.196] result() for ClusterFuture ...
[08:26:27.197] - result already collected: FutureResult
[08:26:27.197] result() for ClusterFuture ... done
[08:26:27.197] result() for ClusterFuture ...
[08:26:27.197] - result already collected: FutureResult
[08:26:27.197] result() for ClusterFuture ... done
[08:26:27.197] - relayed: [n=2] TRUE, TRUE
[08:26:27.197] - queued futures: [n=2] TRUE, TRUE
[08:26:27.197] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:26:27.197]  length: 0 (resolved future 2)
[08:26:27.197] Relaying remaining futures
[08:26:27.197] signalConditionsASAP(NULL, pos=0) ...
[08:26:27.197] - nx: 2
[08:26:27.198] - relay: TRUE
[08:26:27.198] - stdout: TRUE
[08:26:27.198] - signal: TRUE
[08:26:27.198] - resignal: FALSE
[08:26:27.198] - force: TRUE
[08:26:27.198] - relayed: [n=2] TRUE, TRUE
[08:26:27.198] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:27.198] - relayed: [n=2] TRUE, TRUE
[08:26:27.198] - queued futures: [n=2] TRUE, TRUE
[08:26:27.198] signalConditionsASAP(NULL, pos=0) ... done
[08:26:27.198] resolve() on list ... DONE
[08:26:27.198] result() for ClusterFuture ...
[08:26:27.199] - result already collected: FutureResult
[08:26:27.199] result() for ClusterFuture ... done
[08:26:27.199] result() for ClusterFuture ...
[08:26:27.199] - result already collected: FutureResult
[08:26:27.199] result() for ClusterFuture ... done
[08:26:27.199] result() for ClusterFuture ...
[08:26:27.199] - result already collected: FutureResult
[08:26:27.199] result() for ClusterFuture ... done
[08:26:27.199] result() for ClusterFuture ...
[08:26:27.199] - result already collected: FutureResult
[08:26:27.199] result() for ClusterFuture ... done
[08:26:27.199]  - Number of value chunks collected: 2
[08:26:27.200] Resolving 2 futures (chunks) ... DONE
[08:26:27.200] Reducing values from 2 chunks ...
[08:26:27.200]  - Number of values collected after concatenation: 4
[08:26:27.200]  - Number of values expected: 4
[08:26:27.200] Reducing values from 2 chunks ... DONE
[08:26:27.200] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[08:26:27.202] future_lapply() ...
[08:26:27.205] Number of chunks: 2
[08:26:27.205] getGlobalsAndPackagesXApply() ...
[08:26:27.205]  - future.globals: TRUE
[08:26:27.205] getGlobalsAndPackages() ...
[08:26:27.205] Searching for globals...
[08:26:27.211] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[08:26:27.211] Searching for globals ... DONE
[08:26:27.211] Resolving globals: FALSE
[08:26:27.212] The total size of the 7 globals is 14.73 KiB (15079 bytes)
[08:26:27.212] The total size of the 7 globals exported for future expression (‘FUN()’) is 14.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (6.74 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:27.212] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:27.212] - packages: [1] ‘future.apply’
[08:26:27.212] getGlobalsAndPackages() ... DONE
[08:26:27.213]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:27.213]  - needed namespaces: [n=1] ‘future.apply’
[08:26:27.213] Finding globals ... DONE
[08:26:27.213]  - use_args: TRUE
[08:26:27.213]  - Getting '...' globals ...
[08:26:27.213] resolve() on list ...
[08:26:27.213]  recursive: 0
[08:26:27.213]  length: 1
[08:26:27.214]  elements: ‘...’
[08:26:27.214]  length: 0 (resolved future 1)
[08:26:27.214] resolve() on list ... DONE
[08:26:27.214]    - '...' content: [n=0] 
[08:26:27.214] List of 1
[08:26:27.214]  $ ...: list()
[08:26:27.214]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:27.214]  - attr(*, "where")=List of 1
[08:26:27.214]   ..$ ...:<environment: 0x562ca95cad50> 
[08:26:27.214]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:27.214]  - attr(*, "resolved")= logi TRUE
[08:26:27.214]  - attr(*, "total_size")= num NA
[08:26:27.216]  - Getting '...' globals ... DONE
[08:26:27.216] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:27.217] List of 8
[08:26:27.217]  $ ...future.FUN:function (x, ...)  
[08:26:27.217]  $ x_FUN        :function (x)  
[08:26:27.217]  $ times        : int 1
[08:26:27.217]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:27.217]  $ stop_if_not  :function (...)  
[08:26:27.217]  $ dim          : NULL
[08:26:27.217]  $ valid_types  : chr "logical"
[08:26:27.217]  $ ...          : list()
[08:26:27.217]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:27.217]  - attr(*, "where")=List of 8
[08:26:27.217]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:27.217]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:27.217]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:27.217]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:27.217]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:27.217]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:27.217]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:27.217]   ..$ ...          :<environment: 0x562ca95cad50> 
[08:26:27.217]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:27.217]  - attr(*, "resolved")= logi FALSE
[08:26:27.217]  - attr(*, "total_size")= num 30734
[08:26:27.222] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:27.222] getGlobalsAndPackagesXApply() ... DONE
[08:26:27.222] Number of futures (= number of chunks): 2
[08:26:27.222] Launching 2 futures (chunks) ...
[08:26:27.222] Chunk #1 of 2 ...
[08:26:27.222]  - Finding globals in 'X' for chunk #1 ...
[08:26:27.222] getGlobalsAndPackages() ...
[08:26:27.222] Searching for globals...
[08:26:27.223] 
[08:26:27.223] Searching for globals ... DONE
[08:26:27.223] - globals: [0] <none>
[08:26:27.223] getGlobalsAndPackages() ... DONE
[08:26:27.223]    + additional globals found: [n=0] 
[08:26:27.223]    + additional namespaces needed: [n=0] 
[08:26:27.223]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:27.223]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:27.224]  - seeds: <none>
[08:26:27.224]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:27.224] getGlobalsAndPackages() ...
[08:26:27.224] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:27.224] Resolving globals: FALSE
[08:26:27.224] Tweak future expression to call with '...' arguments ...
[08:26:27.224] {
[08:26:27.224]     do.call(function(...) {
[08:26:27.224]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:27.224]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:27.224]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:27.224]             on.exit(options(oopts), add = TRUE)
[08:26:27.224]         }
[08:26:27.224]         {
[08:26:27.224]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:27.224]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:27.224]                 ...future.FUN(...future.X_jj, ...)
[08:26:27.224]             })
[08:26:27.224]         }
[08:26:27.224]     }, args = future.call.arguments)
[08:26:27.224] }
[08:26:27.224] Tweak future expression to call with '...' arguments ... DONE
[08:26:27.225] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:27.225] - packages: [1] ‘future.apply’
[08:26:27.225] getGlobalsAndPackages() ... DONE
[08:26:27.225] run() for ‘Future’ ...
[08:26:27.226] - state: ‘created’
[08:26:27.226] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:27.241] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:27.242] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:27.242]   - Field: ‘node’
[08:26:27.242]   - Field: ‘label’
[08:26:27.242]   - Field: ‘local’
[08:26:27.242]   - Field: ‘owner’
[08:26:27.242]   - Field: ‘envir’
[08:26:27.242]   - Field: ‘workers’
[08:26:27.242]   - Field: ‘packages’
[08:26:27.242]   - Field: ‘gc’
[08:26:27.242]   - Field: ‘conditions’
[08:26:27.242]   - Field: ‘persistent’
[08:26:27.243]   - Field: ‘expr’
[08:26:27.243]   - Field: ‘uuid’
[08:26:27.243]   - Field: ‘seed’
[08:26:27.243]   - Field: ‘version’
[08:26:27.243]   - Field: ‘result’
[08:26:27.243]   - Field: ‘asynchronous’
[08:26:27.243]   - Field: ‘calls’
[08:26:27.243]   - Field: ‘globals’
[08:26:27.243]   - Field: ‘stdout’
[08:26:27.243]   - Field: ‘earlySignal’
[08:26:27.243]   - Field: ‘lazy’
[08:26:27.243]   - Field: ‘state’
[08:26:27.244] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:27.244] - Launch lazy future ...
[08:26:27.244] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:27.244] Packages needed by future strategies (n = 0): <none>
[08:26:27.245] {
[08:26:27.245]     {
[08:26:27.245]         {
[08:26:27.245]             ...future.startTime <- base::Sys.time()
[08:26:27.245]             {
[08:26:27.245]                 {
[08:26:27.245]                   {
[08:26:27.245]                     {
[08:26:27.245]                       {
[08:26:27.245]                         base::local({
[08:26:27.245]                           has_future <- base::requireNamespace("future", 
[08:26:27.245]                             quietly = TRUE)
[08:26:27.245]                           if (has_future) {
[08:26:27.245]                             ns <- base::getNamespace("future")
[08:26:27.245]                             version <- ns[[".package"]][["version"]]
[08:26:27.245]                             if (is.null(version)) 
[08:26:27.245]                               version <- utils::packageVersion("future")
[08:26:27.245]                           }
[08:26:27.245]                           else {
[08:26:27.245]                             version <- NULL
[08:26:27.245]                           }
[08:26:27.245]                           if (!has_future || version < "1.8.0") {
[08:26:27.245]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:27.245]                               "", base::R.version$version.string), 
[08:26:27.245]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:27.245]                                 base::R.version$platform, 8 * 
[08:26:27.245]                                   base::.Machine$sizeof.pointer), 
[08:26:27.245]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:27.245]                                 "release", "version")], collapse = " "), 
[08:26:27.245]                               hostname = base::Sys.info()[["nodename"]])
[08:26:27.245]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:27.245]                               info)
[08:26:27.245]                             info <- base::paste(info, collapse = "; ")
[08:26:27.245]                             if (!has_future) {
[08:26:27.245]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:27.245]                                 info)
[08:26:27.245]                             }
[08:26:27.245]                             else {
[08:26:27.245]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:27.245]                                 info, version)
[08:26:27.245]                             }
[08:26:27.245]                             base::stop(msg)
[08:26:27.245]                           }
[08:26:27.245]                         })
[08:26:27.245]                       }
[08:26:27.245]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:27.245]                       base::options(mc.cores = 1L)
[08:26:27.245]                     }
[08:26:27.245]                     base::local({
[08:26:27.245]                       for (pkg in "future.apply") {
[08:26:27.245]                         base::loadNamespace(pkg)
[08:26:27.245]                         base::library(pkg, character.only = TRUE)
[08:26:27.245]                       }
[08:26:27.245]                     })
[08:26:27.245]                   }
[08:26:27.245]                   ...future.strategy.old <- future::plan("list")
[08:26:27.245]                   options(future.plan = NULL)
[08:26:27.245]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:27.245]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:27.245]                 }
[08:26:27.245]                 ...future.workdir <- getwd()
[08:26:27.245]             }
[08:26:27.245]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:27.245]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:27.245]         }
[08:26:27.245]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:27.245]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:27.245]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:27.245]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:27.245]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:27.245]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:27.245]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:27.245]             base::names(...future.oldOptions))
[08:26:27.245]     }
[08:26:27.245]     if (FALSE) {
[08:26:27.245]     }
[08:26:27.245]     else {
[08:26:27.245]         if (TRUE) {
[08:26:27.245]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:27.245]                 open = "w")
[08:26:27.245]         }
[08:26:27.245]         else {
[08:26:27.245]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:27.245]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:27.245]         }
[08:26:27.245]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:27.245]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:27.245]             base::sink(type = "output", split = FALSE)
[08:26:27.245]             base::close(...future.stdout)
[08:26:27.245]         }, add = TRUE)
[08:26:27.245]     }
[08:26:27.245]     ...future.frame <- base::sys.nframe()
[08:26:27.245]     ...future.conditions <- base::list()
[08:26:27.245]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:27.245]     if (FALSE) {
[08:26:27.245]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:27.245]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:27.245]     }
[08:26:27.245]     ...future.result <- base::tryCatch({
[08:26:27.245]         base::withCallingHandlers({
[08:26:27.245]             ...future.value <- base::withVisible(base::local({
[08:26:27.245]                 ...future.makeSendCondition <- base::local({
[08:26:27.245]                   sendCondition <- NULL
[08:26:27.245]                   function(frame = 1L) {
[08:26:27.245]                     if (is.function(sendCondition)) 
[08:26:27.245]                       return(sendCondition)
[08:26:27.245]                     ns <- getNamespace("parallel")
[08:26:27.245]                     if (exists("sendData", mode = "function", 
[08:26:27.245]                       envir = ns)) {
[08:26:27.245]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:27.245]                         envir = ns)
[08:26:27.245]                       envir <- sys.frame(frame)
[08:26:27.245]                       master <- NULL
[08:26:27.245]                       while (!identical(envir, .GlobalEnv) && 
[08:26:27.245]                         !identical(envir, emptyenv())) {
[08:26:27.245]                         if (exists("master", mode = "list", envir = envir, 
[08:26:27.245]                           inherits = FALSE)) {
[08:26:27.245]                           master <- get("master", mode = "list", 
[08:26:27.245]                             envir = envir, inherits = FALSE)
[08:26:27.245]                           if (inherits(master, c("SOCKnode", 
[08:26:27.245]                             "SOCK0node"))) {
[08:26:27.245]                             sendCondition <<- function(cond) {
[08:26:27.245]                               data <- list(type = "VALUE", value = cond, 
[08:26:27.245]                                 success = TRUE)
[08:26:27.245]                               parallel_sendData(master, data)
[08:26:27.245]                             }
[08:26:27.245]                             return(sendCondition)
[08:26:27.245]                           }
[08:26:27.245]                         }
[08:26:27.245]                         frame <- frame + 1L
[08:26:27.245]                         envir <- sys.frame(frame)
[08:26:27.245]                       }
[08:26:27.245]                     }
[08:26:27.245]                     sendCondition <<- function(cond) NULL
[08:26:27.245]                   }
[08:26:27.245]                 })
[08:26:27.245]                 withCallingHandlers({
[08:26:27.245]                   {
[08:26:27.245]                     do.call(function(...) {
[08:26:27.245]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:27.245]                       if (!identical(...future.globals.maxSize.org, 
[08:26:27.245]                         ...future.globals.maxSize)) {
[08:26:27.245]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:27.245]                         on.exit(options(oopts), add = TRUE)
[08:26:27.245]                       }
[08:26:27.245]                       {
[08:26:27.245]                         lapply(seq_along(...future.elements_ii), 
[08:26:27.245]                           FUN = function(jj) {
[08:26:27.245]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:27.245]                             ...future.FUN(...future.X_jj, ...)
[08:26:27.245]                           })
[08:26:27.245]                       }
[08:26:27.245]                     }, args = future.call.arguments)
[08:26:27.245]                   }
[08:26:27.245]                 }, immediateCondition = function(cond) {
[08:26:27.245]                   sendCondition <- ...future.makeSendCondition()
[08:26:27.245]                   sendCondition(cond)
[08:26:27.245]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:27.245]                   {
[08:26:27.245]                     inherits <- base::inherits
[08:26:27.245]                     invokeRestart <- base::invokeRestart
[08:26:27.245]                     is.null <- base::is.null
[08:26:27.245]                     muffled <- FALSE
[08:26:27.245]                     if (inherits(cond, "message")) {
[08:26:27.245]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:27.245]                       if (muffled) 
[08:26:27.245]                         invokeRestart("muffleMessage")
[08:26:27.245]                     }
[08:26:27.245]                     else if (inherits(cond, "warning")) {
[08:26:27.245]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:27.245]                       if (muffled) 
[08:26:27.245]                         invokeRestart("muffleWarning")
[08:26:27.245]                     }
[08:26:27.245]                     else if (inherits(cond, "condition")) {
[08:26:27.245]                       if (!is.null(pattern)) {
[08:26:27.245]                         computeRestarts <- base::computeRestarts
[08:26:27.245]                         grepl <- base::grepl
[08:26:27.245]                         restarts <- computeRestarts(cond)
[08:26:27.245]                         for (restart in restarts) {
[08:26:27.245]                           name <- restart$name
[08:26:27.245]                           if (is.null(name)) 
[08:26:27.245]                             next
[08:26:27.245]                           if (!grepl(pattern, name)) 
[08:26:27.245]                             next
[08:26:27.245]                           invokeRestart(restart)
[08:26:27.245]                           muffled <- TRUE
[08:26:27.245]                           break
[08:26:27.245]                         }
[08:26:27.245]                       }
[08:26:27.245]                     }
[08:26:27.245]                     invisible(muffled)
[08:26:27.245]                   }
[08:26:27.245]                   muffleCondition(cond)
[08:26:27.245]                 })
[08:26:27.245]             }))
[08:26:27.245]             future::FutureResult(value = ...future.value$value, 
[08:26:27.245]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:27.245]                   ...future.rng), globalenv = if (FALSE) 
[08:26:27.245]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:27.245]                     ...future.globalenv.names))
[08:26:27.245]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:27.245]         }, condition = base::local({
[08:26:27.245]             c <- base::c
[08:26:27.245]             inherits <- base::inherits
[08:26:27.245]             invokeRestart <- base::invokeRestart
[08:26:27.245]             length <- base::length
[08:26:27.245]             list <- base::list
[08:26:27.245]             seq.int <- base::seq.int
[08:26:27.245]             signalCondition <- base::signalCondition
[08:26:27.245]             sys.calls <- base::sys.calls
[08:26:27.245]             `[[` <- base::`[[`
[08:26:27.245]             `+` <- base::`+`
[08:26:27.245]             `<<-` <- base::`<<-`
[08:26:27.245]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:27.245]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:27.245]                   3L)]
[08:26:27.245]             }
[08:26:27.245]             function(cond) {
[08:26:27.245]                 is_error <- inherits(cond, "error")
[08:26:27.245]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:27.245]                   NULL)
[08:26:27.245]                 if (is_error) {
[08:26:27.245]                   sessionInformation <- function() {
[08:26:27.245]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:27.245]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:27.245]                       search = base::search(), system = base::Sys.info())
[08:26:27.245]                   }
[08:26:27.245]                   ...future.conditions[[length(...future.conditions) + 
[08:26:27.245]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:27.245]                     cond$call), session = sessionInformation(), 
[08:26:27.245]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:27.245]                   signalCondition(cond)
[08:26:27.245]                 }
[08:26:27.245]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:27.245]                 "immediateCondition"))) {
[08:26:27.245]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:27.245]                   ...future.conditions[[length(...future.conditions) + 
[08:26:27.245]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:27.245]                   if (TRUE && !signal) {
[08:26:27.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:27.245]                     {
[08:26:27.245]                       inherits <- base::inherits
[08:26:27.245]                       invokeRestart <- base::invokeRestart
[08:26:27.245]                       is.null <- base::is.null
[08:26:27.245]                       muffled <- FALSE
[08:26:27.245]                       if (inherits(cond, "message")) {
[08:26:27.245]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:27.245]                         if (muffled) 
[08:26:27.245]                           invokeRestart("muffleMessage")
[08:26:27.245]                       }
[08:26:27.245]                       else if (inherits(cond, "warning")) {
[08:26:27.245]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:27.245]                         if (muffled) 
[08:26:27.245]                           invokeRestart("muffleWarning")
[08:26:27.245]                       }
[08:26:27.245]                       else if (inherits(cond, "condition")) {
[08:26:27.245]                         if (!is.null(pattern)) {
[08:26:27.245]                           computeRestarts <- base::computeRestarts
[08:26:27.245]                           grepl <- base::grepl
[08:26:27.245]                           restarts <- computeRestarts(cond)
[08:26:27.245]                           for (restart in restarts) {
[08:26:27.245]                             name <- restart$name
[08:26:27.245]                             if (is.null(name)) 
[08:26:27.245]                               next
[08:26:27.245]                             if (!grepl(pattern, name)) 
[08:26:27.245]                               next
[08:26:27.245]                             invokeRestart(restart)
[08:26:27.245]                             muffled <- TRUE
[08:26:27.245]                             break
[08:26:27.245]                           }
[08:26:27.245]                         }
[08:26:27.245]                       }
[08:26:27.245]                       invisible(muffled)
[08:26:27.245]                     }
[08:26:27.245]                     muffleCondition(cond, pattern = "^muffle")
[08:26:27.245]                   }
[08:26:27.245]                 }
[08:26:27.245]                 else {
[08:26:27.245]                   if (TRUE) {
[08:26:27.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:27.245]                     {
[08:26:27.245]                       inherits <- base::inherits
[08:26:27.245]                       invokeRestart <- base::invokeRestart
[08:26:27.245]                       is.null <- base::is.null
[08:26:27.245]                       muffled <- FALSE
[08:26:27.245]                       if (inherits(cond, "message")) {
[08:26:27.245]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:27.245]                         if (muffled) 
[08:26:27.245]                           invokeRestart("muffleMessage")
[08:26:27.245]                       }
[08:26:27.245]                       else if (inherits(cond, "warning")) {
[08:26:27.245]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:27.245]                         if (muffled) 
[08:26:27.245]                           invokeRestart("muffleWarning")
[08:26:27.245]                       }
[08:26:27.245]                       else if (inherits(cond, "condition")) {
[08:26:27.245]                         if (!is.null(pattern)) {
[08:26:27.245]                           computeRestarts <- base::computeRestarts
[08:26:27.245]                           grepl <- base::grepl
[08:26:27.245]                           restarts <- computeRestarts(cond)
[08:26:27.245]                           for (restart in restarts) {
[08:26:27.245]                             name <- restart$name
[08:26:27.245]                             if (is.null(name)) 
[08:26:27.245]                               next
[08:26:27.245]                             if (!grepl(pattern, name)) 
[08:26:27.245]                               next
[08:26:27.245]                             invokeRestart(restart)
[08:26:27.245]                             muffled <- TRUE
[08:26:27.245]                             break
[08:26:27.245]                           }
[08:26:27.245]                         }
[08:26:27.245]                       }
[08:26:27.245]                       invisible(muffled)
[08:26:27.245]                     }
[08:26:27.245]                     muffleCondition(cond, pattern = "^muffle")
[08:26:27.245]                   }
[08:26:27.245]                 }
[08:26:27.245]             }
[08:26:27.245]         }))
[08:26:27.245]     }, error = function(ex) {
[08:26:27.245]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:27.245]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:27.245]                 ...future.rng), started = ...future.startTime, 
[08:26:27.245]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:27.245]             version = "1.8"), class = "FutureResult")
[08:26:27.245]     }, finally = {
[08:26:27.245]         if (!identical(...future.workdir, getwd())) 
[08:26:27.245]             setwd(...future.workdir)
[08:26:27.245]         {
[08:26:27.245]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:27.245]                 ...future.oldOptions$nwarnings <- NULL
[08:26:27.245]             }
[08:26:27.245]             base::options(...future.oldOptions)
[08:26:27.245]             if (.Platform$OS.type == "windows") {
[08:26:27.245]                 old_names <- names(...future.oldEnvVars)
[08:26:27.245]                 envs <- base::Sys.getenv()
[08:26:27.245]                 names <- names(envs)
[08:26:27.245]                 common <- intersect(names, old_names)
[08:26:27.245]                 added <- setdiff(names, old_names)
[08:26:27.245]                 removed <- setdiff(old_names, names)
[08:26:27.245]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:27.245]                   envs[common]]
[08:26:27.245]                 NAMES <- toupper(changed)
[08:26:27.245]                 args <- list()
[08:26:27.245]                 for (kk in seq_along(NAMES)) {
[08:26:27.245]                   name <- changed[[kk]]
[08:26:27.245]                   NAME <- NAMES[[kk]]
[08:26:27.245]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:27.245]                     next
[08:26:27.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:27.245]                 }
[08:26:27.245]                 NAMES <- toupper(added)
[08:26:27.245]                 for (kk in seq_along(NAMES)) {
[08:26:27.245]                   name <- added[[kk]]
[08:26:27.245]                   NAME <- NAMES[[kk]]
[08:26:27.245]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:27.245]                     next
[08:26:27.245]                   args[[name]] <- ""
[08:26:27.245]                 }
[08:26:27.245]                 NAMES <- toupper(removed)
[08:26:27.245]                 for (kk in seq_along(NAMES)) {
[08:26:27.245]                   name <- removed[[kk]]
[08:26:27.245]                   NAME <- NAMES[[kk]]
[08:26:27.245]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:27.245]                     next
[08:26:27.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:27.245]                 }
[08:26:27.245]                 if (length(args) > 0) 
[08:26:27.245]                   base::do.call(base::Sys.setenv, args = args)
[08:26:27.245]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:27.245]             }
[08:26:27.245]             else {
[08:26:27.245]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:27.245]             }
[08:26:27.245]             {
[08:26:27.245]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:27.245]                   0L) {
[08:26:27.245]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:27.245]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:27.245]                   base::options(opts)
[08:26:27.245]                 }
[08:26:27.245]                 {
[08:26:27.245]                   {
[08:26:27.245]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:27.245]                     NULL
[08:26:27.245]                   }
[08:26:27.245]                   options(future.plan = NULL)
[08:26:27.245]                   if (is.na(NA_character_)) 
[08:26:27.245]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:27.245]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:27.245]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:27.245]                     .init = FALSE)
[08:26:27.245]                 }
[08:26:27.245]             }
[08:26:27.245]         }
[08:26:27.245]     })
[08:26:27.245]     if (TRUE) {
[08:26:27.245]         base::sink(type = "output", split = FALSE)
[08:26:27.245]         if (TRUE) {
[08:26:27.245]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:27.245]         }
[08:26:27.245]         else {
[08:26:27.245]             ...future.result["stdout"] <- base::list(NULL)
[08:26:27.245]         }
[08:26:27.245]         base::close(...future.stdout)
[08:26:27.245]         ...future.stdout <- NULL
[08:26:27.245]     }
[08:26:27.245]     ...future.result$conditions <- ...future.conditions
[08:26:27.245]     ...future.result$finished <- base::Sys.time()
[08:26:27.245]     ...future.result
[08:26:27.245] }
[08:26:27.248] Exporting 11 global objects (16.77 KiB) to cluster node #1 ...
[08:26:27.248] Exporting ‘...future.FUN’ (6.73 KiB) to cluster node #1 ...
[08:26:27.289] Exporting ‘...future.FUN’ (6.73 KiB) to cluster node #1 ... DONE
[08:26:27.289] Exporting ‘x_FUN’ (41 bytes) to cluster node #1 ...
[08:26:27.289] Exporting ‘x_FUN’ (41 bytes) to cluster node #1 ... DONE
[08:26:27.290] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[08:26:27.290] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[08:26:27.290] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[08:26:27.331] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[08:26:27.332] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[08:26:27.373] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[08:26:27.373] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[08:26:27.373] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[08:26:27.373] Exporting ‘valid_types’ (46 bytes) to cluster node #1 ...
[08:26:27.374] Exporting ‘valid_types’ (46 bytes) to cluster node #1 ... DONE
[08:26:27.374] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:26:27.374] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:26:27.374] Exporting ‘...future.elements_ii’ (1.67 KiB) to cluster node #1 ...
[08:26:27.375] Exporting ‘...future.elements_ii’ (1.67 KiB) to cluster node #1 ... DONE
[08:26:27.375] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:26:27.375] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:26:27.375] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:26:27.376] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:26:27.376] Exporting 11 global objects (16.77 KiB) to cluster node #1 ... DONE
[08:26:27.376] MultisessionFuture started
[08:26:27.377] - Launch lazy future ... done
[08:26:27.377] run() for ‘MultisessionFuture’ ... done
[08:26:27.377] Created future:
[08:26:27.377] MultisessionFuture:
[08:26:27.377] Label: ‘future_vapply-1’
[08:26:27.377] Expression:
[08:26:27.377] {
[08:26:27.377]     do.call(function(...) {
[08:26:27.377]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:27.377]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:27.377]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:27.377]             on.exit(options(oopts), add = TRUE)
[08:26:27.377]         }
[08:26:27.377]         {
[08:26:27.377]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:27.377]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:27.377]                 ...future.FUN(...future.X_jj, ...)
[08:26:27.377]             })
[08:26:27.377]         }
[08:26:27.377]     }, args = future.call.arguments)
[08:26:27.377] }
[08:26:27.377] Lazy evaluation: FALSE
[08:26:27.377] Asynchronous evaluation: TRUE
[08:26:27.377] Local evaluation: TRUE
[08:26:27.377] Environment: R_GlobalEnv
[08:26:27.377] Capture standard output: TRUE
[08:26:27.377] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:27.377] Globals: 11 objects totaling 16.54 KiB (function ‘...future.FUN’ of 6.73 KiB, function ‘x_FUN’ of 41 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:27.377] Packages: 1 packages (‘future.apply’)
[08:26:27.377] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:27.377] Resolved: FALSE
[08:26:27.377] Value: <not collected>
[08:26:27.377] Conditions captured: <none>
[08:26:27.377] Early signaling: FALSE
[08:26:27.377] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:27.377] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:27.388] Chunk #1 of 2 ... DONE
[08:26:27.389] Chunk #2 of 2 ...
[08:26:27.389]  - Finding globals in 'X' for chunk #2 ...
[08:26:27.389] getGlobalsAndPackages() ...
[08:26:27.389] Searching for globals...
[08:26:27.389] 
[08:26:27.389] Searching for globals ... DONE
[08:26:27.389] - globals: [0] <none>
[08:26:27.389] getGlobalsAndPackages() ... DONE
[08:26:27.390]    + additional globals found: [n=0] 
[08:26:27.390]    + additional namespaces needed: [n=0] 
[08:26:27.390]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:27.390]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:27.390]  - seeds: <none>
[08:26:27.390]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:27.390] getGlobalsAndPackages() ...
[08:26:27.390] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:27.390] Resolving globals: FALSE
[08:26:27.390] Tweak future expression to call with '...' arguments ...
[08:26:27.391] {
[08:26:27.391]     do.call(function(...) {
[08:26:27.391]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:27.391]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:27.391]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:27.391]             on.exit(options(oopts), add = TRUE)
[08:26:27.391]         }
[08:26:27.391]         {
[08:26:27.391]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:27.391]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:27.391]                 ...future.FUN(...future.X_jj, ...)
[08:26:27.391]             })
[08:26:27.391]         }
[08:26:27.391]     }, args = future.call.arguments)
[08:26:27.391] }
[08:26:27.391] Tweak future expression to call with '...' arguments ... DONE
[08:26:27.391] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:27.391] - packages: [1] ‘future.apply’
[08:26:27.392] getGlobalsAndPackages() ... DONE
[08:26:27.392] run() for ‘Future’ ...
[08:26:27.392] - state: ‘created’
[08:26:27.392] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:27.406] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:27.407] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:27.407]   - Field: ‘node’
[08:26:27.407]   - Field: ‘label’
[08:26:27.407]   - Field: ‘local’
[08:26:27.407]   - Field: ‘owner’
[08:26:27.407]   - Field: ‘envir’
[08:26:27.407]   - Field: ‘workers’
[08:26:27.407]   - Field: ‘packages’
[08:26:27.407]   - Field: ‘gc’
[08:26:27.407]   - Field: ‘conditions’
[08:26:27.408]   - Field: ‘persistent’
[08:26:27.408]   - Field: ‘expr’
[08:26:27.408]   - Field: ‘uuid’
[08:26:27.408]   - Field: ‘seed’
[08:26:27.408]   - Field: ‘version’
[08:26:27.408]   - Field: ‘result’
[08:26:27.408]   - Field: ‘asynchronous’
[08:26:27.408]   - Field: ‘calls’
[08:26:27.408]   - Field: ‘globals’
[08:26:27.408]   - Field: ‘stdout’
[08:26:27.408]   - Field: ‘earlySignal’
[08:26:27.409]   - Field: ‘lazy’
[08:26:27.409]   - Field: ‘state’
[08:26:27.409] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:27.409] - Launch lazy future ...
[08:26:27.409] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:27.409] Packages needed by future strategies (n = 0): <none>
[08:26:27.410] {
[08:26:27.410]     {
[08:26:27.410]         {
[08:26:27.410]             ...future.startTime <- base::Sys.time()
[08:26:27.410]             {
[08:26:27.410]                 {
[08:26:27.410]                   {
[08:26:27.410]                     {
[08:26:27.410]                       {
[08:26:27.410]                         base::local({
[08:26:27.410]                           has_future <- base::requireNamespace("future", 
[08:26:27.410]                             quietly = TRUE)
[08:26:27.410]                           if (has_future) {
[08:26:27.410]                             ns <- base::getNamespace("future")
[08:26:27.410]                             version <- ns[[".package"]][["version"]]
[08:26:27.410]                             if (is.null(version)) 
[08:26:27.410]                               version <- utils::packageVersion("future")
[08:26:27.410]                           }
[08:26:27.410]                           else {
[08:26:27.410]                             version <- NULL
[08:26:27.410]                           }
[08:26:27.410]                           if (!has_future || version < "1.8.0") {
[08:26:27.410]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:27.410]                               "", base::R.version$version.string), 
[08:26:27.410]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:27.410]                                 base::R.version$platform, 8 * 
[08:26:27.410]                                   base::.Machine$sizeof.pointer), 
[08:26:27.410]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:27.410]                                 "release", "version")], collapse = " "), 
[08:26:27.410]                               hostname = base::Sys.info()[["nodename"]])
[08:26:27.410]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:27.410]                               info)
[08:26:27.410]                             info <- base::paste(info, collapse = "; ")
[08:26:27.410]                             if (!has_future) {
[08:26:27.410]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:27.410]                                 info)
[08:26:27.410]                             }
[08:26:27.410]                             else {
[08:26:27.410]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:27.410]                                 info, version)
[08:26:27.410]                             }
[08:26:27.410]                             base::stop(msg)
[08:26:27.410]                           }
[08:26:27.410]                         })
[08:26:27.410]                       }
[08:26:27.410]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:27.410]                       base::options(mc.cores = 1L)
[08:26:27.410]                     }
[08:26:27.410]                     base::local({
[08:26:27.410]                       for (pkg in "future.apply") {
[08:26:27.410]                         base::loadNamespace(pkg)
[08:26:27.410]                         base::library(pkg, character.only = TRUE)
[08:26:27.410]                       }
[08:26:27.410]                     })
[08:26:27.410]                   }
[08:26:27.410]                   ...future.strategy.old <- future::plan("list")
[08:26:27.410]                   options(future.plan = NULL)
[08:26:27.410]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:27.410]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:27.410]                 }
[08:26:27.410]                 ...future.workdir <- getwd()
[08:26:27.410]             }
[08:26:27.410]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:27.410]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:27.410]         }
[08:26:27.410]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:27.410]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:27.410]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:27.410]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:27.410]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:27.410]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:27.410]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:27.410]             base::names(...future.oldOptions))
[08:26:27.410]     }
[08:26:27.410]     if (FALSE) {
[08:26:27.410]     }
[08:26:27.410]     else {
[08:26:27.410]         if (TRUE) {
[08:26:27.410]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:27.410]                 open = "w")
[08:26:27.410]         }
[08:26:27.410]         else {
[08:26:27.410]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:27.410]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:27.410]         }
[08:26:27.410]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:27.410]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:27.410]             base::sink(type = "output", split = FALSE)
[08:26:27.410]             base::close(...future.stdout)
[08:26:27.410]         }, add = TRUE)
[08:26:27.410]     }
[08:26:27.410]     ...future.frame <- base::sys.nframe()
[08:26:27.410]     ...future.conditions <- base::list()
[08:26:27.410]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:27.410]     if (FALSE) {
[08:26:27.410]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:27.410]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:27.410]     }
[08:26:27.410]     ...future.result <- base::tryCatch({
[08:26:27.410]         base::withCallingHandlers({
[08:26:27.410]             ...future.value <- base::withVisible(base::local({
[08:26:27.410]                 ...future.makeSendCondition <- base::local({
[08:26:27.410]                   sendCondition <- NULL
[08:26:27.410]                   function(frame = 1L) {
[08:26:27.410]                     if (is.function(sendCondition)) 
[08:26:27.410]                       return(sendCondition)
[08:26:27.410]                     ns <- getNamespace("parallel")
[08:26:27.410]                     if (exists("sendData", mode = "function", 
[08:26:27.410]                       envir = ns)) {
[08:26:27.410]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:27.410]                         envir = ns)
[08:26:27.410]                       envir <- sys.frame(frame)
[08:26:27.410]                       master <- NULL
[08:26:27.410]                       while (!identical(envir, .GlobalEnv) && 
[08:26:27.410]                         !identical(envir, emptyenv())) {
[08:26:27.410]                         if (exists("master", mode = "list", envir = envir, 
[08:26:27.410]                           inherits = FALSE)) {
[08:26:27.410]                           master <- get("master", mode = "list", 
[08:26:27.410]                             envir = envir, inherits = FALSE)
[08:26:27.410]                           if (inherits(master, c("SOCKnode", 
[08:26:27.410]                             "SOCK0node"))) {
[08:26:27.410]                             sendCondition <<- function(cond) {
[08:26:27.410]                               data <- list(type = "VALUE", value = cond, 
[08:26:27.410]                                 success = TRUE)
[08:26:27.410]                               parallel_sendData(master, data)
[08:26:27.410]                             }
[08:26:27.410]                             return(sendCondition)
[08:26:27.410]                           }
[08:26:27.410]                         }
[08:26:27.410]                         frame <- frame + 1L
[08:26:27.410]                         envir <- sys.frame(frame)
[08:26:27.410]                       }
[08:26:27.410]                     }
[08:26:27.410]                     sendCondition <<- function(cond) NULL
[08:26:27.410]                   }
[08:26:27.410]                 })
[08:26:27.410]                 withCallingHandlers({
[08:26:27.410]                   {
[08:26:27.410]                     do.call(function(...) {
[08:26:27.410]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:27.410]                       if (!identical(...future.globals.maxSize.org, 
[08:26:27.410]                         ...future.globals.maxSize)) {
[08:26:27.410]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:27.410]                         on.exit(options(oopts), add = TRUE)
[08:26:27.410]                       }
[08:26:27.410]                       {
[08:26:27.410]                         lapply(seq_along(...future.elements_ii), 
[08:26:27.410]                           FUN = function(jj) {
[08:26:27.410]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:27.410]                             ...future.FUN(...future.X_jj, ...)
[08:26:27.410]                           })
[08:26:27.410]                       }
[08:26:27.410]                     }, args = future.call.arguments)
[08:26:27.410]                   }
[08:26:27.410]                 }, immediateCondition = function(cond) {
[08:26:27.410]                   sendCondition <- ...future.makeSendCondition()
[08:26:27.410]                   sendCondition(cond)
[08:26:27.410]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:27.410]                   {
[08:26:27.410]                     inherits <- base::inherits
[08:26:27.410]                     invokeRestart <- base::invokeRestart
[08:26:27.410]                     is.null <- base::is.null
[08:26:27.410]                     muffled <- FALSE
[08:26:27.410]                     if (inherits(cond, "message")) {
[08:26:27.410]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:27.410]                       if (muffled) 
[08:26:27.410]                         invokeRestart("muffleMessage")
[08:26:27.410]                     }
[08:26:27.410]                     else if (inherits(cond, "warning")) {
[08:26:27.410]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:27.410]                       if (muffled) 
[08:26:27.410]                         invokeRestart("muffleWarning")
[08:26:27.410]                     }
[08:26:27.410]                     else if (inherits(cond, "condition")) {
[08:26:27.410]                       if (!is.null(pattern)) {
[08:26:27.410]                         computeRestarts <- base::computeRestarts
[08:26:27.410]                         grepl <- base::grepl
[08:26:27.410]                         restarts <- computeRestarts(cond)
[08:26:27.410]                         for (restart in restarts) {
[08:26:27.410]                           name <- restart$name
[08:26:27.410]                           if (is.null(name)) 
[08:26:27.410]                             next
[08:26:27.410]                           if (!grepl(pattern, name)) 
[08:26:27.410]                             next
[08:26:27.410]                           invokeRestart(restart)
[08:26:27.410]                           muffled <- TRUE
[08:26:27.410]                           break
[08:26:27.410]                         }
[08:26:27.410]                       }
[08:26:27.410]                     }
[08:26:27.410]                     invisible(muffled)
[08:26:27.410]                   }
[08:26:27.410]                   muffleCondition(cond)
[08:26:27.410]                 })
[08:26:27.410]             }))
[08:26:27.410]             future::FutureResult(value = ...future.value$value, 
[08:26:27.410]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:27.410]                   ...future.rng), globalenv = if (FALSE) 
[08:26:27.410]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:27.410]                     ...future.globalenv.names))
[08:26:27.410]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:27.410]         }, condition = base::local({
[08:26:27.410]             c <- base::c
[08:26:27.410]             inherits <- base::inherits
[08:26:27.410]             invokeRestart <- base::invokeRestart
[08:26:27.410]             length <- base::length
[08:26:27.410]             list <- base::list
[08:26:27.410]             seq.int <- base::seq.int
[08:26:27.410]             signalCondition <- base::signalCondition
[08:26:27.410]             sys.calls <- base::sys.calls
[08:26:27.410]             `[[` <- base::`[[`
[08:26:27.410]             `+` <- base::`+`
[08:26:27.410]             `<<-` <- base::`<<-`
[08:26:27.410]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:27.410]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:27.410]                   3L)]
[08:26:27.410]             }
[08:26:27.410]             function(cond) {
[08:26:27.410]                 is_error <- inherits(cond, "error")
[08:26:27.410]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:27.410]                   NULL)
[08:26:27.410]                 if (is_error) {
[08:26:27.410]                   sessionInformation <- function() {
[08:26:27.410]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:27.410]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:27.410]                       search = base::search(), system = base::Sys.info())
[08:26:27.410]                   }
[08:26:27.410]                   ...future.conditions[[length(...future.conditions) + 
[08:26:27.410]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:27.410]                     cond$call), session = sessionInformation(), 
[08:26:27.410]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:27.410]                   signalCondition(cond)
[08:26:27.410]                 }
[08:26:27.410]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:27.410]                 "immediateCondition"))) {
[08:26:27.410]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:27.410]                   ...future.conditions[[length(...future.conditions) + 
[08:26:27.410]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:27.410]                   if (TRUE && !signal) {
[08:26:27.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:27.410]                     {
[08:26:27.410]                       inherits <- base::inherits
[08:26:27.410]                       invokeRestart <- base::invokeRestart
[08:26:27.410]                       is.null <- base::is.null
[08:26:27.410]                       muffled <- FALSE
[08:26:27.410]                       if (inherits(cond, "message")) {
[08:26:27.410]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:27.410]                         if (muffled) 
[08:26:27.410]                           invokeRestart("muffleMessage")
[08:26:27.410]                       }
[08:26:27.410]                       else if (inherits(cond, "warning")) {
[08:26:27.410]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:27.410]                         if (muffled) 
[08:26:27.410]                           invokeRestart("muffleWarning")
[08:26:27.410]                       }
[08:26:27.410]                       else if (inherits(cond, "condition")) {
[08:26:27.410]                         if (!is.null(pattern)) {
[08:26:27.410]                           computeRestarts <- base::computeRestarts
[08:26:27.410]                           grepl <- base::grepl
[08:26:27.410]                           restarts <- computeRestarts(cond)
[08:26:27.410]                           for (restart in restarts) {
[08:26:27.410]                             name <- restart$name
[08:26:27.410]                             if (is.null(name)) 
[08:26:27.410]                               next
[08:26:27.410]                             if (!grepl(pattern, name)) 
[08:26:27.410]                               next
[08:26:27.410]                             invokeRestart(restart)
[08:26:27.410]                             muffled <- TRUE
[08:26:27.410]                             break
[08:26:27.410]                           }
[08:26:27.410]                         }
[08:26:27.410]                       }
[08:26:27.410]                       invisible(muffled)
[08:26:27.410]                     }
[08:26:27.410]                     muffleCondition(cond, pattern = "^muffle")
[08:26:27.410]                   }
[08:26:27.410]                 }
[08:26:27.410]                 else {
[08:26:27.410]                   if (TRUE) {
[08:26:27.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:27.410]                     {
[08:26:27.410]                       inherits <- base::inherits
[08:26:27.410]                       invokeRestart <- base::invokeRestart
[08:26:27.410]                       is.null <- base::is.null
[08:26:27.410]                       muffled <- FALSE
[08:26:27.410]                       if (inherits(cond, "message")) {
[08:26:27.410]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:27.410]                         if (muffled) 
[08:26:27.410]                           invokeRestart("muffleMessage")
[08:26:27.410]                       }
[08:26:27.410]                       else if (inherits(cond, "warning")) {
[08:26:27.410]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:27.410]                         if (muffled) 
[08:26:27.410]                           invokeRestart("muffleWarning")
[08:26:27.410]                       }
[08:26:27.410]                       else if (inherits(cond, "condition")) {
[08:26:27.410]                         if (!is.null(pattern)) {
[08:26:27.410]                           computeRestarts <- base::computeRestarts
[08:26:27.410]                           grepl <- base::grepl
[08:26:27.410]                           restarts <- computeRestarts(cond)
[08:26:27.410]                           for (restart in restarts) {
[08:26:27.410]                             name <- restart$name
[08:26:27.410]                             if (is.null(name)) 
[08:26:27.410]                               next
[08:26:27.410]                             if (!grepl(pattern, name)) 
[08:26:27.410]                               next
[08:26:27.410]                             invokeRestart(restart)
[08:26:27.410]                             muffled <- TRUE
[08:26:27.410]                             break
[08:26:27.410]                           }
[08:26:27.410]                         }
[08:26:27.410]                       }
[08:26:27.410]                       invisible(muffled)
[08:26:27.410]                     }
[08:26:27.410]                     muffleCondition(cond, pattern = "^muffle")
[08:26:27.410]                   }
[08:26:27.410]                 }
[08:26:27.410]             }
[08:26:27.410]         }))
[08:26:27.410]     }, error = function(ex) {
[08:26:27.410]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:27.410]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:27.410]                 ...future.rng), started = ...future.startTime, 
[08:26:27.410]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:27.410]             version = "1.8"), class = "FutureResult")
[08:26:27.410]     }, finally = {
[08:26:27.410]         if (!identical(...future.workdir, getwd())) 
[08:26:27.410]             setwd(...future.workdir)
[08:26:27.410]         {
[08:26:27.410]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:27.410]                 ...future.oldOptions$nwarnings <- NULL
[08:26:27.410]             }
[08:26:27.410]             base::options(...future.oldOptions)
[08:26:27.410]             if (.Platform$OS.type == "windows") {
[08:26:27.410]                 old_names <- names(...future.oldEnvVars)
[08:26:27.410]                 envs <- base::Sys.getenv()
[08:26:27.410]                 names <- names(envs)
[08:26:27.410]                 common <- intersect(names, old_names)
[08:26:27.410]                 added <- setdiff(names, old_names)
[08:26:27.410]                 removed <- setdiff(old_names, names)
[08:26:27.410]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:27.410]                   envs[common]]
[08:26:27.410]                 NAMES <- toupper(changed)
[08:26:27.410]                 args <- list()
[08:26:27.410]                 for (kk in seq_along(NAMES)) {
[08:26:27.410]                   name <- changed[[kk]]
[08:26:27.410]                   NAME <- NAMES[[kk]]
[08:26:27.410]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:27.410]                     next
[08:26:27.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:27.410]                 }
[08:26:27.410]                 NAMES <- toupper(added)
[08:26:27.410]                 for (kk in seq_along(NAMES)) {
[08:26:27.410]                   name <- added[[kk]]
[08:26:27.410]                   NAME <- NAMES[[kk]]
[08:26:27.410]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:27.410]                     next
[08:26:27.410]                   args[[name]] <- ""
[08:26:27.410]                 }
[08:26:27.410]                 NAMES <- toupper(removed)
[08:26:27.410]                 for (kk in seq_along(NAMES)) {
[08:26:27.410]                   name <- removed[[kk]]
[08:26:27.410]                   NAME <- NAMES[[kk]]
[08:26:27.410]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:27.410]                     next
[08:26:27.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:27.410]                 }
[08:26:27.410]                 if (length(args) > 0) 
[08:26:27.410]                   base::do.call(base::Sys.setenv, args = args)
[08:26:27.410]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:27.410]             }
[08:26:27.410]             else {
[08:26:27.410]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:27.410]             }
[08:26:27.410]             {
[08:26:27.410]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:27.410]                   0L) {
[08:26:27.410]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:27.410]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:27.410]                   base::options(opts)
[08:26:27.410]                 }
[08:26:27.410]                 {
[08:26:27.410]                   {
[08:26:27.410]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:27.410]                     NULL
[08:26:27.410]                   }
[08:26:27.410]                   options(future.plan = NULL)
[08:26:27.410]                   if (is.na(NA_character_)) 
[08:26:27.410]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:27.410]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:27.410]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:27.410]                     .init = FALSE)
[08:26:27.410]                 }
[08:26:27.410]             }
[08:26:27.410]         }
[08:26:27.410]     })
[08:26:27.410]     if (TRUE) {
[08:26:27.410]         base::sink(type = "output", split = FALSE)
[08:26:27.410]         if (TRUE) {
[08:26:27.410]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:27.410]         }
[08:26:27.410]         else {
[08:26:27.410]             ...future.result["stdout"] <- base::list(NULL)
[08:26:27.410]         }
[08:26:27.410]         base::close(...future.stdout)
[08:26:27.410]         ...future.stdout <- NULL
[08:26:27.410]     }
[08:26:27.410]     ...future.result$conditions <- ...future.conditions
[08:26:27.410]     ...future.result$finished <- base::Sys.time()
[08:26:27.410]     ...future.result
[08:26:27.410] }
[08:26:27.413] Exporting 11 global objects (16.50 KiB) to cluster node #2 ...
[08:26:27.413] Exporting ‘...future.FUN’ (6.73 KiB) to cluster node #2 ...
[08:26:27.455] Exporting ‘...future.FUN’ (6.73 KiB) to cluster node #2 ... DONE
[08:26:27.455] Exporting ‘x_FUN’ (41 bytes) to cluster node #2 ...
[08:26:27.455] Exporting ‘x_FUN’ (41 bytes) to cluster node #2 ... DONE
[08:26:27.455] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[08:26:27.456] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[08:26:27.456] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[08:26:27.497] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[08:26:27.498] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[08:26:27.539] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[08:26:27.539] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[08:26:27.539] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[08:26:27.539] Exporting ‘valid_types’ (46 bytes) to cluster node #2 ...
[08:26:27.540] Exporting ‘valid_types’ (46 bytes) to cluster node #2 ... DONE
[08:26:27.540] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:26:27.540] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:26:27.540] Exporting ‘...future.elements_ii’ (1.41 KiB) to cluster node #2 ...
[08:26:27.541] Exporting ‘...future.elements_ii’ (1.41 KiB) to cluster node #2 ... DONE
[08:26:27.541] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:26:27.541] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:26:27.541] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:26:27.542] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:26:27.542] Exporting 11 global objects (16.50 KiB) to cluster node #2 ... DONE
[08:26:27.542] MultisessionFuture started
[08:26:27.542] - Launch lazy future ... done
[08:26:27.543] run() for ‘MultisessionFuture’ ... done
[08:26:27.543] Created future:
[08:26:27.543] MultisessionFuture:
[08:26:27.543] Label: ‘future_vapply-2’
[08:26:27.543] Expression:
[08:26:27.543] {
[08:26:27.543]     do.call(function(...) {
[08:26:27.543]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:27.543]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:27.543]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:27.543]             on.exit(options(oopts), add = TRUE)
[08:26:27.543]         }
[08:26:27.543]         {
[08:26:27.543]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:27.543]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:27.543]                 ...future.FUN(...future.X_jj, ...)
[08:26:27.543]             })
[08:26:27.543]         }
[08:26:27.543]     }, args = future.call.arguments)
[08:26:27.543] }
[08:26:27.543] Lazy evaluation: FALSE
[08:26:27.543] Asynchronous evaluation: TRUE
[08:26:27.543] Local evaluation: TRUE
[08:26:27.543] Environment: R_GlobalEnv
[08:26:27.543] Capture standard output: TRUE
[08:26:27.543] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:27.543] Globals: 11 objects totaling 16.28 KiB (function ‘...future.FUN’ of 6.73 KiB, function ‘x_FUN’ of 41 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:27.543] Packages: 1 packages (‘future.apply’)
[08:26:27.543] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:27.543] Resolved: FALSE
[08:26:27.543] Value: <not collected>
[08:26:27.543] Conditions captured: <none>
[08:26:27.543] Early signaling: FALSE
[08:26:27.543] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:27.543] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:27.554] Chunk #2 of 2 ... DONE
[08:26:27.555] Launching 2 futures (chunks) ... DONE
[08:26:27.555] Resolving 2 futures (chunks) ...
[08:26:27.555] resolve() on list ...
[08:26:27.555]  recursive: 0
[08:26:27.555]  length: 2
[08:26:27.555] 
[08:26:27.555] receiveMessageFromWorker() for ClusterFuture ...
[08:26:27.556] - Validating connection of MultisessionFuture
[08:26:27.556] - received message: FutureResult
[08:26:27.556] - Received FutureResult
[08:26:27.556] - Erased future from FutureRegistry
[08:26:27.556] result() for ClusterFuture ...
[08:26:27.556] - result already collected: FutureResult
[08:26:27.556] result() for ClusterFuture ... done
[08:26:27.556] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:27.556] Future #1
[08:26:27.557] result() for ClusterFuture ...
[08:26:27.557] - result already collected: FutureResult
[08:26:27.557] result() for ClusterFuture ... done
[08:26:27.557] result() for ClusterFuture ...
[08:26:27.557] - result already collected: FutureResult
[08:26:27.557] result() for ClusterFuture ... done
[08:26:27.557] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:26:27.557] - nx: 2
[08:26:27.557] - relay: TRUE
[08:26:27.557] - stdout: TRUE
[08:26:27.557] - signal: TRUE
[08:26:27.557] - resignal: FALSE
[08:26:27.558] - force: TRUE
[08:26:27.558] - relayed: [n=2] FALSE, FALSE
[08:26:27.558] - queued futures: [n=2] FALSE, FALSE
[08:26:27.558]  - until=1
[08:26:27.558]  - relaying element #1
[08:26:27.558] result() for ClusterFuture ...
[08:26:27.558] - result already collected: FutureResult
[08:26:27.558] result() for ClusterFuture ... done
[08:26:27.558] result() for ClusterFuture ...
[08:26:27.558] - result already collected: FutureResult
[08:26:27.558] result() for ClusterFuture ... done
[08:26:27.559] result() for ClusterFuture ...
[08:26:27.559] - result already collected: FutureResult
[08:26:27.559] result() for ClusterFuture ... done
[08:26:27.559] result() for ClusterFuture ...
[08:26:27.559] - result already collected: FutureResult
[08:26:27.559] result() for ClusterFuture ... done
[08:26:27.559] - relayed: [n=2] TRUE, FALSE
[08:26:27.559] - queued futures: [n=2] TRUE, FALSE
[08:26:27.559] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:26:27.559]  length: 1 (resolved future 1)
[08:26:27.584] receiveMessageFromWorker() for ClusterFuture ...
[08:26:27.585] - Validating connection of MultisessionFuture
[08:26:27.585] - received message: FutureResult
[08:26:27.585] - Received FutureResult
[08:26:27.585] - Erased future from FutureRegistry
[08:26:27.585] result() for ClusterFuture ...
[08:26:27.585] - result already collected: FutureResult
[08:26:27.585] result() for ClusterFuture ... done
[08:26:27.585] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:27.585] Future #2
[08:26:27.586] result() for ClusterFuture ...
[08:26:27.586] - result already collected: FutureResult
[08:26:27.586] result() for ClusterFuture ... done
[08:26:27.586] result() for ClusterFuture ...
[08:26:27.586] - result already collected: FutureResult
[08:26:27.586] result() for ClusterFuture ... done
[08:26:27.586] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:26:27.586] - nx: 2
[08:26:27.586] - relay: TRUE
[08:26:27.586] - stdout: TRUE
[08:26:27.586] - signal: TRUE
[08:26:27.586] - resignal: FALSE
[08:26:27.587] - force: TRUE
[08:26:27.587] - relayed: [n=2] TRUE, FALSE
[08:26:27.587] - queued futures: [n=2] TRUE, FALSE
[08:26:27.587]  - until=2
[08:26:27.587]  - relaying element #2
[08:26:27.587] result() for ClusterFuture ...
[08:26:27.587] - result already collected: FutureResult
[08:26:27.587] result() for ClusterFuture ... done
[08:26:27.587] result() for ClusterFuture ...
[08:26:27.587] - result already collected: FutureResult
[08:26:27.587] result() for ClusterFuture ... done
[08:26:27.588] result() for ClusterFuture ...
[08:26:27.588] - result already collected: FutureResult
[08:26:27.588] result() for ClusterFuture ... done
[08:26:27.588] result() for ClusterFuture ...
[08:26:27.588] - result already collected: FutureResult
[08:26:27.588] result() for ClusterFuture ... done
[08:26:27.588] - relayed: [n=2] TRUE, TRUE
[08:26:27.588] - queued futures: [n=2] TRUE, TRUE
[08:26:27.588] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:26:27.588]  length: 0 (resolved future 2)
[08:26:27.588] Relaying remaining futures
[08:26:27.588] signalConditionsASAP(NULL, pos=0) ...
[08:26:27.588] - nx: 2
[08:26:27.589] - relay: TRUE
[08:26:27.589] - stdout: TRUE
[08:26:27.589] - signal: TRUE
[08:26:27.589] - resignal: FALSE
[08:26:27.589] - force: TRUE
[08:26:27.589] - relayed: [n=2] TRUE, TRUE
[08:26:27.589] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:27.589] - relayed: [n=2] TRUE, TRUE
[08:26:27.589] - queued futures: [n=2] TRUE, TRUE
[08:26:27.589] signalConditionsASAP(NULL, pos=0) ... done
[08:26:27.589] resolve() on list ... DONE
[08:26:27.590] result() for ClusterFuture ...
[08:26:27.590] - result already collected: FutureResult
[08:26:27.590] result() for ClusterFuture ... done
[08:26:27.590] result() for ClusterFuture ...
[08:26:27.590] - result already collected: FutureResult
[08:26:27.590] result() for ClusterFuture ... done
[08:26:27.590] result() for ClusterFuture ...
[08:26:27.590] - result already collected: FutureResult
[08:26:27.590] result() for ClusterFuture ... done
[08:26:27.590] result() for ClusterFuture ...
[08:26:27.590] - result already collected: FutureResult
[08:26:27.590] result() for ClusterFuture ... done
[08:26:27.591]  - Number of value chunks collected: 2
[08:26:27.591] Resolving 2 futures (chunks) ... DONE
[08:26:27.591] Reducing values from 2 chunks ...
[08:26:27.591]  - Number of values collected after concatenation: 11
[08:26:27.591]  - Number of values expected: 11
[08:26:27.591] Reducing values from 2 chunks ... DONE
[08:26:27.591] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[08:26:27.592] future_lapply() ...
[08:26:27.595] Number of chunks: 2
[08:26:27.595] getGlobalsAndPackagesXApply() ...
[08:26:27.595]  - future.globals: TRUE
[08:26:27.596] getGlobalsAndPackages() ...
[08:26:27.596] Searching for globals...
[08:26:27.599] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[08:26:27.599] Searching for globals ... DONE
[08:26:27.599] Resolving globals: FALSE
[08:26:27.600] The total size of the 7 globals is 11.92 KiB (12201 bytes)
[08:26:27.600] The total size of the 7 globals exported for future expression (‘FUN()’) is 11.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (3.92 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:27.600] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:27.600] - packages: [1] ‘future.apply’
[08:26:27.600] getGlobalsAndPackages() ... DONE
[08:26:27.600]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:27.601]  - needed namespaces: [n=1] ‘future.apply’
[08:26:27.601] Finding globals ... DONE
[08:26:27.601]  - use_args: TRUE
[08:26:27.601]  - Getting '...' globals ...
[08:26:27.601] resolve() on list ...
[08:26:27.601]  recursive: 0
[08:26:27.601]  length: 1
[08:26:27.601]  elements: ‘...’
[08:26:27.602]  length: 0 (resolved future 1)
[08:26:27.602] resolve() on list ... DONE
[08:26:27.602]    - '...' content: [n=0] 
[08:26:27.602] List of 1
[08:26:27.602]  $ ...: list()
[08:26:27.602]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:27.602]  - attr(*, "where")=List of 1
[08:26:27.602]   ..$ ...:<environment: 0x562caa18d348> 
[08:26:27.602]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:27.602]  - attr(*, "resolved")= logi TRUE
[08:26:27.602]  - attr(*, "total_size")= num NA
[08:26:27.604]  - Getting '...' globals ... DONE
[08:26:27.604] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:27.604] List of 8
[08:26:27.604]  $ ...future.FUN:function (x, ...)  
[08:26:27.604]  $ x_FUN        :function (x)  
[08:26:27.604]  $ times        : int 1
[08:26:27.604]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:27.604]  $ stop_if_not  :function (...)  
[08:26:27.604]  $ dim          : NULL
[08:26:27.604]  $ valid_types  : chr [1:2] "logical" "integer"
[08:26:27.604]  $ ...          : list()
[08:26:27.604]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:27.604]  - attr(*, "where")=List of 8
[08:26:27.604]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:27.604]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:27.604]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:27.604]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:27.604]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:27.604]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:27.604]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:27.604]   ..$ ...          :<environment: 0x562caa18d348> 
[08:26:27.604]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:27.604]  - attr(*, "resolved")= logi FALSE
[08:26:27.604]  - attr(*, "total_size")= num 22016
[08:26:27.610] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:27.610] getGlobalsAndPackagesXApply() ... DONE
[08:26:27.610] Number of futures (= number of chunks): 2
[08:26:27.610] Launching 2 futures (chunks) ...
[08:26:27.610] Chunk #1 of 2 ...
[08:26:27.610]  - Finding globals in 'X' for chunk #1 ...
[08:26:27.610] getGlobalsAndPackages() ...
[08:26:27.610] Searching for globals...
[08:26:27.611] 
[08:26:27.611] Searching for globals ... DONE
[08:26:27.611] - globals: [0] <none>
[08:26:27.611] getGlobalsAndPackages() ... DONE
[08:26:27.611]    + additional globals found: [n=0] 
[08:26:27.611]    + additional namespaces needed: [n=0] 
[08:26:27.611]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:27.611]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:27.611]  - seeds: <none>
[08:26:27.611]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:27.612] getGlobalsAndPackages() ...
[08:26:27.612] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:27.612] Resolving globals: FALSE
[08:26:27.612] Tweak future expression to call with '...' arguments ...
[08:26:27.612] {
[08:26:27.612]     do.call(function(...) {
[08:26:27.612]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:27.612]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:27.612]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:27.612]             on.exit(options(oopts), add = TRUE)
[08:26:27.612]         }
[08:26:27.612]         {
[08:26:27.612]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:27.612]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:27.612]                 ...future.FUN(...future.X_jj, ...)
[08:26:27.612]             })
[08:26:27.612]         }
[08:26:27.612]     }, args = future.call.arguments)
[08:26:27.612] }
[08:26:27.612] Tweak future expression to call with '...' arguments ... DONE
[08:26:27.613] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:27.613] - packages: [1] ‘future.apply’
[08:26:27.613] getGlobalsAndPackages() ... DONE
[08:26:27.613] run() for ‘Future’ ...
[08:26:27.614] - state: ‘created’
[08:26:27.614] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:27.631] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:27.631] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:27.631]   - Field: ‘node’
[08:26:27.631]   - Field: ‘label’
[08:26:27.631]   - Field: ‘local’
[08:26:27.632]   - Field: ‘owner’
[08:26:27.632]   - Field: ‘envir’
[08:26:27.632]   - Field: ‘workers’
[08:26:27.632]   - Field: ‘packages’
[08:26:27.632]   - Field: ‘gc’
[08:26:27.632]   - Field: ‘conditions’
[08:26:27.632]   - Field: ‘persistent’
[08:26:27.632]   - Field: ‘expr’
[08:26:27.632]   - Field: ‘uuid’
[08:26:27.632]   - Field: ‘seed’
[08:26:27.632]   - Field: ‘version’
[08:26:27.632]   - Field: ‘result’
[08:26:27.633]   - Field: ‘asynchronous’
[08:26:27.633]   - Field: ‘calls’
[08:26:27.633]   - Field: ‘globals’
[08:26:27.633]   - Field: ‘stdout’
[08:26:27.633]   - Field: ‘earlySignal’
[08:26:27.633]   - Field: ‘lazy’
[08:26:27.633]   - Field: ‘state’
[08:26:27.633] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:27.633] - Launch lazy future ...
[08:26:27.633] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:27.634] Packages needed by future strategies (n = 0): <none>
[08:26:27.634] {
[08:26:27.634]     {
[08:26:27.634]         {
[08:26:27.634]             ...future.startTime <- base::Sys.time()
[08:26:27.634]             {
[08:26:27.634]                 {
[08:26:27.634]                   {
[08:26:27.634]                     {
[08:26:27.634]                       {
[08:26:27.634]                         base::local({
[08:26:27.634]                           has_future <- base::requireNamespace("future", 
[08:26:27.634]                             quietly = TRUE)
[08:26:27.634]                           if (has_future) {
[08:26:27.634]                             ns <- base::getNamespace("future")
[08:26:27.634]                             version <- ns[[".package"]][["version"]]
[08:26:27.634]                             if (is.null(version)) 
[08:26:27.634]                               version <- utils::packageVersion("future")
[08:26:27.634]                           }
[08:26:27.634]                           else {
[08:26:27.634]                             version <- NULL
[08:26:27.634]                           }
[08:26:27.634]                           if (!has_future || version < "1.8.0") {
[08:26:27.634]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:27.634]                               "", base::R.version$version.string), 
[08:26:27.634]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:27.634]                                 base::R.version$platform, 8 * 
[08:26:27.634]                                   base::.Machine$sizeof.pointer), 
[08:26:27.634]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:27.634]                                 "release", "version")], collapse = " "), 
[08:26:27.634]                               hostname = base::Sys.info()[["nodename"]])
[08:26:27.634]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:27.634]                               info)
[08:26:27.634]                             info <- base::paste(info, collapse = "; ")
[08:26:27.634]                             if (!has_future) {
[08:26:27.634]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:27.634]                                 info)
[08:26:27.634]                             }
[08:26:27.634]                             else {
[08:26:27.634]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:27.634]                                 info, version)
[08:26:27.634]                             }
[08:26:27.634]                             base::stop(msg)
[08:26:27.634]                           }
[08:26:27.634]                         })
[08:26:27.634]                       }
[08:26:27.634]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:27.634]                       base::options(mc.cores = 1L)
[08:26:27.634]                     }
[08:26:27.634]                     base::local({
[08:26:27.634]                       for (pkg in "future.apply") {
[08:26:27.634]                         base::loadNamespace(pkg)
[08:26:27.634]                         base::library(pkg, character.only = TRUE)
[08:26:27.634]                       }
[08:26:27.634]                     })
[08:26:27.634]                   }
[08:26:27.634]                   ...future.strategy.old <- future::plan("list")
[08:26:27.634]                   options(future.plan = NULL)
[08:26:27.634]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:27.634]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:27.634]                 }
[08:26:27.634]                 ...future.workdir <- getwd()
[08:26:27.634]             }
[08:26:27.634]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:27.634]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:27.634]         }
[08:26:27.634]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:27.634]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:27.634]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:27.634]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:27.634]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:27.634]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:27.634]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:27.634]             base::names(...future.oldOptions))
[08:26:27.634]     }
[08:26:27.634]     if (FALSE) {
[08:26:27.634]     }
[08:26:27.634]     else {
[08:26:27.634]         if (TRUE) {
[08:26:27.634]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:27.634]                 open = "w")
[08:26:27.634]         }
[08:26:27.634]         else {
[08:26:27.634]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:27.634]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:27.634]         }
[08:26:27.634]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:27.634]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:27.634]             base::sink(type = "output", split = FALSE)
[08:26:27.634]             base::close(...future.stdout)
[08:26:27.634]         }, add = TRUE)
[08:26:27.634]     }
[08:26:27.634]     ...future.frame <- base::sys.nframe()
[08:26:27.634]     ...future.conditions <- base::list()
[08:26:27.634]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:27.634]     if (FALSE) {
[08:26:27.634]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:27.634]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:27.634]     }
[08:26:27.634]     ...future.result <- base::tryCatch({
[08:26:27.634]         base::withCallingHandlers({
[08:26:27.634]             ...future.value <- base::withVisible(base::local({
[08:26:27.634]                 ...future.makeSendCondition <- base::local({
[08:26:27.634]                   sendCondition <- NULL
[08:26:27.634]                   function(frame = 1L) {
[08:26:27.634]                     if (is.function(sendCondition)) 
[08:26:27.634]                       return(sendCondition)
[08:26:27.634]                     ns <- getNamespace("parallel")
[08:26:27.634]                     if (exists("sendData", mode = "function", 
[08:26:27.634]                       envir = ns)) {
[08:26:27.634]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:27.634]                         envir = ns)
[08:26:27.634]                       envir <- sys.frame(frame)
[08:26:27.634]                       master <- NULL
[08:26:27.634]                       while (!identical(envir, .GlobalEnv) && 
[08:26:27.634]                         !identical(envir, emptyenv())) {
[08:26:27.634]                         if (exists("master", mode = "list", envir = envir, 
[08:26:27.634]                           inherits = FALSE)) {
[08:26:27.634]                           master <- get("master", mode = "list", 
[08:26:27.634]                             envir = envir, inherits = FALSE)
[08:26:27.634]                           if (inherits(master, c("SOCKnode", 
[08:26:27.634]                             "SOCK0node"))) {
[08:26:27.634]                             sendCondition <<- function(cond) {
[08:26:27.634]                               data <- list(type = "VALUE", value = cond, 
[08:26:27.634]                                 success = TRUE)
[08:26:27.634]                               parallel_sendData(master, data)
[08:26:27.634]                             }
[08:26:27.634]                             return(sendCondition)
[08:26:27.634]                           }
[08:26:27.634]                         }
[08:26:27.634]                         frame <- frame + 1L
[08:26:27.634]                         envir <- sys.frame(frame)
[08:26:27.634]                       }
[08:26:27.634]                     }
[08:26:27.634]                     sendCondition <<- function(cond) NULL
[08:26:27.634]                   }
[08:26:27.634]                 })
[08:26:27.634]                 withCallingHandlers({
[08:26:27.634]                   {
[08:26:27.634]                     do.call(function(...) {
[08:26:27.634]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:27.634]                       if (!identical(...future.globals.maxSize.org, 
[08:26:27.634]                         ...future.globals.maxSize)) {
[08:26:27.634]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:27.634]                         on.exit(options(oopts), add = TRUE)
[08:26:27.634]                       }
[08:26:27.634]                       {
[08:26:27.634]                         lapply(seq_along(...future.elements_ii), 
[08:26:27.634]                           FUN = function(jj) {
[08:26:27.634]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:27.634]                             ...future.FUN(...future.X_jj, ...)
[08:26:27.634]                           })
[08:26:27.634]                       }
[08:26:27.634]                     }, args = future.call.arguments)
[08:26:27.634]                   }
[08:26:27.634]                 }, immediateCondition = function(cond) {
[08:26:27.634]                   sendCondition <- ...future.makeSendCondition()
[08:26:27.634]                   sendCondition(cond)
[08:26:27.634]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:27.634]                   {
[08:26:27.634]                     inherits <- base::inherits
[08:26:27.634]                     invokeRestart <- base::invokeRestart
[08:26:27.634]                     is.null <- base::is.null
[08:26:27.634]                     muffled <- FALSE
[08:26:27.634]                     if (inherits(cond, "message")) {
[08:26:27.634]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:27.634]                       if (muffled) 
[08:26:27.634]                         invokeRestart("muffleMessage")
[08:26:27.634]                     }
[08:26:27.634]                     else if (inherits(cond, "warning")) {
[08:26:27.634]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:27.634]                       if (muffled) 
[08:26:27.634]                         invokeRestart("muffleWarning")
[08:26:27.634]                     }
[08:26:27.634]                     else if (inherits(cond, "condition")) {
[08:26:27.634]                       if (!is.null(pattern)) {
[08:26:27.634]                         computeRestarts <- base::computeRestarts
[08:26:27.634]                         grepl <- base::grepl
[08:26:27.634]                         restarts <- computeRestarts(cond)
[08:26:27.634]                         for (restart in restarts) {
[08:26:27.634]                           name <- restart$name
[08:26:27.634]                           if (is.null(name)) 
[08:26:27.634]                             next
[08:26:27.634]                           if (!grepl(pattern, name)) 
[08:26:27.634]                             next
[08:26:27.634]                           invokeRestart(restart)
[08:26:27.634]                           muffled <- TRUE
[08:26:27.634]                           break
[08:26:27.634]                         }
[08:26:27.634]                       }
[08:26:27.634]                     }
[08:26:27.634]                     invisible(muffled)
[08:26:27.634]                   }
[08:26:27.634]                   muffleCondition(cond)
[08:26:27.634]                 })
[08:26:27.634]             }))
[08:26:27.634]             future::FutureResult(value = ...future.value$value, 
[08:26:27.634]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:27.634]                   ...future.rng), globalenv = if (FALSE) 
[08:26:27.634]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:27.634]                     ...future.globalenv.names))
[08:26:27.634]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:27.634]         }, condition = base::local({
[08:26:27.634]             c <- base::c
[08:26:27.634]             inherits <- base::inherits
[08:26:27.634]             invokeRestart <- base::invokeRestart
[08:26:27.634]             length <- base::length
[08:26:27.634]             list <- base::list
[08:26:27.634]             seq.int <- base::seq.int
[08:26:27.634]             signalCondition <- base::signalCondition
[08:26:27.634]             sys.calls <- base::sys.calls
[08:26:27.634]             `[[` <- base::`[[`
[08:26:27.634]             `+` <- base::`+`
[08:26:27.634]             `<<-` <- base::`<<-`
[08:26:27.634]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:27.634]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:27.634]                   3L)]
[08:26:27.634]             }
[08:26:27.634]             function(cond) {
[08:26:27.634]                 is_error <- inherits(cond, "error")
[08:26:27.634]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:27.634]                   NULL)
[08:26:27.634]                 if (is_error) {
[08:26:27.634]                   sessionInformation <- function() {
[08:26:27.634]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:27.634]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:27.634]                       search = base::search(), system = base::Sys.info())
[08:26:27.634]                   }
[08:26:27.634]                   ...future.conditions[[length(...future.conditions) + 
[08:26:27.634]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:27.634]                     cond$call), session = sessionInformation(), 
[08:26:27.634]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:27.634]                   signalCondition(cond)
[08:26:27.634]                 }
[08:26:27.634]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:27.634]                 "immediateCondition"))) {
[08:26:27.634]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:27.634]                   ...future.conditions[[length(...future.conditions) + 
[08:26:27.634]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:27.634]                   if (TRUE && !signal) {
[08:26:27.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:27.634]                     {
[08:26:27.634]                       inherits <- base::inherits
[08:26:27.634]                       invokeRestart <- base::invokeRestart
[08:26:27.634]                       is.null <- base::is.null
[08:26:27.634]                       muffled <- FALSE
[08:26:27.634]                       if (inherits(cond, "message")) {
[08:26:27.634]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:27.634]                         if (muffled) 
[08:26:27.634]                           invokeRestart("muffleMessage")
[08:26:27.634]                       }
[08:26:27.634]                       else if (inherits(cond, "warning")) {
[08:26:27.634]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:27.634]                         if (muffled) 
[08:26:27.634]                           invokeRestart("muffleWarning")
[08:26:27.634]                       }
[08:26:27.634]                       else if (inherits(cond, "condition")) {
[08:26:27.634]                         if (!is.null(pattern)) {
[08:26:27.634]                           computeRestarts <- base::computeRestarts
[08:26:27.634]                           grepl <- base::grepl
[08:26:27.634]                           restarts <- computeRestarts(cond)
[08:26:27.634]                           for (restart in restarts) {
[08:26:27.634]                             name <- restart$name
[08:26:27.634]                             if (is.null(name)) 
[08:26:27.634]                               next
[08:26:27.634]                             if (!grepl(pattern, name)) 
[08:26:27.634]                               next
[08:26:27.634]                             invokeRestart(restart)
[08:26:27.634]                             muffled <- TRUE
[08:26:27.634]                             break
[08:26:27.634]                           }
[08:26:27.634]                         }
[08:26:27.634]                       }
[08:26:27.634]                       invisible(muffled)
[08:26:27.634]                     }
[08:26:27.634]                     muffleCondition(cond, pattern = "^muffle")
[08:26:27.634]                   }
[08:26:27.634]                 }
[08:26:27.634]                 else {
[08:26:27.634]                   if (TRUE) {
[08:26:27.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:27.634]                     {
[08:26:27.634]                       inherits <- base::inherits
[08:26:27.634]                       invokeRestart <- base::invokeRestart
[08:26:27.634]                       is.null <- base::is.null
[08:26:27.634]                       muffled <- FALSE
[08:26:27.634]                       if (inherits(cond, "message")) {
[08:26:27.634]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:27.634]                         if (muffled) 
[08:26:27.634]                           invokeRestart("muffleMessage")
[08:26:27.634]                       }
[08:26:27.634]                       else if (inherits(cond, "warning")) {
[08:26:27.634]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:27.634]                         if (muffled) 
[08:26:27.634]                           invokeRestart("muffleWarning")
[08:26:27.634]                       }
[08:26:27.634]                       else if (inherits(cond, "condition")) {
[08:26:27.634]                         if (!is.null(pattern)) {
[08:26:27.634]                           computeRestarts <- base::computeRestarts
[08:26:27.634]                           grepl <- base::grepl
[08:26:27.634]                           restarts <- computeRestarts(cond)
[08:26:27.634]                           for (restart in restarts) {
[08:26:27.634]                             name <- restart$name
[08:26:27.634]                             if (is.null(name)) 
[08:26:27.634]                               next
[08:26:27.634]                             if (!grepl(pattern, name)) 
[08:26:27.634]                               next
[08:26:27.634]                             invokeRestart(restart)
[08:26:27.634]                             muffled <- TRUE
[08:26:27.634]                             break
[08:26:27.634]                           }
[08:26:27.634]                         }
[08:26:27.634]                       }
[08:26:27.634]                       invisible(muffled)
[08:26:27.634]                     }
[08:26:27.634]                     muffleCondition(cond, pattern = "^muffle")
[08:26:27.634]                   }
[08:26:27.634]                 }
[08:26:27.634]             }
[08:26:27.634]         }))
[08:26:27.634]     }, error = function(ex) {
[08:26:27.634]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:27.634]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:27.634]                 ...future.rng), started = ...future.startTime, 
[08:26:27.634]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:27.634]             version = "1.8"), class = "FutureResult")
[08:26:27.634]     }, finally = {
[08:26:27.634]         if (!identical(...future.workdir, getwd())) 
[08:26:27.634]             setwd(...future.workdir)
[08:26:27.634]         {
[08:26:27.634]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:27.634]                 ...future.oldOptions$nwarnings <- NULL
[08:26:27.634]             }
[08:26:27.634]             base::options(...future.oldOptions)
[08:26:27.634]             if (.Platform$OS.type == "windows") {
[08:26:27.634]                 old_names <- names(...future.oldEnvVars)
[08:26:27.634]                 envs <- base::Sys.getenv()
[08:26:27.634]                 names <- names(envs)
[08:26:27.634]                 common <- intersect(names, old_names)
[08:26:27.634]                 added <- setdiff(names, old_names)
[08:26:27.634]                 removed <- setdiff(old_names, names)
[08:26:27.634]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:27.634]                   envs[common]]
[08:26:27.634]                 NAMES <- toupper(changed)
[08:26:27.634]                 args <- list()
[08:26:27.634]                 for (kk in seq_along(NAMES)) {
[08:26:27.634]                   name <- changed[[kk]]
[08:26:27.634]                   NAME <- NAMES[[kk]]
[08:26:27.634]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:27.634]                     next
[08:26:27.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:27.634]                 }
[08:26:27.634]                 NAMES <- toupper(added)
[08:26:27.634]                 for (kk in seq_along(NAMES)) {
[08:26:27.634]                   name <- added[[kk]]
[08:26:27.634]                   NAME <- NAMES[[kk]]
[08:26:27.634]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:27.634]                     next
[08:26:27.634]                   args[[name]] <- ""
[08:26:27.634]                 }
[08:26:27.634]                 NAMES <- toupper(removed)
[08:26:27.634]                 for (kk in seq_along(NAMES)) {
[08:26:27.634]                   name <- removed[[kk]]
[08:26:27.634]                   NAME <- NAMES[[kk]]
[08:26:27.634]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:27.634]                     next
[08:26:27.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:27.634]                 }
[08:26:27.634]                 if (length(args) > 0) 
[08:26:27.634]                   base::do.call(base::Sys.setenv, args = args)
[08:26:27.634]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:27.634]             }
[08:26:27.634]             else {
[08:26:27.634]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:27.634]             }
[08:26:27.634]             {
[08:26:27.634]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:27.634]                   0L) {
[08:26:27.634]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:27.634]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:27.634]                   base::options(opts)
[08:26:27.634]                 }
[08:26:27.634]                 {
[08:26:27.634]                   {
[08:26:27.634]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:27.634]                     NULL
[08:26:27.634]                   }
[08:26:27.634]                   options(future.plan = NULL)
[08:26:27.634]                   if (is.na(NA_character_)) 
[08:26:27.634]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:27.634]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:27.634]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:27.634]                     .init = FALSE)
[08:26:27.634]                 }
[08:26:27.634]             }
[08:26:27.634]         }
[08:26:27.634]     })
[08:26:27.634]     if (TRUE) {
[08:26:27.634]         base::sink(type = "output", split = FALSE)
[08:26:27.634]         if (TRUE) {
[08:26:27.634]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:27.634]         }
[08:26:27.634]         else {
[08:26:27.634]             ...future.result["stdout"] <- base::list(NULL)
[08:26:27.634]         }
[08:26:27.634]         base::close(...future.stdout)
[08:26:27.634]         ...future.stdout <- NULL
[08:26:27.634]     }
[08:26:27.634]     ...future.result$conditions <- ...future.conditions
[08:26:27.634]     ...future.result$finished <- base::Sys.time()
[08:26:27.634]     ...future.result
[08:26:27.634] }
[08:26:27.637] Exporting 11 global objects (12.36 KiB) to cluster node #1 ...
[08:26:27.637] Exporting ‘...future.FUN’ (3.91 KiB) to cluster node #1 ...
[08:26:27.679] Exporting ‘...future.FUN’ (3.91 KiB) to cluster node #1 ... DONE
[08:26:27.679] Exporting ‘x_FUN’ (37 bytes) to cluster node #1 ...
[08:26:27.679] Exporting ‘x_FUN’ (37 bytes) to cluster node #1 ... DONE
[08:26:27.680] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[08:26:27.680] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[08:26:27.680] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[08:26:27.722] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[08:26:27.722] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[08:26:27.764] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[08:26:27.764] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[08:26:27.764] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[08:26:27.764] Exporting ‘valid_types’ (61 bytes) to cluster node #1 ...
[08:26:27.765] Exporting ‘valid_types’ (61 bytes) to cluster node #1 ... DONE
[08:26:27.765] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:26:27.765] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:26:27.765] Exporting ‘...future.elements_ii’ (89 bytes) to cluster node #1 ...
[08:26:27.766] Exporting ‘...future.elements_ii’ (89 bytes) to cluster node #1 ... DONE
[08:26:27.766] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:26:27.766] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:26:27.766] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:26:27.767] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:26:27.767] Exporting 11 global objects (12.36 KiB) to cluster node #1 ... DONE
[08:26:27.767] MultisessionFuture started
[08:26:27.768] - Launch lazy future ... done
[08:26:27.768] run() for ‘MultisessionFuture’ ... done
[08:26:27.768] Created future:
[08:26:27.768] MultisessionFuture:
[08:26:27.768] Label: ‘future_vapply-1’
[08:26:27.768] Expression:
[08:26:27.768] {
[08:26:27.768]     do.call(function(...) {
[08:26:27.768]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:27.768]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:27.768]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:27.768]             on.exit(options(oopts), add = TRUE)
[08:26:27.768]         }
[08:26:27.768]         {
[08:26:27.768]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:27.768]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:27.768]                 ...future.FUN(...future.X_jj, ...)
[08:26:27.768]             })
[08:26:27.768]         }
[08:26:27.768]     }, args = future.call.arguments)
[08:26:27.768] }
[08:26:27.768] Lazy evaluation: FALSE
[08:26:27.768] Asynchronous evaluation: TRUE
[08:26:27.768] Local evaluation: TRUE
[08:26:27.768] Environment: R_GlobalEnv
[08:26:27.768] Capture standard output: TRUE
[08:26:27.768] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:27.768] Globals: 11 objects totaling 12.15 KiB (function ‘...future.FUN’ of 3.91 KiB, function ‘x_FUN’ of 37 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:27.768] Packages: 1 packages (‘future.apply’)
[08:26:27.768] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:27.768] Resolved: FALSE
[08:26:27.768] Value: <not collected>
[08:26:27.768] Conditions captured: <none>
[08:26:27.768] Early signaling: FALSE
[08:26:27.768] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:27.768] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:27.780] Chunk #1 of 2 ... DONE
[08:26:27.780] Chunk #2 of 2 ...
[08:26:27.780]  - Finding globals in 'X' for chunk #2 ...
[08:26:27.780] getGlobalsAndPackages() ...
[08:26:27.780] Searching for globals...
[08:26:27.781] 
[08:26:27.781] Searching for globals ... DONE
[08:26:27.781] - globals: [0] <none>
[08:26:27.781] getGlobalsAndPackages() ... DONE
[08:26:27.781]    + additional globals found: [n=0] 
[08:26:27.781]    + additional namespaces needed: [n=0] 
[08:26:27.781]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:27.781]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:27.781]  - seeds: <none>
[08:26:27.781]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:27.782] getGlobalsAndPackages() ...
[08:26:27.782] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:27.782] Resolving globals: FALSE
[08:26:27.782] Tweak future expression to call with '...' arguments ...
[08:26:27.782] {
[08:26:27.782]     do.call(function(...) {
[08:26:27.782]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:27.782]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:27.782]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:27.782]             on.exit(options(oopts), add = TRUE)
[08:26:27.782]         }
[08:26:27.782]         {
[08:26:27.782]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:27.782]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:27.782]                 ...future.FUN(...future.X_jj, ...)
[08:26:27.782]             })
[08:26:27.782]         }
[08:26:27.782]     }, args = future.call.arguments)
[08:26:27.782] }
[08:26:27.782] Tweak future expression to call with '...' arguments ... DONE
[08:26:27.783] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:27.783] - packages: [1] ‘future.apply’
[08:26:27.783] getGlobalsAndPackages() ... DONE
[08:26:27.783] run() for ‘Future’ ...
[08:26:27.783] - state: ‘created’
[08:26:27.784] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:27.798] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:27.798] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:27.798]   - Field: ‘node’
[08:26:27.799]   - Field: ‘label’
[08:26:27.799]   - Field: ‘local’
[08:26:27.799]   - Field: ‘owner’
[08:26:27.799]   - Field: ‘envir’
[08:26:27.799]   - Field: ‘workers’
[08:26:27.799]   - Field: ‘packages’
[08:26:27.799]   - Field: ‘gc’
[08:26:27.799]   - Field: ‘conditions’
[08:26:27.799]   - Field: ‘persistent’
[08:26:27.799]   - Field: ‘expr’
[08:26:27.800]   - Field: ‘uuid’
[08:26:27.800]   - Field: ‘seed’
[08:26:27.800]   - Field: ‘version’
[08:26:27.800]   - Field: ‘result’
[08:26:27.800]   - Field: ‘asynchronous’
[08:26:27.800]   - Field: ‘calls’
[08:26:27.800]   - Field: ‘globals’
[08:26:27.800]   - Field: ‘stdout’
[08:26:27.800]   - Field: ‘earlySignal’
[08:26:27.800]   - Field: ‘lazy’
[08:26:27.800]   - Field: ‘state’
[08:26:27.800] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:27.801] - Launch lazy future ...
[08:26:27.801] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:27.801] Packages needed by future strategies (n = 0): <none>
[08:26:27.802] {
[08:26:27.802]     {
[08:26:27.802]         {
[08:26:27.802]             ...future.startTime <- base::Sys.time()
[08:26:27.802]             {
[08:26:27.802]                 {
[08:26:27.802]                   {
[08:26:27.802]                     {
[08:26:27.802]                       {
[08:26:27.802]                         base::local({
[08:26:27.802]                           has_future <- base::requireNamespace("future", 
[08:26:27.802]                             quietly = TRUE)
[08:26:27.802]                           if (has_future) {
[08:26:27.802]                             ns <- base::getNamespace("future")
[08:26:27.802]                             version <- ns[[".package"]][["version"]]
[08:26:27.802]                             if (is.null(version)) 
[08:26:27.802]                               version <- utils::packageVersion("future")
[08:26:27.802]                           }
[08:26:27.802]                           else {
[08:26:27.802]                             version <- NULL
[08:26:27.802]                           }
[08:26:27.802]                           if (!has_future || version < "1.8.0") {
[08:26:27.802]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:27.802]                               "", base::R.version$version.string), 
[08:26:27.802]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:27.802]                                 base::R.version$platform, 8 * 
[08:26:27.802]                                   base::.Machine$sizeof.pointer), 
[08:26:27.802]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:27.802]                                 "release", "version")], collapse = " "), 
[08:26:27.802]                               hostname = base::Sys.info()[["nodename"]])
[08:26:27.802]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:27.802]                               info)
[08:26:27.802]                             info <- base::paste(info, collapse = "; ")
[08:26:27.802]                             if (!has_future) {
[08:26:27.802]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:27.802]                                 info)
[08:26:27.802]                             }
[08:26:27.802]                             else {
[08:26:27.802]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:27.802]                                 info, version)
[08:26:27.802]                             }
[08:26:27.802]                             base::stop(msg)
[08:26:27.802]                           }
[08:26:27.802]                         })
[08:26:27.802]                       }
[08:26:27.802]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:27.802]                       base::options(mc.cores = 1L)
[08:26:27.802]                     }
[08:26:27.802]                     base::local({
[08:26:27.802]                       for (pkg in "future.apply") {
[08:26:27.802]                         base::loadNamespace(pkg)
[08:26:27.802]                         base::library(pkg, character.only = TRUE)
[08:26:27.802]                       }
[08:26:27.802]                     })
[08:26:27.802]                   }
[08:26:27.802]                   ...future.strategy.old <- future::plan("list")
[08:26:27.802]                   options(future.plan = NULL)
[08:26:27.802]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:27.802]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:27.802]                 }
[08:26:27.802]                 ...future.workdir <- getwd()
[08:26:27.802]             }
[08:26:27.802]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:27.802]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:27.802]         }
[08:26:27.802]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:27.802]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:27.802]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:27.802]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:27.802]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:27.802]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:27.802]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:27.802]             base::names(...future.oldOptions))
[08:26:27.802]     }
[08:26:27.802]     if (FALSE) {
[08:26:27.802]     }
[08:26:27.802]     else {
[08:26:27.802]         if (TRUE) {
[08:26:27.802]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:27.802]                 open = "w")
[08:26:27.802]         }
[08:26:27.802]         else {
[08:26:27.802]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:27.802]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:27.802]         }
[08:26:27.802]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:27.802]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:27.802]             base::sink(type = "output", split = FALSE)
[08:26:27.802]             base::close(...future.stdout)
[08:26:27.802]         }, add = TRUE)
[08:26:27.802]     }
[08:26:27.802]     ...future.frame <- base::sys.nframe()
[08:26:27.802]     ...future.conditions <- base::list()
[08:26:27.802]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:27.802]     if (FALSE) {
[08:26:27.802]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:27.802]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:27.802]     }
[08:26:27.802]     ...future.result <- base::tryCatch({
[08:26:27.802]         base::withCallingHandlers({
[08:26:27.802]             ...future.value <- base::withVisible(base::local({
[08:26:27.802]                 ...future.makeSendCondition <- base::local({
[08:26:27.802]                   sendCondition <- NULL
[08:26:27.802]                   function(frame = 1L) {
[08:26:27.802]                     if (is.function(sendCondition)) 
[08:26:27.802]                       return(sendCondition)
[08:26:27.802]                     ns <- getNamespace("parallel")
[08:26:27.802]                     if (exists("sendData", mode = "function", 
[08:26:27.802]                       envir = ns)) {
[08:26:27.802]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:27.802]                         envir = ns)
[08:26:27.802]                       envir <- sys.frame(frame)
[08:26:27.802]                       master <- NULL
[08:26:27.802]                       while (!identical(envir, .GlobalEnv) && 
[08:26:27.802]                         !identical(envir, emptyenv())) {
[08:26:27.802]                         if (exists("master", mode = "list", envir = envir, 
[08:26:27.802]                           inherits = FALSE)) {
[08:26:27.802]                           master <- get("master", mode = "list", 
[08:26:27.802]                             envir = envir, inherits = FALSE)
[08:26:27.802]                           if (inherits(master, c("SOCKnode", 
[08:26:27.802]                             "SOCK0node"))) {
[08:26:27.802]                             sendCondition <<- function(cond) {
[08:26:27.802]                               data <- list(type = "VALUE", value = cond, 
[08:26:27.802]                                 success = TRUE)
[08:26:27.802]                               parallel_sendData(master, data)
[08:26:27.802]                             }
[08:26:27.802]                             return(sendCondition)
[08:26:27.802]                           }
[08:26:27.802]                         }
[08:26:27.802]                         frame <- frame + 1L
[08:26:27.802]                         envir <- sys.frame(frame)
[08:26:27.802]                       }
[08:26:27.802]                     }
[08:26:27.802]                     sendCondition <<- function(cond) NULL
[08:26:27.802]                   }
[08:26:27.802]                 })
[08:26:27.802]                 withCallingHandlers({
[08:26:27.802]                   {
[08:26:27.802]                     do.call(function(...) {
[08:26:27.802]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:27.802]                       if (!identical(...future.globals.maxSize.org, 
[08:26:27.802]                         ...future.globals.maxSize)) {
[08:26:27.802]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:27.802]                         on.exit(options(oopts), add = TRUE)
[08:26:27.802]                       }
[08:26:27.802]                       {
[08:26:27.802]                         lapply(seq_along(...future.elements_ii), 
[08:26:27.802]                           FUN = function(jj) {
[08:26:27.802]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:27.802]                             ...future.FUN(...future.X_jj, ...)
[08:26:27.802]                           })
[08:26:27.802]                       }
[08:26:27.802]                     }, args = future.call.arguments)
[08:26:27.802]                   }
[08:26:27.802]                 }, immediateCondition = function(cond) {
[08:26:27.802]                   sendCondition <- ...future.makeSendCondition()
[08:26:27.802]                   sendCondition(cond)
[08:26:27.802]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:27.802]                   {
[08:26:27.802]                     inherits <- base::inherits
[08:26:27.802]                     invokeRestart <- base::invokeRestart
[08:26:27.802]                     is.null <- base::is.null
[08:26:27.802]                     muffled <- FALSE
[08:26:27.802]                     if (inherits(cond, "message")) {
[08:26:27.802]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:27.802]                       if (muffled) 
[08:26:27.802]                         invokeRestart("muffleMessage")
[08:26:27.802]                     }
[08:26:27.802]                     else if (inherits(cond, "warning")) {
[08:26:27.802]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:27.802]                       if (muffled) 
[08:26:27.802]                         invokeRestart("muffleWarning")
[08:26:27.802]                     }
[08:26:27.802]                     else if (inherits(cond, "condition")) {
[08:26:27.802]                       if (!is.null(pattern)) {
[08:26:27.802]                         computeRestarts <- base::computeRestarts
[08:26:27.802]                         grepl <- base::grepl
[08:26:27.802]                         restarts <- computeRestarts(cond)
[08:26:27.802]                         for (restart in restarts) {
[08:26:27.802]                           name <- restart$name
[08:26:27.802]                           if (is.null(name)) 
[08:26:27.802]                             next
[08:26:27.802]                           if (!grepl(pattern, name)) 
[08:26:27.802]                             next
[08:26:27.802]                           invokeRestart(restart)
[08:26:27.802]                           muffled <- TRUE
[08:26:27.802]                           break
[08:26:27.802]                         }
[08:26:27.802]                       }
[08:26:27.802]                     }
[08:26:27.802]                     invisible(muffled)
[08:26:27.802]                   }
[08:26:27.802]                   muffleCondition(cond)
[08:26:27.802]                 })
[08:26:27.802]             }))
[08:26:27.802]             future::FutureResult(value = ...future.value$value, 
[08:26:27.802]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:27.802]                   ...future.rng), globalenv = if (FALSE) 
[08:26:27.802]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:27.802]                     ...future.globalenv.names))
[08:26:27.802]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:27.802]         }, condition = base::local({
[08:26:27.802]             c <- base::c
[08:26:27.802]             inherits <- base::inherits
[08:26:27.802]             invokeRestart <- base::invokeRestart
[08:26:27.802]             length <- base::length
[08:26:27.802]             list <- base::list
[08:26:27.802]             seq.int <- base::seq.int
[08:26:27.802]             signalCondition <- base::signalCondition
[08:26:27.802]             sys.calls <- base::sys.calls
[08:26:27.802]             `[[` <- base::`[[`
[08:26:27.802]             `+` <- base::`+`
[08:26:27.802]             `<<-` <- base::`<<-`
[08:26:27.802]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:27.802]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:27.802]                   3L)]
[08:26:27.802]             }
[08:26:27.802]             function(cond) {
[08:26:27.802]                 is_error <- inherits(cond, "error")
[08:26:27.802]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:27.802]                   NULL)
[08:26:27.802]                 if (is_error) {
[08:26:27.802]                   sessionInformation <- function() {
[08:26:27.802]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:27.802]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:27.802]                       search = base::search(), system = base::Sys.info())
[08:26:27.802]                   }
[08:26:27.802]                   ...future.conditions[[length(...future.conditions) + 
[08:26:27.802]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:27.802]                     cond$call), session = sessionInformation(), 
[08:26:27.802]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:27.802]                   signalCondition(cond)
[08:26:27.802]                 }
[08:26:27.802]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:27.802]                 "immediateCondition"))) {
[08:26:27.802]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:27.802]                   ...future.conditions[[length(...future.conditions) + 
[08:26:27.802]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:27.802]                   if (TRUE && !signal) {
[08:26:27.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:27.802]                     {
[08:26:27.802]                       inherits <- base::inherits
[08:26:27.802]                       invokeRestart <- base::invokeRestart
[08:26:27.802]                       is.null <- base::is.null
[08:26:27.802]                       muffled <- FALSE
[08:26:27.802]                       if (inherits(cond, "message")) {
[08:26:27.802]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:27.802]                         if (muffled) 
[08:26:27.802]                           invokeRestart("muffleMessage")
[08:26:27.802]                       }
[08:26:27.802]                       else if (inherits(cond, "warning")) {
[08:26:27.802]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:27.802]                         if (muffled) 
[08:26:27.802]                           invokeRestart("muffleWarning")
[08:26:27.802]                       }
[08:26:27.802]                       else if (inherits(cond, "condition")) {
[08:26:27.802]                         if (!is.null(pattern)) {
[08:26:27.802]                           computeRestarts <- base::computeRestarts
[08:26:27.802]                           grepl <- base::grepl
[08:26:27.802]                           restarts <- computeRestarts(cond)
[08:26:27.802]                           for (restart in restarts) {
[08:26:27.802]                             name <- restart$name
[08:26:27.802]                             if (is.null(name)) 
[08:26:27.802]                               next
[08:26:27.802]                             if (!grepl(pattern, name)) 
[08:26:27.802]                               next
[08:26:27.802]                             invokeRestart(restart)
[08:26:27.802]                             muffled <- TRUE
[08:26:27.802]                             break
[08:26:27.802]                           }
[08:26:27.802]                         }
[08:26:27.802]                       }
[08:26:27.802]                       invisible(muffled)
[08:26:27.802]                     }
[08:26:27.802]                     muffleCondition(cond, pattern = "^muffle")
[08:26:27.802]                   }
[08:26:27.802]                 }
[08:26:27.802]                 else {
[08:26:27.802]                   if (TRUE) {
[08:26:27.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:27.802]                     {
[08:26:27.802]                       inherits <- base::inherits
[08:26:27.802]                       invokeRestart <- base::invokeRestart
[08:26:27.802]                       is.null <- base::is.null
[08:26:27.802]                       muffled <- FALSE
[08:26:27.802]                       if (inherits(cond, "message")) {
[08:26:27.802]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:27.802]                         if (muffled) 
[08:26:27.802]                           invokeRestart("muffleMessage")
[08:26:27.802]                       }
[08:26:27.802]                       else if (inherits(cond, "warning")) {
[08:26:27.802]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:27.802]                         if (muffled) 
[08:26:27.802]                           invokeRestart("muffleWarning")
[08:26:27.802]                       }
[08:26:27.802]                       else if (inherits(cond, "condition")) {
[08:26:27.802]                         if (!is.null(pattern)) {
[08:26:27.802]                           computeRestarts <- base::computeRestarts
[08:26:27.802]                           grepl <- base::grepl
[08:26:27.802]                           restarts <- computeRestarts(cond)
[08:26:27.802]                           for (restart in restarts) {
[08:26:27.802]                             name <- restart$name
[08:26:27.802]                             if (is.null(name)) 
[08:26:27.802]                               next
[08:26:27.802]                             if (!grepl(pattern, name)) 
[08:26:27.802]                               next
[08:26:27.802]                             invokeRestart(restart)
[08:26:27.802]                             muffled <- TRUE
[08:26:27.802]                             break
[08:26:27.802]                           }
[08:26:27.802]                         }
[08:26:27.802]                       }
[08:26:27.802]                       invisible(muffled)
[08:26:27.802]                     }
[08:26:27.802]                     muffleCondition(cond, pattern = "^muffle")
[08:26:27.802]                   }
[08:26:27.802]                 }
[08:26:27.802]             }
[08:26:27.802]         }))
[08:26:27.802]     }, error = function(ex) {
[08:26:27.802]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:27.802]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:27.802]                 ...future.rng), started = ...future.startTime, 
[08:26:27.802]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:27.802]             version = "1.8"), class = "FutureResult")
[08:26:27.802]     }, finally = {
[08:26:27.802]         if (!identical(...future.workdir, getwd())) 
[08:26:27.802]             setwd(...future.workdir)
[08:26:27.802]         {
[08:26:27.802]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:27.802]                 ...future.oldOptions$nwarnings <- NULL
[08:26:27.802]             }
[08:26:27.802]             base::options(...future.oldOptions)
[08:26:27.802]             if (.Platform$OS.type == "windows") {
[08:26:27.802]                 old_names <- names(...future.oldEnvVars)
[08:26:27.802]                 envs <- base::Sys.getenv()
[08:26:27.802]                 names <- names(envs)
[08:26:27.802]                 common <- intersect(names, old_names)
[08:26:27.802]                 added <- setdiff(names, old_names)
[08:26:27.802]                 removed <- setdiff(old_names, names)
[08:26:27.802]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:27.802]                   envs[common]]
[08:26:27.802]                 NAMES <- toupper(changed)
[08:26:27.802]                 args <- list()
[08:26:27.802]                 for (kk in seq_along(NAMES)) {
[08:26:27.802]                   name <- changed[[kk]]
[08:26:27.802]                   NAME <- NAMES[[kk]]
[08:26:27.802]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:27.802]                     next
[08:26:27.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:27.802]                 }
[08:26:27.802]                 NAMES <- toupper(added)
[08:26:27.802]                 for (kk in seq_along(NAMES)) {
[08:26:27.802]                   name <- added[[kk]]
[08:26:27.802]                   NAME <- NAMES[[kk]]
[08:26:27.802]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:27.802]                     next
[08:26:27.802]                   args[[name]] <- ""
[08:26:27.802]                 }
[08:26:27.802]                 NAMES <- toupper(removed)
[08:26:27.802]                 for (kk in seq_along(NAMES)) {
[08:26:27.802]                   name <- removed[[kk]]
[08:26:27.802]                   NAME <- NAMES[[kk]]
[08:26:27.802]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:27.802]                     next
[08:26:27.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:27.802]                 }
[08:26:27.802]                 if (length(args) > 0) 
[08:26:27.802]                   base::do.call(base::Sys.setenv, args = args)
[08:26:27.802]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:27.802]             }
[08:26:27.802]             else {
[08:26:27.802]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:27.802]             }
[08:26:27.802]             {
[08:26:27.802]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:27.802]                   0L) {
[08:26:27.802]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:27.802]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:27.802]                   base::options(opts)
[08:26:27.802]                 }
[08:26:27.802]                 {
[08:26:27.802]                   {
[08:26:27.802]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:27.802]                     NULL
[08:26:27.802]                   }
[08:26:27.802]                   options(future.plan = NULL)
[08:26:27.802]                   if (is.na(NA_character_)) 
[08:26:27.802]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:27.802]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:27.802]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:27.802]                     .init = FALSE)
[08:26:27.802]                 }
[08:26:27.802]             }
[08:26:27.802]         }
[08:26:27.802]     })
[08:26:27.802]     if (TRUE) {
[08:26:27.802]         base::sink(type = "output", split = FALSE)
[08:26:27.802]         if (TRUE) {
[08:26:27.802]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:27.802]         }
[08:26:27.802]         else {
[08:26:27.802]             ...future.result["stdout"] <- base::list(NULL)
[08:26:27.802]         }
[08:26:27.802]         base::close(...future.stdout)
[08:26:27.802]         ...future.stdout <- NULL
[08:26:27.802]     }
[08:26:27.802]     ...future.result$conditions <- ...future.conditions
[08:26:27.802]     ...future.result$finished <- base::Sys.time()
[08:26:27.802]     ...future.result
[08:26:27.802] }
[08:26:27.807] Exporting 11 global objects (12.39 KiB) to cluster node #2 ...
[08:26:27.807] Exporting ‘...future.FUN’ (3.91 KiB) to cluster node #2 ...
[08:26:27.848] Exporting ‘...future.FUN’ (3.91 KiB) to cluster node #2 ... DONE
[08:26:27.848] Exporting ‘x_FUN’ (37 bytes) to cluster node #2 ...
[08:26:27.848] Exporting ‘x_FUN’ (37 bytes) to cluster node #2 ... DONE
[08:26:27.848] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[08:26:27.849] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[08:26:27.849] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[08:26:27.891] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[08:26:27.891] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[08:26:27.932] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[08:26:27.932] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[08:26:27.932] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[08:26:27.932] Exporting ‘valid_types’ (61 bytes) to cluster node #2 ...
[08:26:27.933] Exporting ‘valid_types’ (61 bytes) to cluster node #2 ... DONE
[08:26:27.933] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:26:27.933] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:26:27.934] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #2 ...
[08:26:27.934] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #2 ... DONE
[08:26:27.934] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:26:27.934] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:26:27.935] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:26:27.935] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:26:27.935] Exporting 11 global objects (12.39 KiB) to cluster node #2 ... DONE
[08:26:27.936] MultisessionFuture started
[08:26:27.936] - Launch lazy future ... done
[08:26:27.936] run() for ‘MultisessionFuture’ ... done
[08:26:27.936] Created future:
[08:26:27.936] MultisessionFuture:
[08:26:27.936] Label: ‘future_vapply-2’
[08:26:27.936] Expression:
[08:26:27.936] {
[08:26:27.936]     do.call(function(...) {
[08:26:27.936]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:27.936]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:27.936]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:27.936]             on.exit(options(oopts), add = TRUE)
[08:26:27.936]         }
[08:26:27.936]         {
[08:26:27.936]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:27.936]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:27.936]                 ...future.FUN(...future.X_jj, ...)
[08:26:27.936]             })
[08:26:27.936]         }
[08:26:27.936]     }, args = future.call.arguments)
[08:26:27.936] }
[08:26:27.936] Lazy evaluation: FALSE
[08:26:27.936] Asynchronous evaluation: TRUE
[08:26:27.936] Local evaluation: TRUE
[08:26:27.936] Environment: R_GlobalEnv
[08:26:27.936] Capture standard output: TRUE
[08:26:27.936] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:27.936] Globals: 11 objects totaling 12.17 KiB (function ‘...future.FUN’ of 3.91 KiB, function ‘x_FUN’ of 37 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:27.936] Packages: 1 packages (‘future.apply’)
[08:26:27.936] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:27.936] Resolved: FALSE
[08:26:27.936] Value: <not collected>
[08:26:27.936] Conditions captured: <none>
[08:26:27.936] Early signaling: FALSE
[08:26:27.936] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:27.936] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:27.948] Chunk #2 of 2 ... DONE
[08:26:27.948] Launching 2 futures (chunks) ... DONE
[08:26:27.948] Resolving 2 futures (chunks) ...
[08:26:27.948] resolve() on list ...
[08:26:27.948]  recursive: 0
[08:26:27.948]  length: 2
[08:26:27.948] 
[08:26:27.949] receiveMessageFromWorker() for ClusterFuture ...
[08:26:27.949] - Validating connection of MultisessionFuture
[08:26:27.949] - received message: FutureResult
[08:26:27.949] - Received FutureResult
[08:26:27.949] - Erased future from FutureRegistry
[08:26:27.950] result() for ClusterFuture ...
[08:26:27.950] - result already collected: FutureResult
[08:26:27.950] result() for ClusterFuture ... done
[08:26:27.950] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:27.950] Future #1
[08:26:27.950] result() for ClusterFuture ...
[08:26:27.950] - result already collected: FutureResult
[08:26:27.950] result() for ClusterFuture ... done
[08:26:27.950] result() for ClusterFuture ...
[08:26:27.950] - result already collected: FutureResult
[08:26:27.950] result() for ClusterFuture ... done
[08:26:27.950] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:26:27.951] - nx: 2
[08:26:27.951] - relay: TRUE
[08:26:27.951] - stdout: TRUE
[08:26:27.951] - signal: TRUE
[08:26:27.951] - resignal: FALSE
[08:26:27.951] - force: TRUE
[08:26:27.951] - relayed: [n=2] FALSE, FALSE
[08:26:27.951] - queued futures: [n=2] FALSE, FALSE
[08:26:27.951]  - until=1
[08:26:27.951]  - relaying element #1
[08:26:27.951] result() for ClusterFuture ...
[08:26:27.951] - result already collected: FutureResult
[08:26:27.952] result() for ClusterFuture ... done
[08:26:27.952] result() for ClusterFuture ...
[08:26:27.952] - result already collected: FutureResult
[08:26:27.952] result() for ClusterFuture ... done
[08:26:27.952] result() for ClusterFuture ...
[08:26:27.952] - result already collected: FutureResult
[08:26:27.952] result() for ClusterFuture ... done
[08:26:27.952] result() for ClusterFuture ...
[08:26:27.952] - result already collected: FutureResult
[08:26:27.952] result() for ClusterFuture ... done
[08:26:27.952] - relayed: [n=2] TRUE, FALSE
[08:26:27.952] - queued futures: [n=2] TRUE, FALSE
[08:26:27.953] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:26:27.953]  length: 1 (resolved future 1)
[08:26:27.978] receiveMessageFromWorker() for ClusterFuture ...
[08:26:27.978] - Validating connection of MultisessionFuture
[08:26:27.979] - received message: FutureResult
[08:26:27.979] - Received FutureResult
[08:26:27.979] - Erased future from FutureRegistry
[08:26:27.979] result() for ClusterFuture ...
[08:26:27.979] - result already collected: FutureResult
[08:26:27.979] result() for ClusterFuture ... done
[08:26:27.979] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:27.979] Future #2
[08:26:27.979] result() for ClusterFuture ...
[08:26:27.980] - result already collected: FutureResult
[08:26:27.980] result() for ClusterFuture ... done
[08:26:27.980] result() for ClusterFuture ...
[08:26:27.980] - result already collected: FutureResult
[08:26:27.980] result() for ClusterFuture ... done
[08:26:27.980] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:26:27.980] - nx: 2
[08:26:27.980] - relay: TRUE
[08:26:27.980] - stdout: TRUE
[08:26:27.980] - signal: TRUE
[08:26:27.980] - resignal: FALSE
[08:26:27.980] - force: TRUE
[08:26:27.981] - relayed: [n=2] TRUE, FALSE
[08:26:27.981] - queued futures: [n=2] TRUE, FALSE
[08:26:27.981]  - until=2
[08:26:27.981]  - relaying element #2
[08:26:27.981] result() for ClusterFuture ...
[08:26:27.981] - result already collected: FutureResult
[08:26:27.981] result() for ClusterFuture ... done
[08:26:27.981] result() for ClusterFuture ...
[08:26:27.981] - result already collected: FutureResult
[08:26:27.981] result() for ClusterFuture ... done
[08:26:27.981] result() for ClusterFuture ...
[08:26:27.982] - result already collected: FutureResult
[08:26:27.982] result() for ClusterFuture ... done
[08:26:27.982] result() for ClusterFuture ...
[08:26:27.982] - result already collected: FutureResult
[08:26:27.982] result() for ClusterFuture ... done
[08:26:27.982] - relayed: [n=2] TRUE, TRUE
[08:26:27.982] - queued futures: [n=2] TRUE, TRUE
[08:26:27.982] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:26:27.982]  length: 0 (resolved future 2)
[08:26:27.982] Relaying remaining futures
[08:26:27.982] signalConditionsASAP(NULL, pos=0) ...
[08:26:27.982] - nx: 2
[08:26:27.983] - relay: TRUE
[08:26:27.983] - stdout: TRUE
[08:26:27.983] - signal: TRUE
[08:26:27.983] - resignal: FALSE
[08:26:27.983] - force: TRUE
[08:26:27.983] - relayed: [n=2] TRUE, TRUE
[08:26:27.983] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:27.983] - relayed: [n=2] TRUE, TRUE
[08:26:27.983] - queued futures: [n=2] TRUE, TRUE
[08:26:27.983] signalConditionsASAP(NULL, pos=0) ... done
[08:26:27.983] resolve() on list ... DONE
[08:26:27.983] result() for ClusterFuture ...
[08:26:27.984] - result already collected: FutureResult
[08:26:27.984] result() for ClusterFuture ... done
[08:26:27.984] result() for ClusterFuture ...
[08:26:27.984] - result already collected: FutureResult
[08:26:27.984] result() for ClusterFuture ... done
[08:26:27.984] result() for ClusterFuture ...
[08:26:27.984] - result already collected: FutureResult
[08:26:27.984] result() for ClusterFuture ... done
[08:26:27.984] result() for ClusterFuture ...
[08:26:27.984] - result already collected: FutureResult
[08:26:27.984] result() for ClusterFuture ... done
[08:26:27.984]  - Number of value chunks collected: 2
[08:26:27.985] Resolving 2 futures (chunks) ... DONE
[08:26:27.985] Reducing values from 2 chunks ...
[08:26:27.985]  - Number of values collected after concatenation: 3
[08:26:27.985]  - Number of values expected: 3
[08:26:27.985] Reducing values from 2 chunks ... DONE
[08:26:27.985] future_lapply() ... DONE
- exceptions ...
[08:26:27.985] future_lapply() ...
[08:26:27.989] Number of chunks: 2
[08:26:27.989] getGlobalsAndPackagesXApply() ...
[08:26:27.989]  - future.globals: TRUE
[08:26:27.989] getGlobalsAndPackages() ...
[08:26:27.989] Searching for globals...
[08:26:27.992] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[08:26:27.992] Searching for globals ... DONE
[08:26:27.993] Resolving globals: FALSE
[08:26:27.993] The total size of the 7 globals is 12.81 KiB (13119 bytes)
[08:26:27.994] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.65 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[08:26:27.994] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:27.994] - packages: [1] ‘future.apply’
[08:26:27.994] getGlobalsAndPackages() ... DONE
[08:26:27.994]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[08:26:27.994]  - needed namespaces: [n=1] ‘future.apply’
[08:26:27.994] Finding globals ... DONE
[08:26:27.995]  - use_args: TRUE
[08:26:27.995]  - Getting '...' globals ...
[08:26:27.995] resolve() on list ...
[08:26:27.995]  recursive: 0
[08:26:27.995]  length: 1
[08:26:27.995]  elements: ‘...’
[08:26:27.995]  length: 0 (resolved future 1)
[08:26:27.995] resolve() on list ... DONE
[08:26:27.996]    - '...' content: [n=0] 
[08:26:27.996] List of 1
[08:26:27.996]  $ ...: list()
[08:26:27.996]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:27.996]  - attr(*, "where")=List of 1
[08:26:27.996]   ..$ ...:<environment: 0x562ca94ce020> 
[08:26:27.996]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:27.996]  - attr(*, "resolved")= logi TRUE
[08:26:27.996]  - attr(*, "total_size")= num NA
[08:26:27.998]  - Getting '...' globals ... DONE
[08:26:27.998] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[08:26:27.998] List of 8
[08:26:27.998]  $ ...future.FUN:function (x, ...)  
[08:26:27.998]  $ x_FUN        :function (x)  
[08:26:27.998]  $ times        : int 2
[08:26:27.998]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[08:26:27.998]  $ stop_if_not  :function (...)  
[08:26:27.998]  $ dim          : NULL
[08:26:27.998]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[08:26:27.998]  $ ...          : list()
[08:26:27.998]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:27.998]  - attr(*, "where")=List of 8
[08:26:27.998]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:27.998]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[08:26:27.998]   ..$ times        :<environment: R_EmptyEnv> 
[08:26:27.998]   ..$ stopf        :<environment: R_EmptyEnv> 
[08:26:27.998]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[08:26:27.998]   ..$ dim          :<environment: R_EmptyEnv> 
[08:26:27.998]   ..$ valid_types  :<environment: R_EmptyEnv> 
[08:26:27.998]   ..$ ...          :<environment: 0x562ca94ce020> 
[08:26:27.998]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:27.998]  - attr(*, "resolved")= logi FALSE
[08:26:27.998]  - attr(*, "total_size")= num 23676
[08:26:28.003] Packages to be attached in all futures: [n=1] ‘future.apply’
[08:26:28.004] getGlobalsAndPackagesXApply() ... DONE
[08:26:28.004] Number of futures (= number of chunks): 2
[08:26:28.004] Launching 2 futures (chunks) ...
[08:26:28.004] Chunk #1 of 2 ...
[08:26:28.004]  - Finding globals in 'X' for chunk #1 ...
[08:26:28.004] getGlobalsAndPackages() ...
[08:26:28.004] Searching for globals...
[08:26:28.005] 
[08:26:28.005] Searching for globals ... DONE
[08:26:28.005] - globals: [0] <none>
[08:26:28.005] getGlobalsAndPackages() ... DONE
[08:26:28.005]    + additional globals found: [n=0] 
[08:26:28.005]    + additional namespaces needed: [n=0] 
[08:26:28.005]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:28.005]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:28.005]  - seeds: <none>
[08:26:28.005]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:28.005] getGlobalsAndPackages() ...
[08:26:28.005] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:28.006] Resolving globals: FALSE
[08:26:28.006] Tweak future expression to call with '...' arguments ...
[08:26:28.006] {
[08:26:28.006]     do.call(function(...) {
[08:26:28.006]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:28.006]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:28.006]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:28.006]             on.exit(options(oopts), add = TRUE)
[08:26:28.006]         }
[08:26:28.006]         {
[08:26:28.006]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:28.006]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:28.006]                 ...future.FUN(...future.X_jj, ...)
[08:26:28.006]             })
[08:26:28.006]         }
[08:26:28.006]     }, args = future.call.arguments)
[08:26:28.006] }
[08:26:28.006] Tweak future expression to call with '...' arguments ... DONE
[08:26:28.007] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:28.007] - packages: [1] ‘future.apply’
[08:26:28.007] getGlobalsAndPackages() ... DONE
[08:26:28.007] run() for ‘Future’ ...
[08:26:28.007] - state: ‘created’
[08:26:28.007] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:28.022] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:28.022] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:28.022]   - Field: ‘node’
[08:26:28.022]   - Field: ‘label’
[08:26:28.022]   - Field: ‘local’
[08:26:28.022]   - Field: ‘owner’
[08:26:28.022]   - Field: ‘envir’
[08:26:28.022]   - Field: ‘workers’
[08:26:28.022]   - Field: ‘packages’
[08:26:28.022]   - Field: ‘gc’
[08:26:28.023]   - Field: ‘conditions’
[08:26:28.023]   - Field: ‘persistent’
[08:26:28.023]   - Field: ‘expr’
[08:26:28.023]   - Field: ‘uuid’
[08:26:28.023]   - Field: ‘seed’
[08:26:28.023]   - Field: ‘version’
[08:26:28.023]   - Field: ‘result’
[08:26:28.023]   - Field: ‘asynchronous’
[08:26:28.023]   - Field: ‘calls’
[08:26:28.023]   - Field: ‘globals’
[08:26:28.023]   - Field: ‘stdout’
[08:26:28.024]   - Field: ‘earlySignal’
[08:26:28.024]   - Field: ‘lazy’
[08:26:28.024]   - Field: ‘state’
[08:26:28.024] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:28.024] - Launch lazy future ...
[08:26:28.024] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:28.024] Packages needed by future strategies (n = 0): <none>
[08:26:28.025] {
[08:26:28.025]     {
[08:26:28.025]         {
[08:26:28.025]             ...future.startTime <- base::Sys.time()
[08:26:28.025]             {
[08:26:28.025]                 {
[08:26:28.025]                   {
[08:26:28.025]                     {
[08:26:28.025]                       {
[08:26:28.025]                         base::local({
[08:26:28.025]                           has_future <- base::requireNamespace("future", 
[08:26:28.025]                             quietly = TRUE)
[08:26:28.025]                           if (has_future) {
[08:26:28.025]                             ns <- base::getNamespace("future")
[08:26:28.025]                             version <- ns[[".package"]][["version"]]
[08:26:28.025]                             if (is.null(version)) 
[08:26:28.025]                               version <- utils::packageVersion("future")
[08:26:28.025]                           }
[08:26:28.025]                           else {
[08:26:28.025]                             version <- NULL
[08:26:28.025]                           }
[08:26:28.025]                           if (!has_future || version < "1.8.0") {
[08:26:28.025]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:28.025]                               "", base::R.version$version.string), 
[08:26:28.025]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:28.025]                                 base::R.version$platform, 8 * 
[08:26:28.025]                                   base::.Machine$sizeof.pointer), 
[08:26:28.025]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:28.025]                                 "release", "version")], collapse = " "), 
[08:26:28.025]                               hostname = base::Sys.info()[["nodename"]])
[08:26:28.025]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:28.025]                               info)
[08:26:28.025]                             info <- base::paste(info, collapse = "; ")
[08:26:28.025]                             if (!has_future) {
[08:26:28.025]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:28.025]                                 info)
[08:26:28.025]                             }
[08:26:28.025]                             else {
[08:26:28.025]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:28.025]                                 info, version)
[08:26:28.025]                             }
[08:26:28.025]                             base::stop(msg)
[08:26:28.025]                           }
[08:26:28.025]                         })
[08:26:28.025]                       }
[08:26:28.025]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:28.025]                       base::options(mc.cores = 1L)
[08:26:28.025]                     }
[08:26:28.025]                     base::local({
[08:26:28.025]                       for (pkg in "future.apply") {
[08:26:28.025]                         base::loadNamespace(pkg)
[08:26:28.025]                         base::library(pkg, character.only = TRUE)
[08:26:28.025]                       }
[08:26:28.025]                     })
[08:26:28.025]                   }
[08:26:28.025]                   ...future.strategy.old <- future::plan("list")
[08:26:28.025]                   options(future.plan = NULL)
[08:26:28.025]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:28.025]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:28.025]                 }
[08:26:28.025]                 ...future.workdir <- getwd()
[08:26:28.025]             }
[08:26:28.025]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:28.025]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:28.025]         }
[08:26:28.025]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:28.025]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:28.025]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:28.025]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:28.025]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:28.025]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:28.025]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:28.025]             base::names(...future.oldOptions))
[08:26:28.025]     }
[08:26:28.025]     if (FALSE) {
[08:26:28.025]     }
[08:26:28.025]     else {
[08:26:28.025]         if (TRUE) {
[08:26:28.025]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:28.025]                 open = "w")
[08:26:28.025]         }
[08:26:28.025]         else {
[08:26:28.025]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:28.025]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:28.025]         }
[08:26:28.025]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:28.025]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:28.025]             base::sink(type = "output", split = FALSE)
[08:26:28.025]             base::close(...future.stdout)
[08:26:28.025]         }, add = TRUE)
[08:26:28.025]     }
[08:26:28.025]     ...future.frame <- base::sys.nframe()
[08:26:28.025]     ...future.conditions <- base::list()
[08:26:28.025]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:28.025]     if (FALSE) {
[08:26:28.025]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:28.025]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:28.025]     }
[08:26:28.025]     ...future.result <- base::tryCatch({
[08:26:28.025]         base::withCallingHandlers({
[08:26:28.025]             ...future.value <- base::withVisible(base::local({
[08:26:28.025]                 ...future.makeSendCondition <- base::local({
[08:26:28.025]                   sendCondition <- NULL
[08:26:28.025]                   function(frame = 1L) {
[08:26:28.025]                     if (is.function(sendCondition)) 
[08:26:28.025]                       return(sendCondition)
[08:26:28.025]                     ns <- getNamespace("parallel")
[08:26:28.025]                     if (exists("sendData", mode = "function", 
[08:26:28.025]                       envir = ns)) {
[08:26:28.025]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:28.025]                         envir = ns)
[08:26:28.025]                       envir <- sys.frame(frame)
[08:26:28.025]                       master <- NULL
[08:26:28.025]                       while (!identical(envir, .GlobalEnv) && 
[08:26:28.025]                         !identical(envir, emptyenv())) {
[08:26:28.025]                         if (exists("master", mode = "list", envir = envir, 
[08:26:28.025]                           inherits = FALSE)) {
[08:26:28.025]                           master <- get("master", mode = "list", 
[08:26:28.025]                             envir = envir, inherits = FALSE)
[08:26:28.025]                           if (inherits(master, c("SOCKnode", 
[08:26:28.025]                             "SOCK0node"))) {
[08:26:28.025]                             sendCondition <<- function(cond) {
[08:26:28.025]                               data <- list(type = "VALUE", value = cond, 
[08:26:28.025]                                 success = TRUE)
[08:26:28.025]                               parallel_sendData(master, data)
[08:26:28.025]                             }
[08:26:28.025]                             return(sendCondition)
[08:26:28.025]                           }
[08:26:28.025]                         }
[08:26:28.025]                         frame <- frame + 1L
[08:26:28.025]                         envir <- sys.frame(frame)
[08:26:28.025]                       }
[08:26:28.025]                     }
[08:26:28.025]                     sendCondition <<- function(cond) NULL
[08:26:28.025]                   }
[08:26:28.025]                 })
[08:26:28.025]                 withCallingHandlers({
[08:26:28.025]                   {
[08:26:28.025]                     do.call(function(...) {
[08:26:28.025]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:28.025]                       if (!identical(...future.globals.maxSize.org, 
[08:26:28.025]                         ...future.globals.maxSize)) {
[08:26:28.025]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:28.025]                         on.exit(options(oopts), add = TRUE)
[08:26:28.025]                       }
[08:26:28.025]                       {
[08:26:28.025]                         lapply(seq_along(...future.elements_ii), 
[08:26:28.025]                           FUN = function(jj) {
[08:26:28.025]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:28.025]                             ...future.FUN(...future.X_jj, ...)
[08:26:28.025]                           })
[08:26:28.025]                       }
[08:26:28.025]                     }, args = future.call.arguments)
[08:26:28.025]                   }
[08:26:28.025]                 }, immediateCondition = function(cond) {
[08:26:28.025]                   sendCondition <- ...future.makeSendCondition()
[08:26:28.025]                   sendCondition(cond)
[08:26:28.025]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:28.025]                   {
[08:26:28.025]                     inherits <- base::inherits
[08:26:28.025]                     invokeRestart <- base::invokeRestart
[08:26:28.025]                     is.null <- base::is.null
[08:26:28.025]                     muffled <- FALSE
[08:26:28.025]                     if (inherits(cond, "message")) {
[08:26:28.025]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:28.025]                       if (muffled) 
[08:26:28.025]                         invokeRestart("muffleMessage")
[08:26:28.025]                     }
[08:26:28.025]                     else if (inherits(cond, "warning")) {
[08:26:28.025]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:28.025]                       if (muffled) 
[08:26:28.025]                         invokeRestart("muffleWarning")
[08:26:28.025]                     }
[08:26:28.025]                     else if (inherits(cond, "condition")) {
[08:26:28.025]                       if (!is.null(pattern)) {
[08:26:28.025]                         computeRestarts <- base::computeRestarts
[08:26:28.025]                         grepl <- base::grepl
[08:26:28.025]                         restarts <- computeRestarts(cond)
[08:26:28.025]                         for (restart in restarts) {
[08:26:28.025]                           name <- restart$name
[08:26:28.025]                           if (is.null(name)) 
[08:26:28.025]                             next
[08:26:28.025]                           if (!grepl(pattern, name)) 
[08:26:28.025]                             next
[08:26:28.025]                           invokeRestart(restart)
[08:26:28.025]                           muffled <- TRUE
[08:26:28.025]                           break
[08:26:28.025]                         }
[08:26:28.025]                       }
[08:26:28.025]                     }
[08:26:28.025]                     invisible(muffled)
[08:26:28.025]                   }
[08:26:28.025]                   muffleCondition(cond)
[08:26:28.025]                 })
[08:26:28.025]             }))
[08:26:28.025]             future::FutureResult(value = ...future.value$value, 
[08:26:28.025]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:28.025]                   ...future.rng), globalenv = if (FALSE) 
[08:26:28.025]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:28.025]                     ...future.globalenv.names))
[08:26:28.025]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:28.025]         }, condition = base::local({
[08:26:28.025]             c <- base::c
[08:26:28.025]             inherits <- base::inherits
[08:26:28.025]             invokeRestart <- base::invokeRestart
[08:26:28.025]             length <- base::length
[08:26:28.025]             list <- base::list
[08:26:28.025]             seq.int <- base::seq.int
[08:26:28.025]             signalCondition <- base::signalCondition
[08:26:28.025]             sys.calls <- base::sys.calls
[08:26:28.025]             `[[` <- base::`[[`
[08:26:28.025]             `+` <- base::`+`
[08:26:28.025]             `<<-` <- base::`<<-`
[08:26:28.025]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:28.025]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:28.025]                   3L)]
[08:26:28.025]             }
[08:26:28.025]             function(cond) {
[08:26:28.025]                 is_error <- inherits(cond, "error")
[08:26:28.025]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:28.025]                   NULL)
[08:26:28.025]                 if (is_error) {
[08:26:28.025]                   sessionInformation <- function() {
[08:26:28.025]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:28.025]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:28.025]                       search = base::search(), system = base::Sys.info())
[08:26:28.025]                   }
[08:26:28.025]                   ...future.conditions[[length(...future.conditions) + 
[08:26:28.025]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:28.025]                     cond$call), session = sessionInformation(), 
[08:26:28.025]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:28.025]                   signalCondition(cond)
[08:26:28.025]                 }
[08:26:28.025]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:28.025]                 "immediateCondition"))) {
[08:26:28.025]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:28.025]                   ...future.conditions[[length(...future.conditions) + 
[08:26:28.025]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:28.025]                   if (TRUE && !signal) {
[08:26:28.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:28.025]                     {
[08:26:28.025]                       inherits <- base::inherits
[08:26:28.025]                       invokeRestart <- base::invokeRestart
[08:26:28.025]                       is.null <- base::is.null
[08:26:28.025]                       muffled <- FALSE
[08:26:28.025]                       if (inherits(cond, "message")) {
[08:26:28.025]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:28.025]                         if (muffled) 
[08:26:28.025]                           invokeRestart("muffleMessage")
[08:26:28.025]                       }
[08:26:28.025]                       else if (inherits(cond, "warning")) {
[08:26:28.025]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:28.025]                         if (muffled) 
[08:26:28.025]                           invokeRestart("muffleWarning")
[08:26:28.025]                       }
[08:26:28.025]                       else if (inherits(cond, "condition")) {
[08:26:28.025]                         if (!is.null(pattern)) {
[08:26:28.025]                           computeRestarts <- base::computeRestarts
[08:26:28.025]                           grepl <- base::grepl
[08:26:28.025]                           restarts <- computeRestarts(cond)
[08:26:28.025]                           for (restart in restarts) {
[08:26:28.025]                             name <- restart$name
[08:26:28.025]                             if (is.null(name)) 
[08:26:28.025]                               next
[08:26:28.025]                             if (!grepl(pattern, name)) 
[08:26:28.025]                               next
[08:26:28.025]                             invokeRestart(restart)
[08:26:28.025]                             muffled <- TRUE
[08:26:28.025]                             break
[08:26:28.025]                           }
[08:26:28.025]                         }
[08:26:28.025]                       }
[08:26:28.025]                       invisible(muffled)
[08:26:28.025]                     }
[08:26:28.025]                     muffleCondition(cond, pattern = "^muffle")
[08:26:28.025]                   }
[08:26:28.025]                 }
[08:26:28.025]                 else {
[08:26:28.025]                   if (TRUE) {
[08:26:28.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:28.025]                     {
[08:26:28.025]                       inherits <- base::inherits
[08:26:28.025]                       invokeRestart <- base::invokeRestart
[08:26:28.025]                       is.null <- base::is.null
[08:26:28.025]                       muffled <- FALSE
[08:26:28.025]                       if (inherits(cond, "message")) {
[08:26:28.025]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:28.025]                         if (muffled) 
[08:26:28.025]                           invokeRestart("muffleMessage")
[08:26:28.025]                       }
[08:26:28.025]                       else if (inherits(cond, "warning")) {
[08:26:28.025]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:28.025]                         if (muffled) 
[08:26:28.025]                           invokeRestart("muffleWarning")
[08:26:28.025]                       }
[08:26:28.025]                       else if (inherits(cond, "condition")) {
[08:26:28.025]                         if (!is.null(pattern)) {
[08:26:28.025]                           computeRestarts <- base::computeRestarts
[08:26:28.025]                           grepl <- base::grepl
[08:26:28.025]                           restarts <- computeRestarts(cond)
[08:26:28.025]                           for (restart in restarts) {
[08:26:28.025]                             name <- restart$name
[08:26:28.025]                             if (is.null(name)) 
[08:26:28.025]                               next
[08:26:28.025]                             if (!grepl(pattern, name)) 
[08:26:28.025]                               next
[08:26:28.025]                             invokeRestart(restart)
[08:26:28.025]                             muffled <- TRUE
[08:26:28.025]                             break
[08:26:28.025]                           }
[08:26:28.025]                         }
[08:26:28.025]                       }
[08:26:28.025]                       invisible(muffled)
[08:26:28.025]                     }
[08:26:28.025]                     muffleCondition(cond, pattern = "^muffle")
[08:26:28.025]                   }
[08:26:28.025]                 }
[08:26:28.025]             }
[08:26:28.025]         }))
[08:26:28.025]     }, error = function(ex) {
[08:26:28.025]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:28.025]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:28.025]                 ...future.rng), started = ...future.startTime, 
[08:26:28.025]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:28.025]             version = "1.8"), class = "FutureResult")
[08:26:28.025]     }, finally = {
[08:26:28.025]         if (!identical(...future.workdir, getwd())) 
[08:26:28.025]             setwd(...future.workdir)
[08:26:28.025]         {
[08:26:28.025]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:28.025]                 ...future.oldOptions$nwarnings <- NULL
[08:26:28.025]             }
[08:26:28.025]             base::options(...future.oldOptions)
[08:26:28.025]             if (.Platform$OS.type == "windows") {
[08:26:28.025]                 old_names <- names(...future.oldEnvVars)
[08:26:28.025]                 envs <- base::Sys.getenv()
[08:26:28.025]                 names <- names(envs)
[08:26:28.025]                 common <- intersect(names, old_names)
[08:26:28.025]                 added <- setdiff(names, old_names)
[08:26:28.025]                 removed <- setdiff(old_names, names)
[08:26:28.025]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:28.025]                   envs[common]]
[08:26:28.025]                 NAMES <- toupper(changed)
[08:26:28.025]                 args <- list()
[08:26:28.025]                 for (kk in seq_along(NAMES)) {
[08:26:28.025]                   name <- changed[[kk]]
[08:26:28.025]                   NAME <- NAMES[[kk]]
[08:26:28.025]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:28.025]                     next
[08:26:28.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:28.025]                 }
[08:26:28.025]                 NAMES <- toupper(added)
[08:26:28.025]                 for (kk in seq_along(NAMES)) {
[08:26:28.025]                   name <- added[[kk]]
[08:26:28.025]                   NAME <- NAMES[[kk]]
[08:26:28.025]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:28.025]                     next
[08:26:28.025]                   args[[name]] <- ""
[08:26:28.025]                 }
[08:26:28.025]                 NAMES <- toupper(removed)
[08:26:28.025]                 for (kk in seq_along(NAMES)) {
[08:26:28.025]                   name <- removed[[kk]]
[08:26:28.025]                   NAME <- NAMES[[kk]]
[08:26:28.025]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:28.025]                     next
[08:26:28.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:28.025]                 }
[08:26:28.025]                 if (length(args) > 0) 
[08:26:28.025]                   base::do.call(base::Sys.setenv, args = args)
[08:26:28.025]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:28.025]             }
[08:26:28.025]             else {
[08:26:28.025]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:28.025]             }
[08:26:28.025]             {
[08:26:28.025]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:28.025]                   0L) {
[08:26:28.025]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:28.025]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:28.025]                   base::options(opts)
[08:26:28.025]                 }
[08:26:28.025]                 {
[08:26:28.025]                   {
[08:26:28.025]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:28.025]                     NULL
[08:26:28.025]                   }
[08:26:28.025]                   options(future.plan = NULL)
[08:26:28.025]                   if (is.na(NA_character_)) 
[08:26:28.025]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:28.025]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:28.025]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:28.025]                     .init = FALSE)
[08:26:28.025]                 }
[08:26:28.025]             }
[08:26:28.025]         }
[08:26:28.025]     })
[08:26:28.025]     if (TRUE) {
[08:26:28.025]         base::sink(type = "output", split = FALSE)
[08:26:28.025]         if (TRUE) {
[08:26:28.025]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:28.025]         }
[08:26:28.025]         else {
[08:26:28.025]             ...future.result["stdout"] <- base::list(NULL)
[08:26:28.025]         }
[08:26:28.025]         base::close(...future.stdout)
[08:26:28.025]         ...future.stdout <- NULL
[08:26:28.025]     }
[08:26:28.025]     ...future.result$conditions <- ...future.conditions
[08:26:28.025]     ...future.result$finished <- base::Sys.time()
[08:26:28.025]     ...future.result
[08:26:28.025] }
[08:26:28.028] Exporting 11 global objects (13.22 KiB) to cluster node #1 ...
[08:26:28.028] Exporting ‘...future.FUN’ (4.65 KiB) to cluster node #1 ...
[08:26:28.070] Exporting ‘...future.FUN’ (4.65 KiB) to cluster node #1 ... DONE
[08:26:28.070] Exporting ‘x_FUN’ (185 bytes) to cluster node #1 ...
[08:26:28.070] Exporting ‘x_FUN’ (185 bytes) to cluster node #1 ... DONE
[08:26:28.070] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[08:26:28.071] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[08:26:28.071] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[08:26:28.112] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[08:26:28.112] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[08:26:28.153] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[08:26:28.153] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[08:26:28.153] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[08:26:28.153] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[08:26:28.154] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[08:26:28.154] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:26:28.154] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:26:28.154] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ...
[08:26:28.155] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ... DONE
[08:26:28.155] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:26:28.155] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:26:28.155] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:26:28.156] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:26:28.156] Exporting 11 global objects (13.22 KiB) to cluster node #1 ... DONE
[08:26:28.156] MultisessionFuture started
[08:26:28.156] - Launch lazy future ... done
[08:26:28.156] run() for ‘MultisessionFuture’ ... done
[08:26:28.157] Created future:
[08:26:28.157] MultisessionFuture:
[08:26:28.157] Label: ‘future_vapply-1’
[08:26:28.157] Expression:
[08:26:28.157] {
[08:26:28.157]     do.call(function(...) {
[08:26:28.157]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:28.157]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:28.157]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:28.157]             on.exit(options(oopts), add = TRUE)
[08:26:28.157]         }
[08:26:28.157]         {
[08:26:28.157]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:28.157]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:28.157]                 ...future.FUN(...future.X_jj, ...)
[08:26:28.157]             })
[08:26:28.157]         }
[08:26:28.157]     }, args = future.call.arguments)
[08:26:28.157] }
[08:26:28.157] Lazy evaluation: FALSE
[08:26:28.157] Asynchronous evaluation: TRUE
[08:26:28.157] Local evaluation: TRUE
[08:26:28.157] Environment: R_GlobalEnv
[08:26:28.157] Capture standard output: TRUE
[08:26:28.157] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:28.157] Globals: 11 objects totaling 13.00 KiB (function ‘...future.FUN’ of 4.65 KiB, function ‘x_FUN’ of 185 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:28.157] Packages: 1 packages (‘future.apply’)
[08:26:28.157] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:28.157] Resolved: FALSE
[08:26:28.157] Value: <not collected>
[08:26:28.157] Conditions captured: <none>
[08:26:28.157] Early signaling: FALSE
[08:26:28.157] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:28.157] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:28.168] Chunk #1 of 2 ... DONE
[08:26:28.169] Chunk #2 of 2 ...
[08:26:28.169]  - Finding globals in 'X' for chunk #2 ...
[08:26:28.169] getGlobalsAndPackages() ...
[08:26:28.169] Searching for globals...
[08:26:28.169] 
[08:26:28.169] Searching for globals ... DONE
[08:26:28.169] - globals: [0] <none>
[08:26:28.169] getGlobalsAndPackages() ... DONE
[08:26:28.170]    + additional globals found: [n=0] 
[08:26:28.170]    + additional namespaces needed: [n=0] 
[08:26:28.170]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:28.170]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:28.170]  - seeds: <none>
[08:26:28.170]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:28.170] getGlobalsAndPackages() ...
[08:26:28.170] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:28.170] Resolving globals: FALSE
[08:26:28.170] Tweak future expression to call with '...' arguments ...
[08:26:28.171] {
[08:26:28.171]     do.call(function(...) {
[08:26:28.171]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:28.171]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:28.171]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:28.171]             on.exit(options(oopts), add = TRUE)
[08:26:28.171]         }
[08:26:28.171]         {
[08:26:28.171]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:28.171]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:28.171]                 ...future.FUN(...future.X_jj, ...)
[08:26:28.171]             })
[08:26:28.171]         }
[08:26:28.171]     }, args = future.call.arguments)
[08:26:28.171] }
[08:26:28.171] Tweak future expression to call with '...' arguments ... DONE
[08:26:28.171] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:28.171] - packages: [1] ‘future.apply’
[08:26:28.172] getGlobalsAndPackages() ... DONE
[08:26:28.172] run() for ‘Future’ ...
[08:26:28.172] - state: ‘created’
[08:26:28.172] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:28.187] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:28.187] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:28.187]   - Field: ‘node’
[08:26:28.187]   - Field: ‘label’
[08:26:28.187]   - Field: ‘local’
[08:26:28.187]   - Field: ‘owner’
[08:26:28.187]   - Field: ‘envir’
[08:26:28.187]   - Field: ‘workers’
[08:26:28.187]   - Field: ‘packages’
[08:26:28.188]   - Field: ‘gc’
[08:26:28.188]   - Field: ‘conditions’
[08:26:28.188]   - Field: ‘persistent’
[08:26:28.188]   - Field: ‘expr’
[08:26:28.188]   - Field: ‘uuid’
[08:26:28.188]   - Field: ‘seed’
[08:26:28.188]   - Field: ‘version’
[08:26:28.188]   - Field: ‘result’
[08:26:28.188]   - Field: ‘asynchronous’
[08:26:28.188]   - Field: ‘calls’
[08:26:28.188]   - Field: ‘globals’
[08:26:28.189]   - Field: ‘stdout’
[08:26:28.189]   - Field: ‘earlySignal’
[08:26:28.189]   - Field: ‘lazy’
[08:26:28.189]   - Field: ‘state’
[08:26:28.189] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:28.189] - Launch lazy future ...
[08:26:28.189] Packages needed by the future expression (n = 1): ‘future.apply’
[08:26:28.189] Packages needed by future strategies (n = 0): <none>
[08:26:28.190] {
[08:26:28.190]     {
[08:26:28.190]         {
[08:26:28.190]             ...future.startTime <- base::Sys.time()
[08:26:28.190]             {
[08:26:28.190]                 {
[08:26:28.190]                   {
[08:26:28.190]                     {
[08:26:28.190]                       {
[08:26:28.190]                         base::local({
[08:26:28.190]                           has_future <- base::requireNamespace("future", 
[08:26:28.190]                             quietly = TRUE)
[08:26:28.190]                           if (has_future) {
[08:26:28.190]                             ns <- base::getNamespace("future")
[08:26:28.190]                             version <- ns[[".package"]][["version"]]
[08:26:28.190]                             if (is.null(version)) 
[08:26:28.190]                               version <- utils::packageVersion("future")
[08:26:28.190]                           }
[08:26:28.190]                           else {
[08:26:28.190]                             version <- NULL
[08:26:28.190]                           }
[08:26:28.190]                           if (!has_future || version < "1.8.0") {
[08:26:28.190]                             info <- base::c(r_version = base::gsub("R version ", 
[08:26:28.190]                               "", base::R.version$version.string), 
[08:26:28.190]                               platform = base::sprintf("%s (%s-bit)", 
[08:26:28.190]                                 base::R.version$platform, 8 * 
[08:26:28.190]                                   base::.Machine$sizeof.pointer), 
[08:26:28.190]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:28.190]                                 "release", "version")], collapse = " "), 
[08:26:28.190]                               hostname = base::Sys.info()[["nodename"]])
[08:26:28.190]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:26:28.190]                               info)
[08:26:28.190]                             info <- base::paste(info, collapse = "; ")
[08:26:28.190]                             if (!has_future) {
[08:26:28.190]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:28.190]                                 info)
[08:26:28.190]                             }
[08:26:28.190]                             else {
[08:26:28.190]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:28.190]                                 info, version)
[08:26:28.190]                             }
[08:26:28.190]                             base::stop(msg)
[08:26:28.190]                           }
[08:26:28.190]                         })
[08:26:28.190]                       }
[08:26:28.190]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:28.190]                       base::options(mc.cores = 1L)
[08:26:28.190]                     }
[08:26:28.190]                     base::local({
[08:26:28.190]                       for (pkg in "future.apply") {
[08:26:28.190]                         base::loadNamespace(pkg)
[08:26:28.190]                         base::library(pkg, character.only = TRUE)
[08:26:28.190]                       }
[08:26:28.190]                     })
[08:26:28.190]                   }
[08:26:28.190]                   ...future.strategy.old <- future::plan("list")
[08:26:28.190]                   options(future.plan = NULL)
[08:26:28.190]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:28.190]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:28.190]                 }
[08:26:28.190]                 ...future.workdir <- getwd()
[08:26:28.190]             }
[08:26:28.190]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:28.190]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:28.190]         }
[08:26:28.190]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:28.190]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:28.190]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:28.190]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:28.190]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:28.190]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:28.190]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:28.190]             base::names(...future.oldOptions))
[08:26:28.190]     }
[08:26:28.190]     if (FALSE) {
[08:26:28.190]     }
[08:26:28.190]     else {
[08:26:28.190]         if (TRUE) {
[08:26:28.190]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:28.190]                 open = "w")
[08:26:28.190]         }
[08:26:28.190]         else {
[08:26:28.190]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:28.190]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:28.190]         }
[08:26:28.190]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:28.190]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:28.190]             base::sink(type = "output", split = FALSE)
[08:26:28.190]             base::close(...future.stdout)
[08:26:28.190]         }, add = TRUE)
[08:26:28.190]     }
[08:26:28.190]     ...future.frame <- base::sys.nframe()
[08:26:28.190]     ...future.conditions <- base::list()
[08:26:28.190]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:28.190]     if (FALSE) {
[08:26:28.190]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:28.190]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:28.190]     }
[08:26:28.190]     ...future.result <- base::tryCatch({
[08:26:28.190]         base::withCallingHandlers({
[08:26:28.190]             ...future.value <- base::withVisible(base::local({
[08:26:28.190]                 ...future.makeSendCondition <- base::local({
[08:26:28.190]                   sendCondition <- NULL
[08:26:28.190]                   function(frame = 1L) {
[08:26:28.190]                     if (is.function(sendCondition)) 
[08:26:28.190]                       return(sendCondition)
[08:26:28.190]                     ns <- getNamespace("parallel")
[08:26:28.190]                     if (exists("sendData", mode = "function", 
[08:26:28.190]                       envir = ns)) {
[08:26:28.190]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:28.190]                         envir = ns)
[08:26:28.190]                       envir <- sys.frame(frame)
[08:26:28.190]                       master <- NULL
[08:26:28.190]                       while (!identical(envir, .GlobalEnv) && 
[08:26:28.190]                         !identical(envir, emptyenv())) {
[08:26:28.190]                         if (exists("master", mode = "list", envir = envir, 
[08:26:28.190]                           inherits = FALSE)) {
[08:26:28.190]                           master <- get("master", mode = "list", 
[08:26:28.190]                             envir = envir, inherits = FALSE)
[08:26:28.190]                           if (inherits(master, c("SOCKnode", 
[08:26:28.190]                             "SOCK0node"))) {
[08:26:28.190]                             sendCondition <<- function(cond) {
[08:26:28.190]                               data <- list(type = "VALUE", value = cond, 
[08:26:28.190]                                 success = TRUE)
[08:26:28.190]                               parallel_sendData(master, data)
[08:26:28.190]                             }
[08:26:28.190]                             return(sendCondition)
[08:26:28.190]                           }
[08:26:28.190]                         }
[08:26:28.190]                         frame <- frame + 1L
[08:26:28.190]                         envir <- sys.frame(frame)
[08:26:28.190]                       }
[08:26:28.190]                     }
[08:26:28.190]                     sendCondition <<- function(cond) NULL
[08:26:28.190]                   }
[08:26:28.190]                 })
[08:26:28.190]                 withCallingHandlers({
[08:26:28.190]                   {
[08:26:28.190]                     do.call(function(...) {
[08:26:28.190]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:28.190]                       if (!identical(...future.globals.maxSize.org, 
[08:26:28.190]                         ...future.globals.maxSize)) {
[08:26:28.190]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:28.190]                         on.exit(options(oopts), add = TRUE)
[08:26:28.190]                       }
[08:26:28.190]                       {
[08:26:28.190]                         lapply(seq_along(...future.elements_ii), 
[08:26:28.190]                           FUN = function(jj) {
[08:26:28.190]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:28.190]                             ...future.FUN(...future.X_jj, ...)
[08:26:28.190]                           })
[08:26:28.190]                       }
[08:26:28.190]                     }, args = future.call.arguments)
[08:26:28.190]                   }
[08:26:28.190]                 }, immediateCondition = function(cond) {
[08:26:28.190]                   sendCondition <- ...future.makeSendCondition()
[08:26:28.190]                   sendCondition(cond)
[08:26:28.190]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:28.190]                   {
[08:26:28.190]                     inherits <- base::inherits
[08:26:28.190]                     invokeRestart <- base::invokeRestart
[08:26:28.190]                     is.null <- base::is.null
[08:26:28.190]                     muffled <- FALSE
[08:26:28.190]                     if (inherits(cond, "message")) {
[08:26:28.190]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:28.190]                       if (muffled) 
[08:26:28.190]                         invokeRestart("muffleMessage")
[08:26:28.190]                     }
[08:26:28.190]                     else if (inherits(cond, "warning")) {
[08:26:28.190]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:28.190]                       if (muffled) 
[08:26:28.190]                         invokeRestart("muffleWarning")
[08:26:28.190]                     }
[08:26:28.190]                     else if (inherits(cond, "condition")) {
[08:26:28.190]                       if (!is.null(pattern)) {
[08:26:28.190]                         computeRestarts <- base::computeRestarts
[08:26:28.190]                         grepl <- base::grepl
[08:26:28.190]                         restarts <- computeRestarts(cond)
[08:26:28.190]                         for (restart in restarts) {
[08:26:28.190]                           name <- restart$name
[08:26:28.190]                           if (is.null(name)) 
[08:26:28.190]                             next
[08:26:28.190]                           if (!grepl(pattern, name)) 
[08:26:28.190]                             next
[08:26:28.190]                           invokeRestart(restart)
[08:26:28.190]                           muffled <- TRUE
[08:26:28.190]                           break
[08:26:28.190]                         }
[08:26:28.190]                       }
[08:26:28.190]                     }
[08:26:28.190]                     invisible(muffled)
[08:26:28.190]                   }
[08:26:28.190]                   muffleCondition(cond)
[08:26:28.190]                 })
[08:26:28.190]             }))
[08:26:28.190]             future::FutureResult(value = ...future.value$value, 
[08:26:28.190]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:28.190]                   ...future.rng), globalenv = if (FALSE) 
[08:26:28.190]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:28.190]                     ...future.globalenv.names))
[08:26:28.190]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:28.190]         }, condition = base::local({
[08:26:28.190]             c <- base::c
[08:26:28.190]             inherits <- base::inherits
[08:26:28.190]             invokeRestart <- base::invokeRestart
[08:26:28.190]             length <- base::length
[08:26:28.190]             list <- base::list
[08:26:28.190]             seq.int <- base::seq.int
[08:26:28.190]             signalCondition <- base::signalCondition
[08:26:28.190]             sys.calls <- base::sys.calls
[08:26:28.190]             `[[` <- base::`[[`
[08:26:28.190]             `+` <- base::`+`
[08:26:28.190]             `<<-` <- base::`<<-`
[08:26:28.190]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:28.190]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:28.190]                   3L)]
[08:26:28.190]             }
[08:26:28.190]             function(cond) {
[08:26:28.190]                 is_error <- inherits(cond, "error")
[08:26:28.190]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:28.190]                   NULL)
[08:26:28.190]                 if (is_error) {
[08:26:28.190]                   sessionInformation <- function() {
[08:26:28.190]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:28.190]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:28.190]                       search = base::search(), system = base::Sys.info())
[08:26:28.190]                   }
[08:26:28.190]                   ...future.conditions[[length(...future.conditions) + 
[08:26:28.190]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:28.190]                     cond$call), session = sessionInformation(), 
[08:26:28.190]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:28.190]                   signalCondition(cond)
[08:26:28.190]                 }
[08:26:28.190]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:28.190]                 "immediateCondition"))) {
[08:26:28.190]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:28.190]                   ...future.conditions[[length(...future.conditions) + 
[08:26:28.190]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:28.190]                   if (TRUE && !signal) {
[08:26:28.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:28.190]                     {
[08:26:28.190]                       inherits <- base::inherits
[08:26:28.190]                       invokeRestart <- base::invokeRestart
[08:26:28.190]                       is.null <- base::is.null
[08:26:28.190]                       muffled <- FALSE
[08:26:28.190]                       if (inherits(cond, "message")) {
[08:26:28.190]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:28.190]                         if (muffled) 
[08:26:28.190]                           invokeRestart("muffleMessage")
[08:26:28.190]                       }
[08:26:28.190]                       else if (inherits(cond, "warning")) {
[08:26:28.190]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:28.190]                         if (muffled) 
[08:26:28.190]                           invokeRestart("muffleWarning")
[08:26:28.190]                       }
[08:26:28.190]                       else if (inherits(cond, "condition")) {
[08:26:28.190]                         if (!is.null(pattern)) {
[08:26:28.190]                           computeRestarts <- base::computeRestarts
[08:26:28.190]                           grepl <- base::grepl
[08:26:28.190]                           restarts <- computeRestarts(cond)
[08:26:28.190]                           for (restart in restarts) {
[08:26:28.190]                             name <- restart$name
[08:26:28.190]                             if (is.null(name)) 
[08:26:28.190]                               next
[08:26:28.190]                             if (!grepl(pattern, name)) 
[08:26:28.190]                               next
[08:26:28.190]                             invokeRestart(restart)
[08:26:28.190]                             muffled <- TRUE
[08:26:28.190]                             break
[08:26:28.190]                           }
[08:26:28.190]                         }
[08:26:28.190]                       }
[08:26:28.190]                       invisible(muffled)
[08:26:28.190]                     }
[08:26:28.190]                     muffleCondition(cond, pattern = "^muffle")
[08:26:28.190]                   }
[08:26:28.190]                 }
[08:26:28.190]                 else {
[08:26:28.190]                   if (TRUE) {
[08:26:28.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:28.190]                     {
[08:26:28.190]                       inherits <- base::inherits
[08:26:28.190]                       invokeRestart <- base::invokeRestart
[08:26:28.190]                       is.null <- base::is.null
[08:26:28.190]                       muffled <- FALSE
[08:26:28.190]                       if (inherits(cond, "message")) {
[08:26:28.190]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:28.190]                         if (muffled) 
[08:26:28.190]                           invokeRestart("muffleMessage")
[08:26:28.190]                       }
[08:26:28.190]                       else if (inherits(cond, "warning")) {
[08:26:28.190]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:28.190]                         if (muffled) 
[08:26:28.190]                           invokeRestart("muffleWarning")
[08:26:28.190]                       }
[08:26:28.190]                       else if (inherits(cond, "condition")) {
[08:26:28.190]                         if (!is.null(pattern)) {
[08:26:28.190]                           computeRestarts <- base::computeRestarts
[08:26:28.190]                           grepl <- base::grepl
[08:26:28.190]                           restarts <- computeRestarts(cond)
[08:26:28.190]                           for (restart in restarts) {
[08:26:28.190]                             name <- restart$name
[08:26:28.190]                             if (is.null(name)) 
[08:26:28.190]                               next
[08:26:28.190]                             if (!grepl(pattern, name)) 
[08:26:28.190]                               next
[08:26:28.190]                             invokeRestart(restart)
[08:26:28.190]                             muffled <- TRUE
[08:26:28.190]                             break
[08:26:28.190]                           }
[08:26:28.190]                         }
[08:26:28.190]                       }
[08:26:28.190]                       invisible(muffled)
[08:26:28.190]                     }
[08:26:28.190]                     muffleCondition(cond, pattern = "^muffle")
[08:26:28.190]                   }
[08:26:28.190]                 }
[08:26:28.190]             }
[08:26:28.190]         }))
[08:26:28.190]     }, error = function(ex) {
[08:26:28.190]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:28.190]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:28.190]                 ...future.rng), started = ...future.startTime, 
[08:26:28.190]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:28.190]             version = "1.8"), class = "FutureResult")
[08:26:28.190]     }, finally = {
[08:26:28.190]         if (!identical(...future.workdir, getwd())) 
[08:26:28.190]             setwd(...future.workdir)
[08:26:28.190]         {
[08:26:28.190]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:28.190]                 ...future.oldOptions$nwarnings <- NULL
[08:26:28.190]             }
[08:26:28.190]             base::options(...future.oldOptions)
[08:26:28.190]             if (.Platform$OS.type == "windows") {
[08:26:28.190]                 old_names <- names(...future.oldEnvVars)
[08:26:28.190]                 envs <- base::Sys.getenv()
[08:26:28.190]                 names <- names(envs)
[08:26:28.190]                 common <- intersect(names, old_names)
[08:26:28.190]                 added <- setdiff(names, old_names)
[08:26:28.190]                 removed <- setdiff(old_names, names)
[08:26:28.190]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:28.190]                   envs[common]]
[08:26:28.190]                 NAMES <- toupper(changed)
[08:26:28.190]                 args <- list()
[08:26:28.190]                 for (kk in seq_along(NAMES)) {
[08:26:28.190]                   name <- changed[[kk]]
[08:26:28.190]                   NAME <- NAMES[[kk]]
[08:26:28.190]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:28.190]                     next
[08:26:28.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:28.190]                 }
[08:26:28.190]                 NAMES <- toupper(added)
[08:26:28.190]                 for (kk in seq_along(NAMES)) {
[08:26:28.190]                   name <- added[[kk]]
[08:26:28.190]                   NAME <- NAMES[[kk]]
[08:26:28.190]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:28.190]                     next
[08:26:28.190]                   args[[name]] <- ""
[08:26:28.190]                 }
[08:26:28.190]                 NAMES <- toupper(removed)
[08:26:28.190]                 for (kk in seq_along(NAMES)) {
[08:26:28.190]                   name <- removed[[kk]]
[08:26:28.190]                   NAME <- NAMES[[kk]]
[08:26:28.190]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:28.190]                     next
[08:26:28.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:28.190]                 }
[08:26:28.190]                 if (length(args) > 0) 
[08:26:28.190]                   base::do.call(base::Sys.setenv, args = args)
[08:26:28.190]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:28.190]             }
[08:26:28.190]             else {
[08:26:28.190]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:28.190]             }
[08:26:28.190]             {
[08:26:28.190]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:28.190]                   0L) {
[08:26:28.190]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:28.190]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:28.190]                   base::options(opts)
[08:26:28.190]                 }
[08:26:28.190]                 {
[08:26:28.190]                   {
[08:26:28.190]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:28.190]                     NULL
[08:26:28.190]                   }
[08:26:28.190]                   options(future.plan = NULL)
[08:26:28.190]                   if (is.na(NA_character_)) 
[08:26:28.190]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:28.190]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:28.190]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:28.190]                     .init = FALSE)
[08:26:28.190]                 }
[08:26:28.190]             }
[08:26:28.190]         }
[08:26:28.190]     })
[08:26:28.190]     if (TRUE) {
[08:26:28.190]         base::sink(type = "output", split = FALSE)
[08:26:28.190]         if (TRUE) {
[08:26:28.190]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:28.190]         }
[08:26:28.190]         else {
[08:26:28.190]             ...future.result["stdout"] <- base::list(NULL)
[08:26:28.190]         }
[08:26:28.190]         base::close(...future.stdout)
[08:26:28.190]         ...future.stdout <- NULL
[08:26:28.190]     }
[08:26:28.190]     ...future.result$conditions <- ...future.conditions
[08:26:28.190]     ...future.result$finished <- base::Sys.time()
[08:26:28.190]     ...future.result
[08:26:28.190] }
[08:26:28.193] Exporting 11 global objects (13.23 KiB) to cluster node #2 ...
[08:26:28.193] Exporting ‘...future.FUN’ (4.65 KiB) to cluster node #2 ...
[08:26:28.235] Exporting ‘...future.FUN’ (4.65 KiB) to cluster node #2 ... DONE
[08:26:28.235] Exporting ‘x_FUN’ (185 bytes) to cluster node #2 ...
[08:26:28.238] Exporting ‘x_FUN’ (185 bytes) to cluster node #2 ... DONE
[08:26:28.238] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[08:26:28.239] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[08:26:28.239] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[08:26:28.280] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[08:26:28.280] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[08:26:28.322] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[08:26:28.322] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[08:26:28.322] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[08:26:28.322] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[08:26:28.323] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[08:26:28.323] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:26:28.323] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:26:28.324] Exporting ‘...future.elements_ii’ (55 bytes) to cluster node #2 ...
[08:26:28.324] Exporting ‘...future.elements_ii’ (55 bytes) to cluster node #2 ... DONE
[08:26:28.324] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:26:28.324] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:26:28.324] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:26:28.325] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:26:28.325] Exporting 11 global objects (13.23 KiB) to cluster node #2 ... DONE
[08:26:28.325] MultisessionFuture started
[08:26:28.326] - Launch lazy future ... done
[08:26:28.326] run() for ‘MultisessionFuture’ ... done
[08:26:28.326] Created future:
[08:26:28.326] MultisessionFuture:
[08:26:28.326] Label: ‘future_vapply-2’
[08:26:28.326] Expression:
[08:26:28.326] {
[08:26:28.326]     do.call(function(...) {
[08:26:28.326]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:28.326]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:28.326]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:28.326]             on.exit(options(oopts), add = TRUE)
[08:26:28.326]         }
[08:26:28.326]         {
[08:26:28.326]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:28.326]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:28.326]                 ...future.FUN(...future.X_jj, ...)
[08:26:28.326]             })
[08:26:28.326]         }
[08:26:28.326]     }, args = future.call.arguments)
[08:26:28.326] }
[08:26:28.326] Lazy evaluation: FALSE
[08:26:28.326] Asynchronous evaluation: TRUE
[08:26:28.326] Local evaluation: TRUE
[08:26:28.326] Environment: R_GlobalEnv
[08:26:28.326] Capture standard output: TRUE
[08:26:28.326] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:28.326] Globals: 11 objects totaling 13.01 KiB (function ‘...future.FUN’ of 4.65 KiB, function ‘x_FUN’ of 185 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[08:26:28.326] Packages: 1 packages (‘future.apply’)
[08:26:28.326] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:28.326] Resolved: FALSE
[08:26:28.326] Value: <not collected>
[08:26:28.326] Conditions captured: <none>
[08:26:28.326] Early signaling: FALSE
[08:26:28.326] Owner process: 112489ed-9e25-87f6-b028-a6697fc6b74a
[08:26:28.326] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:28.338] Chunk #2 of 2 ... DONE
[08:26:28.338] Launching 2 futures (chunks) ... DONE
[08:26:28.338] Resolving 2 futures (chunks) ...
[08:26:28.338] resolve() on list ...
[08:26:28.338]  recursive: 0
[08:26:28.338]  length: 2
[08:26:28.338] 
[08:26:28.339] receiveMessageFromWorker() for ClusterFuture ...
[08:26:28.339] - Validating connection of MultisessionFuture
[08:26:28.339] - received message: FutureResult
[08:26:28.339] - Received FutureResult
[08:26:28.339] - Erased future from FutureRegistry
[08:26:28.340] result() for ClusterFuture ...
[08:26:28.340] - result already collected: FutureResult
[08:26:28.340] result() for ClusterFuture ... done
[08:26:28.340] signalConditions() ...
[08:26:28.340]  - include = ‘immediateCondition’
[08:26:28.340]  - exclude = 
[08:26:28.340]  - resignal = FALSE
[08:26:28.340]  - Number of conditions: 1
[08:26:28.340] signalConditions() ... done
[08:26:28.340] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:28.340] Future #1
[08:26:28.340] result() for ClusterFuture ...
[08:26:28.341] - result already collected: FutureResult
[08:26:28.341] result() for ClusterFuture ... done
[08:26:28.341] result() for ClusterFuture ...
[08:26:28.341] - result already collected: FutureResult
[08:26:28.341] result() for ClusterFuture ... done
[08:26:28.341] signalConditions() ...
[08:26:28.341]  - include = ‘immediateCondition’
[08:26:28.341]  - exclude = 
[08:26:28.341]  - resignal = FALSE
[08:26:28.341]  - Number of conditions: 1
[08:26:28.341] signalConditions() ... done
[08:26:28.341] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:26:28.342] - nx: 2
[08:26:28.342] - relay: TRUE
[08:26:28.342] - stdout: TRUE
[08:26:28.342] - signal: TRUE
[08:26:28.342] - resignal: FALSE
[08:26:28.342] - force: TRUE
[08:26:28.342] - relayed: [n=2] FALSE, FALSE
[08:26:28.342] - queued futures: [n=2] FALSE, FALSE
[08:26:28.342]  - until=1
[08:26:28.342]  - relaying element #1
[08:26:28.342] result() for ClusterFuture ...
[08:26:28.342] - result already collected: FutureResult
[08:26:28.343] result() for ClusterFuture ... done
[08:26:28.343] result() for ClusterFuture ...
[08:26:28.343] - result already collected: FutureResult
[08:26:28.343] result() for ClusterFuture ... done
[08:26:28.343] signalConditions() ...
[08:26:28.343]  - include = ‘immediateCondition’
[08:26:28.343]  - exclude = 
[08:26:28.343]  - resignal = FALSE
[08:26:28.343]  - Number of conditions: 1
[08:26:28.343] signalConditions() ... done
[08:26:28.343] result() for ClusterFuture ...
[08:26:28.343] - result already collected: FutureResult
[08:26:28.344] result() for ClusterFuture ... done
[08:26:28.344] signalConditions() ...
[08:26:28.344]  - include = ‘immediateCondition’
[08:26:28.344]  - exclude = 
[08:26:28.344]  - resignal = FALSE
[08:26:28.344]  - Number of conditions: 1
[08:26:28.344] signalConditions() ... done
[08:26:28.344] result() for ClusterFuture ...
[08:26:28.344] - result already collected: FutureResult
[08:26:28.344] result() for ClusterFuture ... done
[08:26:28.344] signalConditions() ...
[08:26:28.344]  - include = ‘condition’
[08:26:28.344]  - exclude = ‘immediateCondition’
[08:26:28.345]  - resignal = TRUE
[08:26:28.345]  - Number of conditions: 1
[08:26:28.345]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:26:28.345] signalConditions() ... done
[08:26:28.345] - relayed: [n=2] FALSE, FALSE
[08:26:28.345] - queued futures: [n=2] TRUE, FALSE
[08:26:28.345] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:26:28.345] plan(): Setting new future strategy stack:
[08:26:28.345] List of future strategies:
[08:26:28.345] 1. sequential:
[08:26:28.345]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:28.345]    - tweaked: FALSE
[08:26:28.345]    - call: plan(sequential)
[08:26:28.346] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** future_vapply() ... DONE")
*** future_vapply() ... DONE
> 
> source("incl/end.R")
[08:26:28.347] plan(): Setting new future strategy stack:
[08:26:28.347] List of future strategies:
[08:26:28.347] 1. FutureStrategy:
[08:26:28.347]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:28.347]    - tweaked: FALSE
[08:26:28.347]    - call: future::plan(oplan)
[08:26:28.348] plan(): nbrOfWorkers() = 1
> 
