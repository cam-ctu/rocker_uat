
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[11:00:00.081] plan(): Setting new future strategy stack:
[11:00:00.081] List of future strategies:
[11:00:00.081] 1. sequential:
[11:00:00.081]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.081]    - tweaked: FALSE
[11:00:00.081]    - call: future::plan("sequential")
[11:00:00.095] plan(): nbrOfWorkers() = 1
> 
> 
> message("*** future_vapply() ...")
*** future_vapply() ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   x <- NULL
+   fun <- is.factor
+   fun_name <- "is.factor"
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_vapply(x, FUN = fun_name, FUN.VALUE = fun_value)
+   str(y2)
+   stopifnot(all.equal(y2, y0))
+   
+   x <- list()
+   fun <- is.numeric
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- integer()
+   fun <- identity
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   
+   df <- data.frame(x = 1:10, y = letters[1:10], stringsAsFactors=FALSE)
+   fun <- class
+   fun_value <- character(1L)
+   y0 <- vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- 1:10
+   fun <- function(x) double(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) integer(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- sqrt
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) c(x, x^2)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   ## Ditto with dimnames on FUN.VALUE
+   fun <- function(x) {
+     matrix(x, nrow = 2L, ncol = 2L, dimnames = list(c("a", "b"), c("A", "B")))
+   }
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   message("- From example(vapply) ...")
+   x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE, FALSE, FALSE, TRUE))
+   y0 <- vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   y1 <- future_vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   i39 <- sapply(3:9, seq)
+   ys0 <- sapply(i39, fivenum)
+   ys1 <- future_sapply(i39, fivenum)
+   stopifnot(all.equal(ys1, ys0))
+   
+   yv0 <- vapply(i39, fivenum,
+           c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   yv1 <- future_vapply(i39, fivenum,
+          c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   v <- structure(10*(5:8), names = LETTERS[1:4])
+   f <- function(x, y) outer(rep(x, length.out = 3L), y)
+   ys0 <- sapply(v, f, y = 2*(1:5), simplify = "array")
+   ys1 <- future_sapply(v, f, y = 2*(1:5), simplify = "array")
+   stopifnot(all.equal(ys1, ys0))
+   
+   fv <- outer(1:3, 1:5)
+   y <- 2*(1:5)
+   yv0 <- vapply(v, f, fv, y = y)
+   yv1 <- future_vapply(v, f, fv, y = y)
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   y0 <- vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   y1 <- future_vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_vapply(x, ...) where length(x) != length(as.list(x)) ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   as.list.Foo <- function(x, ...) c(x, c = 3)
+   y0 <- vapply(x, FUN = length, FUN.VALUE = -1L)
+   y1 <- future_vapply(x, FUN = length, FUN.VALUE = -1L)
+   stopifnot(identical(y1, y0))
+ 
+   message("- exceptions ...")
+   res <- tryCatch({
+     y0 <- vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   res <- tryCatch({
+     y1 <- future_vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[11:00:00.200] plan(): Setting new future strategy stack:
[11:00:00.200] List of future strategies:
[11:00:00.200] 1. sequential:
[11:00:00.200]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.200]    - tweaked: FALSE
[11:00:00.200]    - call: plan(strategy)
[11:00:00.211] plan(): nbrOfWorkers() = 1
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[11:00:00.216] future_lapply() ...
[11:00:00.221] Number of chunks: 1
[11:00:00.221] getGlobalsAndPackagesXApply() ...
[11:00:00.221]  - future.globals: TRUE
[11:00:00.222] getGlobalsAndPackages() ...
[11:00:00.222] Searching for globals...
[11:00:00.225] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[11:00:00.225] Searching for globals ... DONE
[11:00:00.225] Resolving globals: FALSE
[11:00:00.227] The total size of the 7 globals is 12.01 KiB (12294 bytes)
[11:00:00.227] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.02 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:00.227] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.227] - packages: [1] ‘future.apply’
[11:00:00.228] getGlobalsAndPackages() ... DONE
[11:00:00.228]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.228]  - needed namespaces: [n=1] ‘future.apply’
[11:00:00.228] Finding globals ... DONE
[11:00:00.228]  - use_args: TRUE
[11:00:00.228]  - Getting '...' globals ...
[11:00:00.229] resolve() on list ...
[11:00:00.229]  recursive: 0
[11:00:00.229]  length: 1
[11:00:00.229]  elements: ‘...’
[11:00:00.229]  length: 0 (resolved future 1)
[11:00:00.229] resolve() on list ... DONE
[11:00:00.229]    - '...' content: [n=0] 
[11:00:00.230] List of 1
[11:00:00.230]  $ ...: list()
[11:00:00.230]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.230]  - attr(*, "where")=List of 1
[11:00:00.230]   ..$ ...:<environment: 0x55bbab347850> 
[11:00:00.230]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.230]  - attr(*, "resolved")= logi TRUE
[11:00:00.230]  - attr(*, "total_size")= num NA
[11:00:00.232]  - Getting '...' globals ... DONE
[11:00:00.232] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:00.232] List of 8
[11:00:00.232]  $ ...future.FUN:function (x, ...)  
[11:00:00.232]  $ x_FUN        :function (x)  
[11:00:00.232]  $ times        : int 1
[11:00:00.232]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.232]  $ stop_if_not  :function (...)  
[11:00:00.232]  $ dim          : NULL
[11:00:00.232]  $ valid_types  : chr "character"
[11:00:00.232]  $ ...          : list()
[11:00:00.232]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.232]  - attr(*, "where")=List of 8
[11:00:00.232]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:00.232]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:00.232]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:00.232]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:00.232]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:00.232]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:00.232]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:00.232]   ..$ ...          :<environment: 0x55bbab347850> 
[11:00:00.232]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.232]  - attr(*, "resolved")= logi FALSE
[11:00:00.232]  - attr(*, "total_size")= num 22333
[11:00:00.237] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:00.237] getGlobalsAndPackagesXApply() ... DONE
[11:00:00.238] Number of futures (= number of chunks): 1
[11:00:00.238] Launching 1 futures (chunks) ...
[11:00:00.238] Chunk #1 of 1 ...
[11:00:00.238]  - Finding globals in 'X' for chunk #1 ...
[11:00:00.238] getGlobalsAndPackages() ...
[11:00:00.238] Searching for globals...
[11:00:00.240] 
[11:00:00.240] Searching for globals ... DONE
[11:00:00.240] - globals: [0] <none>
[11:00:00.240] getGlobalsAndPackages() ... DONE
[11:00:00.240]    + additional globals found: [n=0] 
[11:00:00.241]    + additional namespaces needed: [n=0] 
[11:00:00.241]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:00.241]  - seeds: <none>
[11:00:00.241]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.241] getGlobalsAndPackages() ...
[11:00:00.241] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.241] Resolving globals: FALSE
[11:00:00.241] Tweak future expression to call with '...' arguments ...
[11:00:00.241] {
[11:00:00.241]     do.call(function(...) {
[11:00:00.241]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.241]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.241]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.241]             on.exit(options(oopts), add = TRUE)
[11:00:00.241]         }
[11:00:00.241]         {
[11:00:00.241]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.241]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.241]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.241]             })
[11:00:00.241]         }
[11:00:00.241]     }, args = future.call.arguments)
[11:00:00.241] }
[11:00:00.242] Tweak future expression to call with '...' arguments ... DONE
[11:00:00.242] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.242] - packages: [1] ‘future.apply’
[11:00:00.242] getGlobalsAndPackages() ... DONE
[11:00:00.243] run() for ‘Future’ ...
[11:00:00.243] - state: ‘created’
[11:00:00.243] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:00.243] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.244] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:00.244]   - Field: ‘label’
[11:00:00.244]   - Field: ‘local’
[11:00:00.244]   - Field: ‘owner’
[11:00:00.244]   - Field: ‘envir’
[11:00:00.244]   - Field: ‘packages’
[11:00:00.244]   - Field: ‘gc’
[11:00:00.244]   - Field: ‘conditions’
[11:00:00.244]   - Field: ‘expr’
[11:00:00.244]   - Field: ‘uuid’
[11:00:00.244]   - Field: ‘seed’
[11:00:00.244]   - Field: ‘version’
[11:00:00.245]   - Field: ‘result’
[11:00:00.245]   - Field: ‘asynchronous’
[11:00:00.245]   - Field: ‘calls’
[11:00:00.245]   - Field: ‘globals’
[11:00:00.245]   - Field: ‘stdout’
[11:00:00.245]   - Field: ‘earlySignal’
[11:00:00.245]   - Field: ‘lazy’
[11:00:00.245]   - Field: ‘state’
[11:00:00.245] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:00.245] - Launch lazy future ...
[11:00:00.246] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:00.246] Packages needed by future strategies (n = 0): <none>
[11:00:00.247] {
[11:00:00.247]     {
[11:00:00.247]         {
[11:00:00.247]             ...future.startTime <- base::Sys.time()
[11:00:00.247]             {
[11:00:00.247]                 {
[11:00:00.247]                   {
[11:00:00.247]                     {
[11:00:00.247]                       base::local({
[11:00:00.247]                         has_future <- base::requireNamespace("future", 
[11:00:00.247]                           quietly = TRUE)
[11:00:00.247]                         if (has_future) {
[11:00:00.247]                           ns <- base::getNamespace("future")
[11:00:00.247]                           version <- ns[[".package"]][["version"]]
[11:00:00.247]                           if (is.null(version)) 
[11:00:00.247]                             version <- utils::packageVersion("future")
[11:00:00.247]                         }
[11:00:00.247]                         else {
[11:00:00.247]                           version <- NULL
[11:00:00.247]                         }
[11:00:00.247]                         if (!has_future || version < "1.8.0") {
[11:00:00.247]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:00.247]                             "", base::R.version$version.string), 
[11:00:00.247]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:00.247]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:00.247]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:00.247]                               "release", "version")], collapse = " "), 
[11:00:00.247]                             hostname = base::Sys.info()[["nodename"]])
[11:00:00.247]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:00.247]                             info)
[11:00:00.247]                           info <- base::paste(info, collapse = "; ")
[11:00:00.247]                           if (!has_future) {
[11:00:00.247]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:00.247]                               info)
[11:00:00.247]                           }
[11:00:00.247]                           else {
[11:00:00.247]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:00.247]                               info, version)
[11:00:00.247]                           }
[11:00:00.247]                           base::stop(msg)
[11:00:00.247]                         }
[11:00:00.247]                       })
[11:00:00.247]                     }
[11:00:00.247]                     base::local({
[11:00:00.247]                       for (pkg in "future.apply") {
[11:00:00.247]                         base::loadNamespace(pkg)
[11:00:00.247]                         base::library(pkg, character.only = TRUE)
[11:00:00.247]                       }
[11:00:00.247]                     })
[11:00:00.247]                   }
[11:00:00.247]                   ...future.strategy.old <- future::plan("list")
[11:00:00.247]                   options(future.plan = NULL)
[11:00:00.247]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.247]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:00.247]                 }
[11:00:00.247]                 ...future.workdir <- getwd()
[11:00:00.247]             }
[11:00:00.247]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:00.247]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:00.247]         }
[11:00:00.247]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:00.247]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:00.247]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:00.247]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:00.247]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:00.247]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:00.247]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:00.247]             base::names(...future.oldOptions))
[11:00:00.247]     }
[11:00:00.247]     if (FALSE) {
[11:00:00.247]     }
[11:00:00.247]     else {
[11:00:00.247]         if (TRUE) {
[11:00:00.247]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:00.247]                 open = "w")
[11:00:00.247]         }
[11:00:00.247]         else {
[11:00:00.247]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:00.247]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:00.247]         }
[11:00:00.247]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:00.247]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:00.247]             base::sink(type = "output", split = FALSE)
[11:00:00.247]             base::close(...future.stdout)
[11:00:00.247]         }, add = TRUE)
[11:00:00.247]     }
[11:00:00.247]     ...future.frame <- base::sys.nframe()
[11:00:00.247]     ...future.conditions <- base::list()
[11:00:00.247]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:00.247]     if (FALSE) {
[11:00:00.247]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:00.247]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:00.247]     }
[11:00:00.247]     ...future.result <- base::tryCatch({
[11:00:00.247]         base::withCallingHandlers({
[11:00:00.247]             ...future.value <- base::withVisible(base::local({
[11:00:00.247]                 do.call(function(...) {
[11:00:00.247]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.247]                   if (!identical(...future.globals.maxSize.org, 
[11:00:00.247]                     ...future.globals.maxSize)) {
[11:00:00.247]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.247]                     on.exit(options(oopts), add = TRUE)
[11:00:00.247]                   }
[11:00:00.247]                   {
[11:00:00.247]                     lapply(seq_along(...future.elements_ii), 
[11:00:00.247]                       FUN = function(jj) {
[11:00:00.247]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.247]                         ...future.FUN(...future.X_jj, ...)
[11:00:00.247]                       })
[11:00:00.247]                   }
[11:00:00.247]                 }, args = future.call.arguments)
[11:00:00.247]             }))
[11:00:00.247]             future::FutureResult(value = ...future.value$value, 
[11:00:00.247]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.247]                   ...future.rng), globalenv = if (FALSE) 
[11:00:00.247]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:00.247]                     ...future.globalenv.names))
[11:00:00.247]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:00.247]         }, condition = base::local({
[11:00:00.247]             c <- base::c
[11:00:00.247]             inherits <- base::inherits
[11:00:00.247]             invokeRestart <- base::invokeRestart
[11:00:00.247]             length <- base::length
[11:00:00.247]             list <- base::list
[11:00:00.247]             seq.int <- base::seq.int
[11:00:00.247]             signalCondition <- base::signalCondition
[11:00:00.247]             sys.calls <- base::sys.calls
[11:00:00.247]             `[[` <- base::`[[`
[11:00:00.247]             `+` <- base::`+`
[11:00:00.247]             `<<-` <- base::`<<-`
[11:00:00.247]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:00.247]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:00.247]                   3L)]
[11:00:00.247]             }
[11:00:00.247]             function(cond) {
[11:00:00.247]                 is_error <- inherits(cond, "error")
[11:00:00.247]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:00.247]                   NULL)
[11:00:00.247]                 if (is_error) {
[11:00:00.247]                   sessionInformation <- function() {
[11:00:00.247]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:00.247]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:00.247]                       search = base::search(), system = base::Sys.info())
[11:00:00.247]                   }
[11:00:00.247]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.247]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:00.247]                     cond$call), session = sessionInformation(), 
[11:00:00.247]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:00.247]                   signalCondition(cond)
[11:00:00.247]                 }
[11:00:00.247]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:00.247]                 "immediateCondition"))) {
[11:00:00.247]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:00.247]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.247]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:00.247]                   if (TRUE && !signal) {
[11:00:00.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.247]                     {
[11:00:00.247]                       inherits <- base::inherits
[11:00:00.247]                       invokeRestart <- base::invokeRestart
[11:00:00.247]                       is.null <- base::is.null
[11:00:00.247]                       muffled <- FALSE
[11:00:00.247]                       if (inherits(cond, "message")) {
[11:00:00.247]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.247]                         if (muffled) 
[11:00:00.247]                           invokeRestart("muffleMessage")
[11:00:00.247]                       }
[11:00:00.247]                       else if (inherits(cond, "warning")) {
[11:00:00.247]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.247]                         if (muffled) 
[11:00:00.247]                           invokeRestart("muffleWarning")
[11:00:00.247]                       }
[11:00:00.247]                       else if (inherits(cond, "condition")) {
[11:00:00.247]                         if (!is.null(pattern)) {
[11:00:00.247]                           computeRestarts <- base::computeRestarts
[11:00:00.247]                           grepl <- base::grepl
[11:00:00.247]                           restarts <- computeRestarts(cond)
[11:00:00.247]                           for (restart in restarts) {
[11:00:00.247]                             name <- restart$name
[11:00:00.247]                             if (is.null(name)) 
[11:00:00.247]                               next
[11:00:00.247]                             if (!grepl(pattern, name)) 
[11:00:00.247]                               next
[11:00:00.247]                             invokeRestart(restart)
[11:00:00.247]                             muffled <- TRUE
[11:00:00.247]                             break
[11:00:00.247]                           }
[11:00:00.247]                         }
[11:00:00.247]                       }
[11:00:00.247]                       invisible(muffled)
[11:00:00.247]                     }
[11:00:00.247]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.247]                   }
[11:00:00.247]                 }
[11:00:00.247]                 else {
[11:00:00.247]                   if (TRUE) {
[11:00:00.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.247]                     {
[11:00:00.247]                       inherits <- base::inherits
[11:00:00.247]                       invokeRestart <- base::invokeRestart
[11:00:00.247]                       is.null <- base::is.null
[11:00:00.247]                       muffled <- FALSE
[11:00:00.247]                       if (inherits(cond, "message")) {
[11:00:00.247]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.247]                         if (muffled) 
[11:00:00.247]                           invokeRestart("muffleMessage")
[11:00:00.247]                       }
[11:00:00.247]                       else if (inherits(cond, "warning")) {
[11:00:00.247]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.247]                         if (muffled) 
[11:00:00.247]                           invokeRestart("muffleWarning")
[11:00:00.247]                       }
[11:00:00.247]                       else if (inherits(cond, "condition")) {
[11:00:00.247]                         if (!is.null(pattern)) {
[11:00:00.247]                           computeRestarts <- base::computeRestarts
[11:00:00.247]                           grepl <- base::grepl
[11:00:00.247]                           restarts <- computeRestarts(cond)
[11:00:00.247]                           for (restart in restarts) {
[11:00:00.247]                             name <- restart$name
[11:00:00.247]                             if (is.null(name)) 
[11:00:00.247]                               next
[11:00:00.247]                             if (!grepl(pattern, name)) 
[11:00:00.247]                               next
[11:00:00.247]                             invokeRestart(restart)
[11:00:00.247]                             muffled <- TRUE
[11:00:00.247]                             break
[11:00:00.247]                           }
[11:00:00.247]                         }
[11:00:00.247]                       }
[11:00:00.247]                       invisible(muffled)
[11:00:00.247]                     }
[11:00:00.247]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.247]                   }
[11:00:00.247]                 }
[11:00:00.247]             }
[11:00:00.247]         }))
[11:00:00.247]     }, error = function(ex) {
[11:00:00.247]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:00.247]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.247]                 ...future.rng), started = ...future.startTime, 
[11:00:00.247]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:00.247]             version = "1.8"), class = "FutureResult")
[11:00:00.247]     }, finally = {
[11:00:00.247]         if (!identical(...future.workdir, getwd())) 
[11:00:00.247]             setwd(...future.workdir)
[11:00:00.247]         {
[11:00:00.247]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:00.247]                 ...future.oldOptions$nwarnings <- NULL
[11:00:00.247]             }
[11:00:00.247]             base::options(...future.oldOptions)
[11:00:00.247]             if (.Platform$OS.type == "windows") {
[11:00:00.247]                 old_names <- names(...future.oldEnvVars)
[11:00:00.247]                 envs <- base::Sys.getenv()
[11:00:00.247]                 names <- names(envs)
[11:00:00.247]                 common <- intersect(names, old_names)
[11:00:00.247]                 added <- setdiff(names, old_names)
[11:00:00.247]                 removed <- setdiff(old_names, names)
[11:00:00.247]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:00.247]                   envs[common]]
[11:00:00.247]                 NAMES <- toupper(changed)
[11:00:00.247]                 args <- list()
[11:00:00.247]                 for (kk in seq_along(NAMES)) {
[11:00:00.247]                   name <- changed[[kk]]
[11:00:00.247]                   NAME <- NAMES[[kk]]
[11:00:00.247]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.247]                     next
[11:00:00.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.247]                 }
[11:00:00.247]                 NAMES <- toupper(added)
[11:00:00.247]                 for (kk in seq_along(NAMES)) {
[11:00:00.247]                   name <- added[[kk]]
[11:00:00.247]                   NAME <- NAMES[[kk]]
[11:00:00.247]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.247]                     next
[11:00:00.247]                   args[[name]] <- ""
[11:00:00.247]                 }
[11:00:00.247]                 NAMES <- toupper(removed)
[11:00:00.247]                 for (kk in seq_along(NAMES)) {
[11:00:00.247]                   name <- removed[[kk]]
[11:00:00.247]                   NAME <- NAMES[[kk]]
[11:00:00.247]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.247]                     next
[11:00:00.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.247]                 }
[11:00:00.247]                 if (length(args) > 0) 
[11:00:00.247]                   base::do.call(base::Sys.setenv, args = args)
[11:00:00.247]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:00.247]             }
[11:00:00.247]             else {
[11:00:00.247]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:00.247]             }
[11:00:00.247]             {
[11:00:00.247]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:00.247]                   0L) {
[11:00:00.247]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:00.247]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:00.247]                   base::options(opts)
[11:00:00.247]                 }
[11:00:00.247]                 {
[11:00:00.247]                   {
[11:00:00.247]                     NULL
[11:00:00.247]                     RNGkind("Mersenne-Twister")
[11:00:00.247]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:00.247]                       inherits = FALSE)
[11:00:00.247]                   }
[11:00:00.247]                   options(future.plan = NULL)
[11:00:00.247]                   if (is.na(NA_character_)) 
[11:00:00.247]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.247]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:00.247]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:00.247]                     .init = FALSE)
[11:00:00.247]                 }
[11:00:00.247]             }
[11:00:00.247]         }
[11:00:00.247]     })
[11:00:00.247]     if (TRUE) {
[11:00:00.247]         base::sink(type = "output", split = FALSE)
[11:00:00.247]         if (TRUE) {
[11:00:00.247]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:00.247]         }
[11:00:00.247]         else {
[11:00:00.247]             ...future.result["stdout"] <- base::list(NULL)
[11:00:00.247]         }
[11:00:00.247]         base::close(...future.stdout)
[11:00:00.247]         ...future.stdout <- NULL
[11:00:00.247]     }
[11:00:00.247]     ...future.result$conditions <- ...future.conditions
[11:00:00.247]     ...future.result$finished <- base::Sys.time()
[11:00:00.247]     ...future.result
[11:00:00.247] }
[11:00:00.249] assign_globals() ...
[11:00:00.249] List of 11
[11:00:00.249]  $ ...future.FUN            :function (x, ...)  
[11:00:00.249]  $ x_FUN                    :function (x)  
[11:00:00.249]  $ times                    : int 1
[11:00:00.249]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.249]  $ stop_if_not              :function (...)  
[11:00:00.249]  $ dim                      : NULL
[11:00:00.249]  $ valid_types              : chr "character"
[11:00:00.249]  $ future.call.arguments    : list()
[11:00:00.249]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.249]  $ ...future.elements_ii    :List of 2
[11:00:00.249]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[11:00:00.249]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[11:00:00.249]  $ ...future.seeds_ii       : NULL
[11:00:00.249]  $ ...future.globals.maxSize: NULL
[11:00:00.249]  - attr(*, "where")=List of 11
[11:00:00.249]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:00.249]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:00.249]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:00.249]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:00.249]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:00.249]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:00.249]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:00.249]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:00.249]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:00.249]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:00.249]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:00.249]  - attr(*, "resolved")= logi FALSE
[11:00:00.249]  - attr(*, "total_size")= num 22333
[11:00:00.249]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.249]  - attr(*, "already-done")= logi TRUE
[11:00:00.256] - copied ‘...future.FUN’ to environment
[11:00:00.256] - copied ‘x_FUN’ to environment
[11:00:00.256] - copied ‘times’ to environment
[11:00:00.256] - copied ‘stopf’ to environment
[11:00:00.256] - copied ‘stop_if_not’ to environment
[11:00:00.256] - copied ‘dim’ to environment
[11:00:00.256] - copied ‘valid_types’ to environment
[11:00:00.256] - copied ‘future.call.arguments’ to environment
[11:00:00.256] - copied ‘...future.elements_ii’ to environment
[11:00:00.257] - copied ‘...future.seeds_ii’ to environment
[11:00:00.257] - copied ‘...future.globals.maxSize’ to environment
[11:00:00.257] assign_globals() ... done
[11:00:00.257] plan(): Setting new future strategy stack:
[11:00:00.257] List of future strategies:
[11:00:00.257] 1. sequential:
[11:00:00.257]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.257]    - tweaked: FALSE
[11:00:00.257]    - call: NULL
[11:00:00.258] plan(): nbrOfWorkers() = 1
[11:00:00.259] plan(): Setting new future strategy stack:
[11:00:00.259] List of future strategies:
[11:00:00.259] 1. sequential:
[11:00:00.259]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.259]    - tweaked: FALSE
[11:00:00.259]    - call: plan(strategy)
[11:00:00.259] plan(): nbrOfWorkers() = 1
[11:00:00.259] SequentialFuture started (and completed)
[11:00:00.260] - Launch lazy future ... done
[11:00:00.260] run() for ‘SequentialFuture’ ... done
[11:00:00.260] Created future:
[11:00:00.260] SequentialFuture:
[11:00:00.260] Label: ‘future_vapply-1’
[11:00:00.260] Expression:
[11:00:00.260] {
[11:00:00.260]     do.call(function(...) {
[11:00:00.260]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.260]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.260]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.260]             on.exit(options(oopts), add = TRUE)
[11:00:00.260]         }
[11:00:00.260]         {
[11:00:00.260]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.260]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.260]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.260]             })
[11:00:00.260]         }
[11:00:00.260]     }, args = future.call.arguments)
[11:00:00.260] }
[11:00:00.260] Lazy evaluation: FALSE
[11:00:00.260] Asynchronous evaluation: FALSE
[11:00:00.260] Local evaluation: TRUE
[11:00:00.260] Environment: R_GlobalEnv
[11:00:00.260] Capture standard output: TRUE
[11:00:00.260] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:00.260] Globals: 11 objects totaling 12.43 KiB (function ‘...future.FUN’ of 4.02 KiB, function ‘x_FUN’ of 36 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:00.260] Packages: 1 packages (‘future.apply’)
[11:00:00.260] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:00.260] Resolved: TRUE
[11:00:00.260] Value: 79 bytes of class ‘list’
[11:00:00.260] Early signaling: FALSE
[11:00:00.260] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:00.260] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.261] Chunk #1 of 1 ... DONE
[11:00:00.261] Launching 1 futures (chunks) ... DONE
[11:00:00.261] Resolving 1 futures (chunks) ...
[11:00:00.262] resolve() on list ...
[11:00:00.262]  recursive: 0
[11:00:00.262]  length: 1
[11:00:00.262] 
[11:00:00.262] resolved() for ‘SequentialFuture’ ...
[11:00:00.262] - state: ‘finished’
[11:00:00.262] - run: TRUE
[11:00:00.262] - result: ‘FutureResult’
[11:00:00.262] resolved() for ‘SequentialFuture’ ... done
[11:00:00.262] Future #1
[11:00:00.263] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:00.263] - nx: 1
[11:00:00.263] - relay: TRUE
[11:00:00.263] - stdout: TRUE
[11:00:00.263] - signal: TRUE
[11:00:00.263] - resignal: FALSE
[11:00:00.263] - force: TRUE
[11:00:00.263] - relayed: [n=1] FALSE
[11:00:00.263] - queued futures: [n=1] FALSE
[11:00:00.263]  - until=1
[11:00:00.263]  - relaying element #1
[11:00:00.264] - relayed: [n=1] TRUE
[11:00:00.264] - queued futures: [n=1] TRUE
[11:00:00.264] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:00.264]  length: 0 (resolved future 1)
[11:00:00.264] Relaying remaining futures
[11:00:00.264] signalConditionsASAP(NULL, pos=0) ...
[11:00:00.264] - nx: 1
[11:00:00.264] - relay: TRUE
[11:00:00.264] - stdout: TRUE
[11:00:00.264] - signal: TRUE
[11:00:00.264] - resignal: FALSE
[11:00:00.265] - force: TRUE
[11:00:00.265] - relayed: [n=1] TRUE
[11:00:00.266] - queued futures: [n=1] TRUE
 - flush all
[11:00:00.266] - relayed: [n=1] TRUE
[11:00:00.266] - queued futures: [n=1] TRUE
[11:00:00.266] signalConditionsASAP(NULL, pos=0) ... done
[11:00:00.266] resolve() on list ... DONE
[11:00:00.266]  - Number of value chunks collected: 1
[11:00:00.266] Resolving 1 futures (chunks) ... DONE
[11:00:00.266] Reducing values from 1 chunks ...
[11:00:00.267]  - Number of values collected after concatenation: 2
[11:00:00.267]  - Number of values expected: 2
[11:00:00.267] Reducing values from 1 chunks ... DONE
[11:00:00.267] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[11:00:00.268] future_lapply() ...
[11:00:00.269] Number of chunks: 1
[11:00:00.269] getGlobalsAndPackagesXApply() ...
[11:00:00.270]  - future.globals: TRUE
[11:00:00.270] getGlobalsAndPackages() ...
[11:00:00.270] Searching for globals...
[11:00:00.273] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[11:00:00.273] Searching for globals ... DONE
[11:00:00.273] Resolving globals: FALSE
[11:00:00.274] The total size of the 7 globals is 12.77 KiB (13081 bytes)
[11:00:00.274] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.77 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:00.274] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.274] - packages: [1] ‘future.apply’
[11:00:00.274] getGlobalsAndPackages() ... DONE
[11:00:00.274]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.275]  - needed namespaces: [n=1] ‘future.apply’
[11:00:00.275] Finding globals ... DONE
[11:00:00.275]  - use_args: TRUE
[11:00:00.275]  - Getting '...' globals ...
[11:00:00.275] resolve() on list ...
[11:00:00.275]  recursive: 0
[11:00:00.275]  length: 1
[11:00:00.275]  elements: ‘...’
[11:00:00.275]  length: 0 (resolved future 1)
[11:00:00.276] resolve() on list ... DONE
[11:00:00.276]    - '...' content: [n=0] 
[11:00:00.276] List of 1
[11:00:00.276]  $ ...: list()
[11:00:00.276]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.276]  - attr(*, "where")=List of 1
[11:00:00.276]   ..$ ...:<environment: 0x55bbabf5ca10> 
[11:00:00.276]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.276]  - attr(*, "resolved")= logi TRUE
[11:00:00.276]  - attr(*, "total_size")= num NA
[11:00:00.278]  - Getting '...' globals ... DONE
[11:00:00.278] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:00.278] List of 8
[11:00:00.278]  $ ...future.FUN:function (x, ...)  
[11:00:00.278]  $ x_FUN        :function (x)  
[11:00:00.278]  $ times        : int 0
[11:00:00.278]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.278]  $ stop_if_not  :function (...)  
[11:00:00.278]  $ dim          : NULL
[11:00:00.278]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:00.278]  $ ...          : list()
[11:00:00.278]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.278]  - attr(*, "where")=List of 8
[11:00:00.278]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:00.278]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:00.278]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:00.278]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:00.278]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:00.278]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:00.278]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:00.278]   ..$ ...          :<environment: 0x55bbabf5ca10> 
[11:00:00.278]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.278]  - attr(*, "resolved")= logi FALSE
[11:00:00.278]  - attr(*, "total_size")= num 23490
[11:00:00.283] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:00.283] getGlobalsAndPackagesXApply() ... DONE
[11:00:00.283] Number of futures (= number of chunks): 1
[11:00:00.283] Launching 1 futures (chunks) ...
[11:00:00.283] Chunk #1 of 1 ...
[11:00:00.283]  - Finding globals in 'X' for chunk #1 ...
[11:00:00.284] getGlobalsAndPackages() ...
[11:00:00.284] Searching for globals...
[11:00:00.284] 
[11:00:00.284] Searching for globals ... DONE
[11:00:00.284] - globals: [0] <none>
[11:00:00.284] getGlobalsAndPackages() ... DONE
[11:00:00.284]    + additional globals found: [n=0] 
[11:00:00.284]    + additional namespaces needed: [n=0] 
[11:00:00.284]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:00.285]  - seeds: <none>
[11:00:00.285]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.285] getGlobalsAndPackages() ...
[11:00:00.285] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.285] Resolving globals: FALSE
[11:00:00.285] Tweak future expression to call with '...' arguments ...
[11:00:00.285] {
[11:00:00.285]     do.call(function(...) {
[11:00:00.285]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.285]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.285]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.285]             on.exit(options(oopts), add = TRUE)
[11:00:00.285]         }
[11:00:00.285]         {
[11:00:00.285]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.285]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.285]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.285]             })
[11:00:00.285]         }
[11:00:00.285]     }, args = future.call.arguments)
[11:00:00.285] }
[11:00:00.285] Tweak future expression to call with '...' arguments ... DONE
[11:00:00.286] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.287] - packages: [1] ‘future.apply’
[11:00:00.287] getGlobalsAndPackages() ... DONE
[11:00:00.287] run() for ‘Future’ ...
[11:00:00.287] - state: ‘created’
[11:00:00.287] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:00.287] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.287] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:00.288]   - Field: ‘label’
[11:00:00.288]   - Field: ‘local’
[11:00:00.288]   - Field: ‘owner’
[11:00:00.288]   - Field: ‘envir’
[11:00:00.288]   - Field: ‘packages’
[11:00:00.288]   - Field: ‘gc’
[11:00:00.288]   - Field: ‘conditions’
[11:00:00.288]   - Field: ‘expr’
[11:00:00.288]   - Field: ‘uuid’
[11:00:00.288]   - Field: ‘seed’
[11:00:00.288]   - Field: ‘version’
[11:00:00.288]   - Field: ‘result’
[11:00:00.289]   - Field: ‘asynchronous’
[11:00:00.289]   - Field: ‘calls’
[11:00:00.289]   - Field: ‘globals’
[11:00:00.289]   - Field: ‘stdout’
[11:00:00.289]   - Field: ‘earlySignal’
[11:00:00.289]   - Field: ‘lazy’
[11:00:00.289]   - Field: ‘state’
[11:00:00.289] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:00.289] - Launch lazy future ...
[11:00:00.289] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:00.289] Packages needed by future strategies (n = 0): <none>
[11:00:00.290] {
[11:00:00.290]     {
[11:00:00.290]         {
[11:00:00.290]             ...future.startTime <- base::Sys.time()
[11:00:00.290]             {
[11:00:00.290]                 {
[11:00:00.290]                   {
[11:00:00.290]                     {
[11:00:00.290]                       base::local({
[11:00:00.290]                         has_future <- base::requireNamespace("future", 
[11:00:00.290]                           quietly = TRUE)
[11:00:00.290]                         if (has_future) {
[11:00:00.290]                           ns <- base::getNamespace("future")
[11:00:00.290]                           version <- ns[[".package"]][["version"]]
[11:00:00.290]                           if (is.null(version)) 
[11:00:00.290]                             version <- utils::packageVersion("future")
[11:00:00.290]                         }
[11:00:00.290]                         else {
[11:00:00.290]                           version <- NULL
[11:00:00.290]                         }
[11:00:00.290]                         if (!has_future || version < "1.8.0") {
[11:00:00.290]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:00.290]                             "", base::R.version$version.string), 
[11:00:00.290]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:00.290]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:00.290]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:00.290]                               "release", "version")], collapse = " "), 
[11:00:00.290]                             hostname = base::Sys.info()[["nodename"]])
[11:00:00.290]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:00.290]                             info)
[11:00:00.290]                           info <- base::paste(info, collapse = "; ")
[11:00:00.290]                           if (!has_future) {
[11:00:00.290]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:00.290]                               info)
[11:00:00.290]                           }
[11:00:00.290]                           else {
[11:00:00.290]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:00.290]                               info, version)
[11:00:00.290]                           }
[11:00:00.290]                           base::stop(msg)
[11:00:00.290]                         }
[11:00:00.290]                       })
[11:00:00.290]                     }
[11:00:00.290]                     base::local({
[11:00:00.290]                       for (pkg in "future.apply") {
[11:00:00.290]                         base::loadNamespace(pkg)
[11:00:00.290]                         base::library(pkg, character.only = TRUE)
[11:00:00.290]                       }
[11:00:00.290]                     })
[11:00:00.290]                   }
[11:00:00.290]                   ...future.strategy.old <- future::plan("list")
[11:00:00.290]                   options(future.plan = NULL)
[11:00:00.290]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.290]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:00.290]                 }
[11:00:00.290]                 ...future.workdir <- getwd()
[11:00:00.290]             }
[11:00:00.290]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:00.290]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:00.290]         }
[11:00:00.290]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:00.290]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:00.290]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:00.290]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:00.290]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:00.290]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:00.290]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:00.290]             base::names(...future.oldOptions))
[11:00:00.290]     }
[11:00:00.290]     if (FALSE) {
[11:00:00.290]     }
[11:00:00.290]     else {
[11:00:00.290]         if (TRUE) {
[11:00:00.290]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:00.290]                 open = "w")
[11:00:00.290]         }
[11:00:00.290]         else {
[11:00:00.290]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:00.290]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:00.290]         }
[11:00:00.290]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:00.290]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:00.290]             base::sink(type = "output", split = FALSE)
[11:00:00.290]             base::close(...future.stdout)
[11:00:00.290]         }, add = TRUE)
[11:00:00.290]     }
[11:00:00.290]     ...future.frame <- base::sys.nframe()
[11:00:00.290]     ...future.conditions <- base::list()
[11:00:00.290]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:00.290]     if (FALSE) {
[11:00:00.290]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:00.290]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:00.290]     }
[11:00:00.290]     ...future.result <- base::tryCatch({
[11:00:00.290]         base::withCallingHandlers({
[11:00:00.290]             ...future.value <- base::withVisible(base::local({
[11:00:00.290]                 do.call(function(...) {
[11:00:00.290]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.290]                   if (!identical(...future.globals.maxSize.org, 
[11:00:00.290]                     ...future.globals.maxSize)) {
[11:00:00.290]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.290]                     on.exit(options(oopts), add = TRUE)
[11:00:00.290]                   }
[11:00:00.290]                   {
[11:00:00.290]                     lapply(seq_along(...future.elements_ii), 
[11:00:00.290]                       FUN = function(jj) {
[11:00:00.290]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.290]                         ...future.FUN(...future.X_jj, ...)
[11:00:00.290]                       })
[11:00:00.290]                   }
[11:00:00.290]                 }, args = future.call.arguments)
[11:00:00.290]             }))
[11:00:00.290]             future::FutureResult(value = ...future.value$value, 
[11:00:00.290]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.290]                   ...future.rng), globalenv = if (FALSE) 
[11:00:00.290]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:00.290]                     ...future.globalenv.names))
[11:00:00.290]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:00.290]         }, condition = base::local({
[11:00:00.290]             c <- base::c
[11:00:00.290]             inherits <- base::inherits
[11:00:00.290]             invokeRestart <- base::invokeRestart
[11:00:00.290]             length <- base::length
[11:00:00.290]             list <- base::list
[11:00:00.290]             seq.int <- base::seq.int
[11:00:00.290]             signalCondition <- base::signalCondition
[11:00:00.290]             sys.calls <- base::sys.calls
[11:00:00.290]             `[[` <- base::`[[`
[11:00:00.290]             `+` <- base::`+`
[11:00:00.290]             `<<-` <- base::`<<-`
[11:00:00.290]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:00.290]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:00.290]                   3L)]
[11:00:00.290]             }
[11:00:00.290]             function(cond) {
[11:00:00.290]                 is_error <- inherits(cond, "error")
[11:00:00.290]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:00.290]                   NULL)
[11:00:00.290]                 if (is_error) {
[11:00:00.290]                   sessionInformation <- function() {
[11:00:00.290]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:00.290]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:00.290]                       search = base::search(), system = base::Sys.info())
[11:00:00.290]                   }
[11:00:00.290]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.290]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:00.290]                     cond$call), session = sessionInformation(), 
[11:00:00.290]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:00.290]                   signalCondition(cond)
[11:00:00.290]                 }
[11:00:00.290]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:00.290]                 "immediateCondition"))) {
[11:00:00.290]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:00.290]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.290]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:00.290]                   if (TRUE && !signal) {
[11:00:00.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.290]                     {
[11:00:00.290]                       inherits <- base::inherits
[11:00:00.290]                       invokeRestart <- base::invokeRestart
[11:00:00.290]                       is.null <- base::is.null
[11:00:00.290]                       muffled <- FALSE
[11:00:00.290]                       if (inherits(cond, "message")) {
[11:00:00.290]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.290]                         if (muffled) 
[11:00:00.290]                           invokeRestart("muffleMessage")
[11:00:00.290]                       }
[11:00:00.290]                       else if (inherits(cond, "warning")) {
[11:00:00.290]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.290]                         if (muffled) 
[11:00:00.290]                           invokeRestart("muffleWarning")
[11:00:00.290]                       }
[11:00:00.290]                       else if (inherits(cond, "condition")) {
[11:00:00.290]                         if (!is.null(pattern)) {
[11:00:00.290]                           computeRestarts <- base::computeRestarts
[11:00:00.290]                           grepl <- base::grepl
[11:00:00.290]                           restarts <- computeRestarts(cond)
[11:00:00.290]                           for (restart in restarts) {
[11:00:00.290]                             name <- restart$name
[11:00:00.290]                             if (is.null(name)) 
[11:00:00.290]                               next
[11:00:00.290]                             if (!grepl(pattern, name)) 
[11:00:00.290]                               next
[11:00:00.290]                             invokeRestart(restart)
[11:00:00.290]                             muffled <- TRUE
[11:00:00.290]                             break
[11:00:00.290]                           }
[11:00:00.290]                         }
[11:00:00.290]                       }
[11:00:00.290]                       invisible(muffled)
[11:00:00.290]                     }
[11:00:00.290]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.290]                   }
[11:00:00.290]                 }
[11:00:00.290]                 else {
[11:00:00.290]                   if (TRUE) {
[11:00:00.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.290]                     {
[11:00:00.290]                       inherits <- base::inherits
[11:00:00.290]                       invokeRestart <- base::invokeRestart
[11:00:00.290]                       is.null <- base::is.null
[11:00:00.290]                       muffled <- FALSE
[11:00:00.290]                       if (inherits(cond, "message")) {
[11:00:00.290]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.290]                         if (muffled) 
[11:00:00.290]                           invokeRestart("muffleMessage")
[11:00:00.290]                       }
[11:00:00.290]                       else if (inherits(cond, "warning")) {
[11:00:00.290]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.290]                         if (muffled) 
[11:00:00.290]                           invokeRestart("muffleWarning")
[11:00:00.290]                       }
[11:00:00.290]                       else if (inherits(cond, "condition")) {
[11:00:00.290]                         if (!is.null(pattern)) {
[11:00:00.290]                           computeRestarts <- base::computeRestarts
[11:00:00.290]                           grepl <- base::grepl
[11:00:00.290]                           restarts <- computeRestarts(cond)
[11:00:00.290]                           for (restart in restarts) {
[11:00:00.290]                             name <- restart$name
[11:00:00.290]                             if (is.null(name)) 
[11:00:00.290]                               next
[11:00:00.290]                             if (!grepl(pattern, name)) 
[11:00:00.290]                               next
[11:00:00.290]                             invokeRestart(restart)
[11:00:00.290]                             muffled <- TRUE
[11:00:00.290]                             break
[11:00:00.290]                           }
[11:00:00.290]                         }
[11:00:00.290]                       }
[11:00:00.290]                       invisible(muffled)
[11:00:00.290]                     }
[11:00:00.290]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.290]                   }
[11:00:00.290]                 }
[11:00:00.290]             }
[11:00:00.290]         }))
[11:00:00.290]     }, error = function(ex) {
[11:00:00.290]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:00.290]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.290]                 ...future.rng), started = ...future.startTime, 
[11:00:00.290]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:00.290]             version = "1.8"), class = "FutureResult")
[11:00:00.290]     }, finally = {
[11:00:00.290]         if (!identical(...future.workdir, getwd())) 
[11:00:00.290]             setwd(...future.workdir)
[11:00:00.290]         {
[11:00:00.290]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:00.290]                 ...future.oldOptions$nwarnings <- NULL
[11:00:00.290]             }
[11:00:00.290]             base::options(...future.oldOptions)
[11:00:00.290]             if (.Platform$OS.type == "windows") {
[11:00:00.290]                 old_names <- names(...future.oldEnvVars)
[11:00:00.290]                 envs <- base::Sys.getenv()
[11:00:00.290]                 names <- names(envs)
[11:00:00.290]                 common <- intersect(names, old_names)
[11:00:00.290]                 added <- setdiff(names, old_names)
[11:00:00.290]                 removed <- setdiff(old_names, names)
[11:00:00.290]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:00.290]                   envs[common]]
[11:00:00.290]                 NAMES <- toupper(changed)
[11:00:00.290]                 args <- list()
[11:00:00.290]                 for (kk in seq_along(NAMES)) {
[11:00:00.290]                   name <- changed[[kk]]
[11:00:00.290]                   NAME <- NAMES[[kk]]
[11:00:00.290]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.290]                     next
[11:00:00.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.290]                 }
[11:00:00.290]                 NAMES <- toupper(added)
[11:00:00.290]                 for (kk in seq_along(NAMES)) {
[11:00:00.290]                   name <- added[[kk]]
[11:00:00.290]                   NAME <- NAMES[[kk]]
[11:00:00.290]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.290]                     next
[11:00:00.290]                   args[[name]] <- ""
[11:00:00.290]                 }
[11:00:00.290]                 NAMES <- toupper(removed)
[11:00:00.290]                 for (kk in seq_along(NAMES)) {
[11:00:00.290]                   name <- removed[[kk]]
[11:00:00.290]                   NAME <- NAMES[[kk]]
[11:00:00.290]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.290]                     next
[11:00:00.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.290]                 }
[11:00:00.290]                 if (length(args) > 0) 
[11:00:00.290]                   base::do.call(base::Sys.setenv, args = args)
[11:00:00.290]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:00.290]             }
[11:00:00.290]             else {
[11:00:00.290]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:00.290]             }
[11:00:00.290]             {
[11:00:00.290]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:00.290]                   0L) {
[11:00:00.290]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:00.290]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:00.290]                   base::options(opts)
[11:00:00.290]                 }
[11:00:00.290]                 {
[11:00:00.290]                   {
[11:00:00.290]                     NULL
[11:00:00.290]                     RNGkind("Mersenne-Twister")
[11:00:00.290]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:00.290]                       inherits = FALSE)
[11:00:00.290]                   }
[11:00:00.290]                   options(future.plan = NULL)
[11:00:00.290]                   if (is.na(NA_character_)) 
[11:00:00.290]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.290]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:00.290]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:00.290]                     .init = FALSE)
[11:00:00.290]                 }
[11:00:00.290]             }
[11:00:00.290]         }
[11:00:00.290]     })
[11:00:00.290]     if (TRUE) {
[11:00:00.290]         base::sink(type = "output", split = FALSE)
[11:00:00.290]         if (TRUE) {
[11:00:00.290]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:00.290]         }
[11:00:00.290]         else {
[11:00:00.290]             ...future.result["stdout"] <- base::list(NULL)
[11:00:00.290]         }
[11:00:00.290]         base::close(...future.stdout)
[11:00:00.290]         ...future.stdout <- NULL
[11:00:00.290]     }
[11:00:00.290]     ...future.result$conditions <- ...future.conditions
[11:00:00.290]     ...future.result$finished <- base::Sys.time()
[11:00:00.290]     ...future.result
[11:00:00.290] }
[11:00:00.292] assign_globals() ...
[11:00:00.292] List of 11
[11:00:00.292]  $ ...future.FUN            :function (x, ...)  
[11:00:00.292]  $ x_FUN                    :function (x)  
[11:00:00.292]  $ times                    : int 0
[11:00:00.292]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.292]  $ stop_if_not              :function (...)  
[11:00:00.292]  $ dim                      : NULL
[11:00:00.292]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:00.292]  $ future.call.arguments    : list()
[11:00:00.292]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.292]  $ ...future.elements_ii    :List of 10
[11:00:00.292]   ..$ : int 1
[11:00:00.292]   ..$ : int 2
[11:00:00.292]   ..$ : int 3
[11:00:00.292]   ..$ : int 4
[11:00:00.292]   ..$ : int 5
[11:00:00.292]   ..$ : int 6
[11:00:00.292]   ..$ : int 7
[11:00:00.292]   ..$ : int 8
[11:00:00.292]   ..$ : int 9
[11:00:00.292]   ..$ : int 10
[11:00:00.292]  $ ...future.seeds_ii       : NULL
[11:00:00.292]  $ ...future.globals.maxSize: NULL
[11:00:00.292]  - attr(*, "where")=List of 11
[11:00:00.292]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:00.292]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:00.292]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:00.292]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:00.292]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:00.292]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:00.292]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:00.292]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:00.292]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:00.292]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:00.292]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:00.292]  - attr(*, "resolved")= logi FALSE
[11:00:00.292]  - attr(*, "total_size")= num 23490
[11:00:00.292]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.292]  - attr(*, "already-done")= logi TRUE
[11:00:00.301] - copied ‘...future.FUN’ to environment
[11:00:00.301] - reassign environment for ‘x_FUN’
[11:00:00.301] - copied ‘x_FUN’ to environment
[11:00:00.301] - copied ‘times’ to environment
[11:00:00.301] - copied ‘stopf’ to environment
[11:00:00.301] - copied ‘stop_if_not’ to environment
[11:00:00.301] - copied ‘dim’ to environment
[11:00:00.301] - copied ‘valid_types’ to environment
[11:00:00.301] - copied ‘future.call.arguments’ to environment
[11:00:00.301] - copied ‘...future.elements_ii’ to environment
[11:00:00.301] - copied ‘...future.seeds_ii’ to environment
[11:00:00.301] - copied ‘...future.globals.maxSize’ to environment
[11:00:00.302] assign_globals() ... done
[11:00:00.302] plan(): Setting new future strategy stack:
[11:00:00.302] List of future strategies:
[11:00:00.302] 1. sequential:
[11:00:00.302]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.302]    - tweaked: FALSE
[11:00:00.302]    - call: NULL
[11:00:00.302] plan(): nbrOfWorkers() = 1
[11:00:00.303] plan(): Setting new future strategy stack:
[11:00:00.303] List of future strategies:
[11:00:00.303] 1. sequential:
[11:00:00.303]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.303]    - tweaked: FALSE
[11:00:00.303]    - call: plan(strategy)
[11:00:00.304] plan(): nbrOfWorkers() = 1
[11:00:00.304] SequentialFuture started (and completed)
[11:00:00.304] - Launch lazy future ... done
[11:00:00.304] run() for ‘SequentialFuture’ ... done
[11:00:00.304] Created future:
[11:00:00.304] SequentialFuture:
[11:00:00.304] Label: ‘future_vapply-1’
[11:00:00.304] Expression:
[11:00:00.304] {
[11:00:00.304]     do.call(function(...) {
[11:00:00.304]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.304]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.304]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.304]             on.exit(options(oopts), add = TRUE)
[11:00:00.304]         }
[11:00:00.304]         {
[11:00:00.304]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.304]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.304]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.304]             })
[11:00:00.304]         }
[11:00:00.304]     }, args = future.call.arguments)
[11:00:00.304] }
[11:00:00.304] Lazy evaluation: FALSE
[11:00:00.304] Asynchronous evaluation: FALSE
[11:00:00.304] Local evaluation: TRUE
[11:00:00.304] Environment: R_GlobalEnv
[11:00:00.304] Capture standard output: TRUE
[11:00:00.304] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:00.304] Globals: 11 objects totaling 13.07 KiB (function ‘...future.FUN’ of 4.50 KiB, function ‘x_FUN’ of 295 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:00.304] Packages: 1 packages (‘future.apply’)
[11:00:00.304] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:00.304] Resolved: TRUE
[11:00:00.304] Value: 111 bytes of class ‘list’
[11:00:00.304] Early signaling: FALSE
[11:00:00.304] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:00.304] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.305] Chunk #1 of 1 ... DONE
[11:00:00.305] Launching 1 futures (chunks) ... DONE
[11:00:00.305] Resolving 1 futures (chunks) ...
[11:00:00.305] resolve() on list ...
[11:00:00.305]  recursive: 0
[11:00:00.305]  length: 1
[11:00:00.305] 
[11:00:00.305] resolved() for ‘SequentialFuture’ ...
[11:00:00.306] - state: ‘finished’
[11:00:00.306] - run: TRUE
[11:00:00.306] - result: ‘FutureResult’
[11:00:00.306] resolved() for ‘SequentialFuture’ ... done
[11:00:00.306] Future #1
[11:00:00.306] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:00.306] - nx: 1
[11:00:00.306] - relay: TRUE
[11:00:00.306] - stdout: TRUE
[11:00:00.306] - signal: TRUE
[11:00:00.306] - resignal: FALSE
[11:00:00.306] - force: TRUE
[11:00:00.307] - relayed: [n=1] FALSE
[11:00:00.307] - queued futures: [n=1] FALSE
[11:00:00.307]  - until=1
[11:00:00.307]  - relaying element #1
[11:00:00.307] - relayed: [n=1] TRUE
[11:00:00.308] - queued futures: [n=1] TRUE
[11:00:00.308] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:00.308]  length: 0 (resolved future 1)
[11:00:00.308] Relaying remaining futures
[11:00:00.308] signalConditionsASAP(NULL, pos=0) ...
[11:00:00.308] - nx: 1
[11:00:00.308] - relay: TRUE
[11:00:00.308] - stdout: TRUE
[11:00:00.308] - signal: TRUE
[11:00:00.308] - resignal: FALSE
[11:00:00.309] - force: TRUE
[11:00:00.309] - relayed: [n=1] TRUE
[11:00:00.309] - queued futures: [n=1] TRUE
 - flush all
[11:00:00.309] - relayed: [n=1] TRUE
[11:00:00.309] - queued futures: [n=1] TRUE
[11:00:00.309] signalConditionsASAP(NULL, pos=0) ... done
[11:00:00.309] resolve() on list ... DONE
[11:00:00.309]  - Number of value chunks collected: 1
[11:00:00.309] Resolving 1 futures (chunks) ... DONE
[11:00:00.309] Reducing values from 1 chunks ...
[11:00:00.309]  - Number of values collected after concatenation: 10
[11:00:00.309]  - Number of values expected: 10
[11:00:00.310] Reducing values from 1 chunks ... DONE
[11:00:00.310] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[11:00:00.310] future_lapply() ...
[11:00:00.312] Number of chunks: 1
[11:00:00.312] getGlobalsAndPackagesXApply() ...
[11:00:00.312]  - future.globals: TRUE
[11:00:00.312] getGlobalsAndPackages() ...
[11:00:00.312] Searching for globals...
[11:00:00.315] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[11:00:00.316] Searching for globals ... DONE
[11:00:00.316] Resolving globals: FALSE
[11:00:00.316] The total size of the 7 globals is 12.75 KiB (13056 bytes)
[11:00:00.317] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.50 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:00.317] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.317] - packages: [1] ‘future.apply’
[11:00:00.317] getGlobalsAndPackages() ... DONE
[11:00:00.317]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.317]  - needed namespaces: [n=1] ‘future.apply’
[11:00:00.317] Finding globals ... DONE
[11:00:00.317]  - use_args: TRUE
[11:00:00.317]  - Getting '...' globals ...
[11:00:00.318] resolve() on list ...
[11:00:00.318]  recursive: 0
[11:00:00.318]  length: 1
[11:00:00.318]  elements: ‘...’
[11:00:00.318]  length: 0 (resolved future 1)
[11:00:00.318] resolve() on list ... DONE
[11:00:00.318]    - '...' content: [n=0] 
[11:00:00.318] List of 1
[11:00:00.318]  $ ...: list()
[11:00:00.318]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.318]  - attr(*, "where")=List of 1
[11:00:00.318]   ..$ ...:<environment: 0x55bbaba0c2b0> 
[11:00:00.318]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.318]  - attr(*, "resolved")= logi TRUE
[11:00:00.318]  - attr(*, "total_size")= num NA
[11:00:00.320]  - Getting '...' globals ... DONE
[11:00:00.321] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:00.321] List of 8
[11:00:00.321]  $ ...future.FUN:function (x, ...)  
[11:00:00.321]  $ x_FUN        :function (x)  
[11:00:00.321]  $ times        : int 0
[11:00:00.321]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.321]  $ stop_if_not  :function (...)  
[11:00:00.321]  $ dim          : NULL
[11:00:00.321]  $ valid_types  : chr [1:2] "logical" "integer"
[11:00:00.321]  $ ...          : list()
[11:00:00.321]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.321]  - attr(*, "where")=List of 8
[11:00:00.321]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:00.321]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:00.321]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:00.321]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:00.321]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:00.321]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:00.321]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:00.321]   ..$ ...          :<environment: 0x55bbaba0c2b0> 
[11:00:00.321]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.321]  - attr(*, "resolved")= logi FALSE
[11:00:00.321]  - attr(*, "total_size")= num 23453
[11:00:00.325] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:00.326] getGlobalsAndPackagesXApply() ... DONE
[11:00:00.326] Number of futures (= number of chunks): 1
[11:00:00.326] Launching 1 futures (chunks) ...
[11:00:00.326] Chunk #1 of 1 ...
[11:00:00.326]  - Finding globals in 'X' for chunk #1 ...
[11:00:00.326] getGlobalsAndPackages() ...
[11:00:00.326] Searching for globals...
[11:00:00.326] 
[11:00:00.326] Searching for globals ... DONE
[11:00:00.327] - globals: [0] <none>
[11:00:00.327] getGlobalsAndPackages() ... DONE
[11:00:00.327]    + additional globals found: [n=0] 
[11:00:00.327]    + additional namespaces needed: [n=0] 
[11:00:00.328]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:00.328]  - seeds: <none>
[11:00:00.328]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.328] getGlobalsAndPackages() ...
[11:00:00.328] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.328] Resolving globals: FALSE
[11:00:00.328] Tweak future expression to call with '...' arguments ...
[11:00:00.328] {
[11:00:00.328]     do.call(function(...) {
[11:00:00.328]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.328]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.328]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.328]             on.exit(options(oopts), add = TRUE)
[11:00:00.328]         }
[11:00:00.328]         {
[11:00:00.328]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.328]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.328]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.328]             })
[11:00:00.328]         }
[11:00:00.328]     }, args = future.call.arguments)
[11:00:00.328] }
[11:00:00.328] Tweak future expression to call with '...' arguments ... DONE
[11:00:00.329] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.329] - packages: [1] ‘future.apply’
[11:00:00.329] getGlobalsAndPackages() ... DONE
[11:00:00.329] run() for ‘Future’ ...
[11:00:00.329] - state: ‘created’
[11:00:00.330] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:00.330] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.330] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:00.330]   - Field: ‘label’
[11:00:00.330]   - Field: ‘local’
[11:00:00.330]   - Field: ‘owner’
[11:00:00.330]   - Field: ‘envir’
[11:00:00.330]   - Field: ‘packages’
[11:00:00.330]   - Field: ‘gc’
[11:00:00.330]   - Field: ‘conditions’
[11:00:00.331]   - Field: ‘expr’
[11:00:00.331]   - Field: ‘uuid’
[11:00:00.331]   - Field: ‘seed’
[11:00:00.331]   - Field: ‘version’
[11:00:00.331]   - Field: ‘result’
[11:00:00.331]   - Field: ‘asynchronous’
[11:00:00.331]   - Field: ‘calls’
[11:00:00.331]   - Field: ‘globals’
[11:00:00.331]   - Field: ‘stdout’
[11:00:00.331]   - Field: ‘earlySignal’
[11:00:00.331]   - Field: ‘lazy’
[11:00:00.331]   - Field: ‘state’
[11:00:00.332] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:00.332] - Launch lazy future ...
[11:00:00.332] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:00.332] Packages needed by future strategies (n = 0): <none>
[11:00:00.332] {
[11:00:00.332]     {
[11:00:00.332]         {
[11:00:00.332]             ...future.startTime <- base::Sys.time()
[11:00:00.332]             {
[11:00:00.332]                 {
[11:00:00.332]                   {
[11:00:00.332]                     {
[11:00:00.332]                       base::local({
[11:00:00.332]                         has_future <- base::requireNamespace("future", 
[11:00:00.332]                           quietly = TRUE)
[11:00:00.332]                         if (has_future) {
[11:00:00.332]                           ns <- base::getNamespace("future")
[11:00:00.332]                           version <- ns[[".package"]][["version"]]
[11:00:00.332]                           if (is.null(version)) 
[11:00:00.332]                             version <- utils::packageVersion("future")
[11:00:00.332]                         }
[11:00:00.332]                         else {
[11:00:00.332]                           version <- NULL
[11:00:00.332]                         }
[11:00:00.332]                         if (!has_future || version < "1.8.0") {
[11:00:00.332]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:00.332]                             "", base::R.version$version.string), 
[11:00:00.332]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:00.332]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:00.332]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:00.332]                               "release", "version")], collapse = " "), 
[11:00:00.332]                             hostname = base::Sys.info()[["nodename"]])
[11:00:00.332]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:00.332]                             info)
[11:00:00.332]                           info <- base::paste(info, collapse = "; ")
[11:00:00.332]                           if (!has_future) {
[11:00:00.332]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:00.332]                               info)
[11:00:00.332]                           }
[11:00:00.332]                           else {
[11:00:00.332]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:00.332]                               info, version)
[11:00:00.332]                           }
[11:00:00.332]                           base::stop(msg)
[11:00:00.332]                         }
[11:00:00.332]                       })
[11:00:00.332]                     }
[11:00:00.332]                     base::local({
[11:00:00.332]                       for (pkg in "future.apply") {
[11:00:00.332]                         base::loadNamespace(pkg)
[11:00:00.332]                         base::library(pkg, character.only = TRUE)
[11:00:00.332]                       }
[11:00:00.332]                     })
[11:00:00.332]                   }
[11:00:00.332]                   ...future.strategy.old <- future::plan("list")
[11:00:00.332]                   options(future.plan = NULL)
[11:00:00.332]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.332]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:00.332]                 }
[11:00:00.332]                 ...future.workdir <- getwd()
[11:00:00.332]             }
[11:00:00.332]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:00.332]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:00.332]         }
[11:00:00.332]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:00.332]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:00.332]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:00.332]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:00.332]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:00.332]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:00.332]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:00.332]             base::names(...future.oldOptions))
[11:00:00.332]     }
[11:00:00.332]     if (FALSE) {
[11:00:00.332]     }
[11:00:00.332]     else {
[11:00:00.332]         if (TRUE) {
[11:00:00.332]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:00.332]                 open = "w")
[11:00:00.332]         }
[11:00:00.332]         else {
[11:00:00.332]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:00.332]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:00.332]         }
[11:00:00.332]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:00.332]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:00.332]             base::sink(type = "output", split = FALSE)
[11:00:00.332]             base::close(...future.stdout)
[11:00:00.332]         }, add = TRUE)
[11:00:00.332]     }
[11:00:00.332]     ...future.frame <- base::sys.nframe()
[11:00:00.332]     ...future.conditions <- base::list()
[11:00:00.332]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:00.332]     if (FALSE) {
[11:00:00.332]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:00.332]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:00.332]     }
[11:00:00.332]     ...future.result <- base::tryCatch({
[11:00:00.332]         base::withCallingHandlers({
[11:00:00.332]             ...future.value <- base::withVisible(base::local({
[11:00:00.332]                 do.call(function(...) {
[11:00:00.332]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.332]                   if (!identical(...future.globals.maxSize.org, 
[11:00:00.332]                     ...future.globals.maxSize)) {
[11:00:00.332]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.332]                     on.exit(options(oopts), add = TRUE)
[11:00:00.332]                   }
[11:00:00.332]                   {
[11:00:00.332]                     lapply(seq_along(...future.elements_ii), 
[11:00:00.332]                       FUN = function(jj) {
[11:00:00.332]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.332]                         ...future.FUN(...future.X_jj, ...)
[11:00:00.332]                       })
[11:00:00.332]                   }
[11:00:00.332]                 }, args = future.call.arguments)
[11:00:00.332]             }))
[11:00:00.332]             future::FutureResult(value = ...future.value$value, 
[11:00:00.332]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.332]                   ...future.rng), globalenv = if (FALSE) 
[11:00:00.332]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:00.332]                     ...future.globalenv.names))
[11:00:00.332]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:00.332]         }, condition = base::local({
[11:00:00.332]             c <- base::c
[11:00:00.332]             inherits <- base::inherits
[11:00:00.332]             invokeRestart <- base::invokeRestart
[11:00:00.332]             length <- base::length
[11:00:00.332]             list <- base::list
[11:00:00.332]             seq.int <- base::seq.int
[11:00:00.332]             signalCondition <- base::signalCondition
[11:00:00.332]             sys.calls <- base::sys.calls
[11:00:00.332]             `[[` <- base::`[[`
[11:00:00.332]             `+` <- base::`+`
[11:00:00.332]             `<<-` <- base::`<<-`
[11:00:00.332]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:00.332]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:00.332]                   3L)]
[11:00:00.332]             }
[11:00:00.332]             function(cond) {
[11:00:00.332]                 is_error <- inherits(cond, "error")
[11:00:00.332]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:00.332]                   NULL)
[11:00:00.332]                 if (is_error) {
[11:00:00.332]                   sessionInformation <- function() {
[11:00:00.332]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:00.332]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:00.332]                       search = base::search(), system = base::Sys.info())
[11:00:00.332]                   }
[11:00:00.332]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.332]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:00.332]                     cond$call), session = sessionInformation(), 
[11:00:00.332]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:00.332]                   signalCondition(cond)
[11:00:00.332]                 }
[11:00:00.332]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:00.332]                 "immediateCondition"))) {
[11:00:00.332]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:00.332]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.332]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:00.332]                   if (TRUE && !signal) {
[11:00:00.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.332]                     {
[11:00:00.332]                       inherits <- base::inherits
[11:00:00.332]                       invokeRestart <- base::invokeRestart
[11:00:00.332]                       is.null <- base::is.null
[11:00:00.332]                       muffled <- FALSE
[11:00:00.332]                       if (inherits(cond, "message")) {
[11:00:00.332]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.332]                         if (muffled) 
[11:00:00.332]                           invokeRestart("muffleMessage")
[11:00:00.332]                       }
[11:00:00.332]                       else if (inherits(cond, "warning")) {
[11:00:00.332]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.332]                         if (muffled) 
[11:00:00.332]                           invokeRestart("muffleWarning")
[11:00:00.332]                       }
[11:00:00.332]                       else if (inherits(cond, "condition")) {
[11:00:00.332]                         if (!is.null(pattern)) {
[11:00:00.332]                           computeRestarts <- base::computeRestarts
[11:00:00.332]                           grepl <- base::grepl
[11:00:00.332]                           restarts <- computeRestarts(cond)
[11:00:00.332]                           for (restart in restarts) {
[11:00:00.332]                             name <- restart$name
[11:00:00.332]                             if (is.null(name)) 
[11:00:00.332]                               next
[11:00:00.332]                             if (!grepl(pattern, name)) 
[11:00:00.332]                               next
[11:00:00.332]                             invokeRestart(restart)
[11:00:00.332]                             muffled <- TRUE
[11:00:00.332]                             break
[11:00:00.332]                           }
[11:00:00.332]                         }
[11:00:00.332]                       }
[11:00:00.332]                       invisible(muffled)
[11:00:00.332]                     }
[11:00:00.332]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.332]                   }
[11:00:00.332]                 }
[11:00:00.332]                 else {
[11:00:00.332]                   if (TRUE) {
[11:00:00.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.332]                     {
[11:00:00.332]                       inherits <- base::inherits
[11:00:00.332]                       invokeRestart <- base::invokeRestart
[11:00:00.332]                       is.null <- base::is.null
[11:00:00.332]                       muffled <- FALSE
[11:00:00.332]                       if (inherits(cond, "message")) {
[11:00:00.332]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.332]                         if (muffled) 
[11:00:00.332]                           invokeRestart("muffleMessage")
[11:00:00.332]                       }
[11:00:00.332]                       else if (inherits(cond, "warning")) {
[11:00:00.332]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.332]                         if (muffled) 
[11:00:00.332]                           invokeRestart("muffleWarning")
[11:00:00.332]                       }
[11:00:00.332]                       else if (inherits(cond, "condition")) {
[11:00:00.332]                         if (!is.null(pattern)) {
[11:00:00.332]                           computeRestarts <- base::computeRestarts
[11:00:00.332]                           grepl <- base::grepl
[11:00:00.332]                           restarts <- computeRestarts(cond)
[11:00:00.332]                           for (restart in restarts) {
[11:00:00.332]                             name <- restart$name
[11:00:00.332]                             if (is.null(name)) 
[11:00:00.332]                               next
[11:00:00.332]                             if (!grepl(pattern, name)) 
[11:00:00.332]                               next
[11:00:00.332]                             invokeRestart(restart)
[11:00:00.332]                             muffled <- TRUE
[11:00:00.332]                             break
[11:00:00.332]                           }
[11:00:00.332]                         }
[11:00:00.332]                       }
[11:00:00.332]                       invisible(muffled)
[11:00:00.332]                     }
[11:00:00.332]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.332]                   }
[11:00:00.332]                 }
[11:00:00.332]             }
[11:00:00.332]         }))
[11:00:00.332]     }, error = function(ex) {
[11:00:00.332]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:00.332]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.332]                 ...future.rng), started = ...future.startTime, 
[11:00:00.332]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:00.332]             version = "1.8"), class = "FutureResult")
[11:00:00.332]     }, finally = {
[11:00:00.332]         if (!identical(...future.workdir, getwd())) 
[11:00:00.332]             setwd(...future.workdir)
[11:00:00.332]         {
[11:00:00.332]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:00.332]                 ...future.oldOptions$nwarnings <- NULL
[11:00:00.332]             }
[11:00:00.332]             base::options(...future.oldOptions)
[11:00:00.332]             if (.Platform$OS.type == "windows") {
[11:00:00.332]                 old_names <- names(...future.oldEnvVars)
[11:00:00.332]                 envs <- base::Sys.getenv()
[11:00:00.332]                 names <- names(envs)
[11:00:00.332]                 common <- intersect(names, old_names)
[11:00:00.332]                 added <- setdiff(names, old_names)
[11:00:00.332]                 removed <- setdiff(old_names, names)
[11:00:00.332]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:00.332]                   envs[common]]
[11:00:00.332]                 NAMES <- toupper(changed)
[11:00:00.332]                 args <- list()
[11:00:00.332]                 for (kk in seq_along(NAMES)) {
[11:00:00.332]                   name <- changed[[kk]]
[11:00:00.332]                   NAME <- NAMES[[kk]]
[11:00:00.332]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.332]                     next
[11:00:00.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.332]                 }
[11:00:00.332]                 NAMES <- toupper(added)
[11:00:00.332]                 for (kk in seq_along(NAMES)) {
[11:00:00.332]                   name <- added[[kk]]
[11:00:00.332]                   NAME <- NAMES[[kk]]
[11:00:00.332]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.332]                     next
[11:00:00.332]                   args[[name]] <- ""
[11:00:00.332]                 }
[11:00:00.332]                 NAMES <- toupper(removed)
[11:00:00.332]                 for (kk in seq_along(NAMES)) {
[11:00:00.332]                   name <- removed[[kk]]
[11:00:00.332]                   NAME <- NAMES[[kk]]
[11:00:00.332]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.332]                     next
[11:00:00.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.332]                 }
[11:00:00.332]                 if (length(args) > 0) 
[11:00:00.332]                   base::do.call(base::Sys.setenv, args = args)
[11:00:00.332]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:00.332]             }
[11:00:00.332]             else {
[11:00:00.332]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:00.332]             }
[11:00:00.332]             {
[11:00:00.332]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:00.332]                   0L) {
[11:00:00.332]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:00.332]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:00.332]                   base::options(opts)
[11:00:00.332]                 }
[11:00:00.332]                 {
[11:00:00.332]                   {
[11:00:00.332]                     NULL
[11:00:00.332]                     RNGkind("Mersenne-Twister")
[11:00:00.332]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:00.332]                       inherits = FALSE)
[11:00:00.332]                   }
[11:00:00.332]                   options(future.plan = NULL)
[11:00:00.332]                   if (is.na(NA_character_)) 
[11:00:00.332]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.332]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:00.332]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:00.332]                     .init = FALSE)
[11:00:00.332]                 }
[11:00:00.332]             }
[11:00:00.332]         }
[11:00:00.332]     })
[11:00:00.332]     if (TRUE) {
[11:00:00.332]         base::sink(type = "output", split = FALSE)
[11:00:00.332]         if (TRUE) {
[11:00:00.332]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:00.332]         }
[11:00:00.332]         else {
[11:00:00.332]             ...future.result["stdout"] <- base::list(NULL)
[11:00:00.332]         }
[11:00:00.332]         base::close(...future.stdout)
[11:00:00.332]         ...future.stdout <- NULL
[11:00:00.332]     }
[11:00:00.332]     ...future.result$conditions <- ...future.conditions
[11:00:00.332]     ...future.result$finished <- base::Sys.time()
[11:00:00.332]     ...future.result
[11:00:00.332] }
[11:00:00.334] assign_globals() ...
[11:00:00.334] List of 11
[11:00:00.334]  $ ...future.FUN            :function (x, ...)  
[11:00:00.334]  $ x_FUN                    :function (x)  
[11:00:00.334]  $ times                    : int 0
[11:00:00.334]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.334]  $ stop_if_not              :function (...)  
[11:00:00.334]  $ dim                      : NULL
[11:00:00.334]  $ valid_types              : chr [1:2] "logical" "integer"
[11:00:00.334]  $ future.call.arguments    : list()
[11:00:00.334]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.334]  $ ...future.elements_ii    :List of 10
[11:00:00.334]   ..$ : int 1
[11:00:00.334]   ..$ : int 2
[11:00:00.334]   ..$ : int 3
[11:00:00.334]   ..$ : int 4
[11:00:00.334]   ..$ : int 5
[11:00:00.334]   ..$ : int 6
[11:00:00.334]   ..$ : int 7
[11:00:00.334]   ..$ : int 8
[11:00:00.334]   ..$ : int 9
[11:00:00.334]   ..$ : int 10
[11:00:00.334]  $ ...future.seeds_ii       : NULL
[11:00:00.334]  $ ...future.globals.maxSize: NULL
[11:00:00.334]  - attr(*, "where")=List of 11
[11:00:00.334]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:00.334]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:00.334]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:00.334]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:00.334]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:00.334]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:00.334]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:00.334]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:00.334]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:00.334]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:00.334]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:00.334]  - attr(*, "resolved")= logi FALSE
[11:00:00.334]  - attr(*, "total_size")= num 23453
[11:00:00.334]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.334]  - attr(*, "already-done")= logi TRUE
[11:00:00.343] - copied ‘...future.FUN’ to environment
[11:00:00.343] - reassign environment for ‘x_FUN’
[11:00:00.343] - copied ‘x_FUN’ to environment
[11:00:00.343] - copied ‘times’ to environment
[11:00:00.343] - copied ‘stopf’ to environment
[11:00:00.343] - copied ‘stop_if_not’ to environment
[11:00:00.343] - copied ‘dim’ to environment
[11:00:00.343] - copied ‘valid_types’ to environment
[11:00:00.344] - copied ‘future.call.arguments’ to environment
[11:00:00.344] - copied ‘...future.elements_ii’ to environment
[11:00:00.344] - copied ‘...future.seeds_ii’ to environment
[11:00:00.344] - copied ‘...future.globals.maxSize’ to environment
[11:00:00.344] assign_globals() ... done
[11:00:00.344] plan(): Setting new future strategy stack:
[11:00:00.344] List of future strategies:
[11:00:00.344] 1. sequential:
[11:00:00.344]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.344]    - tweaked: FALSE
[11:00:00.344]    - call: NULL
[11:00:00.345] plan(): nbrOfWorkers() = 1
[11:00:00.345] plan(): Setting new future strategy stack:
[11:00:00.345] List of future strategies:
[11:00:00.345] 1. sequential:
[11:00:00.345]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.345]    - tweaked: FALSE
[11:00:00.345]    - call: plan(strategy)
[11:00:00.346] plan(): nbrOfWorkers() = 1
[11:00:00.346] SequentialFuture started (and completed)
[11:00:00.346] - Launch lazy future ... done
[11:00:00.346] run() for ‘SequentialFuture’ ... done
[11:00:00.346] Created future:
[11:00:00.346] SequentialFuture:
[11:00:00.346] Label: ‘future_vapply-1’
[11:00:00.346] Expression:
[11:00:00.346] {
[11:00:00.346]     do.call(function(...) {
[11:00:00.346]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.346]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.346]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.346]             on.exit(options(oopts), add = TRUE)
[11:00:00.346]         }
[11:00:00.346]         {
[11:00:00.346]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.346]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.346]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.346]             })
[11:00:00.346]         }
[11:00:00.346]     }, args = future.call.arguments)
[11:00:00.346] }
[11:00:00.346] Lazy evaluation: FALSE
[11:00:00.346] Asynchronous evaluation: FALSE
[11:00:00.346] Local evaluation: TRUE
[11:00:00.346] Environment: R_GlobalEnv
[11:00:00.346] Capture standard output: TRUE
[11:00:00.346] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:00.346] Globals: 11 objects totaling 13.04 KiB (function ‘...future.FUN’ of 4.49 KiB, function ‘x_FUN’ of 296 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:00.346] Packages: 1 packages (‘future.apply’)
[11:00:00.346] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:00.346] Resolved: TRUE
[11:00:00.346] Value: 111 bytes of class ‘list’
[11:00:00.346] Early signaling: FALSE
[11:00:00.346] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:00.346] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.347] Chunk #1 of 1 ... DONE
[11:00:00.347] Launching 1 futures (chunks) ... DONE
[11:00:00.347] Resolving 1 futures (chunks) ...
[11:00:00.348] resolve() on list ...
[11:00:00.348]  recursive: 0
[11:00:00.348]  length: 1
[11:00:00.348] 
[11:00:00.348] resolved() for ‘SequentialFuture’ ...
[11:00:00.348] - state: ‘finished’
[11:00:00.348] - run: TRUE
[11:00:00.349] - result: ‘FutureResult’
[11:00:00.349] resolved() for ‘SequentialFuture’ ... done
[11:00:00.349] Future #1
[11:00:00.349] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:00.349] - nx: 1
[11:00:00.349] - relay: TRUE
[11:00:00.350] - stdout: TRUE
[11:00:00.350] - signal: TRUE
[11:00:00.350] - resignal: FALSE
[11:00:00.350] - force: TRUE
[11:00:00.350] - relayed: [n=1] FALSE
[11:00:00.350] - queued futures: [n=1] FALSE
[11:00:00.350]  - until=1
[11:00:00.350]  - relaying element #1
[11:00:00.350] - relayed: [n=1] TRUE
[11:00:00.350] - queued futures: [n=1] TRUE
[11:00:00.350] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:00.350]  length: 0 (resolved future 1)
[11:00:00.351] Relaying remaining futures
[11:00:00.351] signalConditionsASAP(NULL, pos=0) ...
[11:00:00.351] - nx: 1
[11:00:00.351] - relay: TRUE
[11:00:00.351] - stdout: TRUE
[11:00:00.351] - signal: TRUE
[11:00:00.351] - resignal: FALSE
[11:00:00.351] - force: TRUE
[11:00:00.351] - relayed: [n=1] TRUE
[11:00:00.351] - queued futures: [n=1] TRUE
 - flush all
[11:00:00.351] - relayed: [n=1] TRUE
[11:00:00.351] - queued futures: [n=1] TRUE
[11:00:00.351] signalConditionsASAP(NULL, pos=0) ... done
[11:00:00.352] resolve() on list ... DONE
[11:00:00.352]  - Number of value chunks collected: 1
[11:00:00.352] Resolving 1 futures (chunks) ... DONE
[11:00:00.352] Reducing values from 1 chunks ...
[11:00:00.352]  - Number of values collected after concatenation: 10
[11:00:00.352]  - Number of values expected: 10
[11:00:00.352] Reducing values from 1 chunks ... DONE
[11:00:00.352] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[11:00:00.353] future_lapply() ...
[11:00:00.354] Number of chunks: 1
[11:00:00.354] getGlobalsAndPackagesXApply() ...
[11:00:00.355]  - future.globals: TRUE
[11:00:00.355] getGlobalsAndPackages() ...
[11:00:00.355] Searching for globals...
[11:00:00.357] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[11:00:00.357] Searching for globals ... DONE
[11:00:00.358] Resolving globals: FALSE
[11:00:00.358] The total size of the 7 globals is 12.08 KiB (12367 bytes)
[11:00:00.359] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.07 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:00.359] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.359] - packages: [1] ‘future.apply’
[11:00:00.359] getGlobalsAndPackages() ... DONE
[11:00:00.359]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.359]  - needed namespaces: [n=1] ‘future.apply’
[11:00:00.359] Finding globals ... DONE
[11:00:00.359]  - use_args: TRUE
[11:00:00.359]  - Getting '...' globals ...
[11:00:00.360] resolve() on list ...
[11:00:00.360]  recursive: 0
[11:00:00.360]  length: 1
[11:00:00.360]  elements: ‘...’
[11:00:00.360]  length: 0 (resolved future 1)
[11:00:00.360] resolve() on list ... DONE
[11:00:00.360]    - '...' content: [n=0] 
[11:00:00.360] List of 1
[11:00:00.360]  $ ...: list()
[11:00:00.360]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.360]  - attr(*, "where")=List of 1
[11:00:00.360]   ..$ ...:<environment: 0x55bbab0f44f0> 
[11:00:00.360]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.360]  - attr(*, "resolved")= logi TRUE
[11:00:00.360]  - attr(*, "total_size")= num NA
[11:00:00.362]  - Getting '...' globals ... DONE
[11:00:00.362] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:00.363] List of 8
[11:00:00.363]  $ ...future.FUN:function (x, ...)  
[11:00:00.363]  $ x_FUN        :function (x)  
[11:00:00.363]  $ times        : int 1
[11:00:00.363]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.363]  $ stop_if_not  :function (...)  
[11:00:00.363]  $ dim          : NULL
[11:00:00.363]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:00.363]  $ ...          : list()
[11:00:00.363]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.363]  - attr(*, "where")=List of 8
[11:00:00.363]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:00.363]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:00.363]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:00.363]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:00.363]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:00.363]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:00.363]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:00.363]   ..$ ...          :<environment: 0x55bbab0f44f0> 
[11:00:00.363]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.363]  - attr(*, "resolved")= logi FALSE
[11:00:00.363]  - attr(*, "total_size")= num 22322
[11:00:00.367] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:00.367] getGlobalsAndPackagesXApply() ... DONE
[11:00:00.368] Number of futures (= number of chunks): 1
[11:00:00.368] Launching 1 futures (chunks) ...
[11:00:00.369] Chunk #1 of 1 ...
[11:00:00.369]  - Finding globals in 'X' for chunk #1 ...
[11:00:00.369] getGlobalsAndPackages() ...
[11:00:00.369] Searching for globals...
[11:00:00.369] 
[11:00:00.369] Searching for globals ... DONE
[11:00:00.369] - globals: [0] <none>
[11:00:00.369] getGlobalsAndPackages() ... DONE
[11:00:00.369]    + additional globals found: [n=0] 
[11:00:00.369]    + additional namespaces needed: [n=0] 
[11:00:00.370]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:00.370]  - seeds: <none>
[11:00:00.370]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.370] getGlobalsAndPackages() ...
[11:00:00.370] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.370] Resolving globals: FALSE
[11:00:00.370] Tweak future expression to call with '...' arguments ...
[11:00:00.370] {
[11:00:00.370]     do.call(function(...) {
[11:00:00.370]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.370]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.370]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.370]             on.exit(options(oopts), add = TRUE)
[11:00:00.370]         }
[11:00:00.370]         {
[11:00:00.370]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.370]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.370]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.370]             })
[11:00:00.370]         }
[11:00:00.370]     }, args = future.call.arguments)
[11:00:00.370] }
[11:00:00.370] Tweak future expression to call with '...' arguments ... DONE
[11:00:00.371] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.371] - packages: [1] ‘future.apply’
[11:00:00.371] getGlobalsAndPackages() ... DONE
[11:00:00.371] run() for ‘Future’ ...
[11:00:00.371] - state: ‘created’
[11:00:00.371] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:00.372] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.372] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:00.372]   - Field: ‘label’
[11:00:00.372]   - Field: ‘local’
[11:00:00.372]   - Field: ‘owner’
[11:00:00.372]   - Field: ‘envir’
[11:00:00.372]   - Field: ‘packages’
[11:00:00.372]   - Field: ‘gc’
[11:00:00.372]   - Field: ‘conditions’
[11:00:00.372]   - Field: ‘expr’
[11:00:00.373]   - Field: ‘uuid’
[11:00:00.373]   - Field: ‘seed’
[11:00:00.373]   - Field: ‘version’
[11:00:00.373]   - Field: ‘result’
[11:00:00.373]   - Field: ‘asynchronous’
[11:00:00.373]   - Field: ‘calls’
[11:00:00.373]   - Field: ‘globals’
[11:00:00.373]   - Field: ‘stdout’
[11:00:00.373]   - Field: ‘earlySignal’
[11:00:00.373]   - Field: ‘lazy’
[11:00:00.373]   - Field: ‘state’
[11:00:00.373] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:00.373] - Launch lazy future ...
[11:00:00.374] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:00.374] Packages needed by future strategies (n = 0): <none>
[11:00:00.374] {
[11:00:00.374]     {
[11:00:00.374]         {
[11:00:00.374]             ...future.startTime <- base::Sys.time()
[11:00:00.374]             {
[11:00:00.374]                 {
[11:00:00.374]                   {
[11:00:00.374]                     {
[11:00:00.374]                       base::local({
[11:00:00.374]                         has_future <- base::requireNamespace("future", 
[11:00:00.374]                           quietly = TRUE)
[11:00:00.374]                         if (has_future) {
[11:00:00.374]                           ns <- base::getNamespace("future")
[11:00:00.374]                           version <- ns[[".package"]][["version"]]
[11:00:00.374]                           if (is.null(version)) 
[11:00:00.374]                             version <- utils::packageVersion("future")
[11:00:00.374]                         }
[11:00:00.374]                         else {
[11:00:00.374]                           version <- NULL
[11:00:00.374]                         }
[11:00:00.374]                         if (!has_future || version < "1.8.0") {
[11:00:00.374]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:00.374]                             "", base::R.version$version.string), 
[11:00:00.374]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:00.374]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:00.374]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:00.374]                               "release", "version")], collapse = " "), 
[11:00:00.374]                             hostname = base::Sys.info()[["nodename"]])
[11:00:00.374]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:00.374]                             info)
[11:00:00.374]                           info <- base::paste(info, collapse = "; ")
[11:00:00.374]                           if (!has_future) {
[11:00:00.374]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:00.374]                               info)
[11:00:00.374]                           }
[11:00:00.374]                           else {
[11:00:00.374]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:00.374]                               info, version)
[11:00:00.374]                           }
[11:00:00.374]                           base::stop(msg)
[11:00:00.374]                         }
[11:00:00.374]                       })
[11:00:00.374]                     }
[11:00:00.374]                     base::local({
[11:00:00.374]                       for (pkg in "future.apply") {
[11:00:00.374]                         base::loadNamespace(pkg)
[11:00:00.374]                         base::library(pkg, character.only = TRUE)
[11:00:00.374]                       }
[11:00:00.374]                     })
[11:00:00.374]                   }
[11:00:00.374]                   ...future.strategy.old <- future::plan("list")
[11:00:00.374]                   options(future.plan = NULL)
[11:00:00.374]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.374]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:00.374]                 }
[11:00:00.374]                 ...future.workdir <- getwd()
[11:00:00.374]             }
[11:00:00.374]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:00.374]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:00.374]         }
[11:00:00.374]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:00.374]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:00.374]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:00.374]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:00.374]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:00.374]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:00.374]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:00.374]             base::names(...future.oldOptions))
[11:00:00.374]     }
[11:00:00.374]     if (FALSE) {
[11:00:00.374]     }
[11:00:00.374]     else {
[11:00:00.374]         if (TRUE) {
[11:00:00.374]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:00.374]                 open = "w")
[11:00:00.374]         }
[11:00:00.374]         else {
[11:00:00.374]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:00.374]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:00.374]         }
[11:00:00.374]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:00.374]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:00.374]             base::sink(type = "output", split = FALSE)
[11:00:00.374]             base::close(...future.stdout)
[11:00:00.374]         }, add = TRUE)
[11:00:00.374]     }
[11:00:00.374]     ...future.frame <- base::sys.nframe()
[11:00:00.374]     ...future.conditions <- base::list()
[11:00:00.374]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:00.374]     if (FALSE) {
[11:00:00.374]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:00.374]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:00.374]     }
[11:00:00.374]     ...future.result <- base::tryCatch({
[11:00:00.374]         base::withCallingHandlers({
[11:00:00.374]             ...future.value <- base::withVisible(base::local({
[11:00:00.374]                 do.call(function(...) {
[11:00:00.374]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.374]                   if (!identical(...future.globals.maxSize.org, 
[11:00:00.374]                     ...future.globals.maxSize)) {
[11:00:00.374]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.374]                     on.exit(options(oopts), add = TRUE)
[11:00:00.374]                   }
[11:00:00.374]                   {
[11:00:00.374]                     lapply(seq_along(...future.elements_ii), 
[11:00:00.374]                       FUN = function(jj) {
[11:00:00.374]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.374]                         ...future.FUN(...future.X_jj, ...)
[11:00:00.374]                       })
[11:00:00.374]                   }
[11:00:00.374]                 }, args = future.call.arguments)
[11:00:00.374]             }))
[11:00:00.374]             future::FutureResult(value = ...future.value$value, 
[11:00:00.374]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.374]                   ...future.rng), globalenv = if (FALSE) 
[11:00:00.374]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:00.374]                     ...future.globalenv.names))
[11:00:00.374]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:00.374]         }, condition = base::local({
[11:00:00.374]             c <- base::c
[11:00:00.374]             inherits <- base::inherits
[11:00:00.374]             invokeRestart <- base::invokeRestart
[11:00:00.374]             length <- base::length
[11:00:00.374]             list <- base::list
[11:00:00.374]             seq.int <- base::seq.int
[11:00:00.374]             signalCondition <- base::signalCondition
[11:00:00.374]             sys.calls <- base::sys.calls
[11:00:00.374]             `[[` <- base::`[[`
[11:00:00.374]             `+` <- base::`+`
[11:00:00.374]             `<<-` <- base::`<<-`
[11:00:00.374]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:00.374]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:00.374]                   3L)]
[11:00:00.374]             }
[11:00:00.374]             function(cond) {
[11:00:00.374]                 is_error <- inherits(cond, "error")
[11:00:00.374]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:00.374]                   NULL)
[11:00:00.374]                 if (is_error) {
[11:00:00.374]                   sessionInformation <- function() {
[11:00:00.374]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:00.374]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:00.374]                       search = base::search(), system = base::Sys.info())
[11:00:00.374]                   }
[11:00:00.374]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.374]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:00.374]                     cond$call), session = sessionInformation(), 
[11:00:00.374]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:00.374]                   signalCondition(cond)
[11:00:00.374]                 }
[11:00:00.374]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:00.374]                 "immediateCondition"))) {
[11:00:00.374]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:00.374]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.374]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:00.374]                   if (TRUE && !signal) {
[11:00:00.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.374]                     {
[11:00:00.374]                       inherits <- base::inherits
[11:00:00.374]                       invokeRestart <- base::invokeRestart
[11:00:00.374]                       is.null <- base::is.null
[11:00:00.374]                       muffled <- FALSE
[11:00:00.374]                       if (inherits(cond, "message")) {
[11:00:00.374]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.374]                         if (muffled) 
[11:00:00.374]                           invokeRestart("muffleMessage")
[11:00:00.374]                       }
[11:00:00.374]                       else if (inherits(cond, "warning")) {
[11:00:00.374]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.374]                         if (muffled) 
[11:00:00.374]                           invokeRestart("muffleWarning")
[11:00:00.374]                       }
[11:00:00.374]                       else if (inherits(cond, "condition")) {
[11:00:00.374]                         if (!is.null(pattern)) {
[11:00:00.374]                           computeRestarts <- base::computeRestarts
[11:00:00.374]                           grepl <- base::grepl
[11:00:00.374]                           restarts <- computeRestarts(cond)
[11:00:00.374]                           for (restart in restarts) {
[11:00:00.374]                             name <- restart$name
[11:00:00.374]                             if (is.null(name)) 
[11:00:00.374]                               next
[11:00:00.374]                             if (!grepl(pattern, name)) 
[11:00:00.374]                               next
[11:00:00.374]                             invokeRestart(restart)
[11:00:00.374]                             muffled <- TRUE
[11:00:00.374]                             break
[11:00:00.374]                           }
[11:00:00.374]                         }
[11:00:00.374]                       }
[11:00:00.374]                       invisible(muffled)
[11:00:00.374]                     }
[11:00:00.374]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.374]                   }
[11:00:00.374]                 }
[11:00:00.374]                 else {
[11:00:00.374]                   if (TRUE) {
[11:00:00.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.374]                     {
[11:00:00.374]                       inherits <- base::inherits
[11:00:00.374]                       invokeRestart <- base::invokeRestart
[11:00:00.374]                       is.null <- base::is.null
[11:00:00.374]                       muffled <- FALSE
[11:00:00.374]                       if (inherits(cond, "message")) {
[11:00:00.374]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.374]                         if (muffled) 
[11:00:00.374]                           invokeRestart("muffleMessage")
[11:00:00.374]                       }
[11:00:00.374]                       else if (inherits(cond, "warning")) {
[11:00:00.374]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.374]                         if (muffled) 
[11:00:00.374]                           invokeRestart("muffleWarning")
[11:00:00.374]                       }
[11:00:00.374]                       else if (inherits(cond, "condition")) {
[11:00:00.374]                         if (!is.null(pattern)) {
[11:00:00.374]                           computeRestarts <- base::computeRestarts
[11:00:00.374]                           grepl <- base::grepl
[11:00:00.374]                           restarts <- computeRestarts(cond)
[11:00:00.374]                           for (restart in restarts) {
[11:00:00.374]                             name <- restart$name
[11:00:00.374]                             if (is.null(name)) 
[11:00:00.374]                               next
[11:00:00.374]                             if (!grepl(pattern, name)) 
[11:00:00.374]                               next
[11:00:00.374]                             invokeRestart(restart)
[11:00:00.374]                             muffled <- TRUE
[11:00:00.374]                             break
[11:00:00.374]                           }
[11:00:00.374]                         }
[11:00:00.374]                       }
[11:00:00.374]                       invisible(muffled)
[11:00:00.374]                     }
[11:00:00.374]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.374]                   }
[11:00:00.374]                 }
[11:00:00.374]             }
[11:00:00.374]         }))
[11:00:00.374]     }, error = function(ex) {
[11:00:00.374]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:00.374]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.374]                 ...future.rng), started = ...future.startTime, 
[11:00:00.374]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:00.374]             version = "1.8"), class = "FutureResult")
[11:00:00.374]     }, finally = {
[11:00:00.374]         if (!identical(...future.workdir, getwd())) 
[11:00:00.374]             setwd(...future.workdir)
[11:00:00.374]         {
[11:00:00.374]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:00.374]                 ...future.oldOptions$nwarnings <- NULL
[11:00:00.374]             }
[11:00:00.374]             base::options(...future.oldOptions)
[11:00:00.374]             if (.Platform$OS.type == "windows") {
[11:00:00.374]                 old_names <- names(...future.oldEnvVars)
[11:00:00.374]                 envs <- base::Sys.getenv()
[11:00:00.374]                 names <- names(envs)
[11:00:00.374]                 common <- intersect(names, old_names)
[11:00:00.374]                 added <- setdiff(names, old_names)
[11:00:00.374]                 removed <- setdiff(old_names, names)
[11:00:00.374]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:00.374]                   envs[common]]
[11:00:00.374]                 NAMES <- toupper(changed)
[11:00:00.374]                 args <- list()
[11:00:00.374]                 for (kk in seq_along(NAMES)) {
[11:00:00.374]                   name <- changed[[kk]]
[11:00:00.374]                   NAME <- NAMES[[kk]]
[11:00:00.374]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.374]                     next
[11:00:00.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.374]                 }
[11:00:00.374]                 NAMES <- toupper(added)
[11:00:00.374]                 for (kk in seq_along(NAMES)) {
[11:00:00.374]                   name <- added[[kk]]
[11:00:00.374]                   NAME <- NAMES[[kk]]
[11:00:00.374]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.374]                     next
[11:00:00.374]                   args[[name]] <- ""
[11:00:00.374]                 }
[11:00:00.374]                 NAMES <- toupper(removed)
[11:00:00.374]                 for (kk in seq_along(NAMES)) {
[11:00:00.374]                   name <- removed[[kk]]
[11:00:00.374]                   NAME <- NAMES[[kk]]
[11:00:00.374]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.374]                     next
[11:00:00.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.374]                 }
[11:00:00.374]                 if (length(args) > 0) 
[11:00:00.374]                   base::do.call(base::Sys.setenv, args = args)
[11:00:00.374]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:00.374]             }
[11:00:00.374]             else {
[11:00:00.374]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:00.374]             }
[11:00:00.374]             {
[11:00:00.374]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:00.374]                   0L) {
[11:00:00.374]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:00.374]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:00.374]                   base::options(opts)
[11:00:00.374]                 }
[11:00:00.374]                 {
[11:00:00.374]                   {
[11:00:00.374]                     NULL
[11:00:00.374]                     RNGkind("Mersenne-Twister")
[11:00:00.374]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:00.374]                       inherits = FALSE)
[11:00:00.374]                   }
[11:00:00.374]                   options(future.plan = NULL)
[11:00:00.374]                   if (is.na(NA_character_)) 
[11:00:00.374]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.374]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:00.374]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:00.374]                     .init = FALSE)
[11:00:00.374]                 }
[11:00:00.374]             }
[11:00:00.374]         }
[11:00:00.374]     })
[11:00:00.374]     if (TRUE) {
[11:00:00.374]         base::sink(type = "output", split = FALSE)
[11:00:00.374]         if (TRUE) {
[11:00:00.374]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:00.374]         }
[11:00:00.374]         else {
[11:00:00.374]             ...future.result["stdout"] <- base::list(NULL)
[11:00:00.374]         }
[11:00:00.374]         base::close(...future.stdout)
[11:00:00.374]         ...future.stdout <- NULL
[11:00:00.374]     }
[11:00:00.374]     ...future.result$conditions <- ...future.conditions
[11:00:00.374]     ...future.result$finished <- base::Sys.time()
[11:00:00.374]     ...future.result
[11:00:00.374] }
[11:00:00.376] assign_globals() ...
[11:00:00.376] List of 11
[11:00:00.376]  $ ...future.FUN            :function (x, ...)  
[11:00:00.376]  $ x_FUN                    :function (x)  
[11:00:00.376]  $ times                    : int 1
[11:00:00.376]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.376]  $ stop_if_not              :function (...)  
[11:00:00.376]  $ dim                      : NULL
[11:00:00.376]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:00.376]  $ future.call.arguments    : list()
[11:00:00.376]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.376]  $ ...future.elements_ii    :List of 10
[11:00:00.376]   ..$ : int 1
[11:00:00.376]   ..$ : int 2
[11:00:00.376]   ..$ : int 3
[11:00:00.376]   ..$ : int 4
[11:00:00.376]   ..$ : int 5
[11:00:00.376]   ..$ : int 6
[11:00:00.376]   ..$ : int 7
[11:00:00.376]   ..$ : int 8
[11:00:00.376]   ..$ : int 9
[11:00:00.376]   ..$ : int 10
[11:00:00.376]  $ ...future.seeds_ii       : NULL
[11:00:00.376]  $ ...future.globals.maxSize: NULL
[11:00:00.376]  - attr(*, "where")=List of 11
[11:00:00.376]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:00.376]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:00.376]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:00.376]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:00.376]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:00.376]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:00.376]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:00.376]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:00.376]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:00.376]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:00.376]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:00.376]  - attr(*, "resolved")= logi FALSE
[11:00:00.376]  - attr(*, "total_size")= num 22322
[11:00:00.376]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.376]  - attr(*, "already-done")= logi TRUE
[11:00:00.385] - copied ‘...future.FUN’ to environment
[11:00:00.385] - copied ‘x_FUN’ to environment
[11:00:00.385] - copied ‘times’ to environment
[11:00:00.385] - copied ‘stopf’ to environment
[11:00:00.385] - copied ‘stop_if_not’ to environment
[11:00:00.385] - copied ‘dim’ to environment
[11:00:00.385] - copied ‘valid_types’ to environment
[11:00:00.385] - copied ‘future.call.arguments’ to environment
[11:00:00.386] - copied ‘...future.elements_ii’ to environment
[11:00:00.386] - copied ‘...future.seeds_ii’ to environment
[11:00:00.386] - copied ‘...future.globals.maxSize’ to environment
[11:00:00.386] assign_globals() ... done
[11:00:00.386] plan(): Setting new future strategy stack:
[11:00:00.386] List of future strategies:
[11:00:00.386] 1. sequential:
[11:00:00.386]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.386]    - tweaked: FALSE
[11:00:00.386]    - call: NULL
[11:00:00.387] plan(): nbrOfWorkers() = 1
[11:00:00.387] plan(): Setting new future strategy stack:
[11:00:00.387] List of future strategies:
[11:00:00.387] 1. sequential:
[11:00:00.387]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.387]    - tweaked: FALSE
[11:00:00.387]    - call: plan(strategy)
[11:00:00.388] plan(): nbrOfWorkers() = 1
[11:00:00.388] SequentialFuture started (and completed)
[11:00:00.388] - Launch lazy future ... done
[11:00:00.388] run() for ‘SequentialFuture’ ... done
[11:00:00.388] Created future:
[11:00:00.388] SequentialFuture:
[11:00:00.388] Label: ‘future_vapply-1’
[11:00:00.388] Expression:
[11:00:00.388] {
[11:00:00.388]     do.call(function(...) {
[11:00:00.388]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.388]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.388]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.388]             on.exit(options(oopts), add = TRUE)
[11:00:00.388]         }
[11:00:00.388]         {
[11:00:00.388]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.388]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.388]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.388]             })
[11:00:00.388]         }
[11:00:00.388]     }, args = future.call.arguments)
[11:00:00.388] }
[11:00:00.388] Lazy evaluation: FALSE
[11:00:00.388] Asynchronous evaluation: FALSE
[11:00:00.388] Local evaluation: TRUE
[11:00:00.388] Environment: R_GlobalEnv
[11:00:00.388] Capture standard output: TRUE
[11:00:00.388] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:00.388] Globals: 11 objects totaling 12.37 KiB (function ‘...future.FUN’ of 4.06 KiB, function ‘x_FUN’ of 35 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:00.388] Packages: 1 packages (‘future.apply’)
[11:00:00.388] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:00.388] Resolved: TRUE
[11:00:00.388] Value: 191 bytes of class ‘list’
[11:00:00.388] Early signaling: FALSE
[11:00:00.388] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:00.388] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.390] Chunk #1 of 1 ... DONE
[11:00:00.390] Launching 1 futures (chunks) ... DONE
[11:00:00.390] Resolving 1 futures (chunks) ...
[11:00:00.390] resolve() on list ...
[11:00:00.390]  recursive: 0
[11:00:00.390]  length: 1
[11:00:00.390] 
[11:00:00.390] resolved() for ‘SequentialFuture’ ...
[11:00:00.391] - state: ‘finished’
[11:00:00.391] - run: TRUE
[11:00:00.391] - result: ‘FutureResult’
[11:00:00.391] resolved() for ‘SequentialFuture’ ... done
[11:00:00.391] Future #1
[11:00:00.391] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:00.391] - nx: 1
[11:00:00.391] - relay: TRUE
[11:00:00.391] - stdout: TRUE
[11:00:00.391] - signal: TRUE
[11:00:00.391] - resignal: FALSE
[11:00:00.391] - force: TRUE
[11:00:00.391] - relayed: [n=1] FALSE
[11:00:00.392] - queued futures: [n=1] FALSE
[11:00:00.392]  - until=1
[11:00:00.392]  - relaying element #1
[11:00:00.392] - relayed: [n=1] TRUE
[11:00:00.392] - queued futures: [n=1] TRUE
[11:00:00.392] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:00.392]  length: 0 (resolved future 1)
[11:00:00.392] Relaying remaining futures
[11:00:00.392] signalConditionsASAP(NULL, pos=0) ...
[11:00:00.392] - nx: 1
[11:00:00.392] - relay: TRUE
[11:00:00.392] - stdout: TRUE
[11:00:00.393] - signal: TRUE
[11:00:00.393] - resignal: FALSE
[11:00:00.393] - force: TRUE
[11:00:00.393] - relayed: [n=1] TRUE
[11:00:00.393] - queued futures: [n=1] TRUE
 - flush all
[11:00:00.393] - relayed: [n=1] TRUE
[11:00:00.393] - queued futures: [n=1] TRUE
[11:00:00.393] signalConditionsASAP(NULL, pos=0) ... done
[11:00:00.393] resolve() on list ... DONE
[11:00:00.393]  - Number of value chunks collected: 1
[11:00:00.393] Resolving 1 futures (chunks) ... DONE
[11:00:00.394] Reducing values from 1 chunks ...
[11:00:00.394]  - Number of values collected after concatenation: 10
[11:00:00.394]  - Number of values expected: 10
[11:00:00.394] Reducing values from 1 chunks ... DONE
[11:00:00.394] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[11:00:00.394] future_lapply() ...
[11:00:00.396] Number of chunks: 1
[11:00:00.396] getGlobalsAndPackagesXApply() ...
[11:00:00.396]  - future.globals: TRUE
[11:00:00.396] getGlobalsAndPackages() ...
[11:00:00.396] Searching for globals...
[11:00:00.399] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[11:00:00.400] Searching for globals ... DONE
[11:00:00.400] Resolving globals: FALSE
[11:00:00.400] The total size of the 7 globals is 13.34 KiB (13657 bytes)
[11:00:00.401] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.89 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:00.401] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.401] - packages: [1] ‘future.apply’
[11:00:00.401] getGlobalsAndPackages() ... DONE
[11:00:00.401]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.401]  - needed namespaces: [n=1] ‘future.apply’
[11:00:00.401] Finding globals ... DONE
[11:00:00.401]  - use_args: TRUE
[11:00:00.402]  - Getting '...' globals ...
[11:00:00.402] resolve() on list ...
[11:00:00.402]  recursive: 0
[11:00:00.402]  length: 1
[11:00:00.402]  elements: ‘...’
[11:00:00.402]  length: 0 (resolved future 1)
[11:00:00.402] resolve() on list ... DONE
[11:00:00.402]    - '...' content: [n=0] 
[11:00:00.402] List of 1
[11:00:00.402]  $ ...: list()
[11:00:00.402]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.402]  - attr(*, "where")=List of 1
[11:00:00.402]   ..$ ...:<environment: 0x55bbab594f10> 
[11:00:00.402]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.402]  - attr(*, "resolved")= logi TRUE
[11:00:00.402]  - attr(*, "total_size")= num NA
[11:00:00.404]  - Getting '...' globals ... DONE
[11:00:00.405] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:00.405] List of 8
[11:00:00.405]  $ ...future.FUN:function (x, ...)  
[11:00:00.405]  $ x_FUN        :function (x)  
[11:00:00.405]  $ times        : int 2
[11:00:00.405]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.405]  $ stop_if_not  :function (...)  
[11:00:00.405]  $ dim          : NULL
[11:00:00.405]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:00.405]  $ ...          : list()
[11:00:00.405]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.405]  - attr(*, "where")=List of 8
[11:00:00.405]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:00.405]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:00.405]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:00.405]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:00.405]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:00.405]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:00.405]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:00.405]   ..$ ...          :<environment: 0x55bbab594f10> 
[11:00:00.405]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.405]  - attr(*, "resolved")= logi FALSE
[11:00:00.405]  - attr(*, "total_size")= num 24454
[11:00:00.410] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:00.411] getGlobalsAndPackagesXApply() ... DONE
[11:00:00.411] Number of futures (= number of chunks): 1
[11:00:00.411] Launching 1 futures (chunks) ...
[11:00:00.411] Chunk #1 of 1 ...
[11:00:00.411]  - Finding globals in 'X' for chunk #1 ...
[11:00:00.411] getGlobalsAndPackages() ...
[11:00:00.411] Searching for globals...
[11:00:00.411] 
[11:00:00.411] Searching for globals ... DONE
[11:00:00.412] - globals: [0] <none>
[11:00:00.412] getGlobalsAndPackages() ... DONE
[11:00:00.412]    + additional globals found: [n=0] 
[11:00:00.412]    + additional namespaces needed: [n=0] 
[11:00:00.412]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:00.412]  - seeds: <none>
[11:00:00.412]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.412] getGlobalsAndPackages() ...
[11:00:00.412] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.412] Resolving globals: FALSE
[11:00:00.412] Tweak future expression to call with '...' arguments ...
[11:00:00.412] {
[11:00:00.412]     do.call(function(...) {
[11:00:00.412]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.412]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.412]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.412]             on.exit(options(oopts), add = TRUE)
[11:00:00.412]         }
[11:00:00.412]         {
[11:00:00.412]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.412]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.412]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.412]             })
[11:00:00.412]         }
[11:00:00.412]     }, args = future.call.arguments)
[11:00:00.412] }
[11:00:00.413] Tweak future expression to call with '...' arguments ... DONE
[11:00:00.413] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.413] - packages: [1] ‘future.apply’
[11:00:00.413] getGlobalsAndPackages() ... DONE
[11:00:00.414] run() for ‘Future’ ...
[11:00:00.414] - state: ‘created’
[11:00:00.414] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:00.414] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.414] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:00.414]   - Field: ‘label’
[11:00:00.414]   - Field: ‘local’
[11:00:00.414]   - Field: ‘owner’
[11:00:00.415]   - Field: ‘envir’
[11:00:00.415]   - Field: ‘packages’
[11:00:00.415]   - Field: ‘gc’
[11:00:00.415]   - Field: ‘conditions’
[11:00:00.415]   - Field: ‘expr’
[11:00:00.415]   - Field: ‘uuid’
[11:00:00.415]   - Field: ‘seed’
[11:00:00.415]   - Field: ‘version’
[11:00:00.415]   - Field: ‘result’
[11:00:00.415]   - Field: ‘asynchronous’
[11:00:00.415]   - Field: ‘calls’
[11:00:00.415]   - Field: ‘globals’
[11:00:00.415]   - Field: ‘stdout’
[11:00:00.416]   - Field: ‘earlySignal’
[11:00:00.416]   - Field: ‘lazy’
[11:00:00.416]   - Field: ‘state’
[11:00:00.416] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:00.416] - Launch lazy future ...
[11:00:00.416] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:00.416] Packages needed by future strategies (n = 0): <none>
[11:00:00.417] {
[11:00:00.417]     {
[11:00:00.417]         {
[11:00:00.417]             ...future.startTime <- base::Sys.time()
[11:00:00.417]             {
[11:00:00.417]                 {
[11:00:00.417]                   {
[11:00:00.417]                     {
[11:00:00.417]                       base::local({
[11:00:00.417]                         has_future <- base::requireNamespace("future", 
[11:00:00.417]                           quietly = TRUE)
[11:00:00.417]                         if (has_future) {
[11:00:00.417]                           ns <- base::getNamespace("future")
[11:00:00.417]                           version <- ns[[".package"]][["version"]]
[11:00:00.417]                           if (is.null(version)) 
[11:00:00.417]                             version <- utils::packageVersion("future")
[11:00:00.417]                         }
[11:00:00.417]                         else {
[11:00:00.417]                           version <- NULL
[11:00:00.417]                         }
[11:00:00.417]                         if (!has_future || version < "1.8.0") {
[11:00:00.417]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:00.417]                             "", base::R.version$version.string), 
[11:00:00.417]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:00.417]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:00.417]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:00.417]                               "release", "version")], collapse = " "), 
[11:00:00.417]                             hostname = base::Sys.info()[["nodename"]])
[11:00:00.417]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:00.417]                             info)
[11:00:00.417]                           info <- base::paste(info, collapse = "; ")
[11:00:00.417]                           if (!has_future) {
[11:00:00.417]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:00.417]                               info)
[11:00:00.417]                           }
[11:00:00.417]                           else {
[11:00:00.417]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:00.417]                               info, version)
[11:00:00.417]                           }
[11:00:00.417]                           base::stop(msg)
[11:00:00.417]                         }
[11:00:00.417]                       })
[11:00:00.417]                     }
[11:00:00.417]                     base::local({
[11:00:00.417]                       for (pkg in "future.apply") {
[11:00:00.417]                         base::loadNamespace(pkg)
[11:00:00.417]                         base::library(pkg, character.only = TRUE)
[11:00:00.417]                       }
[11:00:00.417]                     })
[11:00:00.417]                   }
[11:00:00.417]                   ...future.strategy.old <- future::plan("list")
[11:00:00.417]                   options(future.plan = NULL)
[11:00:00.417]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.417]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:00.417]                 }
[11:00:00.417]                 ...future.workdir <- getwd()
[11:00:00.417]             }
[11:00:00.417]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:00.417]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:00.417]         }
[11:00:00.417]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:00.417]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:00.417]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:00.417]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:00.417]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:00.417]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:00.417]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:00.417]             base::names(...future.oldOptions))
[11:00:00.417]     }
[11:00:00.417]     if (FALSE) {
[11:00:00.417]     }
[11:00:00.417]     else {
[11:00:00.417]         if (TRUE) {
[11:00:00.417]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:00.417]                 open = "w")
[11:00:00.417]         }
[11:00:00.417]         else {
[11:00:00.417]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:00.417]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:00.417]         }
[11:00:00.417]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:00.417]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:00.417]             base::sink(type = "output", split = FALSE)
[11:00:00.417]             base::close(...future.stdout)
[11:00:00.417]         }, add = TRUE)
[11:00:00.417]     }
[11:00:00.417]     ...future.frame <- base::sys.nframe()
[11:00:00.417]     ...future.conditions <- base::list()
[11:00:00.417]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:00.417]     if (FALSE) {
[11:00:00.417]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:00.417]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:00.417]     }
[11:00:00.417]     ...future.result <- base::tryCatch({
[11:00:00.417]         base::withCallingHandlers({
[11:00:00.417]             ...future.value <- base::withVisible(base::local({
[11:00:00.417]                 do.call(function(...) {
[11:00:00.417]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.417]                   if (!identical(...future.globals.maxSize.org, 
[11:00:00.417]                     ...future.globals.maxSize)) {
[11:00:00.417]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.417]                     on.exit(options(oopts), add = TRUE)
[11:00:00.417]                   }
[11:00:00.417]                   {
[11:00:00.417]                     lapply(seq_along(...future.elements_ii), 
[11:00:00.417]                       FUN = function(jj) {
[11:00:00.417]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.417]                         ...future.FUN(...future.X_jj, ...)
[11:00:00.417]                       })
[11:00:00.417]                   }
[11:00:00.417]                 }, args = future.call.arguments)
[11:00:00.417]             }))
[11:00:00.417]             future::FutureResult(value = ...future.value$value, 
[11:00:00.417]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.417]                   ...future.rng), globalenv = if (FALSE) 
[11:00:00.417]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:00.417]                     ...future.globalenv.names))
[11:00:00.417]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:00.417]         }, condition = base::local({
[11:00:00.417]             c <- base::c
[11:00:00.417]             inherits <- base::inherits
[11:00:00.417]             invokeRestart <- base::invokeRestart
[11:00:00.417]             length <- base::length
[11:00:00.417]             list <- base::list
[11:00:00.417]             seq.int <- base::seq.int
[11:00:00.417]             signalCondition <- base::signalCondition
[11:00:00.417]             sys.calls <- base::sys.calls
[11:00:00.417]             `[[` <- base::`[[`
[11:00:00.417]             `+` <- base::`+`
[11:00:00.417]             `<<-` <- base::`<<-`
[11:00:00.417]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:00.417]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:00.417]                   3L)]
[11:00:00.417]             }
[11:00:00.417]             function(cond) {
[11:00:00.417]                 is_error <- inherits(cond, "error")
[11:00:00.417]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:00.417]                   NULL)
[11:00:00.417]                 if (is_error) {
[11:00:00.417]                   sessionInformation <- function() {
[11:00:00.417]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:00.417]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:00.417]                       search = base::search(), system = base::Sys.info())
[11:00:00.417]                   }
[11:00:00.417]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.417]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:00.417]                     cond$call), session = sessionInformation(), 
[11:00:00.417]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:00.417]                   signalCondition(cond)
[11:00:00.417]                 }
[11:00:00.417]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:00.417]                 "immediateCondition"))) {
[11:00:00.417]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:00.417]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.417]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:00.417]                   if (TRUE && !signal) {
[11:00:00.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.417]                     {
[11:00:00.417]                       inherits <- base::inherits
[11:00:00.417]                       invokeRestart <- base::invokeRestart
[11:00:00.417]                       is.null <- base::is.null
[11:00:00.417]                       muffled <- FALSE
[11:00:00.417]                       if (inherits(cond, "message")) {
[11:00:00.417]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.417]                         if (muffled) 
[11:00:00.417]                           invokeRestart("muffleMessage")
[11:00:00.417]                       }
[11:00:00.417]                       else if (inherits(cond, "warning")) {
[11:00:00.417]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.417]                         if (muffled) 
[11:00:00.417]                           invokeRestart("muffleWarning")
[11:00:00.417]                       }
[11:00:00.417]                       else if (inherits(cond, "condition")) {
[11:00:00.417]                         if (!is.null(pattern)) {
[11:00:00.417]                           computeRestarts <- base::computeRestarts
[11:00:00.417]                           grepl <- base::grepl
[11:00:00.417]                           restarts <- computeRestarts(cond)
[11:00:00.417]                           for (restart in restarts) {
[11:00:00.417]                             name <- restart$name
[11:00:00.417]                             if (is.null(name)) 
[11:00:00.417]                               next
[11:00:00.417]                             if (!grepl(pattern, name)) 
[11:00:00.417]                               next
[11:00:00.417]                             invokeRestart(restart)
[11:00:00.417]                             muffled <- TRUE
[11:00:00.417]                             break
[11:00:00.417]                           }
[11:00:00.417]                         }
[11:00:00.417]                       }
[11:00:00.417]                       invisible(muffled)
[11:00:00.417]                     }
[11:00:00.417]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.417]                   }
[11:00:00.417]                 }
[11:00:00.417]                 else {
[11:00:00.417]                   if (TRUE) {
[11:00:00.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.417]                     {
[11:00:00.417]                       inherits <- base::inherits
[11:00:00.417]                       invokeRestart <- base::invokeRestart
[11:00:00.417]                       is.null <- base::is.null
[11:00:00.417]                       muffled <- FALSE
[11:00:00.417]                       if (inherits(cond, "message")) {
[11:00:00.417]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.417]                         if (muffled) 
[11:00:00.417]                           invokeRestart("muffleMessage")
[11:00:00.417]                       }
[11:00:00.417]                       else if (inherits(cond, "warning")) {
[11:00:00.417]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.417]                         if (muffled) 
[11:00:00.417]                           invokeRestart("muffleWarning")
[11:00:00.417]                       }
[11:00:00.417]                       else if (inherits(cond, "condition")) {
[11:00:00.417]                         if (!is.null(pattern)) {
[11:00:00.417]                           computeRestarts <- base::computeRestarts
[11:00:00.417]                           grepl <- base::grepl
[11:00:00.417]                           restarts <- computeRestarts(cond)
[11:00:00.417]                           for (restart in restarts) {
[11:00:00.417]                             name <- restart$name
[11:00:00.417]                             if (is.null(name)) 
[11:00:00.417]                               next
[11:00:00.417]                             if (!grepl(pattern, name)) 
[11:00:00.417]                               next
[11:00:00.417]                             invokeRestart(restart)
[11:00:00.417]                             muffled <- TRUE
[11:00:00.417]                             break
[11:00:00.417]                           }
[11:00:00.417]                         }
[11:00:00.417]                       }
[11:00:00.417]                       invisible(muffled)
[11:00:00.417]                     }
[11:00:00.417]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.417]                   }
[11:00:00.417]                 }
[11:00:00.417]             }
[11:00:00.417]         }))
[11:00:00.417]     }, error = function(ex) {
[11:00:00.417]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:00.417]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.417]                 ...future.rng), started = ...future.startTime, 
[11:00:00.417]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:00.417]             version = "1.8"), class = "FutureResult")
[11:00:00.417]     }, finally = {
[11:00:00.417]         if (!identical(...future.workdir, getwd())) 
[11:00:00.417]             setwd(...future.workdir)
[11:00:00.417]         {
[11:00:00.417]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:00.417]                 ...future.oldOptions$nwarnings <- NULL
[11:00:00.417]             }
[11:00:00.417]             base::options(...future.oldOptions)
[11:00:00.417]             if (.Platform$OS.type == "windows") {
[11:00:00.417]                 old_names <- names(...future.oldEnvVars)
[11:00:00.417]                 envs <- base::Sys.getenv()
[11:00:00.417]                 names <- names(envs)
[11:00:00.417]                 common <- intersect(names, old_names)
[11:00:00.417]                 added <- setdiff(names, old_names)
[11:00:00.417]                 removed <- setdiff(old_names, names)
[11:00:00.417]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:00.417]                   envs[common]]
[11:00:00.417]                 NAMES <- toupper(changed)
[11:00:00.417]                 args <- list()
[11:00:00.417]                 for (kk in seq_along(NAMES)) {
[11:00:00.417]                   name <- changed[[kk]]
[11:00:00.417]                   NAME <- NAMES[[kk]]
[11:00:00.417]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.417]                     next
[11:00:00.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.417]                 }
[11:00:00.417]                 NAMES <- toupper(added)
[11:00:00.417]                 for (kk in seq_along(NAMES)) {
[11:00:00.417]                   name <- added[[kk]]
[11:00:00.417]                   NAME <- NAMES[[kk]]
[11:00:00.417]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.417]                     next
[11:00:00.417]                   args[[name]] <- ""
[11:00:00.417]                 }
[11:00:00.417]                 NAMES <- toupper(removed)
[11:00:00.417]                 for (kk in seq_along(NAMES)) {
[11:00:00.417]                   name <- removed[[kk]]
[11:00:00.417]                   NAME <- NAMES[[kk]]
[11:00:00.417]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.417]                     next
[11:00:00.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.417]                 }
[11:00:00.417]                 if (length(args) > 0) 
[11:00:00.417]                   base::do.call(base::Sys.setenv, args = args)
[11:00:00.417]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:00.417]             }
[11:00:00.417]             else {
[11:00:00.417]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:00.417]             }
[11:00:00.417]             {
[11:00:00.417]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:00.417]                   0L) {
[11:00:00.417]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:00.417]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:00.417]                   base::options(opts)
[11:00:00.417]                 }
[11:00:00.417]                 {
[11:00:00.417]                   {
[11:00:00.417]                     NULL
[11:00:00.417]                     RNGkind("Mersenne-Twister")
[11:00:00.417]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:00.417]                       inherits = FALSE)
[11:00:00.417]                   }
[11:00:00.417]                   options(future.plan = NULL)
[11:00:00.417]                   if (is.na(NA_character_)) 
[11:00:00.417]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.417]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:00.417]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:00.417]                     .init = FALSE)
[11:00:00.417]                 }
[11:00:00.417]             }
[11:00:00.417]         }
[11:00:00.417]     })
[11:00:00.417]     if (TRUE) {
[11:00:00.417]         base::sink(type = "output", split = FALSE)
[11:00:00.417]         if (TRUE) {
[11:00:00.417]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:00.417]         }
[11:00:00.417]         else {
[11:00:00.417]             ...future.result["stdout"] <- base::list(NULL)
[11:00:00.417]         }
[11:00:00.417]         base::close(...future.stdout)
[11:00:00.417]         ...future.stdout <- NULL
[11:00:00.417]     }
[11:00:00.417]     ...future.result$conditions <- ...future.conditions
[11:00:00.417]     ...future.result$finished <- base::Sys.time()
[11:00:00.417]     ...future.result
[11:00:00.417] }
[11:00:00.418] assign_globals() ...
[11:00:00.418] List of 11
[11:00:00.418]  $ ...future.FUN            :function (x, ...)  
[11:00:00.418]  $ x_FUN                    :function (x)  
[11:00:00.418]  $ times                    : int 2
[11:00:00.418]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.418]  $ stop_if_not              :function (...)  
[11:00:00.418]  $ dim                      : NULL
[11:00:00.418]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:00.418]  $ future.call.arguments    : list()
[11:00:00.418]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.418]  $ ...future.elements_ii    :List of 10
[11:00:00.418]   ..$ : int 1
[11:00:00.418]   ..$ : int 2
[11:00:00.418]   ..$ : int 3
[11:00:00.418]   ..$ : int 4
[11:00:00.418]   ..$ : int 5
[11:00:00.418]   ..$ : int 6
[11:00:00.418]   ..$ : int 7
[11:00:00.418]   ..$ : int 8
[11:00:00.418]   ..$ : int 9
[11:00:00.418]   ..$ : int 10
[11:00:00.418]  $ ...future.seeds_ii       : NULL
[11:00:00.418]  $ ...future.globals.maxSize: NULL
[11:00:00.418]  - attr(*, "where")=List of 11
[11:00:00.418]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:00.418]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:00.418]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:00.418]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:00.418]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:00.418]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:00.418]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:00.418]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:00.418]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:00.418]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:00.418]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:00.418]  - attr(*, "resolved")= logi FALSE
[11:00:00.418]  - attr(*, "total_size")= num 24454
[11:00:00.418]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.418]  - attr(*, "already-done")= logi TRUE
[11:00:00.427] - copied ‘...future.FUN’ to environment
[11:00:00.427] - reassign environment for ‘x_FUN’
[11:00:00.427] - copied ‘x_FUN’ to environment
[11:00:00.427] - copied ‘times’ to environment
[11:00:00.428] - copied ‘stopf’ to environment
[11:00:00.428] - copied ‘stop_if_not’ to environment
[11:00:00.428] - copied ‘dim’ to environment
[11:00:00.428] - copied ‘valid_types’ to environment
[11:00:00.428] - copied ‘future.call.arguments’ to environment
[11:00:00.428] - copied ‘...future.elements_ii’ to environment
[11:00:00.428] - copied ‘...future.seeds_ii’ to environment
[11:00:00.428] - copied ‘...future.globals.maxSize’ to environment
[11:00:00.428] assign_globals() ... done
[11:00:00.428] plan(): Setting new future strategy stack:
[11:00:00.429] List of future strategies:
[11:00:00.429] 1. sequential:
[11:00:00.429]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.429]    - tweaked: FALSE
[11:00:00.429]    - call: NULL
[11:00:00.430] plan(): nbrOfWorkers() = 1
[11:00:00.431] plan(): Setting new future strategy stack:
[11:00:00.431] List of future strategies:
[11:00:00.431] 1. sequential:
[11:00:00.431]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.431]    - tweaked: FALSE
[11:00:00.431]    - call: plan(strategy)
[11:00:00.431] plan(): nbrOfWorkers() = 1
[11:00:00.431] SequentialFuture started (and completed)
[11:00:00.431] - Launch lazy future ... done
[11:00:00.431] run() for ‘SequentialFuture’ ... done
[11:00:00.431] Created future:
[11:00:00.432] SequentialFuture:
[11:00:00.432] Label: ‘future_vapply-1’
[11:00:00.432] Expression:
[11:00:00.432] {
[11:00:00.432]     do.call(function(...) {
[11:00:00.432]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.432]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.432]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.432]             on.exit(options(oopts), add = TRUE)
[11:00:00.432]         }
[11:00:00.432]         {
[11:00:00.432]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.432]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.432]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.432]             })
[11:00:00.432]         }
[11:00:00.432]     }, args = future.call.arguments)
[11:00:00.432] }
[11:00:00.432] Lazy evaluation: FALSE
[11:00:00.432] Asynchronous evaluation: FALSE
[11:00:00.432] Local evaluation: TRUE
[11:00:00.432] Environment: R_GlobalEnv
[11:00:00.432] Capture standard output: TRUE
[11:00:00.432] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:00.432] Globals: 11 objects totaling 13.63 KiB (function ‘...future.FUN’ of 4.88 KiB, function ‘x_FUN’ of 483 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:00.432] Packages: 1 packages (‘future.apply’)
[11:00:00.432] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:00.432] Resolved: TRUE
[11:00:00.432] Value: 271 bytes of class ‘list’
[11:00:00.432] Early signaling: FALSE
[11:00:00.432] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:00.432] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.432] Chunk #1 of 1 ... DONE
[11:00:00.432] Launching 1 futures (chunks) ... DONE
[11:00:00.433] Resolving 1 futures (chunks) ...
[11:00:00.433] resolve() on list ...
[11:00:00.433]  recursive: 0
[11:00:00.433]  length: 1
[11:00:00.433] 
[11:00:00.433] resolved() for ‘SequentialFuture’ ...
[11:00:00.433] - state: ‘finished’
[11:00:00.433] - run: TRUE
[11:00:00.433] - result: ‘FutureResult’
[11:00:00.433] resolved() for ‘SequentialFuture’ ... done
[11:00:00.433] Future #1
[11:00:00.433] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:00.434] - nx: 1
[11:00:00.434] - relay: TRUE
[11:00:00.434] - stdout: TRUE
[11:00:00.434] - signal: TRUE
[11:00:00.434] - resignal: FALSE
[11:00:00.434] - force: TRUE
[11:00:00.434] - relayed: [n=1] FALSE
[11:00:00.434] - queued futures: [n=1] FALSE
[11:00:00.434]  - until=1
[11:00:00.434]  - relaying element #1
[11:00:00.434] - relayed: [n=1] TRUE
[11:00:00.434] - queued futures: [n=1] TRUE
[11:00:00.435] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:00.435]  length: 0 (resolved future 1)
[11:00:00.435] Relaying remaining futures
[11:00:00.435] signalConditionsASAP(NULL, pos=0) ...
[11:00:00.435] - nx: 1
[11:00:00.435] - relay: TRUE
[11:00:00.435] - stdout: TRUE
[11:00:00.435] - signal: TRUE
[11:00:00.435] - resignal: FALSE
[11:00:00.435] - force: TRUE
[11:00:00.435] - relayed: [n=1] TRUE
[11:00:00.435] - queued futures: [n=1] TRUE
 - flush all
[11:00:00.436] - relayed: [n=1] TRUE
[11:00:00.436] - queued futures: [n=1] TRUE
[11:00:00.436] signalConditionsASAP(NULL, pos=0) ... done
[11:00:00.436] resolve() on list ... DONE
[11:00:00.436]  - Number of value chunks collected: 1
[11:00:00.436] Resolving 1 futures (chunks) ... DONE
[11:00:00.436] Reducing values from 1 chunks ...
[11:00:00.436]  - Number of values collected after concatenation: 10
[11:00:00.436]  - Number of values expected: 10
[11:00:00.436] Reducing values from 1 chunks ... DONE
[11:00:00.436] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[11:00:00.437] future_lapply() ...
[11:00:00.439] Number of chunks: 1
[11:00:00.439] getGlobalsAndPackagesXApply() ...
[11:00:00.439]  - future.globals: TRUE
[11:00:00.439] getGlobalsAndPackages() ...
[11:00:00.439] Searching for globals...
[11:00:00.442] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[11:00:00.442] Searching for globals ... DONE
[11:00:00.442] Resolving globals: FALSE
[11:00:00.443] The total size of the 7 globals is 13.59 KiB (13914 bytes)
[11:00:00.443] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.59 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.06 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:00.444] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.444] - packages: [1] ‘future.apply’
[11:00:00.444] getGlobalsAndPackages() ... DONE
[11:00:00.444]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.444]  - needed namespaces: [n=1] ‘future.apply’
[11:00:00.444] Finding globals ... DONE
[11:00:00.444]  - use_args: TRUE
[11:00:00.444]  - Getting '...' globals ...
[11:00:00.444] resolve() on list ...
[11:00:00.444]  recursive: 0
[11:00:00.445]  length: 1
[11:00:00.445]  elements: ‘...’
[11:00:00.445]  length: 0 (resolved future 1)
[11:00:00.445] resolve() on list ... DONE
[11:00:00.445]    - '...' content: [n=0] 
[11:00:00.445] List of 1
[11:00:00.445]  $ ...: list()
[11:00:00.445]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.445]  - attr(*, "where")=List of 1
[11:00:00.445]   ..$ ...:<environment: 0x55bbacd35768> 
[11:00:00.445]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.445]  - attr(*, "resolved")= logi TRUE
[11:00:00.445]  - attr(*, "total_size")= num NA
[11:00:00.447]  - Getting '...' globals ... DONE
[11:00:00.447] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:00.447] List of 8
[11:00:00.447]  $ ...future.FUN:function (x, ...)  
[11:00:00.447]  $ x_FUN        :function (x)  
[11:00:00.447]  $ times        : int 4
[11:00:00.447]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.447]  $ stop_if_not  :function (...)  
[11:00:00.447]  $ dim          : int [1:2] 2 2
[11:00:00.447]  $ valid_types  : chr [1:2] "logical" "integer"
[11:00:00.447]  $ ...          : list()
[11:00:00.447]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.447]  - attr(*, "where")=List of 8
[11:00:00.447]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:00.447]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:00.447]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:00.447]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:00.447]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:00.447]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:00.447]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:00.447]   ..$ ...          :<environment: 0x55bbacd35768> 
[11:00:00.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.447]  - attr(*, "resolved")= logi FALSE
[11:00:00.447]  - attr(*, "total_size")= num 24886
[11:00:00.453] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:00.453] getGlobalsAndPackagesXApply() ... DONE
[11:00:00.454] Number of futures (= number of chunks): 1
[11:00:00.454] Launching 1 futures (chunks) ...
[11:00:00.454] Chunk #1 of 1 ...
[11:00:00.454]  - Finding globals in 'X' for chunk #1 ...
[11:00:00.454] getGlobalsAndPackages() ...
[11:00:00.454] Searching for globals...
[11:00:00.454] 
[11:00:00.454] Searching for globals ... DONE
[11:00:00.454] - globals: [0] <none>
[11:00:00.454] getGlobalsAndPackages() ... DONE
[11:00:00.455]    + additional globals found: [n=0] 
[11:00:00.455]    + additional namespaces needed: [n=0] 
[11:00:00.455]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:00.455]  - seeds: <none>
[11:00:00.455]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.455] getGlobalsAndPackages() ...
[11:00:00.455] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.455] Resolving globals: FALSE
[11:00:00.455] Tweak future expression to call with '...' arguments ...
[11:00:00.455] {
[11:00:00.455]     do.call(function(...) {
[11:00:00.455]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.455]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.455]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.455]             on.exit(options(oopts), add = TRUE)
[11:00:00.455]         }
[11:00:00.455]         {
[11:00:00.455]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.455]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.455]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.455]             })
[11:00:00.455]         }
[11:00:00.455]     }, args = future.call.arguments)
[11:00:00.455] }
[11:00:00.456] Tweak future expression to call with '...' arguments ... DONE
[11:00:00.456] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.456] - packages: [1] ‘future.apply’
[11:00:00.456] getGlobalsAndPackages() ... DONE
[11:00:00.456] run() for ‘Future’ ...
[11:00:00.457] - state: ‘created’
[11:00:00.457] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:00.457] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.457] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:00.457]   - Field: ‘label’
[11:00:00.457]   - Field: ‘local’
[11:00:00.457]   - Field: ‘owner’
[11:00:00.457]   - Field: ‘envir’
[11:00:00.457]   - Field: ‘packages’
[11:00:00.458]   - Field: ‘gc’
[11:00:00.458]   - Field: ‘conditions’
[11:00:00.458]   - Field: ‘expr’
[11:00:00.458]   - Field: ‘uuid’
[11:00:00.458]   - Field: ‘seed’
[11:00:00.458]   - Field: ‘version’
[11:00:00.458]   - Field: ‘result’
[11:00:00.458]   - Field: ‘asynchronous’
[11:00:00.458]   - Field: ‘calls’
[11:00:00.458]   - Field: ‘globals’
[11:00:00.458]   - Field: ‘stdout’
[11:00:00.458]   - Field: ‘earlySignal’
[11:00:00.458]   - Field: ‘lazy’
[11:00:00.459]   - Field: ‘state’
[11:00:00.459] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:00.459] - Launch lazy future ...
[11:00:00.459] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:00.459] Packages needed by future strategies (n = 0): <none>
[11:00:00.459] {
[11:00:00.459]     {
[11:00:00.459]         {
[11:00:00.459]             ...future.startTime <- base::Sys.time()
[11:00:00.459]             {
[11:00:00.459]                 {
[11:00:00.459]                   {
[11:00:00.459]                     {
[11:00:00.459]                       base::local({
[11:00:00.459]                         has_future <- base::requireNamespace("future", 
[11:00:00.459]                           quietly = TRUE)
[11:00:00.459]                         if (has_future) {
[11:00:00.459]                           ns <- base::getNamespace("future")
[11:00:00.459]                           version <- ns[[".package"]][["version"]]
[11:00:00.459]                           if (is.null(version)) 
[11:00:00.459]                             version <- utils::packageVersion("future")
[11:00:00.459]                         }
[11:00:00.459]                         else {
[11:00:00.459]                           version <- NULL
[11:00:00.459]                         }
[11:00:00.459]                         if (!has_future || version < "1.8.0") {
[11:00:00.459]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:00.459]                             "", base::R.version$version.string), 
[11:00:00.459]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:00.459]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:00.459]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:00.459]                               "release", "version")], collapse = " "), 
[11:00:00.459]                             hostname = base::Sys.info()[["nodename"]])
[11:00:00.459]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:00.459]                             info)
[11:00:00.459]                           info <- base::paste(info, collapse = "; ")
[11:00:00.459]                           if (!has_future) {
[11:00:00.459]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:00.459]                               info)
[11:00:00.459]                           }
[11:00:00.459]                           else {
[11:00:00.459]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:00.459]                               info, version)
[11:00:00.459]                           }
[11:00:00.459]                           base::stop(msg)
[11:00:00.459]                         }
[11:00:00.459]                       })
[11:00:00.459]                     }
[11:00:00.459]                     base::local({
[11:00:00.459]                       for (pkg in "future.apply") {
[11:00:00.459]                         base::loadNamespace(pkg)
[11:00:00.459]                         base::library(pkg, character.only = TRUE)
[11:00:00.459]                       }
[11:00:00.459]                     })
[11:00:00.459]                   }
[11:00:00.459]                   ...future.strategy.old <- future::plan("list")
[11:00:00.459]                   options(future.plan = NULL)
[11:00:00.459]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.459]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:00.459]                 }
[11:00:00.459]                 ...future.workdir <- getwd()
[11:00:00.459]             }
[11:00:00.459]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:00.459]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:00.459]         }
[11:00:00.459]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:00.459]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:00.459]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:00.459]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:00.459]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:00.459]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:00.459]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:00.459]             base::names(...future.oldOptions))
[11:00:00.459]     }
[11:00:00.459]     if (FALSE) {
[11:00:00.459]     }
[11:00:00.459]     else {
[11:00:00.459]         if (TRUE) {
[11:00:00.459]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:00.459]                 open = "w")
[11:00:00.459]         }
[11:00:00.459]         else {
[11:00:00.459]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:00.459]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:00.459]         }
[11:00:00.459]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:00.459]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:00.459]             base::sink(type = "output", split = FALSE)
[11:00:00.459]             base::close(...future.stdout)
[11:00:00.459]         }, add = TRUE)
[11:00:00.459]     }
[11:00:00.459]     ...future.frame <- base::sys.nframe()
[11:00:00.459]     ...future.conditions <- base::list()
[11:00:00.459]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:00.459]     if (FALSE) {
[11:00:00.459]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:00.459]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:00.459]     }
[11:00:00.459]     ...future.result <- base::tryCatch({
[11:00:00.459]         base::withCallingHandlers({
[11:00:00.459]             ...future.value <- base::withVisible(base::local({
[11:00:00.459]                 do.call(function(...) {
[11:00:00.459]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.459]                   if (!identical(...future.globals.maxSize.org, 
[11:00:00.459]                     ...future.globals.maxSize)) {
[11:00:00.459]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.459]                     on.exit(options(oopts), add = TRUE)
[11:00:00.459]                   }
[11:00:00.459]                   {
[11:00:00.459]                     lapply(seq_along(...future.elements_ii), 
[11:00:00.459]                       FUN = function(jj) {
[11:00:00.459]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.459]                         ...future.FUN(...future.X_jj, ...)
[11:00:00.459]                       })
[11:00:00.459]                   }
[11:00:00.459]                 }, args = future.call.arguments)
[11:00:00.459]             }))
[11:00:00.459]             future::FutureResult(value = ...future.value$value, 
[11:00:00.459]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.459]                   ...future.rng), globalenv = if (FALSE) 
[11:00:00.459]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:00.459]                     ...future.globalenv.names))
[11:00:00.459]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:00.459]         }, condition = base::local({
[11:00:00.459]             c <- base::c
[11:00:00.459]             inherits <- base::inherits
[11:00:00.459]             invokeRestart <- base::invokeRestart
[11:00:00.459]             length <- base::length
[11:00:00.459]             list <- base::list
[11:00:00.459]             seq.int <- base::seq.int
[11:00:00.459]             signalCondition <- base::signalCondition
[11:00:00.459]             sys.calls <- base::sys.calls
[11:00:00.459]             `[[` <- base::`[[`
[11:00:00.459]             `+` <- base::`+`
[11:00:00.459]             `<<-` <- base::`<<-`
[11:00:00.459]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:00.459]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:00.459]                   3L)]
[11:00:00.459]             }
[11:00:00.459]             function(cond) {
[11:00:00.459]                 is_error <- inherits(cond, "error")
[11:00:00.459]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:00.459]                   NULL)
[11:00:00.459]                 if (is_error) {
[11:00:00.459]                   sessionInformation <- function() {
[11:00:00.459]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:00.459]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:00.459]                       search = base::search(), system = base::Sys.info())
[11:00:00.459]                   }
[11:00:00.459]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.459]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:00.459]                     cond$call), session = sessionInformation(), 
[11:00:00.459]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:00.459]                   signalCondition(cond)
[11:00:00.459]                 }
[11:00:00.459]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:00.459]                 "immediateCondition"))) {
[11:00:00.459]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:00.459]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.459]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:00.459]                   if (TRUE && !signal) {
[11:00:00.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.459]                     {
[11:00:00.459]                       inherits <- base::inherits
[11:00:00.459]                       invokeRestart <- base::invokeRestart
[11:00:00.459]                       is.null <- base::is.null
[11:00:00.459]                       muffled <- FALSE
[11:00:00.459]                       if (inherits(cond, "message")) {
[11:00:00.459]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.459]                         if (muffled) 
[11:00:00.459]                           invokeRestart("muffleMessage")
[11:00:00.459]                       }
[11:00:00.459]                       else if (inherits(cond, "warning")) {
[11:00:00.459]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.459]                         if (muffled) 
[11:00:00.459]                           invokeRestart("muffleWarning")
[11:00:00.459]                       }
[11:00:00.459]                       else if (inherits(cond, "condition")) {
[11:00:00.459]                         if (!is.null(pattern)) {
[11:00:00.459]                           computeRestarts <- base::computeRestarts
[11:00:00.459]                           grepl <- base::grepl
[11:00:00.459]                           restarts <- computeRestarts(cond)
[11:00:00.459]                           for (restart in restarts) {
[11:00:00.459]                             name <- restart$name
[11:00:00.459]                             if (is.null(name)) 
[11:00:00.459]                               next
[11:00:00.459]                             if (!grepl(pattern, name)) 
[11:00:00.459]                               next
[11:00:00.459]                             invokeRestart(restart)
[11:00:00.459]                             muffled <- TRUE
[11:00:00.459]                             break
[11:00:00.459]                           }
[11:00:00.459]                         }
[11:00:00.459]                       }
[11:00:00.459]                       invisible(muffled)
[11:00:00.459]                     }
[11:00:00.459]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.459]                   }
[11:00:00.459]                 }
[11:00:00.459]                 else {
[11:00:00.459]                   if (TRUE) {
[11:00:00.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.459]                     {
[11:00:00.459]                       inherits <- base::inherits
[11:00:00.459]                       invokeRestart <- base::invokeRestart
[11:00:00.459]                       is.null <- base::is.null
[11:00:00.459]                       muffled <- FALSE
[11:00:00.459]                       if (inherits(cond, "message")) {
[11:00:00.459]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.459]                         if (muffled) 
[11:00:00.459]                           invokeRestart("muffleMessage")
[11:00:00.459]                       }
[11:00:00.459]                       else if (inherits(cond, "warning")) {
[11:00:00.459]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.459]                         if (muffled) 
[11:00:00.459]                           invokeRestart("muffleWarning")
[11:00:00.459]                       }
[11:00:00.459]                       else if (inherits(cond, "condition")) {
[11:00:00.459]                         if (!is.null(pattern)) {
[11:00:00.459]                           computeRestarts <- base::computeRestarts
[11:00:00.459]                           grepl <- base::grepl
[11:00:00.459]                           restarts <- computeRestarts(cond)
[11:00:00.459]                           for (restart in restarts) {
[11:00:00.459]                             name <- restart$name
[11:00:00.459]                             if (is.null(name)) 
[11:00:00.459]                               next
[11:00:00.459]                             if (!grepl(pattern, name)) 
[11:00:00.459]                               next
[11:00:00.459]                             invokeRestart(restart)
[11:00:00.459]                             muffled <- TRUE
[11:00:00.459]                             break
[11:00:00.459]                           }
[11:00:00.459]                         }
[11:00:00.459]                       }
[11:00:00.459]                       invisible(muffled)
[11:00:00.459]                     }
[11:00:00.459]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.459]                   }
[11:00:00.459]                 }
[11:00:00.459]             }
[11:00:00.459]         }))
[11:00:00.459]     }, error = function(ex) {
[11:00:00.459]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:00.459]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.459]                 ...future.rng), started = ...future.startTime, 
[11:00:00.459]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:00.459]             version = "1.8"), class = "FutureResult")
[11:00:00.459]     }, finally = {
[11:00:00.459]         if (!identical(...future.workdir, getwd())) 
[11:00:00.459]             setwd(...future.workdir)
[11:00:00.459]         {
[11:00:00.459]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:00.459]                 ...future.oldOptions$nwarnings <- NULL
[11:00:00.459]             }
[11:00:00.459]             base::options(...future.oldOptions)
[11:00:00.459]             if (.Platform$OS.type == "windows") {
[11:00:00.459]                 old_names <- names(...future.oldEnvVars)
[11:00:00.459]                 envs <- base::Sys.getenv()
[11:00:00.459]                 names <- names(envs)
[11:00:00.459]                 common <- intersect(names, old_names)
[11:00:00.459]                 added <- setdiff(names, old_names)
[11:00:00.459]                 removed <- setdiff(old_names, names)
[11:00:00.459]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:00.459]                   envs[common]]
[11:00:00.459]                 NAMES <- toupper(changed)
[11:00:00.459]                 args <- list()
[11:00:00.459]                 for (kk in seq_along(NAMES)) {
[11:00:00.459]                   name <- changed[[kk]]
[11:00:00.459]                   NAME <- NAMES[[kk]]
[11:00:00.459]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.459]                     next
[11:00:00.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.459]                 }
[11:00:00.459]                 NAMES <- toupper(added)
[11:00:00.459]                 for (kk in seq_along(NAMES)) {
[11:00:00.459]                   name <- added[[kk]]
[11:00:00.459]                   NAME <- NAMES[[kk]]
[11:00:00.459]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.459]                     next
[11:00:00.459]                   args[[name]] <- ""
[11:00:00.459]                 }
[11:00:00.459]                 NAMES <- toupper(removed)
[11:00:00.459]                 for (kk in seq_along(NAMES)) {
[11:00:00.459]                   name <- removed[[kk]]
[11:00:00.459]                   NAME <- NAMES[[kk]]
[11:00:00.459]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.459]                     next
[11:00:00.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.459]                 }
[11:00:00.459]                 if (length(args) > 0) 
[11:00:00.459]                   base::do.call(base::Sys.setenv, args = args)
[11:00:00.459]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:00.459]             }
[11:00:00.459]             else {
[11:00:00.459]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:00.459]             }
[11:00:00.459]             {
[11:00:00.459]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:00.459]                   0L) {
[11:00:00.459]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:00.459]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:00.459]                   base::options(opts)
[11:00:00.459]                 }
[11:00:00.459]                 {
[11:00:00.459]                   {
[11:00:00.459]                     NULL
[11:00:00.459]                     RNGkind("Mersenne-Twister")
[11:00:00.459]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:00.459]                       inherits = FALSE)
[11:00:00.459]                   }
[11:00:00.459]                   options(future.plan = NULL)
[11:00:00.459]                   if (is.na(NA_character_)) 
[11:00:00.459]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.459]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:00.459]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:00.459]                     .init = FALSE)
[11:00:00.459]                 }
[11:00:00.459]             }
[11:00:00.459]         }
[11:00:00.459]     })
[11:00:00.459]     if (TRUE) {
[11:00:00.459]         base::sink(type = "output", split = FALSE)
[11:00:00.459]         if (TRUE) {
[11:00:00.459]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:00.459]         }
[11:00:00.459]         else {
[11:00:00.459]             ...future.result["stdout"] <- base::list(NULL)
[11:00:00.459]         }
[11:00:00.459]         base::close(...future.stdout)
[11:00:00.459]         ...future.stdout <- NULL
[11:00:00.459]     }
[11:00:00.459]     ...future.result$conditions <- ...future.conditions
[11:00:00.459]     ...future.result$finished <- base::Sys.time()
[11:00:00.459]     ...future.result
[11:00:00.459] }
[11:00:00.461] assign_globals() ...
[11:00:00.461] List of 11
[11:00:00.461]  $ ...future.FUN            :function (x, ...)  
[11:00:00.461]  $ x_FUN                    :function (x)  
[11:00:00.461]  $ times                    : int 4
[11:00:00.461]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.461]  $ stop_if_not              :function (...)  
[11:00:00.461]  $ dim                      : int [1:2] 2 2
[11:00:00.461]  $ valid_types              : chr [1:2] "logical" "integer"
[11:00:00.461]  $ future.call.arguments    : list()
[11:00:00.461]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.461]  $ ...future.elements_ii    :List of 10
[11:00:00.461]   ..$ : int 1
[11:00:00.461]   ..$ : int 2
[11:00:00.461]   ..$ : int 3
[11:00:00.461]   ..$ : int 4
[11:00:00.461]   ..$ : int 5
[11:00:00.461]   ..$ : int 6
[11:00:00.461]   ..$ : int 7
[11:00:00.461]   ..$ : int 8
[11:00:00.461]   ..$ : int 9
[11:00:00.461]   ..$ : int 10
[11:00:00.461]  $ ...future.seeds_ii       : NULL
[11:00:00.461]  $ ...future.globals.maxSize: NULL
[11:00:00.461]  - attr(*, "where")=List of 11
[11:00:00.461]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:00.461]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:00.461]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:00.461]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:00.461]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:00.461]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:00.461]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:00.461]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:00.461]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:00.461]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:00.461]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:00.461]  - attr(*, "resolved")= logi FALSE
[11:00:00.461]  - attr(*, "total_size")= num 24886
[11:00:00.461]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.461]  - attr(*, "already-done")= logi TRUE
[11:00:00.471] - copied ‘...future.FUN’ to environment
[11:00:00.471] - reassign environment for ‘x_FUN’
[11:00:00.471] - copied ‘x_FUN’ to environment
[11:00:00.471] - copied ‘times’ to environment
[11:00:00.471] - copied ‘stopf’ to environment
[11:00:00.472] - copied ‘stop_if_not’ to environment
[11:00:00.472] - copied ‘dim’ to environment
[11:00:00.472] - copied ‘valid_types’ to environment
[11:00:00.472] - copied ‘future.call.arguments’ to environment
[11:00:00.472] - copied ‘...future.elements_ii’ to environment
[11:00:00.472] - copied ‘...future.seeds_ii’ to environment
[11:00:00.472] - copied ‘...future.globals.maxSize’ to environment
[11:00:00.472] assign_globals() ... done
[11:00:00.472] plan(): Setting new future strategy stack:
[11:00:00.472] List of future strategies:
[11:00:00.472] 1. sequential:
[11:00:00.472]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.472]    - tweaked: FALSE
[11:00:00.472]    - call: NULL
[11:00:00.473] plan(): nbrOfWorkers() = 1
[11:00:00.474] plan(): Setting new future strategy stack:
[11:00:00.474] List of future strategies:
[11:00:00.474] 1. sequential:
[11:00:00.474]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.474]    - tweaked: FALSE
[11:00:00.474]    - call: plan(strategy)
[11:00:00.474] plan(): nbrOfWorkers() = 1
[11:00:00.474] SequentialFuture started (and completed)
[11:00:00.474] - Launch lazy future ... done
[11:00:00.474] run() for ‘SequentialFuture’ ... done
[11:00:00.475] Created future:
[11:00:00.475] SequentialFuture:
[11:00:00.475] Label: ‘future_vapply-1’
[11:00:00.475] Expression:
[11:00:00.475] {
[11:00:00.475]     do.call(function(...) {
[11:00:00.475]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.475]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.475]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.475]             on.exit(options(oopts), add = TRUE)
[11:00:00.475]         }
[11:00:00.475]         {
[11:00:00.475]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.475]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.475]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.475]             })
[11:00:00.475]         }
[11:00:00.475]     }, args = future.call.arguments)
[11:00:00.475] }
[11:00:00.475] Lazy evaluation: FALSE
[11:00:00.475] Asynchronous evaluation: FALSE
[11:00:00.475] Local evaluation: TRUE
[11:00:00.475] Environment: R_GlobalEnv
[11:00:00.475] Capture standard output: TRUE
[11:00:00.475] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:00.475] Globals: 11 objects totaling 13.88 KiB (function ‘...future.FUN’ of 5.05 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:00.475] Packages: 1 packages (‘future.apply’)
[11:00:00.475] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:00.475] Resolved: TRUE
[11:00:00.475] Value: 562 bytes of class ‘list’
[11:00:00.475] Early signaling: FALSE
[11:00:00.475] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:00.475] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.476] Chunk #1 of 1 ... DONE
[11:00:00.476] Launching 1 futures (chunks) ... DONE
[11:00:00.476] Resolving 1 futures (chunks) ...
[11:00:00.476] resolve() on list ...
[11:00:00.476]  recursive: 0
[11:00:00.476]  length: 1
[11:00:00.476] 
[11:00:00.476] resolved() for ‘SequentialFuture’ ...
[11:00:00.476] - state: ‘finished’
[11:00:00.476] - run: TRUE
[11:00:00.476] - result: ‘FutureResult’
[11:00:00.476] resolved() for ‘SequentialFuture’ ... done
[11:00:00.477] Future #1
[11:00:00.477] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:00.477] - nx: 1
[11:00:00.477] - relay: TRUE
[11:00:00.477] - stdout: TRUE
[11:00:00.477] - signal: TRUE
[11:00:00.477] - resignal: FALSE
[11:00:00.477] - force: TRUE
[11:00:00.477] - relayed: [n=1] FALSE
[11:00:00.477] - queued futures: [n=1] FALSE
[11:00:00.477]  - until=1
[11:00:00.477]  - relaying element #1
[11:00:00.478] - relayed: [n=1] TRUE
[11:00:00.478] - queued futures: [n=1] TRUE
[11:00:00.478] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:00.478]  length: 0 (resolved future 1)
[11:00:00.478] Relaying remaining futures
[11:00:00.478] signalConditionsASAP(NULL, pos=0) ...
[11:00:00.478] - nx: 1
[11:00:00.478] - relay: TRUE
[11:00:00.478] - stdout: TRUE
[11:00:00.478] - signal: TRUE
[11:00:00.478] - resignal: FALSE
[11:00:00.478] - force: TRUE
[11:00:00.479] - relayed: [n=1] TRUE
[11:00:00.479] - queued futures: [n=1] TRUE
 - flush all
[11:00:00.479] - relayed: [n=1] TRUE
[11:00:00.479] - queued futures: [n=1] TRUE
[11:00:00.479] signalConditionsASAP(NULL, pos=0) ... done
[11:00:00.479] resolve() on list ... DONE
[11:00:00.479]  - Number of value chunks collected: 1
[11:00:00.479] Resolving 1 futures (chunks) ... DONE
[11:00:00.479] Reducing values from 1 chunks ...
[11:00:00.479]  - Number of values collected after concatenation: 10
[11:00:00.479]  - Number of values expected: 10
[11:00:00.479] Reducing values from 1 chunks ... DONE
[11:00:00.480] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[11:00:00.480] future_lapply() ...
[11:00:00.482] Number of chunks: 1
[11:00:00.482] getGlobalsAndPackagesXApply() ...
[11:00:00.482]  - future.globals: TRUE
[11:00:00.482] getGlobalsAndPackages() ...
[11:00:00.482] Searching for globals...
[11:00:00.485] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[11:00:00.485] Searching for globals ... DONE
[11:00:00.485] Resolving globals: FALSE
[11:00:00.486] The total size of the 7 globals is 13.63 KiB (13957 bytes)
[11:00:00.487] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.63 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.09 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:00.487] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.487] - packages: [1] ‘future.apply’
[11:00:00.487] getGlobalsAndPackages() ... DONE
[11:00:00.487]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.487]  - needed namespaces: [n=1] ‘future.apply’
[11:00:00.487] Finding globals ... DONE
[11:00:00.487]  - use_args: TRUE
[11:00:00.487]  - Getting '...' globals ...
[11:00:00.488] resolve() on list ...
[11:00:00.488]  recursive: 0
[11:00:00.488]  length: 1
[11:00:00.488]  elements: ‘...’
[11:00:00.488]  length: 0 (resolved future 1)
[11:00:00.488] resolve() on list ... DONE
[11:00:00.488]    - '...' content: [n=0] 
[11:00:00.488] List of 1
[11:00:00.488]  $ ...: list()
[11:00:00.488]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.488]  - attr(*, "where")=List of 1
[11:00:00.488]   ..$ ...:<environment: 0x55bbad378bf8> 
[11:00:00.488]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.488]  - attr(*, "resolved")= logi TRUE
[11:00:00.488]  - attr(*, "total_size")= num NA
[11:00:00.491]  - Getting '...' globals ... DONE
[11:00:00.491] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:00.492] List of 8
[11:00:00.492]  $ ...future.FUN:function (x, ...)  
[11:00:00.492]  $ x_FUN        :function (x)  
[11:00:00.492]  $ times        : int 4
[11:00:00.492]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.492]  $ stop_if_not  :function (...)  
[11:00:00.492]  $ dim          : int [1:2] 2 2
[11:00:00.492]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:00.492]  $ ...          : list()
[11:00:00.492]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.492]  - attr(*, "where")=List of 8
[11:00:00.492]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:00.492]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:00.492]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:00.492]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:00.492]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:00.492]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:00.492]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:00.492]   ..$ ...          :<environment: 0x55bbad378bf8> 
[11:00:00.492]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.492]  - attr(*, "resolved")= logi FALSE
[11:00:00.492]  - attr(*, "total_size")= num 24958
[11:00:00.497] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:00.497] getGlobalsAndPackagesXApply() ... DONE
[11:00:00.497] Number of futures (= number of chunks): 1
[11:00:00.497] Launching 1 futures (chunks) ...
[11:00:00.497] Chunk #1 of 1 ...
[11:00:00.497]  - Finding globals in 'X' for chunk #1 ...
[11:00:00.497] getGlobalsAndPackages() ...
[11:00:00.497] Searching for globals...
[11:00:00.498] 
[11:00:00.498] Searching for globals ... DONE
[11:00:00.498] - globals: [0] <none>
[11:00:00.498] getGlobalsAndPackages() ... DONE
[11:00:00.498]    + additional globals found: [n=0] 
[11:00:00.498]    + additional namespaces needed: [n=0] 
[11:00:00.498]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:00.498]  - seeds: <none>
[11:00:00.498]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.498] getGlobalsAndPackages() ...
[11:00:00.498] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.499] Resolving globals: FALSE
[11:00:00.499] Tweak future expression to call with '...' arguments ...
[11:00:00.499] {
[11:00:00.499]     do.call(function(...) {
[11:00:00.499]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.499]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.499]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.499]             on.exit(options(oopts), add = TRUE)
[11:00:00.499]         }
[11:00:00.499]         {
[11:00:00.499]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.499]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.499]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.499]             })
[11:00:00.499]         }
[11:00:00.499]     }, args = future.call.arguments)
[11:00:00.499] }
[11:00:00.499] Tweak future expression to call with '...' arguments ... DONE
[11:00:00.499] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.500] - packages: [1] ‘future.apply’
[11:00:00.500] getGlobalsAndPackages() ... DONE
[11:00:00.500] run() for ‘Future’ ...
[11:00:00.500] - state: ‘created’
[11:00:00.500] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:00.500] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.500] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:00.501]   - Field: ‘label’
[11:00:00.501]   - Field: ‘local’
[11:00:00.501]   - Field: ‘owner’
[11:00:00.501]   - Field: ‘envir’
[11:00:00.501]   - Field: ‘packages’
[11:00:00.501]   - Field: ‘gc’
[11:00:00.501]   - Field: ‘conditions’
[11:00:00.501]   - Field: ‘expr’
[11:00:00.501]   - Field: ‘uuid’
[11:00:00.501]   - Field: ‘seed’
[11:00:00.501]   - Field: ‘version’
[11:00:00.501]   - Field: ‘result’
[11:00:00.501]   - Field: ‘asynchronous’
[11:00:00.502]   - Field: ‘calls’
[11:00:00.502]   - Field: ‘globals’
[11:00:00.502]   - Field: ‘stdout’
[11:00:00.502]   - Field: ‘earlySignal’
[11:00:00.502]   - Field: ‘lazy’
[11:00:00.502]   - Field: ‘state’
[11:00:00.502] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:00.502] - Launch lazy future ...
[11:00:00.502] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:00.502] Packages needed by future strategies (n = 0): <none>
[11:00:00.503] {
[11:00:00.503]     {
[11:00:00.503]         {
[11:00:00.503]             ...future.startTime <- base::Sys.time()
[11:00:00.503]             {
[11:00:00.503]                 {
[11:00:00.503]                   {
[11:00:00.503]                     {
[11:00:00.503]                       base::local({
[11:00:00.503]                         has_future <- base::requireNamespace("future", 
[11:00:00.503]                           quietly = TRUE)
[11:00:00.503]                         if (has_future) {
[11:00:00.503]                           ns <- base::getNamespace("future")
[11:00:00.503]                           version <- ns[[".package"]][["version"]]
[11:00:00.503]                           if (is.null(version)) 
[11:00:00.503]                             version <- utils::packageVersion("future")
[11:00:00.503]                         }
[11:00:00.503]                         else {
[11:00:00.503]                           version <- NULL
[11:00:00.503]                         }
[11:00:00.503]                         if (!has_future || version < "1.8.0") {
[11:00:00.503]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:00.503]                             "", base::R.version$version.string), 
[11:00:00.503]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:00.503]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:00.503]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:00.503]                               "release", "version")], collapse = " "), 
[11:00:00.503]                             hostname = base::Sys.info()[["nodename"]])
[11:00:00.503]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:00.503]                             info)
[11:00:00.503]                           info <- base::paste(info, collapse = "; ")
[11:00:00.503]                           if (!has_future) {
[11:00:00.503]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:00.503]                               info)
[11:00:00.503]                           }
[11:00:00.503]                           else {
[11:00:00.503]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:00.503]                               info, version)
[11:00:00.503]                           }
[11:00:00.503]                           base::stop(msg)
[11:00:00.503]                         }
[11:00:00.503]                       })
[11:00:00.503]                     }
[11:00:00.503]                     base::local({
[11:00:00.503]                       for (pkg in "future.apply") {
[11:00:00.503]                         base::loadNamespace(pkg)
[11:00:00.503]                         base::library(pkg, character.only = TRUE)
[11:00:00.503]                       }
[11:00:00.503]                     })
[11:00:00.503]                   }
[11:00:00.503]                   ...future.strategy.old <- future::plan("list")
[11:00:00.503]                   options(future.plan = NULL)
[11:00:00.503]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.503]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:00.503]                 }
[11:00:00.503]                 ...future.workdir <- getwd()
[11:00:00.503]             }
[11:00:00.503]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:00.503]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:00.503]         }
[11:00:00.503]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:00.503]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:00.503]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:00.503]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:00.503]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:00.503]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:00.503]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:00.503]             base::names(...future.oldOptions))
[11:00:00.503]     }
[11:00:00.503]     if (FALSE) {
[11:00:00.503]     }
[11:00:00.503]     else {
[11:00:00.503]         if (TRUE) {
[11:00:00.503]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:00.503]                 open = "w")
[11:00:00.503]         }
[11:00:00.503]         else {
[11:00:00.503]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:00.503]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:00.503]         }
[11:00:00.503]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:00.503]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:00.503]             base::sink(type = "output", split = FALSE)
[11:00:00.503]             base::close(...future.stdout)
[11:00:00.503]         }, add = TRUE)
[11:00:00.503]     }
[11:00:00.503]     ...future.frame <- base::sys.nframe()
[11:00:00.503]     ...future.conditions <- base::list()
[11:00:00.503]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:00.503]     if (FALSE) {
[11:00:00.503]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:00.503]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:00.503]     }
[11:00:00.503]     ...future.result <- base::tryCatch({
[11:00:00.503]         base::withCallingHandlers({
[11:00:00.503]             ...future.value <- base::withVisible(base::local({
[11:00:00.503]                 do.call(function(...) {
[11:00:00.503]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.503]                   if (!identical(...future.globals.maxSize.org, 
[11:00:00.503]                     ...future.globals.maxSize)) {
[11:00:00.503]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.503]                     on.exit(options(oopts), add = TRUE)
[11:00:00.503]                   }
[11:00:00.503]                   {
[11:00:00.503]                     lapply(seq_along(...future.elements_ii), 
[11:00:00.503]                       FUN = function(jj) {
[11:00:00.503]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.503]                         ...future.FUN(...future.X_jj, ...)
[11:00:00.503]                       })
[11:00:00.503]                   }
[11:00:00.503]                 }, args = future.call.arguments)
[11:00:00.503]             }))
[11:00:00.503]             future::FutureResult(value = ...future.value$value, 
[11:00:00.503]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.503]                   ...future.rng), globalenv = if (FALSE) 
[11:00:00.503]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:00.503]                     ...future.globalenv.names))
[11:00:00.503]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:00.503]         }, condition = base::local({
[11:00:00.503]             c <- base::c
[11:00:00.503]             inherits <- base::inherits
[11:00:00.503]             invokeRestart <- base::invokeRestart
[11:00:00.503]             length <- base::length
[11:00:00.503]             list <- base::list
[11:00:00.503]             seq.int <- base::seq.int
[11:00:00.503]             signalCondition <- base::signalCondition
[11:00:00.503]             sys.calls <- base::sys.calls
[11:00:00.503]             `[[` <- base::`[[`
[11:00:00.503]             `+` <- base::`+`
[11:00:00.503]             `<<-` <- base::`<<-`
[11:00:00.503]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:00.503]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:00.503]                   3L)]
[11:00:00.503]             }
[11:00:00.503]             function(cond) {
[11:00:00.503]                 is_error <- inherits(cond, "error")
[11:00:00.503]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:00.503]                   NULL)
[11:00:00.503]                 if (is_error) {
[11:00:00.503]                   sessionInformation <- function() {
[11:00:00.503]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:00.503]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:00.503]                       search = base::search(), system = base::Sys.info())
[11:00:00.503]                   }
[11:00:00.503]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.503]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:00.503]                     cond$call), session = sessionInformation(), 
[11:00:00.503]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:00.503]                   signalCondition(cond)
[11:00:00.503]                 }
[11:00:00.503]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:00.503]                 "immediateCondition"))) {
[11:00:00.503]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:00.503]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.503]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:00.503]                   if (TRUE && !signal) {
[11:00:00.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.503]                     {
[11:00:00.503]                       inherits <- base::inherits
[11:00:00.503]                       invokeRestart <- base::invokeRestart
[11:00:00.503]                       is.null <- base::is.null
[11:00:00.503]                       muffled <- FALSE
[11:00:00.503]                       if (inherits(cond, "message")) {
[11:00:00.503]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.503]                         if (muffled) 
[11:00:00.503]                           invokeRestart("muffleMessage")
[11:00:00.503]                       }
[11:00:00.503]                       else if (inherits(cond, "warning")) {
[11:00:00.503]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.503]                         if (muffled) 
[11:00:00.503]                           invokeRestart("muffleWarning")
[11:00:00.503]                       }
[11:00:00.503]                       else if (inherits(cond, "condition")) {
[11:00:00.503]                         if (!is.null(pattern)) {
[11:00:00.503]                           computeRestarts <- base::computeRestarts
[11:00:00.503]                           grepl <- base::grepl
[11:00:00.503]                           restarts <- computeRestarts(cond)
[11:00:00.503]                           for (restart in restarts) {
[11:00:00.503]                             name <- restart$name
[11:00:00.503]                             if (is.null(name)) 
[11:00:00.503]                               next
[11:00:00.503]                             if (!grepl(pattern, name)) 
[11:00:00.503]                               next
[11:00:00.503]                             invokeRestart(restart)
[11:00:00.503]                             muffled <- TRUE
[11:00:00.503]                             break
[11:00:00.503]                           }
[11:00:00.503]                         }
[11:00:00.503]                       }
[11:00:00.503]                       invisible(muffled)
[11:00:00.503]                     }
[11:00:00.503]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.503]                   }
[11:00:00.503]                 }
[11:00:00.503]                 else {
[11:00:00.503]                   if (TRUE) {
[11:00:00.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.503]                     {
[11:00:00.503]                       inherits <- base::inherits
[11:00:00.503]                       invokeRestart <- base::invokeRestart
[11:00:00.503]                       is.null <- base::is.null
[11:00:00.503]                       muffled <- FALSE
[11:00:00.503]                       if (inherits(cond, "message")) {
[11:00:00.503]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.503]                         if (muffled) 
[11:00:00.503]                           invokeRestart("muffleMessage")
[11:00:00.503]                       }
[11:00:00.503]                       else if (inherits(cond, "warning")) {
[11:00:00.503]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.503]                         if (muffled) 
[11:00:00.503]                           invokeRestart("muffleWarning")
[11:00:00.503]                       }
[11:00:00.503]                       else if (inherits(cond, "condition")) {
[11:00:00.503]                         if (!is.null(pattern)) {
[11:00:00.503]                           computeRestarts <- base::computeRestarts
[11:00:00.503]                           grepl <- base::grepl
[11:00:00.503]                           restarts <- computeRestarts(cond)
[11:00:00.503]                           for (restart in restarts) {
[11:00:00.503]                             name <- restart$name
[11:00:00.503]                             if (is.null(name)) 
[11:00:00.503]                               next
[11:00:00.503]                             if (!grepl(pattern, name)) 
[11:00:00.503]                               next
[11:00:00.503]                             invokeRestart(restart)
[11:00:00.503]                             muffled <- TRUE
[11:00:00.503]                             break
[11:00:00.503]                           }
[11:00:00.503]                         }
[11:00:00.503]                       }
[11:00:00.503]                       invisible(muffled)
[11:00:00.503]                     }
[11:00:00.503]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.503]                   }
[11:00:00.503]                 }
[11:00:00.503]             }
[11:00:00.503]         }))
[11:00:00.503]     }, error = function(ex) {
[11:00:00.503]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:00.503]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.503]                 ...future.rng), started = ...future.startTime, 
[11:00:00.503]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:00.503]             version = "1.8"), class = "FutureResult")
[11:00:00.503]     }, finally = {
[11:00:00.503]         if (!identical(...future.workdir, getwd())) 
[11:00:00.503]             setwd(...future.workdir)
[11:00:00.503]         {
[11:00:00.503]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:00.503]                 ...future.oldOptions$nwarnings <- NULL
[11:00:00.503]             }
[11:00:00.503]             base::options(...future.oldOptions)
[11:00:00.503]             if (.Platform$OS.type == "windows") {
[11:00:00.503]                 old_names <- names(...future.oldEnvVars)
[11:00:00.503]                 envs <- base::Sys.getenv()
[11:00:00.503]                 names <- names(envs)
[11:00:00.503]                 common <- intersect(names, old_names)
[11:00:00.503]                 added <- setdiff(names, old_names)
[11:00:00.503]                 removed <- setdiff(old_names, names)
[11:00:00.503]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:00.503]                   envs[common]]
[11:00:00.503]                 NAMES <- toupper(changed)
[11:00:00.503]                 args <- list()
[11:00:00.503]                 for (kk in seq_along(NAMES)) {
[11:00:00.503]                   name <- changed[[kk]]
[11:00:00.503]                   NAME <- NAMES[[kk]]
[11:00:00.503]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.503]                     next
[11:00:00.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.503]                 }
[11:00:00.503]                 NAMES <- toupper(added)
[11:00:00.503]                 for (kk in seq_along(NAMES)) {
[11:00:00.503]                   name <- added[[kk]]
[11:00:00.503]                   NAME <- NAMES[[kk]]
[11:00:00.503]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.503]                     next
[11:00:00.503]                   args[[name]] <- ""
[11:00:00.503]                 }
[11:00:00.503]                 NAMES <- toupper(removed)
[11:00:00.503]                 for (kk in seq_along(NAMES)) {
[11:00:00.503]                   name <- removed[[kk]]
[11:00:00.503]                   NAME <- NAMES[[kk]]
[11:00:00.503]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.503]                     next
[11:00:00.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.503]                 }
[11:00:00.503]                 if (length(args) > 0) 
[11:00:00.503]                   base::do.call(base::Sys.setenv, args = args)
[11:00:00.503]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:00.503]             }
[11:00:00.503]             else {
[11:00:00.503]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:00.503]             }
[11:00:00.503]             {
[11:00:00.503]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:00.503]                   0L) {
[11:00:00.503]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:00.503]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:00.503]                   base::options(opts)
[11:00:00.503]                 }
[11:00:00.503]                 {
[11:00:00.503]                   {
[11:00:00.503]                     NULL
[11:00:00.503]                     RNGkind("Mersenne-Twister")
[11:00:00.503]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:00.503]                       inherits = FALSE)
[11:00:00.503]                   }
[11:00:00.503]                   options(future.plan = NULL)
[11:00:00.503]                   if (is.na(NA_character_)) 
[11:00:00.503]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.503]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:00.503]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:00.503]                     .init = FALSE)
[11:00:00.503]                 }
[11:00:00.503]             }
[11:00:00.503]         }
[11:00:00.503]     })
[11:00:00.503]     if (TRUE) {
[11:00:00.503]         base::sink(type = "output", split = FALSE)
[11:00:00.503]         if (TRUE) {
[11:00:00.503]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:00.503]         }
[11:00:00.503]         else {
[11:00:00.503]             ...future.result["stdout"] <- base::list(NULL)
[11:00:00.503]         }
[11:00:00.503]         base::close(...future.stdout)
[11:00:00.503]         ...future.stdout <- NULL
[11:00:00.503]     }
[11:00:00.503]     ...future.result$conditions <- ...future.conditions
[11:00:00.503]     ...future.result$finished <- base::Sys.time()
[11:00:00.503]     ...future.result
[11:00:00.503] }
[11:00:00.505] assign_globals() ...
[11:00:00.505] List of 11
[11:00:00.505]  $ ...future.FUN            :function (x, ...)  
[11:00:00.505]  $ x_FUN                    :function (x)  
[11:00:00.505]  $ times                    : int 4
[11:00:00.505]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.505]  $ stop_if_not              :function (...)  
[11:00:00.505]  $ dim                      : int [1:2] 2 2
[11:00:00.505]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:00.505]  $ future.call.arguments    : list()
[11:00:00.505]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.505]  $ ...future.elements_ii    :List of 10
[11:00:00.505]   ..$ : int 1
[11:00:00.505]   ..$ : int 2
[11:00:00.505]   ..$ : int 3
[11:00:00.505]   ..$ : int 4
[11:00:00.505]   ..$ : int 5
[11:00:00.505]   ..$ : int 6
[11:00:00.505]   ..$ : int 7
[11:00:00.505]   ..$ : int 8
[11:00:00.505]   ..$ : int 9
[11:00:00.505]   ..$ : int 10
[11:00:00.505]  $ ...future.seeds_ii       : NULL
[11:00:00.505]  $ ...future.globals.maxSize: NULL
[11:00:00.505]  - attr(*, "where")=List of 11
[11:00:00.505]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:00.505]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:00.505]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:00.505]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:00.505]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:00.505]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:00.505]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:00.505]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:00.505]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:00.505]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:00.505]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:00.505]  - attr(*, "resolved")= logi FALSE
[11:00:00.505]  - attr(*, "total_size")= num 24958
[11:00:00.505]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.505]  - attr(*, "already-done")= logi TRUE
[11:00:00.515] - copied ‘...future.FUN’ to environment
[11:00:00.515] - reassign environment for ‘x_FUN’
[11:00:00.515] - copied ‘x_FUN’ to environment
[11:00:00.515] - copied ‘times’ to environment
[11:00:00.515] - copied ‘stopf’ to environment
[11:00:00.515] - copied ‘stop_if_not’ to environment
[11:00:00.515] - copied ‘dim’ to environment
[11:00:00.515] - copied ‘valid_types’ to environment
[11:00:00.515] - copied ‘future.call.arguments’ to environment
[11:00:00.515] - copied ‘...future.elements_ii’ to environment
[11:00:00.515] - copied ‘...future.seeds_ii’ to environment
[11:00:00.516] - copied ‘...future.globals.maxSize’ to environment
[11:00:00.516] assign_globals() ... done
[11:00:00.516] plan(): Setting new future strategy stack:
[11:00:00.516] List of future strategies:
[11:00:00.516] 1. sequential:
[11:00:00.516]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.516]    - tweaked: FALSE
[11:00:00.516]    - call: NULL
[11:00:00.516] plan(): nbrOfWorkers() = 1
[11:00:00.517] plan(): Setting new future strategy stack:
[11:00:00.517] List of future strategies:
[11:00:00.517] 1. sequential:
[11:00:00.517]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.517]    - tweaked: FALSE
[11:00:00.517]    - call: plan(strategy)
[11:00:00.518] plan(): nbrOfWorkers() = 1
[11:00:00.518] SequentialFuture started (and completed)
[11:00:00.518] - Launch lazy future ... done
[11:00:00.518] run() for ‘SequentialFuture’ ... done
[11:00:00.518] Created future:
[11:00:00.518] SequentialFuture:
[11:00:00.518] Label: ‘future_vapply-1’
[11:00:00.518] Expression:
[11:00:00.518] {
[11:00:00.518]     do.call(function(...) {
[11:00:00.518]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.518]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.518]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.518]             on.exit(options(oopts), add = TRUE)
[11:00:00.518]         }
[11:00:00.518]         {
[11:00:00.518]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.518]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.518]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.518]             })
[11:00:00.518]         }
[11:00:00.518]     }, args = future.call.arguments)
[11:00:00.518] }
[11:00:00.518] Lazy evaluation: FALSE
[11:00:00.518] Asynchronous evaluation: FALSE
[11:00:00.518] Local evaluation: TRUE
[11:00:00.518] Environment: R_GlobalEnv
[11:00:00.518] Capture standard output: TRUE
[11:00:00.518] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:00.518] Globals: 11 objects totaling 13.92 KiB (function ‘...future.FUN’ of 5.08 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:00.518] Packages: 1 packages (‘future.apply’)
[11:00:00.518] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:00.518] Resolved: TRUE
[11:00:00.518] Value: 562 bytes of class ‘list’
[11:00:00.518] Early signaling: FALSE
[11:00:00.518] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:00.518] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.519] Chunk #1 of 1 ... DONE
[11:00:00.519] Launching 1 futures (chunks) ... DONE
[11:00:00.519] Resolving 1 futures (chunks) ...
[11:00:00.519] resolve() on list ...
[11:00:00.519]  recursive: 0
[11:00:00.519]  length: 1
[11:00:00.520] 
[11:00:00.520] resolved() for ‘SequentialFuture’ ...
[11:00:00.520] - state: ‘finished’
[11:00:00.520] - run: TRUE
[11:00:00.520] - result: ‘FutureResult’
[11:00:00.520] resolved() for ‘SequentialFuture’ ... done
[11:00:00.520] Future #1
[11:00:00.520] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:00.520] - nx: 1
[11:00:00.520] - relay: TRUE
[11:00:00.520] - stdout: TRUE
[11:00:00.521] - signal: TRUE
[11:00:00.521] - resignal: FALSE
[11:00:00.521] - force: TRUE
[11:00:00.521] - relayed: [n=1] FALSE
[11:00:00.521] - queued futures: [n=1] FALSE
[11:00:00.521]  - until=1
[11:00:00.521]  - relaying element #1
[11:00:00.521] - relayed: [n=1] TRUE
[11:00:00.521] - queued futures: [n=1] TRUE
[11:00:00.521] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:00.521]  length: 0 (resolved future 1)
[11:00:00.521] Relaying remaining futures
[11:00:00.522] signalConditionsASAP(NULL, pos=0) ...
[11:00:00.522] - nx: 1
[11:00:00.522] - relay: TRUE
[11:00:00.522] - stdout: TRUE
[11:00:00.522] - signal: TRUE
[11:00:00.522] - resignal: FALSE
[11:00:00.522] - force: TRUE
[11:00:00.522] - relayed: [n=1] TRUE
[11:00:00.522] - queued futures: [n=1] TRUE
 - flush all
[11:00:00.522] - relayed: [n=1] TRUE
[11:00:00.522] - queued futures: [n=1] TRUE
[11:00:00.522] signalConditionsASAP(NULL, pos=0) ... done
[11:00:00.522] resolve() on list ... DONE
[11:00:00.523]  - Number of value chunks collected: 1
[11:00:00.523] Resolving 1 futures (chunks) ... DONE
[11:00:00.523] Reducing values from 1 chunks ...
[11:00:00.523]  - Number of values collected after concatenation: 10
[11:00:00.523]  - Number of values expected: 10
[11:00:00.523] Reducing values from 1 chunks ... DONE
[11:00:00.523] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[11:00:00.525] future_lapply() ...
[11:00:00.526] Number of chunks: 1
[11:00:00.526] getGlobalsAndPackagesXApply() ...
[11:00:00.526]  - future.globals: TRUE
[11:00:00.527] getGlobalsAndPackages() ...
[11:00:00.527] Searching for globals...
[11:00:00.553] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[11:00:00.554] Searching for globals ... DONE
[11:00:00.554] Resolving globals: FALSE
[11:00:00.555] The total size of the 7 globals is 16.05 KiB (16436 bytes)
[11:00:00.555] The total size of the 7 globals exported for future expression (‘FUN()’) is 16.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (6.71 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:00.555] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.555] - packages: [1] ‘future.apply’
[11:00:00.555] getGlobalsAndPackages() ... DONE
[11:00:00.555]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.555]  - needed namespaces: [n=1] ‘future.apply’
[11:00:00.556] Finding globals ... DONE
[11:00:00.556]  - use_args: TRUE
[11:00:00.556]  - Getting '...' globals ...
[11:00:00.556] resolve() on list ...
[11:00:00.556]  recursive: 0
[11:00:00.556]  length: 1
[11:00:00.556]  elements: ‘...’
[11:00:00.556]  length: 0 (resolved future 1)
[11:00:00.556] resolve() on list ... DONE
[11:00:00.557]    - '...' content: [n=0] 
[11:00:00.557] List of 1
[11:00:00.557]  $ ...: list()
[11:00:00.557]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.557]  - attr(*, "where")=List of 1
[11:00:00.557]   ..$ ...:<environment: 0x55bbad6a2d98> 
[11:00:00.557]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.557]  - attr(*, "resolved")= logi TRUE
[11:00:00.557]  - attr(*, "total_size")= num NA
[11:00:00.559]  - Getting '...' globals ... DONE
[11:00:00.559] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:00.559] List of 8
[11:00:00.559]  $ ...future.FUN:function (x, ...)  
[11:00:00.559]  $ x_FUN        :function (x)  
[11:00:00.559]  $ times        : int 4
[11:00:00.559]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.559]  $ stop_if_not  :function (...)  
[11:00:00.559]  $ dim          : int [1:2] 2 2
[11:00:00.559]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:00.559]  $ ...          : list()
[11:00:00.559]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.559]  - attr(*, "where")=List of 8
[11:00:00.559]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:00.559]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:00.559]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:00.559]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:00.559]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:00.559]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:00.559]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:00.559]   ..$ ...          :<environment: 0x55bbad6a2d98> 
[11:00:00.559]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.559]  - attr(*, "resolved")= logi FALSE
[11:00:00.559]  - attr(*, "total_size")= num 29094
[11:00:00.564] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:00.564] getGlobalsAndPackagesXApply() ... DONE
[11:00:00.565] Number of futures (= number of chunks): 1
[11:00:00.565] Launching 1 futures (chunks) ...
[11:00:00.565] Chunk #1 of 1 ...
[11:00:00.565]  - Finding globals in 'X' for chunk #1 ...
[11:00:00.565] getGlobalsAndPackages() ...
[11:00:00.565] Searching for globals...
[11:00:00.565] 
[11:00:00.565] Searching for globals ... DONE
[11:00:00.566] - globals: [0] <none>
[11:00:00.566] getGlobalsAndPackages() ... DONE
[11:00:00.566]    + additional globals found: [n=0] 
[11:00:00.566]    + additional namespaces needed: [n=0] 
[11:00:00.566]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:00.566]  - seeds: <none>
[11:00:00.566]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.566] getGlobalsAndPackages() ...
[11:00:00.566] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.566] Resolving globals: FALSE
[11:00:00.566] Tweak future expression to call with '...' arguments ...
[11:00:00.566] {
[11:00:00.566]     do.call(function(...) {
[11:00:00.566]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.566]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.566]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.566]             on.exit(options(oopts), add = TRUE)
[11:00:00.566]         }
[11:00:00.566]         {
[11:00:00.566]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.566]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.566]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.566]             })
[11:00:00.566]         }
[11:00:00.566]     }, args = future.call.arguments)
[11:00:00.566] }
[11:00:00.567] Tweak future expression to call with '...' arguments ... DONE
[11:00:00.567] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.567] - packages: [1] ‘future.apply’
[11:00:00.567] getGlobalsAndPackages() ... DONE
[11:00:00.568] run() for ‘Future’ ...
[11:00:00.568] - state: ‘created’
[11:00:00.568] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:00.568] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.568] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:00.568]   - Field: ‘label’
[11:00:00.568]   - Field: ‘local’
[11:00:00.569]   - Field: ‘owner’
[11:00:00.569]   - Field: ‘envir’
[11:00:00.569]   - Field: ‘packages’
[11:00:00.569]   - Field: ‘gc’
[11:00:00.569]   - Field: ‘conditions’
[11:00:00.569]   - Field: ‘expr’
[11:00:00.569]   - Field: ‘uuid’
[11:00:00.569]   - Field: ‘seed’
[11:00:00.569]   - Field: ‘version’
[11:00:00.569]   - Field: ‘result’
[11:00:00.569]   - Field: ‘asynchronous’
[11:00:00.569]   - Field: ‘calls’
[11:00:00.570]   - Field: ‘globals’
[11:00:00.570]   - Field: ‘stdout’
[11:00:00.570]   - Field: ‘earlySignal’
[11:00:00.570]   - Field: ‘lazy’
[11:00:00.570]   - Field: ‘state’
[11:00:00.570] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:00.570] - Launch lazy future ...
[11:00:00.570] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:00.570] Packages needed by future strategies (n = 0): <none>
[11:00:00.571] {
[11:00:00.571]     {
[11:00:00.571]         {
[11:00:00.571]             ...future.startTime <- base::Sys.time()
[11:00:00.571]             {
[11:00:00.571]                 {
[11:00:00.571]                   {
[11:00:00.571]                     {
[11:00:00.571]                       base::local({
[11:00:00.571]                         has_future <- base::requireNamespace("future", 
[11:00:00.571]                           quietly = TRUE)
[11:00:00.571]                         if (has_future) {
[11:00:00.571]                           ns <- base::getNamespace("future")
[11:00:00.571]                           version <- ns[[".package"]][["version"]]
[11:00:00.571]                           if (is.null(version)) 
[11:00:00.571]                             version <- utils::packageVersion("future")
[11:00:00.571]                         }
[11:00:00.571]                         else {
[11:00:00.571]                           version <- NULL
[11:00:00.571]                         }
[11:00:00.571]                         if (!has_future || version < "1.8.0") {
[11:00:00.571]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:00.571]                             "", base::R.version$version.string), 
[11:00:00.571]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:00.571]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:00.571]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:00.571]                               "release", "version")], collapse = " "), 
[11:00:00.571]                             hostname = base::Sys.info()[["nodename"]])
[11:00:00.571]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:00.571]                             info)
[11:00:00.571]                           info <- base::paste(info, collapse = "; ")
[11:00:00.571]                           if (!has_future) {
[11:00:00.571]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:00.571]                               info)
[11:00:00.571]                           }
[11:00:00.571]                           else {
[11:00:00.571]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:00.571]                               info, version)
[11:00:00.571]                           }
[11:00:00.571]                           base::stop(msg)
[11:00:00.571]                         }
[11:00:00.571]                       })
[11:00:00.571]                     }
[11:00:00.571]                     base::local({
[11:00:00.571]                       for (pkg in "future.apply") {
[11:00:00.571]                         base::loadNamespace(pkg)
[11:00:00.571]                         base::library(pkg, character.only = TRUE)
[11:00:00.571]                       }
[11:00:00.571]                     })
[11:00:00.571]                   }
[11:00:00.571]                   ...future.strategy.old <- future::plan("list")
[11:00:00.571]                   options(future.plan = NULL)
[11:00:00.571]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.571]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:00.571]                 }
[11:00:00.571]                 ...future.workdir <- getwd()
[11:00:00.571]             }
[11:00:00.571]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:00.571]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:00.571]         }
[11:00:00.571]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:00.571]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:00.571]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:00.571]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:00.571]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:00.571]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:00.571]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:00.571]             base::names(...future.oldOptions))
[11:00:00.571]     }
[11:00:00.571]     if (FALSE) {
[11:00:00.571]     }
[11:00:00.571]     else {
[11:00:00.571]         if (TRUE) {
[11:00:00.571]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:00.571]                 open = "w")
[11:00:00.571]         }
[11:00:00.571]         else {
[11:00:00.571]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:00.571]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:00.571]         }
[11:00:00.571]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:00.571]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:00.571]             base::sink(type = "output", split = FALSE)
[11:00:00.571]             base::close(...future.stdout)
[11:00:00.571]         }, add = TRUE)
[11:00:00.571]     }
[11:00:00.571]     ...future.frame <- base::sys.nframe()
[11:00:00.571]     ...future.conditions <- base::list()
[11:00:00.571]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:00.571]     if (FALSE) {
[11:00:00.571]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:00.571]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:00.571]     }
[11:00:00.571]     ...future.result <- base::tryCatch({
[11:00:00.571]         base::withCallingHandlers({
[11:00:00.571]             ...future.value <- base::withVisible(base::local({
[11:00:00.571]                 do.call(function(...) {
[11:00:00.571]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.571]                   if (!identical(...future.globals.maxSize.org, 
[11:00:00.571]                     ...future.globals.maxSize)) {
[11:00:00.571]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.571]                     on.exit(options(oopts), add = TRUE)
[11:00:00.571]                   }
[11:00:00.571]                   {
[11:00:00.571]                     lapply(seq_along(...future.elements_ii), 
[11:00:00.571]                       FUN = function(jj) {
[11:00:00.571]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.571]                         ...future.FUN(...future.X_jj, ...)
[11:00:00.571]                       })
[11:00:00.571]                   }
[11:00:00.571]                 }, args = future.call.arguments)
[11:00:00.571]             }))
[11:00:00.571]             future::FutureResult(value = ...future.value$value, 
[11:00:00.571]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.571]                   ...future.rng), globalenv = if (FALSE) 
[11:00:00.571]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:00.571]                     ...future.globalenv.names))
[11:00:00.571]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:00.571]         }, condition = base::local({
[11:00:00.571]             c <- base::c
[11:00:00.571]             inherits <- base::inherits
[11:00:00.571]             invokeRestart <- base::invokeRestart
[11:00:00.571]             length <- base::length
[11:00:00.571]             list <- base::list
[11:00:00.571]             seq.int <- base::seq.int
[11:00:00.571]             signalCondition <- base::signalCondition
[11:00:00.571]             sys.calls <- base::sys.calls
[11:00:00.571]             `[[` <- base::`[[`
[11:00:00.571]             `+` <- base::`+`
[11:00:00.571]             `<<-` <- base::`<<-`
[11:00:00.571]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:00.571]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:00.571]                   3L)]
[11:00:00.571]             }
[11:00:00.571]             function(cond) {
[11:00:00.571]                 is_error <- inherits(cond, "error")
[11:00:00.571]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:00.571]                   NULL)
[11:00:00.571]                 if (is_error) {
[11:00:00.571]                   sessionInformation <- function() {
[11:00:00.571]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:00.571]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:00.571]                       search = base::search(), system = base::Sys.info())
[11:00:00.571]                   }
[11:00:00.571]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.571]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:00.571]                     cond$call), session = sessionInformation(), 
[11:00:00.571]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:00.571]                   signalCondition(cond)
[11:00:00.571]                 }
[11:00:00.571]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:00.571]                 "immediateCondition"))) {
[11:00:00.571]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:00.571]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.571]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:00.571]                   if (TRUE && !signal) {
[11:00:00.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.571]                     {
[11:00:00.571]                       inherits <- base::inherits
[11:00:00.571]                       invokeRestart <- base::invokeRestart
[11:00:00.571]                       is.null <- base::is.null
[11:00:00.571]                       muffled <- FALSE
[11:00:00.571]                       if (inherits(cond, "message")) {
[11:00:00.571]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.571]                         if (muffled) 
[11:00:00.571]                           invokeRestart("muffleMessage")
[11:00:00.571]                       }
[11:00:00.571]                       else if (inherits(cond, "warning")) {
[11:00:00.571]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.571]                         if (muffled) 
[11:00:00.571]                           invokeRestart("muffleWarning")
[11:00:00.571]                       }
[11:00:00.571]                       else if (inherits(cond, "condition")) {
[11:00:00.571]                         if (!is.null(pattern)) {
[11:00:00.571]                           computeRestarts <- base::computeRestarts
[11:00:00.571]                           grepl <- base::grepl
[11:00:00.571]                           restarts <- computeRestarts(cond)
[11:00:00.571]                           for (restart in restarts) {
[11:00:00.571]                             name <- restart$name
[11:00:00.571]                             if (is.null(name)) 
[11:00:00.571]                               next
[11:00:00.571]                             if (!grepl(pattern, name)) 
[11:00:00.571]                               next
[11:00:00.571]                             invokeRestart(restart)
[11:00:00.571]                             muffled <- TRUE
[11:00:00.571]                             break
[11:00:00.571]                           }
[11:00:00.571]                         }
[11:00:00.571]                       }
[11:00:00.571]                       invisible(muffled)
[11:00:00.571]                     }
[11:00:00.571]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.571]                   }
[11:00:00.571]                 }
[11:00:00.571]                 else {
[11:00:00.571]                   if (TRUE) {
[11:00:00.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.571]                     {
[11:00:00.571]                       inherits <- base::inherits
[11:00:00.571]                       invokeRestart <- base::invokeRestart
[11:00:00.571]                       is.null <- base::is.null
[11:00:00.571]                       muffled <- FALSE
[11:00:00.571]                       if (inherits(cond, "message")) {
[11:00:00.571]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.571]                         if (muffled) 
[11:00:00.571]                           invokeRestart("muffleMessage")
[11:00:00.571]                       }
[11:00:00.571]                       else if (inherits(cond, "warning")) {
[11:00:00.571]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.571]                         if (muffled) 
[11:00:00.571]                           invokeRestart("muffleWarning")
[11:00:00.571]                       }
[11:00:00.571]                       else if (inherits(cond, "condition")) {
[11:00:00.571]                         if (!is.null(pattern)) {
[11:00:00.571]                           computeRestarts <- base::computeRestarts
[11:00:00.571]                           grepl <- base::grepl
[11:00:00.571]                           restarts <- computeRestarts(cond)
[11:00:00.571]                           for (restart in restarts) {
[11:00:00.571]                             name <- restart$name
[11:00:00.571]                             if (is.null(name)) 
[11:00:00.571]                               next
[11:00:00.571]                             if (!grepl(pattern, name)) 
[11:00:00.571]                               next
[11:00:00.571]                             invokeRestart(restart)
[11:00:00.571]                             muffled <- TRUE
[11:00:00.571]                             break
[11:00:00.571]                           }
[11:00:00.571]                         }
[11:00:00.571]                       }
[11:00:00.571]                       invisible(muffled)
[11:00:00.571]                     }
[11:00:00.571]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.571]                   }
[11:00:00.571]                 }
[11:00:00.571]             }
[11:00:00.571]         }))
[11:00:00.571]     }, error = function(ex) {
[11:00:00.571]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:00.571]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.571]                 ...future.rng), started = ...future.startTime, 
[11:00:00.571]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:00.571]             version = "1.8"), class = "FutureResult")
[11:00:00.571]     }, finally = {
[11:00:00.571]         if (!identical(...future.workdir, getwd())) 
[11:00:00.571]             setwd(...future.workdir)
[11:00:00.571]         {
[11:00:00.571]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:00.571]                 ...future.oldOptions$nwarnings <- NULL
[11:00:00.571]             }
[11:00:00.571]             base::options(...future.oldOptions)
[11:00:00.571]             if (.Platform$OS.type == "windows") {
[11:00:00.571]                 old_names <- names(...future.oldEnvVars)
[11:00:00.571]                 envs <- base::Sys.getenv()
[11:00:00.571]                 names <- names(envs)
[11:00:00.571]                 common <- intersect(names, old_names)
[11:00:00.571]                 added <- setdiff(names, old_names)
[11:00:00.571]                 removed <- setdiff(old_names, names)
[11:00:00.571]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:00.571]                   envs[common]]
[11:00:00.571]                 NAMES <- toupper(changed)
[11:00:00.571]                 args <- list()
[11:00:00.571]                 for (kk in seq_along(NAMES)) {
[11:00:00.571]                   name <- changed[[kk]]
[11:00:00.571]                   NAME <- NAMES[[kk]]
[11:00:00.571]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.571]                     next
[11:00:00.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.571]                 }
[11:00:00.571]                 NAMES <- toupper(added)
[11:00:00.571]                 for (kk in seq_along(NAMES)) {
[11:00:00.571]                   name <- added[[kk]]
[11:00:00.571]                   NAME <- NAMES[[kk]]
[11:00:00.571]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.571]                     next
[11:00:00.571]                   args[[name]] <- ""
[11:00:00.571]                 }
[11:00:00.571]                 NAMES <- toupper(removed)
[11:00:00.571]                 for (kk in seq_along(NAMES)) {
[11:00:00.571]                   name <- removed[[kk]]
[11:00:00.571]                   NAME <- NAMES[[kk]]
[11:00:00.571]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.571]                     next
[11:00:00.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.571]                 }
[11:00:00.571]                 if (length(args) > 0) 
[11:00:00.571]                   base::do.call(base::Sys.setenv, args = args)
[11:00:00.571]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:00.571]             }
[11:00:00.571]             else {
[11:00:00.571]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:00.571]             }
[11:00:00.571]             {
[11:00:00.571]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:00.571]                   0L) {
[11:00:00.571]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:00.571]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:00.571]                   base::options(opts)
[11:00:00.571]                 }
[11:00:00.571]                 {
[11:00:00.571]                   {
[11:00:00.571]                     NULL
[11:00:00.571]                     RNGkind("Mersenne-Twister")
[11:00:00.571]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:00.571]                       inherits = FALSE)
[11:00:00.571]                   }
[11:00:00.571]                   options(future.plan = NULL)
[11:00:00.571]                   if (is.na(NA_character_)) 
[11:00:00.571]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.571]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:00.571]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:00.571]                     .init = FALSE)
[11:00:00.571]                 }
[11:00:00.571]             }
[11:00:00.571]         }
[11:00:00.571]     })
[11:00:00.571]     if (TRUE) {
[11:00:00.571]         base::sink(type = "output", split = FALSE)
[11:00:00.571]         if (TRUE) {
[11:00:00.571]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:00.571]         }
[11:00:00.571]         else {
[11:00:00.571]             ...future.result["stdout"] <- base::list(NULL)
[11:00:00.571]         }
[11:00:00.571]         base::close(...future.stdout)
[11:00:00.571]         ...future.stdout <- NULL
[11:00:00.571]     }
[11:00:00.571]     ...future.result$conditions <- ...future.conditions
[11:00:00.571]     ...future.result$finished <- base::Sys.time()
[11:00:00.571]     ...future.result
[11:00:00.571] }
[11:00:00.573] assign_globals() ...
[11:00:00.573] List of 11
[11:00:00.573]  $ ...future.FUN            :function (x, ...)  
[11:00:00.573]  $ x_FUN                    :function (x)  
[11:00:00.573]  $ times                    : int 4
[11:00:00.573]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.573]  $ stop_if_not              :function (...)  
[11:00:00.573]  $ dim                      : int [1:2] 2 2
[11:00:00.573]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:00.573]  $ future.call.arguments    : list()
[11:00:00.573]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.573]  $ ...future.elements_ii    :List of 10
[11:00:00.573]   ..$ : int 1
[11:00:00.573]   ..$ : int 2
[11:00:00.573]   ..$ : int 3
[11:00:00.573]   ..$ : int 4
[11:00:00.573]   ..$ : int 5
[11:00:00.573]   ..$ : int 6
[11:00:00.573]   ..$ : int 7
[11:00:00.573]   ..$ : int 8
[11:00:00.573]   ..$ : int 9
[11:00:00.573]   ..$ : int 10
[11:00:00.573]  $ ...future.seeds_ii       : NULL
[11:00:00.573]  $ ...future.globals.maxSize: NULL
[11:00:00.573]  - attr(*, "where")=List of 11
[11:00:00.573]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:00.573]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:00.573]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:00.573]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:00.573]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:00.573]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:00.573]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:00.573]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:00.573]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:00.573]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:00.573]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:00.573]  - attr(*, "resolved")= logi FALSE
[11:00:00.573]  - attr(*, "total_size")= num 29094
[11:00:00.573]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.573]  - attr(*, "already-done")= logi TRUE
[11:00:00.583] - copied ‘...future.FUN’ to environment
[11:00:00.583] - reassign environment for ‘x_FUN’
[11:00:00.583] - copied ‘x_FUN’ to environment
[11:00:00.583] - copied ‘times’ to environment
[11:00:00.583] - copied ‘stopf’ to environment
[11:00:00.583] - copied ‘stop_if_not’ to environment
[11:00:00.583] - copied ‘dim’ to environment
[11:00:00.583] - copied ‘valid_types’ to environment
[11:00:00.583] - copied ‘future.call.arguments’ to environment
[11:00:00.584] - copied ‘...future.elements_ii’ to environment
[11:00:00.584] - copied ‘...future.seeds_ii’ to environment
[11:00:00.584] - copied ‘...future.globals.maxSize’ to environment
[11:00:00.584] assign_globals() ... done
[11:00:00.584] plan(): Setting new future strategy stack:
[11:00:00.584] List of future strategies:
[11:00:00.584] 1. sequential:
[11:00:00.584]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.584]    - tweaked: FALSE
[11:00:00.584]    - call: NULL
[11:00:00.585] plan(): nbrOfWorkers() = 1
[11:00:00.585] plan(): Setting new future strategy stack:
[11:00:00.586] List of future strategies:
[11:00:00.586] 1. sequential:
[11:00:00.586]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.586]    - tweaked: FALSE
[11:00:00.586]    - call: plan(strategy)
[11:00:00.586] plan(): nbrOfWorkers() = 1
[11:00:00.586] SequentialFuture started (and completed)
[11:00:00.586] - Launch lazy future ... done
[11:00:00.586] run() for ‘SequentialFuture’ ... done
[11:00:00.586] Created future:
[11:00:00.586] SequentialFuture:
[11:00:00.586] Label: ‘future_vapply-1’
[11:00:00.586] Expression:
[11:00:00.586] {
[11:00:00.586]     do.call(function(...) {
[11:00:00.586]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.586]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.586]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.586]             on.exit(options(oopts), add = TRUE)
[11:00:00.586]         }
[11:00:00.586]         {
[11:00:00.586]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.586]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.586]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.586]             })
[11:00:00.586]         }
[11:00:00.586]     }, args = future.call.arguments)
[11:00:00.586] }
[11:00:00.586] Lazy evaluation: FALSE
[11:00:00.586] Asynchronous evaluation: FALSE
[11:00:00.586] Local evaluation: TRUE
[11:00:00.586] Environment: R_GlobalEnv
[11:00:00.586] Capture standard output: TRUE
[11:00:00.586] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:00.586] Globals: 11 objects totaling 16.34 KiB (function ‘...future.FUN’ of 6.70 KiB, function ‘x_FUN’ of 1.36 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:00.586] Packages: 1 packages (‘future.apply’)
[11:00:00.586] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:00.586] Resolved: TRUE
[11:00:00.586] Value: 1.23 KiB of class ‘list’
[11:00:00.586] Early signaling: FALSE
[11:00:00.586] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:00.586] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.587] Chunk #1 of 1 ... DONE
[11:00:00.587] Launching 1 futures (chunks) ... DONE
[11:00:00.587] Resolving 1 futures (chunks) ...
[11:00:00.588] resolve() on list ...
[11:00:00.588]  recursive: 0
[11:00:00.588]  length: 1
[11:00:00.588] 
[11:00:00.588] resolved() for ‘SequentialFuture’ ...
[11:00:00.588] - state: ‘finished’
[11:00:00.588] - run: TRUE
[11:00:00.588] - result: ‘FutureResult’
[11:00:00.588] resolved() for ‘SequentialFuture’ ... done
[11:00:00.588] Future #1
[11:00:00.588] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:00.588] - nx: 1
[11:00:00.589] - relay: TRUE
[11:00:00.589] - stdout: TRUE
[11:00:00.589] - signal: TRUE
[11:00:00.589] - resignal: FALSE
[11:00:00.589] - force: TRUE
[11:00:00.589] - relayed: [n=1] FALSE
[11:00:00.589] - queued futures: [n=1] FALSE
[11:00:00.589]  - until=1
[11:00:00.589]  - relaying element #1
[11:00:00.589] - relayed: [n=1] TRUE
[11:00:00.589] - queued futures: [n=1] TRUE
[11:00:00.590] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:00.590]  length: 0 (resolved future 1)
[11:00:00.590] Relaying remaining futures
[11:00:00.590] signalConditionsASAP(NULL, pos=0) ...
[11:00:00.590] - nx: 1
[11:00:00.590] - relay: TRUE
[11:00:00.590] - stdout: TRUE
[11:00:00.590] - signal: TRUE
[11:00:00.590] - resignal: FALSE
[11:00:00.590] - force: TRUE
[11:00:00.590] - relayed: [n=1] TRUE
[11:00:00.590] - queued futures: [n=1] TRUE
 - flush all
[11:00:00.590] - relayed: [n=1] TRUE
[11:00:00.591] - queued futures: [n=1] TRUE
[11:00:00.591] signalConditionsASAP(NULL, pos=0) ... done
[11:00:00.591] resolve() on list ... DONE
[11:00:00.591]  - Number of value chunks collected: 1
[11:00:00.591] Resolving 1 futures (chunks) ... DONE
[11:00:00.591] Reducing values from 1 chunks ...
[11:00:00.591]  - Number of values collected after concatenation: 10
[11:00:00.591]  - Number of values expected: 10
[11:00:00.591] Reducing values from 1 chunks ... DONE
[11:00:00.591] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[11:00:00.594] future_lapply() ...
[11:00:00.596] Number of chunks: 1
[11:00:00.596] getGlobalsAndPackagesXApply() ...
[11:00:00.596]  - future.globals: TRUE
[11:00:00.596] getGlobalsAndPackages() ...
[11:00:00.596] Searching for globals...
[11:00:00.600] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[11:00:00.600] Searching for globals ... DONE
[11:00:00.600] Resolving globals: FALSE
[11:00:00.601] The total size of the 7 globals is 13.03 KiB (13339 bytes)
[11:00:00.602] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.03 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.75 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:00.602] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.602] - packages: [2] ‘stats’, ‘future.apply’
[11:00:00.602] getGlobalsAndPackages() ... DONE
[11:00:00.602]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.602]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[11:00:00.602] Finding globals ... DONE
[11:00:00.602]  - use_args: TRUE
[11:00:00.602]  - Getting '...' globals ...
[11:00:00.603] resolve() on list ...
[11:00:00.603]  recursive: 0
[11:00:00.603]  length: 1
[11:00:00.603]  elements: ‘...’
[11:00:00.603]  length: 0 (resolved future 1)
[11:00:00.603] resolve() on list ... DONE
[11:00:00.603]    - '...' content: [n=0] 
[11:00:00.603] List of 1
[11:00:00.603]  $ ...: list()
[11:00:00.603]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.603]  - attr(*, "where")=List of 1
[11:00:00.603]   ..$ ...:<environment: 0x55bbad8c5b58> 
[11:00:00.603]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.603]  - attr(*, "resolved")= logi TRUE
[11:00:00.603]  - attr(*, "total_size")= num NA
[11:00:00.605]  - Getting '...' globals ... DONE
[11:00:00.605] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:00.606] List of 8
[11:00:00.606]  $ ...future.FUN:function (x, ...)  
[11:00:00.606]  $ x_FUN        :function (x, ...)  
[11:00:00.606]  $ times        : int 5
[11:00:00.606]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.606]  $ stop_if_not  :function (...)  
[11:00:00.606]  $ dim          : NULL
[11:00:00.606]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:00.606]  $ ...          : list()
[11:00:00.606]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.606]  - attr(*, "where")=List of 8
[11:00:00.606]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:00.606]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:00.606]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:00.606]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:00.606]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:00.606]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:00.606]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:00.606]   ..$ ...          :<environment: 0x55bbad8c5b58> 
[11:00:00.606]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.606]  - attr(*, "resolved")= logi FALSE
[11:00:00.606]  - attr(*, "total_size")= num 24127
[11:00:00.610] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[11:00:00.611] getGlobalsAndPackagesXApply() ... DONE
[11:00:00.611] Number of futures (= number of chunks): 1
[11:00:00.611] Launching 1 futures (chunks) ...
[11:00:00.611] Chunk #1 of 1 ...
[11:00:00.611]  - Finding globals in 'X' for chunk #1 ...
[11:00:00.611] getGlobalsAndPackages() ...
[11:00:00.611] Searching for globals...
[11:00:00.611] 
[11:00:00.611] Searching for globals ... DONE
[11:00:00.612] - globals: [0] <none>
[11:00:00.612] getGlobalsAndPackages() ... DONE
[11:00:00.612]    + additional globals found: [n=0] 
[11:00:00.612]    + additional namespaces needed: [n=0] 
[11:00:00.612]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:00.612]  - seeds: <none>
[11:00:00.612]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.612] getGlobalsAndPackages() ...
[11:00:00.612] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.612] Resolving globals: FALSE
[11:00:00.612] Tweak future expression to call with '...' arguments ...
[11:00:00.612] {
[11:00:00.612]     do.call(function(...) {
[11:00:00.612]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.612]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.612]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.612]             on.exit(options(oopts), add = TRUE)
[11:00:00.612]         }
[11:00:00.612]         {
[11:00:00.612]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.612]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.612]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.612]             })
[11:00:00.612]         }
[11:00:00.612]     }, args = future.call.arguments)
[11:00:00.612] }
[11:00:00.613] Tweak future expression to call with '...' arguments ... DONE
[11:00:00.613] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.613] - packages: [2] ‘stats’, ‘future.apply’
[11:00:00.613] getGlobalsAndPackages() ... DONE
[11:00:00.614] run() for ‘Future’ ...
[11:00:00.614] - state: ‘created’
[11:00:00.614] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:00.614] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.614] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:00.614]   - Field: ‘label’
[11:00:00.614]   - Field: ‘local’
[11:00:00.615]   - Field: ‘owner’
[11:00:00.615]   - Field: ‘envir’
[11:00:00.615]   - Field: ‘packages’
[11:00:00.615]   - Field: ‘gc’
[11:00:00.615]   - Field: ‘conditions’
[11:00:00.615]   - Field: ‘expr’
[11:00:00.615]   - Field: ‘uuid’
[11:00:00.615]   - Field: ‘seed’
[11:00:00.615]   - Field: ‘version’
[11:00:00.615]   - Field: ‘result’
[11:00:00.615]   - Field: ‘asynchronous’
[11:00:00.615]   - Field: ‘calls’
[11:00:00.615]   - Field: ‘globals’
[11:00:00.616]   - Field: ‘stdout’
[11:00:00.616]   - Field: ‘earlySignal’
[11:00:00.616]   - Field: ‘lazy’
[11:00:00.616]   - Field: ‘state’
[11:00:00.616] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:00.616] - Launch lazy future ...
[11:00:00.616] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[11:00:00.616] Packages needed by future strategies (n = 0): <none>
[11:00:00.617] {
[11:00:00.617]     {
[11:00:00.617]         {
[11:00:00.617]             ...future.startTime <- base::Sys.time()
[11:00:00.617]             {
[11:00:00.617]                 {
[11:00:00.617]                   {
[11:00:00.617]                     {
[11:00:00.617]                       base::local({
[11:00:00.617]                         has_future <- base::requireNamespace("future", 
[11:00:00.617]                           quietly = TRUE)
[11:00:00.617]                         if (has_future) {
[11:00:00.617]                           ns <- base::getNamespace("future")
[11:00:00.617]                           version <- ns[[".package"]][["version"]]
[11:00:00.617]                           if (is.null(version)) 
[11:00:00.617]                             version <- utils::packageVersion("future")
[11:00:00.617]                         }
[11:00:00.617]                         else {
[11:00:00.617]                           version <- NULL
[11:00:00.617]                         }
[11:00:00.617]                         if (!has_future || version < "1.8.0") {
[11:00:00.617]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:00.617]                             "", base::R.version$version.string), 
[11:00:00.617]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:00.617]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:00.617]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:00.617]                               "release", "version")], collapse = " "), 
[11:00:00.617]                             hostname = base::Sys.info()[["nodename"]])
[11:00:00.617]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:00.617]                             info)
[11:00:00.617]                           info <- base::paste(info, collapse = "; ")
[11:00:00.617]                           if (!has_future) {
[11:00:00.617]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:00.617]                               info)
[11:00:00.617]                           }
[11:00:00.617]                           else {
[11:00:00.617]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:00.617]                               info, version)
[11:00:00.617]                           }
[11:00:00.617]                           base::stop(msg)
[11:00:00.617]                         }
[11:00:00.617]                       })
[11:00:00.617]                     }
[11:00:00.617]                     base::local({
[11:00:00.617]                       for (pkg in c("stats", "future.apply")) {
[11:00:00.617]                         base::loadNamespace(pkg)
[11:00:00.617]                         base::library(pkg, character.only = TRUE)
[11:00:00.617]                       }
[11:00:00.617]                     })
[11:00:00.617]                   }
[11:00:00.617]                   ...future.strategy.old <- future::plan("list")
[11:00:00.617]                   options(future.plan = NULL)
[11:00:00.617]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.617]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:00.617]                 }
[11:00:00.617]                 ...future.workdir <- getwd()
[11:00:00.617]             }
[11:00:00.617]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:00.617]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:00.617]         }
[11:00:00.617]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:00.617]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:00.617]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:00.617]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:00.617]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:00.617]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:00.617]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:00.617]             base::names(...future.oldOptions))
[11:00:00.617]     }
[11:00:00.617]     if (FALSE) {
[11:00:00.617]     }
[11:00:00.617]     else {
[11:00:00.617]         if (TRUE) {
[11:00:00.617]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:00.617]                 open = "w")
[11:00:00.617]         }
[11:00:00.617]         else {
[11:00:00.617]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:00.617]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:00.617]         }
[11:00:00.617]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:00.617]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:00.617]             base::sink(type = "output", split = FALSE)
[11:00:00.617]             base::close(...future.stdout)
[11:00:00.617]         }, add = TRUE)
[11:00:00.617]     }
[11:00:00.617]     ...future.frame <- base::sys.nframe()
[11:00:00.617]     ...future.conditions <- base::list()
[11:00:00.617]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:00.617]     if (FALSE) {
[11:00:00.617]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:00.617]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:00.617]     }
[11:00:00.617]     ...future.result <- base::tryCatch({
[11:00:00.617]         base::withCallingHandlers({
[11:00:00.617]             ...future.value <- base::withVisible(base::local({
[11:00:00.617]                 do.call(function(...) {
[11:00:00.617]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.617]                   if (!identical(...future.globals.maxSize.org, 
[11:00:00.617]                     ...future.globals.maxSize)) {
[11:00:00.617]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.617]                     on.exit(options(oopts), add = TRUE)
[11:00:00.617]                   }
[11:00:00.617]                   {
[11:00:00.617]                     lapply(seq_along(...future.elements_ii), 
[11:00:00.617]                       FUN = function(jj) {
[11:00:00.617]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.617]                         ...future.FUN(...future.X_jj, ...)
[11:00:00.617]                       })
[11:00:00.617]                   }
[11:00:00.617]                 }, args = future.call.arguments)
[11:00:00.617]             }))
[11:00:00.617]             future::FutureResult(value = ...future.value$value, 
[11:00:00.617]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.617]                   ...future.rng), globalenv = if (FALSE) 
[11:00:00.617]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:00.617]                     ...future.globalenv.names))
[11:00:00.617]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:00.617]         }, condition = base::local({
[11:00:00.617]             c <- base::c
[11:00:00.617]             inherits <- base::inherits
[11:00:00.617]             invokeRestart <- base::invokeRestart
[11:00:00.617]             length <- base::length
[11:00:00.617]             list <- base::list
[11:00:00.617]             seq.int <- base::seq.int
[11:00:00.617]             signalCondition <- base::signalCondition
[11:00:00.617]             sys.calls <- base::sys.calls
[11:00:00.617]             `[[` <- base::`[[`
[11:00:00.617]             `+` <- base::`+`
[11:00:00.617]             `<<-` <- base::`<<-`
[11:00:00.617]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:00.617]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:00.617]                   3L)]
[11:00:00.617]             }
[11:00:00.617]             function(cond) {
[11:00:00.617]                 is_error <- inherits(cond, "error")
[11:00:00.617]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:00.617]                   NULL)
[11:00:00.617]                 if (is_error) {
[11:00:00.617]                   sessionInformation <- function() {
[11:00:00.617]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:00.617]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:00.617]                       search = base::search(), system = base::Sys.info())
[11:00:00.617]                   }
[11:00:00.617]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.617]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:00.617]                     cond$call), session = sessionInformation(), 
[11:00:00.617]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:00.617]                   signalCondition(cond)
[11:00:00.617]                 }
[11:00:00.617]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:00.617]                 "immediateCondition"))) {
[11:00:00.617]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:00.617]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.617]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:00.617]                   if (TRUE && !signal) {
[11:00:00.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.617]                     {
[11:00:00.617]                       inherits <- base::inherits
[11:00:00.617]                       invokeRestart <- base::invokeRestart
[11:00:00.617]                       is.null <- base::is.null
[11:00:00.617]                       muffled <- FALSE
[11:00:00.617]                       if (inherits(cond, "message")) {
[11:00:00.617]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.617]                         if (muffled) 
[11:00:00.617]                           invokeRestart("muffleMessage")
[11:00:00.617]                       }
[11:00:00.617]                       else if (inherits(cond, "warning")) {
[11:00:00.617]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.617]                         if (muffled) 
[11:00:00.617]                           invokeRestart("muffleWarning")
[11:00:00.617]                       }
[11:00:00.617]                       else if (inherits(cond, "condition")) {
[11:00:00.617]                         if (!is.null(pattern)) {
[11:00:00.617]                           computeRestarts <- base::computeRestarts
[11:00:00.617]                           grepl <- base::grepl
[11:00:00.617]                           restarts <- computeRestarts(cond)
[11:00:00.617]                           for (restart in restarts) {
[11:00:00.617]                             name <- restart$name
[11:00:00.617]                             if (is.null(name)) 
[11:00:00.617]                               next
[11:00:00.617]                             if (!grepl(pattern, name)) 
[11:00:00.617]                               next
[11:00:00.617]                             invokeRestart(restart)
[11:00:00.617]                             muffled <- TRUE
[11:00:00.617]                             break
[11:00:00.617]                           }
[11:00:00.617]                         }
[11:00:00.617]                       }
[11:00:00.617]                       invisible(muffled)
[11:00:00.617]                     }
[11:00:00.617]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.617]                   }
[11:00:00.617]                 }
[11:00:00.617]                 else {
[11:00:00.617]                   if (TRUE) {
[11:00:00.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.617]                     {
[11:00:00.617]                       inherits <- base::inherits
[11:00:00.617]                       invokeRestart <- base::invokeRestart
[11:00:00.617]                       is.null <- base::is.null
[11:00:00.617]                       muffled <- FALSE
[11:00:00.617]                       if (inherits(cond, "message")) {
[11:00:00.617]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.617]                         if (muffled) 
[11:00:00.617]                           invokeRestart("muffleMessage")
[11:00:00.617]                       }
[11:00:00.617]                       else if (inherits(cond, "warning")) {
[11:00:00.617]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.617]                         if (muffled) 
[11:00:00.617]                           invokeRestart("muffleWarning")
[11:00:00.617]                       }
[11:00:00.617]                       else if (inherits(cond, "condition")) {
[11:00:00.617]                         if (!is.null(pattern)) {
[11:00:00.617]                           computeRestarts <- base::computeRestarts
[11:00:00.617]                           grepl <- base::grepl
[11:00:00.617]                           restarts <- computeRestarts(cond)
[11:00:00.617]                           for (restart in restarts) {
[11:00:00.617]                             name <- restart$name
[11:00:00.617]                             if (is.null(name)) 
[11:00:00.617]                               next
[11:00:00.617]                             if (!grepl(pattern, name)) 
[11:00:00.617]                               next
[11:00:00.617]                             invokeRestart(restart)
[11:00:00.617]                             muffled <- TRUE
[11:00:00.617]                             break
[11:00:00.617]                           }
[11:00:00.617]                         }
[11:00:00.617]                       }
[11:00:00.617]                       invisible(muffled)
[11:00:00.617]                     }
[11:00:00.617]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.617]                   }
[11:00:00.617]                 }
[11:00:00.617]             }
[11:00:00.617]         }))
[11:00:00.617]     }, error = function(ex) {
[11:00:00.617]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:00.617]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.617]                 ...future.rng), started = ...future.startTime, 
[11:00:00.617]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:00.617]             version = "1.8"), class = "FutureResult")
[11:00:00.617]     }, finally = {
[11:00:00.617]         if (!identical(...future.workdir, getwd())) 
[11:00:00.617]             setwd(...future.workdir)
[11:00:00.617]         {
[11:00:00.617]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:00.617]                 ...future.oldOptions$nwarnings <- NULL
[11:00:00.617]             }
[11:00:00.617]             base::options(...future.oldOptions)
[11:00:00.617]             if (.Platform$OS.type == "windows") {
[11:00:00.617]                 old_names <- names(...future.oldEnvVars)
[11:00:00.617]                 envs <- base::Sys.getenv()
[11:00:00.617]                 names <- names(envs)
[11:00:00.617]                 common <- intersect(names, old_names)
[11:00:00.617]                 added <- setdiff(names, old_names)
[11:00:00.617]                 removed <- setdiff(old_names, names)
[11:00:00.617]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:00.617]                   envs[common]]
[11:00:00.617]                 NAMES <- toupper(changed)
[11:00:00.617]                 args <- list()
[11:00:00.617]                 for (kk in seq_along(NAMES)) {
[11:00:00.617]                   name <- changed[[kk]]
[11:00:00.617]                   NAME <- NAMES[[kk]]
[11:00:00.617]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.617]                     next
[11:00:00.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.617]                 }
[11:00:00.617]                 NAMES <- toupper(added)
[11:00:00.617]                 for (kk in seq_along(NAMES)) {
[11:00:00.617]                   name <- added[[kk]]
[11:00:00.617]                   NAME <- NAMES[[kk]]
[11:00:00.617]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.617]                     next
[11:00:00.617]                   args[[name]] <- ""
[11:00:00.617]                 }
[11:00:00.617]                 NAMES <- toupper(removed)
[11:00:00.617]                 for (kk in seq_along(NAMES)) {
[11:00:00.617]                   name <- removed[[kk]]
[11:00:00.617]                   NAME <- NAMES[[kk]]
[11:00:00.617]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.617]                     next
[11:00:00.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.617]                 }
[11:00:00.617]                 if (length(args) > 0) 
[11:00:00.617]                   base::do.call(base::Sys.setenv, args = args)
[11:00:00.617]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:00.617]             }
[11:00:00.617]             else {
[11:00:00.617]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:00.617]             }
[11:00:00.617]             {
[11:00:00.617]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:00.617]                   0L) {
[11:00:00.617]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:00.617]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:00.617]                   base::options(opts)
[11:00:00.617]                 }
[11:00:00.617]                 {
[11:00:00.617]                   {
[11:00:00.617]                     NULL
[11:00:00.617]                     RNGkind("Mersenne-Twister")
[11:00:00.617]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:00.617]                       inherits = FALSE)
[11:00:00.617]                   }
[11:00:00.617]                   options(future.plan = NULL)
[11:00:00.617]                   if (is.na(NA_character_)) 
[11:00:00.617]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.617]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:00.617]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:00.617]                     .init = FALSE)
[11:00:00.617]                 }
[11:00:00.617]             }
[11:00:00.617]         }
[11:00:00.617]     })
[11:00:00.617]     if (TRUE) {
[11:00:00.617]         base::sink(type = "output", split = FALSE)
[11:00:00.617]         if (TRUE) {
[11:00:00.617]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:00.617]         }
[11:00:00.617]         else {
[11:00:00.617]             ...future.result["stdout"] <- base::list(NULL)
[11:00:00.617]         }
[11:00:00.617]         base::close(...future.stdout)
[11:00:00.617]         ...future.stdout <- NULL
[11:00:00.617]     }
[11:00:00.617]     ...future.result$conditions <- ...future.conditions
[11:00:00.617]     ...future.result$finished <- base::Sys.time()
[11:00:00.617]     ...future.result
[11:00:00.617] }
[11:00:00.618] assign_globals() ...
[11:00:00.618] List of 11
[11:00:00.618]  $ ...future.FUN            :function (x, ...)  
[11:00:00.618]  $ x_FUN                    :function (x, ...)  
[11:00:00.618]  $ times                    : int 5
[11:00:00.618]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.618]  $ stop_if_not              :function (...)  
[11:00:00.618]  $ dim                      : NULL
[11:00:00.618]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:00.618]  $ future.call.arguments    : list()
[11:00:00.618]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.618]  $ ...future.elements_ii    :List of 3
[11:00:00.618]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[11:00:00.618]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[11:00:00.618]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[11:00:00.618]  $ ...future.seeds_ii       : NULL
[11:00:00.618]  $ ...future.globals.maxSize: NULL
[11:00:00.618]  - attr(*, "where")=List of 11
[11:00:00.618]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:00.618]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:00.618]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:00.618]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:00.618]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:00.618]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:00.618]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:00.618]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:00.618]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:00.618]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:00.618]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:00.618]  - attr(*, "resolved")= logi FALSE
[11:00:00.618]  - attr(*, "total_size")= num 24127
[11:00:00.618]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.618]  - attr(*, "already-done")= logi TRUE
[11:00:00.626] - copied ‘...future.FUN’ to environment
[11:00:00.627] - copied ‘x_FUN’ to environment
[11:00:00.627] - copied ‘times’ to environment
[11:00:00.627] - copied ‘stopf’ to environment
[11:00:00.627] - copied ‘stop_if_not’ to environment
[11:00:00.627] - copied ‘dim’ to environment
[11:00:00.627] - copied ‘valid_types’ to environment
[11:00:00.627] - copied ‘future.call.arguments’ to environment
[11:00:00.627] - copied ‘...future.elements_ii’ to environment
[11:00:00.627] - copied ‘...future.seeds_ii’ to environment
[11:00:00.627] - copied ‘...future.globals.maxSize’ to environment
[11:00:00.627] assign_globals() ... done
[11:00:00.628] plan(): Setting new future strategy stack:
[11:00:00.628] List of future strategies:
[11:00:00.628] 1. sequential:
[11:00:00.628]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.628]    - tweaked: FALSE
[11:00:00.628]    - call: NULL
[11:00:00.628] plan(): nbrOfWorkers() = 1
[11:00:00.629] plan(): Setting new future strategy stack:
[11:00:00.630] List of future strategies:
[11:00:00.630] 1. sequential:
[11:00:00.630]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.630]    - tweaked: FALSE
[11:00:00.630]    - call: plan(strategy)
[11:00:00.630] plan(): nbrOfWorkers() = 1
[11:00:00.630] SequentialFuture started (and completed)
[11:00:00.630] - Launch lazy future ... done
[11:00:00.630] run() for ‘SequentialFuture’ ... done
[11:00:00.630] Created future:
[11:00:00.630] SequentialFuture:
[11:00:00.630] Label: ‘future_vapply-1’
[11:00:00.630] Expression:
[11:00:00.630] {
[11:00:00.630]     do.call(function(...) {
[11:00:00.630]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.630]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.630]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.630]             on.exit(options(oopts), add = TRUE)
[11:00:00.630]         }
[11:00:00.630]         {
[11:00:00.630]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.630]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.630]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.630]             })
[11:00:00.630]         }
[11:00:00.630]     }, args = future.call.arguments)
[11:00:00.630] }
[11:00:00.630] Lazy evaluation: FALSE
[11:00:00.630] Asynchronous evaluation: FALSE
[11:00:00.630] Local evaluation: TRUE
[11:00:00.630] Environment: R_GlobalEnv
[11:00:00.630] Capture standard output: TRUE
[11:00:00.630] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:00.630] Globals: 11 objects totaling 13.46 KiB (function ‘...future.FUN’ of 4.74 KiB, function ‘x_FUN’ of 311 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:00.630] Packages: 2 packages (‘stats’, ‘future.apply’)
[11:00:00.630] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:00.630] Resolved: TRUE
[11:00:00.630] Value: 413 bytes of class ‘list’
[11:00:00.630] Early signaling: FALSE
[11:00:00.630] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:00.630] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.631] Chunk #1 of 1 ... DONE
[11:00:00.631] Launching 1 futures (chunks) ... DONE
[11:00:00.631] Resolving 1 futures (chunks) ...
[11:00:00.632] resolve() on list ...
[11:00:00.632]  recursive: 0
[11:00:00.632]  length: 1
[11:00:00.632] 
[11:00:00.632] resolved() for ‘SequentialFuture’ ...
[11:00:00.632] - state: ‘finished’
[11:00:00.632] - run: TRUE
[11:00:00.632] - result: ‘FutureResult’
[11:00:00.632] resolved() for ‘SequentialFuture’ ... done
[11:00:00.632] Future #1
[11:00:00.632] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:00.633] - nx: 1
[11:00:00.633] - relay: TRUE
[11:00:00.633] - stdout: TRUE
[11:00:00.633] - signal: TRUE
[11:00:00.633] - resignal: FALSE
[11:00:00.633] - force: TRUE
[11:00:00.633] - relayed: [n=1] FALSE
[11:00:00.633] - queued futures: [n=1] FALSE
[11:00:00.633]  - until=1
[11:00:00.633]  - relaying element #1
[11:00:00.633] - relayed: [n=1] TRUE
[11:00:00.633] - queued futures: [n=1] TRUE
[11:00:00.634] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:00.634]  length: 0 (resolved future 1)
[11:00:00.634] Relaying remaining futures
[11:00:00.634] signalConditionsASAP(NULL, pos=0) ...
[11:00:00.634] - nx: 1
[11:00:00.634] - relay: TRUE
[11:00:00.634] - stdout: TRUE
[11:00:00.634] - signal: TRUE
[11:00:00.634] - resignal: FALSE
[11:00:00.634] - force: TRUE
[11:00:00.634] - relayed: [n=1] TRUE
[11:00:00.634] - queued futures: [n=1] TRUE
 - flush all
[11:00:00.635] - relayed: [n=1] TRUE
[11:00:00.635] - queued futures: [n=1] TRUE
[11:00:00.635] signalConditionsASAP(NULL, pos=0) ... done
[11:00:00.635] resolve() on list ... DONE
[11:00:00.635]  - Number of value chunks collected: 1
[11:00:00.635] Resolving 1 futures (chunks) ... DONE
[11:00:00.635] Reducing values from 1 chunks ...
[11:00:00.635]  - Number of values collected after concatenation: 3
[11:00:00.635]  - Number of values expected: 3
[11:00:00.635] Reducing values from 1 chunks ... DONE
[11:00:00.635] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[11:00:00.637] future_lapply() ...
[11:00:00.641] Number of chunks: 1
[11:00:00.641] getGlobalsAndPackagesXApply() ...
[11:00:00.641]  - future.globals: TRUE
[11:00:00.641] getGlobalsAndPackages() ...
[11:00:00.641] Searching for globals...
[11:00:00.646] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[11:00:00.646] Searching for globals ... DONE
[11:00:00.646] Resolving globals: FALSE
[11:00:00.647] The total size of the 1 globals is 4.67 KiB (4777 bytes)
[11:00:00.647] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.67 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.67 KiB of class ‘function’)
[11:00:00.647] - globals: [1] ‘FUN’
[11:00:00.647] - packages: [1] ‘stats’
[11:00:00.647] getGlobalsAndPackages() ... DONE
[11:00:00.647]  - globals found/used: [n=1] ‘FUN’
[11:00:00.648]  - needed namespaces: [n=1] ‘stats’
[11:00:00.648] Finding globals ... DONE
[11:00:00.648]  - use_args: TRUE
[11:00:00.648]  - Getting '...' globals ...
[11:00:00.648] resolve() on list ...
[11:00:00.648]  recursive: 0
[11:00:00.648]  length: 1
[11:00:00.648]  elements: ‘...’
[11:00:00.648]  length: 0 (resolved future 1)
[11:00:00.648] resolve() on list ... DONE
[11:00:00.649]    - '...' content: [n=0] 
[11:00:00.649] List of 1
[11:00:00.649]  $ ...: list()
[11:00:00.649]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.649]  - attr(*, "where")=List of 1
[11:00:00.649]   ..$ ...:<environment: 0x55bbad8cd0b0> 
[11:00:00.649]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.649]  - attr(*, "resolved")= logi TRUE
[11:00:00.649]  - attr(*, "total_size")= num NA
[11:00:00.651]  - Getting '...' globals ... DONE
[11:00:00.651] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[11:00:00.651] List of 2
[11:00:00.651]  $ ...future.FUN:function (x, na.rm = TRUE)  
[11:00:00.651]  $ ...          : list()
[11:00:00.651]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.651]  - attr(*, "where")=List of 2
[11:00:00.651]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:00.651]   ..$ ...          :<environment: 0x55bbad8cd0b0> 
[11:00:00.651]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.651]  - attr(*, "resolved")= logi FALSE
[11:00:00.651]  - attr(*, "total_size")= num 18895
[11:00:00.654] Packages to be attached in all futures: [n=1] ‘stats’
[11:00:00.654] getGlobalsAndPackagesXApply() ... DONE
[11:00:00.654] Number of futures (= number of chunks): 1
[11:00:00.654] Launching 1 futures (chunks) ...
[11:00:00.654] Chunk #1 of 1 ...
[11:00:00.654]  - Finding globals in 'X' for chunk #1 ...
[11:00:00.654] getGlobalsAndPackages() ...
[11:00:00.654] Searching for globals...
[11:00:00.655] 
[11:00:00.655] Searching for globals ... DONE
[11:00:00.655] - globals: [0] <none>
[11:00:00.655] getGlobalsAndPackages() ... DONE
[11:00:00.655]    + additional globals found: [n=0] 
[11:00:00.655]    + additional namespaces needed: [n=0] 
[11:00:00.655]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:00.655]  - seeds: <none>
[11:00:00.655]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.655] getGlobalsAndPackages() ...
[11:00:00.655] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.655] Resolving globals: FALSE
[11:00:00.656] Tweak future expression to call with '...' arguments ...
[11:00:00.656] {
[11:00:00.656]     do.call(function(...) {
[11:00:00.656]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.656]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.656]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.656]             on.exit(options(oopts), add = TRUE)
[11:00:00.656]         }
[11:00:00.656]         {
[11:00:00.656]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.656]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.656]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.656]             })
[11:00:00.656]         }
[11:00:00.656]     }, args = future.call.arguments)
[11:00:00.656] }
[11:00:00.656] Tweak future expression to call with '...' arguments ... DONE
[11:00:00.656] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.656] - packages: [1] ‘stats’
[11:00:00.656] getGlobalsAndPackages() ... DONE
[11:00:00.657] run() for ‘Future’ ...
[11:00:00.657] - state: ‘created’
[11:00:00.657] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:00.657] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.657] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:00.657]   - Field: ‘label’
[11:00:00.657]   - Field: ‘local’
[11:00:00.657]   - Field: ‘owner’
[11:00:00.657]   - Field: ‘envir’
[11:00:00.658]   - Field: ‘packages’
[11:00:00.658]   - Field: ‘gc’
[11:00:00.658]   - Field: ‘conditions’
[11:00:00.658]   - Field: ‘expr’
[11:00:00.658]   - Field: ‘uuid’
[11:00:00.658]   - Field: ‘seed’
[11:00:00.658]   - Field: ‘version’
[11:00:00.658]   - Field: ‘result’
[11:00:00.658]   - Field: ‘asynchronous’
[11:00:00.658]   - Field: ‘calls’
[11:00:00.659]   - Field: ‘globals’
[11:00:00.659]   - Field: ‘stdout’
[11:00:00.659]   - Field: ‘earlySignal’
[11:00:00.659]   - Field: ‘lazy’
[11:00:00.659]   - Field: ‘state’
[11:00:00.660] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:00.660] - Launch lazy future ...
[11:00:00.660] Packages needed by the future expression (n = 1): ‘stats’
[11:00:00.660] Packages needed by future strategies (n = 0): <none>
[11:00:00.660] {
[11:00:00.660]     {
[11:00:00.660]         {
[11:00:00.660]             ...future.startTime <- base::Sys.time()
[11:00:00.660]             {
[11:00:00.660]                 {
[11:00:00.660]                   {
[11:00:00.660]                     {
[11:00:00.660]                       base::local({
[11:00:00.660]                         has_future <- base::requireNamespace("future", 
[11:00:00.660]                           quietly = TRUE)
[11:00:00.660]                         if (has_future) {
[11:00:00.660]                           ns <- base::getNamespace("future")
[11:00:00.660]                           version <- ns[[".package"]][["version"]]
[11:00:00.660]                           if (is.null(version)) 
[11:00:00.660]                             version <- utils::packageVersion("future")
[11:00:00.660]                         }
[11:00:00.660]                         else {
[11:00:00.660]                           version <- NULL
[11:00:00.660]                         }
[11:00:00.660]                         if (!has_future || version < "1.8.0") {
[11:00:00.660]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:00.660]                             "", base::R.version$version.string), 
[11:00:00.660]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:00.660]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:00.660]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:00.660]                               "release", "version")], collapse = " "), 
[11:00:00.660]                             hostname = base::Sys.info()[["nodename"]])
[11:00:00.660]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:00.660]                             info)
[11:00:00.660]                           info <- base::paste(info, collapse = "; ")
[11:00:00.660]                           if (!has_future) {
[11:00:00.660]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:00.660]                               info)
[11:00:00.660]                           }
[11:00:00.660]                           else {
[11:00:00.660]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:00.660]                               info, version)
[11:00:00.660]                           }
[11:00:00.660]                           base::stop(msg)
[11:00:00.660]                         }
[11:00:00.660]                       })
[11:00:00.660]                     }
[11:00:00.660]                     base::local({
[11:00:00.660]                       for (pkg in "stats") {
[11:00:00.660]                         base::loadNamespace(pkg)
[11:00:00.660]                         base::library(pkg, character.only = TRUE)
[11:00:00.660]                       }
[11:00:00.660]                     })
[11:00:00.660]                   }
[11:00:00.660]                   ...future.strategy.old <- future::plan("list")
[11:00:00.660]                   options(future.plan = NULL)
[11:00:00.660]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.660]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:00.660]                 }
[11:00:00.660]                 ...future.workdir <- getwd()
[11:00:00.660]             }
[11:00:00.660]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:00.660]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:00.660]         }
[11:00:00.660]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:00.660]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:00.660]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:00.660]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:00.660]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:00.660]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:00.660]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:00.660]             base::names(...future.oldOptions))
[11:00:00.660]     }
[11:00:00.660]     if (FALSE) {
[11:00:00.660]     }
[11:00:00.660]     else {
[11:00:00.660]         if (TRUE) {
[11:00:00.660]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:00.660]                 open = "w")
[11:00:00.660]         }
[11:00:00.660]         else {
[11:00:00.660]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:00.660]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:00.660]         }
[11:00:00.660]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:00.660]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:00.660]             base::sink(type = "output", split = FALSE)
[11:00:00.660]             base::close(...future.stdout)
[11:00:00.660]         }, add = TRUE)
[11:00:00.660]     }
[11:00:00.660]     ...future.frame <- base::sys.nframe()
[11:00:00.660]     ...future.conditions <- base::list()
[11:00:00.660]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:00.660]     if (FALSE) {
[11:00:00.660]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:00.660]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:00.660]     }
[11:00:00.660]     ...future.result <- base::tryCatch({
[11:00:00.660]         base::withCallingHandlers({
[11:00:00.660]             ...future.value <- base::withVisible(base::local({
[11:00:00.660]                 do.call(function(...) {
[11:00:00.660]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.660]                   if (!identical(...future.globals.maxSize.org, 
[11:00:00.660]                     ...future.globals.maxSize)) {
[11:00:00.660]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.660]                     on.exit(options(oopts), add = TRUE)
[11:00:00.660]                   }
[11:00:00.660]                   {
[11:00:00.660]                     lapply(seq_along(...future.elements_ii), 
[11:00:00.660]                       FUN = function(jj) {
[11:00:00.660]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.660]                         ...future.FUN(...future.X_jj, ...)
[11:00:00.660]                       })
[11:00:00.660]                   }
[11:00:00.660]                 }, args = future.call.arguments)
[11:00:00.660]             }))
[11:00:00.660]             future::FutureResult(value = ...future.value$value, 
[11:00:00.660]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.660]                   ...future.rng), globalenv = if (FALSE) 
[11:00:00.660]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:00.660]                     ...future.globalenv.names))
[11:00:00.660]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:00.660]         }, condition = base::local({
[11:00:00.660]             c <- base::c
[11:00:00.660]             inherits <- base::inherits
[11:00:00.660]             invokeRestart <- base::invokeRestart
[11:00:00.660]             length <- base::length
[11:00:00.660]             list <- base::list
[11:00:00.660]             seq.int <- base::seq.int
[11:00:00.660]             signalCondition <- base::signalCondition
[11:00:00.660]             sys.calls <- base::sys.calls
[11:00:00.660]             `[[` <- base::`[[`
[11:00:00.660]             `+` <- base::`+`
[11:00:00.660]             `<<-` <- base::`<<-`
[11:00:00.660]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:00.660]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:00.660]                   3L)]
[11:00:00.660]             }
[11:00:00.660]             function(cond) {
[11:00:00.660]                 is_error <- inherits(cond, "error")
[11:00:00.660]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:00.660]                   NULL)
[11:00:00.660]                 if (is_error) {
[11:00:00.660]                   sessionInformation <- function() {
[11:00:00.660]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:00.660]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:00.660]                       search = base::search(), system = base::Sys.info())
[11:00:00.660]                   }
[11:00:00.660]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.660]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:00.660]                     cond$call), session = sessionInformation(), 
[11:00:00.660]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:00.660]                   signalCondition(cond)
[11:00:00.660]                 }
[11:00:00.660]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:00.660]                 "immediateCondition"))) {
[11:00:00.660]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:00.660]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.660]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:00.660]                   if (TRUE && !signal) {
[11:00:00.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.660]                     {
[11:00:00.660]                       inherits <- base::inherits
[11:00:00.660]                       invokeRestart <- base::invokeRestart
[11:00:00.660]                       is.null <- base::is.null
[11:00:00.660]                       muffled <- FALSE
[11:00:00.660]                       if (inherits(cond, "message")) {
[11:00:00.660]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.660]                         if (muffled) 
[11:00:00.660]                           invokeRestart("muffleMessage")
[11:00:00.660]                       }
[11:00:00.660]                       else if (inherits(cond, "warning")) {
[11:00:00.660]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.660]                         if (muffled) 
[11:00:00.660]                           invokeRestart("muffleWarning")
[11:00:00.660]                       }
[11:00:00.660]                       else if (inherits(cond, "condition")) {
[11:00:00.660]                         if (!is.null(pattern)) {
[11:00:00.660]                           computeRestarts <- base::computeRestarts
[11:00:00.660]                           grepl <- base::grepl
[11:00:00.660]                           restarts <- computeRestarts(cond)
[11:00:00.660]                           for (restart in restarts) {
[11:00:00.660]                             name <- restart$name
[11:00:00.660]                             if (is.null(name)) 
[11:00:00.660]                               next
[11:00:00.660]                             if (!grepl(pattern, name)) 
[11:00:00.660]                               next
[11:00:00.660]                             invokeRestart(restart)
[11:00:00.660]                             muffled <- TRUE
[11:00:00.660]                             break
[11:00:00.660]                           }
[11:00:00.660]                         }
[11:00:00.660]                       }
[11:00:00.660]                       invisible(muffled)
[11:00:00.660]                     }
[11:00:00.660]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.660]                   }
[11:00:00.660]                 }
[11:00:00.660]                 else {
[11:00:00.660]                   if (TRUE) {
[11:00:00.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.660]                     {
[11:00:00.660]                       inherits <- base::inherits
[11:00:00.660]                       invokeRestart <- base::invokeRestart
[11:00:00.660]                       is.null <- base::is.null
[11:00:00.660]                       muffled <- FALSE
[11:00:00.660]                       if (inherits(cond, "message")) {
[11:00:00.660]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.660]                         if (muffled) 
[11:00:00.660]                           invokeRestart("muffleMessage")
[11:00:00.660]                       }
[11:00:00.660]                       else if (inherits(cond, "warning")) {
[11:00:00.660]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.660]                         if (muffled) 
[11:00:00.660]                           invokeRestart("muffleWarning")
[11:00:00.660]                       }
[11:00:00.660]                       else if (inherits(cond, "condition")) {
[11:00:00.660]                         if (!is.null(pattern)) {
[11:00:00.660]                           computeRestarts <- base::computeRestarts
[11:00:00.660]                           grepl <- base::grepl
[11:00:00.660]                           restarts <- computeRestarts(cond)
[11:00:00.660]                           for (restart in restarts) {
[11:00:00.660]                             name <- restart$name
[11:00:00.660]                             if (is.null(name)) 
[11:00:00.660]                               next
[11:00:00.660]                             if (!grepl(pattern, name)) 
[11:00:00.660]                               next
[11:00:00.660]                             invokeRestart(restart)
[11:00:00.660]                             muffled <- TRUE
[11:00:00.660]                             break
[11:00:00.660]                           }
[11:00:00.660]                         }
[11:00:00.660]                       }
[11:00:00.660]                       invisible(muffled)
[11:00:00.660]                     }
[11:00:00.660]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.660]                   }
[11:00:00.660]                 }
[11:00:00.660]             }
[11:00:00.660]         }))
[11:00:00.660]     }, error = function(ex) {
[11:00:00.660]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:00.660]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.660]                 ...future.rng), started = ...future.startTime, 
[11:00:00.660]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:00.660]             version = "1.8"), class = "FutureResult")
[11:00:00.660]     }, finally = {
[11:00:00.660]         if (!identical(...future.workdir, getwd())) 
[11:00:00.660]             setwd(...future.workdir)
[11:00:00.660]         {
[11:00:00.660]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:00.660]                 ...future.oldOptions$nwarnings <- NULL
[11:00:00.660]             }
[11:00:00.660]             base::options(...future.oldOptions)
[11:00:00.660]             if (.Platform$OS.type == "windows") {
[11:00:00.660]                 old_names <- names(...future.oldEnvVars)
[11:00:00.660]                 envs <- base::Sys.getenv()
[11:00:00.660]                 names <- names(envs)
[11:00:00.660]                 common <- intersect(names, old_names)
[11:00:00.660]                 added <- setdiff(names, old_names)
[11:00:00.660]                 removed <- setdiff(old_names, names)
[11:00:00.660]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:00.660]                   envs[common]]
[11:00:00.660]                 NAMES <- toupper(changed)
[11:00:00.660]                 args <- list()
[11:00:00.660]                 for (kk in seq_along(NAMES)) {
[11:00:00.660]                   name <- changed[[kk]]
[11:00:00.660]                   NAME <- NAMES[[kk]]
[11:00:00.660]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.660]                     next
[11:00:00.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.660]                 }
[11:00:00.660]                 NAMES <- toupper(added)
[11:00:00.660]                 for (kk in seq_along(NAMES)) {
[11:00:00.660]                   name <- added[[kk]]
[11:00:00.660]                   NAME <- NAMES[[kk]]
[11:00:00.660]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.660]                     next
[11:00:00.660]                   args[[name]] <- ""
[11:00:00.660]                 }
[11:00:00.660]                 NAMES <- toupper(removed)
[11:00:00.660]                 for (kk in seq_along(NAMES)) {
[11:00:00.660]                   name <- removed[[kk]]
[11:00:00.660]                   NAME <- NAMES[[kk]]
[11:00:00.660]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.660]                     next
[11:00:00.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.660]                 }
[11:00:00.660]                 if (length(args) > 0) 
[11:00:00.660]                   base::do.call(base::Sys.setenv, args = args)
[11:00:00.660]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:00.660]             }
[11:00:00.660]             else {
[11:00:00.660]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:00.660]             }
[11:00:00.660]             {
[11:00:00.660]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:00.660]                   0L) {
[11:00:00.660]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:00.660]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:00.660]                   base::options(opts)
[11:00:00.660]                 }
[11:00:00.660]                 {
[11:00:00.660]                   {
[11:00:00.660]                     NULL
[11:00:00.660]                     RNGkind("Mersenne-Twister")
[11:00:00.660]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:00.660]                       inherits = FALSE)
[11:00:00.660]                   }
[11:00:00.660]                   options(future.plan = NULL)
[11:00:00.660]                   if (is.na(NA_character_)) 
[11:00:00.660]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.660]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:00.660]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:00.660]                     .init = FALSE)
[11:00:00.660]                 }
[11:00:00.660]             }
[11:00:00.660]         }
[11:00:00.660]     })
[11:00:00.660]     if (TRUE) {
[11:00:00.660]         base::sink(type = "output", split = FALSE)
[11:00:00.660]         if (TRUE) {
[11:00:00.660]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:00.660]         }
[11:00:00.660]         else {
[11:00:00.660]             ...future.result["stdout"] <- base::list(NULL)
[11:00:00.660]         }
[11:00:00.660]         base::close(...future.stdout)
[11:00:00.660]         ...future.stdout <- NULL
[11:00:00.660]     }
[11:00:00.660]     ...future.result$conditions <- ...future.conditions
[11:00:00.660]     ...future.result$finished <- base::Sys.time()
[11:00:00.660]     ...future.result
[11:00:00.660] }
[11:00:00.662] assign_globals() ...
[11:00:00.662] List of 5
[11:00:00.662]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[11:00:00.662]  $ future.call.arguments    : list()
[11:00:00.662]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.662]  $ ...future.elements_ii    :List of 7
[11:00:00.662]   ..$ : int [1:3] 1 2 3
[11:00:00.662]   ..$ : int [1:4] 1 2 3 4
[11:00:00.662]   ..$ : int [1:5] 1 2 3 4 5
[11:00:00.662]   ..$ : int [1:6] 1 2 3 4 5 6
[11:00:00.662]   ..$ : int [1:7] 1 2 3 4 5 6 7
[11:00:00.662]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[11:00:00.662]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[11:00:00.662]  $ ...future.seeds_ii       : NULL
[11:00:00.662]  $ ...future.globals.maxSize: NULL
[11:00:00.662]  - attr(*, "where")=List of 5
[11:00:00.662]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:00.662]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:00.662]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:00.662]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:00.662]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:00.662]  - attr(*, "resolved")= logi FALSE
[11:00:00.662]  - attr(*, "total_size")= num 18895
[11:00:00.662]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.662]  - attr(*, "already-done")= logi TRUE
[11:00:00.668] - copied ‘...future.FUN’ to environment
[11:00:00.668] - copied ‘future.call.arguments’ to environment
[11:00:00.668] - copied ‘...future.elements_ii’ to environment
[11:00:00.668] - copied ‘...future.seeds_ii’ to environment
[11:00:00.668] - copied ‘...future.globals.maxSize’ to environment
[11:00:00.669] assign_globals() ... done
[11:00:00.669] plan(): Setting new future strategy stack:
[11:00:00.669] List of future strategies:
[11:00:00.669] 1. sequential:
[11:00:00.669]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.669]    - tweaked: FALSE
[11:00:00.669]    - call: NULL
[11:00:00.669] plan(): nbrOfWorkers() = 1
[11:00:00.670] plan(): Setting new future strategy stack:
[11:00:00.670] List of future strategies:
[11:00:00.670] 1. sequential:
[11:00:00.670]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.670]    - tweaked: FALSE
[11:00:00.670]    - call: plan(strategy)
[11:00:00.671] plan(): nbrOfWorkers() = 1
[11:00:00.671] SequentialFuture started (and completed)
[11:00:00.671] - Launch lazy future ... done
[11:00:00.671] run() for ‘SequentialFuture’ ... done
[11:00:00.671] Created future:
[11:00:00.671] SequentialFuture:
[11:00:00.671] Label: ‘future_sapply-1’
[11:00:00.671] Expression:
[11:00:00.671] {
[11:00:00.671]     do.call(function(...) {
[11:00:00.671]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.671]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.671]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.671]             on.exit(options(oopts), add = TRUE)
[11:00:00.671]         }
[11:00:00.671]         {
[11:00:00.671]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.671]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.671]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.671]             })
[11:00:00.671]         }
[11:00:00.671]     }, args = future.call.arguments)
[11:00:00.671] }
[11:00:00.671] Lazy evaluation: FALSE
[11:00:00.671] Asynchronous evaluation: FALSE
[11:00:00.671] Local evaluation: TRUE
[11:00:00.671] Environment: R_GlobalEnv
[11:00:00.671] Capture standard output: TRUE
[11:00:00.671] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:00.671] Globals: 5 objects totaling 5.40 KiB (function ‘...future.FUN’ of 4.67 KiB, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 597 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:00.671] Packages: 1 packages (‘stats’)
[11:00:00.671] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:00.671] Resolved: TRUE
[11:00:00.671] Value: 367 bytes of class ‘list’
[11:00:00.671] Early signaling: FALSE
[11:00:00.671] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:00.671] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.672] Chunk #1 of 1 ... DONE
[11:00:00.672] Launching 1 futures (chunks) ... DONE
[11:00:00.672] Resolving 1 futures (chunks) ...
[11:00:00.672] resolve() on list ...
[11:00:00.672]  recursive: 0
[11:00:00.672]  length: 1
[11:00:00.672] 
[11:00:00.672] resolved() for ‘SequentialFuture’ ...
[11:00:00.672] - state: ‘finished’
[11:00:00.673] - run: TRUE
[11:00:00.673] - result: ‘FutureResult’
[11:00:00.673] resolved() for ‘SequentialFuture’ ... done
[11:00:00.673] Future #1
[11:00:00.673] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:00.673] - nx: 1
[11:00:00.673] - relay: TRUE
[11:00:00.673] - stdout: TRUE
[11:00:00.673] - signal: TRUE
[11:00:00.673] - resignal: FALSE
[11:00:00.673] - force: TRUE
[11:00:00.673] - relayed: [n=1] FALSE
[11:00:00.674] - queued futures: [n=1] FALSE
[11:00:00.674]  - until=1
[11:00:00.674]  - relaying element #1
[11:00:00.674] - relayed: [n=1] TRUE
[11:00:00.674] - queued futures: [n=1] TRUE
[11:00:00.674] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:00.674]  length: 0 (resolved future 1)
[11:00:00.674] Relaying remaining futures
[11:00:00.674] signalConditionsASAP(NULL, pos=0) ...
[11:00:00.674] - nx: 1
[11:00:00.674] - relay: TRUE
[11:00:00.674] - stdout: TRUE
[11:00:00.675] - signal: TRUE
[11:00:00.675] - resignal: FALSE
[11:00:00.675] - force: TRUE
[11:00:00.675] - relayed: [n=1] TRUE
[11:00:00.675] - queued futures: [n=1] TRUE
 - flush all
[11:00:00.675] - relayed: [n=1] TRUE
[11:00:00.675] - queued futures: [n=1] TRUE
[11:00:00.675] signalConditionsASAP(NULL, pos=0) ... done
[11:00:00.675] resolve() on list ... DONE
[11:00:00.675]  - Number of value chunks collected: 1
[11:00:00.675] Resolving 1 futures (chunks) ... DONE
[11:00:00.676] Reducing values from 1 chunks ...
[11:00:00.676]  - Number of values collected after concatenation: 7
[11:00:00.676]  - Number of values expected: 7
[11:00:00.676] Reducing values from 1 chunks ... DONE
[11:00:00.676] future_lapply() ... DONE
[11:00:00.676] future_lapply() ...
[11:00:00.678] Number of chunks: 1
[11:00:00.678] getGlobalsAndPackagesXApply() ...
[11:00:00.678]  - future.globals: TRUE
[11:00:00.678] getGlobalsAndPackages() ...
[11:00:00.678] Searching for globals...
[11:00:00.685] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[11:00:00.685] Searching for globals ... DONE
[11:00:00.685] Resolving globals: FALSE
[11:00:00.686] The total size of the 7 globals is 26.71 KiB (27354 bytes)
[11:00:00.687] The total size of the 7 globals exported for future expression (‘FUN()’) is 26.71 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (14.07 KiB of class ‘function’), ‘x_FUN’ (4.67 KiB of class ‘function’) and ‘stop_if_not’ (4.51 KiB of class ‘function’)
[11:00:00.687] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.687] - packages: [2] ‘stats’, ‘future.apply’
[11:00:00.687] getGlobalsAndPackages() ... DONE
[11:00:00.687]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.687]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[11:00:00.687] Finding globals ... DONE
[11:00:00.688]  - use_args: TRUE
[11:00:00.688]  - Getting '...' globals ...
[11:00:00.688] resolve() on list ...
[11:00:00.688]  recursive: 0
[11:00:00.688]  length: 1
[11:00:00.688]  elements: ‘...’
[11:00:00.688]  length: 0 (resolved future 1)
[11:00:00.688] resolve() on list ... DONE
[11:00:00.688]    - '...' content: [n=0] 
[11:00:00.688] List of 1
[11:00:00.688]  $ ...: list()
[11:00:00.688]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.688]  - attr(*, "where")=List of 1
[11:00:00.688]   ..$ ...:<environment: 0x55bbad65abd0> 
[11:00:00.688]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.688]  - attr(*, "resolved")= logi TRUE
[11:00:00.688]  - attr(*, "total_size")= num NA
[11:00:00.691]  - Getting '...' globals ... DONE
[11:00:00.691] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:00.691] List of 8
[11:00:00.691]  $ ...future.FUN:function (x, ...)  
[11:00:00.691]  $ x_FUN        :function (x, na.rm = TRUE)  
[11:00:00.691]  $ times        : int 5
[11:00:00.691]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.691]  $ stop_if_not  :function (...)  
[11:00:00.691]  $ dim          : NULL
[11:00:00.691]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:00.691]  $ ...          : list()
[11:00:00.691]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.691]  - attr(*, "where")=List of 8
[11:00:00.691]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:00.691]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:00.691]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:00.691]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:00.691]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:00.691]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:00.691]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:00.691]   ..$ ...          :<environment: 0x55bbad65abd0> 
[11:00:00.691]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.691]  - attr(*, "resolved")= logi FALSE
[11:00:00.691]  - attr(*, "total_size")= num 48005
[11:00:00.696] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[11:00:00.696] getGlobalsAndPackagesXApply() ... DONE
[11:00:00.696] Number of futures (= number of chunks): 1
[11:00:00.696] Launching 1 futures (chunks) ...
[11:00:00.696] Chunk #1 of 1 ...
[11:00:00.696]  - Finding globals in 'X' for chunk #1 ...
[11:00:00.696] getGlobalsAndPackages() ...
[11:00:00.696] Searching for globals...
[11:00:00.697] 
[11:00:00.697] Searching for globals ... DONE
[11:00:00.697] - globals: [0] <none>
[11:00:00.697] getGlobalsAndPackages() ... DONE
[11:00:00.697]    + additional globals found: [n=0] 
[11:00:00.697]    + additional namespaces needed: [n=0] 
[11:00:00.697]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:00.697]  - seeds: <none>
[11:00:00.697]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.697] getGlobalsAndPackages() ...
[11:00:00.697] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.698] Resolving globals: FALSE
[11:00:00.698] Tweak future expression to call with '...' arguments ...
[11:00:00.698] {
[11:00:00.698]     do.call(function(...) {
[11:00:00.698]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.698]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.698]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.698]             on.exit(options(oopts), add = TRUE)
[11:00:00.698]         }
[11:00:00.698]         {
[11:00:00.698]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.698]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.698]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.698]             })
[11:00:00.698]         }
[11:00:00.698]     }, args = future.call.arguments)
[11:00:00.698] }
[11:00:00.698] Tweak future expression to call with '...' arguments ... DONE
[11:00:00.698] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.699] - packages: [2] ‘stats’, ‘future.apply’
[11:00:00.699] getGlobalsAndPackages() ... DONE
[11:00:00.700] run() for ‘Future’ ...
[11:00:00.700] - state: ‘created’
[11:00:00.700] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:00.700] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.700] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:00.700]   - Field: ‘label’
[11:00:00.700]   - Field: ‘local’
[11:00:00.700]   - Field: ‘owner’
[11:00:00.701]   - Field: ‘envir’
[11:00:00.701]   - Field: ‘packages’
[11:00:00.701]   - Field: ‘gc’
[11:00:00.701]   - Field: ‘conditions’
[11:00:00.701]   - Field: ‘expr’
[11:00:00.701]   - Field: ‘uuid’
[11:00:00.701]   - Field: ‘seed’
[11:00:00.701]   - Field: ‘version’
[11:00:00.701]   - Field: ‘result’
[11:00:00.701]   - Field: ‘asynchronous’
[11:00:00.701]   - Field: ‘calls’
[11:00:00.701]   - Field: ‘globals’
[11:00:00.701]   - Field: ‘stdout’
[11:00:00.702]   - Field: ‘earlySignal’
[11:00:00.702]   - Field: ‘lazy’
[11:00:00.702]   - Field: ‘state’
[11:00:00.702] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:00.702] - Launch lazy future ...
[11:00:00.702] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[11:00:00.702] Packages needed by future strategies (n = 0): <none>
[11:00:00.703] {
[11:00:00.703]     {
[11:00:00.703]         {
[11:00:00.703]             ...future.startTime <- base::Sys.time()
[11:00:00.703]             {
[11:00:00.703]                 {
[11:00:00.703]                   {
[11:00:00.703]                     {
[11:00:00.703]                       base::local({
[11:00:00.703]                         has_future <- base::requireNamespace("future", 
[11:00:00.703]                           quietly = TRUE)
[11:00:00.703]                         if (has_future) {
[11:00:00.703]                           ns <- base::getNamespace("future")
[11:00:00.703]                           version <- ns[[".package"]][["version"]]
[11:00:00.703]                           if (is.null(version)) 
[11:00:00.703]                             version <- utils::packageVersion("future")
[11:00:00.703]                         }
[11:00:00.703]                         else {
[11:00:00.703]                           version <- NULL
[11:00:00.703]                         }
[11:00:00.703]                         if (!has_future || version < "1.8.0") {
[11:00:00.703]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:00.703]                             "", base::R.version$version.string), 
[11:00:00.703]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:00.703]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:00.703]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:00.703]                               "release", "version")], collapse = " "), 
[11:00:00.703]                             hostname = base::Sys.info()[["nodename"]])
[11:00:00.703]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:00.703]                             info)
[11:00:00.703]                           info <- base::paste(info, collapse = "; ")
[11:00:00.703]                           if (!has_future) {
[11:00:00.703]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:00.703]                               info)
[11:00:00.703]                           }
[11:00:00.703]                           else {
[11:00:00.703]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:00.703]                               info, version)
[11:00:00.703]                           }
[11:00:00.703]                           base::stop(msg)
[11:00:00.703]                         }
[11:00:00.703]                       })
[11:00:00.703]                     }
[11:00:00.703]                     base::local({
[11:00:00.703]                       for (pkg in c("stats", "future.apply")) {
[11:00:00.703]                         base::loadNamespace(pkg)
[11:00:00.703]                         base::library(pkg, character.only = TRUE)
[11:00:00.703]                       }
[11:00:00.703]                     })
[11:00:00.703]                   }
[11:00:00.703]                   ...future.strategy.old <- future::plan("list")
[11:00:00.703]                   options(future.plan = NULL)
[11:00:00.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:00.703]                 }
[11:00:00.703]                 ...future.workdir <- getwd()
[11:00:00.703]             }
[11:00:00.703]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:00.703]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:00.703]         }
[11:00:00.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:00.703]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:00.703]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:00.703]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:00.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:00.703]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:00.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:00.703]             base::names(...future.oldOptions))
[11:00:00.703]     }
[11:00:00.703]     if (FALSE) {
[11:00:00.703]     }
[11:00:00.703]     else {
[11:00:00.703]         if (TRUE) {
[11:00:00.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:00.703]                 open = "w")
[11:00:00.703]         }
[11:00:00.703]         else {
[11:00:00.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:00.703]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:00.703]         }
[11:00:00.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:00.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:00.703]             base::sink(type = "output", split = FALSE)
[11:00:00.703]             base::close(...future.stdout)
[11:00:00.703]         }, add = TRUE)
[11:00:00.703]     }
[11:00:00.703]     ...future.frame <- base::sys.nframe()
[11:00:00.703]     ...future.conditions <- base::list()
[11:00:00.703]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:00.703]     if (FALSE) {
[11:00:00.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:00.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:00.703]     }
[11:00:00.703]     ...future.result <- base::tryCatch({
[11:00:00.703]         base::withCallingHandlers({
[11:00:00.703]             ...future.value <- base::withVisible(base::local({
[11:00:00.703]                 do.call(function(...) {
[11:00:00.703]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.703]                   if (!identical(...future.globals.maxSize.org, 
[11:00:00.703]                     ...future.globals.maxSize)) {
[11:00:00.703]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.703]                     on.exit(options(oopts), add = TRUE)
[11:00:00.703]                   }
[11:00:00.703]                   {
[11:00:00.703]                     lapply(seq_along(...future.elements_ii), 
[11:00:00.703]                       FUN = function(jj) {
[11:00:00.703]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.703]                         ...future.FUN(...future.X_jj, ...)
[11:00:00.703]                       })
[11:00:00.703]                   }
[11:00:00.703]                 }, args = future.call.arguments)
[11:00:00.703]             }))
[11:00:00.703]             future::FutureResult(value = ...future.value$value, 
[11:00:00.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.703]                   ...future.rng), globalenv = if (FALSE) 
[11:00:00.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:00.703]                     ...future.globalenv.names))
[11:00:00.703]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:00.703]         }, condition = base::local({
[11:00:00.703]             c <- base::c
[11:00:00.703]             inherits <- base::inherits
[11:00:00.703]             invokeRestart <- base::invokeRestart
[11:00:00.703]             length <- base::length
[11:00:00.703]             list <- base::list
[11:00:00.703]             seq.int <- base::seq.int
[11:00:00.703]             signalCondition <- base::signalCondition
[11:00:00.703]             sys.calls <- base::sys.calls
[11:00:00.703]             `[[` <- base::`[[`
[11:00:00.703]             `+` <- base::`+`
[11:00:00.703]             `<<-` <- base::`<<-`
[11:00:00.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:00.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:00.703]                   3L)]
[11:00:00.703]             }
[11:00:00.703]             function(cond) {
[11:00:00.703]                 is_error <- inherits(cond, "error")
[11:00:00.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:00.703]                   NULL)
[11:00:00.703]                 if (is_error) {
[11:00:00.703]                   sessionInformation <- function() {
[11:00:00.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:00.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:00.703]                       search = base::search(), system = base::Sys.info())
[11:00:00.703]                   }
[11:00:00.703]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:00.703]                     cond$call), session = sessionInformation(), 
[11:00:00.703]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:00.703]                   signalCondition(cond)
[11:00:00.703]                 }
[11:00:00.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:00.703]                 "immediateCondition"))) {
[11:00:00.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:00.703]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:00.703]                   if (TRUE && !signal) {
[11:00:00.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.703]                     {
[11:00:00.703]                       inherits <- base::inherits
[11:00:00.703]                       invokeRestart <- base::invokeRestart
[11:00:00.703]                       is.null <- base::is.null
[11:00:00.703]                       muffled <- FALSE
[11:00:00.703]                       if (inherits(cond, "message")) {
[11:00:00.703]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.703]                         if (muffled) 
[11:00:00.703]                           invokeRestart("muffleMessage")
[11:00:00.703]                       }
[11:00:00.703]                       else if (inherits(cond, "warning")) {
[11:00:00.703]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.703]                         if (muffled) 
[11:00:00.703]                           invokeRestart("muffleWarning")
[11:00:00.703]                       }
[11:00:00.703]                       else if (inherits(cond, "condition")) {
[11:00:00.703]                         if (!is.null(pattern)) {
[11:00:00.703]                           computeRestarts <- base::computeRestarts
[11:00:00.703]                           grepl <- base::grepl
[11:00:00.703]                           restarts <- computeRestarts(cond)
[11:00:00.703]                           for (restart in restarts) {
[11:00:00.703]                             name <- restart$name
[11:00:00.703]                             if (is.null(name)) 
[11:00:00.703]                               next
[11:00:00.703]                             if (!grepl(pattern, name)) 
[11:00:00.703]                               next
[11:00:00.703]                             invokeRestart(restart)
[11:00:00.703]                             muffled <- TRUE
[11:00:00.703]                             break
[11:00:00.703]                           }
[11:00:00.703]                         }
[11:00:00.703]                       }
[11:00:00.703]                       invisible(muffled)
[11:00:00.703]                     }
[11:00:00.703]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.703]                   }
[11:00:00.703]                 }
[11:00:00.703]                 else {
[11:00:00.703]                   if (TRUE) {
[11:00:00.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.703]                     {
[11:00:00.703]                       inherits <- base::inherits
[11:00:00.703]                       invokeRestart <- base::invokeRestart
[11:00:00.703]                       is.null <- base::is.null
[11:00:00.703]                       muffled <- FALSE
[11:00:00.703]                       if (inherits(cond, "message")) {
[11:00:00.703]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.703]                         if (muffled) 
[11:00:00.703]                           invokeRestart("muffleMessage")
[11:00:00.703]                       }
[11:00:00.703]                       else if (inherits(cond, "warning")) {
[11:00:00.703]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.703]                         if (muffled) 
[11:00:00.703]                           invokeRestart("muffleWarning")
[11:00:00.703]                       }
[11:00:00.703]                       else if (inherits(cond, "condition")) {
[11:00:00.703]                         if (!is.null(pattern)) {
[11:00:00.703]                           computeRestarts <- base::computeRestarts
[11:00:00.703]                           grepl <- base::grepl
[11:00:00.703]                           restarts <- computeRestarts(cond)
[11:00:00.703]                           for (restart in restarts) {
[11:00:00.703]                             name <- restart$name
[11:00:00.703]                             if (is.null(name)) 
[11:00:00.703]                               next
[11:00:00.703]                             if (!grepl(pattern, name)) 
[11:00:00.703]                               next
[11:00:00.703]                             invokeRestart(restart)
[11:00:00.703]                             muffled <- TRUE
[11:00:00.703]                             break
[11:00:00.703]                           }
[11:00:00.703]                         }
[11:00:00.703]                       }
[11:00:00.703]                       invisible(muffled)
[11:00:00.703]                     }
[11:00:00.703]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.703]                   }
[11:00:00.703]                 }
[11:00:00.703]             }
[11:00:00.703]         }))
[11:00:00.703]     }, error = function(ex) {
[11:00:00.703]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:00.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.703]                 ...future.rng), started = ...future.startTime, 
[11:00:00.703]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:00.703]             version = "1.8"), class = "FutureResult")
[11:00:00.703]     }, finally = {
[11:00:00.703]         if (!identical(...future.workdir, getwd())) 
[11:00:00.703]             setwd(...future.workdir)
[11:00:00.703]         {
[11:00:00.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:00.703]                 ...future.oldOptions$nwarnings <- NULL
[11:00:00.703]             }
[11:00:00.703]             base::options(...future.oldOptions)
[11:00:00.703]             if (.Platform$OS.type == "windows") {
[11:00:00.703]                 old_names <- names(...future.oldEnvVars)
[11:00:00.703]                 envs <- base::Sys.getenv()
[11:00:00.703]                 names <- names(envs)
[11:00:00.703]                 common <- intersect(names, old_names)
[11:00:00.703]                 added <- setdiff(names, old_names)
[11:00:00.703]                 removed <- setdiff(old_names, names)
[11:00:00.703]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:00.703]                   envs[common]]
[11:00:00.703]                 NAMES <- toupper(changed)
[11:00:00.703]                 args <- list()
[11:00:00.703]                 for (kk in seq_along(NAMES)) {
[11:00:00.703]                   name <- changed[[kk]]
[11:00:00.703]                   NAME <- NAMES[[kk]]
[11:00:00.703]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.703]                     next
[11:00:00.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.703]                 }
[11:00:00.703]                 NAMES <- toupper(added)
[11:00:00.703]                 for (kk in seq_along(NAMES)) {
[11:00:00.703]                   name <- added[[kk]]
[11:00:00.703]                   NAME <- NAMES[[kk]]
[11:00:00.703]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.703]                     next
[11:00:00.703]                   args[[name]] <- ""
[11:00:00.703]                 }
[11:00:00.703]                 NAMES <- toupper(removed)
[11:00:00.703]                 for (kk in seq_along(NAMES)) {
[11:00:00.703]                   name <- removed[[kk]]
[11:00:00.703]                   NAME <- NAMES[[kk]]
[11:00:00.703]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.703]                     next
[11:00:00.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.703]                 }
[11:00:00.703]                 if (length(args) > 0) 
[11:00:00.703]                   base::do.call(base::Sys.setenv, args = args)
[11:00:00.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:00.703]             }
[11:00:00.703]             else {
[11:00:00.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:00.703]             }
[11:00:00.703]             {
[11:00:00.703]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:00.703]                   0L) {
[11:00:00.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:00.703]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:00.703]                   base::options(opts)
[11:00:00.703]                 }
[11:00:00.703]                 {
[11:00:00.703]                   {
[11:00:00.703]                     NULL
[11:00:00.703]                     RNGkind("Mersenne-Twister")
[11:00:00.703]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:00.703]                       inherits = FALSE)
[11:00:00.703]                   }
[11:00:00.703]                   options(future.plan = NULL)
[11:00:00.703]                   if (is.na(NA_character_)) 
[11:00:00.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:00.703]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:00.703]                     .init = FALSE)
[11:00:00.703]                 }
[11:00:00.703]             }
[11:00:00.703]         }
[11:00:00.703]     })
[11:00:00.703]     if (TRUE) {
[11:00:00.703]         base::sink(type = "output", split = FALSE)
[11:00:00.703]         if (TRUE) {
[11:00:00.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:00.703]         }
[11:00:00.703]         else {
[11:00:00.703]             ...future.result["stdout"] <- base::list(NULL)
[11:00:00.703]         }
[11:00:00.703]         base::close(...future.stdout)
[11:00:00.703]         ...future.stdout <- NULL
[11:00:00.703]     }
[11:00:00.703]     ...future.result$conditions <- ...future.conditions
[11:00:00.703]     ...future.result$finished <- base::Sys.time()
[11:00:00.703]     ...future.result
[11:00:00.703] }
[11:00:00.704] assign_globals() ...
[11:00:00.704] List of 11
[11:00:00.704]  $ ...future.FUN            :function (x, ...)  
[11:00:00.704]  $ x_FUN                    :function (x, na.rm = TRUE)  
[11:00:00.704]  $ times                    : int 5
[11:00:00.704]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.704]  $ stop_if_not              :function (...)  
[11:00:00.704]  $ dim                      : NULL
[11:00:00.704]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:00.704]  $ future.call.arguments    : list()
[11:00:00.704]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.704]  $ ...future.elements_ii    :List of 7
[11:00:00.704]   ..$ : int [1:3] 1 2 3
[11:00:00.704]   ..$ : int [1:4] 1 2 3 4
[11:00:00.704]   ..$ : int [1:5] 1 2 3 4 5
[11:00:00.704]   ..$ : int [1:6] 1 2 3 4 5 6
[11:00:00.704]   ..$ : int [1:7] 1 2 3 4 5 6 7
[11:00:00.704]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[11:00:00.704]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[11:00:00.704]  $ ...future.seeds_ii       : NULL
[11:00:00.704]  $ ...future.globals.maxSize: NULL
[11:00:00.704]  - attr(*, "where")=List of 11
[11:00:00.704]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:00.704]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:00.704]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:00.704]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:00.704]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:00.704]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:00.704]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:00.704]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:00.704]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:00.704]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:00.704]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:00.704]  - attr(*, "resolved")= logi FALSE
[11:00:00.704]  - attr(*, "total_size")= num 48005
[11:00:00.704]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.704]  - attr(*, "already-done")= logi TRUE
[11:00:00.713] - copied ‘...future.FUN’ to environment
[11:00:00.713] - copied ‘x_FUN’ to environment
[11:00:00.713] - copied ‘times’ to environment
[11:00:00.713] - copied ‘stopf’ to environment
[11:00:00.713] - copied ‘stop_if_not’ to environment
[11:00:00.713] - copied ‘dim’ to environment
[11:00:00.713] - copied ‘valid_types’ to environment
[11:00:00.713] - copied ‘future.call.arguments’ to environment
[11:00:00.713] - copied ‘...future.elements_ii’ to environment
[11:00:00.713] - copied ‘...future.seeds_ii’ to environment
[11:00:00.713] - copied ‘...future.globals.maxSize’ to environment
[11:00:00.714] assign_globals() ... done
[11:00:00.714] plan(): Setting new future strategy stack:
[11:00:00.714] List of future strategies:
[11:00:00.714] 1. sequential:
[11:00:00.714]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.714]    - tweaked: FALSE
[11:00:00.714]    - call: NULL
[11:00:00.714] plan(): nbrOfWorkers() = 1
[11:00:00.715] plan(): Setting new future strategy stack:
[11:00:00.715] List of future strategies:
[11:00:00.715] 1. sequential:
[11:00:00.715]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.715]    - tweaked: FALSE
[11:00:00.715]    - call: plan(strategy)
[11:00:00.716] plan(): nbrOfWorkers() = 1
[11:00:00.716] SequentialFuture started (and completed)
[11:00:00.716] - Launch lazy future ... done
[11:00:00.716] run() for ‘SequentialFuture’ ... done
[11:00:00.716] Created future:
[11:00:00.716] SequentialFuture:
[11:00:00.716] Label: ‘future_vapply-1’
[11:00:00.716] Expression:
[11:00:00.716] {
[11:00:00.716]     do.call(function(...) {
[11:00:00.716]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.716]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.716]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.716]             on.exit(options(oopts), add = TRUE)
[11:00:00.716]         }
[11:00:00.716]         {
[11:00:00.716]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.716]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.716]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.716]             })
[11:00:00.716]         }
[11:00:00.716]     }, args = future.call.arguments)
[11:00:00.716] }
[11:00:00.716] Lazy evaluation: FALSE
[11:00:00.716] Asynchronous evaluation: FALSE
[11:00:00.716] Local evaluation: TRUE
[11:00:00.716] Environment: R_GlobalEnv
[11:00:00.716] Capture standard output: TRUE
[11:00:00.716] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:00.716] Globals: 11 objects totaling 27.44 KiB (function ‘...future.FUN’ of 14.07 KiB, function ‘x_FUN’ of 4.67 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:00.716] Packages: 2 packages (‘stats’, ‘future.apply’)
[11:00:00.716] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:00.716] Resolved: TRUE
[11:00:00.716] Value: 367 bytes of class ‘list’
[11:00:00.716] Early signaling: FALSE
[11:00:00.716] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:00.716] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.717] Chunk #1 of 1 ... DONE
[11:00:00.717] Launching 1 futures (chunks) ... DONE
[11:00:00.717] Resolving 1 futures (chunks) ...
[11:00:00.717] resolve() on list ...
[11:00:00.717]  recursive: 0
[11:00:00.718]  length: 1
[11:00:00.718] 
[11:00:00.718] resolved() for ‘SequentialFuture’ ...
[11:00:00.718] - state: ‘finished’
[11:00:00.718] - run: TRUE
[11:00:00.718] - result: ‘FutureResult’
[11:00:00.718] resolved() for ‘SequentialFuture’ ... done
[11:00:00.718] Future #1
[11:00:00.718] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:00.718] - nx: 1
[11:00:00.718] - relay: TRUE
[11:00:00.718] - stdout: TRUE
[11:00:00.719] - signal: TRUE
[11:00:00.719] - resignal: FALSE
[11:00:00.719] - force: TRUE
[11:00:00.719] - relayed: [n=1] FALSE
[11:00:00.719] - queued futures: [n=1] FALSE
[11:00:00.719]  - until=1
[11:00:00.719]  - relaying element #1
[11:00:00.719] - relayed: [n=1] TRUE
[11:00:00.719] - queued futures: [n=1] TRUE
[11:00:00.719] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:00.719]  length: 0 (resolved future 1)
[11:00:00.720] Relaying remaining futures
[11:00:00.720] signalConditionsASAP(NULL, pos=0) ...
[11:00:00.720] - nx: 1
[11:00:00.720] - relay: TRUE
[11:00:00.720] - stdout: TRUE
[11:00:00.720] - signal: TRUE
[11:00:00.721] - resignal: FALSE
[11:00:00.721] - force: TRUE
[11:00:00.721] - relayed: [n=1] TRUE
[11:00:00.721] - queued futures: [n=1] TRUE
 - flush all
[11:00:00.721] - relayed: [n=1] TRUE
[11:00:00.721] - queued futures: [n=1] TRUE
[11:00:00.721] signalConditionsASAP(NULL, pos=0) ... done
[11:00:00.721] resolve() on list ... DONE
[11:00:00.721]  - Number of value chunks collected: 1
[11:00:00.721] Resolving 1 futures (chunks) ... DONE
[11:00:00.722] Reducing values from 1 chunks ...
[11:00:00.722]  - Number of values collected after concatenation: 7
[11:00:00.722]  - Number of values expected: 7
[11:00:00.722] Reducing values from 1 chunks ... DONE
[11:00:00.722] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[11:00:00.723] future_lapply() ...
[11:00:00.724] Number of chunks: 1
[11:00:00.724] getGlobalsAndPackagesXApply() ...
[11:00:00.724]  - future.globals: TRUE
[11:00:00.724] getGlobalsAndPackages() ...
[11:00:00.724] Searching for globals...
[11:00:00.725] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[11:00:00.726] Searching for globals ... DONE
[11:00:00.726] Resolving globals: FALSE
[11:00:00.726] The total size of the 1 globals is 680 bytes (680 bytes)
[11:00:00.726] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 680 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (680 bytes of class ‘function’)
[11:00:00.726] - globals: [1] ‘FUN’
[11:00:00.726] 
[11:00:00.727] getGlobalsAndPackages() ... DONE
[11:00:00.727]  - globals found/used: [n=1] ‘FUN’
[11:00:00.727]  - needed namespaces: [n=0] 
[11:00:00.727] Finding globals ... DONE
[11:00:00.727]  - use_args: TRUE
[11:00:00.727]  - Getting '...' globals ...
[11:00:00.727] resolve() on list ...
[11:00:00.727]  recursive: 0
[11:00:00.727]  length: 1
[11:00:00.727]  elements: ‘...’
[11:00:00.728]  length: 0 (resolved future 1)
[11:00:00.728] resolve() on list ... DONE
[11:00:00.728]    - '...' content: [n=1] ‘y’
[11:00:00.728] List of 1
[11:00:00.728]  $ ...:List of 1
[11:00:00.728]   ..$ y: num [1:5] 2 4 6 8 10
[11:00:00.728]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.728]  - attr(*, "where")=List of 1
[11:00:00.728]   ..$ ...:<environment: 0x55bbac8988e8> 
[11:00:00.728]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.728]  - attr(*, "resolved")= logi TRUE
[11:00:00.728]  - attr(*, "total_size")= num NA
[11:00:00.730]  - Getting '...' globals ... DONE
[11:00:00.731] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[11:00:00.731] List of 2
[11:00:00.731]  $ ...future.FUN:function (x, y)  
[11:00:00.731]  $ ...          :List of 1
[11:00:00.731]   ..$ y: num [1:5] 2 4 6 8 10
[11:00:00.731]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.731]  - attr(*, "where")=List of 2
[11:00:00.731]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:00.731]   ..$ ...          :<environment: 0x55bbac8988e8> 
[11:00:00.731]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.731]  - attr(*, "resolved")= logi FALSE
[11:00:00.731]  - attr(*, "total_size")= num 7318
[11:00:00.734] Packages to be attached in all futures: [n=0] 
[11:00:00.735] getGlobalsAndPackagesXApply() ... DONE
[11:00:00.735] Number of futures (= number of chunks): 1
[11:00:00.735] Launching 1 futures (chunks) ...
[11:00:00.735] Chunk #1 of 1 ...
[11:00:00.735]  - Finding globals in 'X' for chunk #1 ...
[11:00:00.735] getGlobalsAndPackages() ...
[11:00:00.736] Searching for globals...
[11:00:00.736] 
[11:00:00.736] Searching for globals ... DONE
[11:00:00.736] - globals: [0] <none>
[11:00:00.736] getGlobalsAndPackages() ... DONE
[11:00:00.736]    + additional globals found: [n=0] 
[11:00:00.736]    + additional namespaces needed: [n=0] 
[11:00:00.736]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:00.737]  - seeds: <none>
[11:00:00.737]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.737] getGlobalsAndPackages() ...
[11:00:00.737] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.737] Resolving globals: FALSE
[11:00:00.737] Tweak future expression to call with '...' arguments ...
[11:00:00.737] {
[11:00:00.737]     do.call(function(...) {
[11:00:00.737]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.737]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.737]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.737]             on.exit(options(oopts), add = TRUE)
[11:00:00.737]         }
[11:00:00.737]         {
[11:00:00.737]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.737]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.737]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.737]             })
[11:00:00.737]         }
[11:00:00.737]     }, args = future.call.arguments)
[11:00:00.737] }
[11:00:00.737] Tweak future expression to call with '...' arguments ... DONE
[11:00:00.738] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.738] 
[11:00:00.738] getGlobalsAndPackages() ... DONE
[11:00:00.738] run() for ‘Future’ ...
[11:00:00.738] - state: ‘created’
[11:00:00.738] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:00.739] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.739] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:00.739]   - Field: ‘label’
[11:00:00.739]   - Field: ‘local’
[11:00:00.739]   - Field: ‘owner’
[11:00:00.739]   - Field: ‘envir’
[11:00:00.739]   - Field: ‘packages’
[11:00:00.739]   - Field: ‘gc’
[11:00:00.739]   - Field: ‘conditions’
[11:00:00.739]   - Field: ‘expr’
[11:00:00.739]   - Field: ‘uuid’
[11:00:00.740]   - Field: ‘seed’
[11:00:00.740]   - Field: ‘version’
[11:00:00.740]   - Field: ‘result’
[11:00:00.740]   - Field: ‘asynchronous’
[11:00:00.740]   - Field: ‘calls’
[11:00:00.740]   - Field: ‘globals’
[11:00:00.740]   - Field: ‘stdout’
[11:00:00.740]   - Field: ‘earlySignal’
[11:00:00.740]   - Field: ‘lazy’
[11:00:00.740]   - Field: ‘state’
[11:00:00.740] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:00.740] - Launch lazy future ...
[11:00:00.741] Packages needed by the future expression (n = 0): <none>
[11:00:00.741] Packages needed by future strategies (n = 0): <none>
[11:00:00.741] {
[11:00:00.741]     {
[11:00:00.741]         {
[11:00:00.741]             ...future.startTime <- base::Sys.time()
[11:00:00.741]             {
[11:00:00.741]                 {
[11:00:00.741]                   {
[11:00:00.741]                     base::local({
[11:00:00.741]                       has_future <- base::requireNamespace("future", 
[11:00:00.741]                         quietly = TRUE)
[11:00:00.741]                       if (has_future) {
[11:00:00.741]                         ns <- base::getNamespace("future")
[11:00:00.741]                         version <- ns[[".package"]][["version"]]
[11:00:00.741]                         if (is.null(version)) 
[11:00:00.741]                           version <- utils::packageVersion("future")
[11:00:00.741]                       }
[11:00:00.741]                       else {
[11:00:00.741]                         version <- NULL
[11:00:00.741]                       }
[11:00:00.741]                       if (!has_future || version < "1.8.0") {
[11:00:00.741]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:00.741]                           "", base::R.version$version.string), 
[11:00:00.741]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:00.741]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:00.741]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:00.741]                             "release", "version")], collapse = " "), 
[11:00:00.741]                           hostname = base::Sys.info()[["nodename"]])
[11:00:00.741]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:00.741]                           info)
[11:00:00.741]                         info <- base::paste(info, collapse = "; ")
[11:00:00.741]                         if (!has_future) {
[11:00:00.741]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:00.741]                             info)
[11:00:00.741]                         }
[11:00:00.741]                         else {
[11:00:00.741]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:00.741]                             info, version)
[11:00:00.741]                         }
[11:00:00.741]                         base::stop(msg)
[11:00:00.741]                       }
[11:00:00.741]                     })
[11:00:00.741]                   }
[11:00:00.741]                   ...future.strategy.old <- future::plan("list")
[11:00:00.741]                   options(future.plan = NULL)
[11:00:00.741]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.741]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:00.741]                 }
[11:00:00.741]                 ...future.workdir <- getwd()
[11:00:00.741]             }
[11:00:00.741]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:00.741]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:00.741]         }
[11:00:00.741]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:00.741]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:00.741]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:00.741]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:00.741]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:00.741]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:00.741]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:00.741]             base::names(...future.oldOptions))
[11:00:00.741]     }
[11:00:00.741]     if (FALSE) {
[11:00:00.741]     }
[11:00:00.741]     else {
[11:00:00.741]         if (TRUE) {
[11:00:00.741]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:00.741]                 open = "w")
[11:00:00.741]         }
[11:00:00.741]         else {
[11:00:00.741]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:00.741]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:00.741]         }
[11:00:00.741]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:00.741]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:00.741]             base::sink(type = "output", split = FALSE)
[11:00:00.741]             base::close(...future.stdout)
[11:00:00.741]         }, add = TRUE)
[11:00:00.741]     }
[11:00:00.741]     ...future.frame <- base::sys.nframe()
[11:00:00.741]     ...future.conditions <- base::list()
[11:00:00.741]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:00.741]     if (FALSE) {
[11:00:00.741]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:00.741]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:00.741]     }
[11:00:00.741]     ...future.result <- base::tryCatch({
[11:00:00.741]         base::withCallingHandlers({
[11:00:00.741]             ...future.value <- base::withVisible(base::local({
[11:00:00.741]                 do.call(function(...) {
[11:00:00.741]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.741]                   if (!identical(...future.globals.maxSize.org, 
[11:00:00.741]                     ...future.globals.maxSize)) {
[11:00:00.741]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.741]                     on.exit(options(oopts), add = TRUE)
[11:00:00.741]                   }
[11:00:00.741]                   {
[11:00:00.741]                     lapply(seq_along(...future.elements_ii), 
[11:00:00.741]                       FUN = function(jj) {
[11:00:00.741]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.741]                         ...future.FUN(...future.X_jj, ...)
[11:00:00.741]                       })
[11:00:00.741]                   }
[11:00:00.741]                 }, args = future.call.arguments)
[11:00:00.741]             }))
[11:00:00.741]             future::FutureResult(value = ...future.value$value, 
[11:00:00.741]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.741]                   ...future.rng), globalenv = if (FALSE) 
[11:00:00.741]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:00.741]                     ...future.globalenv.names))
[11:00:00.741]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:00.741]         }, condition = base::local({
[11:00:00.741]             c <- base::c
[11:00:00.741]             inherits <- base::inherits
[11:00:00.741]             invokeRestart <- base::invokeRestart
[11:00:00.741]             length <- base::length
[11:00:00.741]             list <- base::list
[11:00:00.741]             seq.int <- base::seq.int
[11:00:00.741]             signalCondition <- base::signalCondition
[11:00:00.741]             sys.calls <- base::sys.calls
[11:00:00.741]             `[[` <- base::`[[`
[11:00:00.741]             `+` <- base::`+`
[11:00:00.741]             `<<-` <- base::`<<-`
[11:00:00.741]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:00.741]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:00.741]                   3L)]
[11:00:00.741]             }
[11:00:00.741]             function(cond) {
[11:00:00.741]                 is_error <- inherits(cond, "error")
[11:00:00.741]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:00.741]                   NULL)
[11:00:00.741]                 if (is_error) {
[11:00:00.741]                   sessionInformation <- function() {
[11:00:00.741]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:00.741]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:00.741]                       search = base::search(), system = base::Sys.info())
[11:00:00.741]                   }
[11:00:00.741]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.741]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:00.741]                     cond$call), session = sessionInformation(), 
[11:00:00.741]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:00.741]                   signalCondition(cond)
[11:00:00.741]                 }
[11:00:00.741]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:00.741]                 "immediateCondition"))) {
[11:00:00.741]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:00.741]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.741]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:00.741]                   if (TRUE && !signal) {
[11:00:00.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.741]                     {
[11:00:00.741]                       inherits <- base::inherits
[11:00:00.741]                       invokeRestart <- base::invokeRestart
[11:00:00.741]                       is.null <- base::is.null
[11:00:00.741]                       muffled <- FALSE
[11:00:00.741]                       if (inherits(cond, "message")) {
[11:00:00.741]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.741]                         if (muffled) 
[11:00:00.741]                           invokeRestart("muffleMessage")
[11:00:00.741]                       }
[11:00:00.741]                       else if (inherits(cond, "warning")) {
[11:00:00.741]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.741]                         if (muffled) 
[11:00:00.741]                           invokeRestart("muffleWarning")
[11:00:00.741]                       }
[11:00:00.741]                       else if (inherits(cond, "condition")) {
[11:00:00.741]                         if (!is.null(pattern)) {
[11:00:00.741]                           computeRestarts <- base::computeRestarts
[11:00:00.741]                           grepl <- base::grepl
[11:00:00.741]                           restarts <- computeRestarts(cond)
[11:00:00.741]                           for (restart in restarts) {
[11:00:00.741]                             name <- restart$name
[11:00:00.741]                             if (is.null(name)) 
[11:00:00.741]                               next
[11:00:00.741]                             if (!grepl(pattern, name)) 
[11:00:00.741]                               next
[11:00:00.741]                             invokeRestart(restart)
[11:00:00.741]                             muffled <- TRUE
[11:00:00.741]                             break
[11:00:00.741]                           }
[11:00:00.741]                         }
[11:00:00.741]                       }
[11:00:00.741]                       invisible(muffled)
[11:00:00.741]                     }
[11:00:00.741]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.741]                   }
[11:00:00.741]                 }
[11:00:00.741]                 else {
[11:00:00.741]                   if (TRUE) {
[11:00:00.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.741]                     {
[11:00:00.741]                       inherits <- base::inherits
[11:00:00.741]                       invokeRestart <- base::invokeRestart
[11:00:00.741]                       is.null <- base::is.null
[11:00:00.741]                       muffled <- FALSE
[11:00:00.741]                       if (inherits(cond, "message")) {
[11:00:00.741]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.741]                         if (muffled) 
[11:00:00.741]                           invokeRestart("muffleMessage")
[11:00:00.741]                       }
[11:00:00.741]                       else if (inherits(cond, "warning")) {
[11:00:00.741]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.741]                         if (muffled) 
[11:00:00.741]                           invokeRestart("muffleWarning")
[11:00:00.741]                       }
[11:00:00.741]                       else if (inherits(cond, "condition")) {
[11:00:00.741]                         if (!is.null(pattern)) {
[11:00:00.741]                           computeRestarts <- base::computeRestarts
[11:00:00.741]                           grepl <- base::grepl
[11:00:00.741]                           restarts <- computeRestarts(cond)
[11:00:00.741]                           for (restart in restarts) {
[11:00:00.741]                             name <- restart$name
[11:00:00.741]                             if (is.null(name)) 
[11:00:00.741]                               next
[11:00:00.741]                             if (!grepl(pattern, name)) 
[11:00:00.741]                               next
[11:00:00.741]                             invokeRestart(restart)
[11:00:00.741]                             muffled <- TRUE
[11:00:00.741]                             break
[11:00:00.741]                           }
[11:00:00.741]                         }
[11:00:00.741]                       }
[11:00:00.741]                       invisible(muffled)
[11:00:00.741]                     }
[11:00:00.741]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.741]                   }
[11:00:00.741]                 }
[11:00:00.741]             }
[11:00:00.741]         }))
[11:00:00.741]     }, error = function(ex) {
[11:00:00.741]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:00.741]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.741]                 ...future.rng), started = ...future.startTime, 
[11:00:00.741]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:00.741]             version = "1.8"), class = "FutureResult")
[11:00:00.741]     }, finally = {
[11:00:00.741]         if (!identical(...future.workdir, getwd())) 
[11:00:00.741]             setwd(...future.workdir)
[11:00:00.741]         {
[11:00:00.741]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:00.741]                 ...future.oldOptions$nwarnings <- NULL
[11:00:00.741]             }
[11:00:00.741]             base::options(...future.oldOptions)
[11:00:00.741]             if (.Platform$OS.type == "windows") {
[11:00:00.741]                 old_names <- names(...future.oldEnvVars)
[11:00:00.741]                 envs <- base::Sys.getenv()
[11:00:00.741]                 names <- names(envs)
[11:00:00.741]                 common <- intersect(names, old_names)
[11:00:00.741]                 added <- setdiff(names, old_names)
[11:00:00.741]                 removed <- setdiff(old_names, names)
[11:00:00.741]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:00.741]                   envs[common]]
[11:00:00.741]                 NAMES <- toupper(changed)
[11:00:00.741]                 args <- list()
[11:00:00.741]                 for (kk in seq_along(NAMES)) {
[11:00:00.741]                   name <- changed[[kk]]
[11:00:00.741]                   NAME <- NAMES[[kk]]
[11:00:00.741]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.741]                     next
[11:00:00.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.741]                 }
[11:00:00.741]                 NAMES <- toupper(added)
[11:00:00.741]                 for (kk in seq_along(NAMES)) {
[11:00:00.741]                   name <- added[[kk]]
[11:00:00.741]                   NAME <- NAMES[[kk]]
[11:00:00.741]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.741]                     next
[11:00:00.741]                   args[[name]] <- ""
[11:00:00.741]                 }
[11:00:00.741]                 NAMES <- toupper(removed)
[11:00:00.741]                 for (kk in seq_along(NAMES)) {
[11:00:00.741]                   name <- removed[[kk]]
[11:00:00.741]                   NAME <- NAMES[[kk]]
[11:00:00.741]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.741]                     next
[11:00:00.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.741]                 }
[11:00:00.741]                 if (length(args) > 0) 
[11:00:00.741]                   base::do.call(base::Sys.setenv, args = args)
[11:00:00.741]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:00.741]             }
[11:00:00.741]             else {
[11:00:00.741]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:00.741]             }
[11:00:00.741]             {
[11:00:00.741]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:00.741]                   0L) {
[11:00:00.741]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:00.741]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:00.741]                   base::options(opts)
[11:00:00.741]                 }
[11:00:00.741]                 {
[11:00:00.741]                   {
[11:00:00.741]                     NULL
[11:00:00.741]                     RNGkind("Mersenne-Twister")
[11:00:00.741]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:00.741]                       inherits = FALSE)
[11:00:00.741]                   }
[11:00:00.741]                   options(future.plan = NULL)
[11:00:00.741]                   if (is.na(NA_character_)) 
[11:00:00.741]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.741]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:00.741]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:00.741]                     .init = FALSE)
[11:00:00.741]                 }
[11:00:00.741]             }
[11:00:00.741]         }
[11:00:00.741]     })
[11:00:00.741]     if (TRUE) {
[11:00:00.741]         base::sink(type = "output", split = FALSE)
[11:00:00.741]         if (TRUE) {
[11:00:00.741]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:00.741]         }
[11:00:00.741]         else {
[11:00:00.741]             ...future.result["stdout"] <- base::list(NULL)
[11:00:00.741]         }
[11:00:00.741]         base::close(...future.stdout)
[11:00:00.741]         ...future.stdout <- NULL
[11:00:00.741]     }
[11:00:00.741]     ...future.result$conditions <- ...future.conditions
[11:00:00.741]     ...future.result$finished <- base::Sys.time()
[11:00:00.741]     ...future.result
[11:00:00.741] }
[11:00:00.743] assign_globals() ...
[11:00:00.743] List of 5
[11:00:00.743]  $ ...future.FUN            :function (x, y)  
[11:00:00.743]  $ future.call.arguments    :List of 1
[11:00:00.743]   ..$ y: num [1:5] 2 4 6 8 10
[11:00:00.743]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.743]  $ ...future.elements_ii    :List of 4
[11:00:00.743]   ..$ A: num 50
[11:00:00.743]   ..$ B: num 60
[11:00:00.743]   ..$ C: num 70
[11:00:00.743]   ..$ D: num 80
[11:00:00.743]  $ ...future.seeds_ii       : NULL
[11:00:00.743]  $ ...future.globals.maxSize: NULL
[11:00:00.743]  - attr(*, "where")=List of 5
[11:00:00.743]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:00.743]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:00.743]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:00.743]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:00.743]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:00.743]  - attr(*, "resolved")= logi FALSE
[11:00:00.743]  - attr(*, "total_size")= num 7318
[11:00:00.743]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.743]  - attr(*, "already-done")= logi TRUE
[11:00:00.750] - reassign environment for ‘...future.FUN’
[11:00:00.750] - copied ‘...future.FUN’ to environment
[11:00:00.750] - copied ‘future.call.arguments’ to environment
[11:00:00.750] - copied ‘...future.elements_ii’ to environment
[11:00:00.750] - copied ‘...future.seeds_ii’ to environment
[11:00:00.750] - copied ‘...future.globals.maxSize’ to environment
[11:00:00.751] assign_globals() ... done
[11:00:00.751] plan(): Setting new future strategy stack:
[11:00:00.751] List of future strategies:
[11:00:00.751] 1. sequential:
[11:00:00.751]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.751]    - tweaked: FALSE
[11:00:00.751]    - call: NULL
[11:00:00.751] plan(): nbrOfWorkers() = 1
[11:00:00.752] plan(): Setting new future strategy stack:
[11:00:00.752] List of future strategies:
[11:00:00.752] 1. sequential:
[11:00:00.752]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.752]    - tweaked: FALSE
[11:00:00.752]    - call: plan(strategy)
[11:00:00.753] plan(): nbrOfWorkers() = 1
[11:00:00.753] SequentialFuture started (and completed)
[11:00:00.753] - Launch lazy future ... done
[11:00:00.753] run() for ‘SequentialFuture’ ... done
[11:00:00.753] Created future:
[11:00:00.753] SequentialFuture:
[11:00:00.753] Label: ‘future_sapply-1’
[11:00:00.753] Expression:
[11:00:00.753] {
[11:00:00.753]     do.call(function(...) {
[11:00:00.753]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.753]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.753]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.753]             on.exit(options(oopts), add = TRUE)
[11:00:00.753]         }
[11:00:00.753]         {
[11:00:00.753]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.753]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.753]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.753]             })
[11:00:00.753]         }
[11:00:00.753]     }, args = future.call.arguments)
[11:00:00.753] }
[11:00:00.753] Lazy evaluation: FALSE
[11:00:00.753] Asynchronous evaluation: FALSE
[11:00:00.753] Local evaluation: TRUE
[11:00:00.753] Environment: R_GlobalEnv
[11:00:00.753] Capture standard output: TRUE
[11:00:00.753] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:00.753] Globals: 5 objects totaling 1.06 KiB (function ‘...future.FUN’ of 680 bytes, DotDotDotList ‘future.call.arguments’ of 183 bytes, list ‘...future.elements_ii’ of 164 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:00.753] Packages: <none>
[11:00:00.753] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:00.753] Resolved: TRUE
[11:00:00.753] Value: 666 bytes of class ‘list’
[11:00:00.753] Early signaling: FALSE
[11:00:00.753] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:00.753] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.754] Chunk #1 of 1 ... DONE
[11:00:00.754] Launching 1 futures (chunks) ... DONE
[11:00:00.754] Resolving 1 futures (chunks) ...
[11:00:00.754] resolve() on list ...
[11:00:00.754]  recursive: 0
[11:00:00.754]  length: 1
[11:00:00.754] 
[11:00:00.754] resolved() for ‘SequentialFuture’ ...
[11:00:00.755] - state: ‘finished’
[11:00:00.755] - run: TRUE
[11:00:00.755] - result: ‘FutureResult’
[11:00:00.755] resolved() for ‘SequentialFuture’ ... done
[11:00:00.755] Future #1
[11:00:00.755] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:00.755] - nx: 1
[11:00:00.755] - relay: TRUE
[11:00:00.755] - stdout: TRUE
[11:00:00.755] - signal: TRUE
[11:00:00.755] - resignal: FALSE
[11:00:00.755] - force: TRUE
[11:00:00.755] - relayed: [n=1] FALSE
[11:00:00.756] - queued futures: [n=1] FALSE
[11:00:00.756]  - until=1
[11:00:00.756]  - relaying element #1
[11:00:00.756] - relayed: [n=1] TRUE
[11:00:00.756] - queued futures: [n=1] TRUE
[11:00:00.756] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:00.756]  length: 0 (resolved future 1)
[11:00:00.756] Relaying remaining futures
[11:00:00.756] signalConditionsASAP(NULL, pos=0) ...
[11:00:00.756] - nx: 1
[11:00:00.756] - relay: TRUE
[11:00:00.757] - stdout: TRUE
[11:00:00.757] - signal: TRUE
[11:00:00.757] - resignal: FALSE
[11:00:00.757] - force: TRUE
[11:00:00.757] - relayed: [n=1] TRUE
[11:00:00.757] - queued futures: [n=1] TRUE
 - flush all
[11:00:00.757] - relayed: [n=1] TRUE
[11:00:00.757] - queued futures: [n=1] TRUE
[11:00:00.757] signalConditionsASAP(NULL, pos=0) ... done
[11:00:00.757] resolve() on list ... DONE
[11:00:00.757]  - Number of value chunks collected: 1
[11:00:00.757] Resolving 1 futures (chunks) ... DONE
[11:00:00.758] Reducing values from 1 chunks ...
[11:00:00.758]  - Number of values collected after concatenation: 4
[11:00:00.758]  - Number of values expected: 4
[11:00:00.758] Reducing values from 1 chunks ... DONE
[11:00:00.758] future_lapply() ... DONE
[11:00:00.758] future_lapply() ...
[11:00:00.760] Number of chunks: 1
[11:00:00.760] getGlobalsAndPackagesXApply() ...
[11:00:00.760]  - future.globals: TRUE
[11:00:00.760] getGlobalsAndPackages() ...
[11:00:00.760] Searching for globals...
[11:00:00.763] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[11:00:00.763] Searching for globals ... DONE
[11:00:00.764] Resolving globals: FALSE
[11:00:00.765] The total size of the 7 globals is 14.32 KiB (14666 bytes)
[11:00:00.766] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 14.32 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.67 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:00.766] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.766] - packages: [1] ‘future.apply’
[11:00:00.766] getGlobalsAndPackages() ... DONE
[11:00:00.766]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.766]  - needed namespaces: [n=1] ‘future.apply’
[11:00:00.766] Finding globals ... DONE
[11:00:00.766]  - use_args: TRUE
[11:00:00.766]  - Getting '...' globals ...
[11:00:00.767] resolve() on list ...
[11:00:00.767]  recursive: 0
[11:00:00.767]  length: 1
[11:00:00.767]  elements: ‘...’
[11:00:00.767]  length: 0 (resolved future 1)
[11:00:00.768] resolve() on list ... DONE
[11:00:00.768]    - '...' content: [n=1] ‘y’
[11:00:00.768] List of 1
[11:00:00.768]  $ ...:List of 1
[11:00:00.768]   ..$ y: num [1:5] 2 4 6 8 10
[11:00:00.768]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.768]  - attr(*, "where")=List of 1
[11:00:00.768]   ..$ ...:<environment: 0x55bbad44a410> 
[11:00:00.768]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.768]  - attr(*, "resolved")= logi TRUE
[11:00:00.768]  - attr(*, "total_size")= num NA
[11:00:00.772]  - Getting '...' globals ... DONE
[11:00:00.772] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:00.772] List of 8
[11:00:00.772]  $ ...future.FUN:function (x, ...)  
[11:00:00.772]  $ x_FUN        :function (x, y)  
[11:00:00.772]  $ times        : int 15
[11:00:00.772]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.772]  $ stop_if_not  :function (...)  
[11:00:00.772]  $ dim          : int [1:2] 3 5
[11:00:00.772]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:00.772]  $ ...          :List of 1
[11:00:00.772]   ..$ y: num [1:5] 2 4 6 8 10
[11:00:00.772]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.772]  - attr(*, "where")=List of 8
[11:00:00.772]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:00.772]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:00.772]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:00.772]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:00.772]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:00.772]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:00.772]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:00.772]   ..$ ...          :<environment: 0x55bbad44a410> 
[11:00:00.772]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.772]  - attr(*, "resolved")= logi FALSE
[11:00:00.772]  - attr(*, "total_size")= num 26659
[11:00:00.781] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:00.781] getGlobalsAndPackagesXApply() ... DONE
[11:00:00.781] Number of futures (= number of chunks): 1
[11:00:00.781] Launching 1 futures (chunks) ...
[11:00:00.781] Chunk #1 of 1 ...
[11:00:00.781]  - Finding globals in 'X' for chunk #1 ...
[11:00:00.782] getGlobalsAndPackages() ...
[11:00:00.782] Searching for globals...
[11:00:00.782] 
[11:00:00.782] Searching for globals ... DONE
[11:00:00.782] - globals: [0] <none>
[11:00:00.782] getGlobalsAndPackages() ... DONE
[11:00:00.783]    + additional globals found: [n=0] 
[11:00:00.783]    + additional namespaces needed: [n=0] 
[11:00:00.783]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:00.783]  - seeds: <none>
[11:00:00.783]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.783] getGlobalsAndPackages() ...
[11:00:00.783] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.784] Resolving globals: FALSE
[11:00:00.784] Tweak future expression to call with '...' arguments ...
[11:00:00.784] {
[11:00:00.784]     do.call(function(...) {
[11:00:00.784]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.784]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.784]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.784]             on.exit(options(oopts), add = TRUE)
[11:00:00.784]         }
[11:00:00.784]         {
[11:00:00.784]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.784]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.784]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.784]             })
[11:00:00.784]         }
[11:00:00.784]     }, args = future.call.arguments)
[11:00:00.784] }
[11:00:00.784] Tweak future expression to call with '...' arguments ... DONE
[11:00:00.785] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.785] - packages: [1] ‘future.apply’
[11:00:00.785] getGlobalsAndPackages() ... DONE
[11:00:00.786] run() for ‘Future’ ...
[11:00:00.786] - state: ‘created’
[11:00:00.786] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:00.786] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.787] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:00.787]   - Field: ‘label’
[11:00:00.787]   - Field: ‘local’
[11:00:00.787]   - Field: ‘owner’
[11:00:00.787]   - Field: ‘envir’
[11:00:00.787]   - Field: ‘packages’
[11:00:00.787]   - Field: ‘gc’
[11:00:00.787]   - Field: ‘conditions’
[11:00:00.788]   - Field: ‘expr’
[11:00:00.788]   - Field: ‘uuid’
[11:00:00.788]   - Field: ‘seed’
[11:00:00.788]   - Field: ‘version’
[11:00:00.788]   - Field: ‘result’
[11:00:00.788]   - Field: ‘asynchronous’
[11:00:00.788]   - Field: ‘calls’
[11:00:00.789]   - Field: ‘globals’
[11:00:00.789]   - Field: ‘stdout’
[11:00:00.789]   - Field: ‘earlySignal’
[11:00:00.789]   - Field: ‘lazy’
[11:00:00.789]   - Field: ‘state’
[11:00:00.789] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:00.789] - Launch lazy future ...
[11:00:00.790] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:00.790] Packages needed by future strategies (n = 0): <none>
[11:00:00.790] {
[11:00:00.790]     {
[11:00:00.790]         {
[11:00:00.790]             ...future.startTime <- base::Sys.time()
[11:00:00.790]             {
[11:00:00.790]                 {
[11:00:00.790]                   {
[11:00:00.790]                     {
[11:00:00.790]                       base::local({
[11:00:00.790]                         has_future <- base::requireNamespace("future", 
[11:00:00.790]                           quietly = TRUE)
[11:00:00.790]                         if (has_future) {
[11:00:00.790]                           ns <- base::getNamespace("future")
[11:00:00.790]                           version <- ns[[".package"]][["version"]]
[11:00:00.790]                           if (is.null(version)) 
[11:00:00.790]                             version <- utils::packageVersion("future")
[11:00:00.790]                         }
[11:00:00.790]                         else {
[11:00:00.790]                           version <- NULL
[11:00:00.790]                         }
[11:00:00.790]                         if (!has_future || version < "1.8.0") {
[11:00:00.790]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:00.790]                             "", base::R.version$version.string), 
[11:00:00.790]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:00.790]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:00.790]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:00.790]                               "release", "version")], collapse = " "), 
[11:00:00.790]                             hostname = base::Sys.info()[["nodename"]])
[11:00:00.790]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:00.790]                             info)
[11:00:00.790]                           info <- base::paste(info, collapse = "; ")
[11:00:00.790]                           if (!has_future) {
[11:00:00.790]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:00.790]                               info)
[11:00:00.790]                           }
[11:00:00.790]                           else {
[11:00:00.790]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:00.790]                               info, version)
[11:00:00.790]                           }
[11:00:00.790]                           base::stop(msg)
[11:00:00.790]                         }
[11:00:00.790]                       })
[11:00:00.790]                     }
[11:00:00.790]                     base::local({
[11:00:00.790]                       for (pkg in "future.apply") {
[11:00:00.790]                         base::loadNamespace(pkg)
[11:00:00.790]                         base::library(pkg, character.only = TRUE)
[11:00:00.790]                       }
[11:00:00.790]                     })
[11:00:00.790]                   }
[11:00:00.790]                   ...future.strategy.old <- future::plan("list")
[11:00:00.790]                   options(future.plan = NULL)
[11:00:00.790]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.790]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:00.790]                 }
[11:00:00.790]                 ...future.workdir <- getwd()
[11:00:00.790]             }
[11:00:00.790]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:00.790]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:00.790]         }
[11:00:00.790]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:00.790]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:00.790]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:00.790]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:00.790]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:00.790]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:00.790]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:00.790]             base::names(...future.oldOptions))
[11:00:00.790]     }
[11:00:00.790]     if (FALSE) {
[11:00:00.790]     }
[11:00:00.790]     else {
[11:00:00.790]         if (TRUE) {
[11:00:00.790]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:00.790]                 open = "w")
[11:00:00.790]         }
[11:00:00.790]         else {
[11:00:00.790]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:00.790]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:00.790]         }
[11:00:00.790]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:00.790]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:00.790]             base::sink(type = "output", split = FALSE)
[11:00:00.790]             base::close(...future.stdout)
[11:00:00.790]         }, add = TRUE)
[11:00:00.790]     }
[11:00:00.790]     ...future.frame <- base::sys.nframe()
[11:00:00.790]     ...future.conditions <- base::list()
[11:00:00.790]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:00.790]     if (FALSE) {
[11:00:00.790]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:00.790]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:00.790]     }
[11:00:00.790]     ...future.result <- base::tryCatch({
[11:00:00.790]         base::withCallingHandlers({
[11:00:00.790]             ...future.value <- base::withVisible(base::local({
[11:00:00.790]                 do.call(function(...) {
[11:00:00.790]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.790]                   if (!identical(...future.globals.maxSize.org, 
[11:00:00.790]                     ...future.globals.maxSize)) {
[11:00:00.790]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.790]                     on.exit(options(oopts), add = TRUE)
[11:00:00.790]                   }
[11:00:00.790]                   {
[11:00:00.790]                     lapply(seq_along(...future.elements_ii), 
[11:00:00.790]                       FUN = function(jj) {
[11:00:00.790]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.790]                         ...future.FUN(...future.X_jj, ...)
[11:00:00.790]                       })
[11:00:00.790]                   }
[11:00:00.790]                 }, args = future.call.arguments)
[11:00:00.790]             }))
[11:00:00.790]             future::FutureResult(value = ...future.value$value, 
[11:00:00.790]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.790]                   ...future.rng), globalenv = if (FALSE) 
[11:00:00.790]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:00.790]                     ...future.globalenv.names))
[11:00:00.790]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:00.790]         }, condition = base::local({
[11:00:00.790]             c <- base::c
[11:00:00.790]             inherits <- base::inherits
[11:00:00.790]             invokeRestart <- base::invokeRestart
[11:00:00.790]             length <- base::length
[11:00:00.790]             list <- base::list
[11:00:00.790]             seq.int <- base::seq.int
[11:00:00.790]             signalCondition <- base::signalCondition
[11:00:00.790]             sys.calls <- base::sys.calls
[11:00:00.790]             `[[` <- base::`[[`
[11:00:00.790]             `+` <- base::`+`
[11:00:00.790]             `<<-` <- base::`<<-`
[11:00:00.790]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:00.790]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:00.790]                   3L)]
[11:00:00.790]             }
[11:00:00.790]             function(cond) {
[11:00:00.790]                 is_error <- inherits(cond, "error")
[11:00:00.790]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:00.790]                   NULL)
[11:00:00.790]                 if (is_error) {
[11:00:00.790]                   sessionInformation <- function() {
[11:00:00.790]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:00.790]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:00.790]                       search = base::search(), system = base::Sys.info())
[11:00:00.790]                   }
[11:00:00.790]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.790]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:00.790]                     cond$call), session = sessionInformation(), 
[11:00:00.790]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:00.790]                   signalCondition(cond)
[11:00:00.790]                 }
[11:00:00.790]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:00.790]                 "immediateCondition"))) {
[11:00:00.790]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:00.790]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.790]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:00.790]                   if (TRUE && !signal) {
[11:00:00.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.790]                     {
[11:00:00.790]                       inherits <- base::inherits
[11:00:00.790]                       invokeRestart <- base::invokeRestart
[11:00:00.790]                       is.null <- base::is.null
[11:00:00.790]                       muffled <- FALSE
[11:00:00.790]                       if (inherits(cond, "message")) {
[11:00:00.790]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.790]                         if (muffled) 
[11:00:00.790]                           invokeRestart("muffleMessage")
[11:00:00.790]                       }
[11:00:00.790]                       else if (inherits(cond, "warning")) {
[11:00:00.790]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.790]                         if (muffled) 
[11:00:00.790]                           invokeRestart("muffleWarning")
[11:00:00.790]                       }
[11:00:00.790]                       else if (inherits(cond, "condition")) {
[11:00:00.790]                         if (!is.null(pattern)) {
[11:00:00.790]                           computeRestarts <- base::computeRestarts
[11:00:00.790]                           grepl <- base::grepl
[11:00:00.790]                           restarts <- computeRestarts(cond)
[11:00:00.790]                           for (restart in restarts) {
[11:00:00.790]                             name <- restart$name
[11:00:00.790]                             if (is.null(name)) 
[11:00:00.790]                               next
[11:00:00.790]                             if (!grepl(pattern, name)) 
[11:00:00.790]                               next
[11:00:00.790]                             invokeRestart(restart)
[11:00:00.790]                             muffled <- TRUE
[11:00:00.790]                             break
[11:00:00.790]                           }
[11:00:00.790]                         }
[11:00:00.790]                       }
[11:00:00.790]                       invisible(muffled)
[11:00:00.790]                     }
[11:00:00.790]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.790]                   }
[11:00:00.790]                 }
[11:00:00.790]                 else {
[11:00:00.790]                   if (TRUE) {
[11:00:00.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.790]                     {
[11:00:00.790]                       inherits <- base::inherits
[11:00:00.790]                       invokeRestart <- base::invokeRestart
[11:00:00.790]                       is.null <- base::is.null
[11:00:00.790]                       muffled <- FALSE
[11:00:00.790]                       if (inherits(cond, "message")) {
[11:00:00.790]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.790]                         if (muffled) 
[11:00:00.790]                           invokeRestart("muffleMessage")
[11:00:00.790]                       }
[11:00:00.790]                       else if (inherits(cond, "warning")) {
[11:00:00.790]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.790]                         if (muffled) 
[11:00:00.790]                           invokeRestart("muffleWarning")
[11:00:00.790]                       }
[11:00:00.790]                       else if (inherits(cond, "condition")) {
[11:00:00.790]                         if (!is.null(pattern)) {
[11:00:00.790]                           computeRestarts <- base::computeRestarts
[11:00:00.790]                           grepl <- base::grepl
[11:00:00.790]                           restarts <- computeRestarts(cond)
[11:00:00.790]                           for (restart in restarts) {
[11:00:00.790]                             name <- restart$name
[11:00:00.790]                             if (is.null(name)) 
[11:00:00.790]                               next
[11:00:00.790]                             if (!grepl(pattern, name)) 
[11:00:00.790]                               next
[11:00:00.790]                             invokeRestart(restart)
[11:00:00.790]                             muffled <- TRUE
[11:00:00.790]                             break
[11:00:00.790]                           }
[11:00:00.790]                         }
[11:00:00.790]                       }
[11:00:00.790]                       invisible(muffled)
[11:00:00.790]                     }
[11:00:00.790]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.790]                   }
[11:00:00.790]                 }
[11:00:00.790]             }
[11:00:00.790]         }))
[11:00:00.790]     }, error = function(ex) {
[11:00:00.790]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:00.790]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.790]                 ...future.rng), started = ...future.startTime, 
[11:00:00.790]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:00.790]             version = "1.8"), class = "FutureResult")
[11:00:00.790]     }, finally = {
[11:00:00.790]         if (!identical(...future.workdir, getwd())) 
[11:00:00.790]             setwd(...future.workdir)
[11:00:00.790]         {
[11:00:00.790]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:00.790]                 ...future.oldOptions$nwarnings <- NULL
[11:00:00.790]             }
[11:00:00.790]             base::options(...future.oldOptions)
[11:00:00.790]             if (.Platform$OS.type == "windows") {
[11:00:00.790]                 old_names <- names(...future.oldEnvVars)
[11:00:00.790]                 envs <- base::Sys.getenv()
[11:00:00.790]                 names <- names(envs)
[11:00:00.790]                 common <- intersect(names, old_names)
[11:00:00.790]                 added <- setdiff(names, old_names)
[11:00:00.790]                 removed <- setdiff(old_names, names)
[11:00:00.790]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:00.790]                   envs[common]]
[11:00:00.790]                 NAMES <- toupper(changed)
[11:00:00.790]                 args <- list()
[11:00:00.790]                 for (kk in seq_along(NAMES)) {
[11:00:00.790]                   name <- changed[[kk]]
[11:00:00.790]                   NAME <- NAMES[[kk]]
[11:00:00.790]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.790]                     next
[11:00:00.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.790]                 }
[11:00:00.790]                 NAMES <- toupper(added)
[11:00:00.790]                 for (kk in seq_along(NAMES)) {
[11:00:00.790]                   name <- added[[kk]]
[11:00:00.790]                   NAME <- NAMES[[kk]]
[11:00:00.790]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.790]                     next
[11:00:00.790]                   args[[name]] <- ""
[11:00:00.790]                 }
[11:00:00.790]                 NAMES <- toupper(removed)
[11:00:00.790]                 for (kk in seq_along(NAMES)) {
[11:00:00.790]                   name <- removed[[kk]]
[11:00:00.790]                   NAME <- NAMES[[kk]]
[11:00:00.790]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.790]                     next
[11:00:00.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.790]                 }
[11:00:00.790]                 if (length(args) > 0) 
[11:00:00.790]                   base::do.call(base::Sys.setenv, args = args)
[11:00:00.790]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:00.790]             }
[11:00:00.790]             else {
[11:00:00.790]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:00.790]             }
[11:00:00.790]             {
[11:00:00.790]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:00.790]                   0L) {
[11:00:00.790]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:00.790]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:00.790]                   base::options(opts)
[11:00:00.790]                 }
[11:00:00.790]                 {
[11:00:00.790]                   {
[11:00:00.790]                     NULL
[11:00:00.790]                     RNGkind("Mersenne-Twister")
[11:00:00.790]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:00.790]                       inherits = FALSE)
[11:00:00.790]                   }
[11:00:00.790]                   options(future.plan = NULL)
[11:00:00.790]                   if (is.na(NA_character_)) 
[11:00:00.790]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.790]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:00.790]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:00.790]                     .init = FALSE)
[11:00:00.790]                 }
[11:00:00.790]             }
[11:00:00.790]         }
[11:00:00.790]     })
[11:00:00.790]     if (TRUE) {
[11:00:00.790]         base::sink(type = "output", split = FALSE)
[11:00:00.790]         if (TRUE) {
[11:00:00.790]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:00.790]         }
[11:00:00.790]         else {
[11:00:00.790]             ...future.result["stdout"] <- base::list(NULL)
[11:00:00.790]         }
[11:00:00.790]         base::close(...future.stdout)
[11:00:00.790]         ...future.stdout <- NULL
[11:00:00.790]     }
[11:00:00.790]     ...future.result$conditions <- ...future.conditions
[11:00:00.790]     ...future.result$finished <- base::Sys.time()
[11:00:00.790]     ...future.result
[11:00:00.790] }
[11:00:00.793] assign_globals() ...
[11:00:00.793] List of 11
[11:00:00.793]  $ ...future.FUN            :function (x, ...)  
[11:00:00.793]  $ x_FUN                    :function (x, y)  
[11:00:00.793]  $ times                    : int 15
[11:00:00.793]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.793]  $ stop_if_not              :function (...)  
[11:00:00.793]  $ dim                      : int [1:2] 3 5
[11:00:00.793]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:00.793]  $ future.call.arguments    :List of 1
[11:00:00.793]   ..$ y: num [1:5] 2 4 6 8 10
[11:00:00.793]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.793]  $ ...future.elements_ii    :List of 4
[11:00:00.793]   ..$ A: num 50
[11:00:00.793]   ..$ B: num 60
[11:00:00.793]   ..$ C: num 70
[11:00:00.793]   ..$ D: num 80
[11:00:00.793]  $ ...future.seeds_ii       : NULL
[11:00:00.793]  $ ...future.globals.maxSize: NULL
[11:00:00.793]  - attr(*, "where")=List of 11
[11:00:00.793]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:00.793]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:00.793]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:00.793]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:00.793]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:00.793]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:00.793]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:00.793]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:00.793]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:00.793]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:00.793]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:00.793]  - attr(*, "resolved")= logi FALSE
[11:00:00.793]  - attr(*, "total_size")= num 26659
[11:00:00.793]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.793]  - attr(*, "already-done")= logi TRUE
[11:00:00.805] - copied ‘...future.FUN’ to environment
[11:00:00.805] - reassign environment for ‘x_FUN’
[11:00:00.805] - copied ‘x_FUN’ to environment
[11:00:00.805] - copied ‘times’ to environment
[11:00:00.806] - copied ‘stopf’ to environment
[11:00:00.806] - copied ‘stop_if_not’ to environment
[11:00:00.806] - copied ‘dim’ to environment
[11:00:00.806] - copied ‘valid_types’ to environment
[11:00:00.806] - copied ‘future.call.arguments’ to environment
[11:00:00.806] - copied ‘...future.elements_ii’ to environment
[11:00:00.806] - copied ‘...future.seeds_ii’ to environment
[11:00:00.807] - copied ‘...future.globals.maxSize’ to environment
[11:00:00.807] assign_globals() ... done
[11:00:00.807] plan(): Setting new future strategy stack:
[11:00:00.807] List of future strategies:
[11:00:00.807] 1. sequential:
[11:00:00.807]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.807]    - tweaked: FALSE
[11:00:00.807]    - call: NULL
[11:00:00.808] plan(): nbrOfWorkers() = 1
[11:00:00.809] plan(): Setting new future strategy stack:
[11:00:00.809] List of future strategies:
[11:00:00.809] 1. sequential:
[11:00:00.809]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.809]    - tweaked: FALSE
[11:00:00.809]    - call: plan(strategy)
[11:00:00.810] plan(): nbrOfWorkers() = 1
[11:00:00.810] SequentialFuture started (and completed)
[11:00:00.810] - Launch lazy future ... done
[11:00:00.810] run() for ‘SequentialFuture’ ... done
[11:00:00.811] Created future:
[11:00:00.811] SequentialFuture:
[11:00:00.811] Label: ‘future_vapply-1’
[11:00:00.811] Expression:
[11:00:00.811] {
[11:00:00.811]     do.call(function(...) {
[11:00:00.811]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.811]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.811]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.811]             on.exit(options(oopts), add = TRUE)
[11:00:00.811]         }
[11:00:00.811]         {
[11:00:00.811]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.811]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.811]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.811]             })
[11:00:00.811]         }
[11:00:00.811]     }, args = future.call.arguments)
[11:00:00.811] }
[11:00:00.811] Lazy evaluation: FALSE
[11:00:00.811] Asynchronous evaluation: FALSE
[11:00:00.811] Local evaluation: TRUE
[11:00:00.811] Environment: R_GlobalEnv
[11:00:00.811] Capture standard output: TRUE
[11:00:00.811] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:00.811] Globals: 11 objects totaling 14.71 KiB (function ‘...future.FUN’ of 5.67 KiB, function ‘x_FUN’ of 680 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:00.811] Packages: 1 packages (‘future.apply’)
[11:00:00.811] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:00.811] Resolved: TRUE
[11:00:00.811] Value: 666 bytes of class ‘list’
[11:00:00.811] Early signaling: FALSE
[11:00:00.811] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:00.811] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.812] Chunk #1 of 1 ... DONE
[11:00:00.812] Launching 1 futures (chunks) ... DONE
[11:00:00.812] Resolving 1 futures (chunks) ...
[11:00:00.812] resolve() on list ...
[11:00:00.813]  recursive: 0
[11:00:00.813]  length: 1
[11:00:00.813] 
[11:00:00.813] resolved() for ‘SequentialFuture’ ...
[11:00:00.813] - state: ‘finished’
[11:00:00.813] - run: TRUE
[11:00:00.813] - result: ‘FutureResult’
[11:00:00.813] resolved() for ‘SequentialFuture’ ... done
[11:00:00.814] Future #1
[11:00:00.814] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:00.814] - nx: 1
[11:00:00.814] - relay: TRUE
[11:00:00.814] - stdout: TRUE
[11:00:00.814] - signal: TRUE
[11:00:00.814] - resignal: FALSE
[11:00:00.815] - force: TRUE
[11:00:00.815] - relayed: [n=1] FALSE
[11:00:00.815] - queued futures: [n=1] FALSE
[11:00:00.815]  - until=1
[11:00:00.815]  - relaying element #1
[11:00:00.815] - relayed: [n=1] TRUE
[11:00:00.815] - queued futures: [n=1] TRUE
[11:00:00.816] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:00.816]  length: 0 (resolved future 1)
[11:00:00.816] Relaying remaining futures
[11:00:00.816] signalConditionsASAP(NULL, pos=0) ...
[11:00:00.816] - nx: 1
[11:00:00.816] - relay: TRUE
[11:00:00.816] - stdout: TRUE
[11:00:00.816] - signal: TRUE
[11:00:00.817] - resignal: FALSE
[11:00:00.817] - force: TRUE
[11:00:00.817] - relayed: [n=1] TRUE
[11:00:00.817] - queued futures: [n=1] TRUE
 - flush all
[11:00:00.817] - relayed: [n=1] TRUE
[11:00:00.817] - queued futures: [n=1] TRUE
[11:00:00.817] signalConditionsASAP(NULL, pos=0) ... done
[11:00:00.817] resolve() on list ... DONE
[11:00:00.818]  - Number of value chunks collected: 1
[11:00:00.818] Resolving 1 futures (chunks) ... DONE
[11:00:00.818] Reducing values from 1 chunks ...
[11:00:00.818]  - Number of values collected after concatenation: 4
[11:00:00.818]  - Number of values expected: 4
[11:00:00.818] Reducing values from 1 chunks ... DONE
[11:00:00.818] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[11:00:00.821] future_lapply() ...
[11:00:00.824] Number of chunks: 1
[11:00:00.824] getGlobalsAndPackagesXApply() ...
[11:00:00.824]  - future.globals: TRUE
[11:00:00.824] getGlobalsAndPackages() ...
[11:00:00.824] Searching for globals...
[11:00:00.831] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[11:00:00.831] Searching for globals ... DONE
[11:00:00.831] Resolving globals: FALSE
[11:00:00.832] The total size of the 7 globals is 14.73 KiB (15079 bytes)
[11:00:00.832] The total size of the 7 globals exported for future expression (‘FUN()’) is 14.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (6.74 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:00.833] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.833] - packages: [1] ‘future.apply’
[11:00:00.833] getGlobalsAndPackages() ... DONE
[11:00:00.833]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.833]  - needed namespaces: [n=1] ‘future.apply’
[11:00:00.833] Finding globals ... DONE
[11:00:00.833]  - use_args: TRUE
[11:00:00.833]  - Getting '...' globals ...
[11:00:00.834] resolve() on list ...
[11:00:00.834]  recursive: 0
[11:00:00.834]  length: 1
[11:00:00.834]  elements: ‘...’
[11:00:00.834]  length: 0 (resolved future 1)
[11:00:00.834] resolve() on list ... DONE
[11:00:00.834]    - '...' content: [n=0] 
[11:00:00.834] List of 1
[11:00:00.834]  $ ...: list()
[11:00:00.834]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.834]  - attr(*, "where")=List of 1
[11:00:00.834]   ..$ ...:<environment: 0x55bbad6d2278> 
[11:00:00.834]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.834]  - attr(*, "resolved")= logi TRUE
[11:00:00.834]  - attr(*, "total_size")= num NA
[11:00:00.837]  - Getting '...' globals ... DONE
[11:00:00.837] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:00.837] List of 8
[11:00:00.837]  $ ...future.FUN:function (x, ...)  
[11:00:00.837]  $ x_FUN        :function (x)  
[11:00:00.837]  $ times        : int 1
[11:00:00.837]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.837]  $ stop_if_not  :function (...)  
[11:00:00.837]  $ dim          : NULL
[11:00:00.837]  $ valid_types  : chr "logical"
[11:00:00.837]  $ ...          : list()
[11:00:00.837]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.837]  - attr(*, "where")=List of 8
[11:00:00.837]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:00.837]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:00.837]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:00.837]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:00.837]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:00.837]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:00.837]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:00.837]   ..$ ...          :<environment: 0x55bbad6d2278> 
[11:00:00.837]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.837]  - attr(*, "resolved")= logi FALSE
[11:00:00.837]  - attr(*, "total_size")= num 30734
[11:00:00.842] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:00.842] getGlobalsAndPackagesXApply() ... DONE
[11:00:00.842] Number of futures (= number of chunks): 1
[11:00:00.843] Launching 1 futures (chunks) ...
[11:00:00.843] Chunk #1 of 1 ...
[11:00:00.843]  - Finding globals in 'X' for chunk #1 ...
[11:00:00.843] getGlobalsAndPackages() ...
[11:00:00.843] Searching for globals...
[11:00:00.843] 
[11:00:00.843] Searching for globals ... DONE
[11:00:00.843] - globals: [0] <none>
[11:00:00.843] getGlobalsAndPackages() ... DONE
[11:00:00.844]    + additional globals found: [n=0] 
[11:00:00.844]    + additional namespaces needed: [n=0] 
[11:00:00.844]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:00.844]  - seeds: <none>
[11:00:00.844]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.844] getGlobalsAndPackages() ...
[11:00:00.844] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.844] Resolving globals: FALSE
[11:00:00.844] Tweak future expression to call with '...' arguments ...
[11:00:00.844] {
[11:00:00.844]     do.call(function(...) {
[11:00:00.844]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.844]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.844]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.844]             on.exit(options(oopts), add = TRUE)
[11:00:00.844]         }
[11:00:00.844]         {
[11:00:00.844]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.844]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.844]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.844]             })
[11:00:00.844]         }
[11:00:00.844]     }, args = future.call.arguments)
[11:00:00.844] }
[11:00:00.845] Tweak future expression to call with '...' arguments ... DONE
[11:00:00.845] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.845] - packages: [1] ‘future.apply’
[11:00:00.845] getGlobalsAndPackages() ... DONE
[11:00:00.846] run() for ‘Future’ ...
[11:00:00.846] - state: ‘created’
[11:00:00.846] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:00.846] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.846] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:00.846]   - Field: ‘label’
[11:00:00.846]   - Field: ‘local’
[11:00:00.846]   - Field: ‘owner’
[11:00:00.847]   - Field: ‘envir’
[11:00:00.847]   - Field: ‘packages’
[11:00:00.847]   - Field: ‘gc’
[11:00:00.847]   - Field: ‘conditions’
[11:00:00.847]   - Field: ‘expr’
[11:00:00.847]   - Field: ‘uuid’
[11:00:00.847]   - Field: ‘seed’
[11:00:00.847]   - Field: ‘version’
[11:00:00.847]   - Field: ‘result’
[11:00:00.847]   - Field: ‘asynchronous’
[11:00:00.847]   - Field: ‘calls’
[11:00:00.848]   - Field: ‘globals’
[11:00:00.848]   - Field: ‘stdout’
[11:00:00.848]   - Field: ‘earlySignal’
[11:00:00.848]   - Field: ‘lazy’
[11:00:00.848]   - Field: ‘state’
[11:00:00.848] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:00.848] - Launch lazy future ...
[11:00:00.848] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:00.848] Packages needed by future strategies (n = 0): <none>
[11:00:00.849] {
[11:00:00.849]     {
[11:00:00.849]         {
[11:00:00.849]             ...future.startTime <- base::Sys.time()
[11:00:00.849]             {
[11:00:00.849]                 {
[11:00:00.849]                   {
[11:00:00.849]                     {
[11:00:00.849]                       base::local({
[11:00:00.849]                         has_future <- base::requireNamespace("future", 
[11:00:00.849]                           quietly = TRUE)
[11:00:00.849]                         if (has_future) {
[11:00:00.849]                           ns <- base::getNamespace("future")
[11:00:00.849]                           version <- ns[[".package"]][["version"]]
[11:00:00.849]                           if (is.null(version)) 
[11:00:00.849]                             version <- utils::packageVersion("future")
[11:00:00.849]                         }
[11:00:00.849]                         else {
[11:00:00.849]                           version <- NULL
[11:00:00.849]                         }
[11:00:00.849]                         if (!has_future || version < "1.8.0") {
[11:00:00.849]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:00.849]                             "", base::R.version$version.string), 
[11:00:00.849]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:00.849]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:00.849]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:00.849]                               "release", "version")], collapse = " "), 
[11:00:00.849]                             hostname = base::Sys.info()[["nodename"]])
[11:00:00.849]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:00.849]                             info)
[11:00:00.849]                           info <- base::paste(info, collapse = "; ")
[11:00:00.849]                           if (!has_future) {
[11:00:00.849]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:00.849]                               info)
[11:00:00.849]                           }
[11:00:00.849]                           else {
[11:00:00.849]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:00.849]                               info, version)
[11:00:00.849]                           }
[11:00:00.849]                           base::stop(msg)
[11:00:00.849]                         }
[11:00:00.849]                       })
[11:00:00.849]                     }
[11:00:00.849]                     base::local({
[11:00:00.849]                       for (pkg in "future.apply") {
[11:00:00.849]                         base::loadNamespace(pkg)
[11:00:00.849]                         base::library(pkg, character.only = TRUE)
[11:00:00.849]                       }
[11:00:00.849]                     })
[11:00:00.849]                   }
[11:00:00.849]                   ...future.strategy.old <- future::plan("list")
[11:00:00.849]                   options(future.plan = NULL)
[11:00:00.849]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.849]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:00.849]                 }
[11:00:00.849]                 ...future.workdir <- getwd()
[11:00:00.849]             }
[11:00:00.849]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:00.849]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:00.849]         }
[11:00:00.849]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:00.849]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:00.849]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:00.849]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:00.849]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:00.849]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:00.849]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:00.849]             base::names(...future.oldOptions))
[11:00:00.849]     }
[11:00:00.849]     if (FALSE) {
[11:00:00.849]     }
[11:00:00.849]     else {
[11:00:00.849]         if (TRUE) {
[11:00:00.849]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:00.849]                 open = "w")
[11:00:00.849]         }
[11:00:00.849]         else {
[11:00:00.849]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:00.849]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:00.849]         }
[11:00:00.849]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:00.849]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:00.849]             base::sink(type = "output", split = FALSE)
[11:00:00.849]             base::close(...future.stdout)
[11:00:00.849]         }, add = TRUE)
[11:00:00.849]     }
[11:00:00.849]     ...future.frame <- base::sys.nframe()
[11:00:00.849]     ...future.conditions <- base::list()
[11:00:00.849]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:00.849]     if (FALSE) {
[11:00:00.849]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:00.849]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:00.849]     }
[11:00:00.849]     ...future.result <- base::tryCatch({
[11:00:00.849]         base::withCallingHandlers({
[11:00:00.849]             ...future.value <- base::withVisible(base::local({
[11:00:00.849]                 do.call(function(...) {
[11:00:00.849]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.849]                   if (!identical(...future.globals.maxSize.org, 
[11:00:00.849]                     ...future.globals.maxSize)) {
[11:00:00.849]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.849]                     on.exit(options(oopts), add = TRUE)
[11:00:00.849]                   }
[11:00:00.849]                   {
[11:00:00.849]                     lapply(seq_along(...future.elements_ii), 
[11:00:00.849]                       FUN = function(jj) {
[11:00:00.849]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.849]                         ...future.FUN(...future.X_jj, ...)
[11:00:00.849]                       })
[11:00:00.849]                   }
[11:00:00.849]                 }, args = future.call.arguments)
[11:00:00.849]             }))
[11:00:00.849]             future::FutureResult(value = ...future.value$value, 
[11:00:00.849]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.849]                   ...future.rng), globalenv = if (FALSE) 
[11:00:00.849]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:00.849]                     ...future.globalenv.names))
[11:00:00.849]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:00.849]         }, condition = base::local({
[11:00:00.849]             c <- base::c
[11:00:00.849]             inherits <- base::inherits
[11:00:00.849]             invokeRestart <- base::invokeRestart
[11:00:00.849]             length <- base::length
[11:00:00.849]             list <- base::list
[11:00:00.849]             seq.int <- base::seq.int
[11:00:00.849]             signalCondition <- base::signalCondition
[11:00:00.849]             sys.calls <- base::sys.calls
[11:00:00.849]             `[[` <- base::`[[`
[11:00:00.849]             `+` <- base::`+`
[11:00:00.849]             `<<-` <- base::`<<-`
[11:00:00.849]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:00.849]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:00.849]                   3L)]
[11:00:00.849]             }
[11:00:00.849]             function(cond) {
[11:00:00.849]                 is_error <- inherits(cond, "error")
[11:00:00.849]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:00.849]                   NULL)
[11:00:00.849]                 if (is_error) {
[11:00:00.849]                   sessionInformation <- function() {
[11:00:00.849]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:00.849]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:00.849]                       search = base::search(), system = base::Sys.info())
[11:00:00.849]                   }
[11:00:00.849]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.849]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:00.849]                     cond$call), session = sessionInformation(), 
[11:00:00.849]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:00.849]                   signalCondition(cond)
[11:00:00.849]                 }
[11:00:00.849]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:00.849]                 "immediateCondition"))) {
[11:00:00.849]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:00.849]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.849]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:00.849]                   if (TRUE && !signal) {
[11:00:00.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.849]                     {
[11:00:00.849]                       inherits <- base::inherits
[11:00:00.849]                       invokeRestart <- base::invokeRestart
[11:00:00.849]                       is.null <- base::is.null
[11:00:00.849]                       muffled <- FALSE
[11:00:00.849]                       if (inherits(cond, "message")) {
[11:00:00.849]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.849]                         if (muffled) 
[11:00:00.849]                           invokeRestart("muffleMessage")
[11:00:00.849]                       }
[11:00:00.849]                       else if (inherits(cond, "warning")) {
[11:00:00.849]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.849]                         if (muffled) 
[11:00:00.849]                           invokeRestart("muffleWarning")
[11:00:00.849]                       }
[11:00:00.849]                       else if (inherits(cond, "condition")) {
[11:00:00.849]                         if (!is.null(pattern)) {
[11:00:00.849]                           computeRestarts <- base::computeRestarts
[11:00:00.849]                           grepl <- base::grepl
[11:00:00.849]                           restarts <- computeRestarts(cond)
[11:00:00.849]                           for (restart in restarts) {
[11:00:00.849]                             name <- restart$name
[11:00:00.849]                             if (is.null(name)) 
[11:00:00.849]                               next
[11:00:00.849]                             if (!grepl(pattern, name)) 
[11:00:00.849]                               next
[11:00:00.849]                             invokeRestart(restart)
[11:00:00.849]                             muffled <- TRUE
[11:00:00.849]                             break
[11:00:00.849]                           }
[11:00:00.849]                         }
[11:00:00.849]                       }
[11:00:00.849]                       invisible(muffled)
[11:00:00.849]                     }
[11:00:00.849]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.849]                   }
[11:00:00.849]                 }
[11:00:00.849]                 else {
[11:00:00.849]                   if (TRUE) {
[11:00:00.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.849]                     {
[11:00:00.849]                       inherits <- base::inherits
[11:00:00.849]                       invokeRestart <- base::invokeRestart
[11:00:00.849]                       is.null <- base::is.null
[11:00:00.849]                       muffled <- FALSE
[11:00:00.849]                       if (inherits(cond, "message")) {
[11:00:00.849]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.849]                         if (muffled) 
[11:00:00.849]                           invokeRestart("muffleMessage")
[11:00:00.849]                       }
[11:00:00.849]                       else if (inherits(cond, "warning")) {
[11:00:00.849]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.849]                         if (muffled) 
[11:00:00.849]                           invokeRestart("muffleWarning")
[11:00:00.849]                       }
[11:00:00.849]                       else if (inherits(cond, "condition")) {
[11:00:00.849]                         if (!is.null(pattern)) {
[11:00:00.849]                           computeRestarts <- base::computeRestarts
[11:00:00.849]                           grepl <- base::grepl
[11:00:00.849]                           restarts <- computeRestarts(cond)
[11:00:00.849]                           for (restart in restarts) {
[11:00:00.849]                             name <- restart$name
[11:00:00.849]                             if (is.null(name)) 
[11:00:00.849]                               next
[11:00:00.849]                             if (!grepl(pattern, name)) 
[11:00:00.849]                               next
[11:00:00.849]                             invokeRestart(restart)
[11:00:00.849]                             muffled <- TRUE
[11:00:00.849]                             break
[11:00:00.849]                           }
[11:00:00.849]                         }
[11:00:00.849]                       }
[11:00:00.849]                       invisible(muffled)
[11:00:00.849]                     }
[11:00:00.849]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.849]                   }
[11:00:00.849]                 }
[11:00:00.849]             }
[11:00:00.849]         }))
[11:00:00.849]     }, error = function(ex) {
[11:00:00.849]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:00.849]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.849]                 ...future.rng), started = ...future.startTime, 
[11:00:00.849]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:00.849]             version = "1.8"), class = "FutureResult")
[11:00:00.849]     }, finally = {
[11:00:00.849]         if (!identical(...future.workdir, getwd())) 
[11:00:00.849]             setwd(...future.workdir)
[11:00:00.849]         {
[11:00:00.849]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:00.849]                 ...future.oldOptions$nwarnings <- NULL
[11:00:00.849]             }
[11:00:00.849]             base::options(...future.oldOptions)
[11:00:00.849]             if (.Platform$OS.type == "windows") {
[11:00:00.849]                 old_names <- names(...future.oldEnvVars)
[11:00:00.849]                 envs <- base::Sys.getenv()
[11:00:00.849]                 names <- names(envs)
[11:00:00.849]                 common <- intersect(names, old_names)
[11:00:00.849]                 added <- setdiff(names, old_names)
[11:00:00.849]                 removed <- setdiff(old_names, names)
[11:00:00.849]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:00.849]                   envs[common]]
[11:00:00.849]                 NAMES <- toupper(changed)
[11:00:00.849]                 args <- list()
[11:00:00.849]                 for (kk in seq_along(NAMES)) {
[11:00:00.849]                   name <- changed[[kk]]
[11:00:00.849]                   NAME <- NAMES[[kk]]
[11:00:00.849]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.849]                     next
[11:00:00.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.849]                 }
[11:00:00.849]                 NAMES <- toupper(added)
[11:00:00.849]                 for (kk in seq_along(NAMES)) {
[11:00:00.849]                   name <- added[[kk]]
[11:00:00.849]                   NAME <- NAMES[[kk]]
[11:00:00.849]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.849]                     next
[11:00:00.849]                   args[[name]] <- ""
[11:00:00.849]                 }
[11:00:00.849]                 NAMES <- toupper(removed)
[11:00:00.849]                 for (kk in seq_along(NAMES)) {
[11:00:00.849]                   name <- removed[[kk]]
[11:00:00.849]                   NAME <- NAMES[[kk]]
[11:00:00.849]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.849]                     next
[11:00:00.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.849]                 }
[11:00:00.849]                 if (length(args) > 0) 
[11:00:00.849]                   base::do.call(base::Sys.setenv, args = args)
[11:00:00.849]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:00.849]             }
[11:00:00.849]             else {
[11:00:00.849]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:00.849]             }
[11:00:00.849]             {
[11:00:00.849]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:00.849]                   0L) {
[11:00:00.849]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:00.849]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:00.849]                   base::options(opts)
[11:00:00.849]                 }
[11:00:00.849]                 {
[11:00:00.849]                   {
[11:00:00.849]                     NULL
[11:00:00.849]                     RNGkind("Mersenne-Twister")
[11:00:00.849]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:00.849]                       inherits = FALSE)
[11:00:00.849]                   }
[11:00:00.849]                   options(future.plan = NULL)
[11:00:00.849]                   if (is.na(NA_character_)) 
[11:00:00.849]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.849]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:00.849]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:00.849]                     .init = FALSE)
[11:00:00.849]                 }
[11:00:00.849]             }
[11:00:00.849]         }
[11:00:00.849]     })
[11:00:00.849]     if (TRUE) {
[11:00:00.849]         base::sink(type = "output", split = FALSE)
[11:00:00.849]         if (TRUE) {
[11:00:00.849]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:00.849]         }
[11:00:00.849]         else {
[11:00:00.849]             ...future.result["stdout"] <- base::list(NULL)
[11:00:00.849]         }
[11:00:00.849]         base::close(...future.stdout)
[11:00:00.849]         ...future.stdout <- NULL
[11:00:00.849]     }
[11:00:00.849]     ...future.result$conditions <- ...future.conditions
[11:00:00.849]     ...future.result$finished <- base::Sys.time()
[11:00:00.849]     ...future.result
[11:00:00.849] }
[11:00:00.851] assign_globals() ...
[11:00:00.852] List of 11
[11:00:00.852]  $ ...future.FUN            :function (x, ...)  
[11:00:00.852]  $ x_FUN                    :function (x)  
[11:00:00.852]  $ times                    : int 1
[11:00:00.852]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.852]  $ stop_if_not              :function (...)  
[11:00:00.852]  $ dim                      : NULL
[11:00:00.852]  $ valid_types              : chr "logical"
[11:00:00.852]  $ future.call.arguments    : list()
[11:00:00.852]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.852]  $ ...future.elements_ii    :List of 11
[11:00:00.852]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[11:00:00.852]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[11:00:00.852]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[11:00:00.852]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[11:00:00.852]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[11:00:00.852]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[11:00:00.852]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[11:00:00.852]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[11:00:00.852]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[11:00:00.852]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[11:00:00.852]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[11:00:00.852]  $ ...future.seeds_ii       : NULL
[11:00:00.852]  $ ...future.globals.maxSize: NULL
[11:00:00.852]  - attr(*, "where")=List of 11
[11:00:00.852]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:00.852]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:00.852]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:00.852]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:00.852]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:00.852]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:00.852]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:00.852]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:00.852]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:00.852]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:00.852]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:00.852]  - attr(*, "resolved")= logi FALSE
[11:00:00.852]  - attr(*, "total_size")= num 30734
[11:00:00.852]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.852]  - attr(*, "already-done")= logi TRUE
[11:00:00.862] - copied ‘...future.FUN’ to environment
[11:00:00.862] - copied ‘x_FUN’ to environment
[11:00:00.862] - copied ‘times’ to environment
[11:00:00.862] - copied ‘stopf’ to environment
[11:00:00.863] - copied ‘stop_if_not’ to environment
[11:00:00.863] - copied ‘dim’ to environment
[11:00:00.863] - copied ‘valid_types’ to environment
[11:00:00.863] - copied ‘future.call.arguments’ to environment
[11:00:00.863] - copied ‘...future.elements_ii’ to environment
[11:00:00.863] - copied ‘...future.seeds_ii’ to environment
[11:00:00.863] - copied ‘...future.globals.maxSize’ to environment
[11:00:00.863] assign_globals() ... done
[11:00:00.863] plan(): Setting new future strategy stack:
[11:00:00.864] List of future strategies:
[11:00:00.864] 1. sequential:
[11:00:00.864]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.864]    - tweaked: FALSE
[11:00:00.864]    - call: NULL
[11:00:00.864] plan(): nbrOfWorkers() = 1
[11:00:00.865] plan(): Setting new future strategy stack:
[11:00:00.865] List of future strategies:
[11:00:00.865] 1. sequential:
[11:00:00.865]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.865]    - tweaked: FALSE
[11:00:00.865]    - call: plan(strategy)
[11:00:00.865] plan(): nbrOfWorkers() = 1
[11:00:00.865] SequentialFuture started (and completed)
[11:00:00.866] - Launch lazy future ... done
[11:00:00.866] run() for ‘SequentialFuture’ ... done
[11:00:00.866] Created future:
[11:00:00.866] SequentialFuture:
[11:00:00.866] Label: ‘future_vapply-1’
[11:00:00.866] Expression:
[11:00:00.866] {
[11:00:00.866]     do.call(function(...) {
[11:00:00.866]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.866]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.866]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.866]             on.exit(options(oopts), add = TRUE)
[11:00:00.866]         }
[11:00:00.866]         {
[11:00:00.866]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.866]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.866]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.866]             })
[11:00:00.866]         }
[11:00:00.866]     }, args = future.call.arguments)
[11:00:00.866] }
[11:00:00.866] Lazy evaluation: FALSE
[11:00:00.866] Asynchronous evaluation: FALSE
[11:00:00.866] Local evaluation: TRUE
[11:00:00.866] Environment: R_GlobalEnv
[11:00:00.866] Capture standard output: TRUE
[11:00:00.866] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:00.866] Globals: 11 objects totaling 17.89 KiB (function ‘...future.FUN’ of 6.73 KiB, function ‘x_FUN’ of 41 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:00.866] Packages: 1 packages (‘future.apply’)
[11:00:00.866] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:00.866] Resolved: TRUE
[11:00:00.866] Value: 163 bytes of class ‘list’
[11:00:00.866] Early signaling: FALSE
[11:00:00.866] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:00.866] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.867] Chunk #1 of 1 ... DONE
[11:00:00.867] Launching 1 futures (chunks) ... DONE
[11:00:00.867] Resolving 1 futures (chunks) ...
[11:00:00.867] resolve() on list ...
[11:00:00.867]  recursive: 0
[11:00:00.867]  length: 1
[11:00:00.867] 
[11:00:00.867] resolved() for ‘SequentialFuture’ ...
[11:00:00.867] - state: ‘finished’
[11:00:00.867] - run: TRUE
[11:00:00.867] - result: ‘FutureResult’
[11:00:00.868] resolved() for ‘SequentialFuture’ ... done
[11:00:00.868] Future #1
[11:00:00.868] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:00.868] - nx: 1
[11:00:00.868] - relay: TRUE
[11:00:00.868] - stdout: TRUE
[11:00:00.868] - signal: TRUE
[11:00:00.868] - resignal: FALSE
[11:00:00.868] - force: TRUE
[11:00:00.868] - relayed: [n=1] FALSE
[11:00:00.868] - queued futures: [n=1] FALSE
[11:00:00.868]  - until=1
[11:00:00.869]  - relaying element #1
[11:00:00.869] - relayed: [n=1] TRUE
[11:00:00.869] - queued futures: [n=1] TRUE
[11:00:00.869] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:00.869]  length: 0 (resolved future 1)
[11:00:00.869] Relaying remaining futures
[11:00:00.869] signalConditionsASAP(NULL, pos=0) ...
[11:00:00.869] - nx: 1
[11:00:00.869] - relay: TRUE
[11:00:00.869] - stdout: TRUE
[11:00:00.869] - signal: TRUE
[11:00:00.869] - resignal: FALSE
[11:00:00.870] - force: TRUE
[11:00:00.870] - relayed: [n=1] TRUE
[11:00:00.870] - queued futures: [n=1] TRUE
 - flush all
[11:00:00.870] - relayed: [n=1] TRUE
[11:00:00.870] - queued futures: [n=1] TRUE
[11:00:00.870] signalConditionsASAP(NULL, pos=0) ... done
[11:00:00.870] resolve() on list ... DONE
[11:00:00.870]  - Number of value chunks collected: 1
[11:00:00.870] Resolving 1 futures (chunks) ... DONE
[11:00:00.870] Reducing values from 1 chunks ...
[11:00:00.870]  - Number of values collected after concatenation: 11
[11:00:00.871]  - Number of values expected: 11
[11:00:00.871] Reducing values from 1 chunks ... DONE
[11:00:00.871] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[11:00:00.872] future_lapply() ...
[11:00:00.874] Number of chunks: 1
[11:00:00.874] getGlobalsAndPackagesXApply() ...
[11:00:00.874]  - future.globals: TRUE
[11:00:00.874] getGlobalsAndPackages() ...
[11:00:00.874] Searching for globals...
[11:00:00.877] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[11:00:00.877] Searching for globals ... DONE
[11:00:00.877] Resolving globals: FALSE
[11:00:00.878] The total size of the 7 globals is 11.92 KiB (12201 bytes)
[11:00:00.878] The total size of the 7 globals exported for future expression (‘FUN()’) is 11.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (3.92 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:00.878] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.878] - packages: [1] ‘future.apply’
[11:00:00.878] getGlobalsAndPackages() ... DONE
[11:00:00.879]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.879]  - needed namespaces: [n=1] ‘future.apply’
[11:00:00.879] Finding globals ... DONE
[11:00:00.879]  - use_args: TRUE
[11:00:00.879]  - Getting '...' globals ...
[11:00:00.879] resolve() on list ...
[11:00:00.879]  recursive: 0
[11:00:00.879]  length: 1
[11:00:00.879]  elements: ‘...’
[11:00:00.879]  length: 0 (resolved future 1)
[11:00:00.880] resolve() on list ... DONE
[11:00:00.880]    - '...' content: [n=0] 
[11:00:00.880] List of 1
[11:00:00.880]  $ ...: list()
[11:00:00.880]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.880]  - attr(*, "where")=List of 1
[11:00:00.880]   ..$ ...:<environment: 0x55bbadceb260> 
[11:00:00.880]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.880]  - attr(*, "resolved")= logi TRUE
[11:00:00.880]  - attr(*, "total_size")= num NA
[11:00:00.882]  - Getting '...' globals ... DONE
[11:00:00.882] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:00.882] List of 8
[11:00:00.882]  $ ...future.FUN:function (x, ...)  
[11:00:00.882]  $ x_FUN        :function (x)  
[11:00:00.882]  $ times        : int 1
[11:00:00.882]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.882]  $ stop_if_not  :function (...)  
[11:00:00.882]  $ dim          : NULL
[11:00:00.882]  $ valid_types  : chr [1:2] "logical" "integer"
[11:00:00.882]  $ ...          : list()
[11:00:00.882]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.882]  - attr(*, "where")=List of 8
[11:00:00.882]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:00.882]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:00.882]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:00.882]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:00.882]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:00.882]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:00.882]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:00.882]   ..$ ...          :<environment: 0x55bbadceb260> 
[11:00:00.882]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.882]  - attr(*, "resolved")= logi FALSE
[11:00:00.882]  - attr(*, "total_size")= num 22016
[11:00:00.887] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:00.887] getGlobalsAndPackagesXApply() ... DONE
[11:00:00.887] Number of futures (= number of chunks): 1
[11:00:00.887] Launching 1 futures (chunks) ...
[11:00:00.887] Chunk #1 of 1 ...
[11:00:00.887]  - Finding globals in 'X' for chunk #1 ...
[11:00:00.888] getGlobalsAndPackages() ...
[11:00:00.888] Searching for globals...
[11:00:00.888] 
[11:00:00.888] Searching for globals ... DONE
[11:00:00.888] - globals: [0] <none>
[11:00:00.888] getGlobalsAndPackages() ... DONE
[11:00:00.888]    + additional globals found: [n=0] 
[11:00:00.888]    + additional namespaces needed: [n=0] 
[11:00:00.888]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:00.888]  - seeds: <none>
[11:00:00.888]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.889] getGlobalsAndPackages() ...
[11:00:00.889] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.889] Resolving globals: FALSE
[11:00:00.889] Tweak future expression to call with '...' arguments ...
[11:00:00.889] {
[11:00:00.889]     do.call(function(...) {
[11:00:00.889]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.889]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.889]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.889]             on.exit(options(oopts), add = TRUE)
[11:00:00.889]         }
[11:00:00.889]         {
[11:00:00.889]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.889]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.889]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.889]             })
[11:00:00.889]         }
[11:00:00.889]     }, args = future.call.arguments)
[11:00:00.889] }
[11:00:00.889] Tweak future expression to call with '...' arguments ... DONE
[11:00:00.890] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.890] - packages: [1] ‘future.apply’
[11:00:00.891] getGlobalsAndPackages() ... DONE
[11:00:00.891] run() for ‘Future’ ...
[11:00:00.891] - state: ‘created’
[11:00:00.891] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:00.891] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.891] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:00.891]   - Field: ‘label’
[11:00:00.892]   - Field: ‘local’
[11:00:00.892]   - Field: ‘owner’
[11:00:00.892]   - Field: ‘envir’
[11:00:00.892]   - Field: ‘packages’
[11:00:00.892]   - Field: ‘gc’
[11:00:00.892]   - Field: ‘conditions’
[11:00:00.892]   - Field: ‘expr’
[11:00:00.892]   - Field: ‘uuid’
[11:00:00.892]   - Field: ‘seed’
[11:00:00.892]   - Field: ‘version’
[11:00:00.892]   - Field: ‘result’
[11:00:00.892]   - Field: ‘asynchronous’
[11:00:00.893]   - Field: ‘calls’
[11:00:00.893]   - Field: ‘globals’
[11:00:00.893]   - Field: ‘stdout’
[11:00:00.893]   - Field: ‘earlySignal’
[11:00:00.893]   - Field: ‘lazy’
[11:00:00.893]   - Field: ‘state’
[11:00:00.893] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:00.893] - Launch lazy future ...
[11:00:00.893] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:00.893] Packages needed by future strategies (n = 0): <none>
[11:00:00.894] {
[11:00:00.894]     {
[11:00:00.894]         {
[11:00:00.894]             ...future.startTime <- base::Sys.time()
[11:00:00.894]             {
[11:00:00.894]                 {
[11:00:00.894]                   {
[11:00:00.894]                     {
[11:00:00.894]                       base::local({
[11:00:00.894]                         has_future <- base::requireNamespace("future", 
[11:00:00.894]                           quietly = TRUE)
[11:00:00.894]                         if (has_future) {
[11:00:00.894]                           ns <- base::getNamespace("future")
[11:00:00.894]                           version <- ns[[".package"]][["version"]]
[11:00:00.894]                           if (is.null(version)) 
[11:00:00.894]                             version <- utils::packageVersion("future")
[11:00:00.894]                         }
[11:00:00.894]                         else {
[11:00:00.894]                           version <- NULL
[11:00:00.894]                         }
[11:00:00.894]                         if (!has_future || version < "1.8.0") {
[11:00:00.894]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:00.894]                             "", base::R.version$version.string), 
[11:00:00.894]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:00.894]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:00.894]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:00.894]                               "release", "version")], collapse = " "), 
[11:00:00.894]                             hostname = base::Sys.info()[["nodename"]])
[11:00:00.894]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:00.894]                             info)
[11:00:00.894]                           info <- base::paste(info, collapse = "; ")
[11:00:00.894]                           if (!has_future) {
[11:00:00.894]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:00.894]                               info)
[11:00:00.894]                           }
[11:00:00.894]                           else {
[11:00:00.894]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:00.894]                               info, version)
[11:00:00.894]                           }
[11:00:00.894]                           base::stop(msg)
[11:00:00.894]                         }
[11:00:00.894]                       })
[11:00:00.894]                     }
[11:00:00.894]                     base::local({
[11:00:00.894]                       for (pkg in "future.apply") {
[11:00:00.894]                         base::loadNamespace(pkg)
[11:00:00.894]                         base::library(pkg, character.only = TRUE)
[11:00:00.894]                       }
[11:00:00.894]                     })
[11:00:00.894]                   }
[11:00:00.894]                   ...future.strategy.old <- future::plan("list")
[11:00:00.894]                   options(future.plan = NULL)
[11:00:00.894]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.894]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:00.894]                 }
[11:00:00.894]                 ...future.workdir <- getwd()
[11:00:00.894]             }
[11:00:00.894]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:00.894]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:00.894]         }
[11:00:00.894]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:00.894]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:00.894]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:00.894]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:00.894]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:00.894]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:00.894]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:00.894]             base::names(...future.oldOptions))
[11:00:00.894]     }
[11:00:00.894]     if (FALSE) {
[11:00:00.894]     }
[11:00:00.894]     else {
[11:00:00.894]         if (TRUE) {
[11:00:00.894]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:00.894]                 open = "w")
[11:00:00.894]         }
[11:00:00.894]         else {
[11:00:00.894]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:00.894]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:00.894]         }
[11:00:00.894]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:00.894]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:00.894]             base::sink(type = "output", split = FALSE)
[11:00:00.894]             base::close(...future.stdout)
[11:00:00.894]         }, add = TRUE)
[11:00:00.894]     }
[11:00:00.894]     ...future.frame <- base::sys.nframe()
[11:00:00.894]     ...future.conditions <- base::list()
[11:00:00.894]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:00.894]     if (FALSE) {
[11:00:00.894]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:00.894]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:00.894]     }
[11:00:00.894]     ...future.result <- base::tryCatch({
[11:00:00.894]         base::withCallingHandlers({
[11:00:00.894]             ...future.value <- base::withVisible(base::local({
[11:00:00.894]                 do.call(function(...) {
[11:00:00.894]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.894]                   if (!identical(...future.globals.maxSize.org, 
[11:00:00.894]                     ...future.globals.maxSize)) {
[11:00:00.894]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.894]                     on.exit(options(oopts), add = TRUE)
[11:00:00.894]                   }
[11:00:00.894]                   {
[11:00:00.894]                     lapply(seq_along(...future.elements_ii), 
[11:00:00.894]                       FUN = function(jj) {
[11:00:00.894]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.894]                         ...future.FUN(...future.X_jj, ...)
[11:00:00.894]                       })
[11:00:00.894]                   }
[11:00:00.894]                 }, args = future.call.arguments)
[11:00:00.894]             }))
[11:00:00.894]             future::FutureResult(value = ...future.value$value, 
[11:00:00.894]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.894]                   ...future.rng), globalenv = if (FALSE) 
[11:00:00.894]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:00.894]                     ...future.globalenv.names))
[11:00:00.894]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:00.894]         }, condition = base::local({
[11:00:00.894]             c <- base::c
[11:00:00.894]             inherits <- base::inherits
[11:00:00.894]             invokeRestart <- base::invokeRestart
[11:00:00.894]             length <- base::length
[11:00:00.894]             list <- base::list
[11:00:00.894]             seq.int <- base::seq.int
[11:00:00.894]             signalCondition <- base::signalCondition
[11:00:00.894]             sys.calls <- base::sys.calls
[11:00:00.894]             `[[` <- base::`[[`
[11:00:00.894]             `+` <- base::`+`
[11:00:00.894]             `<<-` <- base::`<<-`
[11:00:00.894]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:00.894]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:00.894]                   3L)]
[11:00:00.894]             }
[11:00:00.894]             function(cond) {
[11:00:00.894]                 is_error <- inherits(cond, "error")
[11:00:00.894]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:00.894]                   NULL)
[11:00:00.894]                 if (is_error) {
[11:00:00.894]                   sessionInformation <- function() {
[11:00:00.894]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:00.894]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:00.894]                       search = base::search(), system = base::Sys.info())
[11:00:00.894]                   }
[11:00:00.894]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.894]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:00.894]                     cond$call), session = sessionInformation(), 
[11:00:00.894]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:00.894]                   signalCondition(cond)
[11:00:00.894]                 }
[11:00:00.894]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:00.894]                 "immediateCondition"))) {
[11:00:00.894]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:00.894]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.894]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:00.894]                   if (TRUE && !signal) {
[11:00:00.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.894]                     {
[11:00:00.894]                       inherits <- base::inherits
[11:00:00.894]                       invokeRestart <- base::invokeRestart
[11:00:00.894]                       is.null <- base::is.null
[11:00:00.894]                       muffled <- FALSE
[11:00:00.894]                       if (inherits(cond, "message")) {
[11:00:00.894]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.894]                         if (muffled) 
[11:00:00.894]                           invokeRestart("muffleMessage")
[11:00:00.894]                       }
[11:00:00.894]                       else if (inherits(cond, "warning")) {
[11:00:00.894]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.894]                         if (muffled) 
[11:00:00.894]                           invokeRestart("muffleWarning")
[11:00:00.894]                       }
[11:00:00.894]                       else if (inherits(cond, "condition")) {
[11:00:00.894]                         if (!is.null(pattern)) {
[11:00:00.894]                           computeRestarts <- base::computeRestarts
[11:00:00.894]                           grepl <- base::grepl
[11:00:00.894]                           restarts <- computeRestarts(cond)
[11:00:00.894]                           for (restart in restarts) {
[11:00:00.894]                             name <- restart$name
[11:00:00.894]                             if (is.null(name)) 
[11:00:00.894]                               next
[11:00:00.894]                             if (!grepl(pattern, name)) 
[11:00:00.894]                               next
[11:00:00.894]                             invokeRestart(restart)
[11:00:00.894]                             muffled <- TRUE
[11:00:00.894]                             break
[11:00:00.894]                           }
[11:00:00.894]                         }
[11:00:00.894]                       }
[11:00:00.894]                       invisible(muffled)
[11:00:00.894]                     }
[11:00:00.894]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.894]                   }
[11:00:00.894]                 }
[11:00:00.894]                 else {
[11:00:00.894]                   if (TRUE) {
[11:00:00.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.894]                     {
[11:00:00.894]                       inherits <- base::inherits
[11:00:00.894]                       invokeRestart <- base::invokeRestart
[11:00:00.894]                       is.null <- base::is.null
[11:00:00.894]                       muffled <- FALSE
[11:00:00.894]                       if (inherits(cond, "message")) {
[11:00:00.894]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.894]                         if (muffled) 
[11:00:00.894]                           invokeRestart("muffleMessage")
[11:00:00.894]                       }
[11:00:00.894]                       else if (inherits(cond, "warning")) {
[11:00:00.894]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.894]                         if (muffled) 
[11:00:00.894]                           invokeRestart("muffleWarning")
[11:00:00.894]                       }
[11:00:00.894]                       else if (inherits(cond, "condition")) {
[11:00:00.894]                         if (!is.null(pattern)) {
[11:00:00.894]                           computeRestarts <- base::computeRestarts
[11:00:00.894]                           grepl <- base::grepl
[11:00:00.894]                           restarts <- computeRestarts(cond)
[11:00:00.894]                           for (restart in restarts) {
[11:00:00.894]                             name <- restart$name
[11:00:00.894]                             if (is.null(name)) 
[11:00:00.894]                               next
[11:00:00.894]                             if (!grepl(pattern, name)) 
[11:00:00.894]                               next
[11:00:00.894]                             invokeRestart(restart)
[11:00:00.894]                             muffled <- TRUE
[11:00:00.894]                             break
[11:00:00.894]                           }
[11:00:00.894]                         }
[11:00:00.894]                       }
[11:00:00.894]                       invisible(muffled)
[11:00:00.894]                     }
[11:00:00.894]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.894]                   }
[11:00:00.894]                 }
[11:00:00.894]             }
[11:00:00.894]         }))
[11:00:00.894]     }, error = function(ex) {
[11:00:00.894]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:00.894]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.894]                 ...future.rng), started = ...future.startTime, 
[11:00:00.894]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:00.894]             version = "1.8"), class = "FutureResult")
[11:00:00.894]     }, finally = {
[11:00:00.894]         if (!identical(...future.workdir, getwd())) 
[11:00:00.894]             setwd(...future.workdir)
[11:00:00.894]         {
[11:00:00.894]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:00.894]                 ...future.oldOptions$nwarnings <- NULL
[11:00:00.894]             }
[11:00:00.894]             base::options(...future.oldOptions)
[11:00:00.894]             if (.Platform$OS.type == "windows") {
[11:00:00.894]                 old_names <- names(...future.oldEnvVars)
[11:00:00.894]                 envs <- base::Sys.getenv()
[11:00:00.894]                 names <- names(envs)
[11:00:00.894]                 common <- intersect(names, old_names)
[11:00:00.894]                 added <- setdiff(names, old_names)
[11:00:00.894]                 removed <- setdiff(old_names, names)
[11:00:00.894]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:00.894]                   envs[common]]
[11:00:00.894]                 NAMES <- toupper(changed)
[11:00:00.894]                 args <- list()
[11:00:00.894]                 for (kk in seq_along(NAMES)) {
[11:00:00.894]                   name <- changed[[kk]]
[11:00:00.894]                   NAME <- NAMES[[kk]]
[11:00:00.894]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.894]                     next
[11:00:00.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.894]                 }
[11:00:00.894]                 NAMES <- toupper(added)
[11:00:00.894]                 for (kk in seq_along(NAMES)) {
[11:00:00.894]                   name <- added[[kk]]
[11:00:00.894]                   NAME <- NAMES[[kk]]
[11:00:00.894]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.894]                     next
[11:00:00.894]                   args[[name]] <- ""
[11:00:00.894]                 }
[11:00:00.894]                 NAMES <- toupper(removed)
[11:00:00.894]                 for (kk in seq_along(NAMES)) {
[11:00:00.894]                   name <- removed[[kk]]
[11:00:00.894]                   NAME <- NAMES[[kk]]
[11:00:00.894]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.894]                     next
[11:00:00.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.894]                 }
[11:00:00.894]                 if (length(args) > 0) 
[11:00:00.894]                   base::do.call(base::Sys.setenv, args = args)
[11:00:00.894]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:00.894]             }
[11:00:00.894]             else {
[11:00:00.894]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:00.894]             }
[11:00:00.894]             {
[11:00:00.894]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:00.894]                   0L) {
[11:00:00.894]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:00.894]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:00.894]                   base::options(opts)
[11:00:00.894]                 }
[11:00:00.894]                 {
[11:00:00.894]                   {
[11:00:00.894]                     NULL
[11:00:00.894]                     RNGkind("Mersenne-Twister")
[11:00:00.894]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:00.894]                       inherits = FALSE)
[11:00:00.894]                   }
[11:00:00.894]                   options(future.plan = NULL)
[11:00:00.894]                   if (is.na(NA_character_)) 
[11:00:00.894]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.894]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:00.894]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:00.894]                     .init = FALSE)
[11:00:00.894]                 }
[11:00:00.894]             }
[11:00:00.894]         }
[11:00:00.894]     })
[11:00:00.894]     if (TRUE) {
[11:00:00.894]         base::sink(type = "output", split = FALSE)
[11:00:00.894]         if (TRUE) {
[11:00:00.894]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:00.894]         }
[11:00:00.894]         else {
[11:00:00.894]             ...future.result["stdout"] <- base::list(NULL)
[11:00:00.894]         }
[11:00:00.894]         base::close(...future.stdout)
[11:00:00.894]         ...future.stdout <- NULL
[11:00:00.894]     }
[11:00:00.894]     ...future.result$conditions <- ...future.conditions
[11:00:00.894]     ...future.result$finished <- base::Sys.time()
[11:00:00.894]     ...future.result
[11:00:00.894] }
[11:00:00.896] assign_globals() ...
[11:00:00.896] List of 11
[11:00:00.896]  $ ...future.FUN            :function (x, ...)  
[11:00:00.896]  $ x_FUN                    :function (x)  
[11:00:00.896]  $ times                    : int 1
[11:00:00.896]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.896]  $ stop_if_not              :function (...)  
[11:00:00.896]  $ dim                      : NULL
[11:00:00.896]  $ valid_types              : chr [1:2] "logical" "integer"
[11:00:00.896]  $ future.call.arguments    : list()
[11:00:00.896]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.896]  $ ...future.elements_ii    :List of 3
[11:00:00.896]   ..$ a: num 1
[11:00:00.896]   ..$ b: num 2
[11:00:00.896]   ..$ c: num 3
[11:00:00.896]  $ ...future.seeds_ii       : NULL
[11:00:00.896]  $ ...future.globals.maxSize: NULL
[11:00:00.896]  - attr(*, "where")=List of 11
[11:00:00.896]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:00.896]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:00.896]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:00.896]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:00.896]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:00.896]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:00.896]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:00.896]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:00.896]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:00.896]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:00.896]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:00.896]  - attr(*, "resolved")= logi FALSE
[11:00:00.896]  - attr(*, "total_size")= num 22016
[11:00:00.896]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.896]  - attr(*, "already-done")= logi TRUE
[11:00:00.903] - copied ‘...future.FUN’ to environment
[11:00:00.903] - copied ‘x_FUN’ to environment
[11:00:00.903] - copied ‘times’ to environment
[11:00:00.903] - copied ‘stopf’ to environment
[11:00:00.903] - copied ‘stop_if_not’ to environment
[11:00:00.903] - copied ‘dim’ to environment
[11:00:00.903] - copied ‘valid_types’ to environment
[11:00:00.903] - copied ‘future.call.arguments’ to environment
[11:00:00.903] - copied ‘...future.elements_ii’ to environment
[11:00:00.903] - copied ‘...future.seeds_ii’ to environment
[11:00:00.904] - copied ‘...future.globals.maxSize’ to environment
[11:00:00.904] assign_globals() ... done
[11:00:00.904] plan(): Setting new future strategy stack:
[11:00:00.904] List of future strategies:
[11:00:00.904] 1. sequential:
[11:00:00.904]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.904]    - tweaked: FALSE
[11:00:00.904]    - call: NULL
[11:00:00.904] plan(): nbrOfWorkers() = 1
[11:00:00.905] plan(): Setting new future strategy stack:
[11:00:00.905] List of future strategies:
[11:00:00.905] 1. sequential:
[11:00:00.905]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.905]    - tweaked: FALSE
[11:00:00.905]    - call: plan(strategy)
[11:00:00.906] plan(): nbrOfWorkers() = 1
[11:00:00.906] SequentialFuture started (and completed)
[11:00:00.906] - Launch lazy future ... done
[11:00:00.906] run() for ‘SequentialFuture’ ... done
[11:00:00.906] Created future:
[11:00:00.906] SequentialFuture:
[11:00:00.906] Label: ‘future_vapply-1’
[11:00:00.906] Expression:
[11:00:00.906] {
[11:00:00.906]     do.call(function(...) {
[11:00:00.906]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.906]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.906]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.906]             on.exit(options(oopts), add = TRUE)
[11:00:00.906]         }
[11:00:00.906]         {
[11:00:00.906]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.906]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.906]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.906]             })
[11:00:00.906]         }
[11:00:00.906]     }, args = future.call.arguments)
[11:00:00.906] }
[11:00:00.906] Lazy evaluation: FALSE
[11:00:00.906] Asynchronous evaluation: FALSE
[11:00:00.906] Local evaluation: TRUE
[11:00:00.906] Environment: R_GlobalEnv
[11:00:00.906] Capture standard output: TRUE
[11:00:00.906] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:00.906] Globals: 11 objects totaling 12.19 KiB (function ‘...future.FUN’ of 3.91 KiB, function ‘x_FUN’ of 37 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:00.906] Packages: 1 packages (‘future.apply’)
[11:00:00.906] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:00.906] Resolved: TRUE
[11:00:00.906] Value: 67 bytes of class ‘list’
[11:00:00.906] Early signaling: FALSE
[11:00:00.906] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:00.906] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.907] Chunk #1 of 1 ... DONE
[11:00:00.907] Launching 1 futures (chunks) ... DONE
[11:00:00.907] Resolving 1 futures (chunks) ...
[11:00:00.907] resolve() on list ...
[11:00:00.907]  recursive: 0
[11:00:00.907]  length: 1
[11:00:00.907] 
[11:00:00.907] resolved() for ‘SequentialFuture’ ...
[11:00:00.908] - state: ‘finished’
[11:00:00.908] - run: TRUE
[11:00:00.908] - result: ‘FutureResult’
[11:00:00.908] resolved() for ‘SequentialFuture’ ... done
[11:00:00.908] Future #1
[11:00:00.908] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:00.908] - nx: 1
[11:00:00.908] - relay: TRUE
[11:00:00.908] - stdout: TRUE
[11:00:00.908] - signal: TRUE
[11:00:00.908] - resignal: FALSE
[11:00:00.908] - force: TRUE
[11:00:00.909] - relayed: [n=1] FALSE
[11:00:00.909] - queued futures: [n=1] FALSE
[11:00:00.909]  - until=1
[11:00:00.909]  - relaying element #1
[11:00:00.909] - relayed: [n=1] TRUE
[11:00:00.909] - queued futures: [n=1] TRUE
[11:00:00.909] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:00.909]  length: 0 (resolved future 1)
[11:00:00.909] Relaying remaining futures
[11:00:00.909] signalConditionsASAP(NULL, pos=0) ...
[11:00:00.909] - nx: 1
[11:00:00.910] - relay: TRUE
[11:00:00.910] - stdout: TRUE
[11:00:00.910] - signal: TRUE
[11:00:00.910] - resignal: FALSE
[11:00:00.910] - force: TRUE
[11:00:00.910] - relayed: [n=1] TRUE
[11:00:00.911] - queued futures: [n=1] TRUE
 - flush all
[11:00:00.911] - relayed: [n=1] TRUE
[11:00:00.911] - queued futures: [n=1] TRUE
[11:00:00.911] signalConditionsASAP(NULL, pos=0) ... done
[11:00:00.911] resolve() on list ... DONE
[11:00:00.911]  - Number of value chunks collected: 1
[11:00:00.911] Resolving 1 futures (chunks) ... DONE
[11:00:00.911] Reducing values from 1 chunks ...
[11:00:00.911]  - Number of values collected after concatenation: 3
[11:00:00.912]  - Number of values expected: 3
[11:00:00.912] Reducing values from 1 chunks ... DONE
[11:00:00.912] future_lapply() ... DONE
- exceptions ...
[11:00:00.912] future_lapply() ...
[11:00:00.914] Number of chunks: 1
[11:00:00.914] getGlobalsAndPackagesXApply() ...
[11:00:00.914]  - future.globals: TRUE
[11:00:00.914] getGlobalsAndPackages() ...
[11:00:00.914] Searching for globals...
[11:00:00.917] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[11:00:00.917] Searching for globals ... DONE
[11:00:00.917] Resolving globals: FALSE
[11:00:00.918] The total size of the 7 globals is 12.81 KiB (13119 bytes)
[11:00:00.918] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.65 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:00.918] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.918] - packages: [1] ‘future.apply’
[11:00:00.919] getGlobalsAndPackages() ... DONE
[11:00:00.919]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.919]  - needed namespaces: [n=1] ‘future.apply’
[11:00:00.919] Finding globals ... DONE
[11:00:00.919]  - use_args: TRUE
[11:00:00.919]  - Getting '...' globals ...
[11:00:00.919] resolve() on list ...
[11:00:00.919]  recursive: 0
[11:00:00.919]  length: 1
[11:00:00.919]  elements: ‘...’
[11:00:00.920]  length: 0 (resolved future 1)
[11:00:00.920] resolve() on list ... DONE
[11:00:00.920]    - '...' content: [n=0] 
[11:00:00.920] List of 1
[11:00:00.920]  $ ...: list()
[11:00:00.920]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.920]  - attr(*, "where")=List of 1
[11:00:00.920]   ..$ ...:<environment: 0x55bbadc9a168> 
[11:00:00.920]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.920]  - attr(*, "resolved")= logi TRUE
[11:00:00.920]  - attr(*, "total_size")= num NA
[11:00:00.922]  - Getting '...' globals ... DONE
[11:00:00.922] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:00.922] List of 8
[11:00:00.922]  $ ...future.FUN:function (x, ...)  
[11:00:00.922]  $ x_FUN        :function (x)  
[11:00:00.922]  $ times        : int 2
[11:00:00.922]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.922]  $ stop_if_not  :function (...)  
[11:00:00.922]  $ dim          : NULL
[11:00:00.922]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:00.922]  $ ...          : list()
[11:00:00.922]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.922]  - attr(*, "where")=List of 8
[11:00:00.922]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:00.922]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:00.922]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:00.922]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:00.922]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:00.922]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:00.922]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:00.922]   ..$ ...          :<environment: 0x55bbadc9a168> 
[11:00:00.922]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.922]  - attr(*, "resolved")= logi FALSE
[11:00:00.922]  - attr(*, "total_size")= num 23676
[11:00:00.927] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:00.927] getGlobalsAndPackagesXApply() ... DONE
[11:00:00.927] Number of futures (= number of chunks): 1
[11:00:00.927] Launching 1 futures (chunks) ...
[11:00:00.928] Chunk #1 of 1 ...
[11:00:00.928]  - Finding globals in 'X' for chunk #1 ...
[11:00:00.928] getGlobalsAndPackages() ...
[11:00:00.928] Searching for globals...
[11:00:00.928] 
[11:00:00.928] Searching for globals ... DONE
[11:00:00.928] - globals: [0] <none>
[11:00:00.929] getGlobalsAndPackages() ... DONE
[11:00:00.929]    + additional globals found: [n=0] 
[11:00:00.929]    + additional namespaces needed: [n=0] 
[11:00:00.929]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:00.929]  - seeds: <none>
[11:00:00.930]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.930] getGlobalsAndPackages() ...
[11:00:00.930] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.930] Resolving globals: FALSE
[11:00:00.930] Tweak future expression to call with '...' arguments ...
[11:00:00.930] {
[11:00:00.930]     do.call(function(...) {
[11:00:00.930]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.930]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.930]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.930]             on.exit(options(oopts), add = TRUE)
[11:00:00.930]         }
[11:00:00.930]         {
[11:00:00.930]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.930]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.930]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.930]             })
[11:00:00.930]         }
[11:00:00.930]     }, args = future.call.arguments)
[11:00:00.930] }
[11:00:00.930] Tweak future expression to call with '...' arguments ... DONE
[11:00:00.931] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.931] - packages: [1] ‘future.apply’
[11:00:00.931] getGlobalsAndPackages() ... DONE
[11:00:00.931] run() for ‘Future’ ...
[11:00:00.931] - state: ‘created’
[11:00:00.931] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:00.932] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.932] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:00.932]   - Field: ‘label’
[11:00:00.932]   - Field: ‘local’
[11:00:00.932]   - Field: ‘owner’
[11:00:00.932]   - Field: ‘envir’
[11:00:00.932]   - Field: ‘packages’
[11:00:00.932]   - Field: ‘gc’
[11:00:00.932]   - Field: ‘conditions’
[11:00:00.932]   - Field: ‘expr’
[11:00:00.933]   - Field: ‘uuid’
[11:00:00.933]   - Field: ‘seed’
[11:00:00.933]   - Field: ‘version’
[11:00:00.933]   - Field: ‘result’
[11:00:00.933]   - Field: ‘asynchronous’
[11:00:00.933]   - Field: ‘calls’
[11:00:00.933]   - Field: ‘globals’
[11:00:00.933]   - Field: ‘stdout’
[11:00:00.933]   - Field: ‘earlySignal’
[11:00:00.933]   - Field: ‘lazy’
[11:00:00.933]   - Field: ‘state’
[11:00:00.933] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:00.934] - Launch lazy future ...
[11:00:00.934] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:00.934] Packages needed by future strategies (n = 0): <none>
[11:00:00.934] {
[11:00:00.934]     {
[11:00:00.934]         {
[11:00:00.934]             ...future.startTime <- base::Sys.time()
[11:00:00.934]             {
[11:00:00.934]                 {
[11:00:00.934]                   {
[11:00:00.934]                     {
[11:00:00.934]                       base::local({
[11:00:00.934]                         has_future <- base::requireNamespace("future", 
[11:00:00.934]                           quietly = TRUE)
[11:00:00.934]                         if (has_future) {
[11:00:00.934]                           ns <- base::getNamespace("future")
[11:00:00.934]                           version <- ns[[".package"]][["version"]]
[11:00:00.934]                           if (is.null(version)) 
[11:00:00.934]                             version <- utils::packageVersion("future")
[11:00:00.934]                         }
[11:00:00.934]                         else {
[11:00:00.934]                           version <- NULL
[11:00:00.934]                         }
[11:00:00.934]                         if (!has_future || version < "1.8.0") {
[11:00:00.934]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:00.934]                             "", base::R.version$version.string), 
[11:00:00.934]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:00.934]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:00.934]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:00.934]                               "release", "version")], collapse = " "), 
[11:00:00.934]                             hostname = base::Sys.info()[["nodename"]])
[11:00:00.934]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:00.934]                             info)
[11:00:00.934]                           info <- base::paste(info, collapse = "; ")
[11:00:00.934]                           if (!has_future) {
[11:00:00.934]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:00.934]                               info)
[11:00:00.934]                           }
[11:00:00.934]                           else {
[11:00:00.934]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:00.934]                               info, version)
[11:00:00.934]                           }
[11:00:00.934]                           base::stop(msg)
[11:00:00.934]                         }
[11:00:00.934]                       })
[11:00:00.934]                     }
[11:00:00.934]                     base::local({
[11:00:00.934]                       for (pkg in "future.apply") {
[11:00:00.934]                         base::loadNamespace(pkg)
[11:00:00.934]                         base::library(pkg, character.only = TRUE)
[11:00:00.934]                       }
[11:00:00.934]                     })
[11:00:00.934]                   }
[11:00:00.934]                   ...future.strategy.old <- future::plan("list")
[11:00:00.934]                   options(future.plan = NULL)
[11:00:00.934]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.934]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:00.934]                 }
[11:00:00.934]                 ...future.workdir <- getwd()
[11:00:00.934]             }
[11:00:00.934]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:00.934]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:00.934]         }
[11:00:00.934]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:00.934]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:00.934]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:00.934]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:00.934]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:00.934]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:00.934]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:00.934]             base::names(...future.oldOptions))
[11:00:00.934]     }
[11:00:00.934]     if (FALSE) {
[11:00:00.934]     }
[11:00:00.934]     else {
[11:00:00.934]         if (TRUE) {
[11:00:00.934]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:00.934]                 open = "w")
[11:00:00.934]         }
[11:00:00.934]         else {
[11:00:00.934]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:00.934]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:00.934]         }
[11:00:00.934]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:00.934]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:00.934]             base::sink(type = "output", split = FALSE)
[11:00:00.934]             base::close(...future.stdout)
[11:00:00.934]         }, add = TRUE)
[11:00:00.934]     }
[11:00:00.934]     ...future.frame <- base::sys.nframe()
[11:00:00.934]     ...future.conditions <- base::list()
[11:00:00.934]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:00.934]     if (FALSE) {
[11:00:00.934]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:00.934]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:00.934]     }
[11:00:00.934]     ...future.result <- base::tryCatch({
[11:00:00.934]         base::withCallingHandlers({
[11:00:00.934]             ...future.value <- base::withVisible(base::local({
[11:00:00.934]                 do.call(function(...) {
[11:00:00.934]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.934]                   if (!identical(...future.globals.maxSize.org, 
[11:00:00.934]                     ...future.globals.maxSize)) {
[11:00:00.934]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.934]                     on.exit(options(oopts), add = TRUE)
[11:00:00.934]                   }
[11:00:00.934]                   {
[11:00:00.934]                     lapply(seq_along(...future.elements_ii), 
[11:00:00.934]                       FUN = function(jj) {
[11:00:00.934]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.934]                         ...future.FUN(...future.X_jj, ...)
[11:00:00.934]                       })
[11:00:00.934]                   }
[11:00:00.934]                 }, args = future.call.arguments)
[11:00:00.934]             }))
[11:00:00.934]             future::FutureResult(value = ...future.value$value, 
[11:00:00.934]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.934]                   ...future.rng), globalenv = if (FALSE) 
[11:00:00.934]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:00.934]                     ...future.globalenv.names))
[11:00:00.934]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:00.934]         }, condition = base::local({
[11:00:00.934]             c <- base::c
[11:00:00.934]             inherits <- base::inherits
[11:00:00.934]             invokeRestart <- base::invokeRestart
[11:00:00.934]             length <- base::length
[11:00:00.934]             list <- base::list
[11:00:00.934]             seq.int <- base::seq.int
[11:00:00.934]             signalCondition <- base::signalCondition
[11:00:00.934]             sys.calls <- base::sys.calls
[11:00:00.934]             `[[` <- base::`[[`
[11:00:00.934]             `+` <- base::`+`
[11:00:00.934]             `<<-` <- base::`<<-`
[11:00:00.934]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:00.934]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:00.934]                   3L)]
[11:00:00.934]             }
[11:00:00.934]             function(cond) {
[11:00:00.934]                 is_error <- inherits(cond, "error")
[11:00:00.934]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:00.934]                   NULL)
[11:00:00.934]                 if (is_error) {
[11:00:00.934]                   sessionInformation <- function() {
[11:00:00.934]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:00.934]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:00.934]                       search = base::search(), system = base::Sys.info())
[11:00:00.934]                   }
[11:00:00.934]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.934]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:00.934]                     cond$call), session = sessionInformation(), 
[11:00:00.934]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:00.934]                   signalCondition(cond)
[11:00:00.934]                 }
[11:00:00.934]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:00.934]                 "immediateCondition"))) {
[11:00:00.934]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:00.934]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.934]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:00.934]                   if (TRUE && !signal) {
[11:00:00.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.934]                     {
[11:00:00.934]                       inherits <- base::inherits
[11:00:00.934]                       invokeRestart <- base::invokeRestart
[11:00:00.934]                       is.null <- base::is.null
[11:00:00.934]                       muffled <- FALSE
[11:00:00.934]                       if (inherits(cond, "message")) {
[11:00:00.934]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.934]                         if (muffled) 
[11:00:00.934]                           invokeRestart("muffleMessage")
[11:00:00.934]                       }
[11:00:00.934]                       else if (inherits(cond, "warning")) {
[11:00:00.934]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.934]                         if (muffled) 
[11:00:00.934]                           invokeRestart("muffleWarning")
[11:00:00.934]                       }
[11:00:00.934]                       else if (inherits(cond, "condition")) {
[11:00:00.934]                         if (!is.null(pattern)) {
[11:00:00.934]                           computeRestarts <- base::computeRestarts
[11:00:00.934]                           grepl <- base::grepl
[11:00:00.934]                           restarts <- computeRestarts(cond)
[11:00:00.934]                           for (restart in restarts) {
[11:00:00.934]                             name <- restart$name
[11:00:00.934]                             if (is.null(name)) 
[11:00:00.934]                               next
[11:00:00.934]                             if (!grepl(pattern, name)) 
[11:00:00.934]                               next
[11:00:00.934]                             invokeRestart(restart)
[11:00:00.934]                             muffled <- TRUE
[11:00:00.934]                             break
[11:00:00.934]                           }
[11:00:00.934]                         }
[11:00:00.934]                       }
[11:00:00.934]                       invisible(muffled)
[11:00:00.934]                     }
[11:00:00.934]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.934]                   }
[11:00:00.934]                 }
[11:00:00.934]                 else {
[11:00:00.934]                   if (TRUE) {
[11:00:00.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.934]                     {
[11:00:00.934]                       inherits <- base::inherits
[11:00:00.934]                       invokeRestart <- base::invokeRestart
[11:00:00.934]                       is.null <- base::is.null
[11:00:00.934]                       muffled <- FALSE
[11:00:00.934]                       if (inherits(cond, "message")) {
[11:00:00.934]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.934]                         if (muffled) 
[11:00:00.934]                           invokeRestart("muffleMessage")
[11:00:00.934]                       }
[11:00:00.934]                       else if (inherits(cond, "warning")) {
[11:00:00.934]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.934]                         if (muffled) 
[11:00:00.934]                           invokeRestart("muffleWarning")
[11:00:00.934]                       }
[11:00:00.934]                       else if (inherits(cond, "condition")) {
[11:00:00.934]                         if (!is.null(pattern)) {
[11:00:00.934]                           computeRestarts <- base::computeRestarts
[11:00:00.934]                           grepl <- base::grepl
[11:00:00.934]                           restarts <- computeRestarts(cond)
[11:00:00.934]                           for (restart in restarts) {
[11:00:00.934]                             name <- restart$name
[11:00:00.934]                             if (is.null(name)) 
[11:00:00.934]                               next
[11:00:00.934]                             if (!grepl(pattern, name)) 
[11:00:00.934]                               next
[11:00:00.934]                             invokeRestart(restart)
[11:00:00.934]                             muffled <- TRUE
[11:00:00.934]                             break
[11:00:00.934]                           }
[11:00:00.934]                         }
[11:00:00.934]                       }
[11:00:00.934]                       invisible(muffled)
[11:00:00.934]                     }
[11:00:00.934]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.934]                   }
[11:00:00.934]                 }
[11:00:00.934]             }
[11:00:00.934]         }))
[11:00:00.934]     }, error = function(ex) {
[11:00:00.934]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:00.934]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.934]                 ...future.rng), started = ...future.startTime, 
[11:00:00.934]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:00.934]             version = "1.8"), class = "FutureResult")
[11:00:00.934]     }, finally = {
[11:00:00.934]         if (!identical(...future.workdir, getwd())) 
[11:00:00.934]             setwd(...future.workdir)
[11:00:00.934]         {
[11:00:00.934]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:00.934]                 ...future.oldOptions$nwarnings <- NULL
[11:00:00.934]             }
[11:00:00.934]             base::options(...future.oldOptions)
[11:00:00.934]             if (.Platform$OS.type == "windows") {
[11:00:00.934]                 old_names <- names(...future.oldEnvVars)
[11:00:00.934]                 envs <- base::Sys.getenv()
[11:00:00.934]                 names <- names(envs)
[11:00:00.934]                 common <- intersect(names, old_names)
[11:00:00.934]                 added <- setdiff(names, old_names)
[11:00:00.934]                 removed <- setdiff(old_names, names)
[11:00:00.934]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:00.934]                   envs[common]]
[11:00:00.934]                 NAMES <- toupper(changed)
[11:00:00.934]                 args <- list()
[11:00:00.934]                 for (kk in seq_along(NAMES)) {
[11:00:00.934]                   name <- changed[[kk]]
[11:00:00.934]                   NAME <- NAMES[[kk]]
[11:00:00.934]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.934]                     next
[11:00:00.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.934]                 }
[11:00:00.934]                 NAMES <- toupper(added)
[11:00:00.934]                 for (kk in seq_along(NAMES)) {
[11:00:00.934]                   name <- added[[kk]]
[11:00:00.934]                   NAME <- NAMES[[kk]]
[11:00:00.934]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.934]                     next
[11:00:00.934]                   args[[name]] <- ""
[11:00:00.934]                 }
[11:00:00.934]                 NAMES <- toupper(removed)
[11:00:00.934]                 for (kk in seq_along(NAMES)) {
[11:00:00.934]                   name <- removed[[kk]]
[11:00:00.934]                   NAME <- NAMES[[kk]]
[11:00:00.934]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.934]                     next
[11:00:00.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.934]                 }
[11:00:00.934]                 if (length(args) > 0) 
[11:00:00.934]                   base::do.call(base::Sys.setenv, args = args)
[11:00:00.934]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:00.934]             }
[11:00:00.934]             else {
[11:00:00.934]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:00.934]             }
[11:00:00.934]             {
[11:00:00.934]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:00.934]                   0L) {
[11:00:00.934]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:00.934]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:00.934]                   base::options(opts)
[11:00:00.934]                 }
[11:00:00.934]                 {
[11:00:00.934]                   {
[11:00:00.934]                     NULL
[11:00:00.934]                     RNGkind("Mersenne-Twister")
[11:00:00.934]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:00.934]                       inherits = FALSE)
[11:00:00.934]                   }
[11:00:00.934]                   options(future.plan = NULL)
[11:00:00.934]                   if (is.na(NA_character_)) 
[11:00:00.934]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.934]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:00.934]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:00.934]                     .init = FALSE)
[11:00:00.934]                 }
[11:00:00.934]             }
[11:00:00.934]         }
[11:00:00.934]     })
[11:00:00.934]     if (TRUE) {
[11:00:00.934]         base::sink(type = "output", split = FALSE)
[11:00:00.934]         if (TRUE) {
[11:00:00.934]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:00.934]         }
[11:00:00.934]         else {
[11:00:00.934]             ...future.result["stdout"] <- base::list(NULL)
[11:00:00.934]         }
[11:00:00.934]         base::close(...future.stdout)
[11:00:00.934]         ...future.stdout <- NULL
[11:00:00.934]     }
[11:00:00.934]     ...future.result$conditions <- ...future.conditions
[11:00:00.934]     ...future.result$finished <- base::Sys.time()
[11:00:00.934]     ...future.result
[11:00:00.934] }
[11:00:00.936] assign_globals() ...
[11:00:00.936] List of 11
[11:00:00.936]  $ ...future.FUN            :function (x, ...)  
[11:00:00.936]  $ x_FUN                    :function (x)  
[11:00:00.936]  $ times                    : int 2
[11:00:00.936]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.936]  $ stop_if_not              :function (...)  
[11:00:00.936]  $ dim                      : NULL
[11:00:00.936]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:00.936]  $ future.call.arguments    : list()
[11:00:00.936]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.936]  $ ...future.elements_ii    :List of 3
[11:00:00.936]   ..$ : int 1
[11:00:00.936]   ..$ : int 2
[11:00:00.936]   ..$ : int 3
[11:00:00.936]  $ ...future.seeds_ii       : NULL
[11:00:00.936]  $ ...future.globals.maxSize: NULL
[11:00:00.936]  - attr(*, "where")=List of 11
[11:00:00.936]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:00.936]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:00.936]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:00.936]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:00.936]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:00.936]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:00.936]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:00.936]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:00.936]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:00.936]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:00.936]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:00.936]  - attr(*, "resolved")= logi FALSE
[11:00:00.936]  - attr(*, "total_size")= num 23676
[11:00:00.936]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.936]  - attr(*, "already-done")= logi TRUE
[11:00:00.943] - copied ‘...future.FUN’ to environment
[11:00:00.943] - copied ‘x_FUN’ to environment
[11:00:00.943] - copied ‘times’ to environment
[11:00:00.944] - copied ‘stopf’ to environment
[11:00:00.944] - copied ‘stop_if_not’ to environment
[11:00:00.944] - copied ‘dim’ to environment
[11:00:00.944] - copied ‘valid_types’ to environment
[11:00:00.944] - copied ‘future.call.arguments’ to environment
[11:00:00.944] - copied ‘...future.elements_ii’ to environment
[11:00:00.944] - copied ‘...future.seeds_ii’ to environment
[11:00:00.944] - copied ‘...future.globals.maxSize’ to environment
[11:00:00.944] assign_globals() ... done
[11:00:00.945] plan(): Setting new future strategy stack:
[11:00:00.945] List of future strategies:
[11:00:00.945] 1. sequential:
[11:00:00.945]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.945]    - tweaked: FALSE
[11:00:00.945]    - call: NULL
[11:00:00.945] plan(): nbrOfWorkers() = 1
[11:00:00.946] plan(): Setting new future strategy stack:
[11:00:00.946] List of future strategies:
[11:00:00.946] 1. sequential:
[11:00:00.946]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.946]    - tweaked: FALSE
[11:00:00.946]    - call: plan(strategy)
[11:00:00.946] plan(): nbrOfWorkers() = 1
[11:00:00.947] SequentialFuture started (and completed)
[11:00:00.947] signalConditions() ...
[11:00:00.947]  - include = ‘immediateCondition’
[11:00:00.947]  - exclude = 
[11:00:00.947]  - resignal = FALSE
[11:00:00.947]  - Number of conditions: 1
[11:00:00.947] signalConditions() ... done
[11:00:00.947] - Launch lazy future ... done
[11:00:00.947] run() for ‘SequentialFuture’ ... done
[11:00:00.947] Created future:
[11:00:00.947] SequentialFuture:
[11:00:00.947] Label: ‘future_vapply-1’
[11:00:00.947] Expression:
[11:00:00.947] {
[11:00:00.947]     do.call(function(...) {
[11:00:00.947]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.947]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.947]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.947]             on.exit(options(oopts), add = TRUE)
[11:00:00.947]         }
[11:00:00.947]         {
[11:00:00.947]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.947]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.947]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.947]             })
[11:00:00.947]         }
[11:00:00.947]     }, args = future.call.arguments)
[11:00:00.947] }
[11:00:00.947] Lazy evaluation: FALSE
[11:00:00.947] Asynchronous evaluation: FALSE
[11:00:00.947] Local evaluation: TRUE
[11:00:00.947] Environment: R_GlobalEnv
[11:00:00.947] Capture standard output: TRUE
[11:00:00.947] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:00.947] Globals: 11 objects totaling 13.02 KiB (function ‘...future.FUN’ of 4.65 KiB, function ‘x_FUN’ of 185 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:00.947] Packages: 1 packages (‘future.apply’)
[11:00:00.947] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:00.947] Resolved: TRUE
[11:00:00.947] Value: 27 bytes of class ‘NULL’
[11:00:00.947] Conditions captured: [n=1] ‘simpleError’
[11:00:00.947] Early signaling: FALSE
[11:00:00.947] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:00.947] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:00.948] Chunk #1 of 1 ... DONE
[11:00:00.948] Launching 1 futures (chunks) ... DONE
[11:00:00.948] Resolving 1 futures (chunks) ...
[11:00:00.949] resolve() on list ...
[11:00:00.949]  recursive: 0
[11:00:00.949]  length: 1
[11:00:00.949] 
[11:00:00.949] resolved() for ‘SequentialFuture’ ...
[11:00:00.949] - state: ‘finished’
[11:00:00.949] - run: TRUE
[11:00:00.949] - result: ‘FutureResult’
[11:00:00.949] resolved() for ‘SequentialFuture’ ... done
[11:00:00.950] Future #1
[11:00:00.950] signalConditions() ...
[11:00:00.950]  - include = ‘immediateCondition’
[11:00:00.950]  - exclude = 
[11:00:00.951]  - resignal = FALSE
[11:00:00.951]  - Number of conditions: 1
[11:00:00.951] signalConditions() ... done
[11:00:00.951] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:00.951] - nx: 1
[11:00:00.951] - relay: TRUE
[11:00:00.951] - stdout: TRUE
[11:00:00.951] - signal: TRUE
[11:00:00.951] - resignal: FALSE
[11:00:00.951] - force: TRUE
[11:00:00.951] - relayed: [n=1] FALSE
[11:00:00.951] - queued futures: [n=1] FALSE
[11:00:00.952]  - until=1
[11:00:00.952]  - relaying element #1
[11:00:00.952] signalConditions() ...
[11:00:00.952]  - include = ‘immediateCondition’
[11:00:00.952]  - exclude = 
[11:00:00.952]  - resignal = FALSE
[11:00:00.952]  - Number of conditions: 1
[11:00:00.952] signalConditions() ... done
[11:00:00.952] signalConditions() ...
[11:00:00.952]  - include = ‘immediateCondition’
[11:00:00.952]  - exclude = 
[11:00:00.952]  - resignal = FALSE
[11:00:00.953]  - Number of conditions: 1
[11:00:00.953] signalConditions() ... done
[11:00:00.953] signalConditions() ...
[11:00:00.953]  - include = ‘condition’
[11:00:00.953]  - exclude = ‘immediateCondition’
[11:00:00.953]  - resignal = TRUE
[11:00:00.953]  - Number of conditions: 1
[11:00:00.953]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:00:00.953] signalConditions() ... done
[11:00:00.953] - relayed: [n=1] FALSE
[11:00:00.953] - queued futures: [n=1] TRUE
[11:00:00.953] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:00.954] plan(): Setting new future strategy stack:
[11:00:00.954] List of future strategies:
[11:00:00.954] 1. sequential:
[11:00:00.954]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:00.954]    - tweaked: FALSE
[11:00:00.954]    - call: plan(sequential)
[11:00:00.954] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[11:00:00.955] plan(): Setting new future strategy stack:
[11:00:00.955] List of future strategies:
[11:00:00.955] 1. multicore:
[11:00:00.955]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:00.955]    - tweaked: FALSE
[11:00:00.955]    - call: plan(strategy)
[11:00:00.956] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[11:00:00.958] future_lapply() ...
[11:00:00.962] Number of chunks: 2
[11:00:00.962] getGlobalsAndPackagesXApply() ...
[11:00:00.962]  - future.globals: TRUE
[11:00:00.962] getGlobalsAndPackages() ...
[11:00:00.962] Searching for globals...
[11:00:00.965] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[11:00:00.965] Searching for globals ... DONE
[11:00:00.965] Resolving globals: FALSE
[11:00:00.966] The total size of the 7 globals is 12.01 KiB (12294 bytes)
[11:00:00.966] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.02 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:00.966] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.966] - packages: [1] ‘future.apply’
[11:00:00.966] getGlobalsAndPackages() ... DONE
[11:00:00.966]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:00.967]  - needed namespaces: [n=1] ‘future.apply’
[11:00:00.967] Finding globals ... DONE
[11:00:00.967]  - use_args: TRUE
[11:00:00.967]  - Getting '...' globals ...
[11:00:00.967] resolve() on list ...
[11:00:00.967]  recursive: 0
[11:00:00.967]  length: 1
[11:00:00.967]  elements: ‘...’
[11:00:00.967]  length: 0 (resolved future 1)
[11:00:00.968] resolve() on list ... DONE
[11:00:00.968]    - '...' content: [n=0] 
[11:00:00.968] List of 1
[11:00:00.968]  $ ...: list()
[11:00:00.968]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.968]  - attr(*, "where")=List of 1
[11:00:00.968]   ..$ ...:<environment: 0x55bbacc1ab98> 
[11:00:00.968]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.968]  - attr(*, "resolved")= logi TRUE
[11:00:00.968]  - attr(*, "total_size")= num NA
[11:00:00.971]  - Getting '...' globals ... DONE
[11:00:00.971] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:00.971] List of 8
[11:00:00.971]  $ ...future.FUN:function (x, ...)  
[11:00:00.971]  $ x_FUN        :function (x)  
[11:00:00.971]  $ times        : int 1
[11:00:00.971]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.971]  $ stop_if_not  :function (...)  
[11:00:00.971]  $ dim          : NULL
[11:00:00.971]  $ valid_types  : chr "character"
[11:00:00.971]  $ ...          : list()
[11:00:00.971]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.971]  - attr(*, "where")=List of 8
[11:00:00.971]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:00.971]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:00.971]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:00.971]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:00.971]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:00.971]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:00.971]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:00.971]   ..$ ...          :<environment: 0x55bbacc1ab98> 
[11:00:00.971]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.971]  - attr(*, "resolved")= logi FALSE
[11:00:00.971]  - attr(*, "total_size")= num 22333
[11:00:00.976] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:00.976] getGlobalsAndPackagesXApply() ... DONE
[11:00:00.977] Number of futures (= number of chunks): 2
[11:00:00.977] Launching 2 futures (chunks) ...
[11:00:00.977] Chunk #1 of 2 ...
[11:00:00.977]  - Finding globals in 'X' for chunk #1 ...
[11:00:00.977] getGlobalsAndPackages() ...
[11:00:00.977] Searching for globals...
[11:00:00.977] 
[11:00:00.977] Searching for globals ... DONE
[11:00:00.977] - globals: [0] <none>
[11:00:00.977] getGlobalsAndPackages() ... DONE
[11:00:00.978]    + additional globals found: [n=0] 
[11:00:00.978]    + additional namespaces needed: [n=0] 
[11:00:00.978]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:00.978]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:00.978]  - seeds: <none>
[11:00:00.978]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.978] getGlobalsAndPackages() ...
[11:00:00.978] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.978] Resolving globals: FALSE
[11:00:00.978] Tweak future expression to call with '...' arguments ...
[11:00:00.978] {
[11:00:00.978]     do.call(function(...) {
[11:00:00.978]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.978]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:00.978]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.978]             on.exit(options(oopts), add = TRUE)
[11:00:00.978]         }
[11:00:00.978]         {
[11:00:00.978]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:00.978]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.978]                 ...future.FUN(...future.X_jj, ...)
[11:00:00.978]             })
[11:00:00.978]         }
[11:00:00.978]     }, args = future.call.arguments)
[11:00:00.978] }
[11:00:00.979] Tweak future expression to call with '...' arguments ... DONE
[11:00:00.979] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:00.979] - packages: [1] ‘future.apply’
[11:00:00.979] getGlobalsAndPackages() ... DONE
[11:00:00.980] run() for ‘Future’ ...
[11:00:00.980] - state: ‘created’
[11:00:00.980] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:00.981] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:00.981] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:00.982]   - Field: ‘label’
[11:00:00.982]   - Field: ‘local’
[11:00:00.982]   - Field: ‘owner’
[11:00:00.982]   - Field: ‘envir’
[11:00:00.982]   - Field: ‘workers’
[11:00:00.982]   - Field: ‘packages’
[11:00:00.982]   - Field: ‘gc’
[11:00:00.982]   - Field: ‘job’
[11:00:00.982]   - Field: ‘conditions’
[11:00:00.982]   - Field: ‘expr’
[11:00:00.982]   - Field: ‘uuid’
[11:00:00.982]   - Field: ‘seed’
[11:00:00.983]   - Field: ‘version’
[11:00:00.983]   - Field: ‘result’
[11:00:00.983]   - Field: ‘asynchronous’
[11:00:00.983]   - Field: ‘calls’
[11:00:00.983]   - Field: ‘globals’
[11:00:00.983]   - Field: ‘stdout’
[11:00:00.983]   - Field: ‘earlySignal’
[11:00:00.983]   - Field: ‘lazy’
[11:00:00.983]   - Field: ‘state’
[11:00:00.983] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:00.983] - Launch lazy future ...
[11:00:00.984] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:00.984] Packages needed by future strategies (n = 0): <none>
[11:00:00.985] {
[11:00:00.985]     {
[11:00:00.985]         {
[11:00:00.985]             ...future.startTime <- base::Sys.time()
[11:00:00.985]             {
[11:00:00.985]                 {
[11:00:00.985]                   {
[11:00:00.985]                     {
[11:00:00.985]                       {
[11:00:00.985]                         base::local({
[11:00:00.985]                           has_future <- base::requireNamespace("future", 
[11:00:00.985]                             quietly = TRUE)
[11:00:00.985]                           if (has_future) {
[11:00:00.985]                             ns <- base::getNamespace("future")
[11:00:00.985]                             version <- ns[[".package"]][["version"]]
[11:00:00.985]                             if (is.null(version)) 
[11:00:00.985]                               version <- utils::packageVersion("future")
[11:00:00.985]                           }
[11:00:00.985]                           else {
[11:00:00.985]                             version <- NULL
[11:00:00.985]                           }
[11:00:00.985]                           if (!has_future || version < "1.8.0") {
[11:00:00.985]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:00.985]                               "", base::R.version$version.string), 
[11:00:00.985]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:00.985]                                 base::R.version$platform, 8 * 
[11:00:00.985]                                   base::.Machine$sizeof.pointer), 
[11:00:00.985]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:00.985]                                 "release", "version")], collapse = " "), 
[11:00:00.985]                               hostname = base::Sys.info()[["nodename"]])
[11:00:00.985]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:00.985]                               info)
[11:00:00.985]                             info <- base::paste(info, collapse = "; ")
[11:00:00.985]                             if (!has_future) {
[11:00:00.985]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:00.985]                                 info)
[11:00:00.985]                             }
[11:00:00.985]                             else {
[11:00:00.985]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:00.985]                                 info, version)
[11:00:00.985]                             }
[11:00:00.985]                             base::stop(msg)
[11:00:00.985]                           }
[11:00:00.985]                         })
[11:00:00.985]                       }
[11:00:00.985]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:00.985]                       base::options(mc.cores = 1L)
[11:00:00.985]                     }
[11:00:00.985]                     base::local({
[11:00:00.985]                       for (pkg in "future.apply") {
[11:00:00.985]                         base::loadNamespace(pkg)
[11:00:00.985]                         base::library(pkg, character.only = TRUE)
[11:00:00.985]                       }
[11:00:00.985]                     })
[11:00:00.985]                   }
[11:00:00.985]                   ...future.strategy.old <- future::plan("list")
[11:00:00.985]                   options(future.plan = NULL)
[11:00:00.985]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.985]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:00.985]                 }
[11:00:00.985]                 ...future.workdir <- getwd()
[11:00:00.985]             }
[11:00:00.985]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:00.985]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:00.985]         }
[11:00:00.985]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:00.985]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:00.985]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:00.985]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:00.985]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:00.985]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:00.985]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:00.985]             base::names(...future.oldOptions))
[11:00:00.985]     }
[11:00:00.985]     if (FALSE) {
[11:00:00.985]     }
[11:00:00.985]     else {
[11:00:00.985]         if (TRUE) {
[11:00:00.985]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:00.985]                 open = "w")
[11:00:00.985]         }
[11:00:00.985]         else {
[11:00:00.985]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:00.985]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:00.985]         }
[11:00:00.985]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:00.985]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:00.985]             base::sink(type = "output", split = FALSE)
[11:00:00.985]             base::close(...future.stdout)
[11:00:00.985]         }, add = TRUE)
[11:00:00.985]     }
[11:00:00.985]     ...future.frame <- base::sys.nframe()
[11:00:00.985]     ...future.conditions <- base::list()
[11:00:00.985]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:00.985]     if (FALSE) {
[11:00:00.985]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:00.985]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:00.985]     }
[11:00:00.985]     ...future.result <- base::tryCatch({
[11:00:00.985]         base::withCallingHandlers({
[11:00:00.985]             ...future.value <- base::withVisible(base::local({
[11:00:00.985]                 withCallingHandlers({
[11:00:00.985]                   {
[11:00:00.985]                     do.call(function(...) {
[11:00:00.985]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:00.985]                       if (!identical(...future.globals.maxSize.org, 
[11:00:00.985]                         ...future.globals.maxSize)) {
[11:00:00.985]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:00.985]                         on.exit(options(oopts), add = TRUE)
[11:00:00.985]                       }
[11:00:00.985]                       {
[11:00:00.985]                         lapply(seq_along(...future.elements_ii), 
[11:00:00.985]                           FUN = function(jj) {
[11:00:00.985]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:00.985]                             ...future.FUN(...future.X_jj, ...)
[11:00:00.985]                           })
[11:00:00.985]                       }
[11:00:00.985]                     }, args = future.call.arguments)
[11:00:00.985]                   }
[11:00:00.985]                 }, immediateCondition = function(cond) {
[11:00:00.985]                   save_rds <- function (object, pathname, ...) 
[11:00:00.985]                   {
[11:00:00.985]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:00.985]                     if (file_test("-f", pathname_tmp)) {
[11:00:00.985]                       fi_tmp <- file.info(pathname_tmp)
[11:00:00.985]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:00.985]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:00.985]                         fi_tmp[["mtime"]])
[11:00:00.985]                     }
[11:00:00.985]                     tryCatch({
[11:00:00.985]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:00.985]                     }, error = function(ex) {
[11:00:00.985]                       msg <- conditionMessage(ex)
[11:00:00.985]                       fi_tmp <- file.info(pathname_tmp)
[11:00:00.985]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:00.985]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:00.985]                         fi_tmp[["mtime"]], msg)
[11:00:00.985]                       ex$message <- msg
[11:00:00.985]                       stop(ex)
[11:00:00.985]                     })
[11:00:00.985]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:00.985]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:00.985]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:00.985]                       fi_tmp <- file.info(pathname_tmp)
[11:00:00.985]                       fi <- file.info(pathname)
[11:00:00.985]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:00.985]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:00.985]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:00.985]                         fi[["size"]], fi[["mtime"]])
[11:00:00.985]                       stop(msg)
[11:00:00.985]                     }
[11:00:00.985]                     invisible(pathname)
[11:00:00.985]                   }
[11:00:00.985]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:00.985]                     rootPath = tempdir()) 
[11:00:00.985]                   {
[11:00:00.985]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:00.985]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:00.985]                       tmpdir = path, fileext = ".rds")
[11:00:00.985]                     save_rds(obj, file)
[11:00:00.985]                   }
[11:00:00.985]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:00.985]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.985]                   {
[11:00:00.985]                     inherits <- base::inherits
[11:00:00.985]                     invokeRestart <- base::invokeRestart
[11:00:00.985]                     is.null <- base::is.null
[11:00:00.985]                     muffled <- FALSE
[11:00:00.985]                     if (inherits(cond, "message")) {
[11:00:00.985]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:00.985]                       if (muffled) 
[11:00:00.985]                         invokeRestart("muffleMessage")
[11:00:00.985]                     }
[11:00:00.985]                     else if (inherits(cond, "warning")) {
[11:00:00.985]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:00.985]                       if (muffled) 
[11:00:00.985]                         invokeRestart("muffleWarning")
[11:00:00.985]                     }
[11:00:00.985]                     else if (inherits(cond, "condition")) {
[11:00:00.985]                       if (!is.null(pattern)) {
[11:00:00.985]                         computeRestarts <- base::computeRestarts
[11:00:00.985]                         grepl <- base::grepl
[11:00:00.985]                         restarts <- computeRestarts(cond)
[11:00:00.985]                         for (restart in restarts) {
[11:00:00.985]                           name <- restart$name
[11:00:00.985]                           if (is.null(name)) 
[11:00:00.985]                             next
[11:00:00.985]                           if (!grepl(pattern, name)) 
[11:00:00.985]                             next
[11:00:00.985]                           invokeRestart(restart)
[11:00:00.985]                           muffled <- TRUE
[11:00:00.985]                           break
[11:00:00.985]                         }
[11:00:00.985]                       }
[11:00:00.985]                     }
[11:00:00.985]                     invisible(muffled)
[11:00:00.985]                   }
[11:00:00.985]                   muffleCondition(cond)
[11:00:00.985]                 })
[11:00:00.985]             }))
[11:00:00.985]             future::FutureResult(value = ...future.value$value, 
[11:00:00.985]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.985]                   ...future.rng), globalenv = if (FALSE) 
[11:00:00.985]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:00.985]                     ...future.globalenv.names))
[11:00:00.985]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:00.985]         }, condition = base::local({
[11:00:00.985]             c <- base::c
[11:00:00.985]             inherits <- base::inherits
[11:00:00.985]             invokeRestart <- base::invokeRestart
[11:00:00.985]             length <- base::length
[11:00:00.985]             list <- base::list
[11:00:00.985]             seq.int <- base::seq.int
[11:00:00.985]             signalCondition <- base::signalCondition
[11:00:00.985]             sys.calls <- base::sys.calls
[11:00:00.985]             `[[` <- base::`[[`
[11:00:00.985]             `+` <- base::`+`
[11:00:00.985]             `<<-` <- base::`<<-`
[11:00:00.985]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:00.985]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:00.985]                   3L)]
[11:00:00.985]             }
[11:00:00.985]             function(cond) {
[11:00:00.985]                 is_error <- inherits(cond, "error")
[11:00:00.985]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:00.985]                   NULL)
[11:00:00.985]                 if (is_error) {
[11:00:00.985]                   sessionInformation <- function() {
[11:00:00.985]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:00.985]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:00.985]                       search = base::search(), system = base::Sys.info())
[11:00:00.985]                   }
[11:00:00.985]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.985]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:00.985]                     cond$call), session = sessionInformation(), 
[11:00:00.985]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:00.985]                   signalCondition(cond)
[11:00:00.985]                 }
[11:00:00.985]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:00.985]                 "immediateCondition"))) {
[11:00:00.985]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:00.985]                   ...future.conditions[[length(...future.conditions) + 
[11:00:00.985]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:00.985]                   if (TRUE && !signal) {
[11:00:00.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.985]                     {
[11:00:00.985]                       inherits <- base::inherits
[11:00:00.985]                       invokeRestart <- base::invokeRestart
[11:00:00.985]                       is.null <- base::is.null
[11:00:00.985]                       muffled <- FALSE
[11:00:00.985]                       if (inherits(cond, "message")) {
[11:00:00.985]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.985]                         if (muffled) 
[11:00:00.985]                           invokeRestart("muffleMessage")
[11:00:00.985]                       }
[11:00:00.985]                       else if (inherits(cond, "warning")) {
[11:00:00.985]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.985]                         if (muffled) 
[11:00:00.985]                           invokeRestart("muffleWarning")
[11:00:00.985]                       }
[11:00:00.985]                       else if (inherits(cond, "condition")) {
[11:00:00.985]                         if (!is.null(pattern)) {
[11:00:00.985]                           computeRestarts <- base::computeRestarts
[11:00:00.985]                           grepl <- base::grepl
[11:00:00.985]                           restarts <- computeRestarts(cond)
[11:00:00.985]                           for (restart in restarts) {
[11:00:00.985]                             name <- restart$name
[11:00:00.985]                             if (is.null(name)) 
[11:00:00.985]                               next
[11:00:00.985]                             if (!grepl(pattern, name)) 
[11:00:00.985]                               next
[11:00:00.985]                             invokeRestart(restart)
[11:00:00.985]                             muffled <- TRUE
[11:00:00.985]                             break
[11:00:00.985]                           }
[11:00:00.985]                         }
[11:00:00.985]                       }
[11:00:00.985]                       invisible(muffled)
[11:00:00.985]                     }
[11:00:00.985]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.985]                   }
[11:00:00.985]                 }
[11:00:00.985]                 else {
[11:00:00.985]                   if (TRUE) {
[11:00:00.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:00.985]                     {
[11:00:00.985]                       inherits <- base::inherits
[11:00:00.985]                       invokeRestart <- base::invokeRestart
[11:00:00.985]                       is.null <- base::is.null
[11:00:00.985]                       muffled <- FALSE
[11:00:00.985]                       if (inherits(cond, "message")) {
[11:00:00.985]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:00.985]                         if (muffled) 
[11:00:00.985]                           invokeRestart("muffleMessage")
[11:00:00.985]                       }
[11:00:00.985]                       else if (inherits(cond, "warning")) {
[11:00:00.985]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:00.985]                         if (muffled) 
[11:00:00.985]                           invokeRestart("muffleWarning")
[11:00:00.985]                       }
[11:00:00.985]                       else if (inherits(cond, "condition")) {
[11:00:00.985]                         if (!is.null(pattern)) {
[11:00:00.985]                           computeRestarts <- base::computeRestarts
[11:00:00.985]                           grepl <- base::grepl
[11:00:00.985]                           restarts <- computeRestarts(cond)
[11:00:00.985]                           for (restart in restarts) {
[11:00:00.985]                             name <- restart$name
[11:00:00.985]                             if (is.null(name)) 
[11:00:00.985]                               next
[11:00:00.985]                             if (!grepl(pattern, name)) 
[11:00:00.985]                               next
[11:00:00.985]                             invokeRestart(restart)
[11:00:00.985]                             muffled <- TRUE
[11:00:00.985]                             break
[11:00:00.985]                           }
[11:00:00.985]                         }
[11:00:00.985]                       }
[11:00:00.985]                       invisible(muffled)
[11:00:00.985]                     }
[11:00:00.985]                     muffleCondition(cond, pattern = "^muffle")
[11:00:00.985]                   }
[11:00:00.985]                 }
[11:00:00.985]             }
[11:00:00.985]         }))
[11:00:00.985]     }, error = function(ex) {
[11:00:00.985]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:00.985]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:00.985]                 ...future.rng), started = ...future.startTime, 
[11:00:00.985]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:00.985]             version = "1.8"), class = "FutureResult")
[11:00:00.985]     }, finally = {
[11:00:00.985]         if (!identical(...future.workdir, getwd())) 
[11:00:00.985]             setwd(...future.workdir)
[11:00:00.985]         {
[11:00:00.985]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:00.985]                 ...future.oldOptions$nwarnings <- NULL
[11:00:00.985]             }
[11:00:00.985]             base::options(...future.oldOptions)
[11:00:00.985]             if (.Platform$OS.type == "windows") {
[11:00:00.985]                 old_names <- names(...future.oldEnvVars)
[11:00:00.985]                 envs <- base::Sys.getenv()
[11:00:00.985]                 names <- names(envs)
[11:00:00.985]                 common <- intersect(names, old_names)
[11:00:00.985]                 added <- setdiff(names, old_names)
[11:00:00.985]                 removed <- setdiff(old_names, names)
[11:00:00.985]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:00.985]                   envs[common]]
[11:00:00.985]                 NAMES <- toupper(changed)
[11:00:00.985]                 args <- list()
[11:00:00.985]                 for (kk in seq_along(NAMES)) {
[11:00:00.985]                   name <- changed[[kk]]
[11:00:00.985]                   NAME <- NAMES[[kk]]
[11:00:00.985]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.985]                     next
[11:00:00.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.985]                 }
[11:00:00.985]                 NAMES <- toupper(added)
[11:00:00.985]                 for (kk in seq_along(NAMES)) {
[11:00:00.985]                   name <- added[[kk]]
[11:00:00.985]                   NAME <- NAMES[[kk]]
[11:00:00.985]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.985]                     next
[11:00:00.985]                   args[[name]] <- ""
[11:00:00.985]                 }
[11:00:00.985]                 NAMES <- toupper(removed)
[11:00:00.985]                 for (kk in seq_along(NAMES)) {
[11:00:00.985]                   name <- removed[[kk]]
[11:00:00.985]                   NAME <- NAMES[[kk]]
[11:00:00.985]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:00.985]                     next
[11:00:00.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:00.985]                 }
[11:00:00.985]                 if (length(args) > 0) 
[11:00:00.985]                   base::do.call(base::Sys.setenv, args = args)
[11:00:00.985]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:00.985]             }
[11:00:00.985]             else {
[11:00:00.985]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:00.985]             }
[11:00:00.985]             {
[11:00:00.985]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:00.985]                   0L) {
[11:00:00.985]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:00.985]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:00.985]                   base::options(opts)
[11:00:00.985]                 }
[11:00:00.985]                 {
[11:00:00.985]                   {
[11:00:00.985]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:00.985]                     NULL
[11:00:00.985]                   }
[11:00:00.985]                   options(future.plan = NULL)
[11:00:00.985]                   if (is.na(NA_character_)) 
[11:00:00.985]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:00.985]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:00.985]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:00.985]                     .init = FALSE)
[11:00:00.985]                 }
[11:00:00.985]             }
[11:00:00.985]         }
[11:00:00.985]     })
[11:00:00.985]     if (TRUE) {
[11:00:00.985]         base::sink(type = "output", split = FALSE)
[11:00:00.985]         if (TRUE) {
[11:00:00.985]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:00.985]         }
[11:00:00.985]         else {
[11:00:00.985]             ...future.result["stdout"] <- base::list(NULL)
[11:00:00.985]         }
[11:00:00.985]         base::close(...future.stdout)
[11:00:00.985]         ...future.stdout <- NULL
[11:00:00.985]     }
[11:00:00.985]     ...future.result$conditions <- ...future.conditions
[11:00:00.985]     ...future.result$finished <- base::Sys.time()
[11:00:00.985]     ...future.result
[11:00:00.985] }
[11:00:00.987] assign_globals() ...
[11:00:00.987] List of 11
[11:00:00.987]  $ ...future.FUN            :function (x, ...)  
[11:00:00.987]  $ x_FUN                    :function (x)  
[11:00:00.987]  $ times                    : int 1
[11:00:00.987]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:00.987]  $ stop_if_not              :function (...)  
[11:00:00.987]  $ dim                      : NULL
[11:00:00.987]  $ valid_types              : chr "character"
[11:00:00.987]  $ future.call.arguments    : list()
[11:00:00.987]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:00.987]  $ ...future.elements_ii    :List of 1
[11:00:00.987]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[11:00:00.987]  $ ...future.seeds_ii       : NULL
[11:00:00.987]  $ ...future.globals.maxSize: NULL
[11:00:00.987]  - attr(*, "where")=List of 11
[11:00:00.987]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:00.987]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:00.987]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:00.987]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:00.987]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:00.987]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:00.987]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:00.987]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:00.987]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:00.987]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:00.987]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:00.987]  - attr(*, "resolved")= logi FALSE
[11:00:00.987]  - attr(*, "total_size")= num 22333
[11:00:00.987]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:00.987]  - attr(*, "already-done")= logi TRUE
[11:00:00.995] - copied ‘...future.FUN’ to environment
[11:00:00.995] - copied ‘x_FUN’ to environment
[11:00:00.995] - copied ‘times’ to environment
[11:00:00.995] - copied ‘stopf’ to environment
[11:00:00.996] - copied ‘stop_if_not’ to environment
[11:00:00.996] - copied ‘dim’ to environment
[11:00:00.996] - copied ‘valid_types’ to environment
[11:00:00.996] - copied ‘future.call.arguments’ to environment
[11:00:00.996] - copied ‘...future.elements_ii’ to environment
[11:00:00.996] - copied ‘...future.seeds_ii’ to environment
[11:00:00.996] - copied ‘...future.globals.maxSize’ to environment
[11:00:00.996] assign_globals() ... done
[11:00:00.996] requestCore(): workers = 2
[11:00:00.999] MulticoreFuture started
[11:00:01.000] - Launch lazy future ... done
[11:00:01.000] run() for ‘MulticoreFuture’ ... done
[11:00:01.000] plan(): Setting new future strategy stack:
[11:00:01.000] Created future:
[11:00:01.001] List of future strategies:
[11:00:01.001] 1. sequential:
[11:00:01.001]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:01.001]    - tweaked: FALSE
[11:00:01.001]    - call: NULL
[11:00:01.002] plan(): nbrOfWorkers() = 1
[11:00:01.004] plan(): Setting new future strategy stack:
[11:00:01.004] List of future strategies:
[11:00:01.004] 1. multicore:
[11:00:01.004]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:01.004]    - tweaked: FALSE
[11:00:01.004]    - call: plan(strategy)
[11:00:01.007] plan(): nbrOfWorkers() = 2
[11:00:01.001] MulticoreFuture:
[11:00:01.001] Label: ‘future_vapply-1’
[11:00:01.001] Expression:
[11:00:01.001] {
[11:00:01.001]     do.call(function(...) {
[11:00:01.001]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.001]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.001]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.001]             on.exit(options(oopts), add = TRUE)
[11:00:01.001]         }
[11:00:01.001]         {
[11:00:01.001]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.001]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.001]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.001]             })
[11:00:01.001]         }
[11:00:01.001]     }, args = future.call.arguments)
[11:00:01.001] }
[11:00:01.001] Lazy evaluation: FALSE
[11:00:01.001] Asynchronous evaluation: TRUE
[11:00:01.001] Local evaluation: TRUE
[11:00:01.001] Environment: R_GlobalEnv
[11:00:01.001] Capture standard output: TRUE
[11:00:01.001] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:01.001] Globals: 11 objects totaling 12.33 KiB (function ‘...future.FUN’ of 4.02 KiB, function ‘x_FUN’ of 36 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:01.001] Packages: 1 packages (‘future.apply’)
[11:00:01.001] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:01.001] Resolved: TRUE
[11:00:01.001] Value: <not collected>
[11:00:01.001] Conditions captured: <none>
[11:00:01.001] Early signaling: FALSE
[11:00:01.001] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:01.001] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.009] Chunk #1 of 2 ... DONE
[11:00:01.009] Chunk #2 of 2 ...
[11:00:01.009]  - Finding globals in 'X' for chunk #2 ...
[11:00:01.009] getGlobalsAndPackages() ...
[11:00:01.009] Searching for globals...
[11:00:01.010] 
[11:00:01.010] Searching for globals ... DONE
[11:00:01.010] - globals: [0] <none>
[11:00:01.010] getGlobalsAndPackages() ... DONE
[11:00:01.011]    + additional globals found: [n=0] 
[11:00:01.011]    + additional namespaces needed: [n=0] 
[11:00:01.011]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:01.011]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:01.011]  - seeds: <none>
[11:00:01.011]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.012] getGlobalsAndPackages() ...
[11:00:01.012] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.012] Resolving globals: FALSE
[11:00:01.012] Tweak future expression to call with '...' arguments ...
[11:00:01.013] {
[11:00:01.013]     do.call(function(...) {
[11:00:01.013]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.013]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.013]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.013]             on.exit(options(oopts), add = TRUE)
[11:00:01.013]         }
[11:00:01.013]         {
[11:00:01.013]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.013]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.013]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.013]             })
[11:00:01.013]         }
[11:00:01.013]     }, args = future.call.arguments)
[11:00:01.013] }
[11:00:01.013] Tweak future expression to call with '...' arguments ... DONE
[11:00:01.014] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.014] - packages: [1] ‘future.apply’
[11:00:01.014] getGlobalsAndPackages() ... DONE
[11:00:01.015] run() for ‘Future’ ...
[11:00:01.015] - state: ‘created’
[11:00:01.015] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:01.018] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.018] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:01.019]   - Field: ‘label’
[11:00:01.019]   - Field: ‘local’
[11:00:01.019]   - Field: ‘owner’
[11:00:01.019]   - Field: ‘envir’
[11:00:01.019]   - Field: ‘workers’
[11:00:01.019]   - Field: ‘packages’
[11:00:01.020]   - Field: ‘gc’
[11:00:01.020]   - Field: ‘job’
[11:00:01.020]   - Field: ‘conditions’
[11:00:01.020]   - Field: ‘expr’
[11:00:01.020]   - Field: ‘uuid’
[11:00:01.020]   - Field: ‘seed’
[11:00:01.021]   - Field: ‘version’
[11:00:01.021]   - Field: ‘result’
[11:00:01.021]   - Field: ‘asynchronous’
[11:00:01.021]   - Field: ‘calls’
[11:00:01.021]   - Field: ‘globals’
[11:00:01.021]   - Field: ‘stdout’
[11:00:01.022]   - Field: ‘earlySignal’
[11:00:01.022]   - Field: ‘lazy’
[11:00:01.022]   - Field: ‘state’
[11:00:01.022] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:01.022] - Launch lazy future ...
[11:00:01.023] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:01.023] Packages needed by future strategies (n = 0): <none>
[11:00:01.024] {
[11:00:01.024]     {
[11:00:01.024]         {
[11:00:01.024]             ...future.startTime <- base::Sys.time()
[11:00:01.024]             {
[11:00:01.024]                 {
[11:00:01.024]                   {
[11:00:01.024]                     {
[11:00:01.024]                       {
[11:00:01.024]                         base::local({
[11:00:01.024]                           has_future <- base::requireNamespace("future", 
[11:00:01.024]                             quietly = TRUE)
[11:00:01.024]                           if (has_future) {
[11:00:01.024]                             ns <- base::getNamespace("future")
[11:00:01.024]                             version <- ns[[".package"]][["version"]]
[11:00:01.024]                             if (is.null(version)) 
[11:00:01.024]                               version <- utils::packageVersion("future")
[11:00:01.024]                           }
[11:00:01.024]                           else {
[11:00:01.024]                             version <- NULL
[11:00:01.024]                           }
[11:00:01.024]                           if (!has_future || version < "1.8.0") {
[11:00:01.024]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:01.024]                               "", base::R.version$version.string), 
[11:00:01.024]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:01.024]                                 base::R.version$platform, 8 * 
[11:00:01.024]                                   base::.Machine$sizeof.pointer), 
[11:00:01.024]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:01.024]                                 "release", "version")], collapse = " "), 
[11:00:01.024]                               hostname = base::Sys.info()[["nodename"]])
[11:00:01.024]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:01.024]                               info)
[11:00:01.024]                             info <- base::paste(info, collapse = "; ")
[11:00:01.024]                             if (!has_future) {
[11:00:01.024]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:01.024]                                 info)
[11:00:01.024]                             }
[11:00:01.024]                             else {
[11:00:01.024]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:01.024]                                 info, version)
[11:00:01.024]                             }
[11:00:01.024]                             base::stop(msg)
[11:00:01.024]                           }
[11:00:01.024]                         })
[11:00:01.024]                       }
[11:00:01.024]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:01.024]                       base::options(mc.cores = 1L)
[11:00:01.024]                     }
[11:00:01.024]                     base::local({
[11:00:01.024]                       for (pkg in "future.apply") {
[11:00:01.024]                         base::loadNamespace(pkg)
[11:00:01.024]                         base::library(pkg, character.only = TRUE)
[11:00:01.024]                       }
[11:00:01.024]                     })
[11:00:01.024]                   }
[11:00:01.024]                   ...future.strategy.old <- future::plan("list")
[11:00:01.024]                   options(future.plan = NULL)
[11:00:01.024]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.024]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:01.024]                 }
[11:00:01.024]                 ...future.workdir <- getwd()
[11:00:01.024]             }
[11:00:01.024]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:01.024]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:01.024]         }
[11:00:01.024]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:01.024]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:01.024]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:01.024]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:01.024]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:01.024]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:01.024]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:01.024]             base::names(...future.oldOptions))
[11:00:01.024]     }
[11:00:01.024]     if (FALSE) {
[11:00:01.024]     }
[11:00:01.024]     else {
[11:00:01.024]         if (TRUE) {
[11:00:01.024]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:01.024]                 open = "w")
[11:00:01.024]         }
[11:00:01.024]         else {
[11:00:01.024]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:01.024]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:01.024]         }
[11:00:01.024]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:01.024]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:01.024]             base::sink(type = "output", split = FALSE)
[11:00:01.024]             base::close(...future.stdout)
[11:00:01.024]         }, add = TRUE)
[11:00:01.024]     }
[11:00:01.024]     ...future.frame <- base::sys.nframe()
[11:00:01.024]     ...future.conditions <- base::list()
[11:00:01.024]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:01.024]     if (FALSE) {
[11:00:01.024]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:01.024]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:01.024]     }
[11:00:01.024]     ...future.result <- base::tryCatch({
[11:00:01.024]         base::withCallingHandlers({
[11:00:01.024]             ...future.value <- base::withVisible(base::local({
[11:00:01.024]                 withCallingHandlers({
[11:00:01.024]                   {
[11:00:01.024]                     do.call(function(...) {
[11:00:01.024]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.024]                       if (!identical(...future.globals.maxSize.org, 
[11:00:01.024]                         ...future.globals.maxSize)) {
[11:00:01.024]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.024]                         on.exit(options(oopts), add = TRUE)
[11:00:01.024]                       }
[11:00:01.024]                       {
[11:00:01.024]                         lapply(seq_along(...future.elements_ii), 
[11:00:01.024]                           FUN = function(jj) {
[11:00:01.024]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.024]                             ...future.FUN(...future.X_jj, ...)
[11:00:01.024]                           })
[11:00:01.024]                       }
[11:00:01.024]                     }, args = future.call.arguments)
[11:00:01.024]                   }
[11:00:01.024]                 }, immediateCondition = function(cond) {
[11:00:01.024]                   save_rds <- function (object, pathname, ...) 
[11:00:01.024]                   {
[11:00:01.024]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:01.024]                     if (file_test("-f", pathname_tmp)) {
[11:00:01.024]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.024]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:01.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.024]                         fi_tmp[["mtime"]])
[11:00:01.024]                     }
[11:00:01.024]                     tryCatch({
[11:00:01.024]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:01.024]                     }, error = function(ex) {
[11:00:01.024]                       msg <- conditionMessage(ex)
[11:00:01.024]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.024]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:01.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.024]                         fi_tmp[["mtime"]], msg)
[11:00:01.024]                       ex$message <- msg
[11:00:01.024]                       stop(ex)
[11:00:01.024]                     })
[11:00:01.024]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:01.024]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:01.024]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:01.024]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.024]                       fi <- file.info(pathname)
[11:00:01.024]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:01.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.024]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:01.024]                         fi[["size"]], fi[["mtime"]])
[11:00:01.024]                       stop(msg)
[11:00:01.024]                     }
[11:00:01.024]                     invisible(pathname)
[11:00:01.024]                   }
[11:00:01.024]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:01.024]                     rootPath = tempdir()) 
[11:00:01.024]                   {
[11:00:01.024]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:01.024]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:01.024]                       tmpdir = path, fileext = ".rds")
[11:00:01.024]                     save_rds(obj, file)
[11:00:01.024]                   }
[11:00:01.024]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:01.024]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.024]                   {
[11:00:01.024]                     inherits <- base::inherits
[11:00:01.024]                     invokeRestart <- base::invokeRestart
[11:00:01.024]                     is.null <- base::is.null
[11:00:01.024]                     muffled <- FALSE
[11:00:01.024]                     if (inherits(cond, "message")) {
[11:00:01.024]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:01.024]                       if (muffled) 
[11:00:01.024]                         invokeRestart("muffleMessage")
[11:00:01.024]                     }
[11:00:01.024]                     else if (inherits(cond, "warning")) {
[11:00:01.024]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:01.024]                       if (muffled) 
[11:00:01.024]                         invokeRestart("muffleWarning")
[11:00:01.024]                     }
[11:00:01.024]                     else if (inherits(cond, "condition")) {
[11:00:01.024]                       if (!is.null(pattern)) {
[11:00:01.024]                         computeRestarts <- base::computeRestarts
[11:00:01.024]                         grepl <- base::grepl
[11:00:01.024]                         restarts <- computeRestarts(cond)
[11:00:01.024]                         for (restart in restarts) {
[11:00:01.024]                           name <- restart$name
[11:00:01.024]                           if (is.null(name)) 
[11:00:01.024]                             next
[11:00:01.024]                           if (!grepl(pattern, name)) 
[11:00:01.024]                             next
[11:00:01.024]                           invokeRestart(restart)
[11:00:01.024]                           muffled <- TRUE
[11:00:01.024]                           break
[11:00:01.024]                         }
[11:00:01.024]                       }
[11:00:01.024]                     }
[11:00:01.024]                     invisible(muffled)
[11:00:01.024]                   }
[11:00:01.024]                   muffleCondition(cond)
[11:00:01.024]                 })
[11:00:01.024]             }))
[11:00:01.024]             future::FutureResult(value = ...future.value$value, 
[11:00:01.024]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.024]                   ...future.rng), globalenv = if (FALSE) 
[11:00:01.024]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:01.024]                     ...future.globalenv.names))
[11:00:01.024]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:01.024]         }, condition = base::local({
[11:00:01.024]             c <- base::c
[11:00:01.024]             inherits <- base::inherits
[11:00:01.024]             invokeRestart <- base::invokeRestart
[11:00:01.024]             length <- base::length
[11:00:01.024]             list <- base::list
[11:00:01.024]             seq.int <- base::seq.int
[11:00:01.024]             signalCondition <- base::signalCondition
[11:00:01.024]             sys.calls <- base::sys.calls
[11:00:01.024]             `[[` <- base::`[[`
[11:00:01.024]             `+` <- base::`+`
[11:00:01.024]             `<<-` <- base::`<<-`
[11:00:01.024]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:01.024]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:01.024]                   3L)]
[11:00:01.024]             }
[11:00:01.024]             function(cond) {
[11:00:01.024]                 is_error <- inherits(cond, "error")
[11:00:01.024]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:01.024]                   NULL)
[11:00:01.024]                 if (is_error) {
[11:00:01.024]                   sessionInformation <- function() {
[11:00:01.024]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:01.024]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:01.024]                       search = base::search(), system = base::Sys.info())
[11:00:01.024]                   }
[11:00:01.024]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.024]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:01.024]                     cond$call), session = sessionInformation(), 
[11:00:01.024]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:01.024]                   signalCondition(cond)
[11:00:01.024]                 }
[11:00:01.024]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:01.024]                 "immediateCondition"))) {
[11:00:01.024]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:01.024]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.024]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:01.024]                   if (TRUE && !signal) {
[11:00:01.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.024]                     {
[11:00:01.024]                       inherits <- base::inherits
[11:00:01.024]                       invokeRestart <- base::invokeRestart
[11:00:01.024]                       is.null <- base::is.null
[11:00:01.024]                       muffled <- FALSE
[11:00:01.024]                       if (inherits(cond, "message")) {
[11:00:01.024]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.024]                         if (muffled) 
[11:00:01.024]                           invokeRestart("muffleMessage")
[11:00:01.024]                       }
[11:00:01.024]                       else if (inherits(cond, "warning")) {
[11:00:01.024]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.024]                         if (muffled) 
[11:00:01.024]                           invokeRestart("muffleWarning")
[11:00:01.024]                       }
[11:00:01.024]                       else if (inherits(cond, "condition")) {
[11:00:01.024]                         if (!is.null(pattern)) {
[11:00:01.024]                           computeRestarts <- base::computeRestarts
[11:00:01.024]                           grepl <- base::grepl
[11:00:01.024]                           restarts <- computeRestarts(cond)
[11:00:01.024]                           for (restart in restarts) {
[11:00:01.024]                             name <- restart$name
[11:00:01.024]                             if (is.null(name)) 
[11:00:01.024]                               next
[11:00:01.024]                             if (!grepl(pattern, name)) 
[11:00:01.024]                               next
[11:00:01.024]                             invokeRestart(restart)
[11:00:01.024]                             muffled <- TRUE
[11:00:01.024]                             break
[11:00:01.024]                           }
[11:00:01.024]                         }
[11:00:01.024]                       }
[11:00:01.024]                       invisible(muffled)
[11:00:01.024]                     }
[11:00:01.024]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.024]                   }
[11:00:01.024]                 }
[11:00:01.024]                 else {
[11:00:01.024]                   if (TRUE) {
[11:00:01.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.024]                     {
[11:00:01.024]                       inherits <- base::inherits
[11:00:01.024]                       invokeRestart <- base::invokeRestart
[11:00:01.024]                       is.null <- base::is.null
[11:00:01.024]                       muffled <- FALSE
[11:00:01.024]                       if (inherits(cond, "message")) {
[11:00:01.024]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.024]                         if (muffled) 
[11:00:01.024]                           invokeRestart("muffleMessage")
[11:00:01.024]                       }
[11:00:01.024]                       else if (inherits(cond, "warning")) {
[11:00:01.024]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.024]                         if (muffled) 
[11:00:01.024]                           invokeRestart("muffleWarning")
[11:00:01.024]                       }
[11:00:01.024]                       else if (inherits(cond, "condition")) {
[11:00:01.024]                         if (!is.null(pattern)) {
[11:00:01.024]                           computeRestarts <- base::computeRestarts
[11:00:01.024]                           grepl <- base::grepl
[11:00:01.024]                           restarts <- computeRestarts(cond)
[11:00:01.024]                           for (restart in restarts) {
[11:00:01.024]                             name <- restart$name
[11:00:01.024]                             if (is.null(name)) 
[11:00:01.024]                               next
[11:00:01.024]                             if (!grepl(pattern, name)) 
[11:00:01.024]                               next
[11:00:01.024]                             invokeRestart(restart)
[11:00:01.024]                             muffled <- TRUE
[11:00:01.024]                             break
[11:00:01.024]                           }
[11:00:01.024]                         }
[11:00:01.024]                       }
[11:00:01.024]                       invisible(muffled)
[11:00:01.024]                     }
[11:00:01.024]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.024]                   }
[11:00:01.024]                 }
[11:00:01.024]             }
[11:00:01.024]         }))
[11:00:01.024]     }, error = function(ex) {
[11:00:01.024]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:01.024]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.024]                 ...future.rng), started = ...future.startTime, 
[11:00:01.024]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:01.024]             version = "1.8"), class = "FutureResult")
[11:00:01.024]     }, finally = {
[11:00:01.024]         if (!identical(...future.workdir, getwd())) 
[11:00:01.024]             setwd(...future.workdir)
[11:00:01.024]         {
[11:00:01.024]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:01.024]                 ...future.oldOptions$nwarnings <- NULL
[11:00:01.024]             }
[11:00:01.024]             base::options(...future.oldOptions)
[11:00:01.024]             if (.Platform$OS.type == "windows") {
[11:00:01.024]                 old_names <- names(...future.oldEnvVars)
[11:00:01.024]                 envs <- base::Sys.getenv()
[11:00:01.024]                 names <- names(envs)
[11:00:01.024]                 common <- intersect(names, old_names)
[11:00:01.024]                 added <- setdiff(names, old_names)
[11:00:01.024]                 removed <- setdiff(old_names, names)
[11:00:01.024]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:01.024]                   envs[common]]
[11:00:01.024]                 NAMES <- toupper(changed)
[11:00:01.024]                 args <- list()
[11:00:01.024]                 for (kk in seq_along(NAMES)) {
[11:00:01.024]                   name <- changed[[kk]]
[11:00:01.024]                   NAME <- NAMES[[kk]]
[11:00:01.024]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.024]                     next
[11:00:01.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.024]                 }
[11:00:01.024]                 NAMES <- toupper(added)
[11:00:01.024]                 for (kk in seq_along(NAMES)) {
[11:00:01.024]                   name <- added[[kk]]
[11:00:01.024]                   NAME <- NAMES[[kk]]
[11:00:01.024]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.024]                     next
[11:00:01.024]                   args[[name]] <- ""
[11:00:01.024]                 }
[11:00:01.024]                 NAMES <- toupper(removed)
[11:00:01.024]                 for (kk in seq_along(NAMES)) {
[11:00:01.024]                   name <- removed[[kk]]
[11:00:01.024]                   NAME <- NAMES[[kk]]
[11:00:01.024]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.024]                     next
[11:00:01.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.024]                 }
[11:00:01.024]                 if (length(args) > 0) 
[11:00:01.024]                   base::do.call(base::Sys.setenv, args = args)
[11:00:01.024]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:01.024]             }
[11:00:01.024]             else {
[11:00:01.024]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:01.024]             }
[11:00:01.024]             {
[11:00:01.024]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:01.024]                   0L) {
[11:00:01.024]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:01.024]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:01.024]                   base::options(opts)
[11:00:01.024]                 }
[11:00:01.024]                 {
[11:00:01.024]                   {
[11:00:01.024]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:01.024]                     NULL
[11:00:01.024]                   }
[11:00:01.024]                   options(future.plan = NULL)
[11:00:01.024]                   if (is.na(NA_character_)) 
[11:00:01.024]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.024]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:01.024]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:01.024]                     .init = FALSE)
[11:00:01.024]                 }
[11:00:01.024]             }
[11:00:01.024]         }
[11:00:01.024]     })
[11:00:01.024]     if (TRUE) {
[11:00:01.024]         base::sink(type = "output", split = FALSE)
[11:00:01.024]         if (TRUE) {
[11:00:01.024]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:01.024]         }
[11:00:01.024]         else {
[11:00:01.024]             ...future.result["stdout"] <- base::list(NULL)
[11:00:01.024]         }
[11:00:01.024]         base::close(...future.stdout)
[11:00:01.024]         ...future.stdout <- NULL
[11:00:01.024]     }
[11:00:01.024]     ...future.result$conditions <- ...future.conditions
[11:00:01.024]     ...future.result$finished <- base::Sys.time()
[11:00:01.024]     ...future.result
[11:00:01.024] }
[11:00:01.028] assign_globals() ...
[11:00:01.028] List of 11
[11:00:01.028]  $ ...future.FUN            :function (x, ...)  
[11:00:01.028]  $ x_FUN                    :function (x)  
[11:00:01.028]  $ times                    : int 1
[11:00:01.028]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.028]  $ stop_if_not              :function (...)  
[11:00:01.028]  $ dim                      : NULL
[11:00:01.028]  $ valid_types              : chr "character"
[11:00:01.028]  $ future.call.arguments    : list()
[11:00:01.028]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.028]  $ ...future.elements_ii    :List of 1
[11:00:01.028]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[11:00:01.028]  $ ...future.seeds_ii       : NULL
[11:00:01.028]  $ ...future.globals.maxSize: NULL
[11:00:01.028]  - attr(*, "where")=List of 11
[11:00:01.028]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:01.028]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:01.028]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:01.028]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:01.028]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:01.028]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:01.028]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:01.028]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:01.028]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:01.028]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:01.028]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:01.028]  - attr(*, "resolved")= logi FALSE
[11:00:01.028]  - attr(*, "total_size")= num 22333
[11:00:01.028]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.028]  - attr(*, "already-done")= logi TRUE
[11:00:01.048] - copied ‘...future.FUN’ to environment
[11:00:01.049] - copied ‘x_FUN’ to environment
[11:00:01.049] - copied ‘times’ to environment
[11:00:01.049] - copied ‘stopf’ to environment
[11:00:01.049] - copied ‘stop_if_not’ to environment
[11:00:01.049] - copied ‘dim’ to environment
[11:00:01.049] - copied ‘valid_types’ to environment
[11:00:01.049] - copied ‘future.call.arguments’ to environment
[11:00:01.050] - copied ‘...future.elements_ii’ to environment
[11:00:01.050] - copied ‘...future.seeds_ii’ to environment
[11:00:01.050] - copied ‘...future.globals.maxSize’ to environment
[11:00:01.050] assign_globals() ... done
[11:00:01.050] requestCore(): workers = 2
[11:00:01.056] MulticoreFuture started
[11:00:01.057] - Launch lazy future ... done
[11:00:01.057] run() for ‘MulticoreFuture’ ... done
[11:00:01.058] Created future:
[11:00:01.058] plan(): Setting new future strategy stack:
[11:00:01.058] List of future strategies:
[11:00:01.058] 1. sequential:
[11:00:01.058]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:01.058]    - tweaked: FALSE
[11:00:01.058]    - call: NULL
[11:00:01.059] plan(): nbrOfWorkers() = 1
[11:00:01.061] plan(): Setting new future strategy stack:
[11:00:01.062] List of future strategies:
[11:00:01.062] 1. multicore:
[11:00:01.062]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:01.062]    - tweaked: FALSE
[11:00:01.062]    - call: plan(strategy)
[11:00:01.065] plan(): nbrOfWorkers() = 2
[11:00:01.058] MulticoreFuture:
[11:00:01.058] Label: ‘future_vapply-2’
[11:00:01.058] Expression:
[11:00:01.058] {
[11:00:01.058]     do.call(function(...) {
[11:00:01.058]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.058]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.058]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.058]             on.exit(options(oopts), add = TRUE)
[11:00:01.058]         }
[11:00:01.058]         {
[11:00:01.058]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.058]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.058]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.058]             })
[11:00:01.058]         }
[11:00:01.058]     }, args = future.call.arguments)
[11:00:01.058] }
[11:00:01.058] Lazy evaluation: FALSE
[11:00:01.058] Asynchronous evaluation: TRUE
[11:00:01.058] Local evaluation: TRUE
[11:00:01.058] Environment: R_GlobalEnv
[11:00:01.058] Capture standard output: TRUE
[11:00:01.058] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:01.058] Globals: 11 objects totaling 12.32 KiB (function ‘...future.FUN’ of 4.02 KiB, function ‘x_FUN’ of 36 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:01.058] Packages: 1 packages (‘future.apply’)
[11:00:01.058] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:01.058] Resolved: TRUE
[11:00:01.058] Value: <not collected>
[11:00:01.058] Conditions captured: <none>
[11:00:01.058] Early signaling: FALSE
[11:00:01.058] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:01.058] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.066] Chunk #2 of 2 ... DONE
[11:00:01.066] Launching 2 futures (chunks) ... DONE
[11:00:01.066] Resolving 2 futures (chunks) ...
[11:00:01.067] resolve() on list ...
[11:00:01.067]  recursive: 0
[11:00:01.067]  length: 2
[11:00:01.067] 
[11:00:01.067] Future #1
[11:00:01.068] result() for MulticoreFuture ...
[11:00:01.070] result() for MulticoreFuture ...
[11:00:01.071] result() for MulticoreFuture ... done
[11:00:01.071] result() for MulticoreFuture ... done
[11:00:01.071] result() for MulticoreFuture ...
[11:00:01.071] result() for MulticoreFuture ... done
[11:00:01.071] signalConditionsASAP(MulticoreFuture, pos=1) ...
[11:00:01.071] - nx: 2
[11:00:01.072] - relay: TRUE
[11:00:01.072] - stdout: TRUE
[11:00:01.072] - signal: TRUE
[11:00:01.072] - resignal: FALSE
[11:00:01.072] - force: TRUE
[11:00:01.072] - relayed: [n=2] FALSE, FALSE
[11:00:01.072] - queued futures: [n=2] FALSE, FALSE
[11:00:01.073]  - until=1
[11:00:01.073]  - relaying element #1
[11:00:01.073] result() for MulticoreFuture ...
[11:00:01.073] result() for MulticoreFuture ... done
[11:00:01.073] result() for MulticoreFuture ...
[11:00:01.073] result() for MulticoreFuture ... done
[11:00:01.074] result() for MulticoreFuture ...
[11:00:01.074] result() for MulticoreFuture ... done
[11:00:01.074] result() for MulticoreFuture ...
[11:00:01.074] result() for MulticoreFuture ... done
[11:00:01.074] - relayed: [n=2] TRUE, FALSE
[11:00:01.075] - queued futures: [n=2] TRUE, FALSE
[11:00:01.075] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[11:00:01.075]  length: 1 (resolved future 1)
[11:00:01.075] Future #2
[11:00:01.075] result() for MulticoreFuture ...
[11:00:01.076] result() for MulticoreFuture ...
[11:00:01.076] result() for MulticoreFuture ... done
[11:00:01.076] result() for MulticoreFuture ... done
[11:00:01.077] result() for MulticoreFuture ...
[11:00:01.077] result() for MulticoreFuture ... done
[11:00:01.077] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:00:01.077] - nx: 2
[11:00:01.077] - relay: TRUE
[11:00:01.077] - stdout: TRUE
[11:00:01.077] - signal: TRUE
[11:00:01.078] - resignal: FALSE
[11:00:01.078] - force: TRUE
[11:00:01.078] - relayed: [n=2] TRUE, FALSE
[11:00:01.078] - queued futures: [n=2] TRUE, FALSE
[11:00:01.078]  - until=2
[11:00:01.078]  - relaying element #2
[11:00:01.078] result() for MulticoreFuture ...
[11:00:01.078] result() for MulticoreFuture ... done
[11:00:01.079] result() for MulticoreFuture ...
[11:00:01.079] result() for MulticoreFuture ... done
[11:00:01.079] result() for MulticoreFuture ...
[11:00:01.079] result() for MulticoreFuture ... done
[11:00:01.079] result() for MulticoreFuture ...
[11:00:01.079] result() for MulticoreFuture ... done
[11:00:01.079] - relayed: [n=2] TRUE, TRUE
[11:00:01.079] - queued futures: [n=2] TRUE, TRUE
[11:00:01.079] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:00:01.080]  length: 0 (resolved future 2)
[11:00:01.080] Relaying remaining futures
[11:00:01.080] signalConditionsASAP(NULL, pos=0) ...
[11:00:01.080] - nx: 2
[11:00:01.080] - relay: TRUE
[11:00:01.080] - stdout: TRUE
[11:00:01.080] - signal: TRUE
[11:00:01.080] - resignal: FALSE
[11:00:01.080] - force: TRUE
[11:00:01.080] - relayed: [n=2] TRUE, TRUE
[11:00:01.081] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:01.081] - relayed: [n=2] TRUE, TRUE
[11:00:01.081] - queued futures: [n=2] TRUE, TRUE
[11:00:01.081] signalConditionsASAP(NULL, pos=0) ... done
[11:00:01.081] resolve() on list ... DONE
[11:00:01.081] result() for MulticoreFuture ...
[11:00:01.081] result() for MulticoreFuture ... done
[11:00:01.081] result() for MulticoreFuture ...
[11:00:01.081] result() for MulticoreFuture ... done
[11:00:01.082] result() for MulticoreFuture ...
[11:00:01.082] result() for MulticoreFuture ... done
[11:00:01.082] result() for MulticoreFuture ...
[11:00:01.082] result() for MulticoreFuture ... done
[11:00:01.082]  - Number of value chunks collected: 2
[11:00:01.082] Resolving 2 futures (chunks) ... DONE
[11:00:01.082] Reducing values from 2 chunks ...
[11:00:01.082]  - Number of values collected after concatenation: 2
[11:00:01.082]  - Number of values expected: 2
[11:00:01.083] Reducing values from 2 chunks ... DONE
[11:00:01.083] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[11:00:01.084] future_lapply() ...
[11:00:01.091] Number of chunks: 2
[11:00:01.091] getGlobalsAndPackagesXApply() ...
[11:00:01.091]  - future.globals: TRUE
[11:00:01.091] getGlobalsAndPackages() ...
[11:00:01.091] Searching for globals...
[11:00:01.096] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[11:00:01.096] Searching for globals ... DONE
[11:00:01.096] Resolving globals: FALSE
[11:00:01.097] The total size of the 7 globals is 12.77 KiB (13081 bytes)
[11:00:01.098] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.77 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:01.098] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:01.098] - packages: [1] ‘future.apply’
[11:00:01.098] getGlobalsAndPackages() ... DONE
[11:00:01.098]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:01.098]  - needed namespaces: [n=1] ‘future.apply’
[11:00:01.098] Finding globals ... DONE
[11:00:01.098]  - use_args: TRUE
[11:00:01.099]  - Getting '...' globals ...
[11:00:01.099] resolve() on list ...
[11:00:01.099]  recursive: 0
[11:00:01.099]  length: 1
[11:00:01.099]  elements: ‘...’
[11:00:01.099]  length: 0 (resolved future 1)
[11:00:01.099] resolve() on list ... DONE
[11:00:01.100]    - '...' content: [n=0] 
[11:00:01.100] List of 1
[11:00:01.100]  $ ...: list()
[11:00:01.100]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.100]  - attr(*, "where")=List of 1
[11:00:01.100]   ..$ ...:<environment: 0x55bbad769b48> 
[11:00:01.100]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.100]  - attr(*, "resolved")= logi TRUE
[11:00:01.100]  - attr(*, "total_size")= num NA
[11:00:01.102]  - Getting '...' globals ... DONE
[11:00:01.102] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:01.102] List of 8
[11:00:01.102]  $ ...future.FUN:function (x, ...)  
[11:00:01.102]  $ x_FUN        :function (x)  
[11:00:01.102]  $ times        : int 0
[11:00:01.102]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.102]  $ stop_if_not  :function (...)  
[11:00:01.102]  $ dim          : NULL
[11:00:01.102]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:01.102]  $ ...          : list()
[11:00:01.102]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.102]  - attr(*, "where")=List of 8
[11:00:01.102]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:01.102]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:01.102]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:01.102]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:01.102]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:01.102]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:01.102]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:01.102]   ..$ ...          :<environment: 0x55bbad769b48> 
[11:00:01.102]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.102]  - attr(*, "resolved")= logi FALSE
[11:00:01.102]  - attr(*, "total_size")= num 23490
[11:00:01.108] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:01.108] getGlobalsAndPackagesXApply() ... DONE
[11:00:01.108] Number of futures (= number of chunks): 2
[11:00:01.108] Launching 2 futures (chunks) ...
[11:00:01.108] Chunk #1 of 2 ...
[11:00:01.109]  - Finding globals in 'X' for chunk #1 ...
[11:00:01.109] getGlobalsAndPackages() ...
[11:00:01.109] Searching for globals...
[11:00:01.109] 
[11:00:01.109] Searching for globals ... DONE
[11:00:01.109] - globals: [0] <none>
[11:00:01.109] getGlobalsAndPackages() ... DONE
[11:00:01.109]    + additional globals found: [n=0] 
[11:00:01.109]    + additional namespaces needed: [n=0] 
[11:00:01.109]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:01.110]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:01.110]  - seeds: <none>
[11:00:01.110]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.110] getGlobalsAndPackages() ...
[11:00:01.110] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.110] Resolving globals: FALSE
[11:00:01.110] Tweak future expression to call with '...' arguments ...
[11:00:01.110] {
[11:00:01.110]     do.call(function(...) {
[11:00:01.110]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.110]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.110]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.110]             on.exit(options(oopts), add = TRUE)
[11:00:01.110]         }
[11:00:01.110]         {
[11:00:01.110]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.110]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.110]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.110]             })
[11:00:01.110]         }
[11:00:01.110]     }, args = future.call.arguments)
[11:00:01.110] }
[11:00:01.111] Tweak future expression to call with '...' arguments ... DONE
[11:00:01.113] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.113] - packages: [1] ‘future.apply’
[11:00:01.113] getGlobalsAndPackages() ... DONE
[11:00:01.113] run() for ‘Future’ ...
[11:00:01.114] - state: ‘created’
[11:00:01.114] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:01.116] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.116] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:01.116]   - Field: ‘label’
[11:00:01.116]   - Field: ‘local’
[11:00:01.116]   - Field: ‘owner’
[11:00:01.116]   - Field: ‘envir’
[11:00:01.116]   - Field: ‘workers’
[11:00:01.117]   - Field: ‘packages’
[11:00:01.117]   - Field: ‘gc’
[11:00:01.117]   - Field: ‘job’
[11:00:01.117]   - Field: ‘conditions’
[11:00:01.117]   - Field: ‘expr’
[11:00:01.117]   - Field: ‘uuid’
[11:00:01.117]   - Field: ‘seed’
[11:00:01.117]   - Field: ‘version’
[11:00:01.117]   - Field: ‘result’
[11:00:01.118]   - Field: ‘asynchronous’
[11:00:01.118]   - Field: ‘calls’
[11:00:01.118]   - Field: ‘globals’
[11:00:01.118]   - Field: ‘stdout’
[11:00:01.118]   - Field: ‘earlySignal’
[11:00:01.118]   - Field: ‘lazy’
[11:00:01.118]   - Field: ‘state’
[11:00:01.118] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:01.118] - Launch lazy future ...
[11:00:01.119] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:01.119] Packages needed by future strategies (n = 0): <none>
[11:00:01.119] {
[11:00:01.119]     {
[11:00:01.119]         {
[11:00:01.119]             ...future.startTime <- base::Sys.time()
[11:00:01.119]             {
[11:00:01.119]                 {
[11:00:01.119]                   {
[11:00:01.119]                     {
[11:00:01.119]                       {
[11:00:01.119]                         base::local({
[11:00:01.119]                           has_future <- base::requireNamespace("future", 
[11:00:01.119]                             quietly = TRUE)
[11:00:01.119]                           if (has_future) {
[11:00:01.119]                             ns <- base::getNamespace("future")
[11:00:01.119]                             version <- ns[[".package"]][["version"]]
[11:00:01.119]                             if (is.null(version)) 
[11:00:01.119]                               version <- utils::packageVersion("future")
[11:00:01.119]                           }
[11:00:01.119]                           else {
[11:00:01.119]                             version <- NULL
[11:00:01.119]                           }
[11:00:01.119]                           if (!has_future || version < "1.8.0") {
[11:00:01.119]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:01.119]                               "", base::R.version$version.string), 
[11:00:01.119]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:01.119]                                 base::R.version$platform, 8 * 
[11:00:01.119]                                   base::.Machine$sizeof.pointer), 
[11:00:01.119]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:01.119]                                 "release", "version")], collapse = " "), 
[11:00:01.119]                               hostname = base::Sys.info()[["nodename"]])
[11:00:01.119]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:01.119]                               info)
[11:00:01.119]                             info <- base::paste(info, collapse = "; ")
[11:00:01.119]                             if (!has_future) {
[11:00:01.119]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:01.119]                                 info)
[11:00:01.119]                             }
[11:00:01.119]                             else {
[11:00:01.119]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:01.119]                                 info, version)
[11:00:01.119]                             }
[11:00:01.119]                             base::stop(msg)
[11:00:01.119]                           }
[11:00:01.119]                         })
[11:00:01.119]                       }
[11:00:01.119]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:01.119]                       base::options(mc.cores = 1L)
[11:00:01.119]                     }
[11:00:01.119]                     base::local({
[11:00:01.119]                       for (pkg in "future.apply") {
[11:00:01.119]                         base::loadNamespace(pkg)
[11:00:01.119]                         base::library(pkg, character.only = TRUE)
[11:00:01.119]                       }
[11:00:01.119]                     })
[11:00:01.119]                   }
[11:00:01.119]                   ...future.strategy.old <- future::plan("list")
[11:00:01.119]                   options(future.plan = NULL)
[11:00:01.119]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.119]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:01.119]                 }
[11:00:01.119]                 ...future.workdir <- getwd()
[11:00:01.119]             }
[11:00:01.119]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:01.119]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:01.119]         }
[11:00:01.119]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:01.119]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:01.119]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:01.119]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:01.119]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:01.119]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:01.119]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:01.119]             base::names(...future.oldOptions))
[11:00:01.119]     }
[11:00:01.119]     if (FALSE) {
[11:00:01.119]     }
[11:00:01.119]     else {
[11:00:01.119]         if (TRUE) {
[11:00:01.119]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:01.119]                 open = "w")
[11:00:01.119]         }
[11:00:01.119]         else {
[11:00:01.119]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:01.119]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:01.119]         }
[11:00:01.119]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:01.119]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:01.119]             base::sink(type = "output", split = FALSE)
[11:00:01.119]             base::close(...future.stdout)
[11:00:01.119]         }, add = TRUE)
[11:00:01.119]     }
[11:00:01.119]     ...future.frame <- base::sys.nframe()
[11:00:01.119]     ...future.conditions <- base::list()
[11:00:01.119]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:01.119]     if (FALSE) {
[11:00:01.119]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:01.119]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:01.119]     }
[11:00:01.119]     ...future.result <- base::tryCatch({
[11:00:01.119]         base::withCallingHandlers({
[11:00:01.119]             ...future.value <- base::withVisible(base::local({
[11:00:01.119]                 withCallingHandlers({
[11:00:01.119]                   {
[11:00:01.119]                     do.call(function(...) {
[11:00:01.119]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.119]                       if (!identical(...future.globals.maxSize.org, 
[11:00:01.119]                         ...future.globals.maxSize)) {
[11:00:01.119]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.119]                         on.exit(options(oopts), add = TRUE)
[11:00:01.119]                       }
[11:00:01.119]                       {
[11:00:01.119]                         lapply(seq_along(...future.elements_ii), 
[11:00:01.119]                           FUN = function(jj) {
[11:00:01.119]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.119]                             ...future.FUN(...future.X_jj, ...)
[11:00:01.119]                           })
[11:00:01.119]                       }
[11:00:01.119]                     }, args = future.call.arguments)
[11:00:01.119]                   }
[11:00:01.119]                 }, immediateCondition = function(cond) {
[11:00:01.119]                   save_rds <- function (object, pathname, ...) 
[11:00:01.119]                   {
[11:00:01.119]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:01.119]                     if (file_test("-f", pathname_tmp)) {
[11:00:01.119]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.119]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:01.119]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.119]                         fi_tmp[["mtime"]])
[11:00:01.119]                     }
[11:00:01.119]                     tryCatch({
[11:00:01.119]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:01.119]                     }, error = function(ex) {
[11:00:01.119]                       msg <- conditionMessage(ex)
[11:00:01.119]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.119]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:01.119]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.119]                         fi_tmp[["mtime"]], msg)
[11:00:01.119]                       ex$message <- msg
[11:00:01.119]                       stop(ex)
[11:00:01.119]                     })
[11:00:01.119]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:01.119]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:01.119]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:01.119]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.119]                       fi <- file.info(pathname)
[11:00:01.119]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:01.119]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.119]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:01.119]                         fi[["size"]], fi[["mtime"]])
[11:00:01.119]                       stop(msg)
[11:00:01.119]                     }
[11:00:01.119]                     invisible(pathname)
[11:00:01.119]                   }
[11:00:01.119]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:01.119]                     rootPath = tempdir()) 
[11:00:01.119]                   {
[11:00:01.119]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:01.119]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:01.119]                       tmpdir = path, fileext = ".rds")
[11:00:01.119]                     save_rds(obj, file)
[11:00:01.119]                   }
[11:00:01.119]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:01.119]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.119]                   {
[11:00:01.119]                     inherits <- base::inherits
[11:00:01.119]                     invokeRestart <- base::invokeRestart
[11:00:01.119]                     is.null <- base::is.null
[11:00:01.119]                     muffled <- FALSE
[11:00:01.119]                     if (inherits(cond, "message")) {
[11:00:01.119]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:01.119]                       if (muffled) 
[11:00:01.119]                         invokeRestart("muffleMessage")
[11:00:01.119]                     }
[11:00:01.119]                     else if (inherits(cond, "warning")) {
[11:00:01.119]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:01.119]                       if (muffled) 
[11:00:01.119]                         invokeRestart("muffleWarning")
[11:00:01.119]                     }
[11:00:01.119]                     else if (inherits(cond, "condition")) {
[11:00:01.119]                       if (!is.null(pattern)) {
[11:00:01.119]                         computeRestarts <- base::computeRestarts
[11:00:01.119]                         grepl <- base::grepl
[11:00:01.119]                         restarts <- computeRestarts(cond)
[11:00:01.119]                         for (restart in restarts) {
[11:00:01.119]                           name <- restart$name
[11:00:01.119]                           if (is.null(name)) 
[11:00:01.119]                             next
[11:00:01.119]                           if (!grepl(pattern, name)) 
[11:00:01.119]                             next
[11:00:01.119]                           invokeRestart(restart)
[11:00:01.119]                           muffled <- TRUE
[11:00:01.119]                           break
[11:00:01.119]                         }
[11:00:01.119]                       }
[11:00:01.119]                     }
[11:00:01.119]                     invisible(muffled)
[11:00:01.119]                   }
[11:00:01.119]                   muffleCondition(cond)
[11:00:01.119]                 })
[11:00:01.119]             }))
[11:00:01.119]             future::FutureResult(value = ...future.value$value, 
[11:00:01.119]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.119]                   ...future.rng), globalenv = if (FALSE) 
[11:00:01.119]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:01.119]                     ...future.globalenv.names))
[11:00:01.119]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:01.119]         }, condition = base::local({
[11:00:01.119]             c <- base::c
[11:00:01.119]             inherits <- base::inherits
[11:00:01.119]             invokeRestart <- base::invokeRestart
[11:00:01.119]             length <- base::length
[11:00:01.119]             list <- base::list
[11:00:01.119]             seq.int <- base::seq.int
[11:00:01.119]             signalCondition <- base::signalCondition
[11:00:01.119]             sys.calls <- base::sys.calls
[11:00:01.119]             `[[` <- base::`[[`
[11:00:01.119]             `+` <- base::`+`
[11:00:01.119]             `<<-` <- base::`<<-`
[11:00:01.119]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:01.119]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:01.119]                   3L)]
[11:00:01.119]             }
[11:00:01.119]             function(cond) {
[11:00:01.119]                 is_error <- inherits(cond, "error")
[11:00:01.119]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:01.119]                   NULL)
[11:00:01.119]                 if (is_error) {
[11:00:01.119]                   sessionInformation <- function() {
[11:00:01.119]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:01.119]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:01.119]                       search = base::search(), system = base::Sys.info())
[11:00:01.119]                   }
[11:00:01.119]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.119]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:01.119]                     cond$call), session = sessionInformation(), 
[11:00:01.119]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:01.119]                   signalCondition(cond)
[11:00:01.119]                 }
[11:00:01.119]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:01.119]                 "immediateCondition"))) {
[11:00:01.119]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:01.119]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.119]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:01.119]                   if (TRUE && !signal) {
[11:00:01.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.119]                     {
[11:00:01.119]                       inherits <- base::inherits
[11:00:01.119]                       invokeRestart <- base::invokeRestart
[11:00:01.119]                       is.null <- base::is.null
[11:00:01.119]                       muffled <- FALSE
[11:00:01.119]                       if (inherits(cond, "message")) {
[11:00:01.119]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.119]                         if (muffled) 
[11:00:01.119]                           invokeRestart("muffleMessage")
[11:00:01.119]                       }
[11:00:01.119]                       else if (inherits(cond, "warning")) {
[11:00:01.119]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.119]                         if (muffled) 
[11:00:01.119]                           invokeRestart("muffleWarning")
[11:00:01.119]                       }
[11:00:01.119]                       else if (inherits(cond, "condition")) {
[11:00:01.119]                         if (!is.null(pattern)) {
[11:00:01.119]                           computeRestarts <- base::computeRestarts
[11:00:01.119]                           grepl <- base::grepl
[11:00:01.119]                           restarts <- computeRestarts(cond)
[11:00:01.119]                           for (restart in restarts) {
[11:00:01.119]                             name <- restart$name
[11:00:01.119]                             if (is.null(name)) 
[11:00:01.119]                               next
[11:00:01.119]                             if (!grepl(pattern, name)) 
[11:00:01.119]                               next
[11:00:01.119]                             invokeRestart(restart)
[11:00:01.119]                             muffled <- TRUE
[11:00:01.119]                             break
[11:00:01.119]                           }
[11:00:01.119]                         }
[11:00:01.119]                       }
[11:00:01.119]                       invisible(muffled)
[11:00:01.119]                     }
[11:00:01.119]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.119]                   }
[11:00:01.119]                 }
[11:00:01.119]                 else {
[11:00:01.119]                   if (TRUE) {
[11:00:01.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.119]                     {
[11:00:01.119]                       inherits <- base::inherits
[11:00:01.119]                       invokeRestart <- base::invokeRestart
[11:00:01.119]                       is.null <- base::is.null
[11:00:01.119]                       muffled <- FALSE
[11:00:01.119]                       if (inherits(cond, "message")) {
[11:00:01.119]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.119]                         if (muffled) 
[11:00:01.119]                           invokeRestart("muffleMessage")
[11:00:01.119]                       }
[11:00:01.119]                       else if (inherits(cond, "warning")) {
[11:00:01.119]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.119]                         if (muffled) 
[11:00:01.119]                           invokeRestart("muffleWarning")
[11:00:01.119]                       }
[11:00:01.119]                       else if (inherits(cond, "condition")) {
[11:00:01.119]                         if (!is.null(pattern)) {
[11:00:01.119]                           computeRestarts <- base::computeRestarts
[11:00:01.119]                           grepl <- base::grepl
[11:00:01.119]                           restarts <- computeRestarts(cond)
[11:00:01.119]                           for (restart in restarts) {
[11:00:01.119]                             name <- restart$name
[11:00:01.119]                             if (is.null(name)) 
[11:00:01.119]                               next
[11:00:01.119]                             if (!grepl(pattern, name)) 
[11:00:01.119]                               next
[11:00:01.119]                             invokeRestart(restart)
[11:00:01.119]                             muffled <- TRUE
[11:00:01.119]                             break
[11:00:01.119]                           }
[11:00:01.119]                         }
[11:00:01.119]                       }
[11:00:01.119]                       invisible(muffled)
[11:00:01.119]                     }
[11:00:01.119]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.119]                   }
[11:00:01.119]                 }
[11:00:01.119]             }
[11:00:01.119]         }))
[11:00:01.119]     }, error = function(ex) {
[11:00:01.119]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:01.119]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.119]                 ...future.rng), started = ...future.startTime, 
[11:00:01.119]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:01.119]             version = "1.8"), class = "FutureResult")
[11:00:01.119]     }, finally = {
[11:00:01.119]         if (!identical(...future.workdir, getwd())) 
[11:00:01.119]             setwd(...future.workdir)
[11:00:01.119]         {
[11:00:01.119]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:01.119]                 ...future.oldOptions$nwarnings <- NULL
[11:00:01.119]             }
[11:00:01.119]             base::options(...future.oldOptions)
[11:00:01.119]             if (.Platform$OS.type == "windows") {
[11:00:01.119]                 old_names <- names(...future.oldEnvVars)
[11:00:01.119]                 envs <- base::Sys.getenv()
[11:00:01.119]                 names <- names(envs)
[11:00:01.119]                 common <- intersect(names, old_names)
[11:00:01.119]                 added <- setdiff(names, old_names)
[11:00:01.119]                 removed <- setdiff(old_names, names)
[11:00:01.119]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:01.119]                   envs[common]]
[11:00:01.119]                 NAMES <- toupper(changed)
[11:00:01.119]                 args <- list()
[11:00:01.119]                 for (kk in seq_along(NAMES)) {
[11:00:01.119]                   name <- changed[[kk]]
[11:00:01.119]                   NAME <- NAMES[[kk]]
[11:00:01.119]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.119]                     next
[11:00:01.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.119]                 }
[11:00:01.119]                 NAMES <- toupper(added)
[11:00:01.119]                 for (kk in seq_along(NAMES)) {
[11:00:01.119]                   name <- added[[kk]]
[11:00:01.119]                   NAME <- NAMES[[kk]]
[11:00:01.119]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.119]                     next
[11:00:01.119]                   args[[name]] <- ""
[11:00:01.119]                 }
[11:00:01.119]                 NAMES <- toupper(removed)
[11:00:01.119]                 for (kk in seq_along(NAMES)) {
[11:00:01.119]                   name <- removed[[kk]]
[11:00:01.119]                   NAME <- NAMES[[kk]]
[11:00:01.119]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.119]                     next
[11:00:01.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.119]                 }
[11:00:01.119]                 if (length(args) > 0) 
[11:00:01.119]                   base::do.call(base::Sys.setenv, args = args)
[11:00:01.119]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:01.119]             }
[11:00:01.119]             else {
[11:00:01.119]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:01.119]             }
[11:00:01.119]             {
[11:00:01.119]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:01.119]                   0L) {
[11:00:01.119]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:01.119]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:01.119]                   base::options(opts)
[11:00:01.119]                 }
[11:00:01.119]                 {
[11:00:01.119]                   {
[11:00:01.119]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:01.119]                     NULL
[11:00:01.119]                   }
[11:00:01.119]                   options(future.plan = NULL)
[11:00:01.119]                   if (is.na(NA_character_)) 
[11:00:01.119]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.119]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:01.119]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:01.119]                     .init = FALSE)
[11:00:01.119]                 }
[11:00:01.119]             }
[11:00:01.119]         }
[11:00:01.119]     })
[11:00:01.119]     if (TRUE) {
[11:00:01.119]         base::sink(type = "output", split = FALSE)
[11:00:01.119]         if (TRUE) {
[11:00:01.119]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:01.119]         }
[11:00:01.119]         else {
[11:00:01.119]             ...future.result["stdout"] <- base::list(NULL)
[11:00:01.119]         }
[11:00:01.119]         base::close(...future.stdout)
[11:00:01.119]         ...future.stdout <- NULL
[11:00:01.119]     }
[11:00:01.119]     ...future.result$conditions <- ...future.conditions
[11:00:01.119]     ...future.result$finished <- base::Sys.time()
[11:00:01.119]     ...future.result
[11:00:01.119] }
[11:00:01.122] assign_globals() ...
[11:00:01.122] List of 11
[11:00:01.122]  $ ...future.FUN            :function (x, ...)  
[11:00:01.122]  $ x_FUN                    :function (x)  
[11:00:01.122]  $ times                    : int 0
[11:00:01.122]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.122]  $ stop_if_not              :function (...)  
[11:00:01.122]  $ dim                      : NULL
[11:00:01.122]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:01.122]  $ future.call.arguments    : list()
[11:00:01.122]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.122]  $ ...future.elements_ii    :List of 5
[11:00:01.122]   ..$ : int 1
[11:00:01.122]   ..$ : int 2
[11:00:01.122]   ..$ : int 3
[11:00:01.122]   ..$ : int 4
[11:00:01.122]   ..$ : int 5
[11:00:01.122]  $ ...future.seeds_ii       : NULL
[11:00:01.122]  $ ...future.globals.maxSize: NULL
[11:00:01.122]  - attr(*, "where")=List of 11
[11:00:01.122]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:01.122]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:01.122]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:01.122]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:01.122]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:01.122]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:01.122]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:01.122]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:01.122]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:01.122]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:01.122]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:01.122]  - attr(*, "resolved")= logi FALSE
[11:00:01.122]  - attr(*, "total_size")= num 23490
[11:00:01.122]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.122]  - attr(*, "already-done")= logi TRUE
[11:00:01.130] - copied ‘...future.FUN’ to environment
[11:00:01.130] - reassign environment for ‘x_FUN’
[11:00:01.130] - copied ‘x_FUN’ to environment
[11:00:01.130] - copied ‘times’ to environment
[11:00:01.131] - copied ‘stopf’ to environment
[11:00:01.131] - copied ‘stop_if_not’ to environment
[11:00:01.131] - copied ‘dim’ to environment
[11:00:01.131] - copied ‘valid_types’ to environment
[11:00:01.131] - copied ‘future.call.arguments’ to environment
[11:00:01.131] - copied ‘...future.elements_ii’ to environment
[11:00:01.131] - copied ‘...future.seeds_ii’ to environment
[11:00:01.131] - copied ‘...future.globals.maxSize’ to environment
[11:00:01.131] assign_globals() ... done
[11:00:01.131] requestCore(): workers = 2
[11:00:01.134] MulticoreFuture started
[11:00:01.134] - Launch lazy future ... done
[11:00:01.134] run() for ‘MulticoreFuture’ ... done
[11:00:01.134] Created future:
[11:00:01.135] plan(): Setting new future strategy stack:
[11:00:01.135] List of future strategies:
[11:00:01.135] 1. sequential:
[11:00:01.135]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:01.135]    - tweaked: FALSE
[11:00:01.135]    - call: NULL
[11:00:01.136] plan(): nbrOfWorkers() = 1
[11:00:01.138] plan(): Setting new future strategy stack:
[11:00:01.138] List of future strategies:
[11:00:01.138] 1. multicore:
[11:00:01.138]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:01.138]    - tweaked: FALSE
[11:00:01.138]    - call: plan(strategy)
[11:00:01.141] plan(): nbrOfWorkers() = 2
[11:00:01.135] MulticoreFuture:
[11:00:01.135] Label: ‘future_vapply-1’
[11:00:01.135] Expression:
[11:00:01.135] {
[11:00:01.135]     do.call(function(...) {
[11:00:01.135]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.135]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.135]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.135]             on.exit(options(oopts), add = TRUE)
[11:00:01.135]         }
[11:00:01.135]         {
[11:00:01.135]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.135]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.135]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.135]             })
[11:00:01.135]         }
[11:00:01.135]     }, args = future.call.arguments)
[11:00:01.135] }
[11:00:01.135] Lazy evaluation: FALSE
[11:00:01.135] Asynchronous evaluation: TRUE
[11:00:01.135] Local evaluation: TRUE
[11:00:01.135] Environment: R_GlobalEnv
[11:00:01.135] Capture standard output: TRUE
[11:00:01.135] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:01.135] Globals: 11 objects totaling 13.01 KiB (function ‘...future.FUN’ of 4.50 KiB, function ‘x_FUN’ of 295 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:01.135] Packages: 1 packages (‘future.apply’)
[11:00:01.135] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:01.135] Resolved: TRUE
[11:00:01.135] Value: <not collected>
[11:00:01.135] Conditions captured: <none>
[11:00:01.135] Early signaling: FALSE
[11:00:01.135] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:01.135] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.142] Chunk #1 of 2 ... DONE
[11:00:01.142] Chunk #2 of 2 ...
[11:00:01.143]  - Finding globals in 'X' for chunk #2 ...
[11:00:01.143] getGlobalsAndPackages() ...
[11:00:01.143] Searching for globals...
[11:00:01.143] 
[11:00:01.144] Searching for globals ... DONE
[11:00:01.144] - globals: [0] <none>
[11:00:01.144] getGlobalsAndPackages() ... DONE
[11:00:01.144]    + additional globals found: [n=0] 
[11:00:01.144]    + additional namespaces needed: [n=0] 
[11:00:01.144]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:01.144]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:01.144]  - seeds: <none>
[11:00:01.145]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.145] getGlobalsAndPackages() ...
[11:00:01.145] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.145] Resolving globals: FALSE
[11:00:01.145] Tweak future expression to call with '...' arguments ...
[11:00:01.146] {
[11:00:01.146]     do.call(function(...) {
[11:00:01.146]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.146]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.146]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.146]             on.exit(options(oopts), add = TRUE)
[11:00:01.146]         }
[11:00:01.146]         {
[11:00:01.146]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.146]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.146]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.146]             })
[11:00:01.146]         }
[11:00:01.146]     }, args = future.call.arguments)
[11:00:01.146] }
[11:00:01.146] Tweak future expression to call with '...' arguments ... DONE
[11:00:01.147] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.147] - packages: [1] ‘future.apply’
[11:00:01.147] getGlobalsAndPackages() ... DONE
[11:00:01.151] run() for ‘Future’ ...
[11:00:01.152] - state: ‘created’
[11:00:01.152] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:01.156] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.156] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:01.157]   - Field: ‘label’
[11:00:01.157]   - Field: ‘local’
[11:00:01.157]   - Field: ‘owner’
[11:00:01.157]   - Field: ‘envir’
[11:00:01.158]   - Field: ‘workers’
[11:00:01.158]   - Field: ‘packages’
[11:00:01.158]   - Field: ‘gc’
[11:00:01.158]   - Field: ‘job’
[11:00:01.158]   - Field: ‘conditions’
[11:00:01.159]   - Field: ‘expr’
[11:00:01.159]   - Field: ‘uuid’
[11:00:01.159]   - Field: ‘seed’
[11:00:01.159]   - Field: ‘version’
[11:00:01.159]   - Field: ‘result’
[11:00:01.160]   - Field: ‘asynchronous’
[11:00:01.160]   - Field: ‘calls’
[11:00:01.160]   - Field: ‘globals’
[11:00:01.160]   - Field: ‘stdout’
[11:00:01.160]   - Field: ‘earlySignal’
[11:00:01.161]   - Field: ‘lazy’
[11:00:01.161]   - Field: ‘state’
[11:00:01.161] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:01.161] - Launch lazy future ...
[11:00:01.161] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:01.162] Packages needed by future strategies (n = 0): <none>
[11:00:01.162] {
[11:00:01.162]     {
[11:00:01.162]         {
[11:00:01.162]             ...future.startTime <- base::Sys.time()
[11:00:01.162]             {
[11:00:01.162]                 {
[11:00:01.162]                   {
[11:00:01.162]                     {
[11:00:01.162]                       {
[11:00:01.162]                         base::local({
[11:00:01.162]                           has_future <- base::requireNamespace("future", 
[11:00:01.162]                             quietly = TRUE)
[11:00:01.162]                           if (has_future) {
[11:00:01.162]                             ns <- base::getNamespace("future")
[11:00:01.162]                             version <- ns[[".package"]][["version"]]
[11:00:01.162]                             if (is.null(version)) 
[11:00:01.162]                               version <- utils::packageVersion("future")
[11:00:01.162]                           }
[11:00:01.162]                           else {
[11:00:01.162]                             version <- NULL
[11:00:01.162]                           }
[11:00:01.162]                           if (!has_future || version < "1.8.0") {
[11:00:01.162]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:01.162]                               "", base::R.version$version.string), 
[11:00:01.162]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:01.162]                                 base::R.version$platform, 8 * 
[11:00:01.162]                                   base::.Machine$sizeof.pointer), 
[11:00:01.162]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:01.162]                                 "release", "version")], collapse = " "), 
[11:00:01.162]                               hostname = base::Sys.info()[["nodename"]])
[11:00:01.162]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:01.162]                               info)
[11:00:01.162]                             info <- base::paste(info, collapse = "; ")
[11:00:01.162]                             if (!has_future) {
[11:00:01.162]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:01.162]                                 info)
[11:00:01.162]                             }
[11:00:01.162]                             else {
[11:00:01.162]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:01.162]                                 info, version)
[11:00:01.162]                             }
[11:00:01.162]                             base::stop(msg)
[11:00:01.162]                           }
[11:00:01.162]                         })
[11:00:01.162]                       }
[11:00:01.162]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:01.162]                       base::options(mc.cores = 1L)
[11:00:01.162]                     }
[11:00:01.162]                     base::local({
[11:00:01.162]                       for (pkg in "future.apply") {
[11:00:01.162]                         base::loadNamespace(pkg)
[11:00:01.162]                         base::library(pkg, character.only = TRUE)
[11:00:01.162]                       }
[11:00:01.162]                     })
[11:00:01.162]                   }
[11:00:01.162]                   ...future.strategy.old <- future::plan("list")
[11:00:01.162]                   options(future.plan = NULL)
[11:00:01.162]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.162]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:01.162]                 }
[11:00:01.162]                 ...future.workdir <- getwd()
[11:00:01.162]             }
[11:00:01.162]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:01.162]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:01.162]         }
[11:00:01.162]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:01.162]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:01.162]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:01.162]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:01.162]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:01.162]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:01.162]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:01.162]             base::names(...future.oldOptions))
[11:00:01.162]     }
[11:00:01.162]     if (FALSE) {
[11:00:01.162]     }
[11:00:01.162]     else {
[11:00:01.162]         if (TRUE) {
[11:00:01.162]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:01.162]                 open = "w")
[11:00:01.162]         }
[11:00:01.162]         else {
[11:00:01.162]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:01.162]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:01.162]         }
[11:00:01.162]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:01.162]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:01.162]             base::sink(type = "output", split = FALSE)
[11:00:01.162]             base::close(...future.stdout)
[11:00:01.162]         }, add = TRUE)
[11:00:01.162]     }
[11:00:01.162]     ...future.frame <- base::sys.nframe()
[11:00:01.162]     ...future.conditions <- base::list()
[11:00:01.162]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:01.162]     if (FALSE) {
[11:00:01.162]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:01.162]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:01.162]     }
[11:00:01.162]     ...future.result <- base::tryCatch({
[11:00:01.162]         base::withCallingHandlers({
[11:00:01.162]             ...future.value <- base::withVisible(base::local({
[11:00:01.162]                 withCallingHandlers({
[11:00:01.162]                   {
[11:00:01.162]                     do.call(function(...) {
[11:00:01.162]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.162]                       if (!identical(...future.globals.maxSize.org, 
[11:00:01.162]                         ...future.globals.maxSize)) {
[11:00:01.162]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.162]                         on.exit(options(oopts), add = TRUE)
[11:00:01.162]                       }
[11:00:01.162]                       {
[11:00:01.162]                         lapply(seq_along(...future.elements_ii), 
[11:00:01.162]                           FUN = function(jj) {
[11:00:01.162]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.162]                             ...future.FUN(...future.X_jj, ...)
[11:00:01.162]                           })
[11:00:01.162]                       }
[11:00:01.162]                     }, args = future.call.arguments)
[11:00:01.162]                   }
[11:00:01.162]                 }, immediateCondition = function(cond) {
[11:00:01.162]                   save_rds <- function (object, pathname, ...) 
[11:00:01.162]                   {
[11:00:01.162]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:01.162]                     if (file_test("-f", pathname_tmp)) {
[11:00:01.162]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.162]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:01.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.162]                         fi_tmp[["mtime"]])
[11:00:01.162]                     }
[11:00:01.162]                     tryCatch({
[11:00:01.162]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:01.162]                     }, error = function(ex) {
[11:00:01.162]                       msg <- conditionMessage(ex)
[11:00:01.162]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.162]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:01.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.162]                         fi_tmp[["mtime"]], msg)
[11:00:01.162]                       ex$message <- msg
[11:00:01.162]                       stop(ex)
[11:00:01.162]                     })
[11:00:01.162]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:01.162]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:01.162]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:01.162]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.162]                       fi <- file.info(pathname)
[11:00:01.162]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:01.162]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.162]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:01.162]                         fi[["size"]], fi[["mtime"]])
[11:00:01.162]                       stop(msg)
[11:00:01.162]                     }
[11:00:01.162]                     invisible(pathname)
[11:00:01.162]                   }
[11:00:01.162]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:01.162]                     rootPath = tempdir()) 
[11:00:01.162]                   {
[11:00:01.162]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:01.162]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:01.162]                       tmpdir = path, fileext = ".rds")
[11:00:01.162]                     save_rds(obj, file)
[11:00:01.162]                   }
[11:00:01.162]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:01.162]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.162]                   {
[11:00:01.162]                     inherits <- base::inherits
[11:00:01.162]                     invokeRestart <- base::invokeRestart
[11:00:01.162]                     is.null <- base::is.null
[11:00:01.162]                     muffled <- FALSE
[11:00:01.162]                     if (inherits(cond, "message")) {
[11:00:01.162]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:01.162]                       if (muffled) 
[11:00:01.162]                         invokeRestart("muffleMessage")
[11:00:01.162]                     }
[11:00:01.162]                     else if (inherits(cond, "warning")) {
[11:00:01.162]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:01.162]                       if (muffled) 
[11:00:01.162]                         invokeRestart("muffleWarning")
[11:00:01.162]                     }
[11:00:01.162]                     else if (inherits(cond, "condition")) {
[11:00:01.162]                       if (!is.null(pattern)) {
[11:00:01.162]                         computeRestarts <- base::computeRestarts
[11:00:01.162]                         grepl <- base::grepl
[11:00:01.162]                         restarts <- computeRestarts(cond)
[11:00:01.162]                         for (restart in restarts) {
[11:00:01.162]                           name <- restart$name
[11:00:01.162]                           if (is.null(name)) 
[11:00:01.162]                             next
[11:00:01.162]                           if (!grepl(pattern, name)) 
[11:00:01.162]                             next
[11:00:01.162]                           invokeRestart(restart)
[11:00:01.162]                           muffled <- TRUE
[11:00:01.162]                           break
[11:00:01.162]                         }
[11:00:01.162]                       }
[11:00:01.162]                     }
[11:00:01.162]                     invisible(muffled)
[11:00:01.162]                   }
[11:00:01.162]                   muffleCondition(cond)
[11:00:01.162]                 })
[11:00:01.162]             }))
[11:00:01.162]             future::FutureResult(value = ...future.value$value, 
[11:00:01.162]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.162]                   ...future.rng), globalenv = if (FALSE) 
[11:00:01.162]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:01.162]                     ...future.globalenv.names))
[11:00:01.162]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:01.162]         }, condition = base::local({
[11:00:01.162]             c <- base::c
[11:00:01.162]             inherits <- base::inherits
[11:00:01.162]             invokeRestart <- base::invokeRestart
[11:00:01.162]             length <- base::length
[11:00:01.162]             list <- base::list
[11:00:01.162]             seq.int <- base::seq.int
[11:00:01.162]             signalCondition <- base::signalCondition
[11:00:01.162]             sys.calls <- base::sys.calls
[11:00:01.162]             `[[` <- base::`[[`
[11:00:01.162]             `+` <- base::`+`
[11:00:01.162]             `<<-` <- base::`<<-`
[11:00:01.162]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:01.162]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:01.162]                   3L)]
[11:00:01.162]             }
[11:00:01.162]             function(cond) {
[11:00:01.162]                 is_error <- inherits(cond, "error")
[11:00:01.162]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:01.162]                   NULL)
[11:00:01.162]                 if (is_error) {
[11:00:01.162]                   sessionInformation <- function() {
[11:00:01.162]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:01.162]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:01.162]                       search = base::search(), system = base::Sys.info())
[11:00:01.162]                   }
[11:00:01.162]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.162]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:01.162]                     cond$call), session = sessionInformation(), 
[11:00:01.162]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:01.162]                   signalCondition(cond)
[11:00:01.162]                 }
[11:00:01.162]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:01.162]                 "immediateCondition"))) {
[11:00:01.162]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:01.162]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.162]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:01.162]                   if (TRUE && !signal) {
[11:00:01.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.162]                     {
[11:00:01.162]                       inherits <- base::inherits
[11:00:01.162]                       invokeRestart <- base::invokeRestart
[11:00:01.162]                       is.null <- base::is.null
[11:00:01.162]                       muffled <- FALSE
[11:00:01.162]                       if (inherits(cond, "message")) {
[11:00:01.162]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.162]                         if (muffled) 
[11:00:01.162]                           invokeRestart("muffleMessage")
[11:00:01.162]                       }
[11:00:01.162]                       else if (inherits(cond, "warning")) {
[11:00:01.162]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.162]                         if (muffled) 
[11:00:01.162]                           invokeRestart("muffleWarning")
[11:00:01.162]                       }
[11:00:01.162]                       else if (inherits(cond, "condition")) {
[11:00:01.162]                         if (!is.null(pattern)) {
[11:00:01.162]                           computeRestarts <- base::computeRestarts
[11:00:01.162]                           grepl <- base::grepl
[11:00:01.162]                           restarts <- computeRestarts(cond)
[11:00:01.162]                           for (restart in restarts) {
[11:00:01.162]                             name <- restart$name
[11:00:01.162]                             if (is.null(name)) 
[11:00:01.162]                               next
[11:00:01.162]                             if (!grepl(pattern, name)) 
[11:00:01.162]                               next
[11:00:01.162]                             invokeRestart(restart)
[11:00:01.162]                             muffled <- TRUE
[11:00:01.162]                             break
[11:00:01.162]                           }
[11:00:01.162]                         }
[11:00:01.162]                       }
[11:00:01.162]                       invisible(muffled)
[11:00:01.162]                     }
[11:00:01.162]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.162]                   }
[11:00:01.162]                 }
[11:00:01.162]                 else {
[11:00:01.162]                   if (TRUE) {
[11:00:01.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.162]                     {
[11:00:01.162]                       inherits <- base::inherits
[11:00:01.162]                       invokeRestart <- base::invokeRestart
[11:00:01.162]                       is.null <- base::is.null
[11:00:01.162]                       muffled <- FALSE
[11:00:01.162]                       if (inherits(cond, "message")) {
[11:00:01.162]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.162]                         if (muffled) 
[11:00:01.162]                           invokeRestart("muffleMessage")
[11:00:01.162]                       }
[11:00:01.162]                       else if (inherits(cond, "warning")) {
[11:00:01.162]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.162]                         if (muffled) 
[11:00:01.162]                           invokeRestart("muffleWarning")
[11:00:01.162]                       }
[11:00:01.162]                       else if (inherits(cond, "condition")) {
[11:00:01.162]                         if (!is.null(pattern)) {
[11:00:01.162]                           computeRestarts <- base::computeRestarts
[11:00:01.162]                           grepl <- base::grepl
[11:00:01.162]                           restarts <- computeRestarts(cond)
[11:00:01.162]                           for (restart in restarts) {
[11:00:01.162]                             name <- restart$name
[11:00:01.162]                             if (is.null(name)) 
[11:00:01.162]                               next
[11:00:01.162]                             if (!grepl(pattern, name)) 
[11:00:01.162]                               next
[11:00:01.162]                             invokeRestart(restart)
[11:00:01.162]                             muffled <- TRUE
[11:00:01.162]                             break
[11:00:01.162]                           }
[11:00:01.162]                         }
[11:00:01.162]                       }
[11:00:01.162]                       invisible(muffled)
[11:00:01.162]                     }
[11:00:01.162]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.162]                   }
[11:00:01.162]                 }
[11:00:01.162]             }
[11:00:01.162]         }))
[11:00:01.162]     }, error = function(ex) {
[11:00:01.162]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:01.162]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.162]                 ...future.rng), started = ...future.startTime, 
[11:00:01.162]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:01.162]             version = "1.8"), class = "FutureResult")
[11:00:01.162]     }, finally = {
[11:00:01.162]         if (!identical(...future.workdir, getwd())) 
[11:00:01.162]             setwd(...future.workdir)
[11:00:01.162]         {
[11:00:01.162]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:01.162]                 ...future.oldOptions$nwarnings <- NULL
[11:00:01.162]             }
[11:00:01.162]             base::options(...future.oldOptions)
[11:00:01.162]             if (.Platform$OS.type == "windows") {
[11:00:01.162]                 old_names <- names(...future.oldEnvVars)
[11:00:01.162]                 envs <- base::Sys.getenv()
[11:00:01.162]                 names <- names(envs)
[11:00:01.162]                 common <- intersect(names, old_names)
[11:00:01.162]                 added <- setdiff(names, old_names)
[11:00:01.162]                 removed <- setdiff(old_names, names)
[11:00:01.162]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:01.162]                   envs[common]]
[11:00:01.162]                 NAMES <- toupper(changed)
[11:00:01.162]                 args <- list()
[11:00:01.162]                 for (kk in seq_along(NAMES)) {
[11:00:01.162]                   name <- changed[[kk]]
[11:00:01.162]                   NAME <- NAMES[[kk]]
[11:00:01.162]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.162]                     next
[11:00:01.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.162]                 }
[11:00:01.162]                 NAMES <- toupper(added)
[11:00:01.162]                 for (kk in seq_along(NAMES)) {
[11:00:01.162]                   name <- added[[kk]]
[11:00:01.162]                   NAME <- NAMES[[kk]]
[11:00:01.162]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.162]                     next
[11:00:01.162]                   args[[name]] <- ""
[11:00:01.162]                 }
[11:00:01.162]                 NAMES <- toupper(removed)
[11:00:01.162]                 for (kk in seq_along(NAMES)) {
[11:00:01.162]                   name <- removed[[kk]]
[11:00:01.162]                   NAME <- NAMES[[kk]]
[11:00:01.162]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.162]                     next
[11:00:01.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.162]                 }
[11:00:01.162]                 if (length(args) > 0) 
[11:00:01.162]                   base::do.call(base::Sys.setenv, args = args)
[11:00:01.162]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:01.162]             }
[11:00:01.162]             else {
[11:00:01.162]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:01.162]             }
[11:00:01.162]             {
[11:00:01.162]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:01.162]                   0L) {
[11:00:01.162]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:01.162]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:01.162]                   base::options(opts)
[11:00:01.162]                 }
[11:00:01.162]                 {
[11:00:01.162]                   {
[11:00:01.162]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:01.162]                     NULL
[11:00:01.162]                   }
[11:00:01.162]                   options(future.plan = NULL)
[11:00:01.162]                   if (is.na(NA_character_)) 
[11:00:01.162]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.162]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:01.162]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:01.162]                     .init = FALSE)
[11:00:01.162]                 }
[11:00:01.162]             }
[11:00:01.162]         }
[11:00:01.162]     })
[11:00:01.162]     if (TRUE) {
[11:00:01.162]         base::sink(type = "output", split = FALSE)
[11:00:01.162]         if (TRUE) {
[11:00:01.162]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:01.162]         }
[11:00:01.162]         else {
[11:00:01.162]             ...future.result["stdout"] <- base::list(NULL)
[11:00:01.162]         }
[11:00:01.162]         base::close(...future.stdout)
[11:00:01.162]         ...future.stdout <- NULL
[11:00:01.162]     }
[11:00:01.162]     ...future.result$conditions <- ...future.conditions
[11:00:01.162]     ...future.result$finished <- base::Sys.time()
[11:00:01.162]     ...future.result
[11:00:01.162] }
[11:00:01.165] assign_globals() ...
[11:00:01.165] List of 11
[11:00:01.165]  $ ...future.FUN            :function (x, ...)  
[11:00:01.165]  $ x_FUN                    :function (x)  
[11:00:01.165]  $ times                    : int 0
[11:00:01.165]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.165]  $ stop_if_not              :function (...)  
[11:00:01.165]  $ dim                      : NULL
[11:00:01.165]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:01.165]  $ future.call.arguments    : list()
[11:00:01.165]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.165]  $ ...future.elements_ii    :List of 5
[11:00:01.165]   ..$ : int 6
[11:00:01.165]   ..$ : int 7
[11:00:01.165]   ..$ : int 8
[11:00:01.165]   ..$ : int 9
[11:00:01.165]   ..$ : int 10
[11:00:01.165]  $ ...future.seeds_ii       : NULL
[11:00:01.165]  $ ...future.globals.maxSize: NULL
[11:00:01.165]  - attr(*, "where")=List of 11
[11:00:01.165]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:01.165]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:01.165]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:01.165]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:01.165]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:01.165]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:01.165]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:01.165]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:01.165]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:01.165]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:01.165]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:01.165]  - attr(*, "resolved")= logi FALSE
[11:00:01.165]  - attr(*, "total_size")= num 23490
[11:00:01.165]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.165]  - attr(*, "already-done")= logi TRUE
[11:00:01.176] - copied ‘...future.FUN’ to environment
[11:00:01.176] - reassign environment for ‘x_FUN’
[11:00:01.177] - copied ‘x_FUN’ to environment
[11:00:01.177] - copied ‘times’ to environment
[11:00:01.177] - copied ‘stopf’ to environment
[11:00:01.177] - copied ‘stop_if_not’ to environment
[11:00:01.177] - copied ‘dim’ to environment
[11:00:01.177] - copied ‘valid_types’ to environment
[11:00:01.177] - copied ‘future.call.arguments’ to environment
[11:00:01.177] - copied ‘...future.elements_ii’ to environment
[11:00:01.177] - copied ‘...future.seeds_ii’ to environment
[11:00:01.178] - copied ‘...future.globals.maxSize’ to environment
[11:00:01.178] assign_globals() ... done
[11:00:01.178] requestCore(): workers = 2
[11:00:01.180] MulticoreFuture started
[11:00:01.180] - Launch lazy future ... done
[11:00:01.180] run() for ‘MulticoreFuture’ ... done
[11:00:01.181] Created future:
[11:00:01.181] plan(): Setting new future strategy stack:
[11:00:01.181] List of future strategies:
[11:00:01.181] 1. sequential:
[11:00:01.181]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:01.181]    - tweaked: FALSE
[11:00:01.181]    - call: NULL
[11:00:01.182] plan(): nbrOfWorkers() = 1
[11:00:01.184] plan(): Setting new future strategy stack:
[11:00:01.184] List of future strategies:
[11:00:01.184] 1. multicore:
[11:00:01.184]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:01.184]    - tweaked: FALSE
[11:00:01.184]    - call: plan(strategy)
[11:00:01.187] plan(): nbrOfWorkers() = 2
[11:00:01.181] MulticoreFuture:
[11:00:01.181] Label: ‘future_vapply-2’
[11:00:01.181] Expression:
[11:00:01.181] {
[11:00:01.181]     do.call(function(...) {
[11:00:01.181]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.181]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.181]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.181]             on.exit(options(oopts), add = TRUE)
[11:00:01.181]         }
[11:00:01.181]         {
[11:00:01.181]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.181]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.181]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.181]             })
[11:00:01.181]         }
[11:00:01.181]     }, args = future.call.arguments)
[11:00:01.181] }
[11:00:01.181] Lazy evaluation: FALSE
[11:00:01.181] Asynchronous evaluation: TRUE
[11:00:01.181] Local evaluation: TRUE
[11:00:01.181] Environment: R_GlobalEnv
[11:00:01.181] Capture standard output: TRUE
[11:00:01.181] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:01.181] Globals: 11 objects totaling 13.01 KiB (function ‘...future.FUN’ of 4.50 KiB, function ‘x_FUN’ of 295 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:01.181] Packages: 1 packages (‘future.apply’)
[11:00:01.181] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:01.181] Resolved: TRUE
[11:00:01.181] Value: <not collected>
[11:00:01.181] Conditions captured: <none>
[11:00:01.181] Early signaling: FALSE
[11:00:01.181] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:01.181] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.189] Chunk #2 of 2 ... DONE
[11:00:01.189] Launching 2 futures (chunks) ... DONE
[11:00:01.189] Resolving 2 futures (chunks) ...
[11:00:01.189] resolve() on list ...
[11:00:01.189]  recursive: 0
[11:00:01.189]  length: 2
[11:00:01.189] 
[11:00:01.190] Future #1
[11:00:01.190] result() for MulticoreFuture ...
[11:00:01.191] result() for MulticoreFuture ...
[11:00:01.191] result() for MulticoreFuture ... done
[11:00:01.191] result() for MulticoreFuture ... done
[11:00:01.191] result() for MulticoreFuture ...
[11:00:01.191] result() for MulticoreFuture ... done
[11:00:01.191] signalConditionsASAP(MulticoreFuture, pos=1) ...
[11:00:01.192] - nx: 2
[11:00:01.192] - relay: TRUE
[11:00:01.192] - stdout: TRUE
[11:00:01.192] - signal: TRUE
[11:00:01.192] - resignal: FALSE
[11:00:01.192] - force: TRUE
[11:00:01.192] - relayed: [n=2] FALSE, FALSE
[11:00:01.193] - queued futures: [n=2] FALSE, FALSE
[11:00:01.193]  - until=1
[11:00:01.193]  - relaying element #1
[11:00:01.193] result() for MulticoreFuture ...
[11:00:01.193] result() for MulticoreFuture ... done
[11:00:01.193] result() for MulticoreFuture ...
[11:00:01.193] result() for MulticoreFuture ... done
[11:00:01.197] result() for MulticoreFuture ...
[11:00:01.197] result() for MulticoreFuture ... done
[11:00:01.197] result() for MulticoreFuture ...
[11:00:01.198] result() for MulticoreFuture ... done
[11:00:01.198] - relayed: [n=2] TRUE, FALSE
[11:00:01.198] - queued futures: [n=2] TRUE, FALSE
[11:00:01.199] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[11:00:01.199]  length: 1 (resolved future 1)
[11:00:01.200] Future #2
[11:00:01.200] result() for MulticoreFuture ...
[11:00:01.201] result() for MulticoreFuture ...
[11:00:01.201] result() for MulticoreFuture ... done
[11:00:01.201] result() for MulticoreFuture ... done
[11:00:01.202] result() for MulticoreFuture ...
[11:00:01.202] result() for MulticoreFuture ... done
[11:00:01.202] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:00:01.202] - nx: 2
[11:00:01.202] - relay: TRUE
[11:00:01.203] - stdout: TRUE
[11:00:01.203] - signal: TRUE
[11:00:01.203] - resignal: FALSE
[11:00:01.203] - force: TRUE
[11:00:01.203] - relayed: [n=2] TRUE, FALSE
[11:00:01.203] - queued futures: [n=2] TRUE, FALSE
[11:00:01.204]  - until=2
[11:00:01.204]  - relaying element #2
[11:00:01.204] result() for MulticoreFuture ...
[11:00:01.204] result() for MulticoreFuture ... done
[11:00:01.204] result() for MulticoreFuture ...
[11:00:01.204] result() for MulticoreFuture ... done
[11:00:01.205] result() for MulticoreFuture ...
[11:00:01.205] result() for MulticoreFuture ... done
[11:00:01.205] result() for MulticoreFuture ...
[11:00:01.205] result() for MulticoreFuture ... done
[11:00:01.205] - relayed: [n=2] TRUE, TRUE
[11:00:01.205] - queued futures: [n=2] TRUE, TRUE
[11:00:01.205] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:00:01.205]  length: 0 (resolved future 2)
[11:00:01.206] Relaying remaining futures
[11:00:01.206] signalConditionsASAP(NULL, pos=0) ...
[11:00:01.206] - nx: 2
[11:00:01.206] - relay: TRUE
[11:00:01.206] - stdout: TRUE
[11:00:01.206] - signal: TRUE
[11:00:01.206] - resignal: FALSE
[11:00:01.206] - force: TRUE
[11:00:01.206] - relayed: [n=2] TRUE, TRUE
[11:00:01.206] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:01.207] - relayed: [n=2] TRUE, TRUE
[11:00:01.207] - queued futures: [n=2] TRUE, TRUE
[11:00:01.207] signalConditionsASAP(NULL, pos=0) ... done
[11:00:01.207] resolve() on list ... DONE
[11:00:01.207] result() for MulticoreFuture ...
[11:00:01.207] result() for MulticoreFuture ... done
[11:00:01.207] result() for MulticoreFuture ...
[11:00:01.207] result() for MulticoreFuture ... done
[11:00:01.208] result() for MulticoreFuture ...
[11:00:01.208] result() for MulticoreFuture ... done
[11:00:01.208] result() for MulticoreFuture ...
[11:00:01.208] result() for MulticoreFuture ... done
[11:00:01.208]  - Number of value chunks collected: 2
[11:00:01.208] Resolving 2 futures (chunks) ... DONE
[11:00:01.208] Reducing values from 2 chunks ...
[11:00:01.208]  - Number of values collected after concatenation: 10
[11:00:01.208]  - Number of values expected: 10
[11:00:01.209] Reducing values from 2 chunks ... DONE
[11:00:01.209] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[11:00:01.210] future_lapply() ...
[11:00:01.214] Number of chunks: 2
[11:00:01.214] getGlobalsAndPackagesXApply() ...
[11:00:01.214]  - future.globals: TRUE
[11:00:01.214] getGlobalsAndPackages() ...
[11:00:01.214] Searching for globals...
[11:00:01.218] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[11:00:01.218] Searching for globals ... DONE
[11:00:01.218] Resolving globals: FALSE
[11:00:01.219] The total size of the 7 globals is 12.75 KiB (13056 bytes)
[11:00:01.219] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.50 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:01.219] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:01.220] - packages: [1] ‘future.apply’
[11:00:01.220] getGlobalsAndPackages() ... DONE
[11:00:01.220]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:01.220]  - needed namespaces: [n=1] ‘future.apply’
[11:00:01.220] Finding globals ... DONE
[11:00:01.220]  - use_args: TRUE
[11:00:01.220]  - Getting '...' globals ...
[11:00:01.220] resolve() on list ...
[11:00:01.221]  recursive: 0
[11:00:01.221]  length: 1
[11:00:01.221]  elements: ‘...’
[11:00:01.221]  length: 0 (resolved future 1)
[11:00:01.221] resolve() on list ... DONE
[11:00:01.221]    - '...' content: [n=0] 
[11:00:01.221] List of 1
[11:00:01.221]  $ ...: list()
[11:00:01.221]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.221]  - attr(*, "where")=List of 1
[11:00:01.221]   ..$ ...:<environment: 0x55bbab0fb888> 
[11:00:01.221]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.221]  - attr(*, "resolved")= logi TRUE
[11:00:01.221]  - attr(*, "total_size")= num NA
[11:00:01.224]  - Getting '...' globals ... DONE
[11:00:01.225] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:01.225] List of 8
[11:00:01.225]  $ ...future.FUN:function (x, ...)  
[11:00:01.225]  $ x_FUN        :function (x)  
[11:00:01.225]  $ times        : int 0
[11:00:01.225]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.225]  $ stop_if_not  :function (...)  
[11:00:01.225]  $ dim          : NULL
[11:00:01.225]  $ valid_types  : chr [1:2] "logical" "integer"
[11:00:01.225]  $ ...          : list()
[11:00:01.225]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.225]  - attr(*, "where")=List of 8
[11:00:01.225]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:01.225]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:01.225]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:01.225]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:01.225]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:01.225]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:01.225]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:01.225]   ..$ ...          :<environment: 0x55bbab0fb888> 
[11:00:01.225]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.225]  - attr(*, "resolved")= logi FALSE
[11:00:01.225]  - attr(*, "total_size")= num 23453
[11:00:01.231] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:01.231] getGlobalsAndPackagesXApply() ... DONE
[11:00:01.231] Number of futures (= number of chunks): 2
[11:00:01.231] Launching 2 futures (chunks) ...
[11:00:01.231] Chunk #1 of 2 ...
[11:00:01.231]  - Finding globals in 'X' for chunk #1 ...
[11:00:01.231] getGlobalsAndPackages() ...
[11:00:01.232] Searching for globals...
[11:00:01.232] 
[11:00:01.232] Searching for globals ... DONE
[11:00:01.232] - globals: [0] <none>
[11:00:01.232] getGlobalsAndPackages() ... DONE
[11:00:01.232]    + additional globals found: [n=0] 
[11:00:01.232]    + additional namespaces needed: [n=0] 
[11:00:01.232]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:01.232]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:01.233]  - seeds: <none>
[11:00:01.233]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.233] getGlobalsAndPackages() ...
[11:00:01.233] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.233] Resolving globals: FALSE
[11:00:01.233] Tweak future expression to call with '...' arguments ...
[11:00:01.233] {
[11:00:01.233]     do.call(function(...) {
[11:00:01.233]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.233]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.233]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.233]             on.exit(options(oopts), add = TRUE)
[11:00:01.233]         }
[11:00:01.233]         {
[11:00:01.233]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.233]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.233]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.233]             })
[11:00:01.233]         }
[11:00:01.233]     }, args = future.call.arguments)
[11:00:01.233] }
[11:00:01.233] Tweak future expression to call with '...' arguments ... DONE
[11:00:01.234] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.234] - packages: [1] ‘future.apply’
[11:00:01.234] getGlobalsAndPackages() ... DONE
[11:00:01.234] run() for ‘Future’ ...
[11:00:01.234] - state: ‘created’
[11:00:01.235] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:01.236] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.236] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:01.236]   - Field: ‘label’
[11:00:01.237]   - Field: ‘local’
[11:00:01.237]   - Field: ‘owner’
[11:00:01.237]   - Field: ‘envir’
[11:00:01.237]   - Field: ‘workers’
[11:00:01.237]   - Field: ‘packages’
[11:00:01.237]   - Field: ‘gc’
[11:00:01.237]   - Field: ‘job’
[11:00:01.237]   - Field: ‘conditions’
[11:00:01.237]   - Field: ‘expr’
[11:00:01.237]   - Field: ‘uuid’
[11:00:01.237]   - Field: ‘seed’
[11:00:01.237]   - Field: ‘version’
[11:00:01.238]   - Field: ‘result’
[11:00:01.238]   - Field: ‘asynchronous’
[11:00:01.238]   - Field: ‘calls’
[11:00:01.238]   - Field: ‘globals’
[11:00:01.238]   - Field: ‘stdout’
[11:00:01.238]   - Field: ‘earlySignal’
[11:00:01.238]   - Field: ‘lazy’
[11:00:01.238]   - Field: ‘state’
[11:00:01.238] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:01.238] - Launch lazy future ...
[11:00:01.239] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:01.239] Packages needed by future strategies (n = 0): <none>
[11:00:01.239] {
[11:00:01.239]     {
[11:00:01.239]         {
[11:00:01.239]             ...future.startTime <- base::Sys.time()
[11:00:01.239]             {
[11:00:01.239]                 {
[11:00:01.239]                   {
[11:00:01.239]                     {
[11:00:01.239]                       {
[11:00:01.239]                         base::local({
[11:00:01.239]                           has_future <- base::requireNamespace("future", 
[11:00:01.239]                             quietly = TRUE)
[11:00:01.239]                           if (has_future) {
[11:00:01.239]                             ns <- base::getNamespace("future")
[11:00:01.239]                             version <- ns[[".package"]][["version"]]
[11:00:01.239]                             if (is.null(version)) 
[11:00:01.239]                               version <- utils::packageVersion("future")
[11:00:01.239]                           }
[11:00:01.239]                           else {
[11:00:01.239]                             version <- NULL
[11:00:01.239]                           }
[11:00:01.239]                           if (!has_future || version < "1.8.0") {
[11:00:01.239]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:01.239]                               "", base::R.version$version.string), 
[11:00:01.239]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:01.239]                                 base::R.version$platform, 8 * 
[11:00:01.239]                                   base::.Machine$sizeof.pointer), 
[11:00:01.239]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:01.239]                                 "release", "version")], collapse = " "), 
[11:00:01.239]                               hostname = base::Sys.info()[["nodename"]])
[11:00:01.239]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:01.239]                               info)
[11:00:01.239]                             info <- base::paste(info, collapse = "; ")
[11:00:01.239]                             if (!has_future) {
[11:00:01.239]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:01.239]                                 info)
[11:00:01.239]                             }
[11:00:01.239]                             else {
[11:00:01.239]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:01.239]                                 info, version)
[11:00:01.239]                             }
[11:00:01.239]                             base::stop(msg)
[11:00:01.239]                           }
[11:00:01.239]                         })
[11:00:01.239]                       }
[11:00:01.239]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:01.239]                       base::options(mc.cores = 1L)
[11:00:01.239]                     }
[11:00:01.239]                     base::local({
[11:00:01.239]                       for (pkg in "future.apply") {
[11:00:01.239]                         base::loadNamespace(pkg)
[11:00:01.239]                         base::library(pkg, character.only = TRUE)
[11:00:01.239]                       }
[11:00:01.239]                     })
[11:00:01.239]                   }
[11:00:01.239]                   ...future.strategy.old <- future::plan("list")
[11:00:01.239]                   options(future.plan = NULL)
[11:00:01.239]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.239]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:01.239]                 }
[11:00:01.239]                 ...future.workdir <- getwd()
[11:00:01.239]             }
[11:00:01.239]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:01.239]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:01.239]         }
[11:00:01.239]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:01.239]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:01.239]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:01.239]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:01.239]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:01.239]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:01.239]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:01.239]             base::names(...future.oldOptions))
[11:00:01.239]     }
[11:00:01.239]     if (FALSE) {
[11:00:01.239]     }
[11:00:01.239]     else {
[11:00:01.239]         if (TRUE) {
[11:00:01.239]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:01.239]                 open = "w")
[11:00:01.239]         }
[11:00:01.239]         else {
[11:00:01.239]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:01.239]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:01.239]         }
[11:00:01.239]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:01.239]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:01.239]             base::sink(type = "output", split = FALSE)
[11:00:01.239]             base::close(...future.stdout)
[11:00:01.239]         }, add = TRUE)
[11:00:01.239]     }
[11:00:01.239]     ...future.frame <- base::sys.nframe()
[11:00:01.239]     ...future.conditions <- base::list()
[11:00:01.239]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:01.239]     if (FALSE) {
[11:00:01.239]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:01.239]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:01.239]     }
[11:00:01.239]     ...future.result <- base::tryCatch({
[11:00:01.239]         base::withCallingHandlers({
[11:00:01.239]             ...future.value <- base::withVisible(base::local({
[11:00:01.239]                 withCallingHandlers({
[11:00:01.239]                   {
[11:00:01.239]                     do.call(function(...) {
[11:00:01.239]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.239]                       if (!identical(...future.globals.maxSize.org, 
[11:00:01.239]                         ...future.globals.maxSize)) {
[11:00:01.239]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.239]                         on.exit(options(oopts), add = TRUE)
[11:00:01.239]                       }
[11:00:01.239]                       {
[11:00:01.239]                         lapply(seq_along(...future.elements_ii), 
[11:00:01.239]                           FUN = function(jj) {
[11:00:01.239]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.239]                             ...future.FUN(...future.X_jj, ...)
[11:00:01.239]                           })
[11:00:01.239]                       }
[11:00:01.239]                     }, args = future.call.arguments)
[11:00:01.239]                   }
[11:00:01.239]                 }, immediateCondition = function(cond) {
[11:00:01.239]                   save_rds <- function (object, pathname, ...) 
[11:00:01.239]                   {
[11:00:01.239]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:01.239]                     if (file_test("-f", pathname_tmp)) {
[11:00:01.239]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.239]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:01.239]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.239]                         fi_tmp[["mtime"]])
[11:00:01.239]                     }
[11:00:01.239]                     tryCatch({
[11:00:01.239]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:01.239]                     }, error = function(ex) {
[11:00:01.239]                       msg <- conditionMessage(ex)
[11:00:01.239]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.239]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:01.239]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.239]                         fi_tmp[["mtime"]], msg)
[11:00:01.239]                       ex$message <- msg
[11:00:01.239]                       stop(ex)
[11:00:01.239]                     })
[11:00:01.239]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:01.239]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:01.239]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:01.239]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.239]                       fi <- file.info(pathname)
[11:00:01.239]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:01.239]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.239]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:01.239]                         fi[["size"]], fi[["mtime"]])
[11:00:01.239]                       stop(msg)
[11:00:01.239]                     }
[11:00:01.239]                     invisible(pathname)
[11:00:01.239]                   }
[11:00:01.239]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:01.239]                     rootPath = tempdir()) 
[11:00:01.239]                   {
[11:00:01.239]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:01.239]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:01.239]                       tmpdir = path, fileext = ".rds")
[11:00:01.239]                     save_rds(obj, file)
[11:00:01.239]                   }
[11:00:01.239]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:01.239]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.239]                   {
[11:00:01.239]                     inherits <- base::inherits
[11:00:01.239]                     invokeRestart <- base::invokeRestart
[11:00:01.239]                     is.null <- base::is.null
[11:00:01.239]                     muffled <- FALSE
[11:00:01.239]                     if (inherits(cond, "message")) {
[11:00:01.239]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:01.239]                       if (muffled) 
[11:00:01.239]                         invokeRestart("muffleMessage")
[11:00:01.239]                     }
[11:00:01.239]                     else if (inherits(cond, "warning")) {
[11:00:01.239]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:01.239]                       if (muffled) 
[11:00:01.239]                         invokeRestart("muffleWarning")
[11:00:01.239]                     }
[11:00:01.239]                     else if (inherits(cond, "condition")) {
[11:00:01.239]                       if (!is.null(pattern)) {
[11:00:01.239]                         computeRestarts <- base::computeRestarts
[11:00:01.239]                         grepl <- base::grepl
[11:00:01.239]                         restarts <- computeRestarts(cond)
[11:00:01.239]                         for (restart in restarts) {
[11:00:01.239]                           name <- restart$name
[11:00:01.239]                           if (is.null(name)) 
[11:00:01.239]                             next
[11:00:01.239]                           if (!grepl(pattern, name)) 
[11:00:01.239]                             next
[11:00:01.239]                           invokeRestart(restart)
[11:00:01.239]                           muffled <- TRUE
[11:00:01.239]                           break
[11:00:01.239]                         }
[11:00:01.239]                       }
[11:00:01.239]                     }
[11:00:01.239]                     invisible(muffled)
[11:00:01.239]                   }
[11:00:01.239]                   muffleCondition(cond)
[11:00:01.239]                 })
[11:00:01.239]             }))
[11:00:01.239]             future::FutureResult(value = ...future.value$value, 
[11:00:01.239]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.239]                   ...future.rng), globalenv = if (FALSE) 
[11:00:01.239]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:01.239]                     ...future.globalenv.names))
[11:00:01.239]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:01.239]         }, condition = base::local({
[11:00:01.239]             c <- base::c
[11:00:01.239]             inherits <- base::inherits
[11:00:01.239]             invokeRestart <- base::invokeRestart
[11:00:01.239]             length <- base::length
[11:00:01.239]             list <- base::list
[11:00:01.239]             seq.int <- base::seq.int
[11:00:01.239]             signalCondition <- base::signalCondition
[11:00:01.239]             sys.calls <- base::sys.calls
[11:00:01.239]             `[[` <- base::`[[`
[11:00:01.239]             `+` <- base::`+`
[11:00:01.239]             `<<-` <- base::`<<-`
[11:00:01.239]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:01.239]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:01.239]                   3L)]
[11:00:01.239]             }
[11:00:01.239]             function(cond) {
[11:00:01.239]                 is_error <- inherits(cond, "error")
[11:00:01.239]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:01.239]                   NULL)
[11:00:01.239]                 if (is_error) {
[11:00:01.239]                   sessionInformation <- function() {
[11:00:01.239]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:01.239]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:01.239]                       search = base::search(), system = base::Sys.info())
[11:00:01.239]                   }
[11:00:01.239]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.239]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:01.239]                     cond$call), session = sessionInformation(), 
[11:00:01.239]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:01.239]                   signalCondition(cond)
[11:00:01.239]                 }
[11:00:01.239]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:01.239]                 "immediateCondition"))) {
[11:00:01.239]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:01.239]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.239]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:01.239]                   if (TRUE && !signal) {
[11:00:01.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.239]                     {
[11:00:01.239]                       inherits <- base::inherits
[11:00:01.239]                       invokeRestart <- base::invokeRestart
[11:00:01.239]                       is.null <- base::is.null
[11:00:01.239]                       muffled <- FALSE
[11:00:01.239]                       if (inherits(cond, "message")) {
[11:00:01.239]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.239]                         if (muffled) 
[11:00:01.239]                           invokeRestart("muffleMessage")
[11:00:01.239]                       }
[11:00:01.239]                       else if (inherits(cond, "warning")) {
[11:00:01.239]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.239]                         if (muffled) 
[11:00:01.239]                           invokeRestart("muffleWarning")
[11:00:01.239]                       }
[11:00:01.239]                       else if (inherits(cond, "condition")) {
[11:00:01.239]                         if (!is.null(pattern)) {
[11:00:01.239]                           computeRestarts <- base::computeRestarts
[11:00:01.239]                           grepl <- base::grepl
[11:00:01.239]                           restarts <- computeRestarts(cond)
[11:00:01.239]                           for (restart in restarts) {
[11:00:01.239]                             name <- restart$name
[11:00:01.239]                             if (is.null(name)) 
[11:00:01.239]                               next
[11:00:01.239]                             if (!grepl(pattern, name)) 
[11:00:01.239]                               next
[11:00:01.239]                             invokeRestart(restart)
[11:00:01.239]                             muffled <- TRUE
[11:00:01.239]                             break
[11:00:01.239]                           }
[11:00:01.239]                         }
[11:00:01.239]                       }
[11:00:01.239]                       invisible(muffled)
[11:00:01.239]                     }
[11:00:01.239]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.239]                   }
[11:00:01.239]                 }
[11:00:01.239]                 else {
[11:00:01.239]                   if (TRUE) {
[11:00:01.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.239]                     {
[11:00:01.239]                       inherits <- base::inherits
[11:00:01.239]                       invokeRestart <- base::invokeRestart
[11:00:01.239]                       is.null <- base::is.null
[11:00:01.239]                       muffled <- FALSE
[11:00:01.239]                       if (inherits(cond, "message")) {
[11:00:01.239]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.239]                         if (muffled) 
[11:00:01.239]                           invokeRestart("muffleMessage")
[11:00:01.239]                       }
[11:00:01.239]                       else if (inherits(cond, "warning")) {
[11:00:01.239]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.239]                         if (muffled) 
[11:00:01.239]                           invokeRestart("muffleWarning")
[11:00:01.239]                       }
[11:00:01.239]                       else if (inherits(cond, "condition")) {
[11:00:01.239]                         if (!is.null(pattern)) {
[11:00:01.239]                           computeRestarts <- base::computeRestarts
[11:00:01.239]                           grepl <- base::grepl
[11:00:01.239]                           restarts <- computeRestarts(cond)
[11:00:01.239]                           for (restart in restarts) {
[11:00:01.239]                             name <- restart$name
[11:00:01.239]                             if (is.null(name)) 
[11:00:01.239]                               next
[11:00:01.239]                             if (!grepl(pattern, name)) 
[11:00:01.239]                               next
[11:00:01.239]                             invokeRestart(restart)
[11:00:01.239]                             muffled <- TRUE
[11:00:01.239]                             break
[11:00:01.239]                           }
[11:00:01.239]                         }
[11:00:01.239]                       }
[11:00:01.239]                       invisible(muffled)
[11:00:01.239]                     }
[11:00:01.239]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.239]                   }
[11:00:01.239]                 }
[11:00:01.239]             }
[11:00:01.239]         }))
[11:00:01.239]     }, error = function(ex) {
[11:00:01.239]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:01.239]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.239]                 ...future.rng), started = ...future.startTime, 
[11:00:01.239]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:01.239]             version = "1.8"), class = "FutureResult")
[11:00:01.239]     }, finally = {
[11:00:01.239]         if (!identical(...future.workdir, getwd())) 
[11:00:01.239]             setwd(...future.workdir)
[11:00:01.239]         {
[11:00:01.239]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:01.239]                 ...future.oldOptions$nwarnings <- NULL
[11:00:01.239]             }
[11:00:01.239]             base::options(...future.oldOptions)
[11:00:01.239]             if (.Platform$OS.type == "windows") {
[11:00:01.239]                 old_names <- names(...future.oldEnvVars)
[11:00:01.239]                 envs <- base::Sys.getenv()
[11:00:01.239]                 names <- names(envs)
[11:00:01.239]                 common <- intersect(names, old_names)
[11:00:01.239]                 added <- setdiff(names, old_names)
[11:00:01.239]                 removed <- setdiff(old_names, names)
[11:00:01.239]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:01.239]                   envs[common]]
[11:00:01.239]                 NAMES <- toupper(changed)
[11:00:01.239]                 args <- list()
[11:00:01.239]                 for (kk in seq_along(NAMES)) {
[11:00:01.239]                   name <- changed[[kk]]
[11:00:01.239]                   NAME <- NAMES[[kk]]
[11:00:01.239]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.239]                     next
[11:00:01.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.239]                 }
[11:00:01.239]                 NAMES <- toupper(added)
[11:00:01.239]                 for (kk in seq_along(NAMES)) {
[11:00:01.239]                   name <- added[[kk]]
[11:00:01.239]                   NAME <- NAMES[[kk]]
[11:00:01.239]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.239]                     next
[11:00:01.239]                   args[[name]] <- ""
[11:00:01.239]                 }
[11:00:01.239]                 NAMES <- toupper(removed)
[11:00:01.239]                 for (kk in seq_along(NAMES)) {
[11:00:01.239]                   name <- removed[[kk]]
[11:00:01.239]                   NAME <- NAMES[[kk]]
[11:00:01.239]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.239]                     next
[11:00:01.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.239]                 }
[11:00:01.239]                 if (length(args) > 0) 
[11:00:01.239]                   base::do.call(base::Sys.setenv, args = args)
[11:00:01.239]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:01.239]             }
[11:00:01.239]             else {
[11:00:01.239]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:01.239]             }
[11:00:01.239]             {
[11:00:01.239]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:01.239]                   0L) {
[11:00:01.239]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:01.239]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:01.239]                   base::options(opts)
[11:00:01.239]                 }
[11:00:01.239]                 {
[11:00:01.239]                   {
[11:00:01.239]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:01.239]                     NULL
[11:00:01.239]                   }
[11:00:01.239]                   options(future.plan = NULL)
[11:00:01.239]                   if (is.na(NA_character_)) 
[11:00:01.239]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.239]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:01.239]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:01.239]                     .init = FALSE)
[11:00:01.239]                 }
[11:00:01.239]             }
[11:00:01.239]         }
[11:00:01.239]     })
[11:00:01.239]     if (TRUE) {
[11:00:01.239]         base::sink(type = "output", split = FALSE)
[11:00:01.239]         if (TRUE) {
[11:00:01.239]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:01.239]         }
[11:00:01.239]         else {
[11:00:01.239]             ...future.result["stdout"] <- base::list(NULL)
[11:00:01.239]         }
[11:00:01.239]         base::close(...future.stdout)
[11:00:01.239]         ...future.stdout <- NULL
[11:00:01.239]     }
[11:00:01.239]     ...future.result$conditions <- ...future.conditions
[11:00:01.239]     ...future.result$finished <- base::Sys.time()
[11:00:01.239]     ...future.result
[11:00:01.239] }
[11:00:01.242] assign_globals() ...
[11:00:01.242] List of 11
[11:00:01.242]  $ ...future.FUN            :function (x, ...)  
[11:00:01.242]  $ x_FUN                    :function (x)  
[11:00:01.242]  $ times                    : int 0
[11:00:01.242]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.242]  $ stop_if_not              :function (...)  
[11:00:01.242]  $ dim                      : NULL
[11:00:01.242]  $ valid_types              : chr [1:2] "logical" "integer"
[11:00:01.242]  $ future.call.arguments    : list()
[11:00:01.242]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.242]  $ ...future.elements_ii    :List of 5
[11:00:01.242]   ..$ : int 1
[11:00:01.242]   ..$ : int 2
[11:00:01.242]   ..$ : int 3
[11:00:01.242]   ..$ : int 4
[11:00:01.242]   ..$ : int 5
[11:00:01.242]  $ ...future.seeds_ii       : NULL
[11:00:01.242]  $ ...future.globals.maxSize: NULL
[11:00:01.242]  - attr(*, "where")=List of 11
[11:00:01.242]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:01.242]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:01.242]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:01.242]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:01.242]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:01.242]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:01.242]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:01.242]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:01.242]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:01.242]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:01.242]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:01.242]  - attr(*, "resolved")= logi FALSE
[11:00:01.242]  - attr(*, "total_size")= num 23453
[11:00:01.242]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.242]  - attr(*, "already-done")= logi TRUE
[11:00:01.251] - copied ‘...future.FUN’ to environment
[11:00:01.251] - reassign environment for ‘x_FUN’
[11:00:01.251] - copied ‘x_FUN’ to environment
[11:00:01.251] - copied ‘times’ to environment
[11:00:01.251] - copied ‘stopf’ to environment
[11:00:01.251] - copied ‘stop_if_not’ to environment
[11:00:01.252] - copied ‘dim’ to environment
[11:00:01.252] - copied ‘valid_types’ to environment
[11:00:01.252] - copied ‘future.call.arguments’ to environment
[11:00:01.252] - copied ‘...future.elements_ii’ to environment
[11:00:01.252] - copied ‘...future.seeds_ii’ to environment
[11:00:01.252] - copied ‘...future.globals.maxSize’ to environment
[11:00:01.252] assign_globals() ... done
[11:00:01.252] requestCore(): workers = 2
[11:00:01.254] MulticoreFuture started
[11:00:01.255] - Launch lazy future ... done
[11:00:01.255] run() for ‘MulticoreFuture’ ... done
[11:00:01.255] Created future:
[11:00:01.256] plan(): Setting new future strategy stack:
[11:00:01.256] List of future strategies:
[11:00:01.256] 1. sequential:
[11:00:01.256]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:01.256]    - tweaked: FALSE
[11:00:01.256]    - call: NULL
[11:00:01.257] plan(): nbrOfWorkers() = 1
[11:00:01.259] plan(): Setting new future strategy stack:
[11:00:01.259] List of future strategies:
[11:00:01.259] 1. multicore:
[11:00:01.259]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:01.259]    - tweaked: FALSE
[11:00:01.259]    - call: plan(strategy)
[11:00:01.263] plan(): nbrOfWorkers() = 2
[11:00:01.256] MulticoreFuture:
[11:00:01.256] Label: ‘future_vapply-1’
[11:00:01.256] Expression:
[11:00:01.256] {
[11:00:01.256]     do.call(function(...) {
[11:00:01.256]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.256]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.256]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.256]             on.exit(options(oopts), add = TRUE)
[11:00:01.256]         }
[11:00:01.256]         {
[11:00:01.256]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.256]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.256]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.256]             })
[11:00:01.256]         }
[11:00:01.256]     }, args = future.call.arguments)
[11:00:01.256] }
[11:00:01.256] Lazy evaluation: FALSE
[11:00:01.256] Asynchronous evaluation: TRUE
[11:00:01.256] Local evaluation: TRUE
[11:00:01.256] Environment: R_GlobalEnv
[11:00:01.256] Capture standard output: TRUE
[11:00:01.256] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:01.256] Globals: 11 objects totaling 12.98 KiB (function ‘...future.FUN’ of 4.49 KiB, function ‘x_FUN’ of 296 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:01.256] Packages: 1 packages (‘future.apply’)
[11:00:01.256] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:01.256] Resolved: TRUE
[11:00:01.256] Value: <not collected>
[11:00:01.256] Conditions captured: <none>
[11:00:01.256] Early signaling: FALSE
[11:00:01.256] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:01.256] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.264] Chunk #1 of 2 ... DONE
[11:00:01.264] Chunk #2 of 2 ...
[11:00:01.264]  - Finding globals in 'X' for chunk #2 ...
[11:00:01.265] getGlobalsAndPackages() ...
[11:00:01.265] Searching for globals...
[11:00:01.265] 
[11:00:01.265] Searching for globals ... DONE
[11:00:01.265] - globals: [0] <none>
[11:00:01.266] getGlobalsAndPackages() ... DONE
[11:00:01.266]    + additional globals found: [n=0] 
[11:00:01.266]    + additional namespaces needed: [n=0] 
[11:00:01.266]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:01.266]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:01.266]  - seeds: <none>
[11:00:01.266]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.267] getGlobalsAndPackages() ...
[11:00:01.267] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.267] Resolving globals: FALSE
[11:00:01.267] Tweak future expression to call with '...' arguments ...
[11:00:01.267] {
[11:00:01.267]     do.call(function(...) {
[11:00:01.267]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.267]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.267]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.267]             on.exit(options(oopts), add = TRUE)
[11:00:01.267]         }
[11:00:01.267]         {
[11:00:01.267]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.267]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.267]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.267]             })
[11:00:01.267]         }
[11:00:01.267]     }, args = future.call.arguments)
[11:00:01.267] }
[11:00:01.268] Tweak future expression to call with '...' arguments ... DONE
[11:00:01.269] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.269] - packages: [1] ‘future.apply’
[11:00:01.269] getGlobalsAndPackages() ... DONE
[11:00:01.270] run() for ‘Future’ ...
[11:00:01.270] - state: ‘created’
[11:00:01.270] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:01.272] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.272] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:01.273]   - Field: ‘label’
[11:00:01.273]   - Field: ‘local’
[11:00:01.273]   - Field: ‘owner’
[11:00:01.273]   - Field: ‘envir’
[11:00:01.273]   - Field: ‘workers’
[11:00:01.273]   - Field: ‘packages’
[11:00:01.274]   - Field: ‘gc’
[11:00:01.274]   - Field: ‘job’
[11:00:01.274]   - Field: ‘conditions’
[11:00:01.274]   - Field: ‘expr’
[11:00:01.274]   - Field: ‘uuid’
[11:00:01.274]   - Field: ‘seed’
[11:00:01.274]   - Field: ‘version’
[11:00:01.275]   - Field: ‘result’
[11:00:01.275]   - Field: ‘asynchronous’
[11:00:01.275]   - Field: ‘calls’
[11:00:01.275]   - Field: ‘globals’
[11:00:01.275]   - Field: ‘stdout’
[11:00:01.275]   - Field: ‘earlySignal’
[11:00:01.275]   - Field: ‘lazy’
[11:00:01.275]   - Field: ‘state’
[11:00:01.276] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:01.276] - Launch lazy future ...
[11:00:01.276] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:01.276] Packages needed by future strategies (n = 0): <none>
[11:00:01.277] {
[11:00:01.277]     {
[11:00:01.277]         {
[11:00:01.277]             ...future.startTime <- base::Sys.time()
[11:00:01.277]             {
[11:00:01.277]                 {
[11:00:01.277]                   {
[11:00:01.277]                     {
[11:00:01.277]                       {
[11:00:01.277]                         base::local({
[11:00:01.277]                           has_future <- base::requireNamespace("future", 
[11:00:01.277]                             quietly = TRUE)
[11:00:01.277]                           if (has_future) {
[11:00:01.277]                             ns <- base::getNamespace("future")
[11:00:01.277]                             version <- ns[[".package"]][["version"]]
[11:00:01.277]                             if (is.null(version)) 
[11:00:01.277]                               version <- utils::packageVersion("future")
[11:00:01.277]                           }
[11:00:01.277]                           else {
[11:00:01.277]                             version <- NULL
[11:00:01.277]                           }
[11:00:01.277]                           if (!has_future || version < "1.8.0") {
[11:00:01.277]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:01.277]                               "", base::R.version$version.string), 
[11:00:01.277]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:01.277]                                 base::R.version$platform, 8 * 
[11:00:01.277]                                   base::.Machine$sizeof.pointer), 
[11:00:01.277]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:01.277]                                 "release", "version")], collapse = " "), 
[11:00:01.277]                               hostname = base::Sys.info()[["nodename"]])
[11:00:01.277]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:01.277]                               info)
[11:00:01.277]                             info <- base::paste(info, collapse = "; ")
[11:00:01.277]                             if (!has_future) {
[11:00:01.277]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:01.277]                                 info)
[11:00:01.277]                             }
[11:00:01.277]                             else {
[11:00:01.277]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:01.277]                                 info, version)
[11:00:01.277]                             }
[11:00:01.277]                             base::stop(msg)
[11:00:01.277]                           }
[11:00:01.277]                         })
[11:00:01.277]                       }
[11:00:01.277]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:01.277]                       base::options(mc.cores = 1L)
[11:00:01.277]                     }
[11:00:01.277]                     base::local({
[11:00:01.277]                       for (pkg in "future.apply") {
[11:00:01.277]                         base::loadNamespace(pkg)
[11:00:01.277]                         base::library(pkg, character.only = TRUE)
[11:00:01.277]                       }
[11:00:01.277]                     })
[11:00:01.277]                   }
[11:00:01.277]                   ...future.strategy.old <- future::plan("list")
[11:00:01.277]                   options(future.plan = NULL)
[11:00:01.277]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.277]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:01.277]                 }
[11:00:01.277]                 ...future.workdir <- getwd()
[11:00:01.277]             }
[11:00:01.277]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:01.277]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:01.277]         }
[11:00:01.277]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:01.277]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:01.277]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:01.277]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:01.277]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:01.277]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:01.277]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:01.277]             base::names(...future.oldOptions))
[11:00:01.277]     }
[11:00:01.277]     if (FALSE) {
[11:00:01.277]     }
[11:00:01.277]     else {
[11:00:01.277]         if (TRUE) {
[11:00:01.277]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:01.277]                 open = "w")
[11:00:01.277]         }
[11:00:01.277]         else {
[11:00:01.277]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:01.277]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:01.277]         }
[11:00:01.277]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:01.277]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:01.277]             base::sink(type = "output", split = FALSE)
[11:00:01.277]             base::close(...future.stdout)
[11:00:01.277]         }, add = TRUE)
[11:00:01.277]     }
[11:00:01.277]     ...future.frame <- base::sys.nframe()
[11:00:01.277]     ...future.conditions <- base::list()
[11:00:01.277]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:01.277]     if (FALSE) {
[11:00:01.277]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:01.277]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:01.277]     }
[11:00:01.277]     ...future.result <- base::tryCatch({
[11:00:01.277]         base::withCallingHandlers({
[11:00:01.277]             ...future.value <- base::withVisible(base::local({
[11:00:01.277]                 withCallingHandlers({
[11:00:01.277]                   {
[11:00:01.277]                     do.call(function(...) {
[11:00:01.277]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.277]                       if (!identical(...future.globals.maxSize.org, 
[11:00:01.277]                         ...future.globals.maxSize)) {
[11:00:01.277]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.277]                         on.exit(options(oopts), add = TRUE)
[11:00:01.277]                       }
[11:00:01.277]                       {
[11:00:01.277]                         lapply(seq_along(...future.elements_ii), 
[11:00:01.277]                           FUN = function(jj) {
[11:00:01.277]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.277]                             ...future.FUN(...future.X_jj, ...)
[11:00:01.277]                           })
[11:00:01.277]                       }
[11:00:01.277]                     }, args = future.call.arguments)
[11:00:01.277]                   }
[11:00:01.277]                 }, immediateCondition = function(cond) {
[11:00:01.277]                   save_rds <- function (object, pathname, ...) 
[11:00:01.277]                   {
[11:00:01.277]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:01.277]                     if (file_test("-f", pathname_tmp)) {
[11:00:01.277]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.277]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:01.277]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.277]                         fi_tmp[["mtime"]])
[11:00:01.277]                     }
[11:00:01.277]                     tryCatch({
[11:00:01.277]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:01.277]                     }, error = function(ex) {
[11:00:01.277]                       msg <- conditionMessage(ex)
[11:00:01.277]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.277]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:01.277]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.277]                         fi_tmp[["mtime"]], msg)
[11:00:01.277]                       ex$message <- msg
[11:00:01.277]                       stop(ex)
[11:00:01.277]                     })
[11:00:01.277]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:01.277]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:01.277]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:01.277]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.277]                       fi <- file.info(pathname)
[11:00:01.277]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:01.277]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.277]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:01.277]                         fi[["size"]], fi[["mtime"]])
[11:00:01.277]                       stop(msg)
[11:00:01.277]                     }
[11:00:01.277]                     invisible(pathname)
[11:00:01.277]                   }
[11:00:01.277]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:01.277]                     rootPath = tempdir()) 
[11:00:01.277]                   {
[11:00:01.277]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:01.277]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:01.277]                       tmpdir = path, fileext = ".rds")
[11:00:01.277]                     save_rds(obj, file)
[11:00:01.277]                   }
[11:00:01.277]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:01.277]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.277]                   {
[11:00:01.277]                     inherits <- base::inherits
[11:00:01.277]                     invokeRestart <- base::invokeRestart
[11:00:01.277]                     is.null <- base::is.null
[11:00:01.277]                     muffled <- FALSE
[11:00:01.277]                     if (inherits(cond, "message")) {
[11:00:01.277]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:01.277]                       if (muffled) 
[11:00:01.277]                         invokeRestart("muffleMessage")
[11:00:01.277]                     }
[11:00:01.277]                     else if (inherits(cond, "warning")) {
[11:00:01.277]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:01.277]                       if (muffled) 
[11:00:01.277]                         invokeRestart("muffleWarning")
[11:00:01.277]                     }
[11:00:01.277]                     else if (inherits(cond, "condition")) {
[11:00:01.277]                       if (!is.null(pattern)) {
[11:00:01.277]                         computeRestarts <- base::computeRestarts
[11:00:01.277]                         grepl <- base::grepl
[11:00:01.277]                         restarts <- computeRestarts(cond)
[11:00:01.277]                         for (restart in restarts) {
[11:00:01.277]                           name <- restart$name
[11:00:01.277]                           if (is.null(name)) 
[11:00:01.277]                             next
[11:00:01.277]                           if (!grepl(pattern, name)) 
[11:00:01.277]                             next
[11:00:01.277]                           invokeRestart(restart)
[11:00:01.277]                           muffled <- TRUE
[11:00:01.277]                           break
[11:00:01.277]                         }
[11:00:01.277]                       }
[11:00:01.277]                     }
[11:00:01.277]                     invisible(muffled)
[11:00:01.277]                   }
[11:00:01.277]                   muffleCondition(cond)
[11:00:01.277]                 })
[11:00:01.277]             }))
[11:00:01.277]             future::FutureResult(value = ...future.value$value, 
[11:00:01.277]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.277]                   ...future.rng), globalenv = if (FALSE) 
[11:00:01.277]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:01.277]                     ...future.globalenv.names))
[11:00:01.277]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:01.277]         }, condition = base::local({
[11:00:01.277]             c <- base::c
[11:00:01.277]             inherits <- base::inherits
[11:00:01.277]             invokeRestart <- base::invokeRestart
[11:00:01.277]             length <- base::length
[11:00:01.277]             list <- base::list
[11:00:01.277]             seq.int <- base::seq.int
[11:00:01.277]             signalCondition <- base::signalCondition
[11:00:01.277]             sys.calls <- base::sys.calls
[11:00:01.277]             `[[` <- base::`[[`
[11:00:01.277]             `+` <- base::`+`
[11:00:01.277]             `<<-` <- base::`<<-`
[11:00:01.277]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:01.277]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:01.277]                   3L)]
[11:00:01.277]             }
[11:00:01.277]             function(cond) {
[11:00:01.277]                 is_error <- inherits(cond, "error")
[11:00:01.277]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:01.277]                   NULL)
[11:00:01.277]                 if (is_error) {
[11:00:01.277]                   sessionInformation <- function() {
[11:00:01.277]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:01.277]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:01.277]                       search = base::search(), system = base::Sys.info())
[11:00:01.277]                   }
[11:00:01.277]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.277]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:01.277]                     cond$call), session = sessionInformation(), 
[11:00:01.277]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:01.277]                   signalCondition(cond)
[11:00:01.277]                 }
[11:00:01.277]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:01.277]                 "immediateCondition"))) {
[11:00:01.277]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:01.277]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.277]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:01.277]                   if (TRUE && !signal) {
[11:00:01.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.277]                     {
[11:00:01.277]                       inherits <- base::inherits
[11:00:01.277]                       invokeRestart <- base::invokeRestart
[11:00:01.277]                       is.null <- base::is.null
[11:00:01.277]                       muffled <- FALSE
[11:00:01.277]                       if (inherits(cond, "message")) {
[11:00:01.277]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.277]                         if (muffled) 
[11:00:01.277]                           invokeRestart("muffleMessage")
[11:00:01.277]                       }
[11:00:01.277]                       else if (inherits(cond, "warning")) {
[11:00:01.277]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.277]                         if (muffled) 
[11:00:01.277]                           invokeRestart("muffleWarning")
[11:00:01.277]                       }
[11:00:01.277]                       else if (inherits(cond, "condition")) {
[11:00:01.277]                         if (!is.null(pattern)) {
[11:00:01.277]                           computeRestarts <- base::computeRestarts
[11:00:01.277]                           grepl <- base::grepl
[11:00:01.277]                           restarts <- computeRestarts(cond)
[11:00:01.277]                           for (restart in restarts) {
[11:00:01.277]                             name <- restart$name
[11:00:01.277]                             if (is.null(name)) 
[11:00:01.277]                               next
[11:00:01.277]                             if (!grepl(pattern, name)) 
[11:00:01.277]                               next
[11:00:01.277]                             invokeRestart(restart)
[11:00:01.277]                             muffled <- TRUE
[11:00:01.277]                             break
[11:00:01.277]                           }
[11:00:01.277]                         }
[11:00:01.277]                       }
[11:00:01.277]                       invisible(muffled)
[11:00:01.277]                     }
[11:00:01.277]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.277]                   }
[11:00:01.277]                 }
[11:00:01.277]                 else {
[11:00:01.277]                   if (TRUE) {
[11:00:01.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.277]                     {
[11:00:01.277]                       inherits <- base::inherits
[11:00:01.277]                       invokeRestart <- base::invokeRestart
[11:00:01.277]                       is.null <- base::is.null
[11:00:01.277]                       muffled <- FALSE
[11:00:01.277]                       if (inherits(cond, "message")) {
[11:00:01.277]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.277]                         if (muffled) 
[11:00:01.277]                           invokeRestart("muffleMessage")
[11:00:01.277]                       }
[11:00:01.277]                       else if (inherits(cond, "warning")) {
[11:00:01.277]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.277]                         if (muffled) 
[11:00:01.277]                           invokeRestart("muffleWarning")
[11:00:01.277]                       }
[11:00:01.277]                       else if (inherits(cond, "condition")) {
[11:00:01.277]                         if (!is.null(pattern)) {
[11:00:01.277]                           computeRestarts <- base::computeRestarts
[11:00:01.277]                           grepl <- base::grepl
[11:00:01.277]                           restarts <- computeRestarts(cond)
[11:00:01.277]                           for (restart in restarts) {
[11:00:01.277]                             name <- restart$name
[11:00:01.277]                             if (is.null(name)) 
[11:00:01.277]                               next
[11:00:01.277]                             if (!grepl(pattern, name)) 
[11:00:01.277]                               next
[11:00:01.277]                             invokeRestart(restart)
[11:00:01.277]                             muffled <- TRUE
[11:00:01.277]                             break
[11:00:01.277]                           }
[11:00:01.277]                         }
[11:00:01.277]                       }
[11:00:01.277]                       invisible(muffled)
[11:00:01.277]                     }
[11:00:01.277]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.277]                   }
[11:00:01.277]                 }
[11:00:01.277]             }
[11:00:01.277]         }))
[11:00:01.277]     }, error = function(ex) {
[11:00:01.277]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:01.277]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.277]                 ...future.rng), started = ...future.startTime, 
[11:00:01.277]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:01.277]             version = "1.8"), class = "FutureResult")
[11:00:01.277]     }, finally = {
[11:00:01.277]         if (!identical(...future.workdir, getwd())) 
[11:00:01.277]             setwd(...future.workdir)
[11:00:01.277]         {
[11:00:01.277]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:01.277]                 ...future.oldOptions$nwarnings <- NULL
[11:00:01.277]             }
[11:00:01.277]             base::options(...future.oldOptions)
[11:00:01.277]             if (.Platform$OS.type == "windows") {
[11:00:01.277]                 old_names <- names(...future.oldEnvVars)
[11:00:01.277]                 envs <- base::Sys.getenv()
[11:00:01.277]                 names <- names(envs)
[11:00:01.277]                 common <- intersect(names, old_names)
[11:00:01.277]                 added <- setdiff(names, old_names)
[11:00:01.277]                 removed <- setdiff(old_names, names)
[11:00:01.277]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:01.277]                   envs[common]]
[11:00:01.277]                 NAMES <- toupper(changed)
[11:00:01.277]                 args <- list()
[11:00:01.277]                 for (kk in seq_along(NAMES)) {
[11:00:01.277]                   name <- changed[[kk]]
[11:00:01.277]                   NAME <- NAMES[[kk]]
[11:00:01.277]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.277]                     next
[11:00:01.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.277]                 }
[11:00:01.277]                 NAMES <- toupper(added)
[11:00:01.277]                 for (kk in seq_along(NAMES)) {
[11:00:01.277]                   name <- added[[kk]]
[11:00:01.277]                   NAME <- NAMES[[kk]]
[11:00:01.277]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.277]                     next
[11:00:01.277]                   args[[name]] <- ""
[11:00:01.277]                 }
[11:00:01.277]                 NAMES <- toupper(removed)
[11:00:01.277]                 for (kk in seq_along(NAMES)) {
[11:00:01.277]                   name <- removed[[kk]]
[11:00:01.277]                   NAME <- NAMES[[kk]]
[11:00:01.277]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.277]                     next
[11:00:01.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.277]                 }
[11:00:01.277]                 if (length(args) > 0) 
[11:00:01.277]                   base::do.call(base::Sys.setenv, args = args)
[11:00:01.277]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:01.277]             }
[11:00:01.277]             else {
[11:00:01.277]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:01.277]             }
[11:00:01.277]             {
[11:00:01.277]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:01.277]                   0L) {
[11:00:01.277]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:01.277]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:01.277]                   base::options(opts)
[11:00:01.277]                 }
[11:00:01.277]                 {
[11:00:01.277]                   {
[11:00:01.277]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:01.277]                     NULL
[11:00:01.277]                   }
[11:00:01.277]                   options(future.plan = NULL)
[11:00:01.277]                   if (is.na(NA_character_)) 
[11:00:01.277]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.277]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:01.277]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:01.277]                     .init = FALSE)
[11:00:01.277]                 }
[11:00:01.277]             }
[11:00:01.277]         }
[11:00:01.277]     })
[11:00:01.277]     if (TRUE) {
[11:00:01.277]         base::sink(type = "output", split = FALSE)
[11:00:01.277]         if (TRUE) {
[11:00:01.277]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:01.277]         }
[11:00:01.277]         else {
[11:00:01.277]             ...future.result["stdout"] <- base::list(NULL)
[11:00:01.277]         }
[11:00:01.277]         base::close(...future.stdout)
[11:00:01.277]         ...future.stdout <- NULL
[11:00:01.277]     }
[11:00:01.277]     ...future.result$conditions <- ...future.conditions
[11:00:01.277]     ...future.result$finished <- base::Sys.time()
[11:00:01.277]     ...future.result
[11:00:01.277] }
[11:00:01.281] assign_globals() ...
[11:00:01.281] List of 11
[11:00:01.281]  $ ...future.FUN            :function (x, ...)  
[11:00:01.281]  $ x_FUN                    :function (x)  
[11:00:01.281]  $ times                    : int 0
[11:00:01.281]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.281]  $ stop_if_not              :function (...)  
[11:00:01.281]  $ dim                      : NULL
[11:00:01.281]  $ valid_types              : chr [1:2] "logical" "integer"
[11:00:01.281]  $ future.call.arguments    : list()
[11:00:01.281]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.281]  $ ...future.elements_ii    :List of 5
[11:00:01.281]   ..$ : int 6
[11:00:01.281]   ..$ : int 7
[11:00:01.281]   ..$ : int 8
[11:00:01.281]   ..$ : int 9
[11:00:01.281]   ..$ : int 10
[11:00:01.281]  $ ...future.seeds_ii       : NULL
[11:00:01.281]  $ ...future.globals.maxSize: NULL
[11:00:01.281]  - attr(*, "where")=List of 11
[11:00:01.281]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:01.281]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:01.281]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:01.281]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:01.281]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:01.281]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:01.281]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:01.281]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:01.281]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:01.281]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:01.281]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:01.281]  - attr(*, "resolved")= logi FALSE
[11:00:01.281]  - attr(*, "total_size")= num 23453
[11:00:01.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.281]  - attr(*, "already-done")= logi TRUE
[11:00:01.297] - copied ‘...future.FUN’ to environment
[11:00:01.297] - reassign environment for ‘x_FUN’
[11:00:01.297] - copied ‘x_FUN’ to environment
[11:00:01.297] - copied ‘times’ to environment
[11:00:01.297] - copied ‘stopf’ to environment
[11:00:01.297] - copied ‘stop_if_not’ to environment
[11:00:01.298] - copied ‘dim’ to environment
[11:00:01.298] - copied ‘valid_types’ to environment
[11:00:01.298] - copied ‘future.call.arguments’ to environment
[11:00:01.298] - copied ‘...future.elements_ii’ to environment
[11:00:01.298] - copied ‘...future.seeds_ii’ to environment
[11:00:01.298] - copied ‘...future.globals.maxSize’ to environment
[11:00:01.298] assign_globals() ... done
[11:00:01.299] requestCore(): workers = 2
[11:00:01.301] MulticoreFuture started
[11:00:01.301] - Launch lazy future ... done
[11:00:01.301] run() for ‘MulticoreFuture’ ... done
[11:00:01.302] Created future:
[11:00:01.302] plan(): Setting new future strategy stack:
[11:00:01.303] List of future strategies:
[11:00:01.303] 1. sequential:
[11:00:01.303]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:01.303]    - tweaked: FALSE
[11:00:01.303]    - call: NULL
[11:00:01.304] plan(): nbrOfWorkers() = 1
[11:00:01.306] plan(): Setting new future strategy stack:
[11:00:01.306] List of future strategies:
[11:00:01.306] 1. multicore:
[11:00:01.306]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:01.306]    - tweaked: FALSE
[11:00:01.306]    - call: plan(strategy)
[11:00:01.310] plan(): nbrOfWorkers() = 2
[11:00:01.302] MulticoreFuture:
[11:00:01.302] Label: ‘future_vapply-2’
[11:00:01.302] Expression:
[11:00:01.302] {
[11:00:01.302]     do.call(function(...) {
[11:00:01.302]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.302]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.302]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.302]             on.exit(options(oopts), add = TRUE)
[11:00:01.302]         }
[11:00:01.302]         {
[11:00:01.302]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.302]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.302]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.302]             })
[11:00:01.302]         }
[11:00:01.302]     }, args = future.call.arguments)
[11:00:01.302] }
[11:00:01.302] Lazy evaluation: FALSE
[11:00:01.302] Asynchronous evaluation: TRUE
[11:00:01.302] Local evaluation: TRUE
[11:00:01.302] Environment: R_GlobalEnv
[11:00:01.302] Capture standard output: TRUE
[11:00:01.302] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:01.302] Globals: 11 objects totaling 12.98 KiB (function ‘...future.FUN’ of 4.49 KiB, function ‘x_FUN’ of 296 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:01.302] Packages: 1 packages (‘future.apply’)
[11:00:01.302] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:01.302] Resolved: TRUE
[11:00:01.302] Value: <not collected>
[11:00:01.302] Conditions captured: <none>
[11:00:01.302] Early signaling: FALSE
[11:00:01.302] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:01.302] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.311] Chunk #2 of 2 ... DONE
[11:00:01.311] Launching 2 futures (chunks) ... DONE
[11:00:01.311] Resolving 2 futures (chunks) ...
[11:00:01.311] resolve() on list ...
[11:00:01.311]  recursive: 0
[11:00:01.312]  length: 2
[11:00:01.312] 
[11:00:01.312] Future #1
[11:00:01.312] result() for MulticoreFuture ...
[11:00:01.313] result() for MulticoreFuture ...
[11:00:01.313] result() for MulticoreFuture ... done
[11:00:01.313] result() for MulticoreFuture ... done
[11:00:01.314] result() for MulticoreFuture ...
[11:00:01.314] result() for MulticoreFuture ... done
[11:00:01.314] signalConditionsASAP(MulticoreFuture, pos=1) ...
[11:00:01.314] - nx: 2
[11:00:01.314] - relay: TRUE
[11:00:01.314] - stdout: TRUE
[11:00:01.314] - signal: TRUE
[11:00:01.315] - resignal: FALSE
[11:00:01.315] - force: TRUE
[11:00:01.315] - relayed: [n=2] FALSE, FALSE
[11:00:01.315] - queued futures: [n=2] FALSE, FALSE
[11:00:01.315]  - until=1
[11:00:01.315]  - relaying element #1
[11:00:01.316] result() for MulticoreFuture ...
[11:00:01.316] result() for MulticoreFuture ... done
[11:00:01.316] result() for MulticoreFuture ...
[11:00:01.316] result() for MulticoreFuture ... done
[11:00:01.316] result() for MulticoreFuture ...
[11:00:01.316] result() for MulticoreFuture ... done
[11:00:01.316] result() for MulticoreFuture ...
[11:00:01.317] result() for MulticoreFuture ... done
[11:00:01.317] - relayed: [n=2] TRUE, FALSE
[11:00:01.317] - queued futures: [n=2] TRUE, FALSE
[11:00:01.317] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[11:00:01.317]  length: 1 (resolved future 1)
[11:00:01.317] Future #2
[11:00:01.318] result() for MulticoreFuture ...
[11:00:01.318] result() for MulticoreFuture ...
[11:00:01.318] result() for MulticoreFuture ... done
[11:00:01.319] result() for MulticoreFuture ... done
[11:00:01.319] result() for MulticoreFuture ...
[11:00:01.319] result() for MulticoreFuture ... done
[11:00:01.319] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:00:01.319] - nx: 2
[11:00:01.319] - relay: TRUE
[11:00:01.319] - stdout: TRUE
[11:00:01.320] - signal: TRUE
[11:00:01.320] - resignal: FALSE
[11:00:01.320] - force: TRUE
[11:00:01.320] - relayed: [n=2] TRUE, FALSE
[11:00:01.320] - queued futures: [n=2] TRUE, FALSE
[11:00:01.320]  - until=2
[11:00:01.320]  - relaying element #2
[11:00:01.320] result() for MulticoreFuture ...
[11:00:01.320] result() for MulticoreFuture ... done
[11:00:01.321] result() for MulticoreFuture ...
[11:00:01.321] result() for MulticoreFuture ... done
[11:00:01.321] result() for MulticoreFuture ...
[11:00:01.321] result() for MulticoreFuture ... done
[11:00:01.321] result() for MulticoreFuture ...
[11:00:01.321] result() for MulticoreFuture ... done
[11:00:01.321] - relayed: [n=2] TRUE, TRUE
[11:00:01.321] - queued futures: [n=2] TRUE, TRUE
[11:00:01.322] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:00:01.322]  length: 0 (resolved future 2)
[11:00:01.322] Relaying remaining futures
[11:00:01.322] signalConditionsASAP(NULL, pos=0) ...
[11:00:01.322] - nx: 2
[11:00:01.322] - relay: TRUE
[11:00:01.322] - stdout: TRUE
[11:00:01.322] - signal: TRUE
[11:00:01.322] - resignal: FALSE
[11:00:01.322] - force: TRUE
[11:00:01.323] - relayed: [n=2] TRUE, TRUE
[11:00:01.323] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:01.323] - relayed: [n=2] TRUE, TRUE
[11:00:01.323] - queued futures: [n=2] TRUE, TRUE
[11:00:01.323] signalConditionsASAP(NULL, pos=0) ... done
[11:00:01.323] resolve() on list ... DONE
[11:00:01.323] result() for MulticoreFuture ...
[11:00:01.323] result() for MulticoreFuture ... done
[11:00:01.323] result() for MulticoreFuture ...
[11:00:01.324] result() for MulticoreFuture ... done
[11:00:01.324] result() for MulticoreFuture ...
[11:00:01.324] result() for MulticoreFuture ... done
[11:00:01.324] result() for MulticoreFuture ...
[11:00:01.324] result() for MulticoreFuture ... done
[11:00:01.324]  - Number of value chunks collected: 2
[11:00:01.324] Resolving 2 futures (chunks) ... DONE
[11:00:01.324] Reducing values from 2 chunks ...
[11:00:01.324]  - Number of values collected after concatenation: 10
[11:00:01.325]  - Number of values expected: 10
[11:00:01.325] Reducing values from 2 chunks ... DONE
[11:00:01.325] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[11:00:01.326] future_lapply() ...
[11:00:01.332] Number of chunks: 2
[11:00:01.332] getGlobalsAndPackagesXApply() ...
[11:00:01.332]  - future.globals: TRUE
[11:00:01.332] getGlobalsAndPackages() ...
[11:00:01.332] Searching for globals...
[11:00:01.336] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[11:00:01.337] Searching for globals ... DONE
[11:00:01.337] Resolving globals: FALSE
[11:00:01.338] The total size of the 7 globals is 12.08 KiB (12367 bytes)
[11:00:01.338] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.07 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:01.338] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:01.338] - packages: [1] ‘future.apply’
[11:00:01.339] getGlobalsAndPackages() ... DONE
[11:00:01.339]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:01.339]  - needed namespaces: [n=1] ‘future.apply’
[11:00:01.339] Finding globals ... DONE
[11:00:01.339]  - use_args: TRUE
[11:00:01.339]  - Getting '...' globals ...
[11:00:01.339] resolve() on list ...
[11:00:01.339]  recursive: 0
[11:00:01.340]  length: 1
[11:00:01.340]  elements: ‘...’
[11:00:01.340]  length: 0 (resolved future 1)
[11:00:01.340] resolve() on list ... DONE
[11:00:01.340]    - '...' content: [n=0] 
[11:00:01.340] List of 1
[11:00:01.340]  $ ...: list()
[11:00:01.340]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.340]  - attr(*, "where")=List of 1
[11:00:01.340]   ..$ ...:<environment: 0x55bbad64c968> 
[11:00:01.340]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.340]  - attr(*, "resolved")= logi TRUE
[11:00:01.340]  - attr(*, "total_size")= num NA
[11:00:01.342]  - Getting '...' globals ... DONE
[11:00:01.343] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:01.343] List of 8
[11:00:01.343]  $ ...future.FUN:function (x, ...)  
[11:00:01.343]  $ x_FUN        :function (x)  
[11:00:01.343]  $ times        : int 1
[11:00:01.343]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.343]  $ stop_if_not  :function (...)  
[11:00:01.343]  $ dim          : NULL
[11:00:01.343]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:01.343]  $ ...          : list()
[11:00:01.343]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.343]  - attr(*, "where")=List of 8
[11:00:01.343]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:01.343]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:01.343]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:01.343]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:01.343]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:01.343]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:01.343]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:01.343]   ..$ ...          :<environment: 0x55bbad64c968> 
[11:00:01.343]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.343]  - attr(*, "resolved")= logi FALSE
[11:00:01.343]  - attr(*, "total_size")= num 22322
[11:00:01.348] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:01.348] getGlobalsAndPackagesXApply() ... DONE
[11:00:01.348] Number of futures (= number of chunks): 2
[11:00:01.348] Launching 2 futures (chunks) ...
[11:00:01.348] Chunk #1 of 2 ...
[11:00:01.348]  - Finding globals in 'X' for chunk #1 ...
[11:00:01.348] getGlobalsAndPackages() ...
[11:00:01.348] Searching for globals...
[11:00:01.349] 
[11:00:01.349] Searching for globals ... DONE
[11:00:01.349] - globals: [0] <none>
[11:00:01.349] getGlobalsAndPackages() ... DONE
[11:00:01.349]    + additional globals found: [n=0] 
[11:00:01.349]    + additional namespaces needed: [n=0] 
[11:00:01.349]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:01.349]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:01.349]  - seeds: <none>
[11:00:01.349]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.350] getGlobalsAndPackages() ...
[11:00:01.350] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.350] Resolving globals: FALSE
[11:00:01.350] Tweak future expression to call with '...' arguments ...
[11:00:01.350] {
[11:00:01.350]     do.call(function(...) {
[11:00:01.350]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.350]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.350]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.350]             on.exit(options(oopts), add = TRUE)
[11:00:01.350]         }
[11:00:01.350]         {
[11:00:01.350]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.350]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.350]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.350]             })
[11:00:01.350]         }
[11:00:01.350]     }, args = future.call.arguments)
[11:00:01.350] }
[11:00:01.350] Tweak future expression to call with '...' arguments ... DONE
[11:00:01.351] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.351] - packages: [1] ‘future.apply’
[11:00:01.351] getGlobalsAndPackages() ... DONE
[11:00:01.351] run() for ‘Future’ ...
[11:00:01.351] - state: ‘created’
[11:00:01.353] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:01.354] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.354] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:01.355]   - Field: ‘label’
[11:00:01.355]   - Field: ‘local’
[11:00:01.355]   - Field: ‘owner’
[11:00:01.355]   - Field: ‘envir’
[11:00:01.355]   - Field: ‘workers’
[11:00:01.355]   - Field: ‘packages’
[11:00:01.355]   - Field: ‘gc’
[11:00:01.355]   - Field: ‘job’
[11:00:01.355]   - Field: ‘conditions’
[11:00:01.355]   - Field: ‘expr’
[11:00:01.356]   - Field: ‘uuid’
[11:00:01.356]   - Field: ‘seed’
[11:00:01.356]   - Field: ‘version’
[11:00:01.356]   - Field: ‘result’
[11:00:01.356]   - Field: ‘asynchronous’
[11:00:01.356]   - Field: ‘calls’
[11:00:01.356]   - Field: ‘globals’
[11:00:01.356]   - Field: ‘stdout’
[11:00:01.356]   - Field: ‘earlySignal’
[11:00:01.356]   - Field: ‘lazy’
[11:00:01.356]   - Field: ‘state’
[11:00:01.356] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:01.357] - Launch lazy future ...
[11:00:01.357] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:01.357] Packages needed by future strategies (n = 0): <none>
[11:00:01.357] {
[11:00:01.357]     {
[11:00:01.357]         {
[11:00:01.357]             ...future.startTime <- base::Sys.time()
[11:00:01.357]             {
[11:00:01.357]                 {
[11:00:01.357]                   {
[11:00:01.357]                     {
[11:00:01.357]                       {
[11:00:01.357]                         base::local({
[11:00:01.357]                           has_future <- base::requireNamespace("future", 
[11:00:01.357]                             quietly = TRUE)
[11:00:01.357]                           if (has_future) {
[11:00:01.357]                             ns <- base::getNamespace("future")
[11:00:01.357]                             version <- ns[[".package"]][["version"]]
[11:00:01.357]                             if (is.null(version)) 
[11:00:01.357]                               version <- utils::packageVersion("future")
[11:00:01.357]                           }
[11:00:01.357]                           else {
[11:00:01.357]                             version <- NULL
[11:00:01.357]                           }
[11:00:01.357]                           if (!has_future || version < "1.8.0") {
[11:00:01.357]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:01.357]                               "", base::R.version$version.string), 
[11:00:01.357]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:01.357]                                 base::R.version$platform, 8 * 
[11:00:01.357]                                   base::.Machine$sizeof.pointer), 
[11:00:01.357]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:01.357]                                 "release", "version")], collapse = " "), 
[11:00:01.357]                               hostname = base::Sys.info()[["nodename"]])
[11:00:01.357]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:01.357]                               info)
[11:00:01.357]                             info <- base::paste(info, collapse = "; ")
[11:00:01.357]                             if (!has_future) {
[11:00:01.357]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:01.357]                                 info)
[11:00:01.357]                             }
[11:00:01.357]                             else {
[11:00:01.357]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:01.357]                                 info, version)
[11:00:01.357]                             }
[11:00:01.357]                             base::stop(msg)
[11:00:01.357]                           }
[11:00:01.357]                         })
[11:00:01.357]                       }
[11:00:01.357]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:01.357]                       base::options(mc.cores = 1L)
[11:00:01.357]                     }
[11:00:01.357]                     base::local({
[11:00:01.357]                       for (pkg in "future.apply") {
[11:00:01.357]                         base::loadNamespace(pkg)
[11:00:01.357]                         base::library(pkg, character.only = TRUE)
[11:00:01.357]                       }
[11:00:01.357]                     })
[11:00:01.357]                   }
[11:00:01.357]                   ...future.strategy.old <- future::plan("list")
[11:00:01.357]                   options(future.plan = NULL)
[11:00:01.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:01.357]                 }
[11:00:01.357]                 ...future.workdir <- getwd()
[11:00:01.357]             }
[11:00:01.357]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:01.357]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:01.357]         }
[11:00:01.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:01.357]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:01.357]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:01.357]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:01.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:01.357]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:01.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:01.357]             base::names(...future.oldOptions))
[11:00:01.357]     }
[11:00:01.357]     if (FALSE) {
[11:00:01.357]     }
[11:00:01.357]     else {
[11:00:01.357]         if (TRUE) {
[11:00:01.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:01.357]                 open = "w")
[11:00:01.357]         }
[11:00:01.357]         else {
[11:00:01.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:01.357]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:01.357]         }
[11:00:01.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:01.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:01.357]             base::sink(type = "output", split = FALSE)
[11:00:01.357]             base::close(...future.stdout)
[11:00:01.357]         }, add = TRUE)
[11:00:01.357]     }
[11:00:01.357]     ...future.frame <- base::sys.nframe()
[11:00:01.357]     ...future.conditions <- base::list()
[11:00:01.357]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:01.357]     if (FALSE) {
[11:00:01.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:01.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:01.357]     }
[11:00:01.357]     ...future.result <- base::tryCatch({
[11:00:01.357]         base::withCallingHandlers({
[11:00:01.357]             ...future.value <- base::withVisible(base::local({
[11:00:01.357]                 withCallingHandlers({
[11:00:01.357]                   {
[11:00:01.357]                     do.call(function(...) {
[11:00:01.357]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.357]                       if (!identical(...future.globals.maxSize.org, 
[11:00:01.357]                         ...future.globals.maxSize)) {
[11:00:01.357]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.357]                         on.exit(options(oopts), add = TRUE)
[11:00:01.357]                       }
[11:00:01.357]                       {
[11:00:01.357]                         lapply(seq_along(...future.elements_ii), 
[11:00:01.357]                           FUN = function(jj) {
[11:00:01.357]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.357]                             ...future.FUN(...future.X_jj, ...)
[11:00:01.357]                           })
[11:00:01.357]                       }
[11:00:01.357]                     }, args = future.call.arguments)
[11:00:01.357]                   }
[11:00:01.357]                 }, immediateCondition = function(cond) {
[11:00:01.357]                   save_rds <- function (object, pathname, ...) 
[11:00:01.357]                   {
[11:00:01.357]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:01.357]                     if (file_test("-f", pathname_tmp)) {
[11:00:01.357]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.357]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:01.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.357]                         fi_tmp[["mtime"]])
[11:00:01.357]                     }
[11:00:01.357]                     tryCatch({
[11:00:01.357]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:01.357]                     }, error = function(ex) {
[11:00:01.357]                       msg <- conditionMessage(ex)
[11:00:01.357]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.357]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:01.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.357]                         fi_tmp[["mtime"]], msg)
[11:00:01.357]                       ex$message <- msg
[11:00:01.357]                       stop(ex)
[11:00:01.357]                     })
[11:00:01.357]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:01.357]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:01.357]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:01.357]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.357]                       fi <- file.info(pathname)
[11:00:01.357]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:01.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.357]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:01.357]                         fi[["size"]], fi[["mtime"]])
[11:00:01.357]                       stop(msg)
[11:00:01.357]                     }
[11:00:01.357]                     invisible(pathname)
[11:00:01.357]                   }
[11:00:01.357]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:01.357]                     rootPath = tempdir()) 
[11:00:01.357]                   {
[11:00:01.357]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:01.357]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:01.357]                       tmpdir = path, fileext = ".rds")
[11:00:01.357]                     save_rds(obj, file)
[11:00:01.357]                   }
[11:00:01.357]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:01.357]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.357]                   {
[11:00:01.357]                     inherits <- base::inherits
[11:00:01.357]                     invokeRestart <- base::invokeRestart
[11:00:01.357]                     is.null <- base::is.null
[11:00:01.357]                     muffled <- FALSE
[11:00:01.357]                     if (inherits(cond, "message")) {
[11:00:01.357]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:01.357]                       if (muffled) 
[11:00:01.357]                         invokeRestart("muffleMessage")
[11:00:01.357]                     }
[11:00:01.357]                     else if (inherits(cond, "warning")) {
[11:00:01.357]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:01.357]                       if (muffled) 
[11:00:01.357]                         invokeRestart("muffleWarning")
[11:00:01.357]                     }
[11:00:01.357]                     else if (inherits(cond, "condition")) {
[11:00:01.357]                       if (!is.null(pattern)) {
[11:00:01.357]                         computeRestarts <- base::computeRestarts
[11:00:01.357]                         grepl <- base::grepl
[11:00:01.357]                         restarts <- computeRestarts(cond)
[11:00:01.357]                         for (restart in restarts) {
[11:00:01.357]                           name <- restart$name
[11:00:01.357]                           if (is.null(name)) 
[11:00:01.357]                             next
[11:00:01.357]                           if (!grepl(pattern, name)) 
[11:00:01.357]                             next
[11:00:01.357]                           invokeRestart(restart)
[11:00:01.357]                           muffled <- TRUE
[11:00:01.357]                           break
[11:00:01.357]                         }
[11:00:01.357]                       }
[11:00:01.357]                     }
[11:00:01.357]                     invisible(muffled)
[11:00:01.357]                   }
[11:00:01.357]                   muffleCondition(cond)
[11:00:01.357]                 })
[11:00:01.357]             }))
[11:00:01.357]             future::FutureResult(value = ...future.value$value, 
[11:00:01.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.357]                   ...future.rng), globalenv = if (FALSE) 
[11:00:01.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:01.357]                     ...future.globalenv.names))
[11:00:01.357]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:01.357]         }, condition = base::local({
[11:00:01.357]             c <- base::c
[11:00:01.357]             inherits <- base::inherits
[11:00:01.357]             invokeRestart <- base::invokeRestart
[11:00:01.357]             length <- base::length
[11:00:01.357]             list <- base::list
[11:00:01.357]             seq.int <- base::seq.int
[11:00:01.357]             signalCondition <- base::signalCondition
[11:00:01.357]             sys.calls <- base::sys.calls
[11:00:01.357]             `[[` <- base::`[[`
[11:00:01.357]             `+` <- base::`+`
[11:00:01.357]             `<<-` <- base::`<<-`
[11:00:01.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:01.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:01.357]                   3L)]
[11:00:01.357]             }
[11:00:01.357]             function(cond) {
[11:00:01.357]                 is_error <- inherits(cond, "error")
[11:00:01.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:01.357]                   NULL)
[11:00:01.357]                 if (is_error) {
[11:00:01.357]                   sessionInformation <- function() {
[11:00:01.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:01.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:01.357]                       search = base::search(), system = base::Sys.info())
[11:00:01.357]                   }
[11:00:01.357]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:01.357]                     cond$call), session = sessionInformation(), 
[11:00:01.357]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:01.357]                   signalCondition(cond)
[11:00:01.357]                 }
[11:00:01.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:01.357]                 "immediateCondition"))) {
[11:00:01.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:01.357]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:01.357]                   if (TRUE && !signal) {
[11:00:01.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.357]                     {
[11:00:01.357]                       inherits <- base::inherits
[11:00:01.357]                       invokeRestart <- base::invokeRestart
[11:00:01.357]                       is.null <- base::is.null
[11:00:01.357]                       muffled <- FALSE
[11:00:01.357]                       if (inherits(cond, "message")) {
[11:00:01.357]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.357]                         if (muffled) 
[11:00:01.357]                           invokeRestart("muffleMessage")
[11:00:01.357]                       }
[11:00:01.357]                       else if (inherits(cond, "warning")) {
[11:00:01.357]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.357]                         if (muffled) 
[11:00:01.357]                           invokeRestart("muffleWarning")
[11:00:01.357]                       }
[11:00:01.357]                       else if (inherits(cond, "condition")) {
[11:00:01.357]                         if (!is.null(pattern)) {
[11:00:01.357]                           computeRestarts <- base::computeRestarts
[11:00:01.357]                           grepl <- base::grepl
[11:00:01.357]                           restarts <- computeRestarts(cond)
[11:00:01.357]                           for (restart in restarts) {
[11:00:01.357]                             name <- restart$name
[11:00:01.357]                             if (is.null(name)) 
[11:00:01.357]                               next
[11:00:01.357]                             if (!grepl(pattern, name)) 
[11:00:01.357]                               next
[11:00:01.357]                             invokeRestart(restart)
[11:00:01.357]                             muffled <- TRUE
[11:00:01.357]                             break
[11:00:01.357]                           }
[11:00:01.357]                         }
[11:00:01.357]                       }
[11:00:01.357]                       invisible(muffled)
[11:00:01.357]                     }
[11:00:01.357]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.357]                   }
[11:00:01.357]                 }
[11:00:01.357]                 else {
[11:00:01.357]                   if (TRUE) {
[11:00:01.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.357]                     {
[11:00:01.357]                       inherits <- base::inherits
[11:00:01.357]                       invokeRestart <- base::invokeRestart
[11:00:01.357]                       is.null <- base::is.null
[11:00:01.357]                       muffled <- FALSE
[11:00:01.357]                       if (inherits(cond, "message")) {
[11:00:01.357]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.357]                         if (muffled) 
[11:00:01.357]                           invokeRestart("muffleMessage")
[11:00:01.357]                       }
[11:00:01.357]                       else if (inherits(cond, "warning")) {
[11:00:01.357]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.357]                         if (muffled) 
[11:00:01.357]                           invokeRestart("muffleWarning")
[11:00:01.357]                       }
[11:00:01.357]                       else if (inherits(cond, "condition")) {
[11:00:01.357]                         if (!is.null(pattern)) {
[11:00:01.357]                           computeRestarts <- base::computeRestarts
[11:00:01.357]                           grepl <- base::grepl
[11:00:01.357]                           restarts <- computeRestarts(cond)
[11:00:01.357]                           for (restart in restarts) {
[11:00:01.357]                             name <- restart$name
[11:00:01.357]                             if (is.null(name)) 
[11:00:01.357]                               next
[11:00:01.357]                             if (!grepl(pattern, name)) 
[11:00:01.357]                               next
[11:00:01.357]                             invokeRestart(restart)
[11:00:01.357]                             muffled <- TRUE
[11:00:01.357]                             break
[11:00:01.357]                           }
[11:00:01.357]                         }
[11:00:01.357]                       }
[11:00:01.357]                       invisible(muffled)
[11:00:01.357]                     }
[11:00:01.357]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.357]                   }
[11:00:01.357]                 }
[11:00:01.357]             }
[11:00:01.357]         }))
[11:00:01.357]     }, error = function(ex) {
[11:00:01.357]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:01.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.357]                 ...future.rng), started = ...future.startTime, 
[11:00:01.357]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:01.357]             version = "1.8"), class = "FutureResult")
[11:00:01.357]     }, finally = {
[11:00:01.357]         if (!identical(...future.workdir, getwd())) 
[11:00:01.357]             setwd(...future.workdir)
[11:00:01.357]         {
[11:00:01.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:01.357]                 ...future.oldOptions$nwarnings <- NULL
[11:00:01.357]             }
[11:00:01.357]             base::options(...future.oldOptions)
[11:00:01.357]             if (.Platform$OS.type == "windows") {
[11:00:01.357]                 old_names <- names(...future.oldEnvVars)
[11:00:01.357]                 envs <- base::Sys.getenv()
[11:00:01.357]                 names <- names(envs)
[11:00:01.357]                 common <- intersect(names, old_names)
[11:00:01.357]                 added <- setdiff(names, old_names)
[11:00:01.357]                 removed <- setdiff(old_names, names)
[11:00:01.357]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:01.357]                   envs[common]]
[11:00:01.357]                 NAMES <- toupper(changed)
[11:00:01.357]                 args <- list()
[11:00:01.357]                 for (kk in seq_along(NAMES)) {
[11:00:01.357]                   name <- changed[[kk]]
[11:00:01.357]                   NAME <- NAMES[[kk]]
[11:00:01.357]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.357]                     next
[11:00:01.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.357]                 }
[11:00:01.357]                 NAMES <- toupper(added)
[11:00:01.357]                 for (kk in seq_along(NAMES)) {
[11:00:01.357]                   name <- added[[kk]]
[11:00:01.357]                   NAME <- NAMES[[kk]]
[11:00:01.357]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.357]                     next
[11:00:01.357]                   args[[name]] <- ""
[11:00:01.357]                 }
[11:00:01.357]                 NAMES <- toupper(removed)
[11:00:01.357]                 for (kk in seq_along(NAMES)) {
[11:00:01.357]                   name <- removed[[kk]]
[11:00:01.357]                   NAME <- NAMES[[kk]]
[11:00:01.357]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.357]                     next
[11:00:01.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.357]                 }
[11:00:01.357]                 if (length(args) > 0) 
[11:00:01.357]                   base::do.call(base::Sys.setenv, args = args)
[11:00:01.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:01.357]             }
[11:00:01.357]             else {
[11:00:01.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:01.357]             }
[11:00:01.357]             {
[11:00:01.357]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:01.357]                   0L) {
[11:00:01.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:01.357]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:01.357]                   base::options(opts)
[11:00:01.357]                 }
[11:00:01.357]                 {
[11:00:01.357]                   {
[11:00:01.357]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:01.357]                     NULL
[11:00:01.357]                   }
[11:00:01.357]                   options(future.plan = NULL)
[11:00:01.357]                   if (is.na(NA_character_)) 
[11:00:01.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:01.357]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:01.357]                     .init = FALSE)
[11:00:01.357]                 }
[11:00:01.357]             }
[11:00:01.357]         }
[11:00:01.357]     })
[11:00:01.357]     if (TRUE) {
[11:00:01.357]         base::sink(type = "output", split = FALSE)
[11:00:01.357]         if (TRUE) {
[11:00:01.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:01.357]         }
[11:00:01.357]         else {
[11:00:01.357]             ...future.result["stdout"] <- base::list(NULL)
[11:00:01.357]         }
[11:00:01.357]         base::close(...future.stdout)
[11:00:01.357]         ...future.stdout <- NULL
[11:00:01.357]     }
[11:00:01.357]     ...future.result$conditions <- ...future.conditions
[11:00:01.357]     ...future.result$finished <- base::Sys.time()
[11:00:01.357]     ...future.result
[11:00:01.357] }
[11:00:01.360] assign_globals() ...
[11:00:01.360] List of 11
[11:00:01.360]  $ ...future.FUN            :function (x, ...)  
[11:00:01.360]  $ x_FUN                    :function (x)  
[11:00:01.360]  $ times                    : int 1
[11:00:01.360]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.360]  $ stop_if_not              :function (...)  
[11:00:01.360]  $ dim                      : NULL
[11:00:01.360]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:01.360]  $ future.call.arguments    : list()
[11:00:01.360]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.360]  $ ...future.elements_ii    :List of 5
[11:00:01.360]   ..$ : int 1
[11:00:01.360]   ..$ : int 2
[11:00:01.360]   ..$ : int 3
[11:00:01.360]   ..$ : int 4
[11:00:01.360]   ..$ : int 5
[11:00:01.360]  $ ...future.seeds_ii       : NULL
[11:00:01.360]  $ ...future.globals.maxSize: NULL
[11:00:01.360]  - attr(*, "where")=List of 11
[11:00:01.360]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:01.360]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:01.360]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:01.360]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:01.360]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:01.360]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:01.360]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:01.360]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:01.360]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:01.360]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:01.360]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:01.360]  - attr(*, "resolved")= logi FALSE
[11:00:01.360]  - attr(*, "total_size")= num 22322
[11:00:01.360]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.360]  - attr(*, "already-done")= logi TRUE
[11:00:01.368] - copied ‘...future.FUN’ to environment
[11:00:01.368] - copied ‘x_FUN’ to environment
[11:00:01.368] - copied ‘times’ to environment
[11:00:01.368] - copied ‘stopf’ to environment
[11:00:01.368] - copied ‘stop_if_not’ to environment
[11:00:01.368] - copied ‘dim’ to environment
[11:00:01.368] - copied ‘valid_types’ to environment
[11:00:01.369] - copied ‘future.call.arguments’ to environment
[11:00:01.369] - copied ‘...future.elements_ii’ to environment
[11:00:01.369] - copied ‘...future.seeds_ii’ to environment
[11:00:01.369] - copied ‘...future.globals.maxSize’ to environment
[11:00:01.369] assign_globals() ... done
[11:00:01.369] requestCore(): workers = 2
[11:00:01.371] MulticoreFuture started
[11:00:01.371] - Launch lazy future ... done
[11:00:01.371] run() for ‘MulticoreFuture’ ... done
[11:00:01.372] Created future:
[11:00:01.372] plan(): Setting new future strategy stack:
[11:00:01.372] List of future strategies:
[11:00:01.372] 1. sequential:
[11:00:01.372]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:01.372]    - tweaked: FALSE
[11:00:01.372]    - call: NULL
[11:00:01.373] plan(): nbrOfWorkers() = 1
[11:00:01.375] plan(): Setting new future strategy stack:
[11:00:01.376] List of future strategies:
[11:00:01.376] 1. multicore:
[11:00:01.376]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:01.376]    - tweaked: FALSE
[11:00:01.376]    - call: plan(strategy)
[11:00:01.379] plan(): nbrOfWorkers() = 2
[11:00:01.372] MulticoreFuture:
[11:00:01.372] Label: ‘future_vapply-1’
[11:00:01.372] Expression:
[11:00:01.372] {
[11:00:01.372]     do.call(function(...) {
[11:00:01.372]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.372]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.372]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.372]             on.exit(options(oopts), add = TRUE)
[11:00:01.372]         }
[11:00:01.372]         {
[11:00:01.372]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.372]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.372]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.372]             })
[11:00:01.372]         }
[11:00:01.372]     }, args = future.call.arguments)
[11:00:01.372] }
[11:00:01.372] Lazy evaluation: FALSE
[11:00:01.372] Asynchronous evaluation: TRUE
[11:00:01.372] Local evaluation: TRUE
[11:00:01.372] Environment: R_GlobalEnv
[11:00:01.372] Capture standard output: TRUE
[11:00:01.372] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:01.372] Globals: 11 objects totaling 12.31 KiB (function ‘...future.FUN’ of 4.06 KiB, function ‘x_FUN’ of 35 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:01.372] Packages: 1 packages (‘future.apply’)
[11:00:01.372] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:01.372] Resolved: TRUE
[11:00:01.372] Value: <not collected>
[11:00:01.372] Conditions captured: <none>
[11:00:01.372] Early signaling: FALSE
[11:00:01.372] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:01.372] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.380] Chunk #1 of 2 ... DONE
[11:00:01.380] Chunk #2 of 2 ...
[11:00:01.380]  - Finding globals in 'X' for chunk #2 ...
[11:00:01.380] getGlobalsAndPackages() ...
[11:00:01.380] Searching for globals...
[11:00:01.381] 
[11:00:01.381] Searching for globals ... DONE
[11:00:01.381] - globals: [0] <none>
[11:00:01.381] getGlobalsAndPackages() ... DONE
[11:00:01.381]    + additional globals found: [n=0] 
[11:00:01.381]    + additional namespaces needed: [n=0] 
[11:00:01.381]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:01.381]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:01.382]  - seeds: <none>
[11:00:01.382]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.382] getGlobalsAndPackages() ...
[11:00:01.382] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.382] Resolving globals: FALSE
[11:00:01.382] Tweak future expression to call with '...' arguments ...
[11:00:01.383] {
[11:00:01.383]     do.call(function(...) {
[11:00:01.383]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.383]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.383]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.383]             on.exit(options(oopts), add = TRUE)
[11:00:01.383]         }
[11:00:01.383]         {
[11:00:01.383]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.383]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.383]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.383]             })
[11:00:01.383]         }
[11:00:01.383]     }, args = future.call.arguments)
[11:00:01.383] }
[11:00:01.383] Tweak future expression to call with '...' arguments ... DONE
[11:00:01.384] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.387] - packages: [1] ‘future.apply’
[11:00:01.387] getGlobalsAndPackages() ... DONE
[11:00:01.388] run() for ‘Future’ ...
[11:00:01.389] - state: ‘created’
[11:00:01.389] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:01.393] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.393] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:01.393]   - Field: ‘label’
[11:00:01.394]   - Field: ‘local’
[11:00:01.394]   - Field: ‘owner’
[11:00:01.394]   - Field: ‘envir’
[11:00:01.394]   - Field: ‘workers’
[11:00:01.395]   - Field: ‘packages’
[11:00:01.395]   - Field: ‘gc’
[11:00:01.395]   - Field: ‘job’
[11:00:01.395]   - Field: ‘conditions’
[11:00:01.395]   - Field: ‘expr’
[11:00:01.396]   - Field: ‘uuid’
[11:00:01.396]   - Field: ‘seed’
[11:00:01.396]   - Field: ‘version’
[11:00:01.396]   - Field: ‘result’
[11:00:01.396]   - Field: ‘asynchronous’
[11:00:01.397]   - Field: ‘calls’
[11:00:01.397]   - Field: ‘globals’
[11:00:01.397]   - Field: ‘stdout’
[11:00:01.397]   - Field: ‘earlySignal’
[11:00:01.397]   - Field: ‘lazy’
[11:00:01.397]   - Field: ‘state’
[11:00:01.397] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:01.398] - Launch lazy future ...
[11:00:01.398] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:01.398] Packages needed by future strategies (n = 0): <none>
[11:00:01.399] {
[11:00:01.399]     {
[11:00:01.399]         {
[11:00:01.399]             ...future.startTime <- base::Sys.time()
[11:00:01.399]             {
[11:00:01.399]                 {
[11:00:01.399]                   {
[11:00:01.399]                     {
[11:00:01.399]                       {
[11:00:01.399]                         base::local({
[11:00:01.399]                           has_future <- base::requireNamespace("future", 
[11:00:01.399]                             quietly = TRUE)
[11:00:01.399]                           if (has_future) {
[11:00:01.399]                             ns <- base::getNamespace("future")
[11:00:01.399]                             version <- ns[[".package"]][["version"]]
[11:00:01.399]                             if (is.null(version)) 
[11:00:01.399]                               version <- utils::packageVersion("future")
[11:00:01.399]                           }
[11:00:01.399]                           else {
[11:00:01.399]                             version <- NULL
[11:00:01.399]                           }
[11:00:01.399]                           if (!has_future || version < "1.8.0") {
[11:00:01.399]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:01.399]                               "", base::R.version$version.string), 
[11:00:01.399]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:01.399]                                 base::R.version$platform, 8 * 
[11:00:01.399]                                   base::.Machine$sizeof.pointer), 
[11:00:01.399]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:01.399]                                 "release", "version")], collapse = " "), 
[11:00:01.399]                               hostname = base::Sys.info()[["nodename"]])
[11:00:01.399]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:01.399]                               info)
[11:00:01.399]                             info <- base::paste(info, collapse = "; ")
[11:00:01.399]                             if (!has_future) {
[11:00:01.399]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:01.399]                                 info)
[11:00:01.399]                             }
[11:00:01.399]                             else {
[11:00:01.399]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:01.399]                                 info, version)
[11:00:01.399]                             }
[11:00:01.399]                             base::stop(msg)
[11:00:01.399]                           }
[11:00:01.399]                         })
[11:00:01.399]                       }
[11:00:01.399]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:01.399]                       base::options(mc.cores = 1L)
[11:00:01.399]                     }
[11:00:01.399]                     base::local({
[11:00:01.399]                       for (pkg in "future.apply") {
[11:00:01.399]                         base::loadNamespace(pkg)
[11:00:01.399]                         base::library(pkg, character.only = TRUE)
[11:00:01.399]                       }
[11:00:01.399]                     })
[11:00:01.399]                   }
[11:00:01.399]                   ...future.strategy.old <- future::plan("list")
[11:00:01.399]                   options(future.plan = NULL)
[11:00:01.399]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.399]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:01.399]                 }
[11:00:01.399]                 ...future.workdir <- getwd()
[11:00:01.399]             }
[11:00:01.399]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:01.399]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:01.399]         }
[11:00:01.399]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:01.399]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:01.399]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:01.399]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:01.399]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:01.399]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:01.399]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:01.399]             base::names(...future.oldOptions))
[11:00:01.399]     }
[11:00:01.399]     if (FALSE) {
[11:00:01.399]     }
[11:00:01.399]     else {
[11:00:01.399]         if (TRUE) {
[11:00:01.399]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:01.399]                 open = "w")
[11:00:01.399]         }
[11:00:01.399]         else {
[11:00:01.399]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:01.399]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:01.399]         }
[11:00:01.399]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:01.399]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:01.399]             base::sink(type = "output", split = FALSE)
[11:00:01.399]             base::close(...future.stdout)
[11:00:01.399]         }, add = TRUE)
[11:00:01.399]     }
[11:00:01.399]     ...future.frame <- base::sys.nframe()
[11:00:01.399]     ...future.conditions <- base::list()
[11:00:01.399]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:01.399]     if (FALSE) {
[11:00:01.399]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:01.399]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:01.399]     }
[11:00:01.399]     ...future.result <- base::tryCatch({
[11:00:01.399]         base::withCallingHandlers({
[11:00:01.399]             ...future.value <- base::withVisible(base::local({
[11:00:01.399]                 withCallingHandlers({
[11:00:01.399]                   {
[11:00:01.399]                     do.call(function(...) {
[11:00:01.399]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.399]                       if (!identical(...future.globals.maxSize.org, 
[11:00:01.399]                         ...future.globals.maxSize)) {
[11:00:01.399]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.399]                         on.exit(options(oopts), add = TRUE)
[11:00:01.399]                       }
[11:00:01.399]                       {
[11:00:01.399]                         lapply(seq_along(...future.elements_ii), 
[11:00:01.399]                           FUN = function(jj) {
[11:00:01.399]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.399]                             ...future.FUN(...future.X_jj, ...)
[11:00:01.399]                           })
[11:00:01.399]                       }
[11:00:01.399]                     }, args = future.call.arguments)
[11:00:01.399]                   }
[11:00:01.399]                 }, immediateCondition = function(cond) {
[11:00:01.399]                   save_rds <- function (object, pathname, ...) 
[11:00:01.399]                   {
[11:00:01.399]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:01.399]                     if (file_test("-f", pathname_tmp)) {
[11:00:01.399]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.399]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:01.399]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.399]                         fi_tmp[["mtime"]])
[11:00:01.399]                     }
[11:00:01.399]                     tryCatch({
[11:00:01.399]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:01.399]                     }, error = function(ex) {
[11:00:01.399]                       msg <- conditionMessage(ex)
[11:00:01.399]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.399]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:01.399]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.399]                         fi_tmp[["mtime"]], msg)
[11:00:01.399]                       ex$message <- msg
[11:00:01.399]                       stop(ex)
[11:00:01.399]                     })
[11:00:01.399]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:01.399]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:01.399]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:01.399]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.399]                       fi <- file.info(pathname)
[11:00:01.399]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:01.399]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.399]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:01.399]                         fi[["size"]], fi[["mtime"]])
[11:00:01.399]                       stop(msg)
[11:00:01.399]                     }
[11:00:01.399]                     invisible(pathname)
[11:00:01.399]                   }
[11:00:01.399]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:01.399]                     rootPath = tempdir()) 
[11:00:01.399]                   {
[11:00:01.399]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:01.399]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:01.399]                       tmpdir = path, fileext = ".rds")
[11:00:01.399]                     save_rds(obj, file)
[11:00:01.399]                   }
[11:00:01.399]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:01.399]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.399]                   {
[11:00:01.399]                     inherits <- base::inherits
[11:00:01.399]                     invokeRestart <- base::invokeRestart
[11:00:01.399]                     is.null <- base::is.null
[11:00:01.399]                     muffled <- FALSE
[11:00:01.399]                     if (inherits(cond, "message")) {
[11:00:01.399]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:01.399]                       if (muffled) 
[11:00:01.399]                         invokeRestart("muffleMessage")
[11:00:01.399]                     }
[11:00:01.399]                     else if (inherits(cond, "warning")) {
[11:00:01.399]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:01.399]                       if (muffled) 
[11:00:01.399]                         invokeRestart("muffleWarning")
[11:00:01.399]                     }
[11:00:01.399]                     else if (inherits(cond, "condition")) {
[11:00:01.399]                       if (!is.null(pattern)) {
[11:00:01.399]                         computeRestarts <- base::computeRestarts
[11:00:01.399]                         grepl <- base::grepl
[11:00:01.399]                         restarts <- computeRestarts(cond)
[11:00:01.399]                         for (restart in restarts) {
[11:00:01.399]                           name <- restart$name
[11:00:01.399]                           if (is.null(name)) 
[11:00:01.399]                             next
[11:00:01.399]                           if (!grepl(pattern, name)) 
[11:00:01.399]                             next
[11:00:01.399]                           invokeRestart(restart)
[11:00:01.399]                           muffled <- TRUE
[11:00:01.399]                           break
[11:00:01.399]                         }
[11:00:01.399]                       }
[11:00:01.399]                     }
[11:00:01.399]                     invisible(muffled)
[11:00:01.399]                   }
[11:00:01.399]                   muffleCondition(cond)
[11:00:01.399]                 })
[11:00:01.399]             }))
[11:00:01.399]             future::FutureResult(value = ...future.value$value, 
[11:00:01.399]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.399]                   ...future.rng), globalenv = if (FALSE) 
[11:00:01.399]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:01.399]                     ...future.globalenv.names))
[11:00:01.399]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:01.399]         }, condition = base::local({
[11:00:01.399]             c <- base::c
[11:00:01.399]             inherits <- base::inherits
[11:00:01.399]             invokeRestart <- base::invokeRestart
[11:00:01.399]             length <- base::length
[11:00:01.399]             list <- base::list
[11:00:01.399]             seq.int <- base::seq.int
[11:00:01.399]             signalCondition <- base::signalCondition
[11:00:01.399]             sys.calls <- base::sys.calls
[11:00:01.399]             `[[` <- base::`[[`
[11:00:01.399]             `+` <- base::`+`
[11:00:01.399]             `<<-` <- base::`<<-`
[11:00:01.399]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:01.399]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:01.399]                   3L)]
[11:00:01.399]             }
[11:00:01.399]             function(cond) {
[11:00:01.399]                 is_error <- inherits(cond, "error")
[11:00:01.399]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:01.399]                   NULL)
[11:00:01.399]                 if (is_error) {
[11:00:01.399]                   sessionInformation <- function() {
[11:00:01.399]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:01.399]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:01.399]                       search = base::search(), system = base::Sys.info())
[11:00:01.399]                   }
[11:00:01.399]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.399]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:01.399]                     cond$call), session = sessionInformation(), 
[11:00:01.399]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:01.399]                   signalCondition(cond)
[11:00:01.399]                 }
[11:00:01.399]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:01.399]                 "immediateCondition"))) {
[11:00:01.399]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:01.399]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.399]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:01.399]                   if (TRUE && !signal) {
[11:00:01.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.399]                     {
[11:00:01.399]                       inherits <- base::inherits
[11:00:01.399]                       invokeRestart <- base::invokeRestart
[11:00:01.399]                       is.null <- base::is.null
[11:00:01.399]                       muffled <- FALSE
[11:00:01.399]                       if (inherits(cond, "message")) {
[11:00:01.399]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.399]                         if (muffled) 
[11:00:01.399]                           invokeRestart("muffleMessage")
[11:00:01.399]                       }
[11:00:01.399]                       else if (inherits(cond, "warning")) {
[11:00:01.399]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.399]                         if (muffled) 
[11:00:01.399]                           invokeRestart("muffleWarning")
[11:00:01.399]                       }
[11:00:01.399]                       else if (inherits(cond, "condition")) {
[11:00:01.399]                         if (!is.null(pattern)) {
[11:00:01.399]                           computeRestarts <- base::computeRestarts
[11:00:01.399]                           grepl <- base::grepl
[11:00:01.399]                           restarts <- computeRestarts(cond)
[11:00:01.399]                           for (restart in restarts) {
[11:00:01.399]                             name <- restart$name
[11:00:01.399]                             if (is.null(name)) 
[11:00:01.399]                               next
[11:00:01.399]                             if (!grepl(pattern, name)) 
[11:00:01.399]                               next
[11:00:01.399]                             invokeRestart(restart)
[11:00:01.399]                             muffled <- TRUE
[11:00:01.399]                             break
[11:00:01.399]                           }
[11:00:01.399]                         }
[11:00:01.399]                       }
[11:00:01.399]                       invisible(muffled)
[11:00:01.399]                     }
[11:00:01.399]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.399]                   }
[11:00:01.399]                 }
[11:00:01.399]                 else {
[11:00:01.399]                   if (TRUE) {
[11:00:01.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.399]                     {
[11:00:01.399]                       inherits <- base::inherits
[11:00:01.399]                       invokeRestart <- base::invokeRestart
[11:00:01.399]                       is.null <- base::is.null
[11:00:01.399]                       muffled <- FALSE
[11:00:01.399]                       if (inherits(cond, "message")) {
[11:00:01.399]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.399]                         if (muffled) 
[11:00:01.399]                           invokeRestart("muffleMessage")
[11:00:01.399]                       }
[11:00:01.399]                       else if (inherits(cond, "warning")) {
[11:00:01.399]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.399]                         if (muffled) 
[11:00:01.399]                           invokeRestart("muffleWarning")
[11:00:01.399]                       }
[11:00:01.399]                       else if (inherits(cond, "condition")) {
[11:00:01.399]                         if (!is.null(pattern)) {
[11:00:01.399]                           computeRestarts <- base::computeRestarts
[11:00:01.399]                           grepl <- base::grepl
[11:00:01.399]                           restarts <- computeRestarts(cond)
[11:00:01.399]                           for (restart in restarts) {
[11:00:01.399]                             name <- restart$name
[11:00:01.399]                             if (is.null(name)) 
[11:00:01.399]                               next
[11:00:01.399]                             if (!grepl(pattern, name)) 
[11:00:01.399]                               next
[11:00:01.399]                             invokeRestart(restart)
[11:00:01.399]                             muffled <- TRUE
[11:00:01.399]                             break
[11:00:01.399]                           }
[11:00:01.399]                         }
[11:00:01.399]                       }
[11:00:01.399]                       invisible(muffled)
[11:00:01.399]                     }
[11:00:01.399]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.399]                   }
[11:00:01.399]                 }
[11:00:01.399]             }
[11:00:01.399]         }))
[11:00:01.399]     }, error = function(ex) {
[11:00:01.399]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:01.399]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.399]                 ...future.rng), started = ...future.startTime, 
[11:00:01.399]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:01.399]             version = "1.8"), class = "FutureResult")
[11:00:01.399]     }, finally = {
[11:00:01.399]         if (!identical(...future.workdir, getwd())) 
[11:00:01.399]             setwd(...future.workdir)
[11:00:01.399]         {
[11:00:01.399]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:01.399]                 ...future.oldOptions$nwarnings <- NULL
[11:00:01.399]             }
[11:00:01.399]             base::options(...future.oldOptions)
[11:00:01.399]             if (.Platform$OS.type == "windows") {
[11:00:01.399]                 old_names <- names(...future.oldEnvVars)
[11:00:01.399]                 envs <- base::Sys.getenv()
[11:00:01.399]                 names <- names(envs)
[11:00:01.399]                 common <- intersect(names, old_names)
[11:00:01.399]                 added <- setdiff(names, old_names)
[11:00:01.399]                 removed <- setdiff(old_names, names)
[11:00:01.399]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:01.399]                   envs[common]]
[11:00:01.399]                 NAMES <- toupper(changed)
[11:00:01.399]                 args <- list()
[11:00:01.399]                 for (kk in seq_along(NAMES)) {
[11:00:01.399]                   name <- changed[[kk]]
[11:00:01.399]                   NAME <- NAMES[[kk]]
[11:00:01.399]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.399]                     next
[11:00:01.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.399]                 }
[11:00:01.399]                 NAMES <- toupper(added)
[11:00:01.399]                 for (kk in seq_along(NAMES)) {
[11:00:01.399]                   name <- added[[kk]]
[11:00:01.399]                   NAME <- NAMES[[kk]]
[11:00:01.399]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.399]                     next
[11:00:01.399]                   args[[name]] <- ""
[11:00:01.399]                 }
[11:00:01.399]                 NAMES <- toupper(removed)
[11:00:01.399]                 for (kk in seq_along(NAMES)) {
[11:00:01.399]                   name <- removed[[kk]]
[11:00:01.399]                   NAME <- NAMES[[kk]]
[11:00:01.399]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.399]                     next
[11:00:01.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.399]                 }
[11:00:01.399]                 if (length(args) > 0) 
[11:00:01.399]                   base::do.call(base::Sys.setenv, args = args)
[11:00:01.399]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:01.399]             }
[11:00:01.399]             else {
[11:00:01.399]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:01.399]             }
[11:00:01.399]             {
[11:00:01.399]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:01.399]                   0L) {
[11:00:01.399]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:01.399]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:01.399]                   base::options(opts)
[11:00:01.399]                 }
[11:00:01.399]                 {
[11:00:01.399]                   {
[11:00:01.399]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:01.399]                     NULL
[11:00:01.399]                   }
[11:00:01.399]                   options(future.plan = NULL)
[11:00:01.399]                   if (is.na(NA_character_)) 
[11:00:01.399]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.399]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:01.399]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:01.399]                     .init = FALSE)
[11:00:01.399]                 }
[11:00:01.399]             }
[11:00:01.399]         }
[11:00:01.399]     })
[11:00:01.399]     if (TRUE) {
[11:00:01.399]         base::sink(type = "output", split = FALSE)
[11:00:01.399]         if (TRUE) {
[11:00:01.399]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:01.399]         }
[11:00:01.399]         else {
[11:00:01.399]             ...future.result["stdout"] <- base::list(NULL)
[11:00:01.399]         }
[11:00:01.399]         base::close(...future.stdout)
[11:00:01.399]         ...future.stdout <- NULL
[11:00:01.399]     }
[11:00:01.399]     ...future.result$conditions <- ...future.conditions
[11:00:01.399]     ...future.result$finished <- base::Sys.time()
[11:00:01.399]     ...future.result
[11:00:01.399] }
[11:00:01.402] assign_globals() ...
[11:00:01.402] List of 11
[11:00:01.402]  $ ...future.FUN            :function (x, ...)  
[11:00:01.402]  $ x_FUN                    :function (x)  
[11:00:01.402]  $ times                    : int 1
[11:00:01.402]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.402]  $ stop_if_not              :function (...)  
[11:00:01.402]  $ dim                      : NULL
[11:00:01.402]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:01.402]  $ future.call.arguments    : list()
[11:00:01.402]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.402]  $ ...future.elements_ii    :List of 5
[11:00:01.402]   ..$ : int 6
[11:00:01.402]   ..$ : int 7
[11:00:01.402]   ..$ : int 8
[11:00:01.402]   ..$ : int 9
[11:00:01.402]   ..$ : int 10
[11:00:01.402]  $ ...future.seeds_ii       : NULL
[11:00:01.402]  $ ...future.globals.maxSize: NULL
[11:00:01.402]  - attr(*, "where")=List of 11
[11:00:01.402]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:01.402]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:01.402]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:01.402]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:01.402]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:01.402]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:01.402]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:01.402]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:01.402]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:01.402]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:01.402]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:01.402]  - attr(*, "resolved")= logi FALSE
[11:00:01.402]  - attr(*, "total_size")= num 22322
[11:00:01.402]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.402]  - attr(*, "already-done")= logi TRUE
[11:00:01.413] - copied ‘...future.FUN’ to environment
[11:00:01.413] - copied ‘x_FUN’ to environment
[11:00:01.413] - copied ‘times’ to environment
[11:00:01.413] - copied ‘stopf’ to environment
[11:00:01.413] - copied ‘stop_if_not’ to environment
[11:00:01.413] - copied ‘dim’ to environment
[11:00:01.414] - copied ‘valid_types’ to environment
[11:00:01.414] - copied ‘future.call.arguments’ to environment
[11:00:01.414] - copied ‘...future.elements_ii’ to environment
[11:00:01.414] - copied ‘...future.seeds_ii’ to environment
[11:00:01.414] - copied ‘...future.globals.maxSize’ to environment
[11:00:01.414] assign_globals() ... done
[11:00:01.414] requestCore(): workers = 2
[11:00:01.416] MulticoreFuture started
[11:00:01.417] - Launch lazy future ... done
[11:00:01.417] run() for ‘MulticoreFuture’ ... done
[11:00:01.417] Created future:
[11:00:01.418] plan(): Setting new future strategy stack:
[11:00:01.418] List of future strategies:
[11:00:01.418] 1. sequential:
[11:00:01.418]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:01.418]    - tweaked: FALSE
[11:00:01.418]    - call: NULL
[11:00:01.419] plan(): nbrOfWorkers() = 1
[11:00:01.421] plan(): Setting new future strategy stack:
[11:00:01.421] List of future strategies:
[11:00:01.421] 1. multicore:
[11:00:01.421]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:01.421]    - tweaked: FALSE
[11:00:01.421]    - call: plan(strategy)
[11:00:01.424] plan(): nbrOfWorkers() = 2
[11:00:01.417] MulticoreFuture:
[11:00:01.417] Label: ‘future_vapply-2’
[11:00:01.417] Expression:
[11:00:01.417] {
[11:00:01.417]     do.call(function(...) {
[11:00:01.417]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.417]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.417]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.417]             on.exit(options(oopts), add = TRUE)
[11:00:01.417]         }
[11:00:01.417]         {
[11:00:01.417]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.417]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.417]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.417]             })
[11:00:01.417]         }
[11:00:01.417]     }, args = future.call.arguments)
[11:00:01.417] }
[11:00:01.417] Lazy evaluation: FALSE
[11:00:01.417] Asynchronous evaluation: TRUE
[11:00:01.417] Local evaluation: TRUE
[11:00:01.417] Environment: R_GlobalEnv
[11:00:01.417] Capture standard output: TRUE
[11:00:01.417] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:01.417] Globals: 11 objects totaling 12.31 KiB (function ‘...future.FUN’ of 4.06 KiB, function ‘x_FUN’ of 35 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:01.417] Packages: 1 packages (‘future.apply’)
[11:00:01.417] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:01.417] Resolved: TRUE
[11:00:01.417] Value: <not collected>
[11:00:01.417] Conditions captured: <none>
[11:00:01.417] Early signaling: FALSE
[11:00:01.417] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:01.417] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.425] Chunk #2 of 2 ... DONE
[11:00:01.425] Launching 2 futures (chunks) ... DONE
[11:00:01.425] Resolving 2 futures (chunks) ...
[11:00:01.426] resolve() on list ...
[11:00:01.426]  recursive: 0
[11:00:01.426]  length: 2
[11:00:01.426] 
[11:00:01.426] Future #1
[11:00:01.426] result() for MulticoreFuture ...
[11:00:01.427] result() for MulticoreFuture ...
[11:00:01.427] result() for MulticoreFuture ... done
[11:00:01.428] result() for MulticoreFuture ... done
[11:00:01.428] result() for MulticoreFuture ...
[11:00:01.428] result() for MulticoreFuture ... done
[11:00:01.428] signalConditionsASAP(MulticoreFuture, pos=1) ...
[11:00:01.428] - nx: 2
[11:00:01.428] - relay: TRUE
[11:00:01.428] - stdout: TRUE
[11:00:01.429] - signal: TRUE
[11:00:01.432] - resignal: FALSE
[11:00:01.432] - force: TRUE
[11:00:01.432] - relayed: [n=2] FALSE, FALSE
[11:00:01.433] - queued futures: [n=2] FALSE, FALSE
[11:00:01.433]  - until=1
[11:00:01.433]  - relaying element #1
[11:00:01.434] result() for MulticoreFuture ...
[11:00:01.434] result() for MulticoreFuture ... done
[11:00:01.434] result() for MulticoreFuture ...
[11:00:01.435] result() for MulticoreFuture ... done
[11:00:01.435] result() for MulticoreFuture ...
[11:00:01.435] result() for MulticoreFuture ... done
[11:00:01.436] result() for MulticoreFuture ...
[11:00:01.436] result() for MulticoreFuture ... done
[11:00:01.436] - relayed: [n=2] TRUE, FALSE
[11:00:01.436] - queued futures: [n=2] TRUE, FALSE
[11:00:01.437] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[11:00:01.437]  length: 1 (resolved future 1)
[11:00:01.437] Future #2
[11:00:01.438] result() for MulticoreFuture ...
[11:00:01.439] result() for MulticoreFuture ...
[11:00:01.439] result() for MulticoreFuture ... done
[11:00:01.439] result() for MulticoreFuture ... done
[11:00:01.439] result() for MulticoreFuture ...
[11:00:01.440] result() for MulticoreFuture ... done
[11:00:01.440] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:00:01.440] - nx: 2
[11:00:01.440] - relay: TRUE
[11:00:01.440] - stdout: TRUE
[11:00:01.440] - signal: TRUE
[11:00:01.441] - resignal: FALSE
[11:00:01.441] - force: TRUE
[11:00:01.441] - relayed: [n=2] TRUE, FALSE
[11:00:01.441] - queued futures: [n=2] TRUE, FALSE
[11:00:01.441]  - until=2
[11:00:01.441]  - relaying element #2
[11:00:01.441] result() for MulticoreFuture ...
[11:00:01.441] result() for MulticoreFuture ... done
[11:00:01.442] result() for MulticoreFuture ...
[11:00:01.442] result() for MulticoreFuture ... done
[11:00:01.442] result() for MulticoreFuture ...
[11:00:01.442] result() for MulticoreFuture ... done
[11:00:01.442] result() for MulticoreFuture ...
[11:00:01.442] result() for MulticoreFuture ... done
[11:00:01.442] - relayed: [n=2] TRUE, TRUE
[11:00:01.442] - queued futures: [n=2] TRUE, TRUE
[11:00:01.442] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:00:01.443]  length: 0 (resolved future 2)
[11:00:01.443] Relaying remaining futures
[11:00:01.443] signalConditionsASAP(NULL, pos=0) ...
[11:00:01.443] - nx: 2
[11:00:01.443] - relay: TRUE
[11:00:01.443] - stdout: TRUE
[11:00:01.443] - signal: TRUE
[11:00:01.443] - resignal: FALSE
[11:00:01.443] - force: TRUE
[11:00:01.443] - relayed: [n=2] TRUE, TRUE
[11:00:01.444] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:01.444] - relayed: [n=2] TRUE, TRUE
[11:00:01.444] - queued futures: [n=2] TRUE, TRUE
[11:00:01.444] signalConditionsASAP(NULL, pos=0) ... done
[11:00:01.444] resolve() on list ... DONE
[11:00:01.444] result() for MulticoreFuture ...
[11:00:01.444] result() for MulticoreFuture ... done
[11:00:01.444] result() for MulticoreFuture ...
[11:00:01.444] result() for MulticoreFuture ... done
[11:00:01.445] result() for MulticoreFuture ...
[11:00:01.445] result() for MulticoreFuture ... done
[11:00:01.445] result() for MulticoreFuture ...
[11:00:01.445] result() for MulticoreFuture ... done
[11:00:01.445]  - Number of value chunks collected: 2
[11:00:01.445] Resolving 2 futures (chunks) ... DONE
[11:00:01.445] Reducing values from 2 chunks ...
[11:00:01.445]  - Number of values collected after concatenation: 10
[11:00:01.445]  - Number of values expected: 10
[11:00:01.446] Reducing values from 2 chunks ... DONE
[11:00:01.446] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[11:00:01.447] future_lapply() ...
[11:00:01.450] Number of chunks: 2
[11:00:01.450] getGlobalsAndPackagesXApply() ...
[11:00:01.451]  - future.globals: TRUE
[11:00:01.451] getGlobalsAndPackages() ...
[11:00:01.451] Searching for globals...
[11:00:01.455] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[11:00:01.455] Searching for globals ... DONE
[11:00:01.455] Resolving globals: FALSE
[11:00:01.456] The total size of the 7 globals is 13.34 KiB (13657 bytes)
[11:00:01.456] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.89 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:01.456] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:01.456] - packages: [1] ‘future.apply’
[11:00:01.457] getGlobalsAndPackages() ... DONE
[11:00:01.457]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:01.457]  - needed namespaces: [n=1] ‘future.apply’
[11:00:01.457] Finding globals ... DONE
[11:00:01.457]  - use_args: TRUE
[11:00:01.457]  - Getting '...' globals ...
[11:00:01.457] resolve() on list ...
[11:00:01.457]  recursive: 0
[11:00:01.458]  length: 1
[11:00:01.458]  elements: ‘...’
[11:00:01.458]  length: 0 (resolved future 1)
[11:00:01.458] resolve() on list ... DONE
[11:00:01.458]    - '...' content: [n=0] 
[11:00:01.458] List of 1
[11:00:01.458]  $ ...: list()
[11:00:01.458]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.458]  - attr(*, "where")=List of 1
[11:00:01.458]   ..$ ...:<environment: 0x55bbab7592c8> 
[11:00:01.458]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.458]  - attr(*, "resolved")= logi TRUE
[11:00:01.458]  - attr(*, "total_size")= num NA
[11:00:01.462]  - Getting '...' globals ... DONE
[11:00:01.462] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:01.462] List of 8
[11:00:01.462]  $ ...future.FUN:function (x, ...)  
[11:00:01.462]  $ x_FUN        :function (x)  
[11:00:01.462]  $ times        : int 2
[11:00:01.462]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.462]  $ stop_if_not  :function (...)  
[11:00:01.462]  $ dim          : NULL
[11:00:01.462]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:01.462]  $ ...          : list()
[11:00:01.462]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.462]  - attr(*, "where")=List of 8
[11:00:01.462]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:01.462]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:01.462]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:01.462]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:01.462]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:01.462]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:01.462]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:01.462]   ..$ ...          :<environment: 0x55bbab7592c8> 
[11:00:01.462]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.462]  - attr(*, "resolved")= logi FALSE
[11:00:01.462]  - attr(*, "total_size")= num 24454
[11:00:01.468] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:01.468] getGlobalsAndPackagesXApply() ... DONE
[11:00:01.468] Number of futures (= number of chunks): 2
[11:00:01.468] Launching 2 futures (chunks) ...
[11:00:01.468] Chunk #1 of 2 ...
[11:00:01.468]  - Finding globals in 'X' for chunk #1 ...
[11:00:01.468] getGlobalsAndPackages() ...
[11:00:01.468] Searching for globals...
[11:00:01.469] 
[11:00:01.469] Searching for globals ... DONE
[11:00:01.469] - globals: [0] <none>
[11:00:01.469] getGlobalsAndPackages() ... DONE
[11:00:01.469]    + additional globals found: [n=0] 
[11:00:01.469]    + additional namespaces needed: [n=0] 
[11:00:01.469]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:01.469]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:01.469]  - seeds: <none>
[11:00:01.469]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.470] getGlobalsAndPackages() ...
[11:00:01.470] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.470] Resolving globals: FALSE
[11:00:01.470] Tweak future expression to call with '...' arguments ...
[11:00:01.470] {
[11:00:01.470]     do.call(function(...) {
[11:00:01.470]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.470]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.470]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.470]             on.exit(options(oopts), add = TRUE)
[11:00:01.470]         }
[11:00:01.470]         {
[11:00:01.470]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.470]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.470]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.470]             })
[11:00:01.470]         }
[11:00:01.470]     }, args = future.call.arguments)
[11:00:01.470] }
[11:00:01.470] Tweak future expression to call with '...' arguments ... DONE
[11:00:01.471] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.471] - packages: [1] ‘future.apply’
[11:00:01.471] getGlobalsAndPackages() ... DONE
[11:00:01.471] run() for ‘Future’ ...
[11:00:01.471] - state: ‘created’
[11:00:01.471] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:01.473] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.473] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:01.473]   - Field: ‘label’
[11:00:01.473]   - Field: ‘local’
[11:00:01.473]   - Field: ‘owner’
[11:00:01.473]   - Field: ‘envir’
[11:00:01.474]   - Field: ‘workers’
[11:00:01.474]   - Field: ‘packages’
[11:00:01.474]   - Field: ‘gc’
[11:00:01.474]   - Field: ‘job’
[11:00:01.474]   - Field: ‘conditions’
[11:00:01.474]   - Field: ‘expr’
[11:00:01.474]   - Field: ‘uuid’
[11:00:01.474]   - Field: ‘seed’
[11:00:01.474]   - Field: ‘version’
[11:00:01.474]   - Field: ‘result’
[11:00:01.474]   - Field: ‘asynchronous’
[11:00:01.474]   - Field: ‘calls’
[11:00:01.475]   - Field: ‘globals’
[11:00:01.475]   - Field: ‘stdout’
[11:00:01.475]   - Field: ‘earlySignal’
[11:00:01.475]   - Field: ‘lazy’
[11:00:01.475]   - Field: ‘state’
[11:00:01.475] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:01.475] - Launch lazy future ...
[11:00:01.475] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:01.475] Packages needed by future strategies (n = 0): <none>
[11:00:01.476] {
[11:00:01.476]     {
[11:00:01.476]         {
[11:00:01.476]             ...future.startTime <- base::Sys.time()
[11:00:01.476]             {
[11:00:01.476]                 {
[11:00:01.476]                   {
[11:00:01.476]                     {
[11:00:01.476]                       {
[11:00:01.476]                         base::local({
[11:00:01.476]                           has_future <- base::requireNamespace("future", 
[11:00:01.476]                             quietly = TRUE)
[11:00:01.476]                           if (has_future) {
[11:00:01.476]                             ns <- base::getNamespace("future")
[11:00:01.476]                             version <- ns[[".package"]][["version"]]
[11:00:01.476]                             if (is.null(version)) 
[11:00:01.476]                               version <- utils::packageVersion("future")
[11:00:01.476]                           }
[11:00:01.476]                           else {
[11:00:01.476]                             version <- NULL
[11:00:01.476]                           }
[11:00:01.476]                           if (!has_future || version < "1.8.0") {
[11:00:01.476]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:01.476]                               "", base::R.version$version.string), 
[11:00:01.476]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:01.476]                                 base::R.version$platform, 8 * 
[11:00:01.476]                                   base::.Machine$sizeof.pointer), 
[11:00:01.476]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:01.476]                                 "release", "version")], collapse = " "), 
[11:00:01.476]                               hostname = base::Sys.info()[["nodename"]])
[11:00:01.476]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:01.476]                               info)
[11:00:01.476]                             info <- base::paste(info, collapse = "; ")
[11:00:01.476]                             if (!has_future) {
[11:00:01.476]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:01.476]                                 info)
[11:00:01.476]                             }
[11:00:01.476]                             else {
[11:00:01.476]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:01.476]                                 info, version)
[11:00:01.476]                             }
[11:00:01.476]                             base::stop(msg)
[11:00:01.476]                           }
[11:00:01.476]                         })
[11:00:01.476]                       }
[11:00:01.476]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:01.476]                       base::options(mc.cores = 1L)
[11:00:01.476]                     }
[11:00:01.476]                     base::local({
[11:00:01.476]                       for (pkg in "future.apply") {
[11:00:01.476]                         base::loadNamespace(pkg)
[11:00:01.476]                         base::library(pkg, character.only = TRUE)
[11:00:01.476]                       }
[11:00:01.476]                     })
[11:00:01.476]                   }
[11:00:01.476]                   ...future.strategy.old <- future::plan("list")
[11:00:01.476]                   options(future.plan = NULL)
[11:00:01.476]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.476]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:01.476]                 }
[11:00:01.476]                 ...future.workdir <- getwd()
[11:00:01.476]             }
[11:00:01.476]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:01.476]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:01.476]         }
[11:00:01.476]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:01.476]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:01.476]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:01.476]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:01.476]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:01.476]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:01.476]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:01.476]             base::names(...future.oldOptions))
[11:00:01.476]     }
[11:00:01.476]     if (FALSE) {
[11:00:01.476]     }
[11:00:01.476]     else {
[11:00:01.476]         if (TRUE) {
[11:00:01.476]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:01.476]                 open = "w")
[11:00:01.476]         }
[11:00:01.476]         else {
[11:00:01.476]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:01.476]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:01.476]         }
[11:00:01.476]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:01.476]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:01.476]             base::sink(type = "output", split = FALSE)
[11:00:01.476]             base::close(...future.stdout)
[11:00:01.476]         }, add = TRUE)
[11:00:01.476]     }
[11:00:01.476]     ...future.frame <- base::sys.nframe()
[11:00:01.476]     ...future.conditions <- base::list()
[11:00:01.476]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:01.476]     if (FALSE) {
[11:00:01.476]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:01.476]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:01.476]     }
[11:00:01.476]     ...future.result <- base::tryCatch({
[11:00:01.476]         base::withCallingHandlers({
[11:00:01.476]             ...future.value <- base::withVisible(base::local({
[11:00:01.476]                 withCallingHandlers({
[11:00:01.476]                   {
[11:00:01.476]                     do.call(function(...) {
[11:00:01.476]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.476]                       if (!identical(...future.globals.maxSize.org, 
[11:00:01.476]                         ...future.globals.maxSize)) {
[11:00:01.476]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.476]                         on.exit(options(oopts), add = TRUE)
[11:00:01.476]                       }
[11:00:01.476]                       {
[11:00:01.476]                         lapply(seq_along(...future.elements_ii), 
[11:00:01.476]                           FUN = function(jj) {
[11:00:01.476]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.476]                             ...future.FUN(...future.X_jj, ...)
[11:00:01.476]                           })
[11:00:01.476]                       }
[11:00:01.476]                     }, args = future.call.arguments)
[11:00:01.476]                   }
[11:00:01.476]                 }, immediateCondition = function(cond) {
[11:00:01.476]                   save_rds <- function (object, pathname, ...) 
[11:00:01.476]                   {
[11:00:01.476]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:01.476]                     if (file_test("-f", pathname_tmp)) {
[11:00:01.476]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.476]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:01.476]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.476]                         fi_tmp[["mtime"]])
[11:00:01.476]                     }
[11:00:01.476]                     tryCatch({
[11:00:01.476]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:01.476]                     }, error = function(ex) {
[11:00:01.476]                       msg <- conditionMessage(ex)
[11:00:01.476]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.476]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:01.476]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.476]                         fi_tmp[["mtime"]], msg)
[11:00:01.476]                       ex$message <- msg
[11:00:01.476]                       stop(ex)
[11:00:01.476]                     })
[11:00:01.476]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:01.476]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:01.476]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:01.476]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.476]                       fi <- file.info(pathname)
[11:00:01.476]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:01.476]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.476]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:01.476]                         fi[["size"]], fi[["mtime"]])
[11:00:01.476]                       stop(msg)
[11:00:01.476]                     }
[11:00:01.476]                     invisible(pathname)
[11:00:01.476]                   }
[11:00:01.476]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:01.476]                     rootPath = tempdir()) 
[11:00:01.476]                   {
[11:00:01.476]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:01.476]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:01.476]                       tmpdir = path, fileext = ".rds")
[11:00:01.476]                     save_rds(obj, file)
[11:00:01.476]                   }
[11:00:01.476]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:01.476]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.476]                   {
[11:00:01.476]                     inherits <- base::inherits
[11:00:01.476]                     invokeRestart <- base::invokeRestart
[11:00:01.476]                     is.null <- base::is.null
[11:00:01.476]                     muffled <- FALSE
[11:00:01.476]                     if (inherits(cond, "message")) {
[11:00:01.476]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:01.476]                       if (muffled) 
[11:00:01.476]                         invokeRestart("muffleMessage")
[11:00:01.476]                     }
[11:00:01.476]                     else if (inherits(cond, "warning")) {
[11:00:01.476]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:01.476]                       if (muffled) 
[11:00:01.476]                         invokeRestart("muffleWarning")
[11:00:01.476]                     }
[11:00:01.476]                     else if (inherits(cond, "condition")) {
[11:00:01.476]                       if (!is.null(pattern)) {
[11:00:01.476]                         computeRestarts <- base::computeRestarts
[11:00:01.476]                         grepl <- base::grepl
[11:00:01.476]                         restarts <- computeRestarts(cond)
[11:00:01.476]                         for (restart in restarts) {
[11:00:01.476]                           name <- restart$name
[11:00:01.476]                           if (is.null(name)) 
[11:00:01.476]                             next
[11:00:01.476]                           if (!grepl(pattern, name)) 
[11:00:01.476]                             next
[11:00:01.476]                           invokeRestart(restart)
[11:00:01.476]                           muffled <- TRUE
[11:00:01.476]                           break
[11:00:01.476]                         }
[11:00:01.476]                       }
[11:00:01.476]                     }
[11:00:01.476]                     invisible(muffled)
[11:00:01.476]                   }
[11:00:01.476]                   muffleCondition(cond)
[11:00:01.476]                 })
[11:00:01.476]             }))
[11:00:01.476]             future::FutureResult(value = ...future.value$value, 
[11:00:01.476]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.476]                   ...future.rng), globalenv = if (FALSE) 
[11:00:01.476]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:01.476]                     ...future.globalenv.names))
[11:00:01.476]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:01.476]         }, condition = base::local({
[11:00:01.476]             c <- base::c
[11:00:01.476]             inherits <- base::inherits
[11:00:01.476]             invokeRestart <- base::invokeRestart
[11:00:01.476]             length <- base::length
[11:00:01.476]             list <- base::list
[11:00:01.476]             seq.int <- base::seq.int
[11:00:01.476]             signalCondition <- base::signalCondition
[11:00:01.476]             sys.calls <- base::sys.calls
[11:00:01.476]             `[[` <- base::`[[`
[11:00:01.476]             `+` <- base::`+`
[11:00:01.476]             `<<-` <- base::`<<-`
[11:00:01.476]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:01.476]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:01.476]                   3L)]
[11:00:01.476]             }
[11:00:01.476]             function(cond) {
[11:00:01.476]                 is_error <- inherits(cond, "error")
[11:00:01.476]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:01.476]                   NULL)
[11:00:01.476]                 if (is_error) {
[11:00:01.476]                   sessionInformation <- function() {
[11:00:01.476]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:01.476]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:01.476]                       search = base::search(), system = base::Sys.info())
[11:00:01.476]                   }
[11:00:01.476]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.476]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:01.476]                     cond$call), session = sessionInformation(), 
[11:00:01.476]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:01.476]                   signalCondition(cond)
[11:00:01.476]                 }
[11:00:01.476]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:01.476]                 "immediateCondition"))) {
[11:00:01.476]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:01.476]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.476]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:01.476]                   if (TRUE && !signal) {
[11:00:01.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.476]                     {
[11:00:01.476]                       inherits <- base::inherits
[11:00:01.476]                       invokeRestart <- base::invokeRestart
[11:00:01.476]                       is.null <- base::is.null
[11:00:01.476]                       muffled <- FALSE
[11:00:01.476]                       if (inherits(cond, "message")) {
[11:00:01.476]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.476]                         if (muffled) 
[11:00:01.476]                           invokeRestart("muffleMessage")
[11:00:01.476]                       }
[11:00:01.476]                       else if (inherits(cond, "warning")) {
[11:00:01.476]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.476]                         if (muffled) 
[11:00:01.476]                           invokeRestart("muffleWarning")
[11:00:01.476]                       }
[11:00:01.476]                       else if (inherits(cond, "condition")) {
[11:00:01.476]                         if (!is.null(pattern)) {
[11:00:01.476]                           computeRestarts <- base::computeRestarts
[11:00:01.476]                           grepl <- base::grepl
[11:00:01.476]                           restarts <- computeRestarts(cond)
[11:00:01.476]                           for (restart in restarts) {
[11:00:01.476]                             name <- restart$name
[11:00:01.476]                             if (is.null(name)) 
[11:00:01.476]                               next
[11:00:01.476]                             if (!grepl(pattern, name)) 
[11:00:01.476]                               next
[11:00:01.476]                             invokeRestart(restart)
[11:00:01.476]                             muffled <- TRUE
[11:00:01.476]                             break
[11:00:01.476]                           }
[11:00:01.476]                         }
[11:00:01.476]                       }
[11:00:01.476]                       invisible(muffled)
[11:00:01.476]                     }
[11:00:01.476]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.476]                   }
[11:00:01.476]                 }
[11:00:01.476]                 else {
[11:00:01.476]                   if (TRUE) {
[11:00:01.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.476]                     {
[11:00:01.476]                       inherits <- base::inherits
[11:00:01.476]                       invokeRestart <- base::invokeRestart
[11:00:01.476]                       is.null <- base::is.null
[11:00:01.476]                       muffled <- FALSE
[11:00:01.476]                       if (inherits(cond, "message")) {
[11:00:01.476]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.476]                         if (muffled) 
[11:00:01.476]                           invokeRestart("muffleMessage")
[11:00:01.476]                       }
[11:00:01.476]                       else if (inherits(cond, "warning")) {
[11:00:01.476]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.476]                         if (muffled) 
[11:00:01.476]                           invokeRestart("muffleWarning")
[11:00:01.476]                       }
[11:00:01.476]                       else if (inherits(cond, "condition")) {
[11:00:01.476]                         if (!is.null(pattern)) {
[11:00:01.476]                           computeRestarts <- base::computeRestarts
[11:00:01.476]                           grepl <- base::grepl
[11:00:01.476]                           restarts <- computeRestarts(cond)
[11:00:01.476]                           for (restart in restarts) {
[11:00:01.476]                             name <- restart$name
[11:00:01.476]                             if (is.null(name)) 
[11:00:01.476]                               next
[11:00:01.476]                             if (!grepl(pattern, name)) 
[11:00:01.476]                               next
[11:00:01.476]                             invokeRestart(restart)
[11:00:01.476]                             muffled <- TRUE
[11:00:01.476]                             break
[11:00:01.476]                           }
[11:00:01.476]                         }
[11:00:01.476]                       }
[11:00:01.476]                       invisible(muffled)
[11:00:01.476]                     }
[11:00:01.476]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.476]                   }
[11:00:01.476]                 }
[11:00:01.476]             }
[11:00:01.476]         }))
[11:00:01.476]     }, error = function(ex) {
[11:00:01.476]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:01.476]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.476]                 ...future.rng), started = ...future.startTime, 
[11:00:01.476]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:01.476]             version = "1.8"), class = "FutureResult")
[11:00:01.476]     }, finally = {
[11:00:01.476]         if (!identical(...future.workdir, getwd())) 
[11:00:01.476]             setwd(...future.workdir)
[11:00:01.476]         {
[11:00:01.476]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:01.476]                 ...future.oldOptions$nwarnings <- NULL
[11:00:01.476]             }
[11:00:01.476]             base::options(...future.oldOptions)
[11:00:01.476]             if (.Platform$OS.type == "windows") {
[11:00:01.476]                 old_names <- names(...future.oldEnvVars)
[11:00:01.476]                 envs <- base::Sys.getenv()
[11:00:01.476]                 names <- names(envs)
[11:00:01.476]                 common <- intersect(names, old_names)
[11:00:01.476]                 added <- setdiff(names, old_names)
[11:00:01.476]                 removed <- setdiff(old_names, names)
[11:00:01.476]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:01.476]                   envs[common]]
[11:00:01.476]                 NAMES <- toupper(changed)
[11:00:01.476]                 args <- list()
[11:00:01.476]                 for (kk in seq_along(NAMES)) {
[11:00:01.476]                   name <- changed[[kk]]
[11:00:01.476]                   NAME <- NAMES[[kk]]
[11:00:01.476]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.476]                     next
[11:00:01.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.476]                 }
[11:00:01.476]                 NAMES <- toupper(added)
[11:00:01.476]                 for (kk in seq_along(NAMES)) {
[11:00:01.476]                   name <- added[[kk]]
[11:00:01.476]                   NAME <- NAMES[[kk]]
[11:00:01.476]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.476]                     next
[11:00:01.476]                   args[[name]] <- ""
[11:00:01.476]                 }
[11:00:01.476]                 NAMES <- toupper(removed)
[11:00:01.476]                 for (kk in seq_along(NAMES)) {
[11:00:01.476]                   name <- removed[[kk]]
[11:00:01.476]                   NAME <- NAMES[[kk]]
[11:00:01.476]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.476]                     next
[11:00:01.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.476]                 }
[11:00:01.476]                 if (length(args) > 0) 
[11:00:01.476]                   base::do.call(base::Sys.setenv, args = args)
[11:00:01.476]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:01.476]             }
[11:00:01.476]             else {
[11:00:01.476]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:01.476]             }
[11:00:01.476]             {
[11:00:01.476]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:01.476]                   0L) {
[11:00:01.476]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:01.476]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:01.476]                   base::options(opts)
[11:00:01.476]                 }
[11:00:01.476]                 {
[11:00:01.476]                   {
[11:00:01.476]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:01.476]                     NULL
[11:00:01.476]                   }
[11:00:01.476]                   options(future.plan = NULL)
[11:00:01.476]                   if (is.na(NA_character_)) 
[11:00:01.476]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.476]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:01.476]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:01.476]                     .init = FALSE)
[11:00:01.476]                 }
[11:00:01.476]             }
[11:00:01.476]         }
[11:00:01.476]     })
[11:00:01.476]     if (TRUE) {
[11:00:01.476]         base::sink(type = "output", split = FALSE)
[11:00:01.476]         if (TRUE) {
[11:00:01.476]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:01.476]         }
[11:00:01.476]         else {
[11:00:01.476]             ...future.result["stdout"] <- base::list(NULL)
[11:00:01.476]         }
[11:00:01.476]         base::close(...future.stdout)
[11:00:01.476]         ...future.stdout <- NULL
[11:00:01.476]     }
[11:00:01.476]     ...future.result$conditions <- ...future.conditions
[11:00:01.476]     ...future.result$finished <- base::Sys.time()
[11:00:01.476]     ...future.result
[11:00:01.476] }
[11:00:01.478] assign_globals() ...
[11:00:01.478] List of 11
[11:00:01.478]  $ ...future.FUN            :function (x, ...)  
[11:00:01.478]  $ x_FUN                    :function (x)  
[11:00:01.478]  $ times                    : int 2
[11:00:01.478]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.478]  $ stop_if_not              :function (...)  
[11:00:01.478]  $ dim                      : NULL
[11:00:01.478]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:01.478]  $ future.call.arguments    : list()
[11:00:01.478]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.478]  $ ...future.elements_ii    :List of 5
[11:00:01.478]   ..$ : int 1
[11:00:01.478]   ..$ : int 2
[11:00:01.478]   ..$ : int 3
[11:00:01.478]   ..$ : int 4
[11:00:01.478]   ..$ : int 5
[11:00:01.478]  $ ...future.seeds_ii       : NULL
[11:00:01.478]  $ ...future.globals.maxSize: NULL
[11:00:01.478]  - attr(*, "where")=List of 11
[11:00:01.478]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:01.478]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:01.478]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:01.478]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:01.478]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:01.478]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:01.478]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:01.478]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:01.478]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:01.478]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:01.478]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:01.478]  - attr(*, "resolved")= logi FALSE
[11:00:01.478]  - attr(*, "total_size")= num 24454
[11:00:01.478]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.478]  - attr(*, "already-done")= logi TRUE
[11:00:01.488] - copied ‘...future.FUN’ to environment
[11:00:01.488] - reassign environment for ‘x_FUN’
[11:00:01.489] - copied ‘x_FUN’ to environment
[11:00:01.489] - copied ‘times’ to environment
[11:00:01.489] - copied ‘stopf’ to environment
[11:00:01.489] - copied ‘stop_if_not’ to environment
[11:00:01.489] - copied ‘dim’ to environment
[11:00:01.489] - copied ‘valid_types’ to environment
[11:00:01.489] - copied ‘future.call.arguments’ to environment
[11:00:01.489] - copied ‘...future.elements_ii’ to environment
[11:00:01.489] - copied ‘...future.seeds_ii’ to environment
[11:00:01.489] - copied ‘...future.globals.maxSize’ to environment
[11:00:01.489] assign_globals() ... done
[11:00:01.490] requestCore(): workers = 2
[11:00:01.492] MulticoreFuture started
[11:00:01.492] - Launch lazy future ... done
[11:00:01.492] run() for ‘MulticoreFuture’ ... done
[11:00:01.493] Created future:
[11:00:01.493] plan(): Setting new future strategy stack:
[11:00:01.494] List of future strategies:
[11:00:01.494] 1. sequential:
[11:00:01.494]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:01.494]    - tweaked: FALSE
[11:00:01.494]    - call: NULL
[11:00:01.495] plan(): nbrOfWorkers() = 1
[11:00:01.497] plan(): Setting new future strategy stack:
[11:00:01.497] List of future strategies:
[11:00:01.497] 1. multicore:
[11:00:01.497]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:01.497]    - tweaked: FALSE
[11:00:01.497]    - call: plan(strategy)
[11:00:01.501] plan(): nbrOfWorkers() = 2
[11:00:01.493] MulticoreFuture:
[11:00:01.493] Label: ‘future_vapply-1’
[11:00:01.493] Expression:
[11:00:01.493] {
[11:00:01.493]     do.call(function(...) {
[11:00:01.493]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.493]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.493]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.493]             on.exit(options(oopts), add = TRUE)
[11:00:01.493]         }
[11:00:01.493]         {
[11:00:01.493]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.493]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.493]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.493]             })
[11:00:01.493]         }
[11:00:01.493]     }, args = future.call.arguments)
[11:00:01.493] }
[11:00:01.493] Lazy evaluation: FALSE
[11:00:01.493] Asynchronous evaluation: TRUE
[11:00:01.493] Local evaluation: TRUE
[11:00:01.493] Environment: R_GlobalEnv
[11:00:01.493] Capture standard output: TRUE
[11:00:01.493] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:01.493] Globals: 11 objects totaling 13.57 KiB (function ‘...future.FUN’ of 4.88 KiB, function ‘x_FUN’ of 483 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:01.493] Packages: 1 packages (‘future.apply’)
[11:00:01.493] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:01.493] Resolved: TRUE
[11:00:01.493] Value: <not collected>
[11:00:01.493] Conditions captured: <none>
[11:00:01.493] Early signaling: FALSE
[11:00:01.493] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:01.493] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.502] Chunk #1 of 2 ... DONE
[11:00:01.502] Chunk #2 of 2 ...
[11:00:01.502]  - Finding globals in 'X' for chunk #2 ...
[11:00:01.502] getGlobalsAndPackages() ...
[11:00:01.502] Searching for globals...
[11:00:01.503] 
[11:00:01.503] Searching for globals ... DONE
[11:00:01.503] - globals: [0] <none>
[11:00:01.503] getGlobalsAndPackages() ... DONE
[11:00:01.503]    + additional globals found: [n=0] 
[11:00:01.503]    + additional namespaces needed: [n=0] 
[11:00:01.504]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:01.504]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:01.504]  - seeds: <none>
[11:00:01.504]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.504] getGlobalsAndPackages() ...
[11:00:01.504] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.504] Resolving globals: FALSE
[11:00:01.505] Tweak future expression to call with '...' arguments ...
[11:00:01.505] {
[11:00:01.505]     do.call(function(...) {
[11:00:01.505]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.505]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.505]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.505]             on.exit(options(oopts), add = TRUE)
[11:00:01.505]         }
[11:00:01.505]         {
[11:00:01.505]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.505]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.505]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.505]             })
[11:00:01.505]         }
[11:00:01.505]     }, args = future.call.arguments)
[11:00:01.505] }
[11:00:01.505] Tweak future expression to call with '...' arguments ... DONE
[11:00:01.506] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.506] - packages: [1] ‘future.apply’
[11:00:01.506] getGlobalsAndPackages() ... DONE
[11:00:01.507] run() for ‘Future’ ...
[11:00:01.507] - state: ‘created’
[11:00:01.507] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:01.510] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.510] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:01.510]   - Field: ‘label’
[11:00:01.511]   - Field: ‘local’
[11:00:01.511]   - Field: ‘owner’
[11:00:01.511]   - Field: ‘envir’
[11:00:01.511]   - Field: ‘workers’
[11:00:01.511]   - Field: ‘packages’
[11:00:01.511]   - Field: ‘gc’
[11:00:01.511]   - Field: ‘job’
[11:00:01.512]   - Field: ‘conditions’
[11:00:01.512]   - Field: ‘expr’
[11:00:01.512]   - Field: ‘uuid’
[11:00:01.512]   - Field: ‘seed’
[11:00:01.512]   - Field: ‘version’
[11:00:01.512]   - Field: ‘result’
[11:00:01.512]   - Field: ‘asynchronous’
[11:00:01.513]   - Field: ‘calls’
[11:00:01.513]   - Field: ‘globals’
[11:00:01.513]   - Field: ‘stdout’
[11:00:01.513]   - Field: ‘earlySignal’
[11:00:01.513]   - Field: ‘lazy’
[11:00:01.513]   - Field: ‘state’
[11:00:01.513] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:01.513] - Launch lazy future ...
[11:00:01.514] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:01.514] Packages needed by future strategies (n = 0): <none>
[11:00:01.515] {
[11:00:01.515]     {
[11:00:01.515]         {
[11:00:01.515]             ...future.startTime <- base::Sys.time()
[11:00:01.515]             {
[11:00:01.515]                 {
[11:00:01.515]                   {
[11:00:01.515]                     {
[11:00:01.515]                       {
[11:00:01.515]                         base::local({
[11:00:01.515]                           has_future <- base::requireNamespace("future", 
[11:00:01.515]                             quietly = TRUE)
[11:00:01.515]                           if (has_future) {
[11:00:01.515]                             ns <- base::getNamespace("future")
[11:00:01.515]                             version <- ns[[".package"]][["version"]]
[11:00:01.515]                             if (is.null(version)) 
[11:00:01.515]                               version <- utils::packageVersion("future")
[11:00:01.515]                           }
[11:00:01.515]                           else {
[11:00:01.515]                             version <- NULL
[11:00:01.515]                           }
[11:00:01.515]                           if (!has_future || version < "1.8.0") {
[11:00:01.515]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:01.515]                               "", base::R.version$version.string), 
[11:00:01.515]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:01.515]                                 base::R.version$platform, 8 * 
[11:00:01.515]                                   base::.Machine$sizeof.pointer), 
[11:00:01.515]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:01.515]                                 "release", "version")], collapse = " "), 
[11:00:01.515]                               hostname = base::Sys.info()[["nodename"]])
[11:00:01.515]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:01.515]                               info)
[11:00:01.515]                             info <- base::paste(info, collapse = "; ")
[11:00:01.515]                             if (!has_future) {
[11:00:01.515]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:01.515]                                 info)
[11:00:01.515]                             }
[11:00:01.515]                             else {
[11:00:01.515]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:01.515]                                 info, version)
[11:00:01.515]                             }
[11:00:01.515]                             base::stop(msg)
[11:00:01.515]                           }
[11:00:01.515]                         })
[11:00:01.515]                       }
[11:00:01.515]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:01.515]                       base::options(mc.cores = 1L)
[11:00:01.515]                     }
[11:00:01.515]                     base::local({
[11:00:01.515]                       for (pkg in "future.apply") {
[11:00:01.515]                         base::loadNamespace(pkg)
[11:00:01.515]                         base::library(pkg, character.only = TRUE)
[11:00:01.515]                       }
[11:00:01.515]                     })
[11:00:01.515]                   }
[11:00:01.515]                   ...future.strategy.old <- future::plan("list")
[11:00:01.515]                   options(future.plan = NULL)
[11:00:01.515]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.515]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:01.515]                 }
[11:00:01.515]                 ...future.workdir <- getwd()
[11:00:01.515]             }
[11:00:01.515]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:01.515]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:01.515]         }
[11:00:01.515]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:01.515]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:01.515]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:01.515]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:01.515]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:01.515]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:01.515]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:01.515]             base::names(...future.oldOptions))
[11:00:01.515]     }
[11:00:01.515]     if (FALSE) {
[11:00:01.515]     }
[11:00:01.515]     else {
[11:00:01.515]         if (TRUE) {
[11:00:01.515]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:01.515]                 open = "w")
[11:00:01.515]         }
[11:00:01.515]         else {
[11:00:01.515]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:01.515]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:01.515]         }
[11:00:01.515]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:01.515]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:01.515]             base::sink(type = "output", split = FALSE)
[11:00:01.515]             base::close(...future.stdout)
[11:00:01.515]         }, add = TRUE)
[11:00:01.515]     }
[11:00:01.515]     ...future.frame <- base::sys.nframe()
[11:00:01.515]     ...future.conditions <- base::list()
[11:00:01.515]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:01.515]     if (FALSE) {
[11:00:01.515]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:01.515]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:01.515]     }
[11:00:01.515]     ...future.result <- base::tryCatch({
[11:00:01.515]         base::withCallingHandlers({
[11:00:01.515]             ...future.value <- base::withVisible(base::local({
[11:00:01.515]                 withCallingHandlers({
[11:00:01.515]                   {
[11:00:01.515]                     do.call(function(...) {
[11:00:01.515]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.515]                       if (!identical(...future.globals.maxSize.org, 
[11:00:01.515]                         ...future.globals.maxSize)) {
[11:00:01.515]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.515]                         on.exit(options(oopts), add = TRUE)
[11:00:01.515]                       }
[11:00:01.515]                       {
[11:00:01.515]                         lapply(seq_along(...future.elements_ii), 
[11:00:01.515]                           FUN = function(jj) {
[11:00:01.515]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.515]                             ...future.FUN(...future.X_jj, ...)
[11:00:01.515]                           })
[11:00:01.515]                       }
[11:00:01.515]                     }, args = future.call.arguments)
[11:00:01.515]                   }
[11:00:01.515]                 }, immediateCondition = function(cond) {
[11:00:01.515]                   save_rds <- function (object, pathname, ...) 
[11:00:01.515]                   {
[11:00:01.515]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:01.515]                     if (file_test("-f", pathname_tmp)) {
[11:00:01.515]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.515]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:01.515]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.515]                         fi_tmp[["mtime"]])
[11:00:01.515]                     }
[11:00:01.515]                     tryCatch({
[11:00:01.515]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:01.515]                     }, error = function(ex) {
[11:00:01.515]                       msg <- conditionMessage(ex)
[11:00:01.515]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.515]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:01.515]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.515]                         fi_tmp[["mtime"]], msg)
[11:00:01.515]                       ex$message <- msg
[11:00:01.515]                       stop(ex)
[11:00:01.515]                     })
[11:00:01.515]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:01.515]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:01.515]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:01.515]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.515]                       fi <- file.info(pathname)
[11:00:01.515]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:01.515]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.515]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:01.515]                         fi[["size"]], fi[["mtime"]])
[11:00:01.515]                       stop(msg)
[11:00:01.515]                     }
[11:00:01.515]                     invisible(pathname)
[11:00:01.515]                   }
[11:00:01.515]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:01.515]                     rootPath = tempdir()) 
[11:00:01.515]                   {
[11:00:01.515]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:01.515]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:01.515]                       tmpdir = path, fileext = ".rds")
[11:00:01.515]                     save_rds(obj, file)
[11:00:01.515]                   }
[11:00:01.515]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:01.515]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.515]                   {
[11:00:01.515]                     inherits <- base::inherits
[11:00:01.515]                     invokeRestart <- base::invokeRestart
[11:00:01.515]                     is.null <- base::is.null
[11:00:01.515]                     muffled <- FALSE
[11:00:01.515]                     if (inherits(cond, "message")) {
[11:00:01.515]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:01.515]                       if (muffled) 
[11:00:01.515]                         invokeRestart("muffleMessage")
[11:00:01.515]                     }
[11:00:01.515]                     else if (inherits(cond, "warning")) {
[11:00:01.515]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:01.515]                       if (muffled) 
[11:00:01.515]                         invokeRestart("muffleWarning")
[11:00:01.515]                     }
[11:00:01.515]                     else if (inherits(cond, "condition")) {
[11:00:01.515]                       if (!is.null(pattern)) {
[11:00:01.515]                         computeRestarts <- base::computeRestarts
[11:00:01.515]                         grepl <- base::grepl
[11:00:01.515]                         restarts <- computeRestarts(cond)
[11:00:01.515]                         for (restart in restarts) {
[11:00:01.515]                           name <- restart$name
[11:00:01.515]                           if (is.null(name)) 
[11:00:01.515]                             next
[11:00:01.515]                           if (!grepl(pattern, name)) 
[11:00:01.515]                             next
[11:00:01.515]                           invokeRestart(restart)
[11:00:01.515]                           muffled <- TRUE
[11:00:01.515]                           break
[11:00:01.515]                         }
[11:00:01.515]                       }
[11:00:01.515]                     }
[11:00:01.515]                     invisible(muffled)
[11:00:01.515]                   }
[11:00:01.515]                   muffleCondition(cond)
[11:00:01.515]                 })
[11:00:01.515]             }))
[11:00:01.515]             future::FutureResult(value = ...future.value$value, 
[11:00:01.515]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.515]                   ...future.rng), globalenv = if (FALSE) 
[11:00:01.515]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:01.515]                     ...future.globalenv.names))
[11:00:01.515]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:01.515]         }, condition = base::local({
[11:00:01.515]             c <- base::c
[11:00:01.515]             inherits <- base::inherits
[11:00:01.515]             invokeRestart <- base::invokeRestart
[11:00:01.515]             length <- base::length
[11:00:01.515]             list <- base::list
[11:00:01.515]             seq.int <- base::seq.int
[11:00:01.515]             signalCondition <- base::signalCondition
[11:00:01.515]             sys.calls <- base::sys.calls
[11:00:01.515]             `[[` <- base::`[[`
[11:00:01.515]             `+` <- base::`+`
[11:00:01.515]             `<<-` <- base::`<<-`
[11:00:01.515]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:01.515]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:01.515]                   3L)]
[11:00:01.515]             }
[11:00:01.515]             function(cond) {
[11:00:01.515]                 is_error <- inherits(cond, "error")
[11:00:01.515]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:01.515]                   NULL)
[11:00:01.515]                 if (is_error) {
[11:00:01.515]                   sessionInformation <- function() {
[11:00:01.515]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:01.515]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:01.515]                       search = base::search(), system = base::Sys.info())
[11:00:01.515]                   }
[11:00:01.515]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.515]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:01.515]                     cond$call), session = sessionInformation(), 
[11:00:01.515]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:01.515]                   signalCondition(cond)
[11:00:01.515]                 }
[11:00:01.515]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:01.515]                 "immediateCondition"))) {
[11:00:01.515]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:01.515]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.515]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:01.515]                   if (TRUE && !signal) {
[11:00:01.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.515]                     {
[11:00:01.515]                       inherits <- base::inherits
[11:00:01.515]                       invokeRestart <- base::invokeRestart
[11:00:01.515]                       is.null <- base::is.null
[11:00:01.515]                       muffled <- FALSE
[11:00:01.515]                       if (inherits(cond, "message")) {
[11:00:01.515]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.515]                         if (muffled) 
[11:00:01.515]                           invokeRestart("muffleMessage")
[11:00:01.515]                       }
[11:00:01.515]                       else if (inherits(cond, "warning")) {
[11:00:01.515]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.515]                         if (muffled) 
[11:00:01.515]                           invokeRestart("muffleWarning")
[11:00:01.515]                       }
[11:00:01.515]                       else if (inherits(cond, "condition")) {
[11:00:01.515]                         if (!is.null(pattern)) {
[11:00:01.515]                           computeRestarts <- base::computeRestarts
[11:00:01.515]                           grepl <- base::grepl
[11:00:01.515]                           restarts <- computeRestarts(cond)
[11:00:01.515]                           for (restart in restarts) {
[11:00:01.515]                             name <- restart$name
[11:00:01.515]                             if (is.null(name)) 
[11:00:01.515]                               next
[11:00:01.515]                             if (!grepl(pattern, name)) 
[11:00:01.515]                               next
[11:00:01.515]                             invokeRestart(restart)
[11:00:01.515]                             muffled <- TRUE
[11:00:01.515]                             break
[11:00:01.515]                           }
[11:00:01.515]                         }
[11:00:01.515]                       }
[11:00:01.515]                       invisible(muffled)
[11:00:01.515]                     }
[11:00:01.515]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.515]                   }
[11:00:01.515]                 }
[11:00:01.515]                 else {
[11:00:01.515]                   if (TRUE) {
[11:00:01.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.515]                     {
[11:00:01.515]                       inherits <- base::inherits
[11:00:01.515]                       invokeRestart <- base::invokeRestart
[11:00:01.515]                       is.null <- base::is.null
[11:00:01.515]                       muffled <- FALSE
[11:00:01.515]                       if (inherits(cond, "message")) {
[11:00:01.515]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.515]                         if (muffled) 
[11:00:01.515]                           invokeRestart("muffleMessage")
[11:00:01.515]                       }
[11:00:01.515]                       else if (inherits(cond, "warning")) {
[11:00:01.515]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.515]                         if (muffled) 
[11:00:01.515]                           invokeRestart("muffleWarning")
[11:00:01.515]                       }
[11:00:01.515]                       else if (inherits(cond, "condition")) {
[11:00:01.515]                         if (!is.null(pattern)) {
[11:00:01.515]                           computeRestarts <- base::computeRestarts
[11:00:01.515]                           grepl <- base::grepl
[11:00:01.515]                           restarts <- computeRestarts(cond)
[11:00:01.515]                           for (restart in restarts) {
[11:00:01.515]                             name <- restart$name
[11:00:01.515]                             if (is.null(name)) 
[11:00:01.515]                               next
[11:00:01.515]                             if (!grepl(pattern, name)) 
[11:00:01.515]                               next
[11:00:01.515]                             invokeRestart(restart)
[11:00:01.515]                             muffled <- TRUE
[11:00:01.515]                             break
[11:00:01.515]                           }
[11:00:01.515]                         }
[11:00:01.515]                       }
[11:00:01.515]                       invisible(muffled)
[11:00:01.515]                     }
[11:00:01.515]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.515]                   }
[11:00:01.515]                 }
[11:00:01.515]             }
[11:00:01.515]         }))
[11:00:01.515]     }, error = function(ex) {
[11:00:01.515]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:01.515]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.515]                 ...future.rng), started = ...future.startTime, 
[11:00:01.515]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:01.515]             version = "1.8"), class = "FutureResult")
[11:00:01.515]     }, finally = {
[11:00:01.515]         if (!identical(...future.workdir, getwd())) 
[11:00:01.515]             setwd(...future.workdir)
[11:00:01.515]         {
[11:00:01.515]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:01.515]                 ...future.oldOptions$nwarnings <- NULL
[11:00:01.515]             }
[11:00:01.515]             base::options(...future.oldOptions)
[11:00:01.515]             if (.Platform$OS.type == "windows") {
[11:00:01.515]                 old_names <- names(...future.oldEnvVars)
[11:00:01.515]                 envs <- base::Sys.getenv()
[11:00:01.515]                 names <- names(envs)
[11:00:01.515]                 common <- intersect(names, old_names)
[11:00:01.515]                 added <- setdiff(names, old_names)
[11:00:01.515]                 removed <- setdiff(old_names, names)
[11:00:01.515]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:01.515]                   envs[common]]
[11:00:01.515]                 NAMES <- toupper(changed)
[11:00:01.515]                 args <- list()
[11:00:01.515]                 for (kk in seq_along(NAMES)) {
[11:00:01.515]                   name <- changed[[kk]]
[11:00:01.515]                   NAME <- NAMES[[kk]]
[11:00:01.515]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.515]                     next
[11:00:01.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.515]                 }
[11:00:01.515]                 NAMES <- toupper(added)
[11:00:01.515]                 for (kk in seq_along(NAMES)) {
[11:00:01.515]                   name <- added[[kk]]
[11:00:01.515]                   NAME <- NAMES[[kk]]
[11:00:01.515]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.515]                     next
[11:00:01.515]                   args[[name]] <- ""
[11:00:01.515]                 }
[11:00:01.515]                 NAMES <- toupper(removed)
[11:00:01.515]                 for (kk in seq_along(NAMES)) {
[11:00:01.515]                   name <- removed[[kk]]
[11:00:01.515]                   NAME <- NAMES[[kk]]
[11:00:01.515]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.515]                     next
[11:00:01.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.515]                 }
[11:00:01.515]                 if (length(args) > 0) 
[11:00:01.515]                   base::do.call(base::Sys.setenv, args = args)
[11:00:01.515]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:01.515]             }
[11:00:01.515]             else {
[11:00:01.515]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:01.515]             }
[11:00:01.515]             {
[11:00:01.515]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:01.515]                   0L) {
[11:00:01.515]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:01.515]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:01.515]                   base::options(opts)
[11:00:01.515]                 }
[11:00:01.515]                 {
[11:00:01.515]                   {
[11:00:01.515]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:01.515]                     NULL
[11:00:01.515]                   }
[11:00:01.515]                   options(future.plan = NULL)
[11:00:01.515]                   if (is.na(NA_character_)) 
[11:00:01.515]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.515]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:01.515]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:01.515]                     .init = FALSE)
[11:00:01.515]                 }
[11:00:01.515]             }
[11:00:01.515]         }
[11:00:01.515]     })
[11:00:01.515]     if (TRUE) {
[11:00:01.515]         base::sink(type = "output", split = FALSE)
[11:00:01.515]         if (TRUE) {
[11:00:01.515]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:01.515]         }
[11:00:01.515]         else {
[11:00:01.515]             ...future.result["stdout"] <- base::list(NULL)
[11:00:01.515]         }
[11:00:01.515]         base::close(...future.stdout)
[11:00:01.515]         ...future.stdout <- NULL
[11:00:01.515]     }
[11:00:01.515]     ...future.result$conditions <- ...future.conditions
[11:00:01.515]     ...future.result$finished <- base::Sys.time()
[11:00:01.515]     ...future.result
[11:00:01.515] }
[11:00:01.519] assign_globals() ...
[11:00:01.519] List of 11
[11:00:01.519]  $ ...future.FUN            :function (x, ...)  
[11:00:01.519]  $ x_FUN                    :function (x)  
[11:00:01.519]  $ times                    : int 2
[11:00:01.519]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.519]  $ stop_if_not              :function (...)  
[11:00:01.519]  $ dim                      : NULL
[11:00:01.519]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:01.519]  $ future.call.arguments    : list()
[11:00:01.519]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.519]  $ ...future.elements_ii    :List of 5
[11:00:01.519]   ..$ : int 6
[11:00:01.519]   ..$ : int 7
[11:00:01.519]   ..$ : int 8
[11:00:01.519]   ..$ : int 9
[11:00:01.519]   ..$ : int 10
[11:00:01.519]  $ ...future.seeds_ii       : NULL
[11:00:01.519]  $ ...future.globals.maxSize: NULL
[11:00:01.519]  - attr(*, "where")=List of 11
[11:00:01.519]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:01.519]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:01.519]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:01.519]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:01.519]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:01.519]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:01.519]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:01.519]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:01.519]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:01.519]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:01.519]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:01.519]  - attr(*, "resolved")= logi FALSE
[11:00:01.519]  - attr(*, "total_size")= num 24454
[11:00:01.519]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.519]  - attr(*, "already-done")= logi TRUE
[11:00:01.536] - copied ‘...future.FUN’ to environment
[11:00:01.536] - reassign environment for ‘x_FUN’
[11:00:01.537] - copied ‘x_FUN’ to environment
[11:00:01.537] - copied ‘times’ to environment
[11:00:01.537] - copied ‘stopf’ to environment
[11:00:01.537] - copied ‘stop_if_not’ to environment
[11:00:01.537] - copied ‘dim’ to environment
[11:00:01.537] - copied ‘valid_types’ to environment
[11:00:01.537] - copied ‘future.call.arguments’ to environment
[11:00:01.537] - copied ‘...future.elements_ii’ to environment
[11:00:01.537] - copied ‘...future.seeds_ii’ to environment
[11:00:01.538] - copied ‘...future.globals.maxSize’ to environment
[11:00:01.538] assign_globals() ... done
[11:00:01.538] requestCore(): workers = 2
[11:00:01.540] MulticoreFuture started
[11:00:01.541] - Launch lazy future ... done
[11:00:01.541] run() for ‘MulticoreFuture’ ... done
[11:00:01.541] Created future:
[11:00:01.542] plan(): Setting new future strategy stack:
[11:00:01.542] List of future strategies:
[11:00:01.542] 1. sequential:
[11:00:01.542]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:01.542]    - tweaked: FALSE
[11:00:01.542]    - call: NULL
[11:00:01.543] plan(): nbrOfWorkers() = 1
[11:00:01.545] plan(): Setting new future strategy stack:
[11:00:01.545] List of future strategies:
[11:00:01.545] 1. multicore:
[11:00:01.545]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:01.545]    - tweaked: FALSE
[11:00:01.545]    - call: plan(strategy)
[11:00:01.548] plan(): nbrOfWorkers() = 2
[11:00:01.541] MulticoreFuture:
[11:00:01.541] Label: ‘future_vapply-2’
[11:00:01.541] Expression:
[11:00:01.541] {
[11:00:01.541]     do.call(function(...) {
[11:00:01.541]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.541]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.541]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.541]             on.exit(options(oopts), add = TRUE)
[11:00:01.541]         }
[11:00:01.541]         {
[11:00:01.541]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.541]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.541]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.541]             })
[11:00:01.541]         }
[11:00:01.541]     }, args = future.call.arguments)
[11:00:01.541] }
[11:00:01.541] Lazy evaluation: FALSE
[11:00:01.541] Asynchronous evaluation: TRUE
[11:00:01.541] Local evaluation: TRUE
[11:00:01.541] Environment: R_GlobalEnv
[11:00:01.541] Capture standard output: TRUE
[11:00:01.541] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:01.541] Globals: 11 objects totaling 13.57 KiB (function ‘...future.FUN’ of 4.88 KiB, function ‘x_FUN’ of 483 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:01.541] Packages: 1 packages (‘future.apply’)
[11:00:01.541] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:01.541] Resolved: TRUE
[11:00:01.541] Value: <not collected>
[11:00:01.541] Conditions captured: <none>
[11:00:01.541] Early signaling: FALSE
[11:00:01.541] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:01.541] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.549] Chunk #2 of 2 ... DONE
[11:00:01.549] Launching 2 futures (chunks) ... DONE
[11:00:01.550] Resolving 2 futures (chunks) ...
[11:00:01.550] resolve() on list ...
[11:00:01.550]  recursive: 0
[11:00:01.550]  length: 2
[11:00:01.550] 
[11:00:01.551] Future #1
[11:00:01.551] result() for MulticoreFuture ...
[11:00:01.552] result() for MulticoreFuture ...
[11:00:01.552] result() for MulticoreFuture ... done
[11:00:01.552] result() for MulticoreFuture ... done
[11:00:01.552] result() for MulticoreFuture ...
[11:00:01.552] result() for MulticoreFuture ... done
[11:00:01.552] signalConditionsASAP(MulticoreFuture, pos=1) ...
[11:00:01.552] - nx: 2
[11:00:01.553] - relay: TRUE
[11:00:01.553] - stdout: TRUE
[11:00:01.553] - signal: TRUE
[11:00:01.553] - resignal: FALSE
[11:00:01.553] - force: TRUE
[11:00:01.553] - relayed: [n=2] FALSE, FALSE
[11:00:01.553] - queued futures: [n=2] FALSE, FALSE
[11:00:01.553]  - until=1
[11:00:01.554]  - relaying element #1
[11:00:01.554] result() for MulticoreFuture ...
[11:00:01.554] result() for MulticoreFuture ... done
[11:00:01.554] result() for MulticoreFuture ...
[11:00:01.554] result() for MulticoreFuture ... done
[11:00:01.554] result() for MulticoreFuture ...
[11:00:01.555] result() for MulticoreFuture ... done
[11:00:01.555] result() for MulticoreFuture ...
[11:00:01.555] result() for MulticoreFuture ... done
[11:00:01.555] - relayed: [n=2] TRUE, FALSE
[11:00:01.555] - queued futures: [n=2] TRUE, FALSE
[11:00:01.555] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[11:00:01.555]  length: 1 (resolved future 1)
[11:00:01.556] Future #2
[11:00:01.556] result() for MulticoreFuture ...
[11:00:01.557] result() for MulticoreFuture ...
[11:00:01.557] result() for MulticoreFuture ... done
[11:00:01.557] result() for MulticoreFuture ... done
[11:00:01.557] result() for MulticoreFuture ...
[11:00:01.557] result() for MulticoreFuture ... done
[11:00:01.557] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:00:01.557] - nx: 2
[11:00:01.558] - relay: TRUE
[11:00:01.558] - stdout: TRUE
[11:00:01.558] - signal: TRUE
[11:00:01.558] - resignal: FALSE
[11:00:01.558] - force: TRUE
[11:00:01.558] - relayed: [n=2] TRUE, FALSE
[11:00:01.558] - queued futures: [n=2] TRUE, FALSE
[11:00:01.558]  - until=2
[11:00:01.559]  - relaying element #2
[11:00:01.559] result() for MulticoreFuture ...
[11:00:01.559] result() for MulticoreFuture ... done
[11:00:01.559] result() for MulticoreFuture ...
[11:00:01.559] result() for MulticoreFuture ... done
[11:00:01.559] result() for MulticoreFuture ...
[11:00:01.559] result() for MulticoreFuture ... done
[11:00:01.559] result() for MulticoreFuture ...
[11:00:01.560] result() for MulticoreFuture ... done
[11:00:01.560] - relayed: [n=2] TRUE, TRUE
[11:00:01.560] - queued futures: [n=2] TRUE, TRUE
[11:00:01.560] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:00:01.560]  length: 0 (resolved future 2)
[11:00:01.560] Relaying remaining futures
[11:00:01.560] signalConditionsASAP(NULL, pos=0) ...
[11:00:01.560] - nx: 2
[11:00:01.560] - relay: TRUE
[11:00:01.560] - stdout: TRUE
[11:00:01.561] - signal: TRUE
[11:00:01.561] - resignal: FALSE
[11:00:01.561] - force: TRUE
[11:00:01.561] - relayed: [n=2] TRUE, TRUE
[11:00:01.561] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:01.563] - relayed: [n=2] TRUE, TRUE
[11:00:01.563] - queued futures: [n=2] TRUE, TRUE
[11:00:01.563] signalConditionsASAP(NULL, pos=0) ... done
[11:00:01.564] resolve() on list ... DONE
[11:00:01.564] result() for MulticoreFuture ...
[11:00:01.564] result() for MulticoreFuture ... done
[11:00:01.564] result() for MulticoreFuture ...
[11:00:01.564] result() for MulticoreFuture ... done
[11:00:01.565] result() for MulticoreFuture ...
[11:00:01.565] result() for MulticoreFuture ... done
[11:00:01.565] result() for MulticoreFuture ...
[11:00:01.565] result() for MulticoreFuture ... done
[11:00:01.565]  - Number of value chunks collected: 2
[11:00:01.565] Resolving 2 futures (chunks) ... DONE
[11:00:01.565] Reducing values from 2 chunks ...
[11:00:01.566]  - Number of values collected after concatenation: 10
[11:00:01.566]  - Number of values expected: 10
[11:00:01.566] Reducing values from 2 chunks ... DONE
[11:00:01.566] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[11:00:01.568] future_lapply() ...
[11:00:01.572] Number of chunks: 2
[11:00:01.572] getGlobalsAndPackagesXApply() ...
[11:00:01.572]  - future.globals: TRUE
[11:00:01.572] getGlobalsAndPackages() ...
[11:00:01.572] Searching for globals...
[11:00:01.576] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[11:00:01.576] Searching for globals ... DONE
[11:00:01.576] Resolving globals: FALSE
[11:00:01.577] The total size of the 7 globals is 13.59 KiB (13914 bytes)
[11:00:01.578] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.59 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.06 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:01.578] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:01.578] - packages: [1] ‘future.apply’
[11:00:01.578] getGlobalsAndPackages() ... DONE
[11:00:01.578]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:01.578]  - needed namespaces: [n=1] ‘future.apply’
[11:00:01.578] Finding globals ... DONE
[11:00:01.578]  - use_args: TRUE
[11:00:01.578]  - Getting '...' globals ...
[11:00:01.579] resolve() on list ...
[11:00:01.579]  recursive: 0
[11:00:01.579]  length: 1
[11:00:01.579]  elements: ‘...’
[11:00:01.579]  length: 0 (resolved future 1)
[11:00:01.579] resolve() on list ... DONE
[11:00:01.579]    - '...' content: [n=0] 
[11:00:01.579] List of 1
[11:00:01.579]  $ ...: list()
[11:00:01.579]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.579]  - attr(*, "where")=List of 1
[11:00:01.579]   ..$ ...:<environment: 0x55bbadca3c28> 
[11:00:01.579]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.579]  - attr(*, "resolved")= logi TRUE
[11:00:01.579]  - attr(*, "total_size")= num NA
[11:00:01.582]  - Getting '...' globals ... DONE
[11:00:01.582] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:01.582] List of 8
[11:00:01.582]  $ ...future.FUN:function (x, ...)  
[11:00:01.582]  $ x_FUN        :function (x)  
[11:00:01.582]  $ times        : int 4
[11:00:01.582]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.582]  $ stop_if_not  :function (...)  
[11:00:01.582]  $ dim          : int [1:2] 2 2
[11:00:01.582]  $ valid_types  : chr [1:2] "logical" "integer"
[11:00:01.582]  $ ...          : list()
[11:00:01.582]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.582]  - attr(*, "where")=List of 8
[11:00:01.582]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:01.582]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:01.582]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:01.582]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:01.582]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:01.582]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:01.582]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:01.582]   ..$ ...          :<environment: 0x55bbadca3c28> 
[11:00:01.582]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.582]  - attr(*, "resolved")= logi FALSE
[11:00:01.582]  - attr(*, "total_size")= num 24886
[11:00:01.589] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:01.590] getGlobalsAndPackagesXApply() ... DONE
[11:00:01.590] Number of futures (= number of chunks): 2
[11:00:01.590] Launching 2 futures (chunks) ...
[11:00:01.590] Chunk #1 of 2 ...
[11:00:01.590]  - Finding globals in 'X' for chunk #1 ...
[11:00:01.590] getGlobalsAndPackages() ...
[11:00:01.590] Searching for globals...
[11:00:01.591] 
[11:00:01.591] Searching for globals ... DONE
[11:00:01.591] - globals: [0] <none>
[11:00:01.591] getGlobalsAndPackages() ... DONE
[11:00:01.591]    + additional globals found: [n=0] 
[11:00:01.591]    + additional namespaces needed: [n=0] 
[11:00:01.591]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:01.591]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:01.591]  - seeds: <none>
[11:00:01.591]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.592] getGlobalsAndPackages() ...
[11:00:01.592] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.592] Resolving globals: FALSE
[11:00:01.592] Tweak future expression to call with '...' arguments ...
[11:00:01.592] {
[11:00:01.592]     do.call(function(...) {
[11:00:01.592]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.592]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.592]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.592]             on.exit(options(oopts), add = TRUE)
[11:00:01.592]         }
[11:00:01.592]         {
[11:00:01.592]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.592]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.592]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.592]             })
[11:00:01.592]         }
[11:00:01.592]     }, args = future.call.arguments)
[11:00:01.592] }
[11:00:01.592] Tweak future expression to call with '...' arguments ... DONE
[11:00:01.593] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.593] - packages: [1] ‘future.apply’
[11:00:01.593] getGlobalsAndPackages() ... DONE
[11:00:01.593] run() for ‘Future’ ...
[11:00:01.593] - state: ‘created’
[11:00:01.593] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:01.595] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.595] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:01.595]   - Field: ‘label’
[11:00:01.596]   - Field: ‘local’
[11:00:01.596]   - Field: ‘owner’
[11:00:01.596]   - Field: ‘envir’
[11:00:01.596]   - Field: ‘workers’
[11:00:01.596]   - Field: ‘packages’
[11:00:01.596]   - Field: ‘gc’
[11:00:01.596]   - Field: ‘job’
[11:00:01.596]   - Field: ‘conditions’
[11:00:01.596]   - Field: ‘expr’
[11:00:01.596]   - Field: ‘uuid’
[11:00:01.596]   - Field: ‘seed’
[11:00:01.596]   - Field: ‘version’
[11:00:01.597]   - Field: ‘result’
[11:00:01.597]   - Field: ‘asynchronous’
[11:00:01.597]   - Field: ‘calls’
[11:00:01.597]   - Field: ‘globals’
[11:00:01.597]   - Field: ‘stdout’
[11:00:01.597]   - Field: ‘earlySignal’
[11:00:01.597]   - Field: ‘lazy’
[11:00:01.597]   - Field: ‘state’
[11:00:01.597] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:01.597] - Launch lazy future ...
[11:00:01.598] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:01.598] Packages needed by future strategies (n = 0): <none>
[11:00:01.598] {
[11:00:01.598]     {
[11:00:01.598]         {
[11:00:01.598]             ...future.startTime <- base::Sys.time()
[11:00:01.598]             {
[11:00:01.598]                 {
[11:00:01.598]                   {
[11:00:01.598]                     {
[11:00:01.598]                       {
[11:00:01.598]                         base::local({
[11:00:01.598]                           has_future <- base::requireNamespace("future", 
[11:00:01.598]                             quietly = TRUE)
[11:00:01.598]                           if (has_future) {
[11:00:01.598]                             ns <- base::getNamespace("future")
[11:00:01.598]                             version <- ns[[".package"]][["version"]]
[11:00:01.598]                             if (is.null(version)) 
[11:00:01.598]                               version <- utils::packageVersion("future")
[11:00:01.598]                           }
[11:00:01.598]                           else {
[11:00:01.598]                             version <- NULL
[11:00:01.598]                           }
[11:00:01.598]                           if (!has_future || version < "1.8.0") {
[11:00:01.598]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:01.598]                               "", base::R.version$version.string), 
[11:00:01.598]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:01.598]                                 base::R.version$platform, 8 * 
[11:00:01.598]                                   base::.Machine$sizeof.pointer), 
[11:00:01.598]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:01.598]                                 "release", "version")], collapse = " "), 
[11:00:01.598]                               hostname = base::Sys.info()[["nodename"]])
[11:00:01.598]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:01.598]                               info)
[11:00:01.598]                             info <- base::paste(info, collapse = "; ")
[11:00:01.598]                             if (!has_future) {
[11:00:01.598]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:01.598]                                 info)
[11:00:01.598]                             }
[11:00:01.598]                             else {
[11:00:01.598]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:01.598]                                 info, version)
[11:00:01.598]                             }
[11:00:01.598]                             base::stop(msg)
[11:00:01.598]                           }
[11:00:01.598]                         })
[11:00:01.598]                       }
[11:00:01.598]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:01.598]                       base::options(mc.cores = 1L)
[11:00:01.598]                     }
[11:00:01.598]                     base::local({
[11:00:01.598]                       for (pkg in "future.apply") {
[11:00:01.598]                         base::loadNamespace(pkg)
[11:00:01.598]                         base::library(pkg, character.only = TRUE)
[11:00:01.598]                       }
[11:00:01.598]                     })
[11:00:01.598]                   }
[11:00:01.598]                   ...future.strategy.old <- future::plan("list")
[11:00:01.598]                   options(future.plan = NULL)
[11:00:01.598]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.598]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:01.598]                 }
[11:00:01.598]                 ...future.workdir <- getwd()
[11:00:01.598]             }
[11:00:01.598]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:01.598]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:01.598]         }
[11:00:01.598]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:01.598]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:01.598]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:01.598]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:01.598]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:01.598]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:01.598]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:01.598]             base::names(...future.oldOptions))
[11:00:01.598]     }
[11:00:01.598]     if (FALSE) {
[11:00:01.598]     }
[11:00:01.598]     else {
[11:00:01.598]         if (TRUE) {
[11:00:01.598]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:01.598]                 open = "w")
[11:00:01.598]         }
[11:00:01.598]         else {
[11:00:01.598]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:01.598]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:01.598]         }
[11:00:01.598]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:01.598]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:01.598]             base::sink(type = "output", split = FALSE)
[11:00:01.598]             base::close(...future.stdout)
[11:00:01.598]         }, add = TRUE)
[11:00:01.598]     }
[11:00:01.598]     ...future.frame <- base::sys.nframe()
[11:00:01.598]     ...future.conditions <- base::list()
[11:00:01.598]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:01.598]     if (FALSE) {
[11:00:01.598]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:01.598]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:01.598]     }
[11:00:01.598]     ...future.result <- base::tryCatch({
[11:00:01.598]         base::withCallingHandlers({
[11:00:01.598]             ...future.value <- base::withVisible(base::local({
[11:00:01.598]                 withCallingHandlers({
[11:00:01.598]                   {
[11:00:01.598]                     do.call(function(...) {
[11:00:01.598]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.598]                       if (!identical(...future.globals.maxSize.org, 
[11:00:01.598]                         ...future.globals.maxSize)) {
[11:00:01.598]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.598]                         on.exit(options(oopts), add = TRUE)
[11:00:01.598]                       }
[11:00:01.598]                       {
[11:00:01.598]                         lapply(seq_along(...future.elements_ii), 
[11:00:01.598]                           FUN = function(jj) {
[11:00:01.598]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.598]                             ...future.FUN(...future.X_jj, ...)
[11:00:01.598]                           })
[11:00:01.598]                       }
[11:00:01.598]                     }, args = future.call.arguments)
[11:00:01.598]                   }
[11:00:01.598]                 }, immediateCondition = function(cond) {
[11:00:01.598]                   save_rds <- function (object, pathname, ...) 
[11:00:01.598]                   {
[11:00:01.598]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:01.598]                     if (file_test("-f", pathname_tmp)) {
[11:00:01.598]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.598]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:01.598]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.598]                         fi_tmp[["mtime"]])
[11:00:01.598]                     }
[11:00:01.598]                     tryCatch({
[11:00:01.598]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:01.598]                     }, error = function(ex) {
[11:00:01.598]                       msg <- conditionMessage(ex)
[11:00:01.598]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.598]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:01.598]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.598]                         fi_tmp[["mtime"]], msg)
[11:00:01.598]                       ex$message <- msg
[11:00:01.598]                       stop(ex)
[11:00:01.598]                     })
[11:00:01.598]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:01.598]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:01.598]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:01.598]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.598]                       fi <- file.info(pathname)
[11:00:01.598]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:01.598]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.598]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:01.598]                         fi[["size"]], fi[["mtime"]])
[11:00:01.598]                       stop(msg)
[11:00:01.598]                     }
[11:00:01.598]                     invisible(pathname)
[11:00:01.598]                   }
[11:00:01.598]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:01.598]                     rootPath = tempdir()) 
[11:00:01.598]                   {
[11:00:01.598]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:01.598]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:01.598]                       tmpdir = path, fileext = ".rds")
[11:00:01.598]                     save_rds(obj, file)
[11:00:01.598]                   }
[11:00:01.598]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:01.598]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.598]                   {
[11:00:01.598]                     inherits <- base::inherits
[11:00:01.598]                     invokeRestart <- base::invokeRestart
[11:00:01.598]                     is.null <- base::is.null
[11:00:01.598]                     muffled <- FALSE
[11:00:01.598]                     if (inherits(cond, "message")) {
[11:00:01.598]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:01.598]                       if (muffled) 
[11:00:01.598]                         invokeRestart("muffleMessage")
[11:00:01.598]                     }
[11:00:01.598]                     else if (inherits(cond, "warning")) {
[11:00:01.598]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:01.598]                       if (muffled) 
[11:00:01.598]                         invokeRestart("muffleWarning")
[11:00:01.598]                     }
[11:00:01.598]                     else if (inherits(cond, "condition")) {
[11:00:01.598]                       if (!is.null(pattern)) {
[11:00:01.598]                         computeRestarts <- base::computeRestarts
[11:00:01.598]                         grepl <- base::grepl
[11:00:01.598]                         restarts <- computeRestarts(cond)
[11:00:01.598]                         for (restart in restarts) {
[11:00:01.598]                           name <- restart$name
[11:00:01.598]                           if (is.null(name)) 
[11:00:01.598]                             next
[11:00:01.598]                           if (!grepl(pattern, name)) 
[11:00:01.598]                             next
[11:00:01.598]                           invokeRestart(restart)
[11:00:01.598]                           muffled <- TRUE
[11:00:01.598]                           break
[11:00:01.598]                         }
[11:00:01.598]                       }
[11:00:01.598]                     }
[11:00:01.598]                     invisible(muffled)
[11:00:01.598]                   }
[11:00:01.598]                   muffleCondition(cond)
[11:00:01.598]                 })
[11:00:01.598]             }))
[11:00:01.598]             future::FutureResult(value = ...future.value$value, 
[11:00:01.598]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.598]                   ...future.rng), globalenv = if (FALSE) 
[11:00:01.598]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:01.598]                     ...future.globalenv.names))
[11:00:01.598]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:01.598]         }, condition = base::local({
[11:00:01.598]             c <- base::c
[11:00:01.598]             inherits <- base::inherits
[11:00:01.598]             invokeRestart <- base::invokeRestart
[11:00:01.598]             length <- base::length
[11:00:01.598]             list <- base::list
[11:00:01.598]             seq.int <- base::seq.int
[11:00:01.598]             signalCondition <- base::signalCondition
[11:00:01.598]             sys.calls <- base::sys.calls
[11:00:01.598]             `[[` <- base::`[[`
[11:00:01.598]             `+` <- base::`+`
[11:00:01.598]             `<<-` <- base::`<<-`
[11:00:01.598]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:01.598]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:01.598]                   3L)]
[11:00:01.598]             }
[11:00:01.598]             function(cond) {
[11:00:01.598]                 is_error <- inherits(cond, "error")
[11:00:01.598]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:01.598]                   NULL)
[11:00:01.598]                 if (is_error) {
[11:00:01.598]                   sessionInformation <- function() {
[11:00:01.598]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:01.598]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:01.598]                       search = base::search(), system = base::Sys.info())
[11:00:01.598]                   }
[11:00:01.598]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.598]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:01.598]                     cond$call), session = sessionInformation(), 
[11:00:01.598]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:01.598]                   signalCondition(cond)
[11:00:01.598]                 }
[11:00:01.598]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:01.598]                 "immediateCondition"))) {
[11:00:01.598]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:01.598]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.598]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:01.598]                   if (TRUE && !signal) {
[11:00:01.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.598]                     {
[11:00:01.598]                       inherits <- base::inherits
[11:00:01.598]                       invokeRestart <- base::invokeRestart
[11:00:01.598]                       is.null <- base::is.null
[11:00:01.598]                       muffled <- FALSE
[11:00:01.598]                       if (inherits(cond, "message")) {
[11:00:01.598]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.598]                         if (muffled) 
[11:00:01.598]                           invokeRestart("muffleMessage")
[11:00:01.598]                       }
[11:00:01.598]                       else if (inherits(cond, "warning")) {
[11:00:01.598]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.598]                         if (muffled) 
[11:00:01.598]                           invokeRestart("muffleWarning")
[11:00:01.598]                       }
[11:00:01.598]                       else if (inherits(cond, "condition")) {
[11:00:01.598]                         if (!is.null(pattern)) {
[11:00:01.598]                           computeRestarts <- base::computeRestarts
[11:00:01.598]                           grepl <- base::grepl
[11:00:01.598]                           restarts <- computeRestarts(cond)
[11:00:01.598]                           for (restart in restarts) {
[11:00:01.598]                             name <- restart$name
[11:00:01.598]                             if (is.null(name)) 
[11:00:01.598]                               next
[11:00:01.598]                             if (!grepl(pattern, name)) 
[11:00:01.598]                               next
[11:00:01.598]                             invokeRestart(restart)
[11:00:01.598]                             muffled <- TRUE
[11:00:01.598]                             break
[11:00:01.598]                           }
[11:00:01.598]                         }
[11:00:01.598]                       }
[11:00:01.598]                       invisible(muffled)
[11:00:01.598]                     }
[11:00:01.598]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.598]                   }
[11:00:01.598]                 }
[11:00:01.598]                 else {
[11:00:01.598]                   if (TRUE) {
[11:00:01.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.598]                     {
[11:00:01.598]                       inherits <- base::inherits
[11:00:01.598]                       invokeRestart <- base::invokeRestart
[11:00:01.598]                       is.null <- base::is.null
[11:00:01.598]                       muffled <- FALSE
[11:00:01.598]                       if (inherits(cond, "message")) {
[11:00:01.598]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.598]                         if (muffled) 
[11:00:01.598]                           invokeRestart("muffleMessage")
[11:00:01.598]                       }
[11:00:01.598]                       else if (inherits(cond, "warning")) {
[11:00:01.598]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.598]                         if (muffled) 
[11:00:01.598]                           invokeRestart("muffleWarning")
[11:00:01.598]                       }
[11:00:01.598]                       else if (inherits(cond, "condition")) {
[11:00:01.598]                         if (!is.null(pattern)) {
[11:00:01.598]                           computeRestarts <- base::computeRestarts
[11:00:01.598]                           grepl <- base::grepl
[11:00:01.598]                           restarts <- computeRestarts(cond)
[11:00:01.598]                           for (restart in restarts) {
[11:00:01.598]                             name <- restart$name
[11:00:01.598]                             if (is.null(name)) 
[11:00:01.598]                               next
[11:00:01.598]                             if (!grepl(pattern, name)) 
[11:00:01.598]                               next
[11:00:01.598]                             invokeRestart(restart)
[11:00:01.598]                             muffled <- TRUE
[11:00:01.598]                             break
[11:00:01.598]                           }
[11:00:01.598]                         }
[11:00:01.598]                       }
[11:00:01.598]                       invisible(muffled)
[11:00:01.598]                     }
[11:00:01.598]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.598]                   }
[11:00:01.598]                 }
[11:00:01.598]             }
[11:00:01.598]         }))
[11:00:01.598]     }, error = function(ex) {
[11:00:01.598]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:01.598]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.598]                 ...future.rng), started = ...future.startTime, 
[11:00:01.598]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:01.598]             version = "1.8"), class = "FutureResult")
[11:00:01.598]     }, finally = {
[11:00:01.598]         if (!identical(...future.workdir, getwd())) 
[11:00:01.598]             setwd(...future.workdir)
[11:00:01.598]         {
[11:00:01.598]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:01.598]                 ...future.oldOptions$nwarnings <- NULL
[11:00:01.598]             }
[11:00:01.598]             base::options(...future.oldOptions)
[11:00:01.598]             if (.Platform$OS.type == "windows") {
[11:00:01.598]                 old_names <- names(...future.oldEnvVars)
[11:00:01.598]                 envs <- base::Sys.getenv()
[11:00:01.598]                 names <- names(envs)
[11:00:01.598]                 common <- intersect(names, old_names)
[11:00:01.598]                 added <- setdiff(names, old_names)
[11:00:01.598]                 removed <- setdiff(old_names, names)
[11:00:01.598]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:01.598]                   envs[common]]
[11:00:01.598]                 NAMES <- toupper(changed)
[11:00:01.598]                 args <- list()
[11:00:01.598]                 for (kk in seq_along(NAMES)) {
[11:00:01.598]                   name <- changed[[kk]]
[11:00:01.598]                   NAME <- NAMES[[kk]]
[11:00:01.598]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.598]                     next
[11:00:01.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.598]                 }
[11:00:01.598]                 NAMES <- toupper(added)
[11:00:01.598]                 for (kk in seq_along(NAMES)) {
[11:00:01.598]                   name <- added[[kk]]
[11:00:01.598]                   NAME <- NAMES[[kk]]
[11:00:01.598]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.598]                     next
[11:00:01.598]                   args[[name]] <- ""
[11:00:01.598]                 }
[11:00:01.598]                 NAMES <- toupper(removed)
[11:00:01.598]                 for (kk in seq_along(NAMES)) {
[11:00:01.598]                   name <- removed[[kk]]
[11:00:01.598]                   NAME <- NAMES[[kk]]
[11:00:01.598]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.598]                     next
[11:00:01.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.598]                 }
[11:00:01.598]                 if (length(args) > 0) 
[11:00:01.598]                   base::do.call(base::Sys.setenv, args = args)
[11:00:01.598]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:01.598]             }
[11:00:01.598]             else {
[11:00:01.598]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:01.598]             }
[11:00:01.598]             {
[11:00:01.598]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:01.598]                   0L) {
[11:00:01.598]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:01.598]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:01.598]                   base::options(opts)
[11:00:01.598]                 }
[11:00:01.598]                 {
[11:00:01.598]                   {
[11:00:01.598]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:01.598]                     NULL
[11:00:01.598]                   }
[11:00:01.598]                   options(future.plan = NULL)
[11:00:01.598]                   if (is.na(NA_character_)) 
[11:00:01.598]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.598]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:01.598]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:01.598]                     .init = FALSE)
[11:00:01.598]                 }
[11:00:01.598]             }
[11:00:01.598]         }
[11:00:01.598]     })
[11:00:01.598]     if (TRUE) {
[11:00:01.598]         base::sink(type = "output", split = FALSE)
[11:00:01.598]         if (TRUE) {
[11:00:01.598]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:01.598]         }
[11:00:01.598]         else {
[11:00:01.598]             ...future.result["stdout"] <- base::list(NULL)
[11:00:01.598]         }
[11:00:01.598]         base::close(...future.stdout)
[11:00:01.598]         ...future.stdout <- NULL
[11:00:01.598]     }
[11:00:01.598]     ...future.result$conditions <- ...future.conditions
[11:00:01.598]     ...future.result$finished <- base::Sys.time()
[11:00:01.598]     ...future.result
[11:00:01.598] }
[11:00:01.601] assign_globals() ...
[11:00:01.601] List of 11
[11:00:01.601]  $ ...future.FUN            :function (x, ...)  
[11:00:01.601]  $ x_FUN                    :function (x)  
[11:00:01.601]  $ times                    : int 4
[11:00:01.601]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.601]  $ stop_if_not              :function (...)  
[11:00:01.601]  $ dim                      : int [1:2] 2 2
[11:00:01.601]  $ valid_types              : chr [1:2] "logical" "integer"
[11:00:01.601]  $ future.call.arguments    : list()
[11:00:01.601]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.601]  $ ...future.elements_ii    :List of 5
[11:00:01.601]   ..$ : int 1
[11:00:01.601]   ..$ : int 2
[11:00:01.601]   ..$ : int 3
[11:00:01.601]   ..$ : int 4
[11:00:01.601]   ..$ : int 5
[11:00:01.601]  $ ...future.seeds_ii       : NULL
[11:00:01.601]  $ ...future.globals.maxSize: NULL
[11:00:01.601]  - attr(*, "where")=List of 11
[11:00:01.601]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:01.601]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:01.601]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:01.601]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:01.601]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:01.601]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:01.601]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:01.601]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:01.601]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:01.601]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:01.601]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:01.601]  - attr(*, "resolved")= logi FALSE
[11:00:01.601]  - attr(*, "total_size")= num 24886
[11:00:01.601]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.601]  - attr(*, "already-done")= logi TRUE
[11:00:01.611] - copied ‘...future.FUN’ to environment
[11:00:01.611] - reassign environment for ‘x_FUN’
[11:00:01.611] - copied ‘x_FUN’ to environment
[11:00:01.612] - copied ‘times’ to environment
[11:00:01.612] - copied ‘stopf’ to environment
[11:00:01.612] - copied ‘stop_if_not’ to environment
[11:00:01.612] - copied ‘dim’ to environment
[11:00:01.612] - copied ‘valid_types’ to environment
[11:00:01.612] - copied ‘future.call.arguments’ to environment
[11:00:01.612] - copied ‘...future.elements_ii’ to environment
[11:00:01.612] - copied ‘...future.seeds_ii’ to environment
[11:00:01.612] - copied ‘...future.globals.maxSize’ to environment
[11:00:01.612] assign_globals() ... done
[11:00:01.612] requestCore(): workers = 2
[11:00:01.615] MulticoreFuture started
[11:00:01.615] - Launch lazy future ... done
[11:00:01.616] run() for ‘MulticoreFuture’ ... done
[11:00:01.616] Created future:
[11:00:01.617] plan(): Setting new future strategy stack:
[11:00:01.617] List of future strategies:
[11:00:01.617] 1. sequential:
[11:00:01.617]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:01.617]    - tweaked: FALSE
[11:00:01.617]    - call: NULL
[11:00:01.618] plan(): nbrOfWorkers() = 1
[11:00:01.621] plan(): Setting new future strategy stack:
[11:00:01.622] List of future strategies:
[11:00:01.622] 1. multicore:
[11:00:01.622]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:01.622]    - tweaked: FALSE
[11:00:01.622]    - call: plan(strategy)
[11:00:01.625] plan(): nbrOfWorkers() = 2
[11:00:01.617] MulticoreFuture:
[11:00:01.617] Label: ‘future_vapply-1’
[11:00:01.617] Expression:
[11:00:01.617] {
[11:00:01.617]     do.call(function(...) {
[11:00:01.617]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.617]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.617]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.617]             on.exit(options(oopts), add = TRUE)
[11:00:01.617]         }
[11:00:01.617]         {
[11:00:01.617]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.617]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.617]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.617]             })
[11:00:01.617]         }
[11:00:01.617]     }, args = future.call.arguments)
[11:00:01.617] }
[11:00:01.617] Lazy evaluation: FALSE
[11:00:01.617] Asynchronous evaluation: TRUE
[11:00:01.617] Local evaluation: TRUE
[11:00:01.617] Environment: R_GlobalEnv
[11:00:01.617] Capture standard output: TRUE
[11:00:01.617] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:01.617] Globals: 11 objects totaling 13.82 KiB (function ‘...future.FUN’ of 5.05 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:01.617] Packages: 1 packages (‘future.apply’)
[11:00:01.617] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:01.617] Resolved: TRUE
[11:00:01.617] Value: <not collected>
[11:00:01.617] Conditions captured: <none>
[11:00:01.617] Early signaling: FALSE
[11:00:01.617] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:01.617] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.626] Chunk #1 of 2 ... DONE
[11:00:01.626] Chunk #2 of 2 ...
[11:00:01.626]  - Finding globals in 'X' for chunk #2 ...
[11:00:01.627] getGlobalsAndPackages() ...
[11:00:01.627] Searching for globals...
[11:00:01.627] 
[11:00:01.627] Searching for globals ... DONE
[11:00:01.627] - globals: [0] <none>
[11:00:01.628] getGlobalsAndPackages() ... DONE
[11:00:01.628]    + additional globals found: [n=0] 
[11:00:01.628]    + additional namespaces needed: [n=0] 
[11:00:01.628]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:01.628]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:01.628]  - seeds: <none>
[11:00:01.628]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.628] getGlobalsAndPackages() ...
[11:00:01.629] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.629] Resolving globals: FALSE
[11:00:01.629] Tweak future expression to call with '...' arguments ...
[11:00:01.629] {
[11:00:01.629]     do.call(function(...) {
[11:00:01.629]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.629]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.629]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.629]             on.exit(options(oopts), add = TRUE)
[11:00:01.629]         }
[11:00:01.629]         {
[11:00:01.629]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.629]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.629]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.629]             })
[11:00:01.629]         }
[11:00:01.629]     }, args = future.call.arguments)
[11:00:01.629] }
[11:00:01.630] Tweak future expression to call with '...' arguments ... DONE
[11:00:01.631] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.631] - packages: [1] ‘future.apply’
[11:00:01.631] getGlobalsAndPackages() ... DONE
[11:00:01.631] run() for ‘Future’ ...
[11:00:01.632] - state: ‘created’
[11:00:01.632] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:01.634] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.635] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:01.635]   - Field: ‘label’
[11:00:01.635]   - Field: ‘local’
[11:00:01.635]   - Field: ‘owner’
[11:00:01.635]   - Field: ‘envir’
[11:00:01.635]   - Field: ‘workers’
[11:00:01.635]   - Field: ‘packages’
[11:00:01.636]   - Field: ‘gc’
[11:00:01.636]   - Field: ‘job’
[11:00:01.636]   - Field: ‘conditions’
[11:00:01.636]   - Field: ‘expr’
[11:00:01.636]   - Field: ‘uuid’
[11:00:01.636]   - Field: ‘seed’
[11:00:01.636]   - Field: ‘version’
[11:00:01.636]   - Field: ‘result’
[11:00:01.637]   - Field: ‘asynchronous’
[11:00:01.637]   - Field: ‘calls’
[11:00:01.637]   - Field: ‘globals’
[11:00:01.637]   - Field: ‘stdout’
[11:00:01.637]   - Field: ‘earlySignal’
[11:00:01.637]   - Field: ‘lazy’
[11:00:01.638]   - Field: ‘state’
[11:00:01.638] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:01.638] - Launch lazy future ...
[11:00:01.638] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:01.638] Packages needed by future strategies (n = 0): <none>
[11:00:01.639] {
[11:00:01.639]     {
[11:00:01.639]         {
[11:00:01.639]             ...future.startTime <- base::Sys.time()
[11:00:01.639]             {
[11:00:01.639]                 {
[11:00:01.639]                   {
[11:00:01.639]                     {
[11:00:01.639]                       {
[11:00:01.639]                         base::local({
[11:00:01.639]                           has_future <- base::requireNamespace("future", 
[11:00:01.639]                             quietly = TRUE)
[11:00:01.639]                           if (has_future) {
[11:00:01.639]                             ns <- base::getNamespace("future")
[11:00:01.639]                             version <- ns[[".package"]][["version"]]
[11:00:01.639]                             if (is.null(version)) 
[11:00:01.639]                               version <- utils::packageVersion("future")
[11:00:01.639]                           }
[11:00:01.639]                           else {
[11:00:01.639]                             version <- NULL
[11:00:01.639]                           }
[11:00:01.639]                           if (!has_future || version < "1.8.0") {
[11:00:01.639]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:01.639]                               "", base::R.version$version.string), 
[11:00:01.639]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:01.639]                                 base::R.version$platform, 8 * 
[11:00:01.639]                                   base::.Machine$sizeof.pointer), 
[11:00:01.639]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:01.639]                                 "release", "version")], collapse = " "), 
[11:00:01.639]                               hostname = base::Sys.info()[["nodename"]])
[11:00:01.639]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:01.639]                               info)
[11:00:01.639]                             info <- base::paste(info, collapse = "; ")
[11:00:01.639]                             if (!has_future) {
[11:00:01.639]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:01.639]                                 info)
[11:00:01.639]                             }
[11:00:01.639]                             else {
[11:00:01.639]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:01.639]                                 info, version)
[11:00:01.639]                             }
[11:00:01.639]                             base::stop(msg)
[11:00:01.639]                           }
[11:00:01.639]                         })
[11:00:01.639]                       }
[11:00:01.639]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:01.639]                       base::options(mc.cores = 1L)
[11:00:01.639]                     }
[11:00:01.639]                     base::local({
[11:00:01.639]                       for (pkg in "future.apply") {
[11:00:01.639]                         base::loadNamespace(pkg)
[11:00:01.639]                         base::library(pkg, character.only = TRUE)
[11:00:01.639]                       }
[11:00:01.639]                     })
[11:00:01.639]                   }
[11:00:01.639]                   ...future.strategy.old <- future::plan("list")
[11:00:01.639]                   options(future.plan = NULL)
[11:00:01.639]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.639]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:01.639]                 }
[11:00:01.639]                 ...future.workdir <- getwd()
[11:00:01.639]             }
[11:00:01.639]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:01.639]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:01.639]         }
[11:00:01.639]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:01.639]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:01.639]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:01.639]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:01.639]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:01.639]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:01.639]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:01.639]             base::names(...future.oldOptions))
[11:00:01.639]     }
[11:00:01.639]     if (FALSE) {
[11:00:01.639]     }
[11:00:01.639]     else {
[11:00:01.639]         if (TRUE) {
[11:00:01.639]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:01.639]                 open = "w")
[11:00:01.639]         }
[11:00:01.639]         else {
[11:00:01.639]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:01.639]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:01.639]         }
[11:00:01.639]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:01.639]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:01.639]             base::sink(type = "output", split = FALSE)
[11:00:01.639]             base::close(...future.stdout)
[11:00:01.639]         }, add = TRUE)
[11:00:01.639]     }
[11:00:01.639]     ...future.frame <- base::sys.nframe()
[11:00:01.639]     ...future.conditions <- base::list()
[11:00:01.639]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:01.639]     if (FALSE) {
[11:00:01.639]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:01.639]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:01.639]     }
[11:00:01.639]     ...future.result <- base::tryCatch({
[11:00:01.639]         base::withCallingHandlers({
[11:00:01.639]             ...future.value <- base::withVisible(base::local({
[11:00:01.639]                 withCallingHandlers({
[11:00:01.639]                   {
[11:00:01.639]                     do.call(function(...) {
[11:00:01.639]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.639]                       if (!identical(...future.globals.maxSize.org, 
[11:00:01.639]                         ...future.globals.maxSize)) {
[11:00:01.639]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.639]                         on.exit(options(oopts), add = TRUE)
[11:00:01.639]                       }
[11:00:01.639]                       {
[11:00:01.639]                         lapply(seq_along(...future.elements_ii), 
[11:00:01.639]                           FUN = function(jj) {
[11:00:01.639]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.639]                             ...future.FUN(...future.X_jj, ...)
[11:00:01.639]                           })
[11:00:01.639]                       }
[11:00:01.639]                     }, args = future.call.arguments)
[11:00:01.639]                   }
[11:00:01.639]                 }, immediateCondition = function(cond) {
[11:00:01.639]                   save_rds <- function (object, pathname, ...) 
[11:00:01.639]                   {
[11:00:01.639]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:01.639]                     if (file_test("-f", pathname_tmp)) {
[11:00:01.639]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.639]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:01.639]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.639]                         fi_tmp[["mtime"]])
[11:00:01.639]                     }
[11:00:01.639]                     tryCatch({
[11:00:01.639]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:01.639]                     }, error = function(ex) {
[11:00:01.639]                       msg <- conditionMessage(ex)
[11:00:01.639]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.639]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:01.639]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.639]                         fi_tmp[["mtime"]], msg)
[11:00:01.639]                       ex$message <- msg
[11:00:01.639]                       stop(ex)
[11:00:01.639]                     })
[11:00:01.639]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:01.639]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:01.639]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:01.639]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.639]                       fi <- file.info(pathname)
[11:00:01.639]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:01.639]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.639]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:01.639]                         fi[["size"]], fi[["mtime"]])
[11:00:01.639]                       stop(msg)
[11:00:01.639]                     }
[11:00:01.639]                     invisible(pathname)
[11:00:01.639]                   }
[11:00:01.639]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:01.639]                     rootPath = tempdir()) 
[11:00:01.639]                   {
[11:00:01.639]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:01.639]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:01.639]                       tmpdir = path, fileext = ".rds")
[11:00:01.639]                     save_rds(obj, file)
[11:00:01.639]                   }
[11:00:01.639]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:01.639]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.639]                   {
[11:00:01.639]                     inherits <- base::inherits
[11:00:01.639]                     invokeRestart <- base::invokeRestart
[11:00:01.639]                     is.null <- base::is.null
[11:00:01.639]                     muffled <- FALSE
[11:00:01.639]                     if (inherits(cond, "message")) {
[11:00:01.639]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:01.639]                       if (muffled) 
[11:00:01.639]                         invokeRestart("muffleMessage")
[11:00:01.639]                     }
[11:00:01.639]                     else if (inherits(cond, "warning")) {
[11:00:01.639]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:01.639]                       if (muffled) 
[11:00:01.639]                         invokeRestart("muffleWarning")
[11:00:01.639]                     }
[11:00:01.639]                     else if (inherits(cond, "condition")) {
[11:00:01.639]                       if (!is.null(pattern)) {
[11:00:01.639]                         computeRestarts <- base::computeRestarts
[11:00:01.639]                         grepl <- base::grepl
[11:00:01.639]                         restarts <- computeRestarts(cond)
[11:00:01.639]                         for (restart in restarts) {
[11:00:01.639]                           name <- restart$name
[11:00:01.639]                           if (is.null(name)) 
[11:00:01.639]                             next
[11:00:01.639]                           if (!grepl(pattern, name)) 
[11:00:01.639]                             next
[11:00:01.639]                           invokeRestart(restart)
[11:00:01.639]                           muffled <- TRUE
[11:00:01.639]                           break
[11:00:01.639]                         }
[11:00:01.639]                       }
[11:00:01.639]                     }
[11:00:01.639]                     invisible(muffled)
[11:00:01.639]                   }
[11:00:01.639]                   muffleCondition(cond)
[11:00:01.639]                 })
[11:00:01.639]             }))
[11:00:01.639]             future::FutureResult(value = ...future.value$value, 
[11:00:01.639]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.639]                   ...future.rng), globalenv = if (FALSE) 
[11:00:01.639]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:01.639]                     ...future.globalenv.names))
[11:00:01.639]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:01.639]         }, condition = base::local({
[11:00:01.639]             c <- base::c
[11:00:01.639]             inherits <- base::inherits
[11:00:01.639]             invokeRestart <- base::invokeRestart
[11:00:01.639]             length <- base::length
[11:00:01.639]             list <- base::list
[11:00:01.639]             seq.int <- base::seq.int
[11:00:01.639]             signalCondition <- base::signalCondition
[11:00:01.639]             sys.calls <- base::sys.calls
[11:00:01.639]             `[[` <- base::`[[`
[11:00:01.639]             `+` <- base::`+`
[11:00:01.639]             `<<-` <- base::`<<-`
[11:00:01.639]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:01.639]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:01.639]                   3L)]
[11:00:01.639]             }
[11:00:01.639]             function(cond) {
[11:00:01.639]                 is_error <- inherits(cond, "error")
[11:00:01.639]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:01.639]                   NULL)
[11:00:01.639]                 if (is_error) {
[11:00:01.639]                   sessionInformation <- function() {
[11:00:01.639]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:01.639]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:01.639]                       search = base::search(), system = base::Sys.info())
[11:00:01.639]                   }
[11:00:01.639]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.639]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:01.639]                     cond$call), session = sessionInformation(), 
[11:00:01.639]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:01.639]                   signalCondition(cond)
[11:00:01.639]                 }
[11:00:01.639]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:01.639]                 "immediateCondition"))) {
[11:00:01.639]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:01.639]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.639]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:01.639]                   if (TRUE && !signal) {
[11:00:01.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.639]                     {
[11:00:01.639]                       inherits <- base::inherits
[11:00:01.639]                       invokeRestart <- base::invokeRestart
[11:00:01.639]                       is.null <- base::is.null
[11:00:01.639]                       muffled <- FALSE
[11:00:01.639]                       if (inherits(cond, "message")) {
[11:00:01.639]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.639]                         if (muffled) 
[11:00:01.639]                           invokeRestart("muffleMessage")
[11:00:01.639]                       }
[11:00:01.639]                       else if (inherits(cond, "warning")) {
[11:00:01.639]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.639]                         if (muffled) 
[11:00:01.639]                           invokeRestart("muffleWarning")
[11:00:01.639]                       }
[11:00:01.639]                       else if (inherits(cond, "condition")) {
[11:00:01.639]                         if (!is.null(pattern)) {
[11:00:01.639]                           computeRestarts <- base::computeRestarts
[11:00:01.639]                           grepl <- base::grepl
[11:00:01.639]                           restarts <- computeRestarts(cond)
[11:00:01.639]                           for (restart in restarts) {
[11:00:01.639]                             name <- restart$name
[11:00:01.639]                             if (is.null(name)) 
[11:00:01.639]                               next
[11:00:01.639]                             if (!grepl(pattern, name)) 
[11:00:01.639]                               next
[11:00:01.639]                             invokeRestart(restart)
[11:00:01.639]                             muffled <- TRUE
[11:00:01.639]                             break
[11:00:01.639]                           }
[11:00:01.639]                         }
[11:00:01.639]                       }
[11:00:01.639]                       invisible(muffled)
[11:00:01.639]                     }
[11:00:01.639]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.639]                   }
[11:00:01.639]                 }
[11:00:01.639]                 else {
[11:00:01.639]                   if (TRUE) {
[11:00:01.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.639]                     {
[11:00:01.639]                       inherits <- base::inherits
[11:00:01.639]                       invokeRestart <- base::invokeRestart
[11:00:01.639]                       is.null <- base::is.null
[11:00:01.639]                       muffled <- FALSE
[11:00:01.639]                       if (inherits(cond, "message")) {
[11:00:01.639]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.639]                         if (muffled) 
[11:00:01.639]                           invokeRestart("muffleMessage")
[11:00:01.639]                       }
[11:00:01.639]                       else if (inherits(cond, "warning")) {
[11:00:01.639]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.639]                         if (muffled) 
[11:00:01.639]                           invokeRestart("muffleWarning")
[11:00:01.639]                       }
[11:00:01.639]                       else if (inherits(cond, "condition")) {
[11:00:01.639]                         if (!is.null(pattern)) {
[11:00:01.639]                           computeRestarts <- base::computeRestarts
[11:00:01.639]                           grepl <- base::grepl
[11:00:01.639]                           restarts <- computeRestarts(cond)
[11:00:01.639]                           for (restart in restarts) {
[11:00:01.639]                             name <- restart$name
[11:00:01.639]                             if (is.null(name)) 
[11:00:01.639]                               next
[11:00:01.639]                             if (!grepl(pattern, name)) 
[11:00:01.639]                               next
[11:00:01.639]                             invokeRestart(restart)
[11:00:01.639]                             muffled <- TRUE
[11:00:01.639]                             break
[11:00:01.639]                           }
[11:00:01.639]                         }
[11:00:01.639]                       }
[11:00:01.639]                       invisible(muffled)
[11:00:01.639]                     }
[11:00:01.639]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.639]                   }
[11:00:01.639]                 }
[11:00:01.639]             }
[11:00:01.639]         }))
[11:00:01.639]     }, error = function(ex) {
[11:00:01.639]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:01.639]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.639]                 ...future.rng), started = ...future.startTime, 
[11:00:01.639]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:01.639]             version = "1.8"), class = "FutureResult")
[11:00:01.639]     }, finally = {
[11:00:01.639]         if (!identical(...future.workdir, getwd())) 
[11:00:01.639]             setwd(...future.workdir)
[11:00:01.639]         {
[11:00:01.639]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:01.639]                 ...future.oldOptions$nwarnings <- NULL
[11:00:01.639]             }
[11:00:01.639]             base::options(...future.oldOptions)
[11:00:01.639]             if (.Platform$OS.type == "windows") {
[11:00:01.639]                 old_names <- names(...future.oldEnvVars)
[11:00:01.639]                 envs <- base::Sys.getenv()
[11:00:01.639]                 names <- names(envs)
[11:00:01.639]                 common <- intersect(names, old_names)
[11:00:01.639]                 added <- setdiff(names, old_names)
[11:00:01.639]                 removed <- setdiff(old_names, names)
[11:00:01.639]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:01.639]                   envs[common]]
[11:00:01.639]                 NAMES <- toupper(changed)
[11:00:01.639]                 args <- list()
[11:00:01.639]                 for (kk in seq_along(NAMES)) {
[11:00:01.639]                   name <- changed[[kk]]
[11:00:01.639]                   NAME <- NAMES[[kk]]
[11:00:01.639]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.639]                     next
[11:00:01.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.639]                 }
[11:00:01.639]                 NAMES <- toupper(added)
[11:00:01.639]                 for (kk in seq_along(NAMES)) {
[11:00:01.639]                   name <- added[[kk]]
[11:00:01.639]                   NAME <- NAMES[[kk]]
[11:00:01.639]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.639]                     next
[11:00:01.639]                   args[[name]] <- ""
[11:00:01.639]                 }
[11:00:01.639]                 NAMES <- toupper(removed)
[11:00:01.639]                 for (kk in seq_along(NAMES)) {
[11:00:01.639]                   name <- removed[[kk]]
[11:00:01.639]                   NAME <- NAMES[[kk]]
[11:00:01.639]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.639]                     next
[11:00:01.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.639]                 }
[11:00:01.639]                 if (length(args) > 0) 
[11:00:01.639]                   base::do.call(base::Sys.setenv, args = args)
[11:00:01.639]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:01.639]             }
[11:00:01.639]             else {
[11:00:01.639]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:01.639]             }
[11:00:01.639]             {
[11:00:01.639]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:01.639]                   0L) {
[11:00:01.639]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:01.639]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:01.639]                   base::options(opts)
[11:00:01.639]                 }
[11:00:01.639]                 {
[11:00:01.639]                   {
[11:00:01.639]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:01.639]                     NULL
[11:00:01.639]                   }
[11:00:01.639]                   options(future.plan = NULL)
[11:00:01.639]                   if (is.na(NA_character_)) 
[11:00:01.639]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.639]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:01.639]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:01.639]                     .init = FALSE)
[11:00:01.639]                 }
[11:00:01.639]             }
[11:00:01.639]         }
[11:00:01.639]     })
[11:00:01.639]     if (TRUE) {
[11:00:01.639]         base::sink(type = "output", split = FALSE)
[11:00:01.639]         if (TRUE) {
[11:00:01.639]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:01.639]         }
[11:00:01.639]         else {
[11:00:01.639]             ...future.result["stdout"] <- base::list(NULL)
[11:00:01.639]         }
[11:00:01.639]         base::close(...future.stdout)
[11:00:01.639]         ...future.stdout <- NULL
[11:00:01.639]     }
[11:00:01.639]     ...future.result$conditions <- ...future.conditions
[11:00:01.639]     ...future.result$finished <- base::Sys.time()
[11:00:01.639]     ...future.result
[11:00:01.639] }
[11:00:01.643] assign_globals() ...
[11:00:01.643] List of 11
[11:00:01.643]  $ ...future.FUN            :function (x, ...)  
[11:00:01.643]  $ x_FUN                    :function (x)  
[11:00:01.643]  $ times                    : int 4
[11:00:01.643]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.643]  $ stop_if_not              :function (...)  
[11:00:01.643]  $ dim                      : int [1:2] 2 2
[11:00:01.643]  $ valid_types              : chr [1:2] "logical" "integer"
[11:00:01.643]  $ future.call.arguments    : list()
[11:00:01.643]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.643]  $ ...future.elements_ii    :List of 5
[11:00:01.643]   ..$ : int 6
[11:00:01.643]   ..$ : int 7
[11:00:01.643]   ..$ : int 8
[11:00:01.643]   ..$ : int 9
[11:00:01.643]   ..$ : int 10
[11:00:01.643]  $ ...future.seeds_ii       : NULL
[11:00:01.643]  $ ...future.globals.maxSize: NULL
[11:00:01.643]  - attr(*, "where")=List of 11
[11:00:01.643]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:01.643]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:01.643]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:01.643]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:01.643]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:01.643]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:01.643]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:01.643]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:01.643]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:01.643]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:01.643]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:01.643]  - attr(*, "resolved")= logi FALSE
[11:00:01.643]  - attr(*, "total_size")= num 24886
[11:00:01.643]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.643]  - attr(*, "already-done")= logi TRUE
[11:00:01.659] - copied ‘...future.FUN’ to environment
[11:00:01.659] - reassign environment for ‘x_FUN’
[11:00:01.659] - copied ‘x_FUN’ to environment
[11:00:01.659] - copied ‘times’ to environment
[11:00:01.659] - copied ‘stopf’ to environment
[11:00:01.659] - copied ‘stop_if_not’ to environment
[11:00:01.659] - copied ‘dim’ to environment
[11:00:01.659] - copied ‘valid_types’ to environment
[11:00:01.660] - copied ‘future.call.arguments’ to environment
[11:00:01.660] - copied ‘...future.elements_ii’ to environment
[11:00:01.660] - copied ‘...future.seeds_ii’ to environment
[11:00:01.660] - copied ‘...future.globals.maxSize’ to environment
[11:00:01.660] assign_globals() ... done
[11:00:01.660] requestCore(): workers = 2
[11:00:01.662] MulticoreFuture started
[11:00:01.663] - Launch lazy future ... done
[11:00:01.663] run() for ‘MulticoreFuture’ ... done
[11:00:01.663] Created future:
[11:00:01.664] plan(): Setting new future strategy stack:
[11:00:01.664] List of future strategies:
[11:00:01.664] 1. sequential:
[11:00:01.664]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:01.664]    - tweaked: FALSE
[11:00:01.664]    - call: NULL
[11:00:01.665] plan(): nbrOfWorkers() = 1
[11:00:01.667] plan(): Setting new future strategy stack:
[11:00:01.668] List of future strategies:
[11:00:01.668] 1. multicore:
[11:00:01.668]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:01.668]    - tweaked: FALSE
[11:00:01.668]    - call: plan(strategy)
[11:00:01.671] plan(): nbrOfWorkers() = 2
[11:00:01.664] MulticoreFuture:
[11:00:01.664] Label: ‘future_vapply-2’
[11:00:01.664] Expression:
[11:00:01.664] {
[11:00:01.664]     do.call(function(...) {
[11:00:01.664]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.664]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.664]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.664]             on.exit(options(oopts), add = TRUE)
[11:00:01.664]         }
[11:00:01.664]         {
[11:00:01.664]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.664]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.664]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.664]             })
[11:00:01.664]         }
[11:00:01.664]     }, args = future.call.arguments)
[11:00:01.664] }
[11:00:01.664] Lazy evaluation: FALSE
[11:00:01.664] Asynchronous evaluation: TRUE
[11:00:01.664] Local evaluation: TRUE
[11:00:01.664] Environment: R_GlobalEnv
[11:00:01.664] Capture standard output: TRUE
[11:00:01.664] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:01.664] Globals: 11 objects totaling 13.82 KiB (function ‘...future.FUN’ of 5.05 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:01.664] Packages: 1 packages (‘future.apply’)
[11:00:01.664] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:01.664] Resolved: TRUE
[11:00:01.664] Value: <not collected>
[11:00:01.664] Conditions captured: <none>
[11:00:01.664] Early signaling: FALSE
[11:00:01.664] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:01.664] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.672] Chunk #2 of 2 ... DONE
[11:00:01.672] Launching 2 futures (chunks) ... DONE
[11:00:01.672] Resolving 2 futures (chunks) ...
[11:00:01.673] resolve() on list ...
[11:00:01.673]  recursive: 0
[11:00:01.673]  length: 2
[11:00:01.673] 
[11:00:01.673] Future #1
[11:00:01.673] result() for MulticoreFuture ...
[11:00:01.674] result() for MulticoreFuture ...
[11:00:01.675] result() for MulticoreFuture ... done
[11:00:01.675] result() for MulticoreFuture ... done
[11:00:01.675] result() for MulticoreFuture ...
[11:00:01.675] result() for MulticoreFuture ... done
[11:00:01.675] signalConditionsASAP(MulticoreFuture, pos=1) ...
[11:00:01.675] - nx: 2
[11:00:01.676] - relay: TRUE
[11:00:01.676] - stdout: TRUE
[11:00:01.676] - signal: TRUE
[11:00:01.676] - resignal: FALSE
[11:00:01.676] - force: TRUE
[11:00:01.676] - relayed: [n=2] FALSE, FALSE
[11:00:01.676] - queued futures: [n=2] FALSE, FALSE
[11:00:01.677]  - until=1
[11:00:01.677]  - relaying element #1
[11:00:01.677] result() for MulticoreFuture ...
[11:00:01.677] result() for MulticoreFuture ... done
[11:00:01.677] result() for MulticoreFuture ...
[11:00:01.677] result() for MulticoreFuture ... done
[11:00:01.678] result() for MulticoreFuture ...
[11:00:01.678] result() for MulticoreFuture ... done
[11:00:01.678] result() for MulticoreFuture ...
[11:00:01.678] result() for MulticoreFuture ... done
[11:00:01.678] - relayed: [n=2] TRUE, FALSE
[11:00:01.678] - queued futures: [n=2] TRUE, FALSE
[11:00:01.678] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[11:00:01.679]  length: 1 (resolved future 1)
[11:00:01.679] Future #2
[11:00:01.679] result() for MulticoreFuture ...
[11:00:01.680] result() for MulticoreFuture ...
[11:00:01.680] result() for MulticoreFuture ... done
[11:00:01.680] result() for MulticoreFuture ... done
[11:00:01.680] result() for MulticoreFuture ...
[11:00:01.680] result() for MulticoreFuture ... done
[11:00:01.681] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:00:01.681] - nx: 2
[11:00:01.681] - relay: TRUE
[11:00:01.681] - stdout: TRUE
[11:00:01.681] - signal: TRUE
[11:00:01.681] - resignal: FALSE
[11:00:01.681] - force: TRUE
[11:00:01.681] - relayed: [n=2] TRUE, FALSE
[11:00:01.681] - queued futures: [n=2] TRUE, FALSE
[11:00:01.682]  - until=2
[11:00:01.682]  - relaying element #2
[11:00:01.682] result() for MulticoreFuture ...
[11:00:01.682] result() for MulticoreFuture ... done
[11:00:01.682] result() for MulticoreFuture ...
[11:00:01.682] result() for MulticoreFuture ... done
[11:00:01.682] result() for MulticoreFuture ...
[11:00:01.682] result() for MulticoreFuture ... done
[11:00:01.683] result() for MulticoreFuture ...
[11:00:01.683] result() for MulticoreFuture ... done
[11:00:01.683] - relayed: [n=2] TRUE, TRUE
[11:00:01.683] - queued futures: [n=2] TRUE, TRUE
[11:00:01.683] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:00:01.683]  length: 0 (resolved future 2)
[11:00:01.683] Relaying remaining futures
[11:00:01.683] signalConditionsASAP(NULL, pos=0) ...
[11:00:01.683] - nx: 2
[11:00:01.684] - relay: TRUE
[11:00:01.684] - stdout: TRUE
[11:00:01.684] - signal: TRUE
[11:00:01.684] - resignal: FALSE
[11:00:01.684] - force: TRUE
[11:00:01.684] - relayed: [n=2] TRUE, TRUE
[11:00:01.684] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:01.684] - relayed: [n=2] TRUE, TRUE
[11:00:01.684] - queued futures: [n=2] TRUE, TRUE
[11:00:01.685] signalConditionsASAP(NULL, pos=0) ... done
[11:00:01.685] resolve() on list ... DONE
[11:00:01.685] result() for MulticoreFuture ...
[11:00:01.685] result() for MulticoreFuture ... done
[11:00:01.685] result() for MulticoreFuture ...
[11:00:01.685] result() for MulticoreFuture ... done
[11:00:01.685] result() for MulticoreFuture ...
[11:00:01.685] result() for MulticoreFuture ... done
[11:00:01.685] result() for MulticoreFuture ...
[11:00:01.686] result() for MulticoreFuture ... done
[11:00:01.686]  - Number of value chunks collected: 2
[11:00:01.686] Resolving 2 futures (chunks) ... DONE
[11:00:01.686] Reducing values from 2 chunks ...
[11:00:01.686]  - Number of values collected after concatenation: 10
[11:00:01.686]  - Number of values expected: 10
[11:00:01.686] Reducing values from 2 chunks ... DONE
[11:00:01.686] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[11:00:01.688] future_lapply() ...
[11:00:01.695] Number of chunks: 2
[11:00:01.695] getGlobalsAndPackagesXApply() ...
[11:00:01.695]  - future.globals: TRUE
[11:00:01.695] getGlobalsAndPackages() ...
[11:00:01.695] Searching for globals...
[11:00:01.700] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[11:00:01.700] Searching for globals ... DONE
[11:00:01.700] Resolving globals: FALSE
[11:00:01.701] The total size of the 7 globals is 13.63 KiB (13957 bytes)
[11:00:01.701] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.63 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.09 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:01.701] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:01.701] - packages: [1] ‘future.apply’
[11:00:01.702] getGlobalsAndPackages() ... DONE
[11:00:01.702]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:01.702]  - needed namespaces: [n=1] ‘future.apply’
[11:00:01.702] Finding globals ... DONE
[11:00:01.702]  - use_args: TRUE
[11:00:01.702]  - Getting '...' globals ...
[11:00:01.702] resolve() on list ...
[11:00:01.702]  recursive: 0
[11:00:01.703]  length: 1
[11:00:01.703]  elements: ‘...’
[11:00:01.703]  length: 0 (resolved future 1)
[11:00:01.703] resolve() on list ... DONE
[11:00:01.703]    - '...' content: [n=0] 
[11:00:01.703] List of 1
[11:00:01.703]  $ ...: list()
[11:00:01.703]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.703]  - attr(*, "where")=List of 1
[11:00:01.703]   ..$ ...:<environment: 0x55bbad704470> 
[11:00:01.703]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.703]  - attr(*, "resolved")= logi TRUE
[11:00:01.703]  - attr(*, "total_size")= num NA
[11:00:01.705]  - Getting '...' globals ... DONE
[11:00:01.706] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:01.706] List of 8
[11:00:01.706]  $ ...future.FUN:function (x, ...)  
[11:00:01.706]  $ x_FUN        :function (x)  
[11:00:01.706]  $ times        : int 4
[11:00:01.706]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.706]  $ stop_if_not  :function (...)  
[11:00:01.706]  $ dim          : int [1:2] 2 2
[11:00:01.706]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:01.706]  $ ...          : list()
[11:00:01.706]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.706]  - attr(*, "where")=List of 8
[11:00:01.706]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:01.706]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:01.706]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:01.706]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:01.706]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:01.706]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:01.706]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:01.706]   ..$ ...          :<environment: 0x55bbad704470> 
[11:00:01.706]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.706]  - attr(*, "resolved")= logi FALSE
[11:00:01.706]  - attr(*, "total_size")= num 24958
[11:00:01.713] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:01.713] getGlobalsAndPackagesXApply() ... DONE
[11:00:01.714] Number of futures (= number of chunks): 2
[11:00:01.714] Launching 2 futures (chunks) ...
[11:00:01.714] Chunk #1 of 2 ...
[11:00:01.714]  - Finding globals in 'X' for chunk #1 ...
[11:00:01.714] getGlobalsAndPackages() ...
[11:00:01.714] Searching for globals...
[11:00:01.714] 
[11:00:01.715] Searching for globals ... DONE
[11:00:01.715] - globals: [0] <none>
[11:00:01.715] getGlobalsAndPackages() ... DONE
[11:00:01.715]    + additional globals found: [n=0] 
[11:00:01.715]    + additional namespaces needed: [n=0] 
[11:00:01.715]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:01.715]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:01.715]  - seeds: <none>
[11:00:01.715]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.716] getGlobalsAndPackages() ...
[11:00:01.716] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.716] Resolving globals: FALSE
[11:00:01.716] Tweak future expression to call with '...' arguments ...
[11:00:01.716] {
[11:00:01.716]     do.call(function(...) {
[11:00:01.716]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.716]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.716]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.716]             on.exit(options(oopts), add = TRUE)
[11:00:01.716]         }
[11:00:01.716]         {
[11:00:01.716]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.716]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.716]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.716]             })
[11:00:01.716]         }
[11:00:01.716]     }, args = future.call.arguments)
[11:00:01.716] }
[11:00:01.716] Tweak future expression to call with '...' arguments ... DONE
[11:00:01.717] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.717] - packages: [1] ‘future.apply’
[11:00:01.717] getGlobalsAndPackages() ... DONE
[11:00:01.717] run() for ‘Future’ ...
[11:00:01.717] - state: ‘created’
[11:00:01.718] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:01.719] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.719] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:01.720]   - Field: ‘label’
[11:00:01.720]   - Field: ‘local’
[11:00:01.720]   - Field: ‘owner’
[11:00:01.720]   - Field: ‘envir’
[11:00:01.720]   - Field: ‘workers’
[11:00:01.720]   - Field: ‘packages’
[11:00:01.720]   - Field: ‘gc’
[11:00:01.720]   - Field: ‘job’
[11:00:01.720]   - Field: ‘conditions’
[11:00:01.720]   - Field: ‘expr’
[11:00:01.720]   - Field: ‘uuid’
[11:00:01.721]   - Field: ‘seed’
[11:00:01.721]   - Field: ‘version’
[11:00:01.721]   - Field: ‘result’
[11:00:01.721]   - Field: ‘asynchronous’
[11:00:01.721]   - Field: ‘calls’
[11:00:01.721]   - Field: ‘globals’
[11:00:01.721]   - Field: ‘stdout’
[11:00:01.721]   - Field: ‘earlySignal’
[11:00:01.721]   - Field: ‘lazy’
[11:00:01.721]   - Field: ‘state’
[11:00:01.721] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:01.721] - Launch lazy future ...
[11:00:01.722] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:01.722] Packages needed by future strategies (n = 0): <none>
[11:00:01.722] {
[11:00:01.722]     {
[11:00:01.722]         {
[11:00:01.722]             ...future.startTime <- base::Sys.time()
[11:00:01.722]             {
[11:00:01.722]                 {
[11:00:01.722]                   {
[11:00:01.722]                     {
[11:00:01.722]                       {
[11:00:01.722]                         base::local({
[11:00:01.722]                           has_future <- base::requireNamespace("future", 
[11:00:01.722]                             quietly = TRUE)
[11:00:01.722]                           if (has_future) {
[11:00:01.722]                             ns <- base::getNamespace("future")
[11:00:01.722]                             version <- ns[[".package"]][["version"]]
[11:00:01.722]                             if (is.null(version)) 
[11:00:01.722]                               version <- utils::packageVersion("future")
[11:00:01.722]                           }
[11:00:01.722]                           else {
[11:00:01.722]                             version <- NULL
[11:00:01.722]                           }
[11:00:01.722]                           if (!has_future || version < "1.8.0") {
[11:00:01.722]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:01.722]                               "", base::R.version$version.string), 
[11:00:01.722]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:01.722]                                 base::R.version$platform, 8 * 
[11:00:01.722]                                   base::.Machine$sizeof.pointer), 
[11:00:01.722]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:01.722]                                 "release", "version")], collapse = " "), 
[11:00:01.722]                               hostname = base::Sys.info()[["nodename"]])
[11:00:01.722]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:01.722]                               info)
[11:00:01.722]                             info <- base::paste(info, collapse = "; ")
[11:00:01.722]                             if (!has_future) {
[11:00:01.722]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:01.722]                                 info)
[11:00:01.722]                             }
[11:00:01.722]                             else {
[11:00:01.722]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:01.722]                                 info, version)
[11:00:01.722]                             }
[11:00:01.722]                             base::stop(msg)
[11:00:01.722]                           }
[11:00:01.722]                         })
[11:00:01.722]                       }
[11:00:01.722]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:01.722]                       base::options(mc.cores = 1L)
[11:00:01.722]                     }
[11:00:01.722]                     base::local({
[11:00:01.722]                       for (pkg in "future.apply") {
[11:00:01.722]                         base::loadNamespace(pkg)
[11:00:01.722]                         base::library(pkg, character.only = TRUE)
[11:00:01.722]                       }
[11:00:01.722]                     })
[11:00:01.722]                   }
[11:00:01.722]                   ...future.strategy.old <- future::plan("list")
[11:00:01.722]                   options(future.plan = NULL)
[11:00:01.722]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.722]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:01.722]                 }
[11:00:01.722]                 ...future.workdir <- getwd()
[11:00:01.722]             }
[11:00:01.722]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:01.722]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:01.722]         }
[11:00:01.722]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:01.722]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:01.722]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:01.722]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:01.722]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:01.722]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:01.722]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:01.722]             base::names(...future.oldOptions))
[11:00:01.722]     }
[11:00:01.722]     if (FALSE) {
[11:00:01.722]     }
[11:00:01.722]     else {
[11:00:01.722]         if (TRUE) {
[11:00:01.722]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:01.722]                 open = "w")
[11:00:01.722]         }
[11:00:01.722]         else {
[11:00:01.722]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:01.722]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:01.722]         }
[11:00:01.722]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:01.722]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:01.722]             base::sink(type = "output", split = FALSE)
[11:00:01.722]             base::close(...future.stdout)
[11:00:01.722]         }, add = TRUE)
[11:00:01.722]     }
[11:00:01.722]     ...future.frame <- base::sys.nframe()
[11:00:01.722]     ...future.conditions <- base::list()
[11:00:01.722]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:01.722]     if (FALSE) {
[11:00:01.722]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:01.722]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:01.722]     }
[11:00:01.722]     ...future.result <- base::tryCatch({
[11:00:01.722]         base::withCallingHandlers({
[11:00:01.722]             ...future.value <- base::withVisible(base::local({
[11:00:01.722]                 withCallingHandlers({
[11:00:01.722]                   {
[11:00:01.722]                     do.call(function(...) {
[11:00:01.722]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.722]                       if (!identical(...future.globals.maxSize.org, 
[11:00:01.722]                         ...future.globals.maxSize)) {
[11:00:01.722]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.722]                         on.exit(options(oopts), add = TRUE)
[11:00:01.722]                       }
[11:00:01.722]                       {
[11:00:01.722]                         lapply(seq_along(...future.elements_ii), 
[11:00:01.722]                           FUN = function(jj) {
[11:00:01.722]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.722]                             ...future.FUN(...future.X_jj, ...)
[11:00:01.722]                           })
[11:00:01.722]                       }
[11:00:01.722]                     }, args = future.call.arguments)
[11:00:01.722]                   }
[11:00:01.722]                 }, immediateCondition = function(cond) {
[11:00:01.722]                   save_rds <- function (object, pathname, ...) 
[11:00:01.722]                   {
[11:00:01.722]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:01.722]                     if (file_test("-f", pathname_tmp)) {
[11:00:01.722]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.722]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:01.722]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.722]                         fi_tmp[["mtime"]])
[11:00:01.722]                     }
[11:00:01.722]                     tryCatch({
[11:00:01.722]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:01.722]                     }, error = function(ex) {
[11:00:01.722]                       msg <- conditionMessage(ex)
[11:00:01.722]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.722]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:01.722]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.722]                         fi_tmp[["mtime"]], msg)
[11:00:01.722]                       ex$message <- msg
[11:00:01.722]                       stop(ex)
[11:00:01.722]                     })
[11:00:01.722]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:01.722]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:01.722]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:01.722]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.722]                       fi <- file.info(pathname)
[11:00:01.722]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:01.722]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.722]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:01.722]                         fi[["size"]], fi[["mtime"]])
[11:00:01.722]                       stop(msg)
[11:00:01.722]                     }
[11:00:01.722]                     invisible(pathname)
[11:00:01.722]                   }
[11:00:01.722]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:01.722]                     rootPath = tempdir()) 
[11:00:01.722]                   {
[11:00:01.722]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:01.722]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:01.722]                       tmpdir = path, fileext = ".rds")
[11:00:01.722]                     save_rds(obj, file)
[11:00:01.722]                   }
[11:00:01.722]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:01.722]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.722]                   {
[11:00:01.722]                     inherits <- base::inherits
[11:00:01.722]                     invokeRestart <- base::invokeRestart
[11:00:01.722]                     is.null <- base::is.null
[11:00:01.722]                     muffled <- FALSE
[11:00:01.722]                     if (inherits(cond, "message")) {
[11:00:01.722]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:01.722]                       if (muffled) 
[11:00:01.722]                         invokeRestart("muffleMessage")
[11:00:01.722]                     }
[11:00:01.722]                     else if (inherits(cond, "warning")) {
[11:00:01.722]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:01.722]                       if (muffled) 
[11:00:01.722]                         invokeRestart("muffleWarning")
[11:00:01.722]                     }
[11:00:01.722]                     else if (inherits(cond, "condition")) {
[11:00:01.722]                       if (!is.null(pattern)) {
[11:00:01.722]                         computeRestarts <- base::computeRestarts
[11:00:01.722]                         grepl <- base::grepl
[11:00:01.722]                         restarts <- computeRestarts(cond)
[11:00:01.722]                         for (restart in restarts) {
[11:00:01.722]                           name <- restart$name
[11:00:01.722]                           if (is.null(name)) 
[11:00:01.722]                             next
[11:00:01.722]                           if (!grepl(pattern, name)) 
[11:00:01.722]                             next
[11:00:01.722]                           invokeRestart(restart)
[11:00:01.722]                           muffled <- TRUE
[11:00:01.722]                           break
[11:00:01.722]                         }
[11:00:01.722]                       }
[11:00:01.722]                     }
[11:00:01.722]                     invisible(muffled)
[11:00:01.722]                   }
[11:00:01.722]                   muffleCondition(cond)
[11:00:01.722]                 })
[11:00:01.722]             }))
[11:00:01.722]             future::FutureResult(value = ...future.value$value, 
[11:00:01.722]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.722]                   ...future.rng), globalenv = if (FALSE) 
[11:00:01.722]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:01.722]                     ...future.globalenv.names))
[11:00:01.722]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:01.722]         }, condition = base::local({
[11:00:01.722]             c <- base::c
[11:00:01.722]             inherits <- base::inherits
[11:00:01.722]             invokeRestart <- base::invokeRestart
[11:00:01.722]             length <- base::length
[11:00:01.722]             list <- base::list
[11:00:01.722]             seq.int <- base::seq.int
[11:00:01.722]             signalCondition <- base::signalCondition
[11:00:01.722]             sys.calls <- base::sys.calls
[11:00:01.722]             `[[` <- base::`[[`
[11:00:01.722]             `+` <- base::`+`
[11:00:01.722]             `<<-` <- base::`<<-`
[11:00:01.722]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:01.722]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:01.722]                   3L)]
[11:00:01.722]             }
[11:00:01.722]             function(cond) {
[11:00:01.722]                 is_error <- inherits(cond, "error")
[11:00:01.722]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:01.722]                   NULL)
[11:00:01.722]                 if (is_error) {
[11:00:01.722]                   sessionInformation <- function() {
[11:00:01.722]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:01.722]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:01.722]                       search = base::search(), system = base::Sys.info())
[11:00:01.722]                   }
[11:00:01.722]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.722]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:01.722]                     cond$call), session = sessionInformation(), 
[11:00:01.722]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:01.722]                   signalCondition(cond)
[11:00:01.722]                 }
[11:00:01.722]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:01.722]                 "immediateCondition"))) {
[11:00:01.722]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:01.722]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.722]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:01.722]                   if (TRUE && !signal) {
[11:00:01.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.722]                     {
[11:00:01.722]                       inherits <- base::inherits
[11:00:01.722]                       invokeRestart <- base::invokeRestart
[11:00:01.722]                       is.null <- base::is.null
[11:00:01.722]                       muffled <- FALSE
[11:00:01.722]                       if (inherits(cond, "message")) {
[11:00:01.722]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.722]                         if (muffled) 
[11:00:01.722]                           invokeRestart("muffleMessage")
[11:00:01.722]                       }
[11:00:01.722]                       else if (inherits(cond, "warning")) {
[11:00:01.722]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.722]                         if (muffled) 
[11:00:01.722]                           invokeRestart("muffleWarning")
[11:00:01.722]                       }
[11:00:01.722]                       else if (inherits(cond, "condition")) {
[11:00:01.722]                         if (!is.null(pattern)) {
[11:00:01.722]                           computeRestarts <- base::computeRestarts
[11:00:01.722]                           grepl <- base::grepl
[11:00:01.722]                           restarts <- computeRestarts(cond)
[11:00:01.722]                           for (restart in restarts) {
[11:00:01.722]                             name <- restart$name
[11:00:01.722]                             if (is.null(name)) 
[11:00:01.722]                               next
[11:00:01.722]                             if (!grepl(pattern, name)) 
[11:00:01.722]                               next
[11:00:01.722]                             invokeRestart(restart)
[11:00:01.722]                             muffled <- TRUE
[11:00:01.722]                             break
[11:00:01.722]                           }
[11:00:01.722]                         }
[11:00:01.722]                       }
[11:00:01.722]                       invisible(muffled)
[11:00:01.722]                     }
[11:00:01.722]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.722]                   }
[11:00:01.722]                 }
[11:00:01.722]                 else {
[11:00:01.722]                   if (TRUE) {
[11:00:01.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.722]                     {
[11:00:01.722]                       inherits <- base::inherits
[11:00:01.722]                       invokeRestart <- base::invokeRestart
[11:00:01.722]                       is.null <- base::is.null
[11:00:01.722]                       muffled <- FALSE
[11:00:01.722]                       if (inherits(cond, "message")) {
[11:00:01.722]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.722]                         if (muffled) 
[11:00:01.722]                           invokeRestart("muffleMessage")
[11:00:01.722]                       }
[11:00:01.722]                       else if (inherits(cond, "warning")) {
[11:00:01.722]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.722]                         if (muffled) 
[11:00:01.722]                           invokeRestart("muffleWarning")
[11:00:01.722]                       }
[11:00:01.722]                       else if (inherits(cond, "condition")) {
[11:00:01.722]                         if (!is.null(pattern)) {
[11:00:01.722]                           computeRestarts <- base::computeRestarts
[11:00:01.722]                           grepl <- base::grepl
[11:00:01.722]                           restarts <- computeRestarts(cond)
[11:00:01.722]                           for (restart in restarts) {
[11:00:01.722]                             name <- restart$name
[11:00:01.722]                             if (is.null(name)) 
[11:00:01.722]                               next
[11:00:01.722]                             if (!grepl(pattern, name)) 
[11:00:01.722]                               next
[11:00:01.722]                             invokeRestart(restart)
[11:00:01.722]                             muffled <- TRUE
[11:00:01.722]                             break
[11:00:01.722]                           }
[11:00:01.722]                         }
[11:00:01.722]                       }
[11:00:01.722]                       invisible(muffled)
[11:00:01.722]                     }
[11:00:01.722]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.722]                   }
[11:00:01.722]                 }
[11:00:01.722]             }
[11:00:01.722]         }))
[11:00:01.722]     }, error = function(ex) {
[11:00:01.722]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:01.722]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.722]                 ...future.rng), started = ...future.startTime, 
[11:00:01.722]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:01.722]             version = "1.8"), class = "FutureResult")
[11:00:01.722]     }, finally = {
[11:00:01.722]         if (!identical(...future.workdir, getwd())) 
[11:00:01.722]             setwd(...future.workdir)
[11:00:01.722]         {
[11:00:01.722]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:01.722]                 ...future.oldOptions$nwarnings <- NULL
[11:00:01.722]             }
[11:00:01.722]             base::options(...future.oldOptions)
[11:00:01.722]             if (.Platform$OS.type == "windows") {
[11:00:01.722]                 old_names <- names(...future.oldEnvVars)
[11:00:01.722]                 envs <- base::Sys.getenv()
[11:00:01.722]                 names <- names(envs)
[11:00:01.722]                 common <- intersect(names, old_names)
[11:00:01.722]                 added <- setdiff(names, old_names)
[11:00:01.722]                 removed <- setdiff(old_names, names)
[11:00:01.722]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:01.722]                   envs[common]]
[11:00:01.722]                 NAMES <- toupper(changed)
[11:00:01.722]                 args <- list()
[11:00:01.722]                 for (kk in seq_along(NAMES)) {
[11:00:01.722]                   name <- changed[[kk]]
[11:00:01.722]                   NAME <- NAMES[[kk]]
[11:00:01.722]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.722]                     next
[11:00:01.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.722]                 }
[11:00:01.722]                 NAMES <- toupper(added)
[11:00:01.722]                 for (kk in seq_along(NAMES)) {
[11:00:01.722]                   name <- added[[kk]]
[11:00:01.722]                   NAME <- NAMES[[kk]]
[11:00:01.722]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.722]                     next
[11:00:01.722]                   args[[name]] <- ""
[11:00:01.722]                 }
[11:00:01.722]                 NAMES <- toupper(removed)
[11:00:01.722]                 for (kk in seq_along(NAMES)) {
[11:00:01.722]                   name <- removed[[kk]]
[11:00:01.722]                   NAME <- NAMES[[kk]]
[11:00:01.722]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.722]                     next
[11:00:01.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.722]                 }
[11:00:01.722]                 if (length(args) > 0) 
[11:00:01.722]                   base::do.call(base::Sys.setenv, args = args)
[11:00:01.722]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:01.722]             }
[11:00:01.722]             else {
[11:00:01.722]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:01.722]             }
[11:00:01.722]             {
[11:00:01.722]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:01.722]                   0L) {
[11:00:01.722]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:01.722]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:01.722]                   base::options(opts)
[11:00:01.722]                 }
[11:00:01.722]                 {
[11:00:01.722]                   {
[11:00:01.722]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:01.722]                     NULL
[11:00:01.722]                   }
[11:00:01.722]                   options(future.plan = NULL)
[11:00:01.722]                   if (is.na(NA_character_)) 
[11:00:01.722]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.722]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:01.722]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:01.722]                     .init = FALSE)
[11:00:01.722]                 }
[11:00:01.722]             }
[11:00:01.722]         }
[11:00:01.722]     })
[11:00:01.722]     if (TRUE) {
[11:00:01.722]         base::sink(type = "output", split = FALSE)
[11:00:01.722]         if (TRUE) {
[11:00:01.722]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:01.722]         }
[11:00:01.722]         else {
[11:00:01.722]             ...future.result["stdout"] <- base::list(NULL)
[11:00:01.722]         }
[11:00:01.722]         base::close(...future.stdout)
[11:00:01.722]         ...future.stdout <- NULL
[11:00:01.722]     }
[11:00:01.722]     ...future.result$conditions <- ...future.conditions
[11:00:01.722]     ...future.result$finished <- base::Sys.time()
[11:00:01.722]     ...future.result
[11:00:01.722] }
[11:00:01.725] assign_globals() ...
[11:00:01.725] List of 11
[11:00:01.725]  $ ...future.FUN            :function (x, ...)  
[11:00:01.725]  $ x_FUN                    :function (x)  
[11:00:01.725]  $ times                    : int 4
[11:00:01.725]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.725]  $ stop_if_not              :function (...)  
[11:00:01.725]  $ dim                      : int [1:2] 2 2
[11:00:01.725]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:01.725]  $ future.call.arguments    : list()
[11:00:01.725]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.725]  $ ...future.elements_ii    :List of 5
[11:00:01.725]   ..$ : int 1
[11:00:01.725]   ..$ : int 2
[11:00:01.725]   ..$ : int 3
[11:00:01.725]   ..$ : int 4
[11:00:01.725]   ..$ : int 5
[11:00:01.725]  $ ...future.seeds_ii       : NULL
[11:00:01.725]  $ ...future.globals.maxSize: NULL
[11:00:01.725]  - attr(*, "where")=List of 11
[11:00:01.725]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:01.725]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:01.725]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:01.725]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:01.725]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:01.725]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:01.725]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:01.725]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:01.725]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:01.725]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:01.725]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:01.725]  - attr(*, "resolved")= logi FALSE
[11:00:01.725]  - attr(*, "total_size")= num 24958
[11:00:01.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.725]  - attr(*, "already-done")= logi TRUE
[11:00:01.737] - copied ‘...future.FUN’ to environment
[11:00:01.737] - reassign environment for ‘x_FUN’
[11:00:01.737] - copied ‘x_FUN’ to environment
[11:00:01.738] - copied ‘times’ to environment
[11:00:01.738] - copied ‘stopf’ to environment
[11:00:01.738] - copied ‘stop_if_not’ to environment
[11:00:01.738] - copied ‘dim’ to environment
[11:00:01.738] - copied ‘valid_types’ to environment
[11:00:01.738] - copied ‘future.call.arguments’ to environment
[11:00:01.738] - copied ‘...future.elements_ii’ to environment
[11:00:01.738] - copied ‘...future.seeds_ii’ to environment
[11:00:01.738] - copied ‘...future.globals.maxSize’ to environment
[11:00:01.738] assign_globals() ... done
[11:00:01.739] requestCore(): workers = 2
[11:00:01.741] MulticoreFuture started
[11:00:01.742] - Launch lazy future ... done
[11:00:01.743] run() for ‘MulticoreFuture’ ... done
[11:00:01.744] Created future:
[11:00:01.744] plan(): Setting new future strategy stack:
[11:00:01.744] List of future strategies:
[11:00:01.744] 1. sequential:
[11:00:01.744]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:01.744]    - tweaked: FALSE
[11:00:01.744]    - call: NULL
[11:00:01.746] plan(): nbrOfWorkers() = 1
[11:00:01.750] plan(): Setting new future strategy stack:
[11:00:01.750] List of future strategies:
[11:00:01.750] 1. multicore:
[11:00:01.750]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:01.750]    - tweaked: FALSE
[11:00:01.750]    - call: plan(strategy)
[11:00:01.755] plan(): nbrOfWorkers() = 2
[11:00:01.744] MulticoreFuture:
[11:00:01.744] Label: ‘future_vapply-1’
[11:00:01.744] Expression:
[11:00:01.744] {
[11:00:01.744]     do.call(function(...) {
[11:00:01.744]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.744]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.744]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.744]             on.exit(options(oopts), add = TRUE)
[11:00:01.744]         }
[11:00:01.744]         {
[11:00:01.744]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.744]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.744]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.744]             })
[11:00:01.744]         }
[11:00:01.744]     }, args = future.call.arguments)
[11:00:01.744] }
[11:00:01.744] Lazy evaluation: FALSE
[11:00:01.744] Asynchronous evaluation: TRUE
[11:00:01.744] Local evaluation: TRUE
[11:00:01.744] Environment: R_GlobalEnv
[11:00:01.744] Capture standard output: TRUE
[11:00:01.744] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:01.744] Globals: 11 objects totaling 13.86 KiB (function ‘...future.FUN’ of 5.08 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:01.744] Packages: 1 packages (‘future.apply’)
[11:00:01.744] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:01.744] Resolved: TRUE
[11:00:01.744] Value: <not collected>
[11:00:01.744] Conditions captured: <none>
[11:00:01.744] Early signaling: FALSE
[11:00:01.744] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:01.744] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.756] Chunk #1 of 2 ... DONE
[11:00:01.756] Chunk #2 of 2 ...
[11:00:01.757]  - Finding globals in 'X' for chunk #2 ...
[11:00:01.757] getGlobalsAndPackages() ...
[11:00:01.757] Searching for globals...
[11:00:01.758] 
[11:00:01.758] Searching for globals ... DONE
[11:00:01.758] - globals: [0] <none>
[11:00:01.758] getGlobalsAndPackages() ... DONE
[11:00:01.758]    + additional globals found: [n=0] 
[11:00:01.759]    + additional namespaces needed: [n=0] 
[11:00:01.759]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:01.759]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:01.759]  - seeds: <none>
[11:00:01.759]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.760] getGlobalsAndPackages() ...
[11:00:01.760] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.760] Resolving globals: FALSE
[11:00:01.760] Tweak future expression to call with '...' arguments ...
[11:00:01.761] {
[11:00:01.761]     do.call(function(...) {
[11:00:01.761]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.761]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.761]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.761]             on.exit(options(oopts), add = TRUE)
[11:00:01.761]         }
[11:00:01.761]         {
[11:00:01.761]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.761]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.761]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.761]             })
[11:00:01.761]         }
[11:00:01.761]     }, args = future.call.arguments)
[11:00:01.761] }
[11:00:01.761] Tweak future expression to call with '...' arguments ... DONE
[11:00:01.762] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.762] - packages: [1] ‘future.apply’
[11:00:01.762] getGlobalsAndPackages() ... DONE
[11:00:01.763] run() for ‘Future’ ...
[11:00:01.763] - state: ‘created’
[11:00:01.763] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:01.766] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.766] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:01.766]   - Field: ‘label’
[11:00:01.766]   - Field: ‘local’
[11:00:01.766]   - Field: ‘owner’
[11:00:01.767]   - Field: ‘envir’
[11:00:01.767]   - Field: ‘workers’
[11:00:01.767]   - Field: ‘packages’
[11:00:01.767]   - Field: ‘gc’
[11:00:01.767]   - Field: ‘job’
[11:00:01.767]   - Field: ‘conditions’
[11:00:01.767]   - Field: ‘expr’
[11:00:01.767]   - Field: ‘uuid’
[11:00:01.768]   - Field: ‘seed’
[11:00:01.768]   - Field: ‘version’
[11:00:01.768]   - Field: ‘result’
[11:00:01.768]   - Field: ‘asynchronous’
[11:00:01.768]   - Field: ‘calls’
[11:00:01.768]   - Field: ‘globals’
[11:00:01.768]   - Field: ‘stdout’
[11:00:01.768]   - Field: ‘earlySignal’
[11:00:01.769]   - Field: ‘lazy’
[11:00:01.769]   - Field: ‘state’
[11:00:01.769] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:01.769] - Launch lazy future ...
[11:00:01.769] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:01.770] Packages needed by future strategies (n = 0): <none>
[11:00:01.770] {
[11:00:01.770]     {
[11:00:01.770]         {
[11:00:01.770]             ...future.startTime <- base::Sys.time()
[11:00:01.770]             {
[11:00:01.770]                 {
[11:00:01.770]                   {
[11:00:01.770]                     {
[11:00:01.770]                       {
[11:00:01.770]                         base::local({
[11:00:01.770]                           has_future <- base::requireNamespace("future", 
[11:00:01.770]                             quietly = TRUE)
[11:00:01.770]                           if (has_future) {
[11:00:01.770]                             ns <- base::getNamespace("future")
[11:00:01.770]                             version <- ns[[".package"]][["version"]]
[11:00:01.770]                             if (is.null(version)) 
[11:00:01.770]                               version <- utils::packageVersion("future")
[11:00:01.770]                           }
[11:00:01.770]                           else {
[11:00:01.770]                             version <- NULL
[11:00:01.770]                           }
[11:00:01.770]                           if (!has_future || version < "1.8.0") {
[11:00:01.770]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:01.770]                               "", base::R.version$version.string), 
[11:00:01.770]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:01.770]                                 base::R.version$platform, 8 * 
[11:00:01.770]                                   base::.Machine$sizeof.pointer), 
[11:00:01.770]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:01.770]                                 "release", "version")], collapse = " "), 
[11:00:01.770]                               hostname = base::Sys.info()[["nodename"]])
[11:00:01.770]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:01.770]                               info)
[11:00:01.770]                             info <- base::paste(info, collapse = "; ")
[11:00:01.770]                             if (!has_future) {
[11:00:01.770]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:01.770]                                 info)
[11:00:01.770]                             }
[11:00:01.770]                             else {
[11:00:01.770]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:01.770]                                 info, version)
[11:00:01.770]                             }
[11:00:01.770]                             base::stop(msg)
[11:00:01.770]                           }
[11:00:01.770]                         })
[11:00:01.770]                       }
[11:00:01.770]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:01.770]                       base::options(mc.cores = 1L)
[11:00:01.770]                     }
[11:00:01.770]                     base::local({
[11:00:01.770]                       for (pkg in "future.apply") {
[11:00:01.770]                         base::loadNamespace(pkg)
[11:00:01.770]                         base::library(pkg, character.only = TRUE)
[11:00:01.770]                       }
[11:00:01.770]                     })
[11:00:01.770]                   }
[11:00:01.770]                   ...future.strategy.old <- future::plan("list")
[11:00:01.770]                   options(future.plan = NULL)
[11:00:01.770]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.770]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:01.770]                 }
[11:00:01.770]                 ...future.workdir <- getwd()
[11:00:01.770]             }
[11:00:01.770]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:01.770]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:01.770]         }
[11:00:01.770]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:01.770]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:01.770]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:01.770]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:01.770]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:01.770]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:01.770]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:01.770]             base::names(...future.oldOptions))
[11:00:01.770]     }
[11:00:01.770]     if (FALSE) {
[11:00:01.770]     }
[11:00:01.770]     else {
[11:00:01.770]         if (TRUE) {
[11:00:01.770]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:01.770]                 open = "w")
[11:00:01.770]         }
[11:00:01.770]         else {
[11:00:01.770]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:01.770]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:01.770]         }
[11:00:01.770]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:01.770]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:01.770]             base::sink(type = "output", split = FALSE)
[11:00:01.770]             base::close(...future.stdout)
[11:00:01.770]         }, add = TRUE)
[11:00:01.770]     }
[11:00:01.770]     ...future.frame <- base::sys.nframe()
[11:00:01.770]     ...future.conditions <- base::list()
[11:00:01.770]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:01.770]     if (FALSE) {
[11:00:01.770]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:01.770]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:01.770]     }
[11:00:01.770]     ...future.result <- base::tryCatch({
[11:00:01.770]         base::withCallingHandlers({
[11:00:01.770]             ...future.value <- base::withVisible(base::local({
[11:00:01.770]                 withCallingHandlers({
[11:00:01.770]                   {
[11:00:01.770]                     do.call(function(...) {
[11:00:01.770]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.770]                       if (!identical(...future.globals.maxSize.org, 
[11:00:01.770]                         ...future.globals.maxSize)) {
[11:00:01.770]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.770]                         on.exit(options(oopts), add = TRUE)
[11:00:01.770]                       }
[11:00:01.770]                       {
[11:00:01.770]                         lapply(seq_along(...future.elements_ii), 
[11:00:01.770]                           FUN = function(jj) {
[11:00:01.770]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.770]                             ...future.FUN(...future.X_jj, ...)
[11:00:01.770]                           })
[11:00:01.770]                       }
[11:00:01.770]                     }, args = future.call.arguments)
[11:00:01.770]                   }
[11:00:01.770]                 }, immediateCondition = function(cond) {
[11:00:01.770]                   save_rds <- function (object, pathname, ...) 
[11:00:01.770]                   {
[11:00:01.770]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:01.770]                     if (file_test("-f", pathname_tmp)) {
[11:00:01.770]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.770]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:01.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.770]                         fi_tmp[["mtime"]])
[11:00:01.770]                     }
[11:00:01.770]                     tryCatch({
[11:00:01.770]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:01.770]                     }, error = function(ex) {
[11:00:01.770]                       msg <- conditionMessage(ex)
[11:00:01.770]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.770]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:01.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.770]                         fi_tmp[["mtime"]], msg)
[11:00:01.770]                       ex$message <- msg
[11:00:01.770]                       stop(ex)
[11:00:01.770]                     })
[11:00:01.770]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:01.770]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:01.770]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:01.770]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.770]                       fi <- file.info(pathname)
[11:00:01.770]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:01.770]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.770]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:01.770]                         fi[["size"]], fi[["mtime"]])
[11:00:01.770]                       stop(msg)
[11:00:01.770]                     }
[11:00:01.770]                     invisible(pathname)
[11:00:01.770]                   }
[11:00:01.770]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:01.770]                     rootPath = tempdir()) 
[11:00:01.770]                   {
[11:00:01.770]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:01.770]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:01.770]                       tmpdir = path, fileext = ".rds")
[11:00:01.770]                     save_rds(obj, file)
[11:00:01.770]                   }
[11:00:01.770]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:01.770]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.770]                   {
[11:00:01.770]                     inherits <- base::inherits
[11:00:01.770]                     invokeRestart <- base::invokeRestart
[11:00:01.770]                     is.null <- base::is.null
[11:00:01.770]                     muffled <- FALSE
[11:00:01.770]                     if (inherits(cond, "message")) {
[11:00:01.770]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:01.770]                       if (muffled) 
[11:00:01.770]                         invokeRestart("muffleMessage")
[11:00:01.770]                     }
[11:00:01.770]                     else if (inherits(cond, "warning")) {
[11:00:01.770]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:01.770]                       if (muffled) 
[11:00:01.770]                         invokeRestart("muffleWarning")
[11:00:01.770]                     }
[11:00:01.770]                     else if (inherits(cond, "condition")) {
[11:00:01.770]                       if (!is.null(pattern)) {
[11:00:01.770]                         computeRestarts <- base::computeRestarts
[11:00:01.770]                         grepl <- base::grepl
[11:00:01.770]                         restarts <- computeRestarts(cond)
[11:00:01.770]                         for (restart in restarts) {
[11:00:01.770]                           name <- restart$name
[11:00:01.770]                           if (is.null(name)) 
[11:00:01.770]                             next
[11:00:01.770]                           if (!grepl(pattern, name)) 
[11:00:01.770]                             next
[11:00:01.770]                           invokeRestart(restart)
[11:00:01.770]                           muffled <- TRUE
[11:00:01.770]                           break
[11:00:01.770]                         }
[11:00:01.770]                       }
[11:00:01.770]                     }
[11:00:01.770]                     invisible(muffled)
[11:00:01.770]                   }
[11:00:01.770]                   muffleCondition(cond)
[11:00:01.770]                 })
[11:00:01.770]             }))
[11:00:01.770]             future::FutureResult(value = ...future.value$value, 
[11:00:01.770]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.770]                   ...future.rng), globalenv = if (FALSE) 
[11:00:01.770]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:01.770]                     ...future.globalenv.names))
[11:00:01.770]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:01.770]         }, condition = base::local({
[11:00:01.770]             c <- base::c
[11:00:01.770]             inherits <- base::inherits
[11:00:01.770]             invokeRestart <- base::invokeRestart
[11:00:01.770]             length <- base::length
[11:00:01.770]             list <- base::list
[11:00:01.770]             seq.int <- base::seq.int
[11:00:01.770]             signalCondition <- base::signalCondition
[11:00:01.770]             sys.calls <- base::sys.calls
[11:00:01.770]             `[[` <- base::`[[`
[11:00:01.770]             `+` <- base::`+`
[11:00:01.770]             `<<-` <- base::`<<-`
[11:00:01.770]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:01.770]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:01.770]                   3L)]
[11:00:01.770]             }
[11:00:01.770]             function(cond) {
[11:00:01.770]                 is_error <- inherits(cond, "error")
[11:00:01.770]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:01.770]                   NULL)
[11:00:01.770]                 if (is_error) {
[11:00:01.770]                   sessionInformation <- function() {
[11:00:01.770]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:01.770]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:01.770]                       search = base::search(), system = base::Sys.info())
[11:00:01.770]                   }
[11:00:01.770]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.770]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:01.770]                     cond$call), session = sessionInformation(), 
[11:00:01.770]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:01.770]                   signalCondition(cond)
[11:00:01.770]                 }
[11:00:01.770]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:01.770]                 "immediateCondition"))) {
[11:00:01.770]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:01.770]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.770]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:01.770]                   if (TRUE && !signal) {
[11:00:01.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.770]                     {
[11:00:01.770]                       inherits <- base::inherits
[11:00:01.770]                       invokeRestart <- base::invokeRestart
[11:00:01.770]                       is.null <- base::is.null
[11:00:01.770]                       muffled <- FALSE
[11:00:01.770]                       if (inherits(cond, "message")) {
[11:00:01.770]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.770]                         if (muffled) 
[11:00:01.770]                           invokeRestart("muffleMessage")
[11:00:01.770]                       }
[11:00:01.770]                       else if (inherits(cond, "warning")) {
[11:00:01.770]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.770]                         if (muffled) 
[11:00:01.770]                           invokeRestart("muffleWarning")
[11:00:01.770]                       }
[11:00:01.770]                       else if (inherits(cond, "condition")) {
[11:00:01.770]                         if (!is.null(pattern)) {
[11:00:01.770]                           computeRestarts <- base::computeRestarts
[11:00:01.770]                           grepl <- base::grepl
[11:00:01.770]                           restarts <- computeRestarts(cond)
[11:00:01.770]                           for (restart in restarts) {
[11:00:01.770]                             name <- restart$name
[11:00:01.770]                             if (is.null(name)) 
[11:00:01.770]                               next
[11:00:01.770]                             if (!grepl(pattern, name)) 
[11:00:01.770]                               next
[11:00:01.770]                             invokeRestart(restart)
[11:00:01.770]                             muffled <- TRUE
[11:00:01.770]                             break
[11:00:01.770]                           }
[11:00:01.770]                         }
[11:00:01.770]                       }
[11:00:01.770]                       invisible(muffled)
[11:00:01.770]                     }
[11:00:01.770]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.770]                   }
[11:00:01.770]                 }
[11:00:01.770]                 else {
[11:00:01.770]                   if (TRUE) {
[11:00:01.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.770]                     {
[11:00:01.770]                       inherits <- base::inherits
[11:00:01.770]                       invokeRestart <- base::invokeRestart
[11:00:01.770]                       is.null <- base::is.null
[11:00:01.770]                       muffled <- FALSE
[11:00:01.770]                       if (inherits(cond, "message")) {
[11:00:01.770]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.770]                         if (muffled) 
[11:00:01.770]                           invokeRestart("muffleMessage")
[11:00:01.770]                       }
[11:00:01.770]                       else if (inherits(cond, "warning")) {
[11:00:01.770]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.770]                         if (muffled) 
[11:00:01.770]                           invokeRestart("muffleWarning")
[11:00:01.770]                       }
[11:00:01.770]                       else if (inherits(cond, "condition")) {
[11:00:01.770]                         if (!is.null(pattern)) {
[11:00:01.770]                           computeRestarts <- base::computeRestarts
[11:00:01.770]                           grepl <- base::grepl
[11:00:01.770]                           restarts <- computeRestarts(cond)
[11:00:01.770]                           for (restart in restarts) {
[11:00:01.770]                             name <- restart$name
[11:00:01.770]                             if (is.null(name)) 
[11:00:01.770]                               next
[11:00:01.770]                             if (!grepl(pattern, name)) 
[11:00:01.770]                               next
[11:00:01.770]                             invokeRestart(restart)
[11:00:01.770]                             muffled <- TRUE
[11:00:01.770]                             break
[11:00:01.770]                           }
[11:00:01.770]                         }
[11:00:01.770]                       }
[11:00:01.770]                       invisible(muffled)
[11:00:01.770]                     }
[11:00:01.770]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.770]                   }
[11:00:01.770]                 }
[11:00:01.770]             }
[11:00:01.770]         }))
[11:00:01.770]     }, error = function(ex) {
[11:00:01.770]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:01.770]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.770]                 ...future.rng), started = ...future.startTime, 
[11:00:01.770]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:01.770]             version = "1.8"), class = "FutureResult")
[11:00:01.770]     }, finally = {
[11:00:01.770]         if (!identical(...future.workdir, getwd())) 
[11:00:01.770]             setwd(...future.workdir)
[11:00:01.770]         {
[11:00:01.770]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:01.770]                 ...future.oldOptions$nwarnings <- NULL
[11:00:01.770]             }
[11:00:01.770]             base::options(...future.oldOptions)
[11:00:01.770]             if (.Platform$OS.type == "windows") {
[11:00:01.770]                 old_names <- names(...future.oldEnvVars)
[11:00:01.770]                 envs <- base::Sys.getenv()
[11:00:01.770]                 names <- names(envs)
[11:00:01.770]                 common <- intersect(names, old_names)
[11:00:01.770]                 added <- setdiff(names, old_names)
[11:00:01.770]                 removed <- setdiff(old_names, names)
[11:00:01.770]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:01.770]                   envs[common]]
[11:00:01.770]                 NAMES <- toupper(changed)
[11:00:01.770]                 args <- list()
[11:00:01.770]                 for (kk in seq_along(NAMES)) {
[11:00:01.770]                   name <- changed[[kk]]
[11:00:01.770]                   NAME <- NAMES[[kk]]
[11:00:01.770]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.770]                     next
[11:00:01.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.770]                 }
[11:00:01.770]                 NAMES <- toupper(added)
[11:00:01.770]                 for (kk in seq_along(NAMES)) {
[11:00:01.770]                   name <- added[[kk]]
[11:00:01.770]                   NAME <- NAMES[[kk]]
[11:00:01.770]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.770]                     next
[11:00:01.770]                   args[[name]] <- ""
[11:00:01.770]                 }
[11:00:01.770]                 NAMES <- toupper(removed)
[11:00:01.770]                 for (kk in seq_along(NAMES)) {
[11:00:01.770]                   name <- removed[[kk]]
[11:00:01.770]                   NAME <- NAMES[[kk]]
[11:00:01.770]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.770]                     next
[11:00:01.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.770]                 }
[11:00:01.770]                 if (length(args) > 0) 
[11:00:01.770]                   base::do.call(base::Sys.setenv, args = args)
[11:00:01.770]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:01.770]             }
[11:00:01.770]             else {
[11:00:01.770]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:01.770]             }
[11:00:01.770]             {
[11:00:01.770]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:01.770]                   0L) {
[11:00:01.770]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:01.770]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:01.770]                   base::options(opts)
[11:00:01.770]                 }
[11:00:01.770]                 {
[11:00:01.770]                   {
[11:00:01.770]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:01.770]                     NULL
[11:00:01.770]                   }
[11:00:01.770]                   options(future.plan = NULL)
[11:00:01.770]                   if (is.na(NA_character_)) 
[11:00:01.770]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.770]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:01.770]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:01.770]                     .init = FALSE)
[11:00:01.770]                 }
[11:00:01.770]             }
[11:00:01.770]         }
[11:00:01.770]     })
[11:00:01.770]     if (TRUE) {
[11:00:01.770]         base::sink(type = "output", split = FALSE)
[11:00:01.770]         if (TRUE) {
[11:00:01.770]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:01.770]         }
[11:00:01.770]         else {
[11:00:01.770]             ...future.result["stdout"] <- base::list(NULL)
[11:00:01.770]         }
[11:00:01.770]         base::close(...future.stdout)
[11:00:01.770]         ...future.stdout <- NULL
[11:00:01.770]     }
[11:00:01.770]     ...future.result$conditions <- ...future.conditions
[11:00:01.770]     ...future.result$finished <- base::Sys.time()
[11:00:01.770]     ...future.result
[11:00:01.770] }
[11:00:01.774] assign_globals() ...
[11:00:01.774] List of 11
[11:00:01.774]  $ ...future.FUN            :function (x, ...)  
[11:00:01.774]  $ x_FUN                    :function (x)  
[11:00:01.774]  $ times                    : int 4
[11:00:01.774]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.774]  $ stop_if_not              :function (...)  
[11:00:01.774]  $ dim                      : int [1:2] 2 2
[11:00:01.774]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:01.774]  $ future.call.arguments    : list()
[11:00:01.774]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.774]  $ ...future.elements_ii    :List of 5
[11:00:01.774]   ..$ : int 6
[11:00:01.774]   ..$ : int 7
[11:00:01.774]   ..$ : int 8
[11:00:01.774]   ..$ : int 9
[11:00:01.774]   ..$ : int 10
[11:00:01.774]  $ ...future.seeds_ii       : NULL
[11:00:01.774]  $ ...future.globals.maxSize: NULL
[11:00:01.774]  - attr(*, "where")=List of 11
[11:00:01.774]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:01.774]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:01.774]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:01.774]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:01.774]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:01.774]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:01.774]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:01.774]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:01.774]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:01.774]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:01.774]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:01.774]  - attr(*, "resolved")= logi FALSE
[11:00:01.774]  - attr(*, "total_size")= num 24958
[11:00:01.774]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.774]  - attr(*, "already-done")= logi TRUE
[11:00:01.787] - copied ‘...future.FUN’ to environment
[11:00:01.787] - reassign environment for ‘x_FUN’
[11:00:01.787] - copied ‘x_FUN’ to environment
[11:00:01.787] - copied ‘times’ to environment
[11:00:01.787] - copied ‘stopf’ to environment
[11:00:01.787] - copied ‘stop_if_not’ to environment
[11:00:01.787] - copied ‘dim’ to environment
[11:00:01.787] - copied ‘valid_types’ to environment
[11:00:01.788] - copied ‘future.call.arguments’ to environment
[11:00:01.788] - copied ‘...future.elements_ii’ to environment
[11:00:01.788] - copied ‘...future.seeds_ii’ to environment
[11:00:01.788] - copied ‘...future.globals.maxSize’ to environment
[11:00:01.788] assign_globals() ... done
[11:00:01.788] requestCore(): workers = 2
[11:00:01.791] MulticoreFuture started
[11:00:01.791] - Launch lazy future ... done
[11:00:01.792] run() for ‘MulticoreFuture’ ... done
[11:00:01.792] Created future:
[11:00:01.793] plan(): Setting new future strategy stack:
[11:00:01.793] List of future strategies:
[11:00:01.793] 1. sequential:
[11:00:01.793]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:01.793]    - tweaked: FALSE
[11:00:01.793]    - call: NULL
[11:00:01.795] plan(): nbrOfWorkers() = 1
[11:00:01.798] plan(): Setting new future strategy stack:
[11:00:01.798] List of future strategies:
[11:00:01.798] 1. multicore:
[11:00:01.798]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:01.798]    - tweaked: FALSE
[11:00:01.798]    - call: plan(strategy)
[11:00:01.803] plan(): nbrOfWorkers() = 2
[11:00:01.793] MulticoreFuture:
[11:00:01.793] Label: ‘future_vapply-2’
[11:00:01.793] Expression:
[11:00:01.793] {
[11:00:01.793]     do.call(function(...) {
[11:00:01.793]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.793]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.793]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.793]             on.exit(options(oopts), add = TRUE)
[11:00:01.793]         }
[11:00:01.793]         {
[11:00:01.793]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.793]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.793]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.793]             })
[11:00:01.793]         }
[11:00:01.793]     }, args = future.call.arguments)
[11:00:01.793] }
[11:00:01.793] Lazy evaluation: FALSE
[11:00:01.793] Asynchronous evaluation: TRUE
[11:00:01.793] Local evaluation: TRUE
[11:00:01.793] Environment: R_GlobalEnv
[11:00:01.793] Capture standard output: TRUE
[11:00:01.793] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:01.793] Globals: 11 objects totaling 13.86 KiB (function ‘...future.FUN’ of 5.08 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:01.793] Packages: 1 packages (‘future.apply’)
[11:00:01.793] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:01.793] Resolved: TRUE
[11:00:01.793] Value: <not collected>
[11:00:01.793] Conditions captured: <none>
[11:00:01.793] Early signaling: FALSE
[11:00:01.793] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:01.793] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.804] Chunk #2 of 2 ... DONE
[11:00:01.804] Launching 2 futures (chunks) ... DONE
[11:00:01.804] Resolving 2 futures (chunks) ...
[11:00:01.805] resolve() on list ...
[11:00:01.805]  recursive: 0
[11:00:01.805]  length: 2
[11:00:01.805] 
[11:00:01.806] Future #1
[11:00:01.806] result() for MulticoreFuture ...
[11:00:01.807] result() for MulticoreFuture ...
[11:00:01.807] result() for MulticoreFuture ... done
[11:00:01.808] result() for MulticoreFuture ... done
[11:00:01.808] result() for MulticoreFuture ...
[11:00:01.808] result() for MulticoreFuture ... done
[11:00:01.808] signalConditionsASAP(MulticoreFuture, pos=1) ...
[11:00:01.808] - nx: 2
[11:00:01.809] - relay: TRUE
[11:00:01.809] - stdout: TRUE
[11:00:01.809] - signal: TRUE
[11:00:01.809] - resignal: FALSE
[11:00:01.809] - force: TRUE
[11:00:01.810] - relayed: [n=2] FALSE, FALSE
[11:00:01.810] - queued futures: [n=2] FALSE, FALSE
[11:00:01.810]  - until=1
[11:00:01.810]  - relaying element #1
[11:00:01.810] result() for MulticoreFuture ...
[11:00:01.810] result() for MulticoreFuture ... done
[11:00:01.811] result() for MulticoreFuture ...
[11:00:01.811] result() for MulticoreFuture ... done
[11:00:01.811] result() for MulticoreFuture ...
[11:00:01.812] result() for MulticoreFuture ... done
[11:00:01.812] result() for MulticoreFuture ...
[11:00:01.812] result() for MulticoreFuture ... done
[11:00:01.812] - relayed: [n=2] TRUE, FALSE
[11:00:01.812] - queued futures: [n=2] TRUE, FALSE
[11:00:01.812] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[11:00:01.813]  length: 1 (resolved future 1)
[11:00:01.813] Future #2
[11:00:01.813] result() for MulticoreFuture ...
[11:00:01.814] result() for MulticoreFuture ...
[11:00:01.814] result() for MulticoreFuture ... done
[11:00:01.814] result() for MulticoreFuture ... done
[11:00:01.814] result() for MulticoreFuture ...
[11:00:01.815] result() for MulticoreFuture ... done
[11:00:01.815] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:00:01.815] - nx: 2
[11:00:01.815] - relay: TRUE
[11:00:01.815] - stdout: TRUE
[11:00:01.815] - signal: TRUE
[11:00:01.815] - resignal: FALSE
[11:00:01.815] - force: TRUE
[11:00:01.815] - relayed: [n=2] TRUE, FALSE
[11:00:01.816] - queued futures: [n=2] TRUE, FALSE
[11:00:01.816]  - until=2
[11:00:01.816]  - relaying element #2
[11:00:01.816] result() for MulticoreFuture ...
[11:00:01.816] result() for MulticoreFuture ... done
[11:00:01.816] result() for MulticoreFuture ...
[11:00:01.816] result() for MulticoreFuture ... done
[11:00:01.816] result() for MulticoreFuture ...
[11:00:01.817] result() for MulticoreFuture ... done
[11:00:01.817] result() for MulticoreFuture ...
[11:00:01.817] result() for MulticoreFuture ... done
[11:00:01.817] - relayed: [n=2] TRUE, TRUE
[11:00:01.817] - queued futures: [n=2] TRUE, TRUE
[11:00:01.817] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:00:01.817]  length: 0 (resolved future 2)
[11:00:01.817] Relaying remaining futures
[11:00:01.817] signalConditionsASAP(NULL, pos=0) ...
[11:00:01.818] - nx: 2
[11:00:01.818] - relay: TRUE
[11:00:01.818] - stdout: TRUE
[11:00:01.818] - signal: TRUE
[11:00:01.818] - resignal: FALSE
[11:00:01.818] - force: TRUE
[11:00:01.818] - relayed: [n=2] TRUE, TRUE
[11:00:01.818] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:01.818] - relayed: [n=2] TRUE, TRUE
[11:00:01.818] - queued futures: [n=2] TRUE, TRUE
[11:00:01.819] signalConditionsASAP(NULL, pos=0) ... done
[11:00:01.819] resolve() on list ... DONE
[11:00:01.819] result() for MulticoreFuture ...
[11:00:01.819] result() for MulticoreFuture ... done
[11:00:01.819] result() for MulticoreFuture ...
[11:00:01.819] result() for MulticoreFuture ... done
[11:00:01.819] result() for MulticoreFuture ...
[11:00:01.819] result() for MulticoreFuture ... done
[11:00:01.819] result() for MulticoreFuture ...
[11:00:01.819] result() for MulticoreFuture ... done
[11:00:01.820]  - Number of value chunks collected: 2
[11:00:01.820] Resolving 2 futures (chunks) ... DONE
[11:00:01.820] Reducing values from 2 chunks ...
[11:00:01.820]  - Number of values collected after concatenation: 10
[11:00:01.820]  - Number of values expected: 10
[11:00:01.820] Reducing values from 2 chunks ... DONE
[11:00:01.820] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[11:00:01.823] future_lapply() ...
[11:00:01.826] Number of chunks: 2
[11:00:01.827] getGlobalsAndPackagesXApply() ...
[11:00:01.827]  - future.globals: TRUE
[11:00:01.827] getGlobalsAndPackages() ...
[11:00:01.827] Searching for globals...
[11:00:01.834] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[11:00:01.834] Searching for globals ... DONE
[11:00:01.834] Resolving globals: FALSE
[11:00:01.835] The total size of the 7 globals is 16.05 KiB (16436 bytes)
[11:00:01.835] The total size of the 7 globals exported for future expression (‘FUN()’) is 16.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (6.71 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:01.836] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:01.836] - packages: [1] ‘future.apply’
[11:00:01.836] getGlobalsAndPackages() ... DONE
[11:00:01.836]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:01.836]  - needed namespaces: [n=1] ‘future.apply’
[11:00:01.836] Finding globals ... DONE
[11:00:01.836]  - use_args: TRUE
[11:00:01.836]  - Getting '...' globals ...
[11:00:01.837] resolve() on list ...
[11:00:01.837]  recursive: 0
[11:00:01.837]  length: 1
[11:00:01.837]  elements: ‘...’
[11:00:01.837]  length: 0 (resolved future 1)
[11:00:01.837] resolve() on list ... DONE
[11:00:01.837]    - '...' content: [n=0] 
[11:00:01.837] List of 1
[11:00:01.837]  $ ...: list()
[11:00:01.837]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.837]  - attr(*, "where")=List of 1
[11:00:01.837]   ..$ ...:<environment: 0x55bbad40c6a8> 
[11:00:01.837]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.837]  - attr(*, "resolved")= logi TRUE
[11:00:01.837]  - attr(*, "total_size")= num NA
[11:00:01.840]  - Getting '...' globals ... DONE
[11:00:01.840] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:01.840] List of 8
[11:00:01.840]  $ ...future.FUN:function (x, ...)  
[11:00:01.840]  $ x_FUN        :function (x)  
[11:00:01.840]  $ times        : int 4
[11:00:01.840]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.840]  $ stop_if_not  :function (...)  
[11:00:01.840]  $ dim          : int [1:2] 2 2
[11:00:01.840]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:01.840]  $ ...          : list()
[11:00:01.840]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.840]  - attr(*, "where")=List of 8
[11:00:01.840]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:01.840]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:01.840]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:01.840]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:01.840]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:01.840]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:01.840]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:01.840]   ..$ ...          :<environment: 0x55bbad40c6a8> 
[11:00:01.840]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.840]  - attr(*, "resolved")= logi FALSE
[11:00:01.840]  - attr(*, "total_size")= num 29094
[11:00:01.845] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:01.845] getGlobalsAndPackagesXApply() ... DONE
[11:00:01.846] Number of futures (= number of chunks): 2
[11:00:01.846] Launching 2 futures (chunks) ...
[11:00:01.846] Chunk #1 of 2 ...
[11:00:01.846]  - Finding globals in 'X' for chunk #1 ...
[11:00:01.846] getGlobalsAndPackages() ...
[11:00:01.846] Searching for globals...
[11:00:01.846] 
[11:00:01.846] Searching for globals ... DONE
[11:00:01.847] - globals: [0] <none>
[11:00:01.847] getGlobalsAndPackages() ... DONE
[11:00:01.847]    + additional globals found: [n=0] 
[11:00:01.847]    + additional namespaces needed: [n=0] 
[11:00:01.847]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:01.847]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:01.847]  - seeds: <none>
[11:00:01.847]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.847] getGlobalsAndPackages() ...
[11:00:01.847] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.847] Resolving globals: FALSE
[11:00:01.848] Tweak future expression to call with '...' arguments ...
[11:00:01.848] {
[11:00:01.848]     do.call(function(...) {
[11:00:01.848]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.848]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.848]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.848]             on.exit(options(oopts), add = TRUE)
[11:00:01.848]         }
[11:00:01.848]         {
[11:00:01.848]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.848]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.848]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.848]             })
[11:00:01.848]         }
[11:00:01.848]     }, args = future.call.arguments)
[11:00:01.848] }
[11:00:01.848] Tweak future expression to call with '...' arguments ... DONE
[11:00:01.848] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.849] - packages: [1] ‘future.apply’
[11:00:01.849] getGlobalsAndPackages() ... DONE
[11:00:01.849] run() for ‘Future’ ...
[11:00:01.849] - state: ‘created’
[11:00:01.849] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:01.852] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.852] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:01.852]   - Field: ‘label’
[11:00:01.852]   - Field: ‘local’
[11:00:01.853]   - Field: ‘owner’
[11:00:01.853]   - Field: ‘envir’
[11:00:01.853]   - Field: ‘workers’
[11:00:01.853]   - Field: ‘packages’
[11:00:01.853]   - Field: ‘gc’
[11:00:01.853]   - Field: ‘job’
[11:00:01.853]   - Field: ‘conditions’
[11:00:01.853]   - Field: ‘expr’
[11:00:01.853]   - Field: ‘uuid’
[11:00:01.853]   - Field: ‘seed’
[11:00:01.854]   - Field: ‘version’
[11:00:01.854]   - Field: ‘result’
[11:00:01.854]   - Field: ‘asynchronous’
[11:00:01.854]   - Field: ‘calls’
[11:00:01.854]   - Field: ‘globals’
[11:00:01.854]   - Field: ‘stdout’
[11:00:01.854]   - Field: ‘earlySignal’
[11:00:01.854]   - Field: ‘lazy’
[11:00:01.854]   - Field: ‘state’
[11:00:01.854] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:01.854] - Launch lazy future ...
[11:00:01.855] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:01.855] Packages needed by future strategies (n = 0): <none>
[11:00:01.855] {
[11:00:01.855]     {
[11:00:01.855]         {
[11:00:01.855]             ...future.startTime <- base::Sys.time()
[11:00:01.855]             {
[11:00:01.855]                 {
[11:00:01.855]                   {
[11:00:01.855]                     {
[11:00:01.855]                       {
[11:00:01.855]                         base::local({
[11:00:01.855]                           has_future <- base::requireNamespace("future", 
[11:00:01.855]                             quietly = TRUE)
[11:00:01.855]                           if (has_future) {
[11:00:01.855]                             ns <- base::getNamespace("future")
[11:00:01.855]                             version <- ns[[".package"]][["version"]]
[11:00:01.855]                             if (is.null(version)) 
[11:00:01.855]                               version <- utils::packageVersion("future")
[11:00:01.855]                           }
[11:00:01.855]                           else {
[11:00:01.855]                             version <- NULL
[11:00:01.855]                           }
[11:00:01.855]                           if (!has_future || version < "1.8.0") {
[11:00:01.855]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:01.855]                               "", base::R.version$version.string), 
[11:00:01.855]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:01.855]                                 base::R.version$platform, 8 * 
[11:00:01.855]                                   base::.Machine$sizeof.pointer), 
[11:00:01.855]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:01.855]                                 "release", "version")], collapse = " "), 
[11:00:01.855]                               hostname = base::Sys.info()[["nodename"]])
[11:00:01.855]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:01.855]                               info)
[11:00:01.855]                             info <- base::paste(info, collapse = "; ")
[11:00:01.855]                             if (!has_future) {
[11:00:01.855]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:01.855]                                 info)
[11:00:01.855]                             }
[11:00:01.855]                             else {
[11:00:01.855]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:01.855]                                 info, version)
[11:00:01.855]                             }
[11:00:01.855]                             base::stop(msg)
[11:00:01.855]                           }
[11:00:01.855]                         })
[11:00:01.855]                       }
[11:00:01.855]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:01.855]                       base::options(mc.cores = 1L)
[11:00:01.855]                     }
[11:00:01.855]                     base::local({
[11:00:01.855]                       for (pkg in "future.apply") {
[11:00:01.855]                         base::loadNamespace(pkg)
[11:00:01.855]                         base::library(pkg, character.only = TRUE)
[11:00:01.855]                       }
[11:00:01.855]                     })
[11:00:01.855]                   }
[11:00:01.855]                   ...future.strategy.old <- future::plan("list")
[11:00:01.855]                   options(future.plan = NULL)
[11:00:01.855]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.855]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:01.855]                 }
[11:00:01.855]                 ...future.workdir <- getwd()
[11:00:01.855]             }
[11:00:01.855]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:01.855]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:01.855]         }
[11:00:01.855]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:01.855]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:01.855]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:01.855]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:01.855]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:01.855]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:01.855]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:01.855]             base::names(...future.oldOptions))
[11:00:01.855]     }
[11:00:01.855]     if (FALSE) {
[11:00:01.855]     }
[11:00:01.855]     else {
[11:00:01.855]         if (TRUE) {
[11:00:01.855]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:01.855]                 open = "w")
[11:00:01.855]         }
[11:00:01.855]         else {
[11:00:01.855]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:01.855]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:01.855]         }
[11:00:01.855]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:01.855]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:01.855]             base::sink(type = "output", split = FALSE)
[11:00:01.855]             base::close(...future.stdout)
[11:00:01.855]         }, add = TRUE)
[11:00:01.855]     }
[11:00:01.855]     ...future.frame <- base::sys.nframe()
[11:00:01.855]     ...future.conditions <- base::list()
[11:00:01.855]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:01.855]     if (FALSE) {
[11:00:01.855]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:01.855]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:01.855]     }
[11:00:01.855]     ...future.result <- base::tryCatch({
[11:00:01.855]         base::withCallingHandlers({
[11:00:01.855]             ...future.value <- base::withVisible(base::local({
[11:00:01.855]                 withCallingHandlers({
[11:00:01.855]                   {
[11:00:01.855]                     do.call(function(...) {
[11:00:01.855]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.855]                       if (!identical(...future.globals.maxSize.org, 
[11:00:01.855]                         ...future.globals.maxSize)) {
[11:00:01.855]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.855]                         on.exit(options(oopts), add = TRUE)
[11:00:01.855]                       }
[11:00:01.855]                       {
[11:00:01.855]                         lapply(seq_along(...future.elements_ii), 
[11:00:01.855]                           FUN = function(jj) {
[11:00:01.855]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.855]                             ...future.FUN(...future.X_jj, ...)
[11:00:01.855]                           })
[11:00:01.855]                       }
[11:00:01.855]                     }, args = future.call.arguments)
[11:00:01.855]                   }
[11:00:01.855]                 }, immediateCondition = function(cond) {
[11:00:01.855]                   save_rds <- function (object, pathname, ...) 
[11:00:01.855]                   {
[11:00:01.855]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:01.855]                     if (file_test("-f", pathname_tmp)) {
[11:00:01.855]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.855]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:01.855]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.855]                         fi_tmp[["mtime"]])
[11:00:01.855]                     }
[11:00:01.855]                     tryCatch({
[11:00:01.855]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:01.855]                     }, error = function(ex) {
[11:00:01.855]                       msg <- conditionMessage(ex)
[11:00:01.855]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.855]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:01.855]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.855]                         fi_tmp[["mtime"]], msg)
[11:00:01.855]                       ex$message <- msg
[11:00:01.855]                       stop(ex)
[11:00:01.855]                     })
[11:00:01.855]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:01.855]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:01.855]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:01.855]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.855]                       fi <- file.info(pathname)
[11:00:01.855]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:01.855]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.855]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:01.855]                         fi[["size"]], fi[["mtime"]])
[11:00:01.855]                       stop(msg)
[11:00:01.855]                     }
[11:00:01.855]                     invisible(pathname)
[11:00:01.855]                   }
[11:00:01.855]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:01.855]                     rootPath = tempdir()) 
[11:00:01.855]                   {
[11:00:01.855]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:01.855]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:01.855]                       tmpdir = path, fileext = ".rds")
[11:00:01.855]                     save_rds(obj, file)
[11:00:01.855]                   }
[11:00:01.855]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:01.855]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.855]                   {
[11:00:01.855]                     inherits <- base::inherits
[11:00:01.855]                     invokeRestart <- base::invokeRestart
[11:00:01.855]                     is.null <- base::is.null
[11:00:01.855]                     muffled <- FALSE
[11:00:01.855]                     if (inherits(cond, "message")) {
[11:00:01.855]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:01.855]                       if (muffled) 
[11:00:01.855]                         invokeRestart("muffleMessage")
[11:00:01.855]                     }
[11:00:01.855]                     else if (inherits(cond, "warning")) {
[11:00:01.855]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:01.855]                       if (muffled) 
[11:00:01.855]                         invokeRestart("muffleWarning")
[11:00:01.855]                     }
[11:00:01.855]                     else if (inherits(cond, "condition")) {
[11:00:01.855]                       if (!is.null(pattern)) {
[11:00:01.855]                         computeRestarts <- base::computeRestarts
[11:00:01.855]                         grepl <- base::grepl
[11:00:01.855]                         restarts <- computeRestarts(cond)
[11:00:01.855]                         for (restart in restarts) {
[11:00:01.855]                           name <- restart$name
[11:00:01.855]                           if (is.null(name)) 
[11:00:01.855]                             next
[11:00:01.855]                           if (!grepl(pattern, name)) 
[11:00:01.855]                             next
[11:00:01.855]                           invokeRestart(restart)
[11:00:01.855]                           muffled <- TRUE
[11:00:01.855]                           break
[11:00:01.855]                         }
[11:00:01.855]                       }
[11:00:01.855]                     }
[11:00:01.855]                     invisible(muffled)
[11:00:01.855]                   }
[11:00:01.855]                   muffleCondition(cond)
[11:00:01.855]                 })
[11:00:01.855]             }))
[11:00:01.855]             future::FutureResult(value = ...future.value$value, 
[11:00:01.855]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.855]                   ...future.rng), globalenv = if (FALSE) 
[11:00:01.855]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:01.855]                     ...future.globalenv.names))
[11:00:01.855]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:01.855]         }, condition = base::local({
[11:00:01.855]             c <- base::c
[11:00:01.855]             inherits <- base::inherits
[11:00:01.855]             invokeRestart <- base::invokeRestart
[11:00:01.855]             length <- base::length
[11:00:01.855]             list <- base::list
[11:00:01.855]             seq.int <- base::seq.int
[11:00:01.855]             signalCondition <- base::signalCondition
[11:00:01.855]             sys.calls <- base::sys.calls
[11:00:01.855]             `[[` <- base::`[[`
[11:00:01.855]             `+` <- base::`+`
[11:00:01.855]             `<<-` <- base::`<<-`
[11:00:01.855]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:01.855]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:01.855]                   3L)]
[11:00:01.855]             }
[11:00:01.855]             function(cond) {
[11:00:01.855]                 is_error <- inherits(cond, "error")
[11:00:01.855]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:01.855]                   NULL)
[11:00:01.855]                 if (is_error) {
[11:00:01.855]                   sessionInformation <- function() {
[11:00:01.855]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:01.855]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:01.855]                       search = base::search(), system = base::Sys.info())
[11:00:01.855]                   }
[11:00:01.855]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.855]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:01.855]                     cond$call), session = sessionInformation(), 
[11:00:01.855]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:01.855]                   signalCondition(cond)
[11:00:01.855]                 }
[11:00:01.855]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:01.855]                 "immediateCondition"))) {
[11:00:01.855]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:01.855]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.855]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:01.855]                   if (TRUE && !signal) {
[11:00:01.855]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.855]                     {
[11:00:01.855]                       inherits <- base::inherits
[11:00:01.855]                       invokeRestart <- base::invokeRestart
[11:00:01.855]                       is.null <- base::is.null
[11:00:01.855]                       muffled <- FALSE
[11:00:01.855]                       if (inherits(cond, "message")) {
[11:00:01.855]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.855]                         if (muffled) 
[11:00:01.855]                           invokeRestart("muffleMessage")
[11:00:01.855]                       }
[11:00:01.855]                       else if (inherits(cond, "warning")) {
[11:00:01.855]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.855]                         if (muffled) 
[11:00:01.855]                           invokeRestart("muffleWarning")
[11:00:01.855]                       }
[11:00:01.855]                       else if (inherits(cond, "condition")) {
[11:00:01.855]                         if (!is.null(pattern)) {
[11:00:01.855]                           computeRestarts <- base::computeRestarts
[11:00:01.855]                           grepl <- base::grepl
[11:00:01.855]                           restarts <- computeRestarts(cond)
[11:00:01.855]                           for (restart in restarts) {
[11:00:01.855]                             name <- restart$name
[11:00:01.855]                             if (is.null(name)) 
[11:00:01.855]                               next
[11:00:01.855]                             if (!grepl(pattern, name)) 
[11:00:01.855]                               next
[11:00:01.855]                             invokeRestart(restart)
[11:00:01.855]                             muffled <- TRUE
[11:00:01.855]                             break
[11:00:01.855]                           }
[11:00:01.855]                         }
[11:00:01.855]                       }
[11:00:01.855]                       invisible(muffled)
[11:00:01.855]                     }
[11:00:01.855]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.855]                   }
[11:00:01.855]                 }
[11:00:01.855]                 else {
[11:00:01.855]                   if (TRUE) {
[11:00:01.855]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.855]                     {
[11:00:01.855]                       inherits <- base::inherits
[11:00:01.855]                       invokeRestart <- base::invokeRestart
[11:00:01.855]                       is.null <- base::is.null
[11:00:01.855]                       muffled <- FALSE
[11:00:01.855]                       if (inherits(cond, "message")) {
[11:00:01.855]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.855]                         if (muffled) 
[11:00:01.855]                           invokeRestart("muffleMessage")
[11:00:01.855]                       }
[11:00:01.855]                       else if (inherits(cond, "warning")) {
[11:00:01.855]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.855]                         if (muffled) 
[11:00:01.855]                           invokeRestart("muffleWarning")
[11:00:01.855]                       }
[11:00:01.855]                       else if (inherits(cond, "condition")) {
[11:00:01.855]                         if (!is.null(pattern)) {
[11:00:01.855]                           computeRestarts <- base::computeRestarts
[11:00:01.855]                           grepl <- base::grepl
[11:00:01.855]                           restarts <- computeRestarts(cond)
[11:00:01.855]                           for (restart in restarts) {
[11:00:01.855]                             name <- restart$name
[11:00:01.855]                             if (is.null(name)) 
[11:00:01.855]                               next
[11:00:01.855]                             if (!grepl(pattern, name)) 
[11:00:01.855]                               next
[11:00:01.855]                             invokeRestart(restart)
[11:00:01.855]                             muffled <- TRUE
[11:00:01.855]                             break
[11:00:01.855]                           }
[11:00:01.855]                         }
[11:00:01.855]                       }
[11:00:01.855]                       invisible(muffled)
[11:00:01.855]                     }
[11:00:01.855]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.855]                   }
[11:00:01.855]                 }
[11:00:01.855]             }
[11:00:01.855]         }))
[11:00:01.855]     }, error = function(ex) {
[11:00:01.855]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:01.855]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.855]                 ...future.rng), started = ...future.startTime, 
[11:00:01.855]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:01.855]             version = "1.8"), class = "FutureResult")
[11:00:01.855]     }, finally = {
[11:00:01.855]         if (!identical(...future.workdir, getwd())) 
[11:00:01.855]             setwd(...future.workdir)
[11:00:01.855]         {
[11:00:01.855]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:01.855]                 ...future.oldOptions$nwarnings <- NULL
[11:00:01.855]             }
[11:00:01.855]             base::options(...future.oldOptions)
[11:00:01.855]             if (.Platform$OS.type == "windows") {
[11:00:01.855]                 old_names <- names(...future.oldEnvVars)
[11:00:01.855]                 envs <- base::Sys.getenv()
[11:00:01.855]                 names <- names(envs)
[11:00:01.855]                 common <- intersect(names, old_names)
[11:00:01.855]                 added <- setdiff(names, old_names)
[11:00:01.855]                 removed <- setdiff(old_names, names)
[11:00:01.855]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:01.855]                   envs[common]]
[11:00:01.855]                 NAMES <- toupper(changed)
[11:00:01.855]                 args <- list()
[11:00:01.855]                 for (kk in seq_along(NAMES)) {
[11:00:01.855]                   name <- changed[[kk]]
[11:00:01.855]                   NAME <- NAMES[[kk]]
[11:00:01.855]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.855]                     next
[11:00:01.855]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.855]                 }
[11:00:01.855]                 NAMES <- toupper(added)
[11:00:01.855]                 for (kk in seq_along(NAMES)) {
[11:00:01.855]                   name <- added[[kk]]
[11:00:01.855]                   NAME <- NAMES[[kk]]
[11:00:01.855]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.855]                     next
[11:00:01.855]                   args[[name]] <- ""
[11:00:01.855]                 }
[11:00:01.855]                 NAMES <- toupper(removed)
[11:00:01.855]                 for (kk in seq_along(NAMES)) {
[11:00:01.855]                   name <- removed[[kk]]
[11:00:01.855]                   NAME <- NAMES[[kk]]
[11:00:01.855]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.855]                     next
[11:00:01.855]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.855]                 }
[11:00:01.855]                 if (length(args) > 0) 
[11:00:01.855]                   base::do.call(base::Sys.setenv, args = args)
[11:00:01.855]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:01.855]             }
[11:00:01.855]             else {
[11:00:01.855]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:01.855]             }
[11:00:01.855]             {
[11:00:01.855]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:01.855]                   0L) {
[11:00:01.855]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:01.855]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:01.855]                   base::options(opts)
[11:00:01.855]                 }
[11:00:01.855]                 {
[11:00:01.855]                   {
[11:00:01.855]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:01.855]                     NULL
[11:00:01.855]                   }
[11:00:01.855]                   options(future.plan = NULL)
[11:00:01.855]                   if (is.na(NA_character_)) 
[11:00:01.855]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.855]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:01.855]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:01.855]                     .init = FALSE)
[11:00:01.855]                 }
[11:00:01.855]             }
[11:00:01.855]         }
[11:00:01.855]     })
[11:00:01.855]     if (TRUE) {
[11:00:01.855]         base::sink(type = "output", split = FALSE)
[11:00:01.855]         if (TRUE) {
[11:00:01.855]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:01.855]         }
[11:00:01.855]         else {
[11:00:01.855]             ...future.result["stdout"] <- base::list(NULL)
[11:00:01.855]         }
[11:00:01.855]         base::close(...future.stdout)
[11:00:01.855]         ...future.stdout <- NULL
[11:00:01.855]     }
[11:00:01.855]     ...future.result$conditions <- ...future.conditions
[11:00:01.855]     ...future.result$finished <- base::Sys.time()
[11:00:01.855]     ...future.result
[11:00:01.855] }
[11:00:01.858] assign_globals() ...
[11:00:01.858] List of 11
[11:00:01.858]  $ ...future.FUN            :function (x, ...)  
[11:00:01.858]  $ x_FUN                    :function (x)  
[11:00:01.858]  $ times                    : int 4
[11:00:01.858]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.858]  $ stop_if_not              :function (...)  
[11:00:01.858]  $ dim                      : int [1:2] 2 2
[11:00:01.858]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:01.858]  $ future.call.arguments    : list()
[11:00:01.858]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.858]  $ ...future.elements_ii    :List of 5
[11:00:01.858]   ..$ : int 1
[11:00:01.858]   ..$ : int 2
[11:00:01.858]   ..$ : int 3
[11:00:01.858]   ..$ : int 4
[11:00:01.858]   ..$ : int 5
[11:00:01.858]  $ ...future.seeds_ii       : NULL
[11:00:01.858]  $ ...future.globals.maxSize: NULL
[11:00:01.858]  - attr(*, "where")=List of 11
[11:00:01.858]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:01.858]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:01.858]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:01.858]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:01.858]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:01.858]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:01.858]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:01.858]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:01.858]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:01.858]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:01.858]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:01.858]  - attr(*, "resolved")= logi FALSE
[11:00:01.858]  - attr(*, "total_size")= num 29094
[11:00:01.858]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.858]  - attr(*, "already-done")= logi TRUE
[11:00:01.866] - copied ‘...future.FUN’ to environment
[11:00:01.866] - reassign environment for ‘x_FUN’
[11:00:01.866] - copied ‘x_FUN’ to environment
[11:00:01.866] - copied ‘times’ to environment
[11:00:01.866] - copied ‘stopf’ to environment
[11:00:01.867] - copied ‘stop_if_not’ to environment
[11:00:01.867] - copied ‘dim’ to environment
[11:00:01.867] - copied ‘valid_types’ to environment
[11:00:01.867] - copied ‘future.call.arguments’ to environment
[11:00:01.867] - copied ‘...future.elements_ii’ to environment
[11:00:01.867] - copied ‘...future.seeds_ii’ to environment
[11:00:01.867] - copied ‘...future.globals.maxSize’ to environment
[11:00:01.867] assign_globals() ... done
[11:00:01.867] requestCore(): workers = 2
[11:00:01.869] MulticoreFuture started
[11:00:01.870] - Launch lazy future ... done
[11:00:01.870] run() for ‘MulticoreFuture’ ... done
[11:00:01.870] Created future:
[11:00:01.871] plan(): Setting new future strategy stack:
[11:00:01.871] List of future strategies:
[11:00:01.871] 1. sequential:
[11:00:01.871]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:01.871]    - tweaked: FALSE
[11:00:01.871]    - call: NULL
[11:00:01.872] plan(): nbrOfWorkers() = 1
[11:00:01.874] plan(): Setting new future strategy stack:
[11:00:01.874] List of future strategies:
[11:00:01.874] 1. multicore:
[11:00:01.874]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:01.874]    - tweaked: FALSE
[11:00:01.874]    - call: plan(strategy)
[11:00:01.877] plan(): nbrOfWorkers() = 2
[11:00:01.870] MulticoreFuture:
[11:00:01.870] Label: ‘future_vapply-1’
[11:00:01.870] Expression:
[11:00:01.870] {
[11:00:01.870]     do.call(function(...) {
[11:00:01.870]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.870]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.870]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.870]             on.exit(options(oopts), add = TRUE)
[11:00:01.870]         }
[11:00:01.870]         {
[11:00:01.870]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.870]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.870]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.870]             })
[11:00:01.870]         }
[11:00:01.870]     }, args = future.call.arguments)
[11:00:01.870] }
[11:00:01.870] Lazy evaluation: FALSE
[11:00:01.870] Asynchronous evaluation: TRUE
[11:00:01.870] Local evaluation: TRUE
[11:00:01.870] Environment: R_GlobalEnv
[11:00:01.870] Capture standard output: TRUE
[11:00:01.870] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:01.870] Globals: 11 objects totaling 16.28 KiB (function ‘...future.FUN’ of 6.70 KiB, function ‘x_FUN’ of 1.36 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:01.870] Packages: 1 packages (‘future.apply’)
[11:00:01.870] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:01.870] Resolved: TRUE
[11:00:01.870] Value: <not collected>
[11:00:01.870] Conditions captured: <none>
[11:00:01.870] Early signaling: FALSE
[11:00:01.870] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:01.870] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.878] Chunk #1 of 2 ... DONE
[11:00:01.878] Chunk #2 of 2 ...
[11:00:01.879]  - Finding globals in 'X' for chunk #2 ...
[11:00:01.879] getGlobalsAndPackages() ...
[11:00:01.879] Searching for globals...
[11:00:01.879] 
[11:00:01.879] Searching for globals ... DONE
[11:00:01.879] - globals: [0] <none>
[11:00:01.880] getGlobalsAndPackages() ... DONE
[11:00:01.880]    + additional globals found: [n=0] 
[11:00:01.880]    + additional namespaces needed: [n=0] 
[11:00:01.880]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:01.880]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:01.880]  - seeds: <none>
[11:00:01.880]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.880] getGlobalsAndPackages() ...
[11:00:01.881] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.881] Resolving globals: FALSE
[11:00:01.881] Tweak future expression to call with '...' arguments ...
[11:00:01.881] {
[11:00:01.881]     do.call(function(...) {
[11:00:01.881]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.881]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.881]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.881]             on.exit(options(oopts), add = TRUE)
[11:00:01.881]         }
[11:00:01.881]         {
[11:00:01.881]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.881]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.881]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.881]             })
[11:00:01.881]         }
[11:00:01.881]     }, args = future.call.arguments)
[11:00:01.881] }
[11:00:01.881] Tweak future expression to call with '...' arguments ... DONE
[11:00:01.886] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.886] - packages: [1] ‘future.apply’
[11:00:01.887] getGlobalsAndPackages() ... DONE
[11:00:01.888] run() for ‘Future’ ...
[11:00:01.888] - state: ‘created’
[11:00:01.888] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:01.892] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.892] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:01.892]   - Field: ‘label’
[11:00:01.893]   - Field: ‘local’
[11:00:01.893]   - Field: ‘owner’
[11:00:01.893]   - Field: ‘envir’
[11:00:01.893]   - Field: ‘workers’
[11:00:01.893]   - Field: ‘packages’
[11:00:01.894]   - Field: ‘gc’
[11:00:01.894]   - Field: ‘job’
[11:00:01.894]   - Field: ‘conditions’
[11:00:01.894]   - Field: ‘expr’
[11:00:01.894]   - Field: ‘uuid’
[11:00:01.895]   - Field: ‘seed’
[11:00:01.895]   - Field: ‘version’
[11:00:01.895]   - Field: ‘result’
[11:00:01.895]   - Field: ‘asynchronous’
[11:00:01.896]   - Field: ‘calls’
[11:00:01.896]   - Field: ‘globals’
[11:00:01.896]   - Field: ‘stdout’
[11:00:01.896]   - Field: ‘earlySignal’
[11:00:01.896]   - Field: ‘lazy’
[11:00:01.897]   - Field: ‘state’
[11:00:01.897] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:01.897] - Launch lazy future ...
[11:00:01.897] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:01.898] Packages needed by future strategies (n = 0): <none>
[11:00:01.899] {
[11:00:01.899]     {
[11:00:01.899]         {
[11:00:01.899]             ...future.startTime <- base::Sys.time()
[11:00:01.899]             {
[11:00:01.899]                 {
[11:00:01.899]                   {
[11:00:01.899]                     {
[11:00:01.899]                       {
[11:00:01.899]                         base::local({
[11:00:01.899]                           has_future <- base::requireNamespace("future", 
[11:00:01.899]                             quietly = TRUE)
[11:00:01.899]                           if (has_future) {
[11:00:01.899]                             ns <- base::getNamespace("future")
[11:00:01.899]                             version <- ns[[".package"]][["version"]]
[11:00:01.899]                             if (is.null(version)) 
[11:00:01.899]                               version <- utils::packageVersion("future")
[11:00:01.899]                           }
[11:00:01.899]                           else {
[11:00:01.899]                             version <- NULL
[11:00:01.899]                           }
[11:00:01.899]                           if (!has_future || version < "1.8.0") {
[11:00:01.899]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:01.899]                               "", base::R.version$version.string), 
[11:00:01.899]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:01.899]                                 base::R.version$platform, 8 * 
[11:00:01.899]                                   base::.Machine$sizeof.pointer), 
[11:00:01.899]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:01.899]                                 "release", "version")], collapse = " "), 
[11:00:01.899]                               hostname = base::Sys.info()[["nodename"]])
[11:00:01.899]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:01.899]                               info)
[11:00:01.899]                             info <- base::paste(info, collapse = "; ")
[11:00:01.899]                             if (!has_future) {
[11:00:01.899]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:01.899]                                 info)
[11:00:01.899]                             }
[11:00:01.899]                             else {
[11:00:01.899]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:01.899]                                 info, version)
[11:00:01.899]                             }
[11:00:01.899]                             base::stop(msg)
[11:00:01.899]                           }
[11:00:01.899]                         })
[11:00:01.899]                       }
[11:00:01.899]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:01.899]                       base::options(mc.cores = 1L)
[11:00:01.899]                     }
[11:00:01.899]                     base::local({
[11:00:01.899]                       for (pkg in "future.apply") {
[11:00:01.899]                         base::loadNamespace(pkg)
[11:00:01.899]                         base::library(pkg, character.only = TRUE)
[11:00:01.899]                       }
[11:00:01.899]                     })
[11:00:01.899]                   }
[11:00:01.899]                   ...future.strategy.old <- future::plan("list")
[11:00:01.899]                   options(future.plan = NULL)
[11:00:01.899]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.899]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:01.899]                 }
[11:00:01.899]                 ...future.workdir <- getwd()
[11:00:01.899]             }
[11:00:01.899]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:01.899]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:01.899]         }
[11:00:01.899]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:01.899]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:01.899]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:01.899]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:01.899]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:01.899]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:01.899]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:01.899]             base::names(...future.oldOptions))
[11:00:01.899]     }
[11:00:01.899]     if (FALSE) {
[11:00:01.899]     }
[11:00:01.899]     else {
[11:00:01.899]         if (TRUE) {
[11:00:01.899]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:01.899]                 open = "w")
[11:00:01.899]         }
[11:00:01.899]         else {
[11:00:01.899]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:01.899]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:01.899]         }
[11:00:01.899]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:01.899]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:01.899]             base::sink(type = "output", split = FALSE)
[11:00:01.899]             base::close(...future.stdout)
[11:00:01.899]         }, add = TRUE)
[11:00:01.899]     }
[11:00:01.899]     ...future.frame <- base::sys.nframe()
[11:00:01.899]     ...future.conditions <- base::list()
[11:00:01.899]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:01.899]     if (FALSE) {
[11:00:01.899]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:01.899]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:01.899]     }
[11:00:01.899]     ...future.result <- base::tryCatch({
[11:00:01.899]         base::withCallingHandlers({
[11:00:01.899]             ...future.value <- base::withVisible(base::local({
[11:00:01.899]                 withCallingHandlers({
[11:00:01.899]                   {
[11:00:01.899]                     do.call(function(...) {
[11:00:01.899]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.899]                       if (!identical(...future.globals.maxSize.org, 
[11:00:01.899]                         ...future.globals.maxSize)) {
[11:00:01.899]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.899]                         on.exit(options(oopts), add = TRUE)
[11:00:01.899]                       }
[11:00:01.899]                       {
[11:00:01.899]                         lapply(seq_along(...future.elements_ii), 
[11:00:01.899]                           FUN = function(jj) {
[11:00:01.899]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.899]                             ...future.FUN(...future.X_jj, ...)
[11:00:01.899]                           })
[11:00:01.899]                       }
[11:00:01.899]                     }, args = future.call.arguments)
[11:00:01.899]                   }
[11:00:01.899]                 }, immediateCondition = function(cond) {
[11:00:01.899]                   save_rds <- function (object, pathname, ...) 
[11:00:01.899]                   {
[11:00:01.899]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:01.899]                     if (file_test("-f", pathname_tmp)) {
[11:00:01.899]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.899]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:01.899]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.899]                         fi_tmp[["mtime"]])
[11:00:01.899]                     }
[11:00:01.899]                     tryCatch({
[11:00:01.899]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:01.899]                     }, error = function(ex) {
[11:00:01.899]                       msg <- conditionMessage(ex)
[11:00:01.899]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.899]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:01.899]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.899]                         fi_tmp[["mtime"]], msg)
[11:00:01.899]                       ex$message <- msg
[11:00:01.899]                       stop(ex)
[11:00:01.899]                     })
[11:00:01.899]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:01.899]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:01.899]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:01.899]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.899]                       fi <- file.info(pathname)
[11:00:01.899]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:01.899]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.899]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:01.899]                         fi[["size"]], fi[["mtime"]])
[11:00:01.899]                       stop(msg)
[11:00:01.899]                     }
[11:00:01.899]                     invisible(pathname)
[11:00:01.899]                   }
[11:00:01.899]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:01.899]                     rootPath = tempdir()) 
[11:00:01.899]                   {
[11:00:01.899]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:01.899]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:01.899]                       tmpdir = path, fileext = ".rds")
[11:00:01.899]                     save_rds(obj, file)
[11:00:01.899]                   }
[11:00:01.899]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:01.899]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.899]                   {
[11:00:01.899]                     inherits <- base::inherits
[11:00:01.899]                     invokeRestart <- base::invokeRestart
[11:00:01.899]                     is.null <- base::is.null
[11:00:01.899]                     muffled <- FALSE
[11:00:01.899]                     if (inherits(cond, "message")) {
[11:00:01.899]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:01.899]                       if (muffled) 
[11:00:01.899]                         invokeRestart("muffleMessage")
[11:00:01.899]                     }
[11:00:01.899]                     else if (inherits(cond, "warning")) {
[11:00:01.899]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:01.899]                       if (muffled) 
[11:00:01.899]                         invokeRestart("muffleWarning")
[11:00:01.899]                     }
[11:00:01.899]                     else if (inherits(cond, "condition")) {
[11:00:01.899]                       if (!is.null(pattern)) {
[11:00:01.899]                         computeRestarts <- base::computeRestarts
[11:00:01.899]                         grepl <- base::grepl
[11:00:01.899]                         restarts <- computeRestarts(cond)
[11:00:01.899]                         for (restart in restarts) {
[11:00:01.899]                           name <- restart$name
[11:00:01.899]                           if (is.null(name)) 
[11:00:01.899]                             next
[11:00:01.899]                           if (!grepl(pattern, name)) 
[11:00:01.899]                             next
[11:00:01.899]                           invokeRestart(restart)
[11:00:01.899]                           muffled <- TRUE
[11:00:01.899]                           break
[11:00:01.899]                         }
[11:00:01.899]                       }
[11:00:01.899]                     }
[11:00:01.899]                     invisible(muffled)
[11:00:01.899]                   }
[11:00:01.899]                   muffleCondition(cond)
[11:00:01.899]                 })
[11:00:01.899]             }))
[11:00:01.899]             future::FutureResult(value = ...future.value$value, 
[11:00:01.899]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.899]                   ...future.rng), globalenv = if (FALSE) 
[11:00:01.899]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:01.899]                     ...future.globalenv.names))
[11:00:01.899]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:01.899]         }, condition = base::local({
[11:00:01.899]             c <- base::c
[11:00:01.899]             inherits <- base::inherits
[11:00:01.899]             invokeRestart <- base::invokeRestart
[11:00:01.899]             length <- base::length
[11:00:01.899]             list <- base::list
[11:00:01.899]             seq.int <- base::seq.int
[11:00:01.899]             signalCondition <- base::signalCondition
[11:00:01.899]             sys.calls <- base::sys.calls
[11:00:01.899]             `[[` <- base::`[[`
[11:00:01.899]             `+` <- base::`+`
[11:00:01.899]             `<<-` <- base::`<<-`
[11:00:01.899]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:01.899]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:01.899]                   3L)]
[11:00:01.899]             }
[11:00:01.899]             function(cond) {
[11:00:01.899]                 is_error <- inherits(cond, "error")
[11:00:01.899]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:01.899]                   NULL)
[11:00:01.899]                 if (is_error) {
[11:00:01.899]                   sessionInformation <- function() {
[11:00:01.899]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:01.899]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:01.899]                       search = base::search(), system = base::Sys.info())
[11:00:01.899]                   }
[11:00:01.899]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.899]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:01.899]                     cond$call), session = sessionInformation(), 
[11:00:01.899]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:01.899]                   signalCondition(cond)
[11:00:01.899]                 }
[11:00:01.899]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:01.899]                 "immediateCondition"))) {
[11:00:01.899]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:01.899]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.899]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:01.899]                   if (TRUE && !signal) {
[11:00:01.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.899]                     {
[11:00:01.899]                       inherits <- base::inherits
[11:00:01.899]                       invokeRestart <- base::invokeRestart
[11:00:01.899]                       is.null <- base::is.null
[11:00:01.899]                       muffled <- FALSE
[11:00:01.899]                       if (inherits(cond, "message")) {
[11:00:01.899]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.899]                         if (muffled) 
[11:00:01.899]                           invokeRestart("muffleMessage")
[11:00:01.899]                       }
[11:00:01.899]                       else if (inherits(cond, "warning")) {
[11:00:01.899]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.899]                         if (muffled) 
[11:00:01.899]                           invokeRestart("muffleWarning")
[11:00:01.899]                       }
[11:00:01.899]                       else if (inherits(cond, "condition")) {
[11:00:01.899]                         if (!is.null(pattern)) {
[11:00:01.899]                           computeRestarts <- base::computeRestarts
[11:00:01.899]                           grepl <- base::grepl
[11:00:01.899]                           restarts <- computeRestarts(cond)
[11:00:01.899]                           for (restart in restarts) {
[11:00:01.899]                             name <- restart$name
[11:00:01.899]                             if (is.null(name)) 
[11:00:01.899]                               next
[11:00:01.899]                             if (!grepl(pattern, name)) 
[11:00:01.899]                               next
[11:00:01.899]                             invokeRestart(restart)
[11:00:01.899]                             muffled <- TRUE
[11:00:01.899]                             break
[11:00:01.899]                           }
[11:00:01.899]                         }
[11:00:01.899]                       }
[11:00:01.899]                       invisible(muffled)
[11:00:01.899]                     }
[11:00:01.899]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.899]                   }
[11:00:01.899]                 }
[11:00:01.899]                 else {
[11:00:01.899]                   if (TRUE) {
[11:00:01.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.899]                     {
[11:00:01.899]                       inherits <- base::inherits
[11:00:01.899]                       invokeRestart <- base::invokeRestart
[11:00:01.899]                       is.null <- base::is.null
[11:00:01.899]                       muffled <- FALSE
[11:00:01.899]                       if (inherits(cond, "message")) {
[11:00:01.899]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.899]                         if (muffled) 
[11:00:01.899]                           invokeRestart("muffleMessage")
[11:00:01.899]                       }
[11:00:01.899]                       else if (inherits(cond, "warning")) {
[11:00:01.899]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.899]                         if (muffled) 
[11:00:01.899]                           invokeRestart("muffleWarning")
[11:00:01.899]                       }
[11:00:01.899]                       else if (inherits(cond, "condition")) {
[11:00:01.899]                         if (!is.null(pattern)) {
[11:00:01.899]                           computeRestarts <- base::computeRestarts
[11:00:01.899]                           grepl <- base::grepl
[11:00:01.899]                           restarts <- computeRestarts(cond)
[11:00:01.899]                           for (restart in restarts) {
[11:00:01.899]                             name <- restart$name
[11:00:01.899]                             if (is.null(name)) 
[11:00:01.899]                               next
[11:00:01.899]                             if (!grepl(pattern, name)) 
[11:00:01.899]                               next
[11:00:01.899]                             invokeRestart(restart)
[11:00:01.899]                             muffled <- TRUE
[11:00:01.899]                             break
[11:00:01.899]                           }
[11:00:01.899]                         }
[11:00:01.899]                       }
[11:00:01.899]                       invisible(muffled)
[11:00:01.899]                     }
[11:00:01.899]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.899]                   }
[11:00:01.899]                 }
[11:00:01.899]             }
[11:00:01.899]         }))
[11:00:01.899]     }, error = function(ex) {
[11:00:01.899]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:01.899]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.899]                 ...future.rng), started = ...future.startTime, 
[11:00:01.899]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:01.899]             version = "1.8"), class = "FutureResult")
[11:00:01.899]     }, finally = {
[11:00:01.899]         if (!identical(...future.workdir, getwd())) 
[11:00:01.899]             setwd(...future.workdir)
[11:00:01.899]         {
[11:00:01.899]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:01.899]                 ...future.oldOptions$nwarnings <- NULL
[11:00:01.899]             }
[11:00:01.899]             base::options(...future.oldOptions)
[11:00:01.899]             if (.Platform$OS.type == "windows") {
[11:00:01.899]                 old_names <- names(...future.oldEnvVars)
[11:00:01.899]                 envs <- base::Sys.getenv()
[11:00:01.899]                 names <- names(envs)
[11:00:01.899]                 common <- intersect(names, old_names)
[11:00:01.899]                 added <- setdiff(names, old_names)
[11:00:01.899]                 removed <- setdiff(old_names, names)
[11:00:01.899]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:01.899]                   envs[common]]
[11:00:01.899]                 NAMES <- toupper(changed)
[11:00:01.899]                 args <- list()
[11:00:01.899]                 for (kk in seq_along(NAMES)) {
[11:00:01.899]                   name <- changed[[kk]]
[11:00:01.899]                   NAME <- NAMES[[kk]]
[11:00:01.899]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.899]                     next
[11:00:01.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.899]                 }
[11:00:01.899]                 NAMES <- toupper(added)
[11:00:01.899]                 for (kk in seq_along(NAMES)) {
[11:00:01.899]                   name <- added[[kk]]
[11:00:01.899]                   NAME <- NAMES[[kk]]
[11:00:01.899]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.899]                     next
[11:00:01.899]                   args[[name]] <- ""
[11:00:01.899]                 }
[11:00:01.899]                 NAMES <- toupper(removed)
[11:00:01.899]                 for (kk in seq_along(NAMES)) {
[11:00:01.899]                   name <- removed[[kk]]
[11:00:01.899]                   NAME <- NAMES[[kk]]
[11:00:01.899]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.899]                     next
[11:00:01.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.899]                 }
[11:00:01.899]                 if (length(args) > 0) 
[11:00:01.899]                   base::do.call(base::Sys.setenv, args = args)
[11:00:01.899]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:01.899]             }
[11:00:01.899]             else {
[11:00:01.899]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:01.899]             }
[11:00:01.899]             {
[11:00:01.899]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:01.899]                   0L) {
[11:00:01.899]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:01.899]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:01.899]                   base::options(opts)
[11:00:01.899]                 }
[11:00:01.899]                 {
[11:00:01.899]                   {
[11:00:01.899]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:01.899]                     NULL
[11:00:01.899]                   }
[11:00:01.899]                   options(future.plan = NULL)
[11:00:01.899]                   if (is.na(NA_character_)) 
[11:00:01.899]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.899]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:01.899]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:01.899]                     .init = FALSE)
[11:00:01.899]                 }
[11:00:01.899]             }
[11:00:01.899]         }
[11:00:01.899]     })
[11:00:01.899]     if (TRUE) {
[11:00:01.899]         base::sink(type = "output", split = FALSE)
[11:00:01.899]         if (TRUE) {
[11:00:01.899]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:01.899]         }
[11:00:01.899]         else {
[11:00:01.899]             ...future.result["stdout"] <- base::list(NULL)
[11:00:01.899]         }
[11:00:01.899]         base::close(...future.stdout)
[11:00:01.899]         ...future.stdout <- NULL
[11:00:01.899]     }
[11:00:01.899]     ...future.result$conditions <- ...future.conditions
[11:00:01.899]     ...future.result$finished <- base::Sys.time()
[11:00:01.899]     ...future.result
[11:00:01.899] }
[11:00:01.901] assign_globals() ...
[11:00:01.901] List of 11
[11:00:01.901]  $ ...future.FUN            :function (x, ...)  
[11:00:01.901]  $ x_FUN                    :function (x)  
[11:00:01.901]  $ times                    : int 4
[11:00:01.901]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.901]  $ stop_if_not              :function (...)  
[11:00:01.901]  $ dim                      : int [1:2] 2 2
[11:00:01.901]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:01.901]  $ future.call.arguments    : list()
[11:00:01.901]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.901]  $ ...future.elements_ii    :List of 5
[11:00:01.901]   ..$ : int 6
[11:00:01.901]   ..$ : int 7
[11:00:01.901]   ..$ : int 8
[11:00:01.901]   ..$ : int 9
[11:00:01.901]   ..$ : int 10
[11:00:01.901]  $ ...future.seeds_ii       : NULL
[11:00:01.901]  $ ...future.globals.maxSize: NULL
[11:00:01.901]  - attr(*, "where")=List of 11
[11:00:01.901]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:01.901]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:01.901]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:01.901]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:01.901]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:01.901]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:01.901]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:01.901]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:01.901]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:01.901]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:01.901]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:01.901]  - attr(*, "resolved")= logi FALSE
[11:00:01.901]  - attr(*, "total_size")= num 29094
[11:00:01.901]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.901]  - attr(*, "already-done")= logi TRUE
[11:00:01.912] - copied ‘...future.FUN’ to environment
[11:00:01.913] - reassign environment for ‘x_FUN’
[11:00:01.913] - copied ‘x_FUN’ to environment
[11:00:01.913] - copied ‘times’ to environment
[11:00:01.913] - copied ‘stopf’ to environment
[11:00:01.913] - copied ‘stop_if_not’ to environment
[11:00:01.913] - copied ‘dim’ to environment
[11:00:01.913] - copied ‘valid_types’ to environment
[11:00:01.913] - copied ‘future.call.arguments’ to environment
[11:00:01.913] - copied ‘...future.elements_ii’ to environment
[11:00:01.913] - copied ‘...future.seeds_ii’ to environment
[11:00:01.914] - copied ‘...future.globals.maxSize’ to environment
[11:00:01.914] assign_globals() ... done
[11:00:01.914] requestCore(): workers = 2
[11:00:01.916] MulticoreFuture started
[11:00:01.916] - Launch lazy future ... done
[11:00:01.917] run() for ‘MulticoreFuture’ ... done
[11:00:01.917] Created future:
[11:00:01.917] plan(): Setting new future strategy stack:
[11:00:01.918] List of future strategies:
[11:00:01.918] 1. sequential:
[11:00:01.918]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:01.918]    - tweaked: FALSE
[11:00:01.918]    - call: NULL
[11:00:01.919] plan(): nbrOfWorkers() = 1
[11:00:01.921] plan(): Setting new future strategy stack:
[11:00:01.921] List of future strategies:
[11:00:01.921] 1. multicore:
[11:00:01.921]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:01.921]    - tweaked: FALSE
[11:00:01.921]    - call: plan(strategy)
[11:00:01.929] plan(): nbrOfWorkers() = 2
[11:00:01.917] MulticoreFuture:
[11:00:01.917] Label: ‘future_vapply-2’
[11:00:01.917] Expression:
[11:00:01.917] {
[11:00:01.917]     do.call(function(...) {
[11:00:01.917]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.917]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.917]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.917]             on.exit(options(oopts), add = TRUE)
[11:00:01.917]         }
[11:00:01.917]         {
[11:00:01.917]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.917]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.917]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.917]             })
[11:00:01.917]         }
[11:00:01.917]     }, args = future.call.arguments)
[11:00:01.917] }
[11:00:01.917] Lazy evaluation: FALSE
[11:00:01.917] Asynchronous evaluation: TRUE
[11:00:01.917] Local evaluation: TRUE
[11:00:01.917] Environment: R_GlobalEnv
[11:00:01.917] Capture standard output: TRUE
[11:00:01.917] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:01.917] Globals: 11 objects totaling 16.28 KiB (function ‘...future.FUN’ of 6.70 KiB, function ‘x_FUN’ of 1.36 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:01.917] Packages: 1 packages (‘future.apply’)
[11:00:01.917] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:01.917] Resolved: FALSE
[11:00:01.917] Value: <not collected>
[11:00:01.917] Conditions captured: <none>
[11:00:01.917] Early signaling: FALSE
[11:00:01.917] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:01.917] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.930] Chunk #2 of 2 ... DONE
[11:00:01.930] Launching 2 futures (chunks) ... DONE
[11:00:01.930] Resolving 2 futures (chunks) ...
[11:00:01.930] resolve() on list ...
[11:00:01.930]  recursive: 0
[11:00:01.930]  length: 2
[11:00:01.931] 
[11:00:01.931] Future #1
[11:00:01.931] result() for MulticoreFuture ...
[11:00:01.932] result() for MulticoreFuture ...
[11:00:01.934] result() for MulticoreFuture ... done
[11:00:01.935] result() for MulticoreFuture ... done
[11:00:01.935] result() for MulticoreFuture ...
[11:00:01.935] result() for MulticoreFuture ... done
[11:00:01.936] signalConditionsASAP(MulticoreFuture, pos=1) ...
[11:00:01.936] - nx: 2
[11:00:01.936] - relay: TRUE
[11:00:01.936] - stdout: TRUE
[11:00:01.937] - signal: TRUE
[11:00:01.937] - resignal: FALSE
[11:00:01.937] - force: TRUE
[11:00:01.938] - relayed: [n=2] FALSE, FALSE
[11:00:01.938] - queued futures: [n=2] FALSE, FALSE
[11:00:01.938]  - until=1
[11:00:01.938]  - relaying element #1
[11:00:01.939] result() for MulticoreFuture ...
[11:00:01.939] result() for MulticoreFuture ... done
[11:00:01.939] result() for MulticoreFuture ...
[11:00:01.939] result() for MulticoreFuture ... done
[11:00:01.940] result() for MulticoreFuture ...
[11:00:01.940] result() for MulticoreFuture ... done
[11:00:01.940] result() for MulticoreFuture ...
[11:00:01.941] result() for MulticoreFuture ... done
[11:00:01.941] - relayed: [n=2] TRUE, FALSE
[11:00:01.941] - queued futures: [n=2] TRUE, FALSE
[11:00:01.941] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[11:00:01.942]  length: 1 (resolved future 1)
[11:00:01.942] Future #2
[11:00:01.942] result() for MulticoreFuture ...
[11:00:01.943] result() for MulticoreFuture ...
[11:00:01.944] result() for MulticoreFuture ... done
[11:00:01.944] result() for MulticoreFuture ... done
[11:00:01.944] result() for MulticoreFuture ...
[11:00:01.944] result() for MulticoreFuture ... done
[11:00:01.944] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:00:01.945] - nx: 2
[11:00:01.945] - relay: TRUE
[11:00:01.945] - stdout: TRUE
[11:00:01.945] - signal: TRUE
[11:00:01.945] - resignal: FALSE
[11:00:01.946] - force: TRUE
[11:00:01.946] - relayed: [n=2] TRUE, FALSE
[11:00:01.946] - queued futures: [n=2] TRUE, FALSE
[11:00:01.946]  - until=2
[11:00:01.946]  - relaying element #2
[11:00:01.946] result() for MulticoreFuture ...
[11:00:01.946] result() for MulticoreFuture ... done
[11:00:01.947] result() for MulticoreFuture ...
[11:00:01.947] result() for MulticoreFuture ... done
[11:00:01.947] result() for MulticoreFuture ...
[11:00:01.947] result() for MulticoreFuture ... done
[11:00:01.947] result() for MulticoreFuture ...
[11:00:01.947] result() for MulticoreFuture ... done
[11:00:01.947] - relayed: [n=2] TRUE, TRUE
[11:00:01.948] - queued futures: [n=2] TRUE, TRUE
[11:00:01.948] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:00:01.948]  length: 0 (resolved future 2)
[11:00:01.948] Relaying remaining futures
[11:00:01.948] signalConditionsASAP(NULL, pos=0) ...
[11:00:01.948] - nx: 2
[11:00:01.948] - relay: TRUE
[11:00:01.948] - stdout: TRUE
[11:00:01.948] - signal: TRUE
[11:00:01.948] - resignal: FALSE
[11:00:01.948] - force: TRUE
[11:00:01.949] - relayed: [n=2] TRUE, TRUE
[11:00:01.949] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:01.949] - relayed: [n=2] TRUE, TRUE
[11:00:01.949] - queued futures: [n=2] TRUE, TRUE
[11:00:01.949] signalConditionsASAP(NULL, pos=0) ... done
[11:00:01.949] resolve() on list ... DONE
[11:00:01.949] result() for MulticoreFuture ...
[11:00:01.949] result() for MulticoreFuture ... done
[11:00:01.950] result() for MulticoreFuture ...
[11:00:01.950] result() for MulticoreFuture ... done
[11:00:01.950] result() for MulticoreFuture ...
[11:00:01.950] result() for MulticoreFuture ... done
[11:00:01.950] result() for MulticoreFuture ...
[11:00:01.950] result() for MulticoreFuture ... done
[11:00:01.950]  - Number of value chunks collected: 2
[11:00:01.950] Resolving 2 futures (chunks) ... DONE
[11:00:01.950] Reducing values from 2 chunks ...
[11:00:01.951]  - Number of values collected after concatenation: 10
[11:00:01.951]  - Number of values expected: 10
[11:00:01.951] Reducing values from 2 chunks ... DONE
[11:00:01.951] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[11:00:01.954] future_lapply() ...
[11:00:01.957] Number of chunks: 2
[11:00:01.958] getGlobalsAndPackagesXApply() ...
[11:00:01.958]  - future.globals: TRUE
[11:00:01.958] getGlobalsAndPackages() ...
[11:00:01.958] Searching for globals...
[11:00:01.962] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[11:00:01.962] Searching for globals ... DONE
[11:00:01.962] Resolving globals: FALSE
[11:00:01.963] The total size of the 7 globals is 13.03 KiB (13339 bytes)
[11:00:01.965] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.03 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.75 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:01.965] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:01.965] - packages: [2] ‘stats’, ‘future.apply’
[11:00:01.965] getGlobalsAndPackages() ... DONE
[11:00:01.966]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:01.966]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[11:00:01.966] Finding globals ... DONE
[11:00:01.966]  - use_args: TRUE
[11:00:01.966]  - Getting '...' globals ...
[11:00:01.966] resolve() on list ...
[11:00:01.967]  recursive: 0
[11:00:01.967]  length: 1
[11:00:01.967]  elements: ‘...’
[11:00:01.967]  length: 0 (resolved future 1)
[11:00:01.967] resolve() on list ... DONE
[11:00:01.967]    - '...' content: [n=0] 
[11:00:01.967] List of 1
[11:00:01.967]  $ ...: list()
[11:00:01.967]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.967]  - attr(*, "where")=List of 1
[11:00:01.967]   ..$ ...:<environment: 0x55bbab8e9c10> 
[11:00:01.967]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.967]  - attr(*, "resolved")= logi TRUE
[11:00:01.967]  - attr(*, "total_size")= num NA
[11:00:01.970]  - Getting '...' globals ... DONE
[11:00:01.970] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:01.970] List of 8
[11:00:01.970]  $ ...future.FUN:function (x, ...)  
[11:00:01.970]  $ x_FUN        :function (x, ...)  
[11:00:01.970]  $ times        : int 5
[11:00:01.970]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.970]  $ stop_if_not  :function (...)  
[11:00:01.970]  $ dim          : NULL
[11:00:01.970]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:01.970]  $ ...          : list()
[11:00:01.970]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.970]  - attr(*, "where")=List of 8
[11:00:01.970]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:01.970]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:01.970]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:01.970]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:01.970]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:01.970]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:01.970]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:01.970]   ..$ ...          :<environment: 0x55bbab8e9c10> 
[11:00:01.970]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.970]  - attr(*, "resolved")= logi FALSE
[11:00:01.970]  - attr(*, "total_size")= num 24127
[11:00:01.976] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[11:00:01.976] getGlobalsAndPackagesXApply() ... DONE
[11:00:01.976] Number of futures (= number of chunks): 2
[11:00:01.976] Launching 2 futures (chunks) ...
[11:00:01.976] Chunk #1 of 2 ...
[11:00:01.977]  - Finding globals in 'X' for chunk #1 ...
[11:00:01.977] getGlobalsAndPackages() ...
[11:00:01.977] Searching for globals...
[11:00:01.977] 
[11:00:01.977] Searching for globals ... DONE
[11:00:01.977] - globals: [0] <none>
[11:00:01.977] getGlobalsAndPackages() ... DONE
[11:00:01.977]    + additional globals found: [n=0] 
[11:00:01.977]    + additional namespaces needed: [n=0] 
[11:00:01.978]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:01.978]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:01.978]  - seeds: <none>
[11:00:01.978]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.978] getGlobalsAndPackages() ...
[11:00:01.978] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.978] Resolving globals: FALSE
[11:00:01.978] Tweak future expression to call with '...' arguments ...
[11:00:01.978] {
[11:00:01.978]     do.call(function(...) {
[11:00:01.978]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.978]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:01.978]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.978]             on.exit(options(oopts), add = TRUE)
[11:00:01.978]         }
[11:00:01.978]         {
[11:00:01.978]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:01.978]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.978]                 ...future.FUN(...future.X_jj, ...)
[11:00:01.978]             })
[11:00:01.978]         }
[11:00:01.978]     }, args = future.call.arguments)
[11:00:01.978] }
[11:00:01.979] Tweak future expression to call with '...' arguments ... DONE
[11:00:01.979] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:01.979] - packages: [2] ‘stats’, ‘future.apply’
[11:00:01.979] getGlobalsAndPackages() ... DONE
[11:00:01.980] run() for ‘Future’ ...
[11:00:01.980] - state: ‘created’
[11:00:01.980] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:01.981] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:01.982] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:01.982]   - Field: ‘label’
[11:00:01.982]   - Field: ‘local’
[11:00:01.982]   - Field: ‘owner’
[11:00:01.982]   - Field: ‘envir’
[11:00:01.982]   - Field: ‘workers’
[11:00:01.982]   - Field: ‘packages’
[11:00:01.982]   - Field: ‘gc’
[11:00:01.982]   - Field: ‘job’
[11:00:01.982]   - Field: ‘conditions’
[11:00:01.983]   - Field: ‘expr’
[11:00:01.983]   - Field: ‘uuid’
[11:00:01.983]   - Field: ‘seed’
[11:00:01.983]   - Field: ‘version’
[11:00:01.983]   - Field: ‘result’
[11:00:01.983]   - Field: ‘asynchronous’
[11:00:01.983]   - Field: ‘calls’
[11:00:01.983]   - Field: ‘globals’
[11:00:01.983]   - Field: ‘stdout’
[11:00:01.983]   - Field: ‘earlySignal’
[11:00:01.983]   - Field: ‘lazy’
[11:00:01.984]   - Field: ‘state’
[11:00:01.984] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:01.984] - Launch lazy future ...
[11:00:01.984] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[11:00:01.984] Packages needed by future strategies (n = 0): <none>
[11:00:01.985] {
[11:00:01.985]     {
[11:00:01.985]         {
[11:00:01.985]             ...future.startTime <- base::Sys.time()
[11:00:01.985]             {
[11:00:01.985]                 {
[11:00:01.985]                   {
[11:00:01.985]                     {
[11:00:01.985]                       {
[11:00:01.985]                         base::local({
[11:00:01.985]                           has_future <- base::requireNamespace("future", 
[11:00:01.985]                             quietly = TRUE)
[11:00:01.985]                           if (has_future) {
[11:00:01.985]                             ns <- base::getNamespace("future")
[11:00:01.985]                             version <- ns[[".package"]][["version"]]
[11:00:01.985]                             if (is.null(version)) 
[11:00:01.985]                               version <- utils::packageVersion("future")
[11:00:01.985]                           }
[11:00:01.985]                           else {
[11:00:01.985]                             version <- NULL
[11:00:01.985]                           }
[11:00:01.985]                           if (!has_future || version < "1.8.0") {
[11:00:01.985]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:01.985]                               "", base::R.version$version.string), 
[11:00:01.985]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:01.985]                                 base::R.version$platform, 8 * 
[11:00:01.985]                                   base::.Machine$sizeof.pointer), 
[11:00:01.985]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:01.985]                                 "release", "version")], collapse = " "), 
[11:00:01.985]                               hostname = base::Sys.info()[["nodename"]])
[11:00:01.985]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:01.985]                               info)
[11:00:01.985]                             info <- base::paste(info, collapse = "; ")
[11:00:01.985]                             if (!has_future) {
[11:00:01.985]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:01.985]                                 info)
[11:00:01.985]                             }
[11:00:01.985]                             else {
[11:00:01.985]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:01.985]                                 info, version)
[11:00:01.985]                             }
[11:00:01.985]                             base::stop(msg)
[11:00:01.985]                           }
[11:00:01.985]                         })
[11:00:01.985]                       }
[11:00:01.985]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:01.985]                       base::options(mc.cores = 1L)
[11:00:01.985]                     }
[11:00:01.985]                     base::local({
[11:00:01.985]                       for (pkg in c("stats", "future.apply")) {
[11:00:01.985]                         base::loadNamespace(pkg)
[11:00:01.985]                         base::library(pkg, character.only = TRUE)
[11:00:01.985]                       }
[11:00:01.985]                     })
[11:00:01.985]                   }
[11:00:01.985]                   ...future.strategy.old <- future::plan("list")
[11:00:01.985]                   options(future.plan = NULL)
[11:00:01.985]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.985]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:01.985]                 }
[11:00:01.985]                 ...future.workdir <- getwd()
[11:00:01.985]             }
[11:00:01.985]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:01.985]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:01.985]         }
[11:00:01.985]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:01.985]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:01.985]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:01.985]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:01.985]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:01.985]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:01.985]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:01.985]             base::names(...future.oldOptions))
[11:00:01.985]     }
[11:00:01.985]     if (FALSE) {
[11:00:01.985]     }
[11:00:01.985]     else {
[11:00:01.985]         if (TRUE) {
[11:00:01.985]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:01.985]                 open = "w")
[11:00:01.985]         }
[11:00:01.985]         else {
[11:00:01.985]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:01.985]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:01.985]         }
[11:00:01.985]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:01.985]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:01.985]             base::sink(type = "output", split = FALSE)
[11:00:01.985]             base::close(...future.stdout)
[11:00:01.985]         }, add = TRUE)
[11:00:01.985]     }
[11:00:01.985]     ...future.frame <- base::sys.nframe()
[11:00:01.985]     ...future.conditions <- base::list()
[11:00:01.985]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:01.985]     if (FALSE) {
[11:00:01.985]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:01.985]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:01.985]     }
[11:00:01.985]     ...future.result <- base::tryCatch({
[11:00:01.985]         base::withCallingHandlers({
[11:00:01.985]             ...future.value <- base::withVisible(base::local({
[11:00:01.985]                 withCallingHandlers({
[11:00:01.985]                   {
[11:00:01.985]                     do.call(function(...) {
[11:00:01.985]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:01.985]                       if (!identical(...future.globals.maxSize.org, 
[11:00:01.985]                         ...future.globals.maxSize)) {
[11:00:01.985]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:01.985]                         on.exit(options(oopts), add = TRUE)
[11:00:01.985]                       }
[11:00:01.985]                       {
[11:00:01.985]                         lapply(seq_along(...future.elements_ii), 
[11:00:01.985]                           FUN = function(jj) {
[11:00:01.985]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:01.985]                             ...future.FUN(...future.X_jj, ...)
[11:00:01.985]                           })
[11:00:01.985]                       }
[11:00:01.985]                     }, args = future.call.arguments)
[11:00:01.985]                   }
[11:00:01.985]                 }, immediateCondition = function(cond) {
[11:00:01.985]                   save_rds <- function (object, pathname, ...) 
[11:00:01.985]                   {
[11:00:01.985]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:01.985]                     if (file_test("-f", pathname_tmp)) {
[11:00:01.985]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.985]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:01.985]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.985]                         fi_tmp[["mtime"]])
[11:00:01.985]                     }
[11:00:01.985]                     tryCatch({
[11:00:01.985]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:01.985]                     }, error = function(ex) {
[11:00:01.985]                       msg <- conditionMessage(ex)
[11:00:01.985]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.985]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:01.985]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.985]                         fi_tmp[["mtime"]], msg)
[11:00:01.985]                       ex$message <- msg
[11:00:01.985]                       stop(ex)
[11:00:01.985]                     })
[11:00:01.985]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:01.985]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:01.985]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:01.985]                       fi_tmp <- file.info(pathname_tmp)
[11:00:01.985]                       fi <- file.info(pathname)
[11:00:01.985]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:01.985]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:01.985]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:01.985]                         fi[["size"]], fi[["mtime"]])
[11:00:01.985]                       stop(msg)
[11:00:01.985]                     }
[11:00:01.985]                     invisible(pathname)
[11:00:01.985]                   }
[11:00:01.985]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:01.985]                     rootPath = tempdir()) 
[11:00:01.985]                   {
[11:00:01.985]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:01.985]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:01.985]                       tmpdir = path, fileext = ".rds")
[11:00:01.985]                     save_rds(obj, file)
[11:00:01.985]                   }
[11:00:01.985]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:01.985]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.985]                   {
[11:00:01.985]                     inherits <- base::inherits
[11:00:01.985]                     invokeRestart <- base::invokeRestart
[11:00:01.985]                     is.null <- base::is.null
[11:00:01.985]                     muffled <- FALSE
[11:00:01.985]                     if (inherits(cond, "message")) {
[11:00:01.985]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:01.985]                       if (muffled) 
[11:00:01.985]                         invokeRestart("muffleMessage")
[11:00:01.985]                     }
[11:00:01.985]                     else if (inherits(cond, "warning")) {
[11:00:01.985]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:01.985]                       if (muffled) 
[11:00:01.985]                         invokeRestart("muffleWarning")
[11:00:01.985]                     }
[11:00:01.985]                     else if (inherits(cond, "condition")) {
[11:00:01.985]                       if (!is.null(pattern)) {
[11:00:01.985]                         computeRestarts <- base::computeRestarts
[11:00:01.985]                         grepl <- base::grepl
[11:00:01.985]                         restarts <- computeRestarts(cond)
[11:00:01.985]                         for (restart in restarts) {
[11:00:01.985]                           name <- restart$name
[11:00:01.985]                           if (is.null(name)) 
[11:00:01.985]                             next
[11:00:01.985]                           if (!grepl(pattern, name)) 
[11:00:01.985]                             next
[11:00:01.985]                           invokeRestart(restart)
[11:00:01.985]                           muffled <- TRUE
[11:00:01.985]                           break
[11:00:01.985]                         }
[11:00:01.985]                       }
[11:00:01.985]                     }
[11:00:01.985]                     invisible(muffled)
[11:00:01.985]                   }
[11:00:01.985]                   muffleCondition(cond)
[11:00:01.985]                 })
[11:00:01.985]             }))
[11:00:01.985]             future::FutureResult(value = ...future.value$value, 
[11:00:01.985]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.985]                   ...future.rng), globalenv = if (FALSE) 
[11:00:01.985]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:01.985]                     ...future.globalenv.names))
[11:00:01.985]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:01.985]         }, condition = base::local({
[11:00:01.985]             c <- base::c
[11:00:01.985]             inherits <- base::inherits
[11:00:01.985]             invokeRestart <- base::invokeRestart
[11:00:01.985]             length <- base::length
[11:00:01.985]             list <- base::list
[11:00:01.985]             seq.int <- base::seq.int
[11:00:01.985]             signalCondition <- base::signalCondition
[11:00:01.985]             sys.calls <- base::sys.calls
[11:00:01.985]             `[[` <- base::`[[`
[11:00:01.985]             `+` <- base::`+`
[11:00:01.985]             `<<-` <- base::`<<-`
[11:00:01.985]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:01.985]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:01.985]                   3L)]
[11:00:01.985]             }
[11:00:01.985]             function(cond) {
[11:00:01.985]                 is_error <- inherits(cond, "error")
[11:00:01.985]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:01.985]                   NULL)
[11:00:01.985]                 if (is_error) {
[11:00:01.985]                   sessionInformation <- function() {
[11:00:01.985]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:01.985]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:01.985]                       search = base::search(), system = base::Sys.info())
[11:00:01.985]                   }
[11:00:01.985]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.985]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:01.985]                     cond$call), session = sessionInformation(), 
[11:00:01.985]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:01.985]                   signalCondition(cond)
[11:00:01.985]                 }
[11:00:01.985]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:01.985]                 "immediateCondition"))) {
[11:00:01.985]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:01.985]                   ...future.conditions[[length(...future.conditions) + 
[11:00:01.985]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:01.985]                   if (TRUE && !signal) {
[11:00:01.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.985]                     {
[11:00:01.985]                       inherits <- base::inherits
[11:00:01.985]                       invokeRestart <- base::invokeRestart
[11:00:01.985]                       is.null <- base::is.null
[11:00:01.985]                       muffled <- FALSE
[11:00:01.985]                       if (inherits(cond, "message")) {
[11:00:01.985]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.985]                         if (muffled) 
[11:00:01.985]                           invokeRestart("muffleMessage")
[11:00:01.985]                       }
[11:00:01.985]                       else if (inherits(cond, "warning")) {
[11:00:01.985]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.985]                         if (muffled) 
[11:00:01.985]                           invokeRestart("muffleWarning")
[11:00:01.985]                       }
[11:00:01.985]                       else if (inherits(cond, "condition")) {
[11:00:01.985]                         if (!is.null(pattern)) {
[11:00:01.985]                           computeRestarts <- base::computeRestarts
[11:00:01.985]                           grepl <- base::grepl
[11:00:01.985]                           restarts <- computeRestarts(cond)
[11:00:01.985]                           for (restart in restarts) {
[11:00:01.985]                             name <- restart$name
[11:00:01.985]                             if (is.null(name)) 
[11:00:01.985]                               next
[11:00:01.985]                             if (!grepl(pattern, name)) 
[11:00:01.985]                               next
[11:00:01.985]                             invokeRestart(restart)
[11:00:01.985]                             muffled <- TRUE
[11:00:01.985]                             break
[11:00:01.985]                           }
[11:00:01.985]                         }
[11:00:01.985]                       }
[11:00:01.985]                       invisible(muffled)
[11:00:01.985]                     }
[11:00:01.985]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.985]                   }
[11:00:01.985]                 }
[11:00:01.985]                 else {
[11:00:01.985]                   if (TRUE) {
[11:00:01.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:01.985]                     {
[11:00:01.985]                       inherits <- base::inherits
[11:00:01.985]                       invokeRestart <- base::invokeRestart
[11:00:01.985]                       is.null <- base::is.null
[11:00:01.985]                       muffled <- FALSE
[11:00:01.985]                       if (inherits(cond, "message")) {
[11:00:01.985]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:01.985]                         if (muffled) 
[11:00:01.985]                           invokeRestart("muffleMessage")
[11:00:01.985]                       }
[11:00:01.985]                       else if (inherits(cond, "warning")) {
[11:00:01.985]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:01.985]                         if (muffled) 
[11:00:01.985]                           invokeRestart("muffleWarning")
[11:00:01.985]                       }
[11:00:01.985]                       else if (inherits(cond, "condition")) {
[11:00:01.985]                         if (!is.null(pattern)) {
[11:00:01.985]                           computeRestarts <- base::computeRestarts
[11:00:01.985]                           grepl <- base::grepl
[11:00:01.985]                           restarts <- computeRestarts(cond)
[11:00:01.985]                           for (restart in restarts) {
[11:00:01.985]                             name <- restart$name
[11:00:01.985]                             if (is.null(name)) 
[11:00:01.985]                               next
[11:00:01.985]                             if (!grepl(pattern, name)) 
[11:00:01.985]                               next
[11:00:01.985]                             invokeRestart(restart)
[11:00:01.985]                             muffled <- TRUE
[11:00:01.985]                             break
[11:00:01.985]                           }
[11:00:01.985]                         }
[11:00:01.985]                       }
[11:00:01.985]                       invisible(muffled)
[11:00:01.985]                     }
[11:00:01.985]                     muffleCondition(cond, pattern = "^muffle")
[11:00:01.985]                   }
[11:00:01.985]                 }
[11:00:01.985]             }
[11:00:01.985]         }))
[11:00:01.985]     }, error = function(ex) {
[11:00:01.985]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:01.985]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:01.985]                 ...future.rng), started = ...future.startTime, 
[11:00:01.985]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:01.985]             version = "1.8"), class = "FutureResult")
[11:00:01.985]     }, finally = {
[11:00:01.985]         if (!identical(...future.workdir, getwd())) 
[11:00:01.985]             setwd(...future.workdir)
[11:00:01.985]         {
[11:00:01.985]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:01.985]                 ...future.oldOptions$nwarnings <- NULL
[11:00:01.985]             }
[11:00:01.985]             base::options(...future.oldOptions)
[11:00:01.985]             if (.Platform$OS.type == "windows") {
[11:00:01.985]                 old_names <- names(...future.oldEnvVars)
[11:00:01.985]                 envs <- base::Sys.getenv()
[11:00:01.985]                 names <- names(envs)
[11:00:01.985]                 common <- intersect(names, old_names)
[11:00:01.985]                 added <- setdiff(names, old_names)
[11:00:01.985]                 removed <- setdiff(old_names, names)
[11:00:01.985]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:01.985]                   envs[common]]
[11:00:01.985]                 NAMES <- toupper(changed)
[11:00:01.985]                 args <- list()
[11:00:01.985]                 for (kk in seq_along(NAMES)) {
[11:00:01.985]                   name <- changed[[kk]]
[11:00:01.985]                   NAME <- NAMES[[kk]]
[11:00:01.985]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.985]                     next
[11:00:01.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.985]                 }
[11:00:01.985]                 NAMES <- toupper(added)
[11:00:01.985]                 for (kk in seq_along(NAMES)) {
[11:00:01.985]                   name <- added[[kk]]
[11:00:01.985]                   NAME <- NAMES[[kk]]
[11:00:01.985]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.985]                     next
[11:00:01.985]                   args[[name]] <- ""
[11:00:01.985]                 }
[11:00:01.985]                 NAMES <- toupper(removed)
[11:00:01.985]                 for (kk in seq_along(NAMES)) {
[11:00:01.985]                   name <- removed[[kk]]
[11:00:01.985]                   NAME <- NAMES[[kk]]
[11:00:01.985]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:01.985]                     next
[11:00:01.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:01.985]                 }
[11:00:01.985]                 if (length(args) > 0) 
[11:00:01.985]                   base::do.call(base::Sys.setenv, args = args)
[11:00:01.985]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:01.985]             }
[11:00:01.985]             else {
[11:00:01.985]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:01.985]             }
[11:00:01.985]             {
[11:00:01.985]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:01.985]                   0L) {
[11:00:01.985]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:01.985]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:01.985]                   base::options(opts)
[11:00:01.985]                 }
[11:00:01.985]                 {
[11:00:01.985]                   {
[11:00:01.985]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:01.985]                     NULL
[11:00:01.985]                   }
[11:00:01.985]                   options(future.plan = NULL)
[11:00:01.985]                   if (is.na(NA_character_)) 
[11:00:01.985]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:01.985]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:01.985]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:01.985]                     .init = FALSE)
[11:00:01.985]                 }
[11:00:01.985]             }
[11:00:01.985]         }
[11:00:01.985]     })
[11:00:01.985]     if (TRUE) {
[11:00:01.985]         base::sink(type = "output", split = FALSE)
[11:00:01.985]         if (TRUE) {
[11:00:01.985]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:01.985]         }
[11:00:01.985]         else {
[11:00:01.985]             ...future.result["stdout"] <- base::list(NULL)
[11:00:01.985]         }
[11:00:01.985]         base::close(...future.stdout)
[11:00:01.985]         ...future.stdout <- NULL
[11:00:01.985]     }
[11:00:01.985]     ...future.result$conditions <- ...future.conditions
[11:00:01.985]     ...future.result$finished <- base::Sys.time()
[11:00:01.985]     ...future.result
[11:00:01.985] }
[11:00:01.989] assign_globals() ...
[11:00:01.989] List of 11
[11:00:01.989]  $ ...future.FUN            :function (x, ...)  
[11:00:01.989]  $ x_FUN                    :function (x, ...)  
[11:00:01.989]  $ times                    : int 5
[11:00:01.989]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:01.989]  $ stop_if_not              :function (...)  
[11:00:01.989]  $ dim                      : NULL
[11:00:01.989]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:01.989]  $ future.call.arguments    : list()
[11:00:01.989]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:01.989]  $ ...future.elements_ii    :List of 1
[11:00:01.989]   ..$ a: int [1:10] 1 2 3 4 5 6 7 8 9 10
[11:00:01.989]  $ ...future.seeds_ii       : NULL
[11:00:01.989]  $ ...future.globals.maxSize: NULL
[11:00:01.989]  - attr(*, "where")=List of 11
[11:00:01.989]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:01.989]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:01.989]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:01.989]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:01.989]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:01.989]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:01.989]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:01.989]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:01.989]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:01.989]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:01.989]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:01.989]  - attr(*, "resolved")= logi FALSE
[11:00:01.989]  - attr(*, "total_size")= num 24127
[11:00:01.989]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:01.989]  - attr(*, "already-done")= logi TRUE
[11:00:01.997] - copied ‘...future.FUN’ to environment
[11:00:01.997] - copied ‘x_FUN’ to environment
[11:00:01.997] - copied ‘times’ to environment
[11:00:01.997] - copied ‘stopf’ to environment
[11:00:01.997] - copied ‘stop_if_not’ to environment
[11:00:01.997] - copied ‘dim’ to environment
[11:00:01.998] - copied ‘valid_types’ to environment
[11:00:01.998] - copied ‘future.call.arguments’ to environment
[11:00:01.998] - copied ‘...future.elements_ii’ to environment
[11:00:01.998] - copied ‘...future.seeds_ii’ to environment
[11:00:01.998] - copied ‘...future.globals.maxSize’ to environment
[11:00:01.998] assign_globals() ... done
[11:00:01.998] requestCore(): workers = 2
[11:00:02.000] MulticoreFuture started
[11:00:02.001] - Launch lazy future ... done
[11:00:02.001] run() for ‘MulticoreFuture’ ... done
[11:00:02.001] Created future:
[11:00:02.002] plan(): Setting new future strategy stack:
[11:00:02.002] List of future strategies:
[11:00:02.002] 1. sequential:
[11:00:02.002]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:02.002]    - tweaked: FALSE
[11:00:02.002]    - call: NULL
[11:00:02.003] plan(): nbrOfWorkers() = 1
[11:00:02.006] plan(): Setting new future strategy stack:
[11:00:02.006] List of future strategies:
[11:00:02.006] 1. multicore:
[11:00:02.006]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:02.006]    - tweaked: FALSE
[11:00:02.006]    - call: plan(strategy)
[11:00:02.009] plan(): nbrOfWorkers() = 2
[11:00:02.001] MulticoreFuture:
[11:00:02.001] Label: ‘future_vapply-1’
[11:00:02.001] Expression:
[11:00:02.001] {
[11:00:02.001]     do.call(function(...) {
[11:00:02.001]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.001]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.001]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.001]             on.exit(options(oopts), add = TRUE)
[11:00:02.001]         }
[11:00:02.001]         {
[11:00:02.001]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.001]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.001]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.001]             })
[11:00:02.001]         }
[11:00:02.001]     }, args = future.call.arguments)
[11:00:02.001] }
[11:00:02.001] Lazy evaluation: FALSE
[11:00:02.001] Asynchronous evaluation: TRUE
[11:00:02.001] Local evaluation: TRUE
[11:00:02.001] Environment: R_GlobalEnv
[11:00:02.001] Capture standard output: TRUE
[11:00:02.001] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:02.001] Globals: 11 objects totaling 13.35 KiB (function ‘...future.FUN’ of 4.74 KiB, function ‘x_FUN’ of 311 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:02.001] Packages: 2 packages (‘stats’, ‘future.apply’)
[11:00:02.001] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:02.001] Resolved: TRUE
[11:00:02.001] Value: <not collected>
[11:00:02.001] Conditions captured: <none>
[11:00:02.001] Early signaling: FALSE
[11:00:02.001] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:02.001] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.010] Chunk #1 of 2 ... DONE
[11:00:02.010] Chunk #2 of 2 ...
[11:00:02.011]  - Finding globals in 'X' for chunk #2 ...
[11:00:02.011] getGlobalsAndPackages() ...
[11:00:02.011] Searching for globals...
[11:00:02.011] 
[11:00:02.012] Searching for globals ... DONE
[11:00:02.012] - globals: [0] <none>
[11:00:02.012] getGlobalsAndPackages() ... DONE
[11:00:02.012]    + additional globals found: [n=0] 
[11:00:02.012]    + additional namespaces needed: [n=0] 
[11:00:02.012]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:02.012]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:02.012]  - seeds: <none>
[11:00:02.013]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.013] getGlobalsAndPackages() ...
[11:00:02.013] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.013] Resolving globals: FALSE
[11:00:02.013] Tweak future expression to call with '...' arguments ...
[11:00:02.013] {
[11:00:02.013]     do.call(function(...) {
[11:00:02.013]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.013]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.013]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.013]             on.exit(options(oopts), add = TRUE)
[11:00:02.013]         }
[11:00:02.013]         {
[11:00:02.013]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.013]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.013]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.013]             })
[11:00:02.013]         }
[11:00:02.013]     }, args = future.call.arguments)
[11:00:02.013] }
[11:00:02.014] Tweak future expression to call with '...' arguments ... DONE
[11:00:02.015] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.015] - packages: [2] ‘stats’, ‘future.apply’
[11:00:02.015] getGlobalsAndPackages() ... DONE
[11:00:02.016] run() for ‘Future’ ...
[11:00:02.016] - state: ‘created’
[11:00:02.016] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:02.019] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.019] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:02.019]   - Field: ‘label’
[11:00:02.019]   - Field: ‘local’
[11:00:02.019]   - Field: ‘owner’
[11:00:02.019]   - Field: ‘envir’
[11:00:02.019]   - Field: ‘workers’
[11:00:02.020]   - Field: ‘packages’
[11:00:02.020]   - Field: ‘gc’
[11:00:02.020]   - Field: ‘job’
[11:00:02.020]   - Field: ‘conditions’
[11:00:02.020]   - Field: ‘expr’
[11:00:02.020]   - Field: ‘uuid’
[11:00:02.020]   - Field: ‘seed’
[11:00:02.021]   - Field: ‘version’
[11:00:02.021]   - Field: ‘result’
[11:00:02.021]   - Field: ‘asynchronous’
[11:00:02.021]   - Field: ‘calls’
[11:00:02.021]   - Field: ‘globals’
[11:00:02.021]   - Field: ‘stdout’
[11:00:02.021]   - Field: ‘earlySignal’
[11:00:02.022]   - Field: ‘lazy’
[11:00:02.022]   - Field: ‘state’
[11:00:02.022] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:02.022] - Launch lazy future ...
[11:00:02.022] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[11:00:02.022] Packages needed by future strategies (n = 0): <none>
[11:00:02.024] {
[11:00:02.024]     {
[11:00:02.024]         {
[11:00:02.024]             ...future.startTime <- base::Sys.time()
[11:00:02.024]             {
[11:00:02.024]                 {
[11:00:02.024]                   {
[11:00:02.024]                     {
[11:00:02.024]                       {
[11:00:02.024]                         base::local({
[11:00:02.024]                           has_future <- base::requireNamespace("future", 
[11:00:02.024]                             quietly = TRUE)
[11:00:02.024]                           if (has_future) {
[11:00:02.024]                             ns <- base::getNamespace("future")
[11:00:02.024]                             version <- ns[[".package"]][["version"]]
[11:00:02.024]                             if (is.null(version)) 
[11:00:02.024]                               version <- utils::packageVersion("future")
[11:00:02.024]                           }
[11:00:02.024]                           else {
[11:00:02.024]                             version <- NULL
[11:00:02.024]                           }
[11:00:02.024]                           if (!has_future || version < "1.8.0") {
[11:00:02.024]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:02.024]                               "", base::R.version$version.string), 
[11:00:02.024]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:02.024]                                 base::R.version$platform, 8 * 
[11:00:02.024]                                   base::.Machine$sizeof.pointer), 
[11:00:02.024]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:02.024]                                 "release", "version")], collapse = " "), 
[11:00:02.024]                               hostname = base::Sys.info()[["nodename"]])
[11:00:02.024]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:02.024]                               info)
[11:00:02.024]                             info <- base::paste(info, collapse = "; ")
[11:00:02.024]                             if (!has_future) {
[11:00:02.024]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:02.024]                                 info)
[11:00:02.024]                             }
[11:00:02.024]                             else {
[11:00:02.024]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:02.024]                                 info, version)
[11:00:02.024]                             }
[11:00:02.024]                             base::stop(msg)
[11:00:02.024]                           }
[11:00:02.024]                         })
[11:00:02.024]                       }
[11:00:02.024]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:02.024]                       base::options(mc.cores = 1L)
[11:00:02.024]                     }
[11:00:02.024]                     base::local({
[11:00:02.024]                       for (pkg in c("stats", "future.apply")) {
[11:00:02.024]                         base::loadNamespace(pkg)
[11:00:02.024]                         base::library(pkg, character.only = TRUE)
[11:00:02.024]                       }
[11:00:02.024]                     })
[11:00:02.024]                   }
[11:00:02.024]                   ...future.strategy.old <- future::plan("list")
[11:00:02.024]                   options(future.plan = NULL)
[11:00:02.024]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.024]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:02.024]                 }
[11:00:02.024]                 ...future.workdir <- getwd()
[11:00:02.024]             }
[11:00:02.024]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:02.024]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:02.024]         }
[11:00:02.024]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:02.024]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:02.024]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:02.024]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:02.024]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:02.024]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:02.024]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:02.024]             base::names(...future.oldOptions))
[11:00:02.024]     }
[11:00:02.024]     if (FALSE) {
[11:00:02.024]     }
[11:00:02.024]     else {
[11:00:02.024]         if (TRUE) {
[11:00:02.024]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:02.024]                 open = "w")
[11:00:02.024]         }
[11:00:02.024]         else {
[11:00:02.024]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:02.024]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:02.024]         }
[11:00:02.024]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:02.024]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:02.024]             base::sink(type = "output", split = FALSE)
[11:00:02.024]             base::close(...future.stdout)
[11:00:02.024]         }, add = TRUE)
[11:00:02.024]     }
[11:00:02.024]     ...future.frame <- base::sys.nframe()
[11:00:02.024]     ...future.conditions <- base::list()
[11:00:02.024]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:02.024]     if (FALSE) {
[11:00:02.024]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:02.024]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:02.024]     }
[11:00:02.024]     ...future.result <- base::tryCatch({
[11:00:02.024]         base::withCallingHandlers({
[11:00:02.024]             ...future.value <- base::withVisible(base::local({
[11:00:02.024]                 withCallingHandlers({
[11:00:02.024]                   {
[11:00:02.024]                     do.call(function(...) {
[11:00:02.024]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.024]                       if (!identical(...future.globals.maxSize.org, 
[11:00:02.024]                         ...future.globals.maxSize)) {
[11:00:02.024]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.024]                         on.exit(options(oopts), add = TRUE)
[11:00:02.024]                       }
[11:00:02.024]                       {
[11:00:02.024]                         lapply(seq_along(...future.elements_ii), 
[11:00:02.024]                           FUN = function(jj) {
[11:00:02.024]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.024]                             ...future.FUN(...future.X_jj, ...)
[11:00:02.024]                           })
[11:00:02.024]                       }
[11:00:02.024]                     }, args = future.call.arguments)
[11:00:02.024]                   }
[11:00:02.024]                 }, immediateCondition = function(cond) {
[11:00:02.024]                   save_rds <- function (object, pathname, ...) 
[11:00:02.024]                   {
[11:00:02.024]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:02.024]                     if (file_test("-f", pathname_tmp)) {
[11:00:02.024]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.024]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:02.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.024]                         fi_tmp[["mtime"]])
[11:00:02.024]                     }
[11:00:02.024]                     tryCatch({
[11:00:02.024]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:02.024]                     }, error = function(ex) {
[11:00:02.024]                       msg <- conditionMessage(ex)
[11:00:02.024]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.024]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:02.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.024]                         fi_tmp[["mtime"]], msg)
[11:00:02.024]                       ex$message <- msg
[11:00:02.024]                       stop(ex)
[11:00:02.024]                     })
[11:00:02.024]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:02.024]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:02.024]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:02.024]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.024]                       fi <- file.info(pathname)
[11:00:02.024]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:02.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.024]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:02.024]                         fi[["size"]], fi[["mtime"]])
[11:00:02.024]                       stop(msg)
[11:00:02.024]                     }
[11:00:02.024]                     invisible(pathname)
[11:00:02.024]                   }
[11:00:02.024]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:02.024]                     rootPath = tempdir()) 
[11:00:02.024]                   {
[11:00:02.024]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:02.024]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:02.024]                       tmpdir = path, fileext = ".rds")
[11:00:02.024]                     save_rds(obj, file)
[11:00:02.024]                   }
[11:00:02.024]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:02.024]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.024]                   {
[11:00:02.024]                     inherits <- base::inherits
[11:00:02.024]                     invokeRestart <- base::invokeRestart
[11:00:02.024]                     is.null <- base::is.null
[11:00:02.024]                     muffled <- FALSE
[11:00:02.024]                     if (inherits(cond, "message")) {
[11:00:02.024]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:02.024]                       if (muffled) 
[11:00:02.024]                         invokeRestart("muffleMessage")
[11:00:02.024]                     }
[11:00:02.024]                     else if (inherits(cond, "warning")) {
[11:00:02.024]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:02.024]                       if (muffled) 
[11:00:02.024]                         invokeRestart("muffleWarning")
[11:00:02.024]                     }
[11:00:02.024]                     else if (inherits(cond, "condition")) {
[11:00:02.024]                       if (!is.null(pattern)) {
[11:00:02.024]                         computeRestarts <- base::computeRestarts
[11:00:02.024]                         grepl <- base::grepl
[11:00:02.024]                         restarts <- computeRestarts(cond)
[11:00:02.024]                         for (restart in restarts) {
[11:00:02.024]                           name <- restart$name
[11:00:02.024]                           if (is.null(name)) 
[11:00:02.024]                             next
[11:00:02.024]                           if (!grepl(pattern, name)) 
[11:00:02.024]                             next
[11:00:02.024]                           invokeRestart(restart)
[11:00:02.024]                           muffled <- TRUE
[11:00:02.024]                           break
[11:00:02.024]                         }
[11:00:02.024]                       }
[11:00:02.024]                     }
[11:00:02.024]                     invisible(muffled)
[11:00:02.024]                   }
[11:00:02.024]                   muffleCondition(cond)
[11:00:02.024]                 })
[11:00:02.024]             }))
[11:00:02.024]             future::FutureResult(value = ...future.value$value, 
[11:00:02.024]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.024]                   ...future.rng), globalenv = if (FALSE) 
[11:00:02.024]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:02.024]                     ...future.globalenv.names))
[11:00:02.024]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:02.024]         }, condition = base::local({
[11:00:02.024]             c <- base::c
[11:00:02.024]             inherits <- base::inherits
[11:00:02.024]             invokeRestart <- base::invokeRestart
[11:00:02.024]             length <- base::length
[11:00:02.024]             list <- base::list
[11:00:02.024]             seq.int <- base::seq.int
[11:00:02.024]             signalCondition <- base::signalCondition
[11:00:02.024]             sys.calls <- base::sys.calls
[11:00:02.024]             `[[` <- base::`[[`
[11:00:02.024]             `+` <- base::`+`
[11:00:02.024]             `<<-` <- base::`<<-`
[11:00:02.024]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:02.024]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:02.024]                   3L)]
[11:00:02.024]             }
[11:00:02.024]             function(cond) {
[11:00:02.024]                 is_error <- inherits(cond, "error")
[11:00:02.024]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:02.024]                   NULL)
[11:00:02.024]                 if (is_error) {
[11:00:02.024]                   sessionInformation <- function() {
[11:00:02.024]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:02.024]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:02.024]                       search = base::search(), system = base::Sys.info())
[11:00:02.024]                   }
[11:00:02.024]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.024]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:02.024]                     cond$call), session = sessionInformation(), 
[11:00:02.024]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:02.024]                   signalCondition(cond)
[11:00:02.024]                 }
[11:00:02.024]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:02.024]                 "immediateCondition"))) {
[11:00:02.024]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:02.024]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.024]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:02.024]                   if (TRUE && !signal) {
[11:00:02.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.024]                     {
[11:00:02.024]                       inherits <- base::inherits
[11:00:02.024]                       invokeRestart <- base::invokeRestart
[11:00:02.024]                       is.null <- base::is.null
[11:00:02.024]                       muffled <- FALSE
[11:00:02.024]                       if (inherits(cond, "message")) {
[11:00:02.024]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.024]                         if (muffled) 
[11:00:02.024]                           invokeRestart("muffleMessage")
[11:00:02.024]                       }
[11:00:02.024]                       else if (inherits(cond, "warning")) {
[11:00:02.024]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.024]                         if (muffled) 
[11:00:02.024]                           invokeRestart("muffleWarning")
[11:00:02.024]                       }
[11:00:02.024]                       else if (inherits(cond, "condition")) {
[11:00:02.024]                         if (!is.null(pattern)) {
[11:00:02.024]                           computeRestarts <- base::computeRestarts
[11:00:02.024]                           grepl <- base::grepl
[11:00:02.024]                           restarts <- computeRestarts(cond)
[11:00:02.024]                           for (restart in restarts) {
[11:00:02.024]                             name <- restart$name
[11:00:02.024]                             if (is.null(name)) 
[11:00:02.024]                               next
[11:00:02.024]                             if (!grepl(pattern, name)) 
[11:00:02.024]                               next
[11:00:02.024]                             invokeRestart(restart)
[11:00:02.024]                             muffled <- TRUE
[11:00:02.024]                             break
[11:00:02.024]                           }
[11:00:02.024]                         }
[11:00:02.024]                       }
[11:00:02.024]                       invisible(muffled)
[11:00:02.024]                     }
[11:00:02.024]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.024]                   }
[11:00:02.024]                 }
[11:00:02.024]                 else {
[11:00:02.024]                   if (TRUE) {
[11:00:02.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.024]                     {
[11:00:02.024]                       inherits <- base::inherits
[11:00:02.024]                       invokeRestart <- base::invokeRestart
[11:00:02.024]                       is.null <- base::is.null
[11:00:02.024]                       muffled <- FALSE
[11:00:02.024]                       if (inherits(cond, "message")) {
[11:00:02.024]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.024]                         if (muffled) 
[11:00:02.024]                           invokeRestart("muffleMessage")
[11:00:02.024]                       }
[11:00:02.024]                       else if (inherits(cond, "warning")) {
[11:00:02.024]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.024]                         if (muffled) 
[11:00:02.024]                           invokeRestart("muffleWarning")
[11:00:02.024]                       }
[11:00:02.024]                       else if (inherits(cond, "condition")) {
[11:00:02.024]                         if (!is.null(pattern)) {
[11:00:02.024]                           computeRestarts <- base::computeRestarts
[11:00:02.024]                           grepl <- base::grepl
[11:00:02.024]                           restarts <- computeRestarts(cond)
[11:00:02.024]                           for (restart in restarts) {
[11:00:02.024]                             name <- restart$name
[11:00:02.024]                             if (is.null(name)) 
[11:00:02.024]                               next
[11:00:02.024]                             if (!grepl(pattern, name)) 
[11:00:02.024]                               next
[11:00:02.024]                             invokeRestart(restart)
[11:00:02.024]                             muffled <- TRUE
[11:00:02.024]                             break
[11:00:02.024]                           }
[11:00:02.024]                         }
[11:00:02.024]                       }
[11:00:02.024]                       invisible(muffled)
[11:00:02.024]                     }
[11:00:02.024]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.024]                   }
[11:00:02.024]                 }
[11:00:02.024]             }
[11:00:02.024]         }))
[11:00:02.024]     }, error = function(ex) {
[11:00:02.024]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:02.024]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.024]                 ...future.rng), started = ...future.startTime, 
[11:00:02.024]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:02.024]             version = "1.8"), class = "FutureResult")
[11:00:02.024]     }, finally = {
[11:00:02.024]         if (!identical(...future.workdir, getwd())) 
[11:00:02.024]             setwd(...future.workdir)
[11:00:02.024]         {
[11:00:02.024]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:02.024]                 ...future.oldOptions$nwarnings <- NULL
[11:00:02.024]             }
[11:00:02.024]             base::options(...future.oldOptions)
[11:00:02.024]             if (.Platform$OS.type == "windows") {
[11:00:02.024]                 old_names <- names(...future.oldEnvVars)
[11:00:02.024]                 envs <- base::Sys.getenv()
[11:00:02.024]                 names <- names(envs)
[11:00:02.024]                 common <- intersect(names, old_names)
[11:00:02.024]                 added <- setdiff(names, old_names)
[11:00:02.024]                 removed <- setdiff(old_names, names)
[11:00:02.024]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:02.024]                   envs[common]]
[11:00:02.024]                 NAMES <- toupper(changed)
[11:00:02.024]                 args <- list()
[11:00:02.024]                 for (kk in seq_along(NAMES)) {
[11:00:02.024]                   name <- changed[[kk]]
[11:00:02.024]                   NAME <- NAMES[[kk]]
[11:00:02.024]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.024]                     next
[11:00:02.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.024]                 }
[11:00:02.024]                 NAMES <- toupper(added)
[11:00:02.024]                 for (kk in seq_along(NAMES)) {
[11:00:02.024]                   name <- added[[kk]]
[11:00:02.024]                   NAME <- NAMES[[kk]]
[11:00:02.024]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.024]                     next
[11:00:02.024]                   args[[name]] <- ""
[11:00:02.024]                 }
[11:00:02.024]                 NAMES <- toupper(removed)
[11:00:02.024]                 for (kk in seq_along(NAMES)) {
[11:00:02.024]                   name <- removed[[kk]]
[11:00:02.024]                   NAME <- NAMES[[kk]]
[11:00:02.024]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.024]                     next
[11:00:02.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.024]                 }
[11:00:02.024]                 if (length(args) > 0) 
[11:00:02.024]                   base::do.call(base::Sys.setenv, args = args)
[11:00:02.024]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:02.024]             }
[11:00:02.024]             else {
[11:00:02.024]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:02.024]             }
[11:00:02.024]             {
[11:00:02.024]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:02.024]                   0L) {
[11:00:02.024]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:02.024]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:02.024]                   base::options(opts)
[11:00:02.024]                 }
[11:00:02.024]                 {
[11:00:02.024]                   {
[11:00:02.024]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:02.024]                     NULL
[11:00:02.024]                   }
[11:00:02.024]                   options(future.plan = NULL)
[11:00:02.024]                   if (is.na(NA_character_)) 
[11:00:02.024]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.024]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:02.024]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:02.024]                     .init = FALSE)
[11:00:02.024]                 }
[11:00:02.024]             }
[11:00:02.024]         }
[11:00:02.024]     })
[11:00:02.024]     if (TRUE) {
[11:00:02.024]         base::sink(type = "output", split = FALSE)
[11:00:02.024]         if (TRUE) {
[11:00:02.024]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:02.024]         }
[11:00:02.024]         else {
[11:00:02.024]             ...future.result["stdout"] <- base::list(NULL)
[11:00:02.024]         }
[11:00:02.024]         base::close(...future.stdout)
[11:00:02.024]         ...future.stdout <- NULL
[11:00:02.024]     }
[11:00:02.024]     ...future.result$conditions <- ...future.conditions
[11:00:02.024]     ...future.result$finished <- base::Sys.time()
[11:00:02.024]     ...future.result
[11:00:02.024] }
[11:00:02.029] assign_globals() ...
[11:00:02.029] List of 11
[11:00:02.029]  $ ...future.FUN            :function (x, ...)  
[11:00:02.029]  $ x_FUN                    :function (x, ...)  
[11:00:02.029]  $ times                    : int 5
[11:00:02.029]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:02.029]  $ stop_if_not              :function (...)  
[11:00:02.029]  $ dim                      : NULL
[11:00:02.029]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:02.029]  $ future.call.arguments    : list()
[11:00:02.029]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.029]  $ ...future.elements_ii    :List of 2
[11:00:02.029]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[11:00:02.029]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[11:00:02.029]  $ ...future.seeds_ii       : NULL
[11:00:02.029]  $ ...future.globals.maxSize: NULL
[11:00:02.029]  - attr(*, "where")=List of 11
[11:00:02.029]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:02.029]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:02.029]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:02.029]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:02.029]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:02.029]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:02.029]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:02.029]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:02.029]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:02.029]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:02.029]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:02.029]  - attr(*, "resolved")= logi FALSE
[11:00:02.029]  - attr(*, "total_size")= num 24127
[11:00:02.029]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.029]  - attr(*, "already-done")= logi TRUE
[11:00:02.043] - copied ‘...future.FUN’ to environment
[11:00:02.044] - copied ‘x_FUN’ to environment
[11:00:02.044] - copied ‘times’ to environment
[11:00:02.044] - copied ‘stopf’ to environment
[11:00:02.044] - copied ‘stop_if_not’ to environment
[11:00:02.044] - copied ‘dim’ to environment
[11:00:02.044] - copied ‘valid_types’ to environment
[11:00:02.044] - copied ‘future.call.arguments’ to environment
[11:00:02.045] - copied ‘...future.elements_ii’ to environment
[11:00:02.045] - copied ‘...future.seeds_ii’ to environment
[11:00:02.045] - copied ‘...future.globals.maxSize’ to environment
[11:00:02.045] assign_globals() ... done
[11:00:02.045] requestCore(): workers = 2
[11:00:02.047] MulticoreFuture started
[11:00:02.048] - Launch lazy future ... done
[11:00:02.048] run() for ‘MulticoreFuture’ ... done
[11:00:02.048] Created future:
[11:00:02.049] plan(): Setting new future strategy stack:
[11:00:02.049] List of future strategies:
[11:00:02.049] 1. sequential:
[11:00:02.049]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:02.049]    - tweaked: FALSE
[11:00:02.049]    - call: NULL
[11:00:02.050] plan(): nbrOfWorkers() = 1
[11:00:02.053] plan(): Setting new future strategy stack:
[11:00:02.053] List of future strategies:
[11:00:02.053] 1. multicore:
[11:00:02.053]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:02.053]    - tweaked: FALSE
[11:00:02.053]    - call: plan(strategy)
[11:00:02.057] plan(): nbrOfWorkers() = 2
[11:00:02.048] MulticoreFuture:
[11:00:02.048] Label: ‘future_vapply-2’
[11:00:02.048] Expression:
[11:00:02.048] {
[11:00:02.048]     do.call(function(...) {
[11:00:02.048]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.048]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.048]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.048]             on.exit(options(oopts), add = TRUE)
[11:00:02.048]         }
[11:00:02.048]         {
[11:00:02.048]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.048]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.048]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.048]             })
[11:00:02.048]         }
[11:00:02.048]     }, args = future.call.arguments)
[11:00:02.048] }
[11:00:02.048] Lazy evaluation: FALSE
[11:00:02.048] Asynchronous evaluation: TRUE
[11:00:02.048] Local evaluation: TRUE
[11:00:02.048] Environment: R_GlobalEnv
[11:00:02.048] Capture standard output: TRUE
[11:00:02.048] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:02.048] Globals: 11 objects totaling 13.34 KiB (function ‘...future.FUN’ of 4.74 KiB, function ‘x_FUN’ of 311 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:02.048] Packages: 2 packages (‘stats’, ‘future.apply’)
[11:00:02.048] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:02.048] Resolved: TRUE
[11:00:02.048] Value: <not collected>
[11:00:02.048] Conditions captured: <none>
[11:00:02.048] Early signaling: FALSE
[11:00:02.048] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:02.048] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.058] Chunk #2 of 2 ... DONE
[11:00:02.058] Launching 2 futures (chunks) ... DONE
[11:00:02.058] Resolving 2 futures (chunks) ...
[11:00:02.058] resolve() on list ...
[11:00:02.058]  recursive: 0
[11:00:02.058]  length: 2
[11:00:02.059] 
[11:00:02.059] Future #1
[11:00:02.059] result() for MulticoreFuture ...
[11:00:02.060] result() for MulticoreFuture ...
[11:00:02.060] result() for MulticoreFuture ... done
[11:00:02.060] result() for MulticoreFuture ... done
[11:00:02.060] result() for MulticoreFuture ...
[11:00:02.060] result() for MulticoreFuture ... done
[11:00:02.061] signalConditionsASAP(MulticoreFuture, pos=1) ...
[11:00:02.061] - nx: 2
[11:00:02.061] - relay: TRUE
[11:00:02.061] - stdout: TRUE
[11:00:02.061] - signal: TRUE
[11:00:02.061] - resignal: FALSE
[11:00:02.061] - force: TRUE
[11:00:02.061] - relayed: [n=2] FALSE, FALSE
[11:00:02.062] - queued futures: [n=2] FALSE, FALSE
[11:00:02.062]  - until=1
[11:00:02.062]  - relaying element #1
[11:00:02.062] result() for MulticoreFuture ...
[11:00:02.062] result() for MulticoreFuture ... done
[11:00:02.062] result() for MulticoreFuture ...
[11:00:02.062] result() for MulticoreFuture ... done
[11:00:02.063] result() for MulticoreFuture ...
[11:00:02.063] result() for MulticoreFuture ... done
[11:00:02.063] result() for MulticoreFuture ...
[11:00:02.063] result() for MulticoreFuture ... done
[11:00:02.063] - relayed: [n=2] TRUE, FALSE
[11:00:02.063] - queued futures: [n=2] TRUE, FALSE
[11:00:02.063] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[11:00:02.064]  length: 1 (resolved future 1)
[11:00:02.064] Future #2
[11:00:02.064] result() for MulticoreFuture ...
[11:00:02.065] result() for MulticoreFuture ...
[11:00:02.065] result() for MulticoreFuture ... done
[11:00:02.065] result() for MulticoreFuture ... done
[11:00:02.065] result() for MulticoreFuture ...
[11:00:02.065] result() for MulticoreFuture ... done
[11:00:02.066] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:00:02.066] - nx: 2
[11:00:02.066] - relay: TRUE
[11:00:02.066] - stdout: TRUE
[11:00:02.066] - signal: TRUE
[11:00:02.066] - resignal: FALSE
[11:00:02.066] - force: TRUE
[11:00:02.066] - relayed: [n=2] TRUE, FALSE
[11:00:02.067] - queued futures: [n=2] TRUE, FALSE
[11:00:02.067]  - until=2
[11:00:02.067]  - relaying element #2
[11:00:02.067] result() for MulticoreFuture ...
[11:00:02.067] result() for MulticoreFuture ... done
[11:00:02.067] result() for MulticoreFuture ...
[11:00:02.067] result() for MulticoreFuture ... done
[11:00:02.068] result() for MulticoreFuture ...
[11:00:02.068] result() for MulticoreFuture ... done
[11:00:02.068] result() for MulticoreFuture ...
[11:00:02.068] result() for MulticoreFuture ... done
[11:00:02.068] - relayed: [n=2] TRUE, TRUE
[11:00:02.068] - queued futures: [n=2] TRUE, TRUE
[11:00:02.068] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:00:02.068]  length: 0 (resolved future 2)
[11:00:02.069] Relaying remaining futures
[11:00:02.069] signalConditionsASAP(NULL, pos=0) ...
[11:00:02.069] - nx: 2
[11:00:02.069] - relay: TRUE
[11:00:02.069] - stdout: TRUE
[11:00:02.071] - signal: TRUE
[11:00:02.071] - resignal: FALSE
[11:00:02.071] - force: TRUE
[11:00:02.072] - relayed: [n=2] TRUE, TRUE
[11:00:02.072] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:02.072] - relayed: [n=2] TRUE, TRUE
[11:00:02.072] - queued futures: [n=2] TRUE, TRUE
[11:00:02.072] signalConditionsASAP(NULL, pos=0) ... done
[11:00:02.073] resolve() on list ... DONE
[11:00:02.073] result() for MulticoreFuture ...
[11:00:02.073] result() for MulticoreFuture ... done
[11:00:02.073] result() for MulticoreFuture ...
[11:00:02.073] result() for MulticoreFuture ... done
[11:00:02.073] result() for MulticoreFuture ...
[11:00:02.074] result() for MulticoreFuture ... done
[11:00:02.074] result() for MulticoreFuture ...
[11:00:02.074] result() for MulticoreFuture ... done
[11:00:02.074]  - Number of value chunks collected: 2
[11:00:02.074] Resolving 2 futures (chunks) ... DONE
[11:00:02.074] Reducing values from 2 chunks ...
[11:00:02.074]  - Number of values collected after concatenation: 3
[11:00:02.075]  - Number of values expected: 3
[11:00:02.075] Reducing values from 2 chunks ... DONE
[11:00:02.075] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[11:00:02.078] future_lapply() ...
[11:00:02.084] Number of chunks: 2
[11:00:02.085] getGlobalsAndPackagesXApply() ...
[11:00:02.085]  - future.globals: TRUE
[11:00:02.085] getGlobalsAndPackages() ...
[11:00:02.085] Searching for globals...
[11:00:02.090] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[11:00:02.090] Searching for globals ... DONE
[11:00:02.090] Resolving globals: FALSE
[11:00:02.091] The total size of the 1 globals is 4.67 KiB (4777 bytes)
[11:00:02.091] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.67 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.67 KiB of class ‘function’)
[11:00:02.091] - globals: [1] ‘FUN’
[11:00:02.091] - packages: [1] ‘stats’
[11:00:02.091] getGlobalsAndPackages() ... DONE
[11:00:02.092]  - globals found/used: [n=1] ‘FUN’
[11:00:02.092]  - needed namespaces: [n=1] ‘stats’
[11:00:02.092] Finding globals ... DONE
[11:00:02.092]  - use_args: TRUE
[11:00:02.092]  - Getting '...' globals ...
[11:00:02.092] resolve() on list ...
[11:00:02.092]  recursive: 0
[11:00:02.092]  length: 1
[11:00:02.093]  elements: ‘...’
[11:00:02.094]  length: 0 (resolved future 1)
[11:00:02.095] resolve() on list ... DONE
[11:00:02.095]    - '...' content: [n=0] 
[11:00:02.095] List of 1
[11:00:02.095]  $ ...: list()
[11:00:02.095]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.095]  - attr(*, "where")=List of 1
[11:00:02.095]   ..$ ...:<environment: 0x55bbadcea5e8> 
[11:00:02.095]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.095]  - attr(*, "resolved")= logi TRUE
[11:00:02.095]  - attr(*, "total_size")= num NA
[11:00:02.097]  - Getting '...' globals ... DONE
[11:00:02.098] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[11:00:02.098] List of 2
[11:00:02.098]  $ ...future.FUN:function (x, na.rm = TRUE)  
[11:00:02.098]  $ ...          : list()
[11:00:02.098]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.098]  - attr(*, "where")=List of 2
[11:00:02.098]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:02.098]   ..$ ...          :<environment: 0x55bbadcea5e8> 
[11:00:02.098]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.098]  - attr(*, "resolved")= logi FALSE
[11:00:02.098]  - attr(*, "total_size")= num 18895
[11:00:02.101] Packages to be attached in all futures: [n=1] ‘stats’
[11:00:02.101] getGlobalsAndPackagesXApply() ... DONE
[11:00:02.101] Number of futures (= number of chunks): 2
[11:00:02.101] Launching 2 futures (chunks) ...
[11:00:02.101] Chunk #1 of 2 ...
[11:00:02.101]  - Finding globals in 'X' for chunk #1 ...
[11:00:02.101] getGlobalsAndPackages() ...
[11:00:02.101] Searching for globals...
[11:00:02.102] 
[11:00:02.102] Searching for globals ... DONE
[11:00:02.102] - globals: [0] <none>
[11:00:02.102] getGlobalsAndPackages() ... DONE
[11:00:02.102]    + additional globals found: [n=0] 
[11:00:02.102]    + additional namespaces needed: [n=0] 
[11:00:02.102]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:02.102]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:02.102]  - seeds: <none>
[11:00:02.102]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.103] getGlobalsAndPackages() ...
[11:00:02.103] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.103] Resolving globals: FALSE
[11:00:02.103] Tweak future expression to call with '...' arguments ...
[11:00:02.103] {
[11:00:02.103]     do.call(function(...) {
[11:00:02.103]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.103]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.103]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.103]             on.exit(options(oopts), add = TRUE)
[11:00:02.103]         }
[11:00:02.103]         {
[11:00:02.103]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.103]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.103]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.103]             })
[11:00:02.103]         }
[11:00:02.103]     }, args = future.call.arguments)
[11:00:02.103] }
[11:00:02.103] Tweak future expression to call with '...' arguments ... DONE
[11:00:02.104] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.104] - packages: [1] ‘stats’
[11:00:02.104] getGlobalsAndPackages() ... DONE
[11:00:02.104] run() for ‘Future’ ...
[11:00:02.104] - state: ‘created’
[11:00:02.104] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:02.106] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.106] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:02.106]   - Field: ‘label’
[11:00:02.106]   - Field: ‘local’
[11:00:02.106]   - Field: ‘owner’
[11:00:02.107]   - Field: ‘envir’
[11:00:02.107]   - Field: ‘workers’
[11:00:02.107]   - Field: ‘packages’
[11:00:02.107]   - Field: ‘gc’
[11:00:02.107]   - Field: ‘job’
[11:00:02.107]   - Field: ‘conditions’
[11:00:02.107]   - Field: ‘expr’
[11:00:02.107]   - Field: ‘uuid’
[11:00:02.107]   - Field: ‘seed’
[11:00:02.107]   - Field: ‘version’
[11:00:02.107]   - Field: ‘result’
[11:00:02.108]   - Field: ‘asynchronous’
[11:00:02.108]   - Field: ‘calls’
[11:00:02.108]   - Field: ‘globals’
[11:00:02.108]   - Field: ‘stdout’
[11:00:02.108]   - Field: ‘earlySignal’
[11:00:02.108]   - Field: ‘lazy’
[11:00:02.108]   - Field: ‘state’
[11:00:02.108] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:02.108] - Launch lazy future ...
[11:00:02.108] Packages needed by the future expression (n = 1): ‘stats’
[11:00:02.109] Packages needed by future strategies (n = 0): <none>
[11:00:02.109] {
[11:00:02.109]     {
[11:00:02.109]         {
[11:00:02.109]             ...future.startTime <- base::Sys.time()
[11:00:02.109]             {
[11:00:02.109]                 {
[11:00:02.109]                   {
[11:00:02.109]                     {
[11:00:02.109]                       {
[11:00:02.109]                         base::local({
[11:00:02.109]                           has_future <- base::requireNamespace("future", 
[11:00:02.109]                             quietly = TRUE)
[11:00:02.109]                           if (has_future) {
[11:00:02.109]                             ns <- base::getNamespace("future")
[11:00:02.109]                             version <- ns[[".package"]][["version"]]
[11:00:02.109]                             if (is.null(version)) 
[11:00:02.109]                               version <- utils::packageVersion("future")
[11:00:02.109]                           }
[11:00:02.109]                           else {
[11:00:02.109]                             version <- NULL
[11:00:02.109]                           }
[11:00:02.109]                           if (!has_future || version < "1.8.0") {
[11:00:02.109]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:02.109]                               "", base::R.version$version.string), 
[11:00:02.109]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:02.109]                                 base::R.version$platform, 8 * 
[11:00:02.109]                                   base::.Machine$sizeof.pointer), 
[11:00:02.109]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:02.109]                                 "release", "version")], collapse = " "), 
[11:00:02.109]                               hostname = base::Sys.info()[["nodename"]])
[11:00:02.109]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:02.109]                               info)
[11:00:02.109]                             info <- base::paste(info, collapse = "; ")
[11:00:02.109]                             if (!has_future) {
[11:00:02.109]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:02.109]                                 info)
[11:00:02.109]                             }
[11:00:02.109]                             else {
[11:00:02.109]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:02.109]                                 info, version)
[11:00:02.109]                             }
[11:00:02.109]                             base::stop(msg)
[11:00:02.109]                           }
[11:00:02.109]                         })
[11:00:02.109]                       }
[11:00:02.109]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:02.109]                       base::options(mc.cores = 1L)
[11:00:02.109]                     }
[11:00:02.109]                     base::local({
[11:00:02.109]                       for (pkg in "stats") {
[11:00:02.109]                         base::loadNamespace(pkg)
[11:00:02.109]                         base::library(pkg, character.only = TRUE)
[11:00:02.109]                       }
[11:00:02.109]                     })
[11:00:02.109]                   }
[11:00:02.109]                   ...future.strategy.old <- future::plan("list")
[11:00:02.109]                   options(future.plan = NULL)
[11:00:02.109]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.109]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:02.109]                 }
[11:00:02.109]                 ...future.workdir <- getwd()
[11:00:02.109]             }
[11:00:02.109]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:02.109]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:02.109]         }
[11:00:02.109]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:02.109]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:02.109]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:02.109]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:02.109]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:02.109]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:02.109]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:02.109]             base::names(...future.oldOptions))
[11:00:02.109]     }
[11:00:02.109]     if (FALSE) {
[11:00:02.109]     }
[11:00:02.109]     else {
[11:00:02.109]         if (TRUE) {
[11:00:02.109]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:02.109]                 open = "w")
[11:00:02.109]         }
[11:00:02.109]         else {
[11:00:02.109]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:02.109]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:02.109]         }
[11:00:02.109]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:02.109]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:02.109]             base::sink(type = "output", split = FALSE)
[11:00:02.109]             base::close(...future.stdout)
[11:00:02.109]         }, add = TRUE)
[11:00:02.109]     }
[11:00:02.109]     ...future.frame <- base::sys.nframe()
[11:00:02.109]     ...future.conditions <- base::list()
[11:00:02.109]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:02.109]     if (FALSE) {
[11:00:02.109]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:02.109]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:02.109]     }
[11:00:02.109]     ...future.result <- base::tryCatch({
[11:00:02.109]         base::withCallingHandlers({
[11:00:02.109]             ...future.value <- base::withVisible(base::local({
[11:00:02.109]                 withCallingHandlers({
[11:00:02.109]                   {
[11:00:02.109]                     do.call(function(...) {
[11:00:02.109]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.109]                       if (!identical(...future.globals.maxSize.org, 
[11:00:02.109]                         ...future.globals.maxSize)) {
[11:00:02.109]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.109]                         on.exit(options(oopts), add = TRUE)
[11:00:02.109]                       }
[11:00:02.109]                       {
[11:00:02.109]                         lapply(seq_along(...future.elements_ii), 
[11:00:02.109]                           FUN = function(jj) {
[11:00:02.109]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.109]                             ...future.FUN(...future.X_jj, ...)
[11:00:02.109]                           })
[11:00:02.109]                       }
[11:00:02.109]                     }, args = future.call.arguments)
[11:00:02.109]                   }
[11:00:02.109]                 }, immediateCondition = function(cond) {
[11:00:02.109]                   save_rds <- function (object, pathname, ...) 
[11:00:02.109]                   {
[11:00:02.109]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:02.109]                     if (file_test("-f", pathname_tmp)) {
[11:00:02.109]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.109]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:02.109]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.109]                         fi_tmp[["mtime"]])
[11:00:02.109]                     }
[11:00:02.109]                     tryCatch({
[11:00:02.109]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:02.109]                     }, error = function(ex) {
[11:00:02.109]                       msg <- conditionMessage(ex)
[11:00:02.109]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.109]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:02.109]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.109]                         fi_tmp[["mtime"]], msg)
[11:00:02.109]                       ex$message <- msg
[11:00:02.109]                       stop(ex)
[11:00:02.109]                     })
[11:00:02.109]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:02.109]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:02.109]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:02.109]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.109]                       fi <- file.info(pathname)
[11:00:02.109]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:02.109]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.109]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:02.109]                         fi[["size"]], fi[["mtime"]])
[11:00:02.109]                       stop(msg)
[11:00:02.109]                     }
[11:00:02.109]                     invisible(pathname)
[11:00:02.109]                   }
[11:00:02.109]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:02.109]                     rootPath = tempdir()) 
[11:00:02.109]                   {
[11:00:02.109]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:02.109]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:02.109]                       tmpdir = path, fileext = ".rds")
[11:00:02.109]                     save_rds(obj, file)
[11:00:02.109]                   }
[11:00:02.109]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:02.109]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.109]                   {
[11:00:02.109]                     inherits <- base::inherits
[11:00:02.109]                     invokeRestart <- base::invokeRestart
[11:00:02.109]                     is.null <- base::is.null
[11:00:02.109]                     muffled <- FALSE
[11:00:02.109]                     if (inherits(cond, "message")) {
[11:00:02.109]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:02.109]                       if (muffled) 
[11:00:02.109]                         invokeRestart("muffleMessage")
[11:00:02.109]                     }
[11:00:02.109]                     else if (inherits(cond, "warning")) {
[11:00:02.109]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:02.109]                       if (muffled) 
[11:00:02.109]                         invokeRestart("muffleWarning")
[11:00:02.109]                     }
[11:00:02.109]                     else if (inherits(cond, "condition")) {
[11:00:02.109]                       if (!is.null(pattern)) {
[11:00:02.109]                         computeRestarts <- base::computeRestarts
[11:00:02.109]                         grepl <- base::grepl
[11:00:02.109]                         restarts <- computeRestarts(cond)
[11:00:02.109]                         for (restart in restarts) {
[11:00:02.109]                           name <- restart$name
[11:00:02.109]                           if (is.null(name)) 
[11:00:02.109]                             next
[11:00:02.109]                           if (!grepl(pattern, name)) 
[11:00:02.109]                             next
[11:00:02.109]                           invokeRestart(restart)
[11:00:02.109]                           muffled <- TRUE
[11:00:02.109]                           break
[11:00:02.109]                         }
[11:00:02.109]                       }
[11:00:02.109]                     }
[11:00:02.109]                     invisible(muffled)
[11:00:02.109]                   }
[11:00:02.109]                   muffleCondition(cond)
[11:00:02.109]                 })
[11:00:02.109]             }))
[11:00:02.109]             future::FutureResult(value = ...future.value$value, 
[11:00:02.109]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.109]                   ...future.rng), globalenv = if (FALSE) 
[11:00:02.109]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:02.109]                     ...future.globalenv.names))
[11:00:02.109]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:02.109]         }, condition = base::local({
[11:00:02.109]             c <- base::c
[11:00:02.109]             inherits <- base::inherits
[11:00:02.109]             invokeRestart <- base::invokeRestart
[11:00:02.109]             length <- base::length
[11:00:02.109]             list <- base::list
[11:00:02.109]             seq.int <- base::seq.int
[11:00:02.109]             signalCondition <- base::signalCondition
[11:00:02.109]             sys.calls <- base::sys.calls
[11:00:02.109]             `[[` <- base::`[[`
[11:00:02.109]             `+` <- base::`+`
[11:00:02.109]             `<<-` <- base::`<<-`
[11:00:02.109]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:02.109]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:02.109]                   3L)]
[11:00:02.109]             }
[11:00:02.109]             function(cond) {
[11:00:02.109]                 is_error <- inherits(cond, "error")
[11:00:02.109]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:02.109]                   NULL)
[11:00:02.109]                 if (is_error) {
[11:00:02.109]                   sessionInformation <- function() {
[11:00:02.109]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:02.109]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:02.109]                       search = base::search(), system = base::Sys.info())
[11:00:02.109]                   }
[11:00:02.109]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.109]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:02.109]                     cond$call), session = sessionInformation(), 
[11:00:02.109]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:02.109]                   signalCondition(cond)
[11:00:02.109]                 }
[11:00:02.109]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:02.109]                 "immediateCondition"))) {
[11:00:02.109]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:02.109]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.109]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:02.109]                   if (TRUE && !signal) {
[11:00:02.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.109]                     {
[11:00:02.109]                       inherits <- base::inherits
[11:00:02.109]                       invokeRestart <- base::invokeRestart
[11:00:02.109]                       is.null <- base::is.null
[11:00:02.109]                       muffled <- FALSE
[11:00:02.109]                       if (inherits(cond, "message")) {
[11:00:02.109]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.109]                         if (muffled) 
[11:00:02.109]                           invokeRestart("muffleMessage")
[11:00:02.109]                       }
[11:00:02.109]                       else if (inherits(cond, "warning")) {
[11:00:02.109]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.109]                         if (muffled) 
[11:00:02.109]                           invokeRestart("muffleWarning")
[11:00:02.109]                       }
[11:00:02.109]                       else if (inherits(cond, "condition")) {
[11:00:02.109]                         if (!is.null(pattern)) {
[11:00:02.109]                           computeRestarts <- base::computeRestarts
[11:00:02.109]                           grepl <- base::grepl
[11:00:02.109]                           restarts <- computeRestarts(cond)
[11:00:02.109]                           for (restart in restarts) {
[11:00:02.109]                             name <- restart$name
[11:00:02.109]                             if (is.null(name)) 
[11:00:02.109]                               next
[11:00:02.109]                             if (!grepl(pattern, name)) 
[11:00:02.109]                               next
[11:00:02.109]                             invokeRestart(restart)
[11:00:02.109]                             muffled <- TRUE
[11:00:02.109]                             break
[11:00:02.109]                           }
[11:00:02.109]                         }
[11:00:02.109]                       }
[11:00:02.109]                       invisible(muffled)
[11:00:02.109]                     }
[11:00:02.109]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.109]                   }
[11:00:02.109]                 }
[11:00:02.109]                 else {
[11:00:02.109]                   if (TRUE) {
[11:00:02.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.109]                     {
[11:00:02.109]                       inherits <- base::inherits
[11:00:02.109]                       invokeRestart <- base::invokeRestart
[11:00:02.109]                       is.null <- base::is.null
[11:00:02.109]                       muffled <- FALSE
[11:00:02.109]                       if (inherits(cond, "message")) {
[11:00:02.109]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.109]                         if (muffled) 
[11:00:02.109]                           invokeRestart("muffleMessage")
[11:00:02.109]                       }
[11:00:02.109]                       else if (inherits(cond, "warning")) {
[11:00:02.109]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.109]                         if (muffled) 
[11:00:02.109]                           invokeRestart("muffleWarning")
[11:00:02.109]                       }
[11:00:02.109]                       else if (inherits(cond, "condition")) {
[11:00:02.109]                         if (!is.null(pattern)) {
[11:00:02.109]                           computeRestarts <- base::computeRestarts
[11:00:02.109]                           grepl <- base::grepl
[11:00:02.109]                           restarts <- computeRestarts(cond)
[11:00:02.109]                           for (restart in restarts) {
[11:00:02.109]                             name <- restart$name
[11:00:02.109]                             if (is.null(name)) 
[11:00:02.109]                               next
[11:00:02.109]                             if (!grepl(pattern, name)) 
[11:00:02.109]                               next
[11:00:02.109]                             invokeRestart(restart)
[11:00:02.109]                             muffled <- TRUE
[11:00:02.109]                             break
[11:00:02.109]                           }
[11:00:02.109]                         }
[11:00:02.109]                       }
[11:00:02.109]                       invisible(muffled)
[11:00:02.109]                     }
[11:00:02.109]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.109]                   }
[11:00:02.109]                 }
[11:00:02.109]             }
[11:00:02.109]         }))
[11:00:02.109]     }, error = function(ex) {
[11:00:02.109]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:02.109]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.109]                 ...future.rng), started = ...future.startTime, 
[11:00:02.109]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:02.109]             version = "1.8"), class = "FutureResult")
[11:00:02.109]     }, finally = {
[11:00:02.109]         if (!identical(...future.workdir, getwd())) 
[11:00:02.109]             setwd(...future.workdir)
[11:00:02.109]         {
[11:00:02.109]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:02.109]                 ...future.oldOptions$nwarnings <- NULL
[11:00:02.109]             }
[11:00:02.109]             base::options(...future.oldOptions)
[11:00:02.109]             if (.Platform$OS.type == "windows") {
[11:00:02.109]                 old_names <- names(...future.oldEnvVars)
[11:00:02.109]                 envs <- base::Sys.getenv()
[11:00:02.109]                 names <- names(envs)
[11:00:02.109]                 common <- intersect(names, old_names)
[11:00:02.109]                 added <- setdiff(names, old_names)
[11:00:02.109]                 removed <- setdiff(old_names, names)
[11:00:02.109]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:02.109]                   envs[common]]
[11:00:02.109]                 NAMES <- toupper(changed)
[11:00:02.109]                 args <- list()
[11:00:02.109]                 for (kk in seq_along(NAMES)) {
[11:00:02.109]                   name <- changed[[kk]]
[11:00:02.109]                   NAME <- NAMES[[kk]]
[11:00:02.109]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.109]                     next
[11:00:02.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.109]                 }
[11:00:02.109]                 NAMES <- toupper(added)
[11:00:02.109]                 for (kk in seq_along(NAMES)) {
[11:00:02.109]                   name <- added[[kk]]
[11:00:02.109]                   NAME <- NAMES[[kk]]
[11:00:02.109]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.109]                     next
[11:00:02.109]                   args[[name]] <- ""
[11:00:02.109]                 }
[11:00:02.109]                 NAMES <- toupper(removed)
[11:00:02.109]                 for (kk in seq_along(NAMES)) {
[11:00:02.109]                   name <- removed[[kk]]
[11:00:02.109]                   NAME <- NAMES[[kk]]
[11:00:02.109]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.109]                     next
[11:00:02.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.109]                 }
[11:00:02.109]                 if (length(args) > 0) 
[11:00:02.109]                   base::do.call(base::Sys.setenv, args = args)
[11:00:02.109]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:02.109]             }
[11:00:02.109]             else {
[11:00:02.109]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:02.109]             }
[11:00:02.109]             {
[11:00:02.109]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:02.109]                   0L) {
[11:00:02.109]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:02.109]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:02.109]                   base::options(opts)
[11:00:02.109]                 }
[11:00:02.109]                 {
[11:00:02.109]                   {
[11:00:02.109]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:02.109]                     NULL
[11:00:02.109]                   }
[11:00:02.109]                   options(future.plan = NULL)
[11:00:02.109]                   if (is.na(NA_character_)) 
[11:00:02.109]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.109]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:02.109]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:02.109]                     .init = FALSE)
[11:00:02.109]                 }
[11:00:02.109]             }
[11:00:02.109]         }
[11:00:02.109]     })
[11:00:02.109]     if (TRUE) {
[11:00:02.109]         base::sink(type = "output", split = FALSE)
[11:00:02.109]         if (TRUE) {
[11:00:02.109]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:02.109]         }
[11:00:02.109]         else {
[11:00:02.109]             ...future.result["stdout"] <- base::list(NULL)
[11:00:02.109]         }
[11:00:02.109]         base::close(...future.stdout)
[11:00:02.109]         ...future.stdout <- NULL
[11:00:02.109]     }
[11:00:02.109]     ...future.result$conditions <- ...future.conditions
[11:00:02.109]     ...future.result$finished <- base::Sys.time()
[11:00:02.109]     ...future.result
[11:00:02.109] }
[11:00:02.112] assign_globals() ...
[11:00:02.112] List of 5
[11:00:02.112]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[11:00:02.112]  $ future.call.arguments    : list()
[11:00:02.112]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.112]  $ ...future.elements_ii    :List of 4
[11:00:02.112]   ..$ : int [1:3] 1 2 3
[11:00:02.112]   ..$ : int [1:4] 1 2 3 4
[11:00:02.112]   ..$ : int [1:5] 1 2 3 4 5
[11:00:02.112]   ..$ : int [1:6] 1 2 3 4 5 6
[11:00:02.112]  $ ...future.seeds_ii       : NULL
[11:00:02.112]  $ ...future.globals.maxSize: NULL
[11:00:02.112]  - attr(*, "where")=List of 5
[11:00:02.112]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:02.112]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:02.112]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:02.112]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:02.112]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:02.112]  - attr(*, "resolved")= logi FALSE
[11:00:02.112]  - attr(*, "total_size")= num 18895
[11:00:02.112]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.112]  - attr(*, "already-done")= logi TRUE
[11:00:02.119] - copied ‘...future.FUN’ to environment
[11:00:02.119] - copied ‘future.call.arguments’ to environment
[11:00:02.120] - copied ‘...future.elements_ii’ to environment
[11:00:02.120] - copied ‘...future.seeds_ii’ to environment
[11:00:02.120] - copied ‘...future.globals.maxSize’ to environment
[11:00:02.120] assign_globals() ... done
[11:00:02.120] requestCore(): workers = 2
[11:00:02.123] MulticoreFuture started
[11:00:02.123] - Launch lazy future ... done
[11:00:02.124] run() for ‘MulticoreFuture’ ... done
[11:00:02.124] Created future:
[11:00:02.124] plan(): Setting new future strategy stack:
[11:00:02.125] List of future strategies:
[11:00:02.125] 1. sequential:
[11:00:02.125]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:02.125]    - tweaked: FALSE
[11:00:02.125]    - call: NULL
[11:00:02.127] plan(): nbrOfWorkers() = 1
[11:00:02.130] plan(): Setting new future strategy stack:
[11:00:02.130] List of future strategies:
[11:00:02.130] 1. multicore:
[11:00:02.130]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:02.130]    - tweaked: FALSE
[11:00:02.130]    - call: plan(strategy)
[11:00:02.135] plan(): nbrOfWorkers() = 2
[11:00:02.124] MulticoreFuture:
[11:00:02.124] Label: ‘future_sapply-1’
[11:00:02.124] Expression:
[11:00:02.124] {
[11:00:02.124]     do.call(function(...) {
[11:00:02.124]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.124]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.124]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.124]             on.exit(options(oopts), add = TRUE)
[11:00:02.124]         }
[11:00:02.124]         {
[11:00:02.124]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.124]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.124]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.124]             })
[11:00:02.124]         }
[11:00:02.124]     }, args = future.call.arguments)
[11:00:02.124] }
[11:00:02.124] Lazy evaluation: FALSE
[11:00:02.124] Asynchronous evaluation: TRUE
[11:00:02.124] Local evaluation: TRUE
[11:00:02.124] Environment: R_GlobalEnv
[11:00:02.124] Capture standard output: TRUE
[11:00:02.124] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:02.124] Globals: 5 objects totaling 5.17 KiB (function ‘...future.FUN’ of 4.67 KiB, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 369 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:02.124] Packages: 1 packages (‘stats’)
[11:00:02.124] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:02.124] Resolved: TRUE
[11:00:02.124] Value: <not collected>
[11:00:02.124] Conditions captured: <none>
[11:00:02.124] Early signaling: FALSE
[11:00:02.124] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:02.124] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.136] Chunk #1 of 2 ... DONE
[11:00:02.137] Chunk #2 of 2 ...
[11:00:02.137]  - Finding globals in 'X' for chunk #2 ...
[11:00:02.137] getGlobalsAndPackages() ...
[11:00:02.137] Searching for globals...
[11:00:02.138] 
[11:00:02.138] Searching for globals ... DONE
[11:00:02.138] - globals: [0] <none>
[11:00:02.138] getGlobalsAndPackages() ... DONE
[11:00:02.139]    + additional globals found: [n=0] 
[11:00:02.139]    + additional namespaces needed: [n=0] 
[11:00:02.139]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:02.139]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:02.139]  - seeds: <none>
[11:00:02.140]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.140] getGlobalsAndPackages() ...
[11:00:02.140] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.140] Resolving globals: FALSE
[11:00:02.140] Tweak future expression to call with '...' arguments ...
[11:00:02.140] {
[11:00:02.140]     do.call(function(...) {
[11:00:02.140]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.140]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.140]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.140]             on.exit(options(oopts), add = TRUE)
[11:00:02.140]         }
[11:00:02.140]         {
[11:00:02.140]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.140]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.140]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.140]             })
[11:00:02.140]         }
[11:00:02.140]     }, args = future.call.arguments)
[11:00:02.140] }
[11:00:02.141] Tweak future expression to call with '...' arguments ... DONE
[11:00:02.141] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.142] - packages: [1] ‘stats’
[11:00:02.142] getGlobalsAndPackages() ... DONE
[11:00:02.142] run() for ‘Future’ ...
[11:00:02.142] - state: ‘created’
[11:00:02.143] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:02.145] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.146] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:02.146]   - Field: ‘label’
[11:00:02.146]   - Field: ‘local’
[11:00:02.146]   - Field: ‘owner’
[11:00:02.146]   - Field: ‘envir’
[11:00:02.146]   - Field: ‘workers’
[11:00:02.147]   - Field: ‘packages’
[11:00:02.147]   - Field: ‘gc’
[11:00:02.147]   - Field: ‘job’
[11:00:02.147]   - Field: ‘conditions’
[11:00:02.147]   - Field: ‘expr’
[11:00:02.147]   - Field: ‘uuid’
[11:00:02.147]   - Field: ‘seed’
[11:00:02.147]   - Field: ‘version’
[11:00:02.148]   - Field: ‘result’
[11:00:02.148]   - Field: ‘asynchronous’
[11:00:02.148]   - Field: ‘calls’
[11:00:02.148]   - Field: ‘globals’
[11:00:02.148]   - Field: ‘stdout’
[11:00:02.148]   - Field: ‘earlySignal’
[11:00:02.148]   - Field: ‘lazy’
[11:00:02.149]   - Field: ‘state’
[11:00:02.149] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:02.149] - Launch lazy future ...
[11:00:02.149] Packages needed by the future expression (n = 1): ‘stats’
[11:00:02.149] Packages needed by future strategies (n = 0): <none>
[11:00:02.150] {
[11:00:02.150]     {
[11:00:02.150]         {
[11:00:02.150]             ...future.startTime <- base::Sys.time()
[11:00:02.150]             {
[11:00:02.150]                 {
[11:00:02.150]                   {
[11:00:02.150]                     {
[11:00:02.150]                       {
[11:00:02.150]                         base::local({
[11:00:02.150]                           has_future <- base::requireNamespace("future", 
[11:00:02.150]                             quietly = TRUE)
[11:00:02.150]                           if (has_future) {
[11:00:02.150]                             ns <- base::getNamespace("future")
[11:00:02.150]                             version <- ns[[".package"]][["version"]]
[11:00:02.150]                             if (is.null(version)) 
[11:00:02.150]                               version <- utils::packageVersion("future")
[11:00:02.150]                           }
[11:00:02.150]                           else {
[11:00:02.150]                             version <- NULL
[11:00:02.150]                           }
[11:00:02.150]                           if (!has_future || version < "1.8.0") {
[11:00:02.150]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:02.150]                               "", base::R.version$version.string), 
[11:00:02.150]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:02.150]                                 base::R.version$platform, 8 * 
[11:00:02.150]                                   base::.Machine$sizeof.pointer), 
[11:00:02.150]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:02.150]                                 "release", "version")], collapse = " "), 
[11:00:02.150]                               hostname = base::Sys.info()[["nodename"]])
[11:00:02.150]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:02.150]                               info)
[11:00:02.150]                             info <- base::paste(info, collapse = "; ")
[11:00:02.150]                             if (!has_future) {
[11:00:02.150]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:02.150]                                 info)
[11:00:02.150]                             }
[11:00:02.150]                             else {
[11:00:02.150]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:02.150]                                 info, version)
[11:00:02.150]                             }
[11:00:02.150]                             base::stop(msg)
[11:00:02.150]                           }
[11:00:02.150]                         })
[11:00:02.150]                       }
[11:00:02.150]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:02.150]                       base::options(mc.cores = 1L)
[11:00:02.150]                     }
[11:00:02.150]                     base::local({
[11:00:02.150]                       for (pkg in "stats") {
[11:00:02.150]                         base::loadNamespace(pkg)
[11:00:02.150]                         base::library(pkg, character.only = TRUE)
[11:00:02.150]                       }
[11:00:02.150]                     })
[11:00:02.150]                   }
[11:00:02.150]                   ...future.strategy.old <- future::plan("list")
[11:00:02.150]                   options(future.plan = NULL)
[11:00:02.150]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.150]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:02.150]                 }
[11:00:02.150]                 ...future.workdir <- getwd()
[11:00:02.150]             }
[11:00:02.150]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:02.150]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:02.150]         }
[11:00:02.150]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:02.150]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:02.150]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:02.150]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:02.150]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:02.150]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:02.150]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:02.150]             base::names(...future.oldOptions))
[11:00:02.150]     }
[11:00:02.150]     if (FALSE) {
[11:00:02.150]     }
[11:00:02.150]     else {
[11:00:02.150]         if (TRUE) {
[11:00:02.150]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:02.150]                 open = "w")
[11:00:02.150]         }
[11:00:02.150]         else {
[11:00:02.150]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:02.150]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:02.150]         }
[11:00:02.150]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:02.150]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:02.150]             base::sink(type = "output", split = FALSE)
[11:00:02.150]             base::close(...future.stdout)
[11:00:02.150]         }, add = TRUE)
[11:00:02.150]     }
[11:00:02.150]     ...future.frame <- base::sys.nframe()
[11:00:02.150]     ...future.conditions <- base::list()
[11:00:02.150]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:02.150]     if (FALSE) {
[11:00:02.150]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:02.150]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:02.150]     }
[11:00:02.150]     ...future.result <- base::tryCatch({
[11:00:02.150]         base::withCallingHandlers({
[11:00:02.150]             ...future.value <- base::withVisible(base::local({
[11:00:02.150]                 withCallingHandlers({
[11:00:02.150]                   {
[11:00:02.150]                     do.call(function(...) {
[11:00:02.150]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.150]                       if (!identical(...future.globals.maxSize.org, 
[11:00:02.150]                         ...future.globals.maxSize)) {
[11:00:02.150]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.150]                         on.exit(options(oopts), add = TRUE)
[11:00:02.150]                       }
[11:00:02.150]                       {
[11:00:02.150]                         lapply(seq_along(...future.elements_ii), 
[11:00:02.150]                           FUN = function(jj) {
[11:00:02.150]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.150]                             ...future.FUN(...future.X_jj, ...)
[11:00:02.150]                           })
[11:00:02.150]                       }
[11:00:02.150]                     }, args = future.call.arguments)
[11:00:02.150]                   }
[11:00:02.150]                 }, immediateCondition = function(cond) {
[11:00:02.150]                   save_rds <- function (object, pathname, ...) 
[11:00:02.150]                   {
[11:00:02.150]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:02.150]                     if (file_test("-f", pathname_tmp)) {
[11:00:02.150]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.150]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:02.150]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.150]                         fi_tmp[["mtime"]])
[11:00:02.150]                     }
[11:00:02.150]                     tryCatch({
[11:00:02.150]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:02.150]                     }, error = function(ex) {
[11:00:02.150]                       msg <- conditionMessage(ex)
[11:00:02.150]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.150]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:02.150]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.150]                         fi_tmp[["mtime"]], msg)
[11:00:02.150]                       ex$message <- msg
[11:00:02.150]                       stop(ex)
[11:00:02.150]                     })
[11:00:02.150]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:02.150]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:02.150]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:02.150]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.150]                       fi <- file.info(pathname)
[11:00:02.150]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:02.150]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.150]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:02.150]                         fi[["size"]], fi[["mtime"]])
[11:00:02.150]                       stop(msg)
[11:00:02.150]                     }
[11:00:02.150]                     invisible(pathname)
[11:00:02.150]                   }
[11:00:02.150]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:02.150]                     rootPath = tempdir()) 
[11:00:02.150]                   {
[11:00:02.150]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:02.150]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:02.150]                       tmpdir = path, fileext = ".rds")
[11:00:02.150]                     save_rds(obj, file)
[11:00:02.150]                   }
[11:00:02.150]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:02.150]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.150]                   {
[11:00:02.150]                     inherits <- base::inherits
[11:00:02.150]                     invokeRestart <- base::invokeRestart
[11:00:02.150]                     is.null <- base::is.null
[11:00:02.150]                     muffled <- FALSE
[11:00:02.150]                     if (inherits(cond, "message")) {
[11:00:02.150]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:02.150]                       if (muffled) 
[11:00:02.150]                         invokeRestart("muffleMessage")
[11:00:02.150]                     }
[11:00:02.150]                     else if (inherits(cond, "warning")) {
[11:00:02.150]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:02.150]                       if (muffled) 
[11:00:02.150]                         invokeRestart("muffleWarning")
[11:00:02.150]                     }
[11:00:02.150]                     else if (inherits(cond, "condition")) {
[11:00:02.150]                       if (!is.null(pattern)) {
[11:00:02.150]                         computeRestarts <- base::computeRestarts
[11:00:02.150]                         grepl <- base::grepl
[11:00:02.150]                         restarts <- computeRestarts(cond)
[11:00:02.150]                         for (restart in restarts) {
[11:00:02.150]                           name <- restart$name
[11:00:02.150]                           if (is.null(name)) 
[11:00:02.150]                             next
[11:00:02.150]                           if (!grepl(pattern, name)) 
[11:00:02.150]                             next
[11:00:02.150]                           invokeRestart(restart)
[11:00:02.150]                           muffled <- TRUE
[11:00:02.150]                           break
[11:00:02.150]                         }
[11:00:02.150]                       }
[11:00:02.150]                     }
[11:00:02.150]                     invisible(muffled)
[11:00:02.150]                   }
[11:00:02.150]                   muffleCondition(cond)
[11:00:02.150]                 })
[11:00:02.150]             }))
[11:00:02.150]             future::FutureResult(value = ...future.value$value, 
[11:00:02.150]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.150]                   ...future.rng), globalenv = if (FALSE) 
[11:00:02.150]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:02.150]                     ...future.globalenv.names))
[11:00:02.150]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:02.150]         }, condition = base::local({
[11:00:02.150]             c <- base::c
[11:00:02.150]             inherits <- base::inherits
[11:00:02.150]             invokeRestart <- base::invokeRestart
[11:00:02.150]             length <- base::length
[11:00:02.150]             list <- base::list
[11:00:02.150]             seq.int <- base::seq.int
[11:00:02.150]             signalCondition <- base::signalCondition
[11:00:02.150]             sys.calls <- base::sys.calls
[11:00:02.150]             `[[` <- base::`[[`
[11:00:02.150]             `+` <- base::`+`
[11:00:02.150]             `<<-` <- base::`<<-`
[11:00:02.150]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:02.150]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:02.150]                   3L)]
[11:00:02.150]             }
[11:00:02.150]             function(cond) {
[11:00:02.150]                 is_error <- inherits(cond, "error")
[11:00:02.150]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:02.150]                   NULL)
[11:00:02.150]                 if (is_error) {
[11:00:02.150]                   sessionInformation <- function() {
[11:00:02.150]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:02.150]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:02.150]                       search = base::search(), system = base::Sys.info())
[11:00:02.150]                   }
[11:00:02.150]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.150]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:02.150]                     cond$call), session = sessionInformation(), 
[11:00:02.150]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:02.150]                   signalCondition(cond)
[11:00:02.150]                 }
[11:00:02.150]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:02.150]                 "immediateCondition"))) {
[11:00:02.150]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:02.150]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.150]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:02.150]                   if (TRUE && !signal) {
[11:00:02.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.150]                     {
[11:00:02.150]                       inherits <- base::inherits
[11:00:02.150]                       invokeRestart <- base::invokeRestart
[11:00:02.150]                       is.null <- base::is.null
[11:00:02.150]                       muffled <- FALSE
[11:00:02.150]                       if (inherits(cond, "message")) {
[11:00:02.150]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.150]                         if (muffled) 
[11:00:02.150]                           invokeRestart("muffleMessage")
[11:00:02.150]                       }
[11:00:02.150]                       else if (inherits(cond, "warning")) {
[11:00:02.150]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.150]                         if (muffled) 
[11:00:02.150]                           invokeRestart("muffleWarning")
[11:00:02.150]                       }
[11:00:02.150]                       else if (inherits(cond, "condition")) {
[11:00:02.150]                         if (!is.null(pattern)) {
[11:00:02.150]                           computeRestarts <- base::computeRestarts
[11:00:02.150]                           grepl <- base::grepl
[11:00:02.150]                           restarts <- computeRestarts(cond)
[11:00:02.150]                           for (restart in restarts) {
[11:00:02.150]                             name <- restart$name
[11:00:02.150]                             if (is.null(name)) 
[11:00:02.150]                               next
[11:00:02.150]                             if (!grepl(pattern, name)) 
[11:00:02.150]                               next
[11:00:02.150]                             invokeRestart(restart)
[11:00:02.150]                             muffled <- TRUE
[11:00:02.150]                             break
[11:00:02.150]                           }
[11:00:02.150]                         }
[11:00:02.150]                       }
[11:00:02.150]                       invisible(muffled)
[11:00:02.150]                     }
[11:00:02.150]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.150]                   }
[11:00:02.150]                 }
[11:00:02.150]                 else {
[11:00:02.150]                   if (TRUE) {
[11:00:02.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.150]                     {
[11:00:02.150]                       inherits <- base::inherits
[11:00:02.150]                       invokeRestart <- base::invokeRestart
[11:00:02.150]                       is.null <- base::is.null
[11:00:02.150]                       muffled <- FALSE
[11:00:02.150]                       if (inherits(cond, "message")) {
[11:00:02.150]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.150]                         if (muffled) 
[11:00:02.150]                           invokeRestart("muffleMessage")
[11:00:02.150]                       }
[11:00:02.150]                       else if (inherits(cond, "warning")) {
[11:00:02.150]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.150]                         if (muffled) 
[11:00:02.150]                           invokeRestart("muffleWarning")
[11:00:02.150]                       }
[11:00:02.150]                       else if (inherits(cond, "condition")) {
[11:00:02.150]                         if (!is.null(pattern)) {
[11:00:02.150]                           computeRestarts <- base::computeRestarts
[11:00:02.150]                           grepl <- base::grepl
[11:00:02.150]                           restarts <- computeRestarts(cond)
[11:00:02.150]                           for (restart in restarts) {
[11:00:02.150]                             name <- restart$name
[11:00:02.150]                             if (is.null(name)) 
[11:00:02.150]                               next
[11:00:02.150]                             if (!grepl(pattern, name)) 
[11:00:02.150]                               next
[11:00:02.150]                             invokeRestart(restart)
[11:00:02.150]                             muffled <- TRUE
[11:00:02.150]                             break
[11:00:02.150]                           }
[11:00:02.150]                         }
[11:00:02.150]                       }
[11:00:02.150]                       invisible(muffled)
[11:00:02.150]                     }
[11:00:02.150]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.150]                   }
[11:00:02.150]                 }
[11:00:02.150]             }
[11:00:02.150]         }))
[11:00:02.150]     }, error = function(ex) {
[11:00:02.150]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:02.150]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.150]                 ...future.rng), started = ...future.startTime, 
[11:00:02.150]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:02.150]             version = "1.8"), class = "FutureResult")
[11:00:02.150]     }, finally = {
[11:00:02.150]         if (!identical(...future.workdir, getwd())) 
[11:00:02.150]             setwd(...future.workdir)
[11:00:02.150]         {
[11:00:02.150]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:02.150]                 ...future.oldOptions$nwarnings <- NULL
[11:00:02.150]             }
[11:00:02.150]             base::options(...future.oldOptions)
[11:00:02.150]             if (.Platform$OS.type == "windows") {
[11:00:02.150]                 old_names <- names(...future.oldEnvVars)
[11:00:02.150]                 envs <- base::Sys.getenv()
[11:00:02.150]                 names <- names(envs)
[11:00:02.150]                 common <- intersect(names, old_names)
[11:00:02.150]                 added <- setdiff(names, old_names)
[11:00:02.150]                 removed <- setdiff(old_names, names)
[11:00:02.150]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:02.150]                   envs[common]]
[11:00:02.150]                 NAMES <- toupper(changed)
[11:00:02.150]                 args <- list()
[11:00:02.150]                 for (kk in seq_along(NAMES)) {
[11:00:02.150]                   name <- changed[[kk]]
[11:00:02.150]                   NAME <- NAMES[[kk]]
[11:00:02.150]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.150]                     next
[11:00:02.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.150]                 }
[11:00:02.150]                 NAMES <- toupper(added)
[11:00:02.150]                 for (kk in seq_along(NAMES)) {
[11:00:02.150]                   name <- added[[kk]]
[11:00:02.150]                   NAME <- NAMES[[kk]]
[11:00:02.150]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.150]                     next
[11:00:02.150]                   args[[name]] <- ""
[11:00:02.150]                 }
[11:00:02.150]                 NAMES <- toupper(removed)
[11:00:02.150]                 for (kk in seq_along(NAMES)) {
[11:00:02.150]                   name <- removed[[kk]]
[11:00:02.150]                   NAME <- NAMES[[kk]]
[11:00:02.150]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.150]                     next
[11:00:02.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.150]                 }
[11:00:02.150]                 if (length(args) > 0) 
[11:00:02.150]                   base::do.call(base::Sys.setenv, args = args)
[11:00:02.150]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:02.150]             }
[11:00:02.150]             else {
[11:00:02.150]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:02.150]             }
[11:00:02.150]             {
[11:00:02.150]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:02.150]                   0L) {
[11:00:02.150]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:02.150]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:02.150]                   base::options(opts)
[11:00:02.150]                 }
[11:00:02.150]                 {
[11:00:02.150]                   {
[11:00:02.150]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:02.150]                     NULL
[11:00:02.150]                   }
[11:00:02.150]                   options(future.plan = NULL)
[11:00:02.150]                   if (is.na(NA_character_)) 
[11:00:02.150]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.150]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:02.150]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:02.150]                     .init = FALSE)
[11:00:02.150]                 }
[11:00:02.150]             }
[11:00:02.150]         }
[11:00:02.150]     })
[11:00:02.150]     if (TRUE) {
[11:00:02.150]         base::sink(type = "output", split = FALSE)
[11:00:02.150]         if (TRUE) {
[11:00:02.150]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:02.150]         }
[11:00:02.150]         else {
[11:00:02.150]             ...future.result["stdout"] <- base::list(NULL)
[11:00:02.150]         }
[11:00:02.150]         base::close(...future.stdout)
[11:00:02.150]         ...future.stdout <- NULL
[11:00:02.150]     }
[11:00:02.150]     ...future.result$conditions <- ...future.conditions
[11:00:02.150]     ...future.result$finished <- base::Sys.time()
[11:00:02.150]     ...future.result
[11:00:02.150] }
[11:00:02.154] assign_globals() ...
[11:00:02.154] List of 5
[11:00:02.154]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[11:00:02.154]  $ future.call.arguments    : list()
[11:00:02.154]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.154]  $ ...future.elements_ii    :List of 3
[11:00:02.154]   ..$ : int [1:7] 1 2 3 4 5 6 7
[11:00:02.154]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[11:00:02.154]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[11:00:02.154]  $ ...future.seeds_ii       : NULL
[11:00:02.154]  $ ...future.globals.maxSize: NULL
[11:00:02.154]  - attr(*, "where")=List of 5
[11:00:02.154]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:02.154]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:02.154]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:02.154]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:02.154]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:02.154]  - attr(*, "resolved")= logi FALSE
[11:00:02.154]  - attr(*, "total_size")= num 18895
[11:00:02.154]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.154]  - attr(*, "already-done")= logi TRUE
[11:00:02.161] - copied ‘...future.FUN’ to environment
[11:00:02.161] - copied ‘future.call.arguments’ to environment
[11:00:02.161] - copied ‘...future.elements_ii’ to environment
[11:00:02.161] - copied ‘...future.seeds_ii’ to environment
[11:00:02.161] - copied ‘...future.globals.maxSize’ to environment
[11:00:02.161] assign_globals() ... done
[11:00:02.161] requestCore(): workers = 2
[11:00:02.164] MulticoreFuture started
[11:00:02.164] - Launch lazy future ... done
[11:00:02.164] run() for ‘MulticoreFuture’ ... done
[11:00:02.165] Created future:
[11:00:02.165] plan(): Setting new future strategy stack:
[11:00:02.165] List of future strategies:
[11:00:02.165] 1. sequential:
[11:00:02.165]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:02.165]    - tweaked: FALSE
[11:00:02.165]    - call: NULL
[11:00:02.170] plan(): nbrOfWorkers() = 1
[11:00:02.174] plan(): Setting new future strategy stack:
[11:00:02.174] List of future strategies:
[11:00:02.174] 1. multicore:
[11:00:02.174]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:02.174]    - tweaked: FALSE
[11:00:02.174]    - call: plan(strategy)
[11:00:02.178] plan(): nbrOfWorkers() = 2
[11:00:02.165] MulticoreFuture:
[11:00:02.165] Label: ‘future_sapply-2’
[11:00:02.165] Expression:
[11:00:02.165] {
[11:00:02.165]     do.call(function(...) {
[11:00:02.165]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.165]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.165]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.165]             on.exit(options(oopts), add = TRUE)
[11:00:02.165]         }
[11:00:02.165]         {
[11:00:02.165]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.165]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.165]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.165]             })
[11:00:02.165]         }
[11:00:02.165]     }, args = future.call.arguments)
[11:00:02.165] }
[11:00:02.165] Lazy evaluation: FALSE
[11:00:02.165] Asynchronous evaluation: TRUE
[11:00:02.165] Local evaluation: TRUE
[11:00:02.165] Environment: R_GlobalEnv
[11:00:02.165] Capture standard output: TRUE
[11:00:02.165] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:02.165] Globals: 5 objects totaling 5.10 KiB (function ‘...future.FUN’ of 4.67 KiB, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 293 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:02.165] Packages: 1 packages (‘stats’)
[11:00:02.165] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:02.165] Resolved: TRUE
[11:00:02.165] Value: <not collected>
[11:00:02.165] Conditions captured: <none>
[11:00:02.165] Early signaling: FALSE
[11:00:02.165] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:02.165] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.180] Chunk #2 of 2 ... DONE
[11:00:02.180] Launching 2 futures (chunks) ... DONE
[11:00:02.180] Resolving 2 futures (chunks) ...
[11:00:02.181] resolve() on list ...
[11:00:02.181]  recursive: 0
[11:00:02.181]  length: 2
[11:00:02.181] 
[11:00:02.182] Future #1
[11:00:02.182] result() for MulticoreFuture ...
[11:00:02.183] result() for MulticoreFuture ...
[11:00:02.183] result() for MulticoreFuture ... done
[11:00:02.183] result() for MulticoreFuture ... done
[11:00:02.183] result() for MulticoreFuture ...
[11:00:02.184] result() for MulticoreFuture ... done
[11:00:02.184] signalConditionsASAP(MulticoreFuture, pos=1) ...
[11:00:02.184] - nx: 2
[11:00:02.184] - relay: TRUE
[11:00:02.185] - stdout: TRUE
[11:00:02.185] - signal: TRUE
[11:00:02.185] - resignal: FALSE
[11:00:02.185] - force: TRUE
[11:00:02.185] - relayed: [n=2] FALSE, FALSE
[11:00:02.186] - queued futures: [n=2] FALSE, FALSE
[11:00:02.186]  - until=1
[11:00:02.186]  - relaying element #1
[11:00:02.186] result() for MulticoreFuture ...
[11:00:02.187] result() for MulticoreFuture ... done
[11:00:02.187] result() for MulticoreFuture ...
[11:00:02.187] result() for MulticoreFuture ... done
[11:00:02.188] result() for MulticoreFuture ...
[11:00:02.188] result() for MulticoreFuture ... done
[11:00:02.188] result() for MulticoreFuture ...
[11:00:02.188] result() for MulticoreFuture ... done
[11:00:02.188] - relayed: [n=2] TRUE, FALSE
[11:00:02.189] - queued futures: [n=2] TRUE, FALSE
[11:00:02.189] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[11:00:02.189]  length: 1 (resolved future 1)
[11:00:02.189] Future #2
[11:00:02.190] result() for MulticoreFuture ...
[11:00:02.190] result() for MulticoreFuture ...
[11:00:02.191] result() for MulticoreFuture ... done
[11:00:02.191] result() for MulticoreFuture ... done
[11:00:02.191] result() for MulticoreFuture ...
[11:00:02.191] result() for MulticoreFuture ... done
[11:00:02.191] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:00:02.191] - nx: 2
[11:00:02.191] - relay: TRUE
[11:00:02.191] - stdout: TRUE
[11:00:02.192] - signal: TRUE
[11:00:02.192] - resignal: FALSE
[11:00:02.192] - force: TRUE
[11:00:02.192] - relayed: [n=2] TRUE, FALSE
[11:00:02.192] - queued futures: [n=2] TRUE, FALSE
[11:00:02.192]  - until=2
[11:00:02.192]  - relaying element #2
[11:00:02.192] result() for MulticoreFuture ...
[11:00:02.192] result() for MulticoreFuture ... done
[11:00:02.193] result() for MulticoreFuture ...
[11:00:02.193] result() for MulticoreFuture ... done
[11:00:02.193] result() for MulticoreFuture ...
[11:00:02.193] result() for MulticoreFuture ... done
[11:00:02.193] result() for MulticoreFuture ...
[11:00:02.193] result() for MulticoreFuture ... done
[11:00:02.193] - relayed: [n=2] TRUE, TRUE
[11:00:02.193] - queued futures: [n=2] TRUE, TRUE
[11:00:02.194] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:00:02.194]  length: 0 (resolved future 2)
[11:00:02.194] Relaying remaining futures
[11:00:02.194] signalConditionsASAP(NULL, pos=0) ...
[11:00:02.194] - nx: 2
[11:00:02.194] - relay: TRUE
[11:00:02.194] - stdout: TRUE
[11:00:02.194] - signal: TRUE
[11:00:02.194] - resignal: FALSE
[11:00:02.194] - force: TRUE
[11:00:02.195] - relayed: [n=2] TRUE, TRUE
[11:00:02.195] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:02.195] - relayed: [n=2] TRUE, TRUE
[11:00:02.195] - queued futures: [n=2] TRUE, TRUE
[11:00:02.195] signalConditionsASAP(NULL, pos=0) ... done
[11:00:02.195] resolve() on list ... DONE
[11:00:02.195] result() for MulticoreFuture ...
[11:00:02.195] result() for MulticoreFuture ... done
[11:00:02.195] result() for MulticoreFuture ...
[11:00:02.196] result() for MulticoreFuture ... done
[11:00:02.196] result() for MulticoreFuture ...
[11:00:02.196] result() for MulticoreFuture ... done
[11:00:02.196] result() for MulticoreFuture ...
[11:00:02.196] result() for MulticoreFuture ... done
[11:00:02.196]  - Number of value chunks collected: 2
[11:00:02.196] Resolving 2 futures (chunks) ... DONE
[11:00:02.196] Reducing values from 2 chunks ...
[11:00:02.196]  - Number of values collected after concatenation: 7
[11:00:02.196]  - Number of values expected: 7
[11:00:02.197] Reducing values from 2 chunks ... DONE
[11:00:02.197] future_lapply() ... DONE
[11:00:02.197] future_lapply() ...
[11:00:02.201] Number of chunks: 2
[11:00:02.201] getGlobalsAndPackagesXApply() ...
[11:00:02.201]  - future.globals: TRUE
[11:00:02.201] getGlobalsAndPackages() ...
[11:00:02.201] Searching for globals...
[11:00:02.212] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[11:00:02.212] Searching for globals ... DONE
[11:00:02.212] Resolving globals: FALSE
[11:00:02.213] The total size of the 7 globals is 26.71 KiB (27354 bytes)
[11:00:02.214] The total size of the 7 globals exported for future expression (‘FUN()’) is 26.71 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (14.07 KiB of class ‘function’), ‘x_FUN’ (4.67 KiB of class ‘function’) and ‘stop_if_not’ (4.51 KiB of class ‘function’)
[11:00:02.214] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:02.214] - packages: [2] ‘stats’, ‘future.apply’
[11:00:02.214] getGlobalsAndPackages() ... DONE
[11:00:02.214]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:02.215]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[11:00:02.215] Finding globals ... DONE
[11:00:02.215]  - use_args: TRUE
[11:00:02.215]  - Getting '...' globals ...
[11:00:02.215] resolve() on list ...
[11:00:02.215]  recursive: 0
[11:00:02.215]  length: 1
[11:00:02.215]  elements: ‘...’
[11:00:02.216]  length: 0 (resolved future 1)
[11:00:02.216] resolve() on list ... DONE
[11:00:02.216]    - '...' content: [n=0] 
[11:00:02.216] List of 1
[11:00:02.216]  $ ...: list()
[11:00:02.216]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.216]  - attr(*, "where")=List of 1
[11:00:02.216]   ..$ ...:<environment: 0x55bbacbb40f8> 
[11:00:02.216]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.216]  - attr(*, "resolved")= logi TRUE
[11:00:02.216]  - attr(*, "total_size")= num NA
[11:00:02.218]  - Getting '...' globals ... DONE
[11:00:02.219] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:02.219] List of 8
[11:00:02.219]  $ ...future.FUN:function (x, ...)  
[11:00:02.219]  $ x_FUN        :function (x, na.rm = TRUE)  
[11:00:02.219]  $ times        : int 5
[11:00:02.219]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:02.219]  $ stop_if_not  :function (...)  
[11:00:02.219]  $ dim          : NULL
[11:00:02.219]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:02.219]  $ ...          : list()
[11:00:02.219]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.219]  - attr(*, "where")=List of 8
[11:00:02.219]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:02.219]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:02.219]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:02.219]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:02.219]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:02.219]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:02.219]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:02.219]   ..$ ...          :<environment: 0x55bbacbb40f8> 
[11:00:02.219]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.219]  - attr(*, "resolved")= logi FALSE
[11:00:02.219]  - attr(*, "total_size")= num 48005
[11:00:02.224] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[11:00:02.224] getGlobalsAndPackagesXApply() ... DONE
[11:00:02.224] Number of futures (= number of chunks): 2
[11:00:02.225] Launching 2 futures (chunks) ...
[11:00:02.225] Chunk #1 of 2 ...
[11:00:02.225]  - Finding globals in 'X' for chunk #1 ...
[11:00:02.225] getGlobalsAndPackages() ...
[11:00:02.225] Searching for globals...
[11:00:02.225] 
[11:00:02.227] Searching for globals ... DONE
[11:00:02.227] - globals: [0] <none>
[11:00:02.227] getGlobalsAndPackages() ... DONE
[11:00:02.227]    + additional globals found: [n=0] 
[11:00:02.228]    + additional namespaces needed: [n=0] 
[11:00:02.228]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:02.228]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:02.228]  - seeds: <none>
[11:00:02.228]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.228] getGlobalsAndPackages() ...
[11:00:02.228] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.228] Resolving globals: FALSE
[11:00:02.228] Tweak future expression to call with '...' arguments ...
[11:00:02.229] {
[11:00:02.229]     do.call(function(...) {
[11:00:02.229]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.229]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.229]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.229]             on.exit(options(oopts), add = TRUE)
[11:00:02.229]         }
[11:00:02.229]         {
[11:00:02.229]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.229]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.229]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.229]             })
[11:00:02.229]         }
[11:00:02.229]     }, args = future.call.arguments)
[11:00:02.229] }
[11:00:02.229] Tweak future expression to call with '...' arguments ... DONE
[11:00:02.229] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.230] - packages: [2] ‘stats’, ‘future.apply’
[11:00:02.230] getGlobalsAndPackages() ... DONE
[11:00:02.230] run() for ‘Future’ ...
[11:00:02.230] - state: ‘created’
[11:00:02.230] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:02.232] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.232] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:02.233]   - Field: ‘label’
[11:00:02.233]   - Field: ‘local’
[11:00:02.233]   - Field: ‘owner’
[11:00:02.233]   - Field: ‘envir’
[11:00:02.233]   - Field: ‘workers’
[11:00:02.233]   - Field: ‘packages’
[11:00:02.233]   - Field: ‘gc’
[11:00:02.233]   - Field: ‘job’
[11:00:02.233]   - Field: ‘conditions’
[11:00:02.234]   - Field: ‘expr’
[11:00:02.234]   - Field: ‘uuid’
[11:00:02.234]   - Field: ‘seed’
[11:00:02.234]   - Field: ‘version’
[11:00:02.234]   - Field: ‘result’
[11:00:02.234]   - Field: ‘asynchronous’
[11:00:02.234]   - Field: ‘calls’
[11:00:02.234]   - Field: ‘globals’
[11:00:02.234]   - Field: ‘stdout’
[11:00:02.234]   - Field: ‘earlySignal’
[11:00:02.234]   - Field: ‘lazy’
[11:00:02.235]   - Field: ‘state’
[11:00:02.235] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:02.235] - Launch lazy future ...
[11:00:02.235] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[11:00:02.235] Packages needed by future strategies (n = 0): <none>
[11:00:02.236] {
[11:00:02.236]     {
[11:00:02.236]         {
[11:00:02.236]             ...future.startTime <- base::Sys.time()
[11:00:02.236]             {
[11:00:02.236]                 {
[11:00:02.236]                   {
[11:00:02.236]                     {
[11:00:02.236]                       {
[11:00:02.236]                         base::local({
[11:00:02.236]                           has_future <- base::requireNamespace("future", 
[11:00:02.236]                             quietly = TRUE)
[11:00:02.236]                           if (has_future) {
[11:00:02.236]                             ns <- base::getNamespace("future")
[11:00:02.236]                             version <- ns[[".package"]][["version"]]
[11:00:02.236]                             if (is.null(version)) 
[11:00:02.236]                               version <- utils::packageVersion("future")
[11:00:02.236]                           }
[11:00:02.236]                           else {
[11:00:02.236]                             version <- NULL
[11:00:02.236]                           }
[11:00:02.236]                           if (!has_future || version < "1.8.0") {
[11:00:02.236]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:02.236]                               "", base::R.version$version.string), 
[11:00:02.236]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:02.236]                                 base::R.version$platform, 8 * 
[11:00:02.236]                                   base::.Machine$sizeof.pointer), 
[11:00:02.236]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:02.236]                                 "release", "version")], collapse = " "), 
[11:00:02.236]                               hostname = base::Sys.info()[["nodename"]])
[11:00:02.236]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:02.236]                               info)
[11:00:02.236]                             info <- base::paste(info, collapse = "; ")
[11:00:02.236]                             if (!has_future) {
[11:00:02.236]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:02.236]                                 info)
[11:00:02.236]                             }
[11:00:02.236]                             else {
[11:00:02.236]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:02.236]                                 info, version)
[11:00:02.236]                             }
[11:00:02.236]                             base::stop(msg)
[11:00:02.236]                           }
[11:00:02.236]                         })
[11:00:02.236]                       }
[11:00:02.236]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:02.236]                       base::options(mc.cores = 1L)
[11:00:02.236]                     }
[11:00:02.236]                     base::local({
[11:00:02.236]                       for (pkg in c("stats", "future.apply")) {
[11:00:02.236]                         base::loadNamespace(pkg)
[11:00:02.236]                         base::library(pkg, character.only = TRUE)
[11:00:02.236]                       }
[11:00:02.236]                     })
[11:00:02.236]                   }
[11:00:02.236]                   ...future.strategy.old <- future::plan("list")
[11:00:02.236]                   options(future.plan = NULL)
[11:00:02.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:02.236]                 }
[11:00:02.236]                 ...future.workdir <- getwd()
[11:00:02.236]             }
[11:00:02.236]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:02.236]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:02.236]         }
[11:00:02.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:02.236]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:02.236]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:02.236]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:02.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:02.236]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:02.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:02.236]             base::names(...future.oldOptions))
[11:00:02.236]     }
[11:00:02.236]     if (FALSE) {
[11:00:02.236]     }
[11:00:02.236]     else {
[11:00:02.236]         if (TRUE) {
[11:00:02.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:02.236]                 open = "w")
[11:00:02.236]         }
[11:00:02.236]         else {
[11:00:02.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:02.236]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:02.236]         }
[11:00:02.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:02.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:02.236]             base::sink(type = "output", split = FALSE)
[11:00:02.236]             base::close(...future.stdout)
[11:00:02.236]         }, add = TRUE)
[11:00:02.236]     }
[11:00:02.236]     ...future.frame <- base::sys.nframe()
[11:00:02.236]     ...future.conditions <- base::list()
[11:00:02.236]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:02.236]     if (FALSE) {
[11:00:02.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:02.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:02.236]     }
[11:00:02.236]     ...future.result <- base::tryCatch({
[11:00:02.236]         base::withCallingHandlers({
[11:00:02.236]             ...future.value <- base::withVisible(base::local({
[11:00:02.236]                 withCallingHandlers({
[11:00:02.236]                   {
[11:00:02.236]                     do.call(function(...) {
[11:00:02.236]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.236]                       if (!identical(...future.globals.maxSize.org, 
[11:00:02.236]                         ...future.globals.maxSize)) {
[11:00:02.236]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.236]                         on.exit(options(oopts), add = TRUE)
[11:00:02.236]                       }
[11:00:02.236]                       {
[11:00:02.236]                         lapply(seq_along(...future.elements_ii), 
[11:00:02.236]                           FUN = function(jj) {
[11:00:02.236]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.236]                             ...future.FUN(...future.X_jj, ...)
[11:00:02.236]                           })
[11:00:02.236]                       }
[11:00:02.236]                     }, args = future.call.arguments)
[11:00:02.236]                   }
[11:00:02.236]                 }, immediateCondition = function(cond) {
[11:00:02.236]                   save_rds <- function (object, pathname, ...) 
[11:00:02.236]                   {
[11:00:02.236]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:02.236]                     if (file_test("-f", pathname_tmp)) {
[11:00:02.236]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.236]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:02.236]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.236]                         fi_tmp[["mtime"]])
[11:00:02.236]                     }
[11:00:02.236]                     tryCatch({
[11:00:02.236]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:02.236]                     }, error = function(ex) {
[11:00:02.236]                       msg <- conditionMessage(ex)
[11:00:02.236]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.236]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:02.236]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.236]                         fi_tmp[["mtime"]], msg)
[11:00:02.236]                       ex$message <- msg
[11:00:02.236]                       stop(ex)
[11:00:02.236]                     })
[11:00:02.236]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:02.236]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:02.236]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:02.236]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.236]                       fi <- file.info(pathname)
[11:00:02.236]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:02.236]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.236]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:02.236]                         fi[["size"]], fi[["mtime"]])
[11:00:02.236]                       stop(msg)
[11:00:02.236]                     }
[11:00:02.236]                     invisible(pathname)
[11:00:02.236]                   }
[11:00:02.236]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:02.236]                     rootPath = tempdir()) 
[11:00:02.236]                   {
[11:00:02.236]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:02.236]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:02.236]                       tmpdir = path, fileext = ".rds")
[11:00:02.236]                     save_rds(obj, file)
[11:00:02.236]                   }
[11:00:02.236]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:02.236]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.236]                   {
[11:00:02.236]                     inherits <- base::inherits
[11:00:02.236]                     invokeRestart <- base::invokeRestart
[11:00:02.236]                     is.null <- base::is.null
[11:00:02.236]                     muffled <- FALSE
[11:00:02.236]                     if (inherits(cond, "message")) {
[11:00:02.236]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:02.236]                       if (muffled) 
[11:00:02.236]                         invokeRestart("muffleMessage")
[11:00:02.236]                     }
[11:00:02.236]                     else if (inherits(cond, "warning")) {
[11:00:02.236]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:02.236]                       if (muffled) 
[11:00:02.236]                         invokeRestart("muffleWarning")
[11:00:02.236]                     }
[11:00:02.236]                     else if (inherits(cond, "condition")) {
[11:00:02.236]                       if (!is.null(pattern)) {
[11:00:02.236]                         computeRestarts <- base::computeRestarts
[11:00:02.236]                         grepl <- base::grepl
[11:00:02.236]                         restarts <- computeRestarts(cond)
[11:00:02.236]                         for (restart in restarts) {
[11:00:02.236]                           name <- restart$name
[11:00:02.236]                           if (is.null(name)) 
[11:00:02.236]                             next
[11:00:02.236]                           if (!grepl(pattern, name)) 
[11:00:02.236]                             next
[11:00:02.236]                           invokeRestart(restart)
[11:00:02.236]                           muffled <- TRUE
[11:00:02.236]                           break
[11:00:02.236]                         }
[11:00:02.236]                       }
[11:00:02.236]                     }
[11:00:02.236]                     invisible(muffled)
[11:00:02.236]                   }
[11:00:02.236]                   muffleCondition(cond)
[11:00:02.236]                 })
[11:00:02.236]             }))
[11:00:02.236]             future::FutureResult(value = ...future.value$value, 
[11:00:02.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.236]                   ...future.rng), globalenv = if (FALSE) 
[11:00:02.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:02.236]                     ...future.globalenv.names))
[11:00:02.236]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:02.236]         }, condition = base::local({
[11:00:02.236]             c <- base::c
[11:00:02.236]             inherits <- base::inherits
[11:00:02.236]             invokeRestart <- base::invokeRestart
[11:00:02.236]             length <- base::length
[11:00:02.236]             list <- base::list
[11:00:02.236]             seq.int <- base::seq.int
[11:00:02.236]             signalCondition <- base::signalCondition
[11:00:02.236]             sys.calls <- base::sys.calls
[11:00:02.236]             `[[` <- base::`[[`
[11:00:02.236]             `+` <- base::`+`
[11:00:02.236]             `<<-` <- base::`<<-`
[11:00:02.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:02.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:02.236]                   3L)]
[11:00:02.236]             }
[11:00:02.236]             function(cond) {
[11:00:02.236]                 is_error <- inherits(cond, "error")
[11:00:02.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:02.236]                   NULL)
[11:00:02.236]                 if (is_error) {
[11:00:02.236]                   sessionInformation <- function() {
[11:00:02.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:02.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:02.236]                       search = base::search(), system = base::Sys.info())
[11:00:02.236]                   }
[11:00:02.236]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:02.236]                     cond$call), session = sessionInformation(), 
[11:00:02.236]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:02.236]                   signalCondition(cond)
[11:00:02.236]                 }
[11:00:02.236]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:02.236]                 "immediateCondition"))) {
[11:00:02.236]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:02.236]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:02.236]                   if (TRUE && !signal) {
[11:00:02.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.236]                     {
[11:00:02.236]                       inherits <- base::inherits
[11:00:02.236]                       invokeRestart <- base::invokeRestart
[11:00:02.236]                       is.null <- base::is.null
[11:00:02.236]                       muffled <- FALSE
[11:00:02.236]                       if (inherits(cond, "message")) {
[11:00:02.236]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.236]                         if (muffled) 
[11:00:02.236]                           invokeRestart("muffleMessage")
[11:00:02.236]                       }
[11:00:02.236]                       else if (inherits(cond, "warning")) {
[11:00:02.236]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.236]                         if (muffled) 
[11:00:02.236]                           invokeRestart("muffleWarning")
[11:00:02.236]                       }
[11:00:02.236]                       else if (inherits(cond, "condition")) {
[11:00:02.236]                         if (!is.null(pattern)) {
[11:00:02.236]                           computeRestarts <- base::computeRestarts
[11:00:02.236]                           grepl <- base::grepl
[11:00:02.236]                           restarts <- computeRestarts(cond)
[11:00:02.236]                           for (restart in restarts) {
[11:00:02.236]                             name <- restart$name
[11:00:02.236]                             if (is.null(name)) 
[11:00:02.236]                               next
[11:00:02.236]                             if (!grepl(pattern, name)) 
[11:00:02.236]                               next
[11:00:02.236]                             invokeRestart(restart)
[11:00:02.236]                             muffled <- TRUE
[11:00:02.236]                             break
[11:00:02.236]                           }
[11:00:02.236]                         }
[11:00:02.236]                       }
[11:00:02.236]                       invisible(muffled)
[11:00:02.236]                     }
[11:00:02.236]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.236]                   }
[11:00:02.236]                 }
[11:00:02.236]                 else {
[11:00:02.236]                   if (TRUE) {
[11:00:02.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.236]                     {
[11:00:02.236]                       inherits <- base::inherits
[11:00:02.236]                       invokeRestart <- base::invokeRestart
[11:00:02.236]                       is.null <- base::is.null
[11:00:02.236]                       muffled <- FALSE
[11:00:02.236]                       if (inherits(cond, "message")) {
[11:00:02.236]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.236]                         if (muffled) 
[11:00:02.236]                           invokeRestart("muffleMessage")
[11:00:02.236]                       }
[11:00:02.236]                       else if (inherits(cond, "warning")) {
[11:00:02.236]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.236]                         if (muffled) 
[11:00:02.236]                           invokeRestart("muffleWarning")
[11:00:02.236]                       }
[11:00:02.236]                       else if (inherits(cond, "condition")) {
[11:00:02.236]                         if (!is.null(pattern)) {
[11:00:02.236]                           computeRestarts <- base::computeRestarts
[11:00:02.236]                           grepl <- base::grepl
[11:00:02.236]                           restarts <- computeRestarts(cond)
[11:00:02.236]                           for (restart in restarts) {
[11:00:02.236]                             name <- restart$name
[11:00:02.236]                             if (is.null(name)) 
[11:00:02.236]                               next
[11:00:02.236]                             if (!grepl(pattern, name)) 
[11:00:02.236]                               next
[11:00:02.236]                             invokeRestart(restart)
[11:00:02.236]                             muffled <- TRUE
[11:00:02.236]                             break
[11:00:02.236]                           }
[11:00:02.236]                         }
[11:00:02.236]                       }
[11:00:02.236]                       invisible(muffled)
[11:00:02.236]                     }
[11:00:02.236]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.236]                   }
[11:00:02.236]                 }
[11:00:02.236]             }
[11:00:02.236]         }))
[11:00:02.236]     }, error = function(ex) {
[11:00:02.236]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:02.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.236]                 ...future.rng), started = ...future.startTime, 
[11:00:02.236]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:02.236]             version = "1.8"), class = "FutureResult")
[11:00:02.236]     }, finally = {
[11:00:02.236]         if (!identical(...future.workdir, getwd())) 
[11:00:02.236]             setwd(...future.workdir)
[11:00:02.236]         {
[11:00:02.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:02.236]                 ...future.oldOptions$nwarnings <- NULL
[11:00:02.236]             }
[11:00:02.236]             base::options(...future.oldOptions)
[11:00:02.236]             if (.Platform$OS.type == "windows") {
[11:00:02.236]                 old_names <- names(...future.oldEnvVars)
[11:00:02.236]                 envs <- base::Sys.getenv()
[11:00:02.236]                 names <- names(envs)
[11:00:02.236]                 common <- intersect(names, old_names)
[11:00:02.236]                 added <- setdiff(names, old_names)
[11:00:02.236]                 removed <- setdiff(old_names, names)
[11:00:02.236]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:02.236]                   envs[common]]
[11:00:02.236]                 NAMES <- toupper(changed)
[11:00:02.236]                 args <- list()
[11:00:02.236]                 for (kk in seq_along(NAMES)) {
[11:00:02.236]                   name <- changed[[kk]]
[11:00:02.236]                   NAME <- NAMES[[kk]]
[11:00:02.236]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.236]                     next
[11:00:02.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.236]                 }
[11:00:02.236]                 NAMES <- toupper(added)
[11:00:02.236]                 for (kk in seq_along(NAMES)) {
[11:00:02.236]                   name <- added[[kk]]
[11:00:02.236]                   NAME <- NAMES[[kk]]
[11:00:02.236]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.236]                     next
[11:00:02.236]                   args[[name]] <- ""
[11:00:02.236]                 }
[11:00:02.236]                 NAMES <- toupper(removed)
[11:00:02.236]                 for (kk in seq_along(NAMES)) {
[11:00:02.236]                   name <- removed[[kk]]
[11:00:02.236]                   NAME <- NAMES[[kk]]
[11:00:02.236]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.236]                     next
[11:00:02.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.236]                 }
[11:00:02.236]                 if (length(args) > 0) 
[11:00:02.236]                   base::do.call(base::Sys.setenv, args = args)
[11:00:02.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:02.236]             }
[11:00:02.236]             else {
[11:00:02.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:02.236]             }
[11:00:02.236]             {
[11:00:02.236]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:02.236]                   0L) {
[11:00:02.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:02.236]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:02.236]                   base::options(opts)
[11:00:02.236]                 }
[11:00:02.236]                 {
[11:00:02.236]                   {
[11:00:02.236]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:02.236]                     NULL
[11:00:02.236]                   }
[11:00:02.236]                   options(future.plan = NULL)
[11:00:02.236]                   if (is.na(NA_character_)) 
[11:00:02.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:02.236]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:02.236]                     .init = FALSE)
[11:00:02.236]                 }
[11:00:02.236]             }
[11:00:02.236]         }
[11:00:02.236]     })
[11:00:02.236]     if (TRUE) {
[11:00:02.236]         base::sink(type = "output", split = FALSE)
[11:00:02.236]         if (TRUE) {
[11:00:02.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:02.236]         }
[11:00:02.236]         else {
[11:00:02.236]             ...future.result["stdout"] <- base::list(NULL)
[11:00:02.236]         }
[11:00:02.236]         base::close(...future.stdout)
[11:00:02.236]         ...future.stdout <- NULL
[11:00:02.236]     }
[11:00:02.236]     ...future.result$conditions <- ...future.conditions
[11:00:02.236]     ...future.result$finished <- base::Sys.time()
[11:00:02.236]     ...future.result
[11:00:02.236] }
[11:00:02.238] assign_globals() ...
[11:00:02.238] List of 11
[11:00:02.238]  $ ...future.FUN            :function (x, ...)  
[11:00:02.238]  $ x_FUN                    :function (x, na.rm = TRUE)  
[11:00:02.238]  $ times                    : int 5
[11:00:02.238]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:02.238]  $ stop_if_not              :function (...)  
[11:00:02.238]  $ dim                      : NULL
[11:00:02.238]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:02.238]  $ future.call.arguments    : list()
[11:00:02.238]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.238]  $ ...future.elements_ii    :List of 4
[11:00:02.238]   ..$ : int [1:3] 1 2 3
[11:00:02.238]   ..$ : int [1:4] 1 2 3 4
[11:00:02.238]   ..$ : int [1:5] 1 2 3 4 5
[11:00:02.238]   ..$ : int [1:6] 1 2 3 4 5 6
[11:00:02.238]  $ ...future.seeds_ii       : NULL
[11:00:02.238]  $ ...future.globals.maxSize: NULL
[11:00:02.238]  - attr(*, "where")=List of 11
[11:00:02.238]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:02.238]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:02.238]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:02.238]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:02.238]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:02.238]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:02.238]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:02.238]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:02.238]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:02.238]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:02.238]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:02.238]  - attr(*, "resolved")= logi FALSE
[11:00:02.238]  - attr(*, "total_size")= num 48005
[11:00:02.238]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.238]  - attr(*, "already-done")= logi TRUE
[11:00:02.247] - copied ‘...future.FUN’ to environment
[11:00:02.247] - copied ‘x_FUN’ to environment
[11:00:02.247] - copied ‘times’ to environment
[11:00:02.247] - copied ‘stopf’ to environment
[11:00:02.247] - copied ‘stop_if_not’ to environment
[11:00:02.247] - copied ‘dim’ to environment
[11:00:02.247] - copied ‘valid_types’ to environment
[11:00:02.247] - copied ‘future.call.arguments’ to environment
[11:00:02.247] - copied ‘...future.elements_ii’ to environment
[11:00:02.247] - copied ‘...future.seeds_ii’ to environment
[11:00:02.248] - copied ‘...future.globals.maxSize’ to environment
[11:00:02.248] assign_globals() ... done
[11:00:02.248] requestCore(): workers = 2
[11:00:02.250] MulticoreFuture started
[11:00:02.254] - Launch lazy future ... done
[11:00:02.255] run() for ‘MulticoreFuture’ ... done
[11:00:02.255] Created future:
[11:00:02.256] plan(): Setting new future strategy stack:
[11:00:02.256] List of future strategies:
[11:00:02.256] 1. sequential:
[11:00:02.256]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:02.256]    - tweaked: FALSE
[11:00:02.256]    - call: NULL
[11:00:02.258] plan(): nbrOfWorkers() = 1
[11:00:02.261] plan(): Setting new future strategy stack:
[11:00:02.261] List of future strategies:
[11:00:02.261] 1. multicore:
[11:00:02.261]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:02.261]    - tweaked: FALSE
[11:00:02.261]    - call: plan(strategy)
[11:00:02.266] plan(): nbrOfWorkers() = 2
[11:00:02.256] MulticoreFuture:
[11:00:02.256] Label: ‘future_vapply-1’
[11:00:02.256] Expression:
[11:00:02.256] {
[11:00:02.256]     do.call(function(...) {
[11:00:02.256]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.256]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.256]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.256]             on.exit(options(oopts), add = TRUE)
[11:00:02.256]         }
[11:00:02.256]         {
[11:00:02.256]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.256]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.256]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.256]             })
[11:00:02.256]         }
[11:00:02.256]     }, args = future.call.arguments)
[11:00:02.256] }
[11:00:02.256] Lazy evaluation: FALSE
[11:00:02.256] Asynchronous evaluation: TRUE
[11:00:02.256] Local evaluation: TRUE
[11:00:02.256] Environment: R_GlobalEnv
[11:00:02.256] Capture standard output: TRUE
[11:00:02.256] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:02.256] Globals: 11 objects totaling 27.22 KiB (function ‘...future.FUN’ of 14.07 KiB, function ‘x_FUN’ of 4.67 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:02.256] Packages: 2 packages (‘stats’, ‘future.apply’)
[11:00:02.256] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:02.256] Resolved: TRUE
[11:00:02.256] Value: <not collected>
[11:00:02.256] Conditions captured: <none>
[11:00:02.256] Early signaling: FALSE
[11:00:02.256] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:02.256] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.267] Chunk #1 of 2 ... DONE
[11:00:02.267] Chunk #2 of 2 ...
[11:00:02.267]  - Finding globals in 'X' for chunk #2 ...
[11:00:02.268] getGlobalsAndPackages() ...
[11:00:02.268] Searching for globals...
[11:00:02.268] 
[11:00:02.269] Searching for globals ... DONE
[11:00:02.269] - globals: [0] <none>
[11:00:02.269] getGlobalsAndPackages() ... DONE
[11:00:02.269]    + additional globals found: [n=0] 
[11:00:02.269]    + additional namespaces needed: [n=0] 
[11:00:02.270]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:02.270]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:02.270]  - seeds: <none>
[11:00:02.270]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.270] getGlobalsAndPackages() ...
[11:00:02.270] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.271] Resolving globals: FALSE
[11:00:02.271] Tweak future expression to call with '...' arguments ...
[11:00:02.271] {
[11:00:02.271]     do.call(function(...) {
[11:00:02.271]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.271]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.271]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.271]             on.exit(options(oopts), add = TRUE)
[11:00:02.271]         }
[11:00:02.271]         {
[11:00:02.271]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.271]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.271]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.271]             })
[11:00:02.271]         }
[11:00:02.271]     }, args = future.call.arguments)
[11:00:02.271] }
[11:00:02.272] Tweak future expression to call with '...' arguments ... DONE
[11:00:02.273] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.273] - packages: [2] ‘stats’, ‘future.apply’
[11:00:02.274] getGlobalsAndPackages() ... DONE
[11:00:02.274] run() for ‘Future’ ...
[11:00:02.275] - state: ‘created’
[11:00:02.275] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:02.277] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.278] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:02.278]   - Field: ‘label’
[11:00:02.278]   - Field: ‘local’
[11:00:02.278]   - Field: ‘owner’
[11:00:02.278]   - Field: ‘envir’
[11:00:02.278]   - Field: ‘workers’
[11:00:02.278]   - Field: ‘packages’
[11:00:02.278]   - Field: ‘gc’
[11:00:02.279]   - Field: ‘job’
[11:00:02.279]   - Field: ‘conditions’
[11:00:02.279]   - Field: ‘expr’
[11:00:02.279]   - Field: ‘uuid’
[11:00:02.279]   - Field: ‘seed’
[11:00:02.279]   - Field: ‘version’
[11:00:02.279]   - Field: ‘result’
[11:00:02.280]   - Field: ‘asynchronous’
[11:00:02.280]   - Field: ‘calls’
[11:00:02.280]   - Field: ‘globals’
[11:00:02.280]   - Field: ‘stdout’
[11:00:02.280]   - Field: ‘earlySignal’
[11:00:02.280]   - Field: ‘lazy’
[11:00:02.280]   - Field: ‘state’
[11:00:02.280] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:02.281] - Launch lazy future ...
[11:00:02.281] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[11:00:02.281] Packages needed by future strategies (n = 0): <none>
[11:00:02.282] {
[11:00:02.282]     {
[11:00:02.282]         {
[11:00:02.282]             ...future.startTime <- base::Sys.time()
[11:00:02.282]             {
[11:00:02.282]                 {
[11:00:02.282]                   {
[11:00:02.282]                     {
[11:00:02.282]                       {
[11:00:02.282]                         base::local({
[11:00:02.282]                           has_future <- base::requireNamespace("future", 
[11:00:02.282]                             quietly = TRUE)
[11:00:02.282]                           if (has_future) {
[11:00:02.282]                             ns <- base::getNamespace("future")
[11:00:02.282]                             version <- ns[[".package"]][["version"]]
[11:00:02.282]                             if (is.null(version)) 
[11:00:02.282]                               version <- utils::packageVersion("future")
[11:00:02.282]                           }
[11:00:02.282]                           else {
[11:00:02.282]                             version <- NULL
[11:00:02.282]                           }
[11:00:02.282]                           if (!has_future || version < "1.8.0") {
[11:00:02.282]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:02.282]                               "", base::R.version$version.string), 
[11:00:02.282]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:02.282]                                 base::R.version$platform, 8 * 
[11:00:02.282]                                   base::.Machine$sizeof.pointer), 
[11:00:02.282]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:02.282]                                 "release", "version")], collapse = " "), 
[11:00:02.282]                               hostname = base::Sys.info()[["nodename"]])
[11:00:02.282]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:02.282]                               info)
[11:00:02.282]                             info <- base::paste(info, collapse = "; ")
[11:00:02.282]                             if (!has_future) {
[11:00:02.282]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:02.282]                                 info)
[11:00:02.282]                             }
[11:00:02.282]                             else {
[11:00:02.282]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:02.282]                                 info, version)
[11:00:02.282]                             }
[11:00:02.282]                             base::stop(msg)
[11:00:02.282]                           }
[11:00:02.282]                         })
[11:00:02.282]                       }
[11:00:02.282]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:02.282]                       base::options(mc.cores = 1L)
[11:00:02.282]                     }
[11:00:02.282]                     base::local({
[11:00:02.282]                       for (pkg in c("stats", "future.apply")) {
[11:00:02.282]                         base::loadNamespace(pkg)
[11:00:02.282]                         base::library(pkg, character.only = TRUE)
[11:00:02.282]                       }
[11:00:02.282]                     })
[11:00:02.282]                   }
[11:00:02.282]                   ...future.strategy.old <- future::plan("list")
[11:00:02.282]                   options(future.plan = NULL)
[11:00:02.282]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.282]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:02.282]                 }
[11:00:02.282]                 ...future.workdir <- getwd()
[11:00:02.282]             }
[11:00:02.282]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:02.282]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:02.282]         }
[11:00:02.282]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:02.282]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:02.282]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:02.282]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:02.282]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:02.282]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:02.282]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:02.282]             base::names(...future.oldOptions))
[11:00:02.282]     }
[11:00:02.282]     if (FALSE) {
[11:00:02.282]     }
[11:00:02.282]     else {
[11:00:02.282]         if (TRUE) {
[11:00:02.282]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:02.282]                 open = "w")
[11:00:02.282]         }
[11:00:02.282]         else {
[11:00:02.282]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:02.282]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:02.282]         }
[11:00:02.282]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:02.282]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:02.282]             base::sink(type = "output", split = FALSE)
[11:00:02.282]             base::close(...future.stdout)
[11:00:02.282]         }, add = TRUE)
[11:00:02.282]     }
[11:00:02.282]     ...future.frame <- base::sys.nframe()
[11:00:02.282]     ...future.conditions <- base::list()
[11:00:02.282]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:02.282]     if (FALSE) {
[11:00:02.282]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:02.282]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:02.282]     }
[11:00:02.282]     ...future.result <- base::tryCatch({
[11:00:02.282]         base::withCallingHandlers({
[11:00:02.282]             ...future.value <- base::withVisible(base::local({
[11:00:02.282]                 withCallingHandlers({
[11:00:02.282]                   {
[11:00:02.282]                     do.call(function(...) {
[11:00:02.282]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.282]                       if (!identical(...future.globals.maxSize.org, 
[11:00:02.282]                         ...future.globals.maxSize)) {
[11:00:02.282]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.282]                         on.exit(options(oopts), add = TRUE)
[11:00:02.282]                       }
[11:00:02.282]                       {
[11:00:02.282]                         lapply(seq_along(...future.elements_ii), 
[11:00:02.282]                           FUN = function(jj) {
[11:00:02.282]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.282]                             ...future.FUN(...future.X_jj, ...)
[11:00:02.282]                           })
[11:00:02.282]                       }
[11:00:02.282]                     }, args = future.call.arguments)
[11:00:02.282]                   }
[11:00:02.282]                 }, immediateCondition = function(cond) {
[11:00:02.282]                   save_rds <- function (object, pathname, ...) 
[11:00:02.282]                   {
[11:00:02.282]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:02.282]                     if (file_test("-f", pathname_tmp)) {
[11:00:02.282]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.282]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:02.282]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.282]                         fi_tmp[["mtime"]])
[11:00:02.282]                     }
[11:00:02.282]                     tryCatch({
[11:00:02.282]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:02.282]                     }, error = function(ex) {
[11:00:02.282]                       msg <- conditionMessage(ex)
[11:00:02.282]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.282]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:02.282]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.282]                         fi_tmp[["mtime"]], msg)
[11:00:02.282]                       ex$message <- msg
[11:00:02.282]                       stop(ex)
[11:00:02.282]                     })
[11:00:02.282]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:02.282]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:02.282]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:02.282]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.282]                       fi <- file.info(pathname)
[11:00:02.282]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:02.282]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.282]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:02.282]                         fi[["size"]], fi[["mtime"]])
[11:00:02.282]                       stop(msg)
[11:00:02.282]                     }
[11:00:02.282]                     invisible(pathname)
[11:00:02.282]                   }
[11:00:02.282]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:02.282]                     rootPath = tempdir()) 
[11:00:02.282]                   {
[11:00:02.282]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:02.282]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:02.282]                       tmpdir = path, fileext = ".rds")
[11:00:02.282]                     save_rds(obj, file)
[11:00:02.282]                   }
[11:00:02.282]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:02.282]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.282]                   {
[11:00:02.282]                     inherits <- base::inherits
[11:00:02.282]                     invokeRestart <- base::invokeRestart
[11:00:02.282]                     is.null <- base::is.null
[11:00:02.282]                     muffled <- FALSE
[11:00:02.282]                     if (inherits(cond, "message")) {
[11:00:02.282]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:02.282]                       if (muffled) 
[11:00:02.282]                         invokeRestart("muffleMessage")
[11:00:02.282]                     }
[11:00:02.282]                     else if (inherits(cond, "warning")) {
[11:00:02.282]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:02.282]                       if (muffled) 
[11:00:02.282]                         invokeRestart("muffleWarning")
[11:00:02.282]                     }
[11:00:02.282]                     else if (inherits(cond, "condition")) {
[11:00:02.282]                       if (!is.null(pattern)) {
[11:00:02.282]                         computeRestarts <- base::computeRestarts
[11:00:02.282]                         grepl <- base::grepl
[11:00:02.282]                         restarts <- computeRestarts(cond)
[11:00:02.282]                         for (restart in restarts) {
[11:00:02.282]                           name <- restart$name
[11:00:02.282]                           if (is.null(name)) 
[11:00:02.282]                             next
[11:00:02.282]                           if (!grepl(pattern, name)) 
[11:00:02.282]                             next
[11:00:02.282]                           invokeRestart(restart)
[11:00:02.282]                           muffled <- TRUE
[11:00:02.282]                           break
[11:00:02.282]                         }
[11:00:02.282]                       }
[11:00:02.282]                     }
[11:00:02.282]                     invisible(muffled)
[11:00:02.282]                   }
[11:00:02.282]                   muffleCondition(cond)
[11:00:02.282]                 })
[11:00:02.282]             }))
[11:00:02.282]             future::FutureResult(value = ...future.value$value, 
[11:00:02.282]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.282]                   ...future.rng), globalenv = if (FALSE) 
[11:00:02.282]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:02.282]                     ...future.globalenv.names))
[11:00:02.282]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:02.282]         }, condition = base::local({
[11:00:02.282]             c <- base::c
[11:00:02.282]             inherits <- base::inherits
[11:00:02.282]             invokeRestart <- base::invokeRestart
[11:00:02.282]             length <- base::length
[11:00:02.282]             list <- base::list
[11:00:02.282]             seq.int <- base::seq.int
[11:00:02.282]             signalCondition <- base::signalCondition
[11:00:02.282]             sys.calls <- base::sys.calls
[11:00:02.282]             `[[` <- base::`[[`
[11:00:02.282]             `+` <- base::`+`
[11:00:02.282]             `<<-` <- base::`<<-`
[11:00:02.282]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:02.282]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:02.282]                   3L)]
[11:00:02.282]             }
[11:00:02.282]             function(cond) {
[11:00:02.282]                 is_error <- inherits(cond, "error")
[11:00:02.282]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:02.282]                   NULL)
[11:00:02.282]                 if (is_error) {
[11:00:02.282]                   sessionInformation <- function() {
[11:00:02.282]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:02.282]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:02.282]                       search = base::search(), system = base::Sys.info())
[11:00:02.282]                   }
[11:00:02.282]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.282]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:02.282]                     cond$call), session = sessionInformation(), 
[11:00:02.282]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:02.282]                   signalCondition(cond)
[11:00:02.282]                 }
[11:00:02.282]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:02.282]                 "immediateCondition"))) {
[11:00:02.282]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:02.282]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.282]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:02.282]                   if (TRUE && !signal) {
[11:00:02.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.282]                     {
[11:00:02.282]                       inherits <- base::inherits
[11:00:02.282]                       invokeRestart <- base::invokeRestart
[11:00:02.282]                       is.null <- base::is.null
[11:00:02.282]                       muffled <- FALSE
[11:00:02.282]                       if (inherits(cond, "message")) {
[11:00:02.282]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.282]                         if (muffled) 
[11:00:02.282]                           invokeRestart("muffleMessage")
[11:00:02.282]                       }
[11:00:02.282]                       else if (inherits(cond, "warning")) {
[11:00:02.282]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.282]                         if (muffled) 
[11:00:02.282]                           invokeRestart("muffleWarning")
[11:00:02.282]                       }
[11:00:02.282]                       else if (inherits(cond, "condition")) {
[11:00:02.282]                         if (!is.null(pattern)) {
[11:00:02.282]                           computeRestarts <- base::computeRestarts
[11:00:02.282]                           grepl <- base::grepl
[11:00:02.282]                           restarts <- computeRestarts(cond)
[11:00:02.282]                           for (restart in restarts) {
[11:00:02.282]                             name <- restart$name
[11:00:02.282]                             if (is.null(name)) 
[11:00:02.282]                               next
[11:00:02.282]                             if (!grepl(pattern, name)) 
[11:00:02.282]                               next
[11:00:02.282]                             invokeRestart(restart)
[11:00:02.282]                             muffled <- TRUE
[11:00:02.282]                             break
[11:00:02.282]                           }
[11:00:02.282]                         }
[11:00:02.282]                       }
[11:00:02.282]                       invisible(muffled)
[11:00:02.282]                     }
[11:00:02.282]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.282]                   }
[11:00:02.282]                 }
[11:00:02.282]                 else {
[11:00:02.282]                   if (TRUE) {
[11:00:02.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.282]                     {
[11:00:02.282]                       inherits <- base::inherits
[11:00:02.282]                       invokeRestart <- base::invokeRestart
[11:00:02.282]                       is.null <- base::is.null
[11:00:02.282]                       muffled <- FALSE
[11:00:02.282]                       if (inherits(cond, "message")) {
[11:00:02.282]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.282]                         if (muffled) 
[11:00:02.282]                           invokeRestart("muffleMessage")
[11:00:02.282]                       }
[11:00:02.282]                       else if (inherits(cond, "warning")) {
[11:00:02.282]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.282]                         if (muffled) 
[11:00:02.282]                           invokeRestart("muffleWarning")
[11:00:02.282]                       }
[11:00:02.282]                       else if (inherits(cond, "condition")) {
[11:00:02.282]                         if (!is.null(pattern)) {
[11:00:02.282]                           computeRestarts <- base::computeRestarts
[11:00:02.282]                           grepl <- base::grepl
[11:00:02.282]                           restarts <- computeRestarts(cond)
[11:00:02.282]                           for (restart in restarts) {
[11:00:02.282]                             name <- restart$name
[11:00:02.282]                             if (is.null(name)) 
[11:00:02.282]                               next
[11:00:02.282]                             if (!grepl(pattern, name)) 
[11:00:02.282]                               next
[11:00:02.282]                             invokeRestart(restart)
[11:00:02.282]                             muffled <- TRUE
[11:00:02.282]                             break
[11:00:02.282]                           }
[11:00:02.282]                         }
[11:00:02.282]                       }
[11:00:02.282]                       invisible(muffled)
[11:00:02.282]                     }
[11:00:02.282]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.282]                   }
[11:00:02.282]                 }
[11:00:02.282]             }
[11:00:02.282]         }))
[11:00:02.282]     }, error = function(ex) {
[11:00:02.282]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:02.282]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.282]                 ...future.rng), started = ...future.startTime, 
[11:00:02.282]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:02.282]             version = "1.8"), class = "FutureResult")
[11:00:02.282]     }, finally = {
[11:00:02.282]         if (!identical(...future.workdir, getwd())) 
[11:00:02.282]             setwd(...future.workdir)
[11:00:02.282]         {
[11:00:02.282]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:02.282]                 ...future.oldOptions$nwarnings <- NULL
[11:00:02.282]             }
[11:00:02.282]             base::options(...future.oldOptions)
[11:00:02.282]             if (.Platform$OS.type == "windows") {
[11:00:02.282]                 old_names <- names(...future.oldEnvVars)
[11:00:02.282]                 envs <- base::Sys.getenv()
[11:00:02.282]                 names <- names(envs)
[11:00:02.282]                 common <- intersect(names, old_names)
[11:00:02.282]                 added <- setdiff(names, old_names)
[11:00:02.282]                 removed <- setdiff(old_names, names)
[11:00:02.282]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:02.282]                   envs[common]]
[11:00:02.282]                 NAMES <- toupper(changed)
[11:00:02.282]                 args <- list()
[11:00:02.282]                 for (kk in seq_along(NAMES)) {
[11:00:02.282]                   name <- changed[[kk]]
[11:00:02.282]                   NAME <- NAMES[[kk]]
[11:00:02.282]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.282]                     next
[11:00:02.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.282]                 }
[11:00:02.282]                 NAMES <- toupper(added)
[11:00:02.282]                 for (kk in seq_along(NAMES)) {
[11:00:02.282]                   name <- added[[kk]]
[11:00:02.282]                   NAME <- NAMES[[kk]]
[11:00:02.282]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.282]                     next
[11:00:02.282]                   args[[name]] <- ""
[11:00:02.282]                 }
[11:00:02.282]                 NAMES <- toupper(removed)
[11:00:02.282]                 for (kk in seq_along(NAMES)) {
[11:00:02.282]                   name <- removed[[kk]]
[11:00:02.282]                   NAME <- NAMES[[kk]]
[11:00:02.282]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.282]                     next
[11:00:02.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.282]                 }
[11:00:02.282]                 if (length(args) > 0) 
[11:00:02.282]                   base::do.call(base::Sys.setenv, args = args)
[11:00:02.282]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:02.282]             }
[11:00:02.282]             else {
[11:00:02.282]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:02.282]             }
[11:00:02.282]             {
[11:00:02.282]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:02.282]                   0L) {
[11:00:02.282]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:02.282]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:02.282]                   base::options(opts)
[11:00:02.282]                 }
[11:00:02.282]                 {
[11:00:02.282]                   {
[11:00:02.282]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:02.282]                     NULL
[11:00:02.282]                   }
[11:00:02.282]                   options(future.plan = NULL)
[11:00:02.282]                   if (is.na(NA_character_)) 
[11:00:02.282]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.282]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:02.282]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:02.282]                     .init = FALSE)
[11:00:02.282]                 }
[11:00:02.282]             }
[11:00:02.282]         }
[11:00:02.282]     })
[11:00:02.282]     if (TRUE) {
[11:00:02.282]         base::sink(type = "output", split = FALSE)
[11:00:02.282]         if (TRUE) {
[11:00:02.282]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:02.282]         }
[11:00:02.282]         else {
[11:00:02.282]             ...future.result["stdout"] <- base::list(NULL)
[11:00:02.282]         }
[11:00:02.282]         base::close(...future.stdout)
[11:00:02.282]         ...future.stdout <- NULL
[11:00:02.282]     }
[11:00:02.282]     ...future.result$conditions <- ...future.conditions
[11:00:02.282]     ...future.result$finished <- base::Sys.time()
[11:00:02.282]     ...future.result
[11:00:02.282] }
[11:00:02.285] assign_globals() ...
[11:00:02.285] List of 11
[11:00:02.285]  $ ...future.FUN            :function (x, ...)  
[11:00:02.285]  $ x_FUN                    :function (x, na.rm = TRUE)  
[11:00:02.285]  $ times                    : int 5
[11:00:02.285]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:02.285]  $ stop_if_not              :function (...)  
[11:00:02.285]  $ dim                      : NULL
[11:00:02.285]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:02.285]  $ future.call.arguments    : list()
[11:00:02.285]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.285]  $ ...future.elements_ii    :List of 3
[11:00:02.285]   ..$ : int [1:7] 1 2 3 4 5 6 7
[11:00:02.285]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[11:00:02.285]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[11:00:02.285]  $ ...future.seeds_ii       : NULL
[11:00:02.285]  $ ...future.globals.maxSize: NULL
[11:00:02.285]  - attr(*, "where")=List of 11
[11:00:02.285]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:02.285]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:02.285]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:02.285]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:02.285]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:02.285]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:02.285]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:02.285]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:02.285]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:02.285]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:02.285]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:02.285]  - attr(*, "resolved")= logi FALSE
[11:00:02.285]  - attr(*, "total_size")= num 48005
[11:00:02.285]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.285]  - attr(*, "already-done")= logi TRUE
[11:00:02.297] - copied ‘...future.FUN’ to environment
[11:00:02.297] - copied ‘x_FUN’ to environment
[11:00:02.297] - copied ‘times’ to environment
[11:00:02.297] - copied ‘stopf’ to environment
[11:00:02.297] - copied ‘stop_if_not’ to environment
[11:00:02.297] - copied ‘dim’ to environment
[11:00:02.297] - copied ‘valid_types’ to environment
[11:00:02.298] - copied ‘future.call.arguments’ to environment
[11:00:02.298] - copied ‘...future.elements_ii’ to environment
[11:00:02.298] - copied ‘...future.seeds_ii’ to environment
[11:00:02.298] - copied ‘...future.globals.maxSize’ to environment
[11:00:02.298] assign_globals() ... done
[11:00:02.298] requestCore(): workers = 2
[11:00:02.301] MulticoreFuture started
[11:00:02.302] - Launch lazy future ... done
[11:00:02.302] run() for ‘MulticoreFuture’ ... done
[11:00:02.303] Created future:
[11:00:02.303] plan(): Setting new future strategy stack:
[11:00:02.304] List of future strategies:
[11:00:02.304] 1. sequential:
[11:00:02.304]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:02.304]    - tweaked: FALSE
[11:00:02.304]    - call: NULL
[11:00:02.305] plan(): nbrOfWorkers() = 1
[11:00:02.309] plan(): Setting new future strategy stack:
[11:00:02.309] List of future strategies:
[11:00:02.309] 1. multicore:
[11:00:02.309]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:02.309]    - tweaked: FALSE
[11:00:02.309]    - call: plan(strategy)
[11:00:02.314] plan(): nbrOfWorkers() = 2
[11:00:02.303] MulticoreFuture:
[11:00:02.303] Label: ‘future_vapply-2’
[11:00:02.303] Expression:
[11:00:02.303] {
[11:00:02.303]     do.call(function(...) {
[11:00:02.303]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.303]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.303]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.303]             on.exit(options(oopts), add = TRUE)
[11:00:02.303]         }
[11:00:02.303]         {
[11:00:02.303]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.303]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.303]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.303]             })
[11:00:02.303]         }
[11:00:02.303]     }, args = future.call.arguments)
[11:00:02.303] }
[11:00:02.303] Lazy evaluation: FALSE
[11:00:02.303] Asynchronous evaluation: TRUE
[11:00:02.303] Local evaluation: TRUE
[11:00:02.303] Environment: R_GlobalEnv
[11:00:02.303] Capture standard output: TRUE
[11:00:02.303] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:02.303] Globals: 11 objects totaling 27.14 KiB (function ‘...future.FUN’ of 14.07 KiB, function ‘x_FUN’ of 4.67 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:02.303] Packages: 2 packages (‘stats’, ‘future.apply’)
[11:00:02.303] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:02.303] Resolved: TRUE
[11:00:02.303] Value: <not collected>
[11:00:02.303] Conditions captured: <none>
[11:00:02.303] Early signaling: FALSE
[11:00:02.303] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:02.303] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.315] Chunk #2 of 2 ... DONE
[11:00:02.315] Launching 2 futures (chunks) ... DONE
[11:00:02.315] Resolving 2 futures (chunks) ...
[11:00:02.316] resolve() on list ...
[11:00:02.316]  recursive: 0
[11:00:02.316]  length: 2
[11:00:02.316] 
[11:00:02.317] Future #1
[11:00:02.317] result() for MulticoreFuture ...
[11:00:02.318] result() for MulticoreFuture ...
[11:00:02.318] result() for MulticoreFuture ... done
[11:00:02.318] result() for MulticoreFuture ... done
[11:00:02.318] result() for MulticoreFuture ...
[11:00:02.319] result() for MulticoreFuture ... done
[11:00:02.319] signalConditionsASAP(MulticoreFuture, pos=1) ...
[11:00:02.319] - nx: 2
[11:00:02.319] - relay: TRUE
[11:00:02.319] - stdout: TRUE
[11:00:02.320] - signal: TRUE
[11:00:02.320] - resignal: FALSE
[11:00:02.320] - force: TRUE
[11:00:02.320] - relayed: [n=2] FALSE, FALSE
[11:00:02.320] - queued futures: [n=2] FALSE, FALSE
[11:00:02.320]  - until=1
[11:00:02.320]  - relaying element #1
[11:00:02.321] result() for MulticoreFuture ...
[11:00:02.321] result() for MulticoreFuture ... done
[11:00:02.321] result() for MulticoreFuture ...
[11:00:02.321] result() for MulticoreFuture ... done
[11:00:02.321] result() for MulticoreFuture ...
[11:00:02.321] result() for MulticoreFuture ... done
[11:00:02.321] result() for MulticoreFuture ...
[11:00:02.321] result() for MulticoreFuture ... done
[11:00:02.322] - relayed: [n=2] TRUE, FALSE
[11:00:02.322] - queued futures: [n=2] TRUE, FALSE
[11:00:02.322] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[11:00:02.322]  length: 1 (resolved future 1)
[11:00:02.323] Future #2
[11:00:02.323] result() for MulticoreFuture ...
[11:00:02.324] result() for MulticoreFuture ...
[11:00:02.324] result() for MulticoreFuture ... done
[11:00:02.324] result() for MulticoreFuture ... done
[11:00:02.324] result() for MulticoreFuture ...
[11:00:02.324] result() for MulticoreFuture ... done
[11:00:02.324] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:00:02.324] - nx: 2
[11:00:02.324] - relay: TRUE
[11:00:02.325] - stdout: TRUE
[11:00:02.325] - signal: TRUE
[11:00:02.325] - resignal: FALSE
[11:00:02.325] - force: TRUE
[11:00:02.325] - relayed: [n=2] TRUE, FALSE
[11:00:02.325] - queued futures: [n=2] TRUE, FALSE
[11:00:02.325]  - until=2
[11:00:02.325]  - relaying element #2
[11:00:02.325] result() for MulticoreFuture ...
[11:00:02.326] result() for MulticoreFuture ... done
[11:00:02.326] result() for MulticoreFuture ...
[11:00:02.326] result() for MulticoreFuture ... done
[11:00:02.326] result() for MulticoreFuture ...
[11:00:02.326] result() for MulticoreFuture ... done
[11:00:02.326] result() for MulticoreFuture ...
[11:00:02.326] result() for MulticoreFuture ... done
[11:00:02.326] - relayed: [n=2] TRUE, TRUE
[11:00:02.326] - queued futures: [n=2] TRUE, TRUE
[11:00:02.327] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:00:02.327]  length: 0 (resolved future 2)
[11:00:02.327] Relaying remaining futures
[11:00:02.327] signalConditionsASAP(NULL, pos=0) ...
[11:00:02.327] - nx: 2
[11:00:02.327] - relay: TRUE
[11:00:02.327] - stdout: TRUE
[11:00:02.327] - signal: TRUE
[11:00:02.327] - resignal: FALSE
[11:00:02.327] - force: TRUE
[11:00:02.328] - relayed: [n=2] TRUE, TRUE
[11:00:02.328] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:02.328] - relayed: [n=2] TRUE, TRUE
[11:00:02.328] - queued futures: [n=2] TRUE, TRUE
[11:00:02.328] signalConditionsASAP(NULL, pos=0) ... done
[11:00:02.328] resolve() on list ... DONE
[11:00:02.328] result() for MulticoreFuture ...
[11:00:02.328] result() for MulticoreFuture ... done
[11:00:02.328] result() for MulticoreFuture ...
[11:00:02.328] result() for MulticoreFuture ... done
[11:00:02.329] result() for MulticoreFuture ...
[11:00:02.329] result() for MulticoreFuture ... done
[11:00:02.329] result() for MulticoreFuture ...
[11:00:02.329] result() for MulticoreFuture ... done
[11:00:02.329]  - Number of value chunks collected: 2
[11:00:02.329] Resolving 2 futures (chunks) ... DONE
[11:00:02.329] Reducing values from 2 chunks ...
[11:00:02.329]  - Number of values collected after concatenation: 7
[11:00:02.329]  - Number of values expected: 7
[11:00:02.329] Reducing values from 2 chunks ... DONE
[11:00:02.330] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[11:00:02.332] future_lapply() ...
[11:00:02.334] Number of chunks: 2
[11:00:02.334] getGlobalsAndPackagesXApply() ...
[11:00:02.335]  - future.globals: TRUE
[11:00:02.335] getGlobalsAndPackages() ...
[11:00:02.335] Searching for globals...
[11:00:02.336] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[11:00:02.336] Searching for globals ... DONE
[11:00:02.336] Resolving globals: FALSE
[11:00:02.339] The total size of the 1 globals is 680 bytes (680 bytes)
[11:00:02.339] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 680 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (680 bytes of class ‘function’)
[11:00:02.340] - globals: [1] ‘FUN’
[11:00:02.340] 
[11:00:02.340] getGlobalsAndPackages() ... DONE
[11:00:02.340]  - globals found/used: [n=1] ‘FUN’
[11:00:02.340]  - needed namespaces: [n=0] 
[11:00:02.340] Finding globals ... DONE
[11:00:02.340]  - use_args: TRUE
[11:00:02.340]  - Getting '...' globals ...
[11:00:02.341] resolve() on list ...
[11:00:02.341]  recursive: 0
[11:00:02.341]  length: 1
[11:00:02.341]  elements: ‘...’
[11:00:02.341]  length: 0 (resolved future 1)
[11:00:02.341] resolve() on list ... DONE
[11:00:02.342]    - '...' content: [n=1] ‘y’
[11:00:02.342] List of 1
[11:00:02.342]  $ ...:List of 1
[11:00:02.342]   ..$ y: num [1:5] 2 4 6 8 10
[11:00:02.342]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.342]  - attr(*, "where")=List of 1
[11:00:02.342]   ..$ ...:<environment: 0x55bbad321130> 
[11:00:02.342]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.342]  - attr(*, "resolved")= logi TRUE
[11:00:02.342]  - attr(*, "total_size")= num NA
[11:00:02.345]  - Getting '...' globals ... DONE
[11:00:02.345] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[11:00:02.346] List of 2
[11:00:02.346]  $ ...future.FUN:function (x, y)  
[11:00:02.346]  $ ...          :List of 1
[11:00:02.346]   ..$ y: num [1:5] 2 4 6 8 10
[11:00:02.346]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.346]  - attr(*, "where")=List of 2
[11:00:02.346]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:02.346]   ..$ ...          :<environment: 0x55bbad321130> 
[11:00:02.346]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.346]  - attr(*, "resolved")= logi FALSE
[11:00:02.346]  - attr(*, "total_size")= num 7318
[11:00:02.349] Packages to be attached in all futures: [n=0] 
[11:00:02.349] getGlobalsAndPackagesXApply() ... DONE
[11:00:02.349] Number of futures (= number of chunks): 2
[11:00:02.349] Launching 2 futures (chunks) ...
[11:00:02.349] Chunk #1 of 2 ...
[11:00:02.349]  - Finding globals in 'X' for chunk #1 ...
[11:00:02.349] getGlobalsAndPackages() ...
[11:00:02.350] Searching for globals...
[11:00:02.350] 
[11:00:02.350] Searching for globals ... DONE
[11:00:02.350] - globals: [0] <none>
[11:00:02.350] getGlobalsAndPackages() ... DONE
[11:00:02.350]    + additional globals found: [n=0] 
[11:00:02.350]    + additional namespaces needed: [n=0] 
[11:00:02.350]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:02.350]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:02.351]  - seeds: <none>
[11:00:02.351]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.351] getGlobalsAndPackages() ...
[11:00:02.351] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.351] Resolving globals: FALSE
[11:00:02.351] Tweak future expression to call with '...' arguments ...
[11:00:02.351] {
[11:00:02.351]     do.call(function(...) {
[11:00:02.351]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.351]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.351]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.351]             on.exit(options(oopts), add = TRUE)
[11:00:02.351]         }
[11:00:02.351]         {
[11:00:02.351]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.351]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.351]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.351]             })
[11:00:02.351]         }
[11:00:02.351]     }, args = future.call.arguments)
[11:00:02.351] }
[11:00:02.351] Tweak future expression to call with '...' arguments ... DONE
[11:00:02.352] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.352] 
[11:00:02.352] getGlobalsAndPackages() ... DONE
[11:00:02.352] run() for ‘Future’ ...
[11:00:02.352] - state: ‘created’
[11:00:02.353] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:02.354] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.354] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:02.355]   - Field: ‘label’
[11:00:02.355]   - Field: ‘local’
[11:00:02.355]   - Field: ‘owner’
[11:00:02.355]   - Field: ‘envir’
[11:00:02.355]   - Field: ‘workers’
[11:00:02.355]   - Field: ‘packages’
[11:00:02.355]   - Field: ‘gc’
[11:00:02.355]   - Field: ‘job’
[11:00:02.355]   - Field: ‘conditions’
[11:00:02.355]   - Field: ‘expr’
[11:00:02.356]   - Field: ‘uuid’
[11:00:02.356]   - Field: ‘seed’
[11:00:02.356]   - Field: ‘version’
[11:00:02.356]   - Field: ‘result’
[11:00:02.356]   - Field: ‘asynchronous’
[11:00:02.356]   - Field: ‘calls’
[11:00:02.356]   - Field: ‘globals’
[11:00:02.356]   - Field: ‘stdout’
[11:00:02.356]   - Field: ‘earlySignal’
[11:00:02.356]   - Field: ‘lazy’
[11:00:02.356]   - Field: ‘state’
[11:00:02.356] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:02.357] - Launch lazy future ...
[11:00:02.357] Packages needed by the future expression (n = 0): <none>
[11:00:02.357] Packages needed by future strategies (n = 0): <none>
[11:00:02.357] {
[11:00:02.357]     {
[11:00:02.357]         {
[11:00:02.357]             ...future.startTime <- base::Sys.time()
[11:00:02.357]             {
[11:00:02.357]                 {
[11:00:02.357]                   {
[11:00:02.357]                     {
[11:00:02.357]                       base::local({
[11:00:02.357]                         has_future <- base::requireNamespace("future", 
[11:00:02.357]                           quietly = TRUE)
[11:00:02.357]                         if (has_future) {
[11:00:02.357]                           ns <- base::getNamespace("future")
[11:00:02.357]                           version <- ns[[".package"]][["version"]]
[11:00:02.357]                           if (is.null(version)) 
[11:00:02.357]                             version <- utils::packageVersion("future")
[11:00:02.357]                         }
[11:00:02.357]                         else {
[11:00:02.357]                           version <- NULL
[11:00:02.357]                         }
[11:00:02.357]                         if (!has_future || version < "1.8.0") {
[11:00:02.357]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:02.357]                             "", base::R.version$version.string), 
[11:00:02.357]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:02.357]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:02.357]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:02.357]                               "release", "version")], collapse = " "), 
[11:00:02.357]                             hostname = base::Sys.info()[["nodename"]])
[11:00:02.357]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:02.357]                             info)
[11:00:02.357]                           info <- base::paste(info, collapse = "; ")
[11:00:02.357]                           if (!has_future) {
[11:00:02.357]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:02.357]                               info)
[11:00:02.357]                           }
[11:00:02.357]                           else {
[11:00:02.357]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:02.357]                               info, version)
[11:00:02.357]                           }
[11:00:02.357]                           base::stop(msg)
[11:00:02.357]                         }
[11:00:02.357]                       })
[11:00:02.357]                     }
[11:00:02.357]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:02.357]                     base::options(mc.cores = 1L)
[11:00:02.357]                   }
[11:00:02.357]                   ...future.strategy.old <- future::plan("list")
[11:00:02.357]                   options(future.plan = NULL)
[11:00:02.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:02.357]                 }
[11:00:02.357]                 ...future.workdir <- getwd()
[11:00:02.357]             }
[11:00:02.357]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:02.357]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:02.357]         }
[11:00:02.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:02.357]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:02.357]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:02.357]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:02.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:02.357]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:02.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:02.357]             base::names(...future.oldOptions))
[11:00:02.357]     }
[11:00:02.357]     if (FALSE) {
[11:00:02.357]     }
[11:00:02.357]     else {
[11:00:02.357]         if (TRUE) {
[11:00:02.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:02.357]                 open = "w")
[11:00:02.357]         }
[11:00:02.357]         else {
[11:00:02.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:02.357]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:02.357]         }
[11:00:02.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:02.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:02.357]             base::sink(type = "output", split = FALSE)
[11:00:02.357]             base::close(...future.stdout)
[11:00:02.357]         }, add = TRUE)
[11:00:02.357]     }
[11:00:02.357]     ...future.frame <- base::sys.nframe()
[11:00:02.357]     ...future.conditions <- base::list()
[11:00:02.357]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:02.357]     if (FALSE) {
[11:00:02.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:02.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:02.357]     }
[11:00:02.357]     ...future.result <- base::tryCatch({
[11:00:02.357]         base::withCallingHandlers({
[11:00:02.357]             ...future.value <- base::withVisible(base::local({
[11:00:02.357]                 withCallingHandlers({
[11:00:02.357]                   {
[11:00:02.357]                     do.call(function(...) {
[11:00:02.357]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.357]                       if (!identical(...future.globals.maxSize.org, 
[11:00:02.357]                         ...future.globals.maxSize)) {
[11:00:02.357]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.357]                         on.exit(options(oopts), add = TRUE)
[11:00:02.357]                       }
[11:00:02.357]                       {
[11:00:02.357]                         lapply(seq_along(...future.elements_ii), 
[11:00:02.357]                           FUN = function(jj) {
[11:00:02.357]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.357]                             ...future.FUN(...future.X_jj, ...)
[11:00:02.357]                           })
[11:00:02.357]                       }
[11:00:02.357]                     }, args = future.call.arguments)
[11:00:02.357]                   }
[11:00:02.357]                 }, immediateCondition = function(cond) {
[11:00:02.357]                   save_rds <- function (object, pathname, ...) 
[11:00:02.357]                   {
[11:00:02.357]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:02.357]                     if (file_test("-f", pathname_tmp)) {
[11:00:02.357]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.357]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:02.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.357]                         fi_tmp[["mtime"]])
[11:00:02.357]                     }
[11:00:02.357]                     tryCatch({
[11:00:02.357]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:02.357]                     }, error = function(ex) {
[11:00:02.357]                       msg <- conditionMessage(ex)
[11:00:02.357]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.357]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:02.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.357]                         fi_tmp[["mtime"]], msg)
[11:00:02.357]                       ex$message <- msg
[11:00:02.357]                       stop(ex)
[11:00:02.357]                     })
[11:00:02.357]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:02.357]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:02.357]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:02.357]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.357]                       fi <- file.info(pathname)
[11:00:02.357]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:02.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.357]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:02.357]                         fi[["size"]], fi[["mtime"]])
[11:00:02.357]                       stop(msg)
[11:00:02.357]                     }
[11:00:02.357]                     invisible(pathname)
[11:00:02.357]                   }
[11:00:02.357]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:02.357]                     rootPath = tempdir()) 
[11:00:02.357]                   {
[11:00:02.357]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:02.357]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:02.357]                       tmpdir = path, fileext = ".rds")
[11:00:02.357]                     save_rds(obj, file)
[11:00:02.357]                   }
[11:00:02.357]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:02.357]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.357]                   {
[11:00:02.357]                     inherits <- base::inherits
[11:00:02.357]                     invokeRestart <- base::invokeRestart
[11:00:02.357]                     is.null <- base::is.null
[11:00:02.357]                     muffled <- FALSE
[11:00:02.357]                     if (inherits(cond, "message")) {
[11:00:02.357]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:02.357]                       if (muffled) 
[11:00:02.357]                         invokeRestart("muffleMessage")
[11:00:02.357]                     }
[11:00:02.357]                     else if (inherits(cond, "warning")) {
[11:00:02.357]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:02.357]                       if (muffled) 
[11:00:02.357]                         invokeRestart("muffleWarning")
[11:00:02.357]                     }
[11:00:02.357]                     else if (inherits(cond, "condition")) {
[11:00:02.357]                       if (!is.null(pattern)) {
[11:00:02.357]                         computeRestarts <- base::computeRestarts
[11:00:02.357]                         grepl <- base::grepl
[11:00:02.357]                         restarts <- computeRestarts(cond)
[11:00:02.357]                         for (restart in restarts) {
[11:00:02.357]                           name <- restart$name
[11:00:02.357]                           if (is.null(name)) 
[11:00:02.357]                             next
[11:00:02.357]                           if (!grepl(pattern, name)) 
[11:00:02.357]                             next
[11:00:02.357]                           invokeRestart(restart)
[11:00:02.357]                           muffled <- TRUE
[11:00:02.357]                           break
[11:00:02.357]                         }
[11:00:02.357]                       }
[11:00:02.357]                     }
[11:00:02.357]                     invisible(muffled)
[11:00:02.357]                   }
[11:00:02.357]                   muffleCondition(cond)
[11:00:02.357]                 })
[11:00:02.357]             }))
[11:00:02.357]             future::FutureResult(value = ...future.value$value, 
[11:00:02.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.357]                   ...future.rng), globalenv = if (FALSE) 
[11:00:02.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:02.357]                     ...future.globalenv.names))
[11:00:02.357]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:02.357]         }, condition = base::local({
[11:00:02.357]             c <- base::c
[11:00:02.357]             inherits <- base::inherits
[11:00:02.357]             invokeRestart <- base::invokeRestart
[11:00:02.357]             length <- base::length
[11:00:02.357]             list <- base::list
[11:00:02.357]             seq.int <- base::seq.int
[11:00:02.357]             signalCondition <- base::signalCondition
[11:00:02.357]             sys.calls <- base::sys.calls
[11:00:02.357]             `[[` <- base::`[[`
[11:00:02.357]             `+` <- base::`+`
[11:00:02.357]             `<<-` <- base::`<<-`
[11:00:02.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:02.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:02.357]                   3L)]
[11:00:02.357]             }
[11:00:02.357]             function(cond) {
[11:00:02.357]                 is_error <- inherits(cond, "error")
[11:00:02.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:02.357]                   NULL)
[11:00:02.357]                 if (is_error) {
[11:00:02.357]                   sessionInformation <- function() {
[11:00:02.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:02.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:02.357]                       search = base::search(), system = base::Sys.info())
[11:00:02.357]                   }
[11:00:02.357]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:02.357]                     cond$call), session = sessionInformation(), 
[11:00:02.357]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:02.357]                   signalCondition(cond)
[11:00:02.357]                 }
[11:00:02.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:02.357]                 "immediateCondition"))) {
[11:00:02.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:02.357]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:02.357]                   if (TRUE && !signal) {
[11:00:02.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.357]                     {
[11:00:02.357]                       inherits <- base::inherits
[11:00:02.357]                       invokeRestart <- base::invokeRestart
[11:00:02.357]                       is.null <- base::is.null
[11:00:02.357]                       muffled <- FALSE
[11:00:02.357]                       if (inherits(cond, "message")) {
[11:00:02.357]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.357]                         if (muffled) 
[11:00:02.357]                           invokeRestart("muffleMessage")
[11:00:02.357]                       }
[11:00:02.357]                       else if (inherits(cond, "warning")) {
[11:00:02.357]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.357]                         if (muffled) 
[11:00:02.357]                           invokeRestart("muffleWarning")
[11:00:02.357]                       }
[11:00:02.357]                       else if (inherits(cond, "condition")) {
[11:00:02.357]                         if (!is.null(pattern)) {
[11:00:02.357]                           computeRestarts <- base::computeRestarts
[11:00:02.357]                           grepl <- base::grepl
[11:00:02.357]                           restarts <- computeRestarts(cond)
[11:00:02.357]                           for (restart in restarts) {
[11:00:02.357]                             name <- restart$name
[11:00:02.357]                             if (is.null(name)) 
[11:00:02.357]                               next
[11:00:02.357]                             if (!grepl(pattern, name)) 
[11:00:02.357]                               next
[11:00:02.357]                             invokeRestart(restart)
[11:00:02.357]                             muffled <- TRUE
[11:00:02.357]                             break
[11:00:02.357]                           }
[11:00:02.357]                         }
[11:00:02.357]                       }
[11:00:02.357]                       invisible(muffled)
[11:00:02.357]                     }
[11:00:02.357]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.357]                   }
[11:00:02.357]                 }
[11:00:02.357]                 else {
[11:00:02.357]                   if (TRUE) {
[11:00:02.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.357]                     {
[11:00:02.357]                       inherits <- base::inherits
[11:00:02.357]                       invokeRestart <- base::invokeRestart
[11:00:02.357]                       is.null <- base::is.null
[11:00:02.357]                       muffled <- FALSE
[11:00:02.357]                       if (inherits(cond, "message")) {
[11:00:02.357]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.357]                         if (muffled) 
[11:00:02.357]                           invokeRestart("muffleMessage")
[11:00:02.357]                       }
[11:00:02.357]                       else if (inherits(cond, "warning")) {
[11:00:02.357]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.357]                         if (muffled) 
[11:00:02.357]                           invokeRestart("muffleWarning")
[11:00:02.357]                       }
[11:00:02.357]                       else if (inherits(cond, "condition")) {
[11:00:02.357]                         if (!is.null(pattern)) {
[11:00:02.357]                           computeRestarts <- base::computeRestarts
[11:00:02.357]                           grepl <- base::grepl
[11:00:02.357]                           restarts <- computeRestarts(cond)
[11:00:02.357]                           for (restart in restarts) {
[11:00:02.357]                             name <- restart$name
[11:00:02.357]                             if (is.null(name)) 
[11:00:02.357]                               next
[11:00:02.357]                             if (!grepl(pattern, name)) 
[11:00:02.357]                               next
[11:00:02.357]                             invokeRestart(restart)
[11:00:02.357]                             muffled <- TRUE
[11:00:02.357]                             break
[11:00:02.357]                           }
[11:00:02.357]                         }
[11:00:02.357]                       }
[11:00:02.357]                       invisible(muffled)
[11:00:02.357]                     }
[11:00:02.357]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.357]                   }
[11:00:02.357]                 }
[11:00:02.357]             }
[11:00:02.357]         }))
[11:00:02.357]     }, error = function(ex) {
[11:00:02.357]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:02.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.357]                 ...future.rng), started = ...future.startTime, 
[11:00:02.357]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:02.357]             version = "1.8"), class = "FutureResult")
[11:00:02.357]     }, finally = {
[11:00:02.357]         if (!identical(...future.workdir, getwd())) 
[11:00:02.357]             setwd(...future.workdir)
[11:00:02.357]         {
[11:00:02.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:02.357]                 ...future.oldOptions$nwarnings <- NULL
[11:00:02.357]             }
[11:00:02.357]             base::options(...future.oldOptions)
[11:00:02.357]             if (.Platform$OS.type == "windows") {
[11:00:02.357]                 old_names <- names(...future.oldEnvVars)
[11:00:02.357]                 envs <- base::Sys.getenv()
[11:00:02.357]                 names <- names(envs)
[11:00:02.357]                 common <- intersect(names, old_names)
[11:00:02.357]                 added <- setdiff(names, old_names)
[11:00:02.357]                 removed <- setdiff(old_names, names)
[11:00:02.357]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:02.357]                   envs[common]]
[11:00:02.357]                 NAMES <- toupper(changed)
[11:00:02.357]                 args <- list()
[11:00:02.357]                 for (kk in seq_along(NAMES)) {
[11:00:02.357]                   name <- changed[[kk]]
[11:00:02.357]                   NAME <- NAMES[[kk]]
[11:00:02.357]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.357]                     next
[11:00:02.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.357]                 }
[11:00:02.357]                 NAMES <- toupper(added)
[11:00:02.357]                 for (kk in seq_along(NAMES)) {
[11:00:02.357]                   name <- added[[kk]]
[11:00:02.357]                   NAME <- NAMES[[kk]]
[11:00:02.357]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.357]                     next
[11:00:02.357]                   args[[name]] <- ""
[11:00:02.357]                 }
[11:00:02.357]                 NAMES <- toupper(removed)
[11:00:02.357]                 for (kk in seq_along(NAMES)) {
[11:00:02.357]                   name <- removed[[kk]]
[11:00:02.357]                   NAME <- NAMES[[kk]]
[11:00:02.357]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.357]                     next
[11:00:02.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.357]                 }
[11:00:02.357]                 if (length(args) > 0) 
[11:00:02.357]                   base::do.call(base::Sys.setenv, args = args)
[11:00:02.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:02.357]             }
[11:00:02.357]             else {
[11:00:02.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:02.357]             }
[11:00:02.357]             {
[11:00:02.357]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:02.357]                   0L) {
[11:00:02.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:02.357]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:02.357]                   base::options(opts)
[11:00:02.357]                 }
[11:00:02.357]                 {
[11:00:02.357]                   {
[11:00:02.357]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:02.357]                     NULL
[11:00:02.357]                   }
[11:00:02.357]                   options(future.plan = NULL)
[11:00:02.357]                   if (is.na(NA_character_)) 
[11:00:02.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:02.357]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:02.357]                     .init = FALSE)
[11:00:02.357]                 }
[11:00:02.357]             }
[11:00:02.357]         }
[11:00:02.357]     })
[11:00:02.357]     if (TRUE) {
[11:00:02.357]         base::sink(type = "output", split = FALSE)
[11:00:02.357]         if (TRUE) {
[11:00:02.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:02.357]         }
[11:00:02.357]         else {
[11:00:02.357]             ...future.result["stdout"] <- base::list(NULL)
[11:00:02.357]         }
[11:00:02.357]         base::close(...future.stdout)
[11:00:02.357]         ...future.stdout <- NULL
[11:00:02.357]     }
[11:00:02.357]     ...future.result$conditions <- ...future.conditions
[11:00:02.357]     ...future.result$finished <- base::Sys.time()
[11:00:02.357]     ...future.result
[11:00:02.357] }
[11:00:02.360] assign_globals() ...
[11:00:02.360] List of 5
[11:00:02.360]  $ ...future.FUN            :function (x, y)  
[11:00:02.360]  $ future.call.arguments    :List of 1
[11:00:02.360]   ..$ y: num [1:5] 2 4 6 8 10
[11:00:02.360]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.360]  $ ...future.elements_ii    :List of 2
[11:00:02.360]   ..$ A: num 50
[11:00:02.360]   ..$ B: num 60
[11:00:02.360]  $ ...future.seeds_ii       : NULL
[11:00:02.360]  $ ...future.globals.maxSize: NULL
[11:00:02.360]  - attr(*, "where")=List of 5
[11:00:02.360]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:02.360]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:02.360]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:02.360]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:02.360]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:02.360]  - attr(*, "resolved")= logi FALSE
[11:00:02.360]  - attr(*, "total_size")= num 7318
[11:00:02.360]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.360]  - attr(*, "already-done")= logi TRUE
[11:00:02.368] - reassign environment for ‘...future.FUN’
[11:00:02.369] - copied ‘...future.FUN’ to environment
[11:00:02.369] - copied ‘future.call.arguments’ to environment
[11:00:02.369] - copied ‘...future.elements_ii’ to environment
[11:00:02.369] - copied ‘...future.seeds_ii’ to environment
[11:00:02.369] - copied ‘...future.globals.maxSize’ to environment
[11:00:02.369] assign_globals() ... done
[11:00:02.369] requestCore(): workers = 2
[11:00:02.371] MulticoreFuture started
[11:00:02.372] - Launch lazy future ... done
[11:00:02.372] run() for ‘MulticoreFuture’ ... done
[11:00:02.373] Created future:
[11:00:02.373] plan(): Setting new future strategy stack:
[11:00:02.373] List of future strategies:
[11:00:02.373] 1. sequential:
[11:00:02.373]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:02.373]    - tweaked: FALSE
[11:00:02.373]    - call: NULL
[11:00:02.374] plan(): nbrOfWorkers() = 1
[11:00:02.377] plan(): Setting new future strategy stack:
[11:00:02.377] List of future strategies:
[11:00:02.377] 1. multicore:
[11:00:02.377]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:02.377]    - tweaked: FALSE
[11:00:02.377]    - call: plan(strategy)
[11:00:02.380] plan(): nbrOfWorkers() = 2
[11:00:02.373] MulticoreFuture:
[11:00:02.373] Label: ‘future_sapply-1’
[11:00:02.373] Expression:
[11:00:02.373] {
[11:00:02.373]     do.call(function(...) {
[11:00:02.373]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.373]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.373]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.373]             on.exit(options(oopts), add = TRUE)
[11:00:02.373]         }
[11:00:02.373]         {
[11:00:02.373]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.373]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.373]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.373]             })
[11:00:02.373]         }
[11:00:02.373]     }, args = future.call.arguments)
[11:00:02.373] }
[11:00:02.373] Lazy evaluation: FALSE
[11:00:02.373] Asynchronous evaluation: TRUE
[11:00:02.373] Local evaluation: TRUE
[11:00:02.373] Environment: R_GlobalEnv
[11:00:02.373] Capture standard output: TRUE
[11:00:02.373] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:02.373] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 680 bytes, DotDotDotList ‘future.call.arguments’ of 183 bytes, list ‘...future.elements_ii’ of 114 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:02.373] Packages: <none>
[11:00:02.373] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:02.373] Resolved: TRUE
[11:00:02.373] Value: <not collected>
[11:00:02.373] Conditions captured: <none>
[11:00:02.373] Early signaling: FALSE
[11:00:02.373] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:02.373] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.382] Chunk #1 of 2 ... DONE
[11:00:02.382] Chunk #2 of 2 ...
[11:00:02.382]  - Finding globals in 'X' for chunk #2 ...
[11:00:02.382] getGlobalsAndPackages() ...
[11:00:02.382] Searching for globals...
[11:00:02.383] 
[11:00:02.383] Searching for globals ... DONE
[11:00:02.383] - globals: [0] <none>
[11:00:02.383] getGlobalsAndPackages() ... DONE
[11:00:02.383]    + additional globals found: [n=0] 
[11:00:02.383]    + additional namespaces needed: [n=0] 
[11:00:02.384]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:02.384]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:02.384]  - seeds: <none>
[11:00:02.384]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.384] getGlobalsAndPackages() ...
[11:00:02.384] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.384] Resolving globals: FALSE
[11:00:02.385] Tweak future expression to call with '...' arguments ...
[11:00:02.385] {
[11:00:02.385]     do.call(function(...) {
[11:00:02.385]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.385]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.385]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.385]             on.exit(options(oopts), add = TRUE)
[11:00:02.385]         }
[11:00:02.385]         {
[11:00:02.385]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.385]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.385]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.385]             })
[11:00:02.385]         }
[11:00:02.385]     }, args = future.call.arguments)
[11:00:02.385] }
[11:00:02.385] Tweak future expression to call with '...' arguments ... DONE
[11:00:02.386] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.386] 
[11:00:02.386] getGlobalsAndPackages() ... DONE
[11:00:02.387] run() for ‘Future’ ...
[11:00:02.387] - state: ‘created’
[11:00:02.387] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:02.390] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.390] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:02.390]   - Field: ‘label’
[11:00:02.391]   - Field: ‘local’
[11:00:02.391]   - Field: ‘owner’
[11:00:02.391]   - Field: ‘envir’
[11:00:02.391]   - Field: ‘workers’
[11:00:02.391]   - Field: ‘packages’
[11:00:02.391]   - Field: ‘gc’
[11:00:02.391]   - Field: ‘job’
[11:00:02.392]   - Field: ‘conditions’
[11:00:02.392]   - Field: ‘expr’
[11:00:02.392]   - Field: ‘uuid’
[11:00:02.392]   - Field: ‘seed’
[11:00:02.392]   - Field: ‘version’
[11:00:02.392]   - Field: ‘result’
[11:00:02.392]   - Field: ‘asynchronous’
[11:00:02.393]   - Field: ‘calls’
[11:00:02.393]   - Field: ‘globals’
[11:00:02.393]   - Field: ‘stdout’
[11:00:02.393]   - Field: ‘earlySignal’
[11:00:02.393]   - Field: ‘lazy’
[11:00:02.393]   - Field: ‘state’
[11:00:02.393] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:02.393] - Launch lazy future ...
[11:00:02.394] Packages needed by the future expression (n = 0): <none>
[11:00:02.394] Packages needed by future strategies (n = 0): <none>
[11:00:02.395] {
[11:00:02.395]     {
[11:00:02.395]         {
[11:00:02.395]             ...future.startTime <- base::Sys.time()
[11:00:02.395]             {
[11:00:02.395]                 {
[11:00:02.395]                   {
[11:00:02.395]                     {
[11:00:02.395]                       base::local({
[11:00:02.395]                         has_future <- base::requireNamespace("future", 
[11:00:02.395]                           quietly = TRUE)
[11:00:02.395]                         if (has_future) {
[11:00:02.395]                           ns <- base::getNamespace("future")
[11:00:02.395]                           version <- ns[[".package"]][["version"]]
[11:00:02.395]                           if (is.null(version)) 
[11:00:02.395]                             version <- utils::packageVersion("future")
[11:00:02.395]                         }
[11:00:02.395]                         else {
[11:00:02.395]                           version <- NULL
[11:00:02.395]                         }
[11:00:02.395]                         if (!has_future || version < "1.8.0") {
[11:00:02.395]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:02.395]                             "", base::R.version$version.string), 
[11:00:02.395]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:02.395]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:02.395]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:02.395]                               "release", "version")], collapse = " "), 
[11:00:02.395]                             hostname = base::Sys.info()[["nodename"]])
[11:00:02.395]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:02.395]                             info)
[11:00:02.395]                           info <- base::paste(info, collapse = "; ")
[11:00:02.395]                           if (!has_future) {
[11:00:02.395]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:02.395]                               info)
[11:00:02.395]                           }
[11:00:02.395]                           else {
[11:00:02.395]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:02.395]                               info, version)
[11:00:02.395]                           }
[11:00:02.395]                           base::stop(msg)
[11:00:02.395]                         }
[11:00:02.395]                       })
[11:00:02.395]                     }
[11:00:02.395]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:02.395]                     base::options(mc.cores = 1L)
[11:00:02.395]                   }
[11:00:02.395]                   ...future.strategy.old <- future::plan("list")
[11:00:02.395]                   options(future.plan = NULL)
[11:00:02.395]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.395]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:02.395]                 }
[11:00:02.395]                 ...future.workdir <- getwd()
[11:00:02.395]             }
[11:00:02.395]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:02.395]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:02.395]         }
[11:00:02.395]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:02.395]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:02.395]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:02.395]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:02.395]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:02.395]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:02.395]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:02.395]             base::names(...future.oldOptions))
[11:00:02.395]     }
[11:00:02.395]     if (FALSE) {
[11:00:02.395]     }
[11:00:02.395]     else {
[11:00:02.395]         if (TRUE) {
[11:00:02.395]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:02.395]                 open = "w")
[11:00:02.395]         }
[11:00:02.395]         else {
[11:00:02.395]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:02.395]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:02.395]         }
[11:00:02.395]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:02.395]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:02.395]             base::sink(type = "output", split = FALSE)
[11:00:02.395]             base::close(...future.stdout)
[11:00:02.395]         }, add = TRUE)
[11:00:02.395]     }
[11:00:02.395]     ...future.frame <- base::sys.nframe()
[11:00:02.395]     ...future.conditions <- base::list()
[11:00:02.395]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:02.395]     if (FALSE) {
[11:00:02.395]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:02.395]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:02.395]     }
[11:00:02.395]     ...future.result <- base::tryCatch({
[11:00:02.395]         base::withCallingHandlers({
[11:00:02.395]             ...future.value <- base::withVisible(base::local({
[11:00:02.395]                 withCallingHandlers({
[11:00:02.395]                   {
[11:00:02.395]                     do.call(function(...) {
[11:00:02.395]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.395]                       if (!identical(...future.globals.maxSize.org, 
[11:00:02.395]                         ...future.globals.maxSize)) {
[11:00:02.395]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.395]                         on.exit(options(oopts), add = TRUE)
[11:00:02.395]                       }
[11:00:02.395]                       {
[11:00:02.395]                         lapply(seq_along(...future.elements_ii), 
[11:00:02.395]                           FUN = function(jj) {
[11:00:02.395]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.395]                             ...future.FUN(...future.X_jj, ...)
[11:00:02.395]                           })
[11:00:02.395]                       }
[11:00:02.395]                     }, args = future.call.arguments)
[11:00:02.395]                   }
[11:00:02.395]                 }, immediateCondition = function(cond) {
[11:00:02.395]                   save_rds <- function (object, pathname, ...) 
[11:00:02.395]                   {
[11:00:02.395]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:02.395]                     if (file_test("-f", pathname_tmp)) {
[11:00:02.395]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.395]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:02.395]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.395]                         fi_tmp[["mtime"]])
[11:00:02.395]                     }
[11:00:02.395]                     tryCatch({
[11:00:02.395]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:02.395]                     }, error = function(ex) {
[11:00:02.395]                       msg <- conditionMessage(ex)
[11:00:02.395]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.395]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:02.395]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.395]                         fi_tmp[["mtime"]], msg)
[11:00:02.395]                       ex$message <- msg
[11:00:02.395]                       stop(ex)
[11:00:02.395]                     })
[11:00:02.395]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:02.395]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:02.395]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:02.395]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.395]                       fi <- file.info(pathname)
[11:00:02.395]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:02.395]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.395]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:02.395]                         fi[["size"]], fi[["mtime"]])
[11:00:02.395]                       stop(msg)
[11:00:02.395]                     }
[11:00:02.395]                     invisible(pathname)
[11:00:02.395]                   }
[11:00:02.395]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:02.395]                     rootPath = tempdir()) 
[11:00:02.395]                   {
[11:00:02.395]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:02.395]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:02.395]                       tmpdir = path, fileext = ".rds")
[11:00:02.395]                     save_rds(obj, file)
[11:00:02.395]                   }
[11:00:02.395]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:02.395]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.395]                   {
[11:00:02.395]                     inherits <- base::inherits
[11:00:02.395]                     invokeRestart <- base::invokeRestart
[11:00:02.395]                     is.null <- base::is.null
[11:00:02.395]                     muffled <- FALSE
[11:00:02.395]                     if (inherits(cond, "message")) {
[11:00:02.395]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:02.395]                       if (muffled) 
[11:00:02.395]                         invokeRestart("muffleMessage")
[11:00:02.395]                     }
[11:00:02.395]                     else if (inherits(cond, "warning")) {
[11:00:02.395]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:02.395]                       if (muffled) 
[11:00:02.395]                         invokeRestart("muffleWarning")
[11:00:02.395]                     }
[11:00:02.395]                     else if (inherits(cond, "condition")) {
[11:00:02.395]                       if (!is.null(pattern)) {
[11:00:02.395]                         computeRestarts <- base::computeRestarts
[11:00:02.395]                         grepl <- base::grepl
[11:00:02.395]                         restarts <- computeRestarts(cond)
[11:00:02.395]                         for (restart in restarts) {
[11:00:02.395]                           name <- restart$name
[11:00:02.395]                           if (is.null(name)) 
[11:00:02.395]                             next
[11:00:02.395]                           if (!grepl(pattern, name)) 
[11:00:02.395]                             next
[11:00:02.395]                           invokeRestart(restart)
[11:00:02.395]                           muffled <- TRUE
[11:00:02.395]                           break
[11:00:02.395]                         }
[11:00:02.395]                       }
[11:00:02.395]                     }
[11:00:02.395]                     invisible(muffled)
[11:00:02.395]                   }
[11:00:02.395]                   muffleCondition(cond)
[11:00:02.395]                 })
[11:00:02.395]             }))
[11:00:02.395]             future::FutureResult(value = ...future.value$value, 
[11:00:02.395]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.395]                   ...future.rng), globalenv = if (FALSE) 
[11:00:02.395]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:02.395]                     ...future.globalenv.names))
[11:00:02.395]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:02.395]         }, condition = base::local({
[11:00:02.395]             c <- base::c
[11:00:02.395]             inherits <- base::inherits
[11:00:02.395]             invokeRestart <- base::invokeRestart
[11:00:02.395]             length <- base::length
[11:00:02.395]             list <- base::list
[11:00:02.395]             seq.int <- base::seq.int
[11:00:02.395]             signalCondition <- base::signalCondition
[11:00:02.395]             sys.calls <- base::sys.calls
[11:00:02.395]             `[[` <- base::`[[`
[11:00:02.395]             `+` <- base::`+`
[11:00:02.395]             `<<-` <- base::`<<-`
[11:00:02.395]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:02.395]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:02.395]                   3L)]
[11:00:02.395]             }
[11:00:02.395]             function(cond) {
[11:00:02.395]                 is_error <- inherits(cond, "error")
[11:00:02.395]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:02.395]                   NULL)
[11:00:02.395]                 if (is_error) {
[11:00:02.395]                   sessionInformation <- function() {
[11:00:02.395]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:02.395]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:02.395]                       search = base::search(), system = base::Sys.info())
[11:00:02.395]                   }
[11:00:02.395]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.395]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:02.395]                     cond$call), session = sessionInformation(), 
[11:00:02.395]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:02.395]                   signalCondition(cond)
[11:00:02.395]                 }
[11:00:02.395]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:02.395]                 "immediateCondition"))) {
[11:00:02.395]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:02.395]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.395]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:02.395]                   if (TRUE && !signal) {
[11:00:02.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.395]                     {
[11:00:02.395]                       inherits <- base::inherits
[11:00:02.395]                       invokeRestart <- base::invokeRestart
[11:00:02.395]                       is.null <- base::is.null
[11:00:02.395]                       muffled <- FALSE
[11:00:02.395]                       if (inherits(cond, "message")) {
[11:00:02.395]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.395]                         if (muffled) 
[11:00:02.395]                           invokeRestart("muffleMessage")
[11:00:02.395]                       }
[11:00:02.395]                       else if (inherits(cond, "warning")) {
[11:00:02.395]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.395]                         if (muffled) 
[11:00:02.395]                           invokeRestart("muffleWarning")
[11:00:02.395]                       }
[11:00:02.395]                       else if (inherits(cond, "condition")) {
[11:00:02.395]                         if (!is.null(pattern)) {
[11:00:02.395]                           computeRestarts <- base::computeRestarts
[11:00:02.395]                           grepl <- base::grepl
[11:00:02.395]                           restarts <- computeRestarts(cond)
[11:00:02.395]                           for (restart in restarts) {
[11:00:02.395]                             name <- restart$name
[11:00:02.395]                             if (is.null(name)) 
[11:00:02.395]                               next
[11:00:02.395]                             if (!grepl(pattern, name)) 
[11:00:02.395]                               next
[11:00:02.395]                             invokeRestart(restart)
[11:00:02.395]                             muffled <- TRUE
[11:00:02.395]                             break
[11:00:02.395]                           }
[11:00:02.395]                         }
[11:00:02.395]                       }
[11:00:02.395]                       invisible(muffled)
[11:00:02.395]                     }
[11:00:02.395]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.395]                   }
[11:00:02.395]                 }
[11:00:02.395]                 else {
[11:00:02.395]                   if (TRUE) {
[11:00:02.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.395]                     {
[11:00:02.395]                       inherits <- base::inherits
[11:00:02.395]                       invokeRestart <- base::invokeRestart
[11:00:02.395]                       is.null <- base::is.null
[11:00:02.395]                       muffled <- FALSE
[11:00:02.395]                       if (inherits(cond, "message")) {
[11:00:02.395]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.395]                         if (muffled) 
[11:00:02.395]                           invokeRestart("muffleMessage")
[11:00:02.395]                       }
[11:00:02.395]                       else if (inherits(cond, "warning")) {
[11:00:02.395]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.395]                         if (muffled) 
[11:00:02.395]                           invokeRestart("muffleWarning")
[11:00:02.395]                       }
[11:00:02.395]                       else if (inherits(cond, "condition")) {
[11:00:02.395]                         if (!is.null(pattern)) {
[11:00:02.395]                           computeRestarts <- base::computeRestarts
[11:00:02.395]                           grepl <- base::grepl
[11:00:02.395]                           restarts <- computeRestarts(cond)
[11:00:02.395]                           for (restart in restarts) {
[11:00:02.395]                             name <- restart$name
[11:00:02.395]                             if (is.null(name)) 
[11:00:02.395]                               next
[11:00:02.395]                             if (!grepl(pattern, name)) 
[11:00:02.395]                               next
[11:00:02.395]                             invokeRestart(restart)
[11:00:02.395]                             muffled <- TRUE
[11:00:02.395]                             break
[11:00:02.395]                           }
[11:00:02.395]                         }
[11:00:02.395]                       }
[11:00:02.395]                       invisible(muffled)
[11:00:02.395]                     }
[11:00:02.395]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.395]                   }
[11:00:02.395]                 }
[11:00:02.395]             }
[11:00:02.395]         }))
[11:00:02.395]     }, error = function(ex) {
[11:00:02.395]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:02.395]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.395]                 ...future.rng), started = ...future.startTime, 
[11:00:02.395]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:02.395]             version = "1.8"), class = "FutureResult")
[11:00:02.395]     }, finally = {
[11:00:02.395]         if (!identical(...future.workdir, getwd())) 
[11:00:02.395]             setwd(...future.workdir)
[11:00:02.395]         {
[11:00:02.395]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:02.395]                 ...future.oldOptions$nwarnings <- NULL
[11:00:02.395]             }
[11:00:02.395]             base::options(...future.oldOptions)
[11:00:02.395]             if (.Platform$OS.type == "windows") {
[11:00:02.395]                 old_names <- names(...future.oldEnvVars)
[11:00:02.395]                 envs <- base::Sys.getenv()
[11:00:02.395]                 names <- names(envs)
[11:00:02.395]                 common <- intersect(names, old_names)
[11:00:02.395]                 added <- setdiff(names, old_names)
[11:00:02.395]                 removed <- setdiff(old_names, names)
[11:00:02.395]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:02.395]                   envs[common]]
[11:00:02.395]                 NAMES <- toupper(changed)
[11:00:02.395]                 args <- list()
[11:00:02.395]                 for (kk in seq_along(NAMES)) {
[11:00:02.395]                   name <- changed[[kk]]
[11:00:02.395]                   NAME <- NAMES[[kk]]
[11:00:02.395]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.395]                     next
[11:00:02.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.395]                 }
[11:00:02.395]                 NAMES <- toupper(added)
[11:00:02.395]                 for (kk in seq_along(NAMES)) {
[11:00:02.395]                   name <- added[[kk]]
[11:00:02.395]                   NAME <- NAMES[[kk]]
[11:00:02.395]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.395]                     next
[11:00:02.395]                   args[[name]] <- ""
[11:00:02.395]                 }
[11:00:02.395]                 NAMES <- toupper(removed)
[11:00:02.395]                 for (kk in seq_along(NAMES)) {
[11:00:02.395]                   name <- removed[[kk]]
[11:00:02.395]                   NAME <- NAMES[[kk]]
[11:00:02.395]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.395]                     next
[11:00:02.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.395]                 }
[11:00:02.395]                 if (length(args) > 0) 
[11:00:02.395]                   base::do.call(base::Sys.setenv, args = args)
[11:00:02.395]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:02.395]             }
[11:00:02.395]             else {
[11:00:02.395]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:02.395]             }
[11:00:02.395]             {
[11:00:02.395]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:02.395]                   0L) {
[11:00:02.395]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:02.395]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:02.395]                   base::options(opts)
[11:00:02.395]                 }
[11:00:02.395]                 {
[11:00:02.395]                   {
[11:00:02.395]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:02.395]                     NULL
[11:00:02.395]                   }
[11:00:02.395]                   options(future.plan = NULL)
[11:00:02.395]                   if (is.na(NA_character_)) 
[11:00:02.395]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.395]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:02.395]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:02.395]                     .init = FALSE)
[11:00:02.395]                 }
[11:00:02.395]             }
[11:00:02.395]         }
[11:00:02.395]     })
[11:00:02.395]     if (TRUE) {
[11:00:02.395]         base::sink(type = "output", split = FALSE)
[11:00:02.395]         if (TRUE) {
[11:00:02.395]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:02.395]         }
[11:00:02.395]         else {
[11:00:02.395]             ...future.result["stdout"] <- base::list(NULL)
[11:00:02.395]         }
[11:00:02.395]         base::close(...future.stdout)
[11:00:02.395]         ...future.stdout <- NULL
[11:00:02.395]     }
[11:00:02.395]     ...future.result$conditions <- ...future.conditions
[11:00:02.395]     ...future.result$finished <- base::Sys.time()
[11:00:02.395]     ...future.result
[11:00:02.395] }
[11:00:02.398] assign_globals() ...
[11:00:02.399] List of 5
[11:00:02.399]  $ ...future.FUN            :function (x, y)  
[11:00:02.399]  $ future.call.arguments    :List of 1
[11:00:02.399]   ..$ y: num [1:5] 2 4 6 8 10
[11:00:02.399]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.399]  $ ...future.elements_ii    :List of 2
[11:00:02.399]   ..$ C: num 70
[11:00:02.399]   ..$ D: num 80
[11:00:02.399]  $ ...future.seeds_ii       : NULL
[11:00:02.399]  $ ...future.globals.maxSize: NULL
[11:00:02.399]  - attr(*, "where")=List of 5
[11:00:02.399]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:02.399]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:02.399]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:02.399]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:02.399]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:02.399]  - attr(*, "resolved")= logi FALSE
[11:00:02.399]  - attr(*, "total_size")= num 7318
[11:00:02.399]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.399]  - attr(*, "already-done")= logi TRUE
[11:00:02.411] - reassign environment for ‘...future.FUN’
[11:00:02.411] - copied ‘...future.FUN’ to environment
[11:00:02.411] - copied ‘future.call.arguments’ to environment
[11:00:02.411] - copied ‘...future.elements_ii’ to environment
[11:00:02.411] - copied ‘...future.seeds_ii’ to environment
[11:00:02.412] - copied ‘...future.globals.maxSize’ to environment
[11:00:02.412] assign_globals() ... done
[11:00:02.412] requestCore(): workers = 2
[11:00:02.415] MulticoreFuture started
[11:00:02.415] - Launch lazy future ... done
[11:00:02.416] plan(): Setting new future strategy stack:
[11:00:02.416] run() for ‘MulticoreFuture’ ... done
[11:00:02.416] Created future:
[11:00:02.416] List of future strategies:
[11:00:02.416] 1. sequential:
[11:00:02.416]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:02.416]    - tweaked: FALSE
[11:00:02.416]    - call: NULL
[11:00:02.418] plan(): nbrOfWorkers() = 1
[11:00:02.421] plan(): Setting new future strategy stack:
[11:00:02.421] List of future strategies:
[11:00:02.421] 1. multicore:
[11:00:02.421]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:02.421]    - tweaked: FALSE
[11:00:02.421]    - call: plan(strategy)
[11:00:02.425] plan(): nbrOfWorkers() = 2
[11:00:02.417] MulticoreFuture:
[11:00:02.417] Label: ‘future_sapply-2’
[11:00:02.417] Expression:
[11:00:02.417] {
[11:00:02.417]     do.call(function(...) {
[11:00:02.417]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.417]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.417]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.417]             on.exit(options(oopts), add = TRUE)
[11:00:02.417]         }
[11:00:02.417]         {
[11:00:02.417]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.417]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.417]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.417]             })
[11:00:02.417]         }
[11:00:02.417]     }, args = future.call.arguments)
[11:00:02.417] }
[11:00:02.417] Lazy evaluation: FALSE
[11:00:02.417] Asynchronous evaluation: TRUE
[11:00:02.417] Local evaluation: TRUE
[11:00:02.417] Environment: R_GlobalEnv
[11:00:02.417] Capture standard output: TRUE
[11:00:02.417] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:02.417] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 680 bytes, DotDotDotList ‘future.call.arguments’ of 183 bytes, list ‘...future.elements_ii’ of 114 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:02.417] Packages: <none>
[11:00:02.417] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:02.417] Resolved: TRUE
[11:00:02.417] Value: <not collected>
[11:00:02.417] Conditions captured: <none>
[11:00:02.417] Early signaling: FALSE
[11:00:02.417] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:02.417] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.426] Chunk #2 of 2 ... DONE
[11:00:02.426] Launching 2 futures (chunks) ... DONE
[11:00:02.427] Resolving 2 futures (chunks) ...
[11:00:02.427] resolve() on list ...
[11:00:02.427]  recursive: 0
[11:00:02.427]  length: 2
[11:00:02.427] 
[11:00:02.427] Future #1
[11:00:02.428] result() for MulticoreFuture ...
[11:00:02.429] result() for MulticoreFuture ...
[11:00:02.429] result() for MulticoreFuture ... done
[11:00:02.429] result() for MulticoreFuture ... done
[11:00:02.429] result() for MulticoreFuture ...
[11:00:02.429] result() for MulticoreFuture ... done
[11:00:02.429] signalConditionsASAP(MulticoreFuture, pos=1) ...
[11:00:02.429] - nx: 2
[11:00:02.430] - relay: TRUE
[11:00:02.430] - stdout: TRUE
[11:00:02.430] - signal: TRUE
[11:00:02.430] - resignal: FALSE
[11:00:02.430] - force: TRUE
[11:00:02.430] - relayed: [n=2] FALSE, FALSE
[11:00:02.431] - queued futures: [n=2] FALSE, FALSE
[11:00:02.431]  - until=1
[11:00:02.431]  - relaying element #1
[11:00:02.431] result() for MulticoreFuture ...
[11:00:02.431] result() for MulticoreFuture ... done
[11:00:02.431] result() for MulticoreFuture ...
[11:00:02.432] result() for MulticoreFuture ... done
[11:00:02.432] result() for MulticoreFuture ...
[11:00:02.432] result() for MulticoreFuture ... done
[11:00:02.432] result() for MulticoreFuture ...
[11:00:02.432] result() for MulticoreFuture ... done
[11:00:02.432] - relayed: [n=2] TRUE, FALSE
[11:00:02.432] - queued futures: [n=2] TRUE, FALSE
[11:00:02.433] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[11:00:02.433]  length: 1 (resolved future 1)
[11:00:02.433] Future #2
[11:00:02.433] result() for MulticoreFuture ...
[11:00:02.434] result() for MulticoreFuture ...
[11:00:02.434] result() for MulticoreFuture ... done
[11:00:02.434] result() for MulticoreFuture ... done
[11:00:02.435] result() for MulticoreFuture ...
[11:00:02.435] result() for MulticoreFuture ... done
[11:00:02.435] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:00:02.435] - nx: 2
[11:00:02.435] - relay: TRUE
[11:00:02.435] - stdout: TRUE
[11:00:02.435] - signal: TRUE
[11:00:02.435] - resignal: FALSE
[11:00:02.435] - force: TRUE
[11:00:02.436] - relayed: [n=2] TRUE, FALSE
[11:00:02.436] - queued futures: [n=2] TRUE, FALSE
[11:00:02.436]  - until=2
[11:00:02.436]  - relaying element #2
[11:00:02.436] result() for MulticoreFuture ...
[11:00:02.436] result() for MulticoreFuture ... done
[11:00:02.436] result() for MulticoreFuture ...
[11:00:02.436] result() for MulticoreFuture ... done
[11:00:02.437] result() for MulticoreFuture ...
[11:00:02.437] result() for MulticoreFuture ... done
[11:00:02.437] result() for MulticoreFuture ...
[11:00:02.437] result() for MulticoreFuture ... done
[11:00:02.437] - relayed: [n=2] TRUE, TRUE
[11:00:02.437] - queued futures: [n=2] TRUE, TRUE
[11:00:02.437] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:00:02.437]  length: 0 (resolved future 2)
[11:00:02.437] Relaying remaining futures
[11:00:02.437] signalConditionsASAP(NULL, pos=0) ...
[11:00:02.438] - nx: 2
[11:00:02.438] - relay: TRUE
[11:00:02.438] - stdout: TRUE
[11:00:02.438] - signal: TRUE
[11:00:02.438] - resignal: FALSE
[11:00:02.438] - force: TRUE
[11:00:02.438] - relayed: [n=2] TRUE, TRUE
[11:00:02.438] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:02.438] - relayed: [n=2] TRUE, TRUE
[11:00:02.439] - queued futures: [n=2] TRUE, TRUE
[11:00:02.439] signalConditionsASAP(NULL, pos=0) ... done
[11:00:02.439] resolve() on list ... DONE
[11:00:02.439] result() for MulticoreFuture ...
[11:00:02.439] result() for MulticoreFuture ... done
[11:00:02.439] result() for MulticoreFuture ...
[11:00:02.439] result() for MulticoreFuture ... done
[11:00:02.439] result() for MulticoreFuture ...
[11:00:02.439] result() for MulticoreFuture ... done
[11:00:02.439] result() for MulticoreFuture ...
[11:00:02.440] result() for MulticoreFuture ... done
[11:00:02.440]  - Number of value chunks collected: 2
[11:00:02.440] Resolving 2 futures (chunks) ... DONE
[11:00:02.440] Reducing values from 2 chunks ...
[11:00:02.440]  - Number of values collected after concatenation: 4
[11:00:02.440]  - Number of values expected: 4
[11:00:02.440] Reducing values from 2 chunks ... DONE
[11:00:02.440] future_lapply() ... DONE
[11:00:02.441] future_lapply() ...
[11:00:02.447] Number of chunks: 2
[11:00:02.448] getGlobalsAndPackagesXApply() ...
[11:00:02.448]  - future.globals: TRUE
[11:00:02.448] getGlobalsAndPackages() ...
[11:00:02.448] Searching for globals...
[11:00:02.453] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[11:00:02.453] Searching for globals ... DONE
[11:00:02.453] Resolving globals: FALSE
[11:00:02.454] The total size of the 7 globals is 14.32 KiB (14666 bytes)
[11:00:02.455] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 14.32 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.67 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:02.455] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:02.455] - packages: [1] ‘future.apply’
[11:00:02.455] getGlobalsAndPackages() ... DONE
[11:00:02.455]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:02.455]  - needed namespaces: [n=1] ‘future.apply’
[11:00:02.455] Finding globals ... DONE
[11:00:02.455]  - use_args: TRUE
[11:00:02.456]  - Getting '...' globals ...
[11:00:02.456] resolve() on list ...
[11:00:02.456]  recursive: 0
[11:00:02.456]  length: 1
[11:00:02.456]  elements: ‘...’
[11:00:02.456]  length: 0 (resolved future 1)
[11:00:02.456] resolve() on list ... DONE
[11:00:02.456]    - '...' content: [n=1] ‘y’
[11:00:02.457] List of 1
[11:00:02.457]  $ ...:List of 1
[11:00:02.457]   ..$ y: num [1:5] 2 4 6 8 10
[11:00:02.457]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.457]  - attr(*, "where")=List of 1
[11:00:02.457]   ..$ ...:<environment: 0x55bbad44d6f0> 
[11:00:02.457]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.457]  - attr(*, "resolved")= logi TRUE
[11:00:02.457]  - attr(*, "total_size")= num NA
[11:00:02.460]  - Getting '...' globals ... DONE
[11:00:02.460] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:02.460] List of 8
[11:00:02.460]  $ ...future.FUN:function (x, ...)  
[11:00:02.460]  $ x_FUN        :function (x, y)  
[11:00:02.460]  $ times        : int 15
[11:00:02.460]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:02.460]  $ stop_if_not  :function (...)  
[11:00:02.460]  $ dim          : int [1:2] 3 5
[11:00:02.460]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:02.460]  $ ...          :List of 1
[11:00:02.460]   ..$ y: num [1:5] 2 4 6 8 10
[11:00:02.460]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.460]  - attr(*, "where")=List of 8
[11:00:02.460]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:02.460]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:02.460]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:02.460]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:02.460]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:02.460]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:02.460]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:02.460]   ..$ ...          :<environment: 0x55bbad44d6f0> 
[11:00:02.460]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.460]  - attr(*, "resolved")= logi FALSE
[11:00:02.460]  - attr(*, "total_size")= num 26659
[11:00:02.470] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:02.471] getGlobalsAndPackagesXApply() ... DONE
[11:00:02.471] Number of futures (= number of chunks): 2
[11:00:02.471] Launching 2 futures (chunks) ...
[11:00:02.471] Chunk #1 of 2 ...
[11:00:02.472]  - Finding globals in 'X' for chunk #1 ...
[11:00:02.472] getGlobalsAndPackages() ...
[11:00:02.472] Searching for globals...
[11:00:02.472] 
[11:00:02.472] Searching for globals ... DONE
[11:00:02.473] - globals: [0] <none>
[11:00:02.473] getGlobalsAndPackages() ... DONE
[11:00:02.473]    + additional globals found: [n=0] 
[11:00:02.473]    + additional namespaces needed: [n=0] 
[11:00:02.473]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:02.473]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:02.474]  - seeds: <none>
[11:00:02.474]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.474] getGlobalsAndPackages() ...
[11:00:02.474] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.474] Resolving globals: FALSE
[11:00:02.474] Tweak future expression to call with '...' arguments ...
[11:00:02.475] {
[11:00:02.475]     do.call(function(...) {
[11:00:02.475]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.475]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.475]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.475]             on.exit(options(oopts), add = TRUE)
[11:00:02.475]         }
[11:00:02.475]         {
[11:00:02.475]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.475]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.475]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.475]             })
[11:00:02.475]         }
[11:00:02.475]     }, args = future.call.arguments)
[11:00:02.475] }
[11:00:02.475] Tweak future expression to call with '...' arguments ... DONE
[11:00:02.475] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.476] - packages: [1] ‘future.apply’
[11:00:02.476] getGlobalsAndPackages() ... DONE
[11:00:02.476] run() for ‘Future’ ...
[11:00:02.476] - state: ‘created’
[11:00:02.476] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:02.478] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.479] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:02.479]   - Field: ‘label’
[11:00:02.479]   - Field: ‘local’
[11:00:02.479]   - Field: ‘owner’
[11:00:02.479]   - Field: ‘envir’
[11:00:02.479]   - Field: ‘workers’
[11:00:02.479]   - Field: ‘packages’
[11:00:02.479]   - Field: ‘gc’
[11:00:02.480]   - Field: ‘job’
[11:00:02.480]   - Field: ‘conditions’
[11:00:02.480]   - Field: ‘expr’
[11:00:02.480]   - Field: ‘uuid’
[11:00:02.480]   - Field: ‘seed’
[11:00:02.480]   - Field: ‘version’
[11:00:02.480]   - Field: ‘result’
[11:00:02.480]   - Field: ‘asynchronous’
[11:00:02.480]   - Field: ‘calls’
[11:00:02.480]   - Field: ‘globals’
[11:00:02.480]   - Field: ‘stdout’
[11:00:02.480]   - Field: ‘earlySignal’
[11:00:02.481]   - Field: ‘lazy’
[11:00:02.481]   - Field: ‘state’
[11:00:02.481] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:02.481] - Launch lazy future ...
[11:00:02.481] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:02.481] Packages needed by future strategies (n = 0): <none>
[11:00:02.482] {
[11:00:02.482]     {
[11:00:02.482]         {
[11:00:02.482]             ...future.startTime <- base::Sys.time()
[11:00:02.482]             {
[11:00:02.482]                 {
[11:00:02.482]                   {
[11:00:02.482]                     {
[11:00:02.482]                       {
[11:00:02.482]                         base::local({
[11:00:02.482]                           has_future <- base::requireNamespace("future", 
[11:00:02.482]                             quietly = TRUE)
[11:00:02.482]                           if (has_future) {
[11:00:02.482]                             ns <- base::getNamespace("future")
[11:00:02.482]                             version <- ns[[".package"]][["version"]]
[11:00:02.482]                             if (is.null(version)) 
[11:00:02.482]                               version <- utils::packageVersion("future")
[11:00:02.482]                           }
[11:00:02.482]                           else {
[11:00:02.482]                             version <- NULL
[11:00:02.482]                           }
[11:00:02.482]                           if (!has_future || version < "1.8.0") {
[11:00:02.482]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:02.482]                               "", base::R.version$version.string), 
[11:00:02.482]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:02.482]                                 base::R.version$platform, 8 * 
[11:00:02.482]                                   base::.Machine$sizeof.pointer), 
[11:00:02.482]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:02.482]                                 "release", "version")], collapse = " "), 
[11:00:02.482]                               hostname = base::Sys.info()[["nodename"]])
[11:00:02.482]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:02.482]                               info)
[11:00:02.482]                             info <- base::paste(info, collapse = "; ")
[11:00:02.482]                             if (!has_future) {
[11:00:02.482]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:02.482]                                 info)
[11:00:02.482]                             }
[11:00:02.482]                             else {
[11:00:02.482]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:02.482]                                 info, version)
[11:00:02.482]                             }
[11:00:02.482]                             base::stop(msg)
[11:00:02.482]                           }
[11:00:02.482]                         })
[11:00:02.482]                       }
[11:00:02.482]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:02.482]                       base::options(mc.cores = 1L)
[11:00:02.482]                     }
[11:00:02.482]                     base::local({
[11:00:02.482]                       for (pkg in "future.apply") {
[11:00:02.482]                         base::loadNamespace(pkg)
[11:00:02.482]                         base::library(pkg, character.only = TRUE)
[11:00:02.482]                       }
[11:00:02.482]                     })
[11:00:02.482]                   }
[11:00:02.482]                   ...future.strategy.old <- future::plan("list")
[11:00:02.482]                   options(future.plan = NULL)
[11:00:02.482]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.482]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:02.482]                 }
[11:00:02.482]                 ...future.workdir <- getwd()
[11:00:02.482]             }
[11:00:02.482]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:02.482]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:02.482]         }
[11:00:02.482]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:02.482]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:02.482]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:02.482]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:02.482]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:02.482]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:02.482]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:02.482]             base::names(...future.oldOptions))
[11:00:02.482]     }
[11:00:02.482]     if (FALSE) {
[11:00:02.482]     }
[11:00:02.482]     else {
[11:00:02.482]         if (TRUE) {
[11:00:02.482]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:02.482]                 open = "w")
[11:00:02.482]         }
[11:00:02.482]         else {
[11:00:02.482]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:02.482]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:02.482]         }
[11:00:02.482]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:02.482]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:02.482]             base::sink(type = "output", split = FALSE)
[11:00:02.482]             base::close(...future.stdout)
[11:00:02.482]         }, add = TRUE)
[11:00:02.482]     }
[11:00:02.482]     ...future.frame <- base::sys.nframe()
[11:00:02.482]     ...future.conditions <- base::list()
[11:00:02.482]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:02.482]     if (FALSE) {
[11:00:02.482]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:02.482]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:02.482]     }
[11:00:02.482]     ...future.result <- base::tryCatch({
[11:00:02.482]         base::withCallingHandlers({
[11:00:02.482]             ...future.value <- base::withVisible(base::local({
[11:00:02.482]                 withCallingHandlers({
[11:00:02.482]                   {
[11:00:02.482]                     do.call(function(...) {
[11:00:02.482]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.482]                       if (!identical(...future.globals.maxSize.org, 
[11:00:02.482]                         ...future.globals.maxSize)) {
[11:00:02.482]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.482]                         on.exit(options(oopts), add = TRUE)
[11:00:02.482]                       }
[11:00:02.482]                       {
[11:00:02.482]                         lapply(seq_along(...future.elements_ii), 
[11:00:02.482]                           FUN = function(jj) {
[11:00:02.482]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.482]                             ...future.FUN(...future.X_jj, ...)
[11:00:02.482]                           })
[11:00:02.482]                       }
[11:00:02.482]                     }, args = future.call.arguments)
[11:00:02.482]                   }
[11:00:02.482]                 }, immediateCondition = function(cond) {
[11:00:02.482]                   save_rds <- function (object, pathname, ...) 
[11:00:02.482]                   {
[11:00:02.482]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:02.482]                     if (file_test("-f", pathname_tmp)) {
[11:00:02.482]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.482]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:02.482]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.482]                         fi_tmp[["mtime"]])
[11:00:02.482]                     }
[11:00:02.482]                     tryCatch({
[11:00:02.482]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:02.482]                     }, error = function(ex) {
[11:00:02.482]                       msg <- conditionMessage(ex)
[11:00:02.482]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.482]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:02.482]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.482]                         fi_tmp[["mtime"]], msg)
[11:00:02.482]                       ex$message <- msg
[11:00:02.482]                       stop(ex)
[11:00:02.482]                     })
[11:00:02.482]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:02.482]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:02.482]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:02.482]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.482]                       fi <- file.info(pathname)
[11:00:02.482]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:02.482]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.482]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:02.482]                         fi[["size"]], fi[["mtime"]])
[11:00:02.482]                       stop(msg)
[11:00:02.482]                     }
[11:00:02.482]                     invisible(pathname)
[11:00:02.482]                   }
[11:00:02.482]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:02.482]                     rootPath = tempdir()) 
[11:00:02.482]                   {
[11:00:02.482]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:02.482]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:02.482]                       tmpdir = path, fileext = ".rds")
[11:00:02.482]                     save_rds(obj, file)
[11:00:02.482]                   }
[11:00:02.482]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:02.482]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.482]                   {
[11:00:02.482]                     inherits <- base::inherits
[11:00:02.482]                     invokeRestart <- base::invokeRestart
[11:00:02.482]                     is.null <- base::is.null
[11:00:02.482]                     muffled <- FALSE
[11:00:02.482]                     if (inherits(cond, "message")) {
[11:00:02.482]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:02.482]                       if (muffled) 
[11:00:02.482]                         invokeRestart("muffleMessage")
[11:00:02.482]                     }
[11:00:02.482]                     else if (inherits(cond, "warning")) {
[11:00:02.482]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:02.482]                       if (muffled) 
[11:00:02.482]                         invokeRestart("muffleWarning")
[11:00:02.482]                     }
[11:00:02.482]                     else if (inherits(cond, "condition")) {
[11:00:02.482]                       if (!is.null(pattern)) {
[11:00:02.482]                         computeRestarts <- base::computeRestarts
[11:00:02.482]                         grepl <- base::grepl
[11:00:02.482]                         restarts <- computeRestarts(cond)
[11:00:02.482]                         for (restart in restarts) {
[11:00:02.482]                           name <- restart$name
[11:00:02.482]                           if (is.null(name)) 
[11:00:02.482]                             next
[11:00:02.482]                           if (!grepl(pattern, name)) 
[11:00:02.482]                             next
[11:00:02.482]                           invokeRestart(restart)
[11:00:02.482]                           muffled <- TRUE
[11:00:02.482]                           break
[11:00:02.482]                         }
[11:00:02.482]                       }
[11:00:02.482]                     }
[11:00:02.482]                     invisible(muffled)
[11:00:02.482]                   }
[11:00:02.482]                   muffleCondition(cond)
[11:00:02.482]                 })
[11:00:02.482]             }))
[11:00:02.482]             future::FutureResult(value = ...future.value$value, 
[11:00:02.482]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.482]                   ...future.rng), globalenv = if (FALSE) 
[11:00:02.482]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:02.482]                     ...future.globalenv.names))
[11:00:02.482]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:02.482]         }, condition = base::local({
[11:00:02.482]             c <- base::c
[11:00:02.482]             inherits <- base::inherits
[11:00:02.482]             invokeRestart <- base::invokeRestart
[11:00:02.482]             length <- base::length
[11:00:02.482]             list <- base::list
[11:00:02.482]             seq.int <- base::seq.int
[11:00:02.482]             signalCondition <- base::signalCondition
[11:00:02.482]             sys.calls <- base::sys.calls
[11:00:02.482]             `[[` <- base::`[[`
[11:00:02.482]             `+` <- base::`+`
[11:00:02.482]             `<<-` <- base::`<<-`
[11:00:02.482]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:02.482]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:02.482]                   3L)]
[11:00:02.482]             }
[11:00:02.482]             function(cond) {
[11:00:02.482]                 is_error <- inherits(cond, "error")
[11:00:02.482]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:02.482]                   NULL)
[11:00:02.482]                 if (is_error) {
[11:00:02.482]                   sessionInformation <- function() {
[11:00:02.482]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:02.482]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:02.482]                       search = base::search(), system = base::Sys.info())
[11:00:02.482]                   }
[11:00:02.482]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.482]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:02.482]                     cond$call), session = sessionInformation(), 
[11:00:02.482]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:02.482]                   signalCondition(cond)
[11:00:02.482]                 }
[11:00:02.482]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:02.482]                 "immediateCondition"))) {
[11:00:02.482]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:02.482]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.482]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:02.482]                   if (TRUE && !signal) {
[11:00:02.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.482]                     {
[11:00:02.482]                       inherits <- base::inherits
[11:00:02.482]                       invokeRestart <- base::invokeRestart
[11:00:02.482]                       is.null <- base::is.null
[11:00:02.482]                       muffled <- FALSE
[11:00:02.482]                       if (inherits(cond, "message")) {
[11:00:02.482]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.482]                         if (muffled) 
[11:00:02.482]                           invokeRestart("muffleMessage")
[11:00:02.482]                       }
[11:00:02.482]                       else if (inherits(cond, "warning")) {
[11:00:02.482]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.482]                         if (muffled) 
[11:00:02.482]                           invokeRestart("muffleWarning")
[11:00:02.482]                       }
[11:00:02.482]                       else if (inherits(cond, "condition")) {
[11:00:02.482]                         if (!is.null(pattern)) {
[11:00:02.482]                           computeRestarts <- base::computeRestarts
[11:00:02.482]                           grepl <- base::grepl
[11:00:02.482]                           restarts <- computeRestarts(cond)
[11:00:02.482]                           for (restart in restarts) {
[11:00:02.482]                             name <- restart$name
[11:00:02.482]                             if (is.null(name)) 
[11:00:02.482]                               next
[11:00:02.482]                             if (!grepl(pattern, name)) 
[11:00:02.482]                               next
[11:00:02.482]                             invokeRestart(restart)
[11:00:02.482]                             muffled <- TRUE
[11:00:02.482]                             break
[11:00:02.482]                           }
[11:00:02.482]                         }
[11:00:02.482]                       }
[11:00:02.482]                       invisible(muffled)
[11:00:02.482]                     }
[11:00:02.482]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.482]                   }
[11:00:02.482]                 }
[11:00:02.482]                 else {
[11:00:02.482]                   if (TRUE) {
[11:00:02.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.482]                     {
[11:00:02.482]                       inherits <- base::inherits
[11:00:02.482]                       invokeRestart <- base::invokeRestart
[11:00:02.482]                       is.null <- base::is.null
[11:00:02.482]                       muffled <- FALSE
[11:00:02.482]                       if (inherits(cond, "message")) {
[11:00:02.482]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.482]                         if (muffled) 
[11:00:02.482]                           invokeRestart("muffleMessage")
[11:00:02.482]                       }
[11:00:02.482]                       else if (inherits(cond, "warning")) {
[11:00:02.482]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.482]                         if (muffled) 
[11:00:02.482]                           invokeRestart("muffleWarning")
[11:00:02.482]                       }
[11:00:02.482]                       else if (inherits(cond, "condition")) {
[11:00:02.482]                         if (!is.null(pattern)) {
[11:00:02.482]                           computeRestarts <- base::computeRestarts
[11:00:02.482]                           grepl <- base::grepl
[11:00:02.482]                           restarts <- computeRestarts(cond)
[11:00:02.482]                           for (restart in restarts) {
[11:00:02.482]                             name <- restart$name
[11:00:02.482]                             if (is.null(name)) 
[11:00:02.482]                               next
[11:00:02.482]                             if (!grepl(pattern, name)) 
[11:00:02.482]                               next
[11:00:02.482]                             invokeRestart(restart)
[11:00:02.482]                             muffled <- TRUE
[11:00:02.482]                             break
[11:00:02.482]                           }
[11:00:02.482]                         }
[11:00:02.482]                       }
[11:00:02.482]                       invisible(muffled)
[11:00:02.482]                     }
[11:00:02.482]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.482]                   }
[11:00:02.482]                 }
[11:00:02.482]             }
[11:00:02.482]         }))
[11:00:02.482]     }, error = function(ex) {
[11:00:02.482]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:02.482]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.482]                 ...future.rng), started = ...future.startTime, 
[11:00:02.482]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:02.482]             version = "1.8"), class = "FutureResult")
[11:00:02.482]     }, finally = {
[11:00:02.482]         if (!identical(...future.workdir, getwd())) 
[11:00:02.482]             setwd(...future.workdir)
[11:00:02.482]         {
[11:00:02.482]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:02.482]                 ...future.oldOptions$nwarnings <- NULL
[11:00:02.482]             }
[11:00:02.482]             base::options(...future.oldOptions)
[11:00:02.482]             if (.Platform$OS.type == "windows") {
[11:00:02.482]                 old_names <- names(...future.oldEnvVars)
[11:00:02.482]                 envs <- base::Sys.getenv()
[11:00:02.482]                 names <- names(envs)
[11:00:02.482]                 common <- intersect(names, old_names)
[11:00:02.482]                 added <- setdiff(names, old_names)
[11:00:02.482]                 removed <- setdiff(old_names, names)
[11:00:02.482]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:02.482]                   envs[common]]
[11:00:02.482]                 NAMES <- toupper(changed)
[11:00:02.482]                 args <- list()
[11:00:02.482]                 for (kk in seq_along(NAMES)) {
[11:00:02.482]                   name <- changed[[kk]]
[11:00:02.482]                   NAME <- NAMES[[kk]]
[11:00:02.482]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.482]                     next
[11:00:02.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.482]                 }
[11:00:02.482]                 NAMES <- toupper(added)
[11:00:02.482]                 for (kk in seq_along(NAMES)) {
[11:00:02.482]                   name <- added[[kk]]
[11:00:02.482]                   NAME <- NAMES[[kk]]
[11:00:02.482]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.482]                     next
[11:00:02.482]                   args[[name]] <- ""
[11:00:02.482]                 }
[11:00:02.482]                 NAMES <- toupper(removed)
[11:00:02.482]                 for (kk in seq_along(NAMES)) {
[11:00:02.482]                   name <- removed[[kk]]
[11:00:02.482]                   NAME <- NAMES[[kk]]
[11:00:02.482]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.482]                     next
[11:00:02.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.482]                 }
[11:00:02.482]                 if (length(args) > 0) 
[11:00:02.482]                   base::do.call(base::Sys.setenv, args = args)
[11:00:02.482]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:02.482]             }
[11:00:02.482]             else {
[11:00:02.482]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:02.482]             }
[11:00:02.482]             {
[11:00:02.482]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:02.482]                   0L) {
[11:00:02.482]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:02.482]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:02.482]                   base::options(opts)
[11:00:02.482]                 }
[11:00:02.482]                 {
[11:00:02.482]                   {
[11:00:02.482]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:02.482]                     NULL
[11:00:02.482]                   }
[11:00:02.482]                   options(future.plan = NULL)
[11:00:02.482]                   if (is.na(NA_character_)) 
[11:00:02.482]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.482]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:02.482]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:02.482]                     .init = FALSE)
[11:00:02.482]                 }
[11:00:02.482]             }
[11:00:02.482]         }
[11:00:02.482]     })
[11:00:02.482]     if (TRUE) {
[11:00:02.482]         base::sink(type = "output", split = FALSE)
[11:00:02.482]         if (TRUE) {
[11:00:02.482]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:02.482]         }
[11:00:02.482]         else {
[11:00:02.482]             ...future.result["stdout"] <- base::list(NULL)
[11:00:02.482]         }
[11:00:02.482]         base::close(...future.stdout)
[11:00:02.482]         ...future.stdout <- NULL
[11:00:02.482]     }
[11:00:02.482]     ...future.result$conditions <- ...future.conditions
[11:00:02.482]     ...future.result$finished <- base::Sys.time()
[11:00:02.482]     ...future.result
[11:00:02.482] }
[11:00:02.484] assign_globals() ...
[11:00:02.485] List of 11
[11:00:02.485]  $ ...future.FUN            :function (x, ...)  
[11:00:02.485]  $ x_FUN                    :function (x, y)  
[11:00:02.485]  $ times                    : int 15
[11:00:02.485]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:02.485]  $ stop_if_not              :function (...)  
[11:00:02.485]  $ dim                      : int [1:2] 3 5
[11:00:02.485]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:02.485]  $ future.call.arguments    :List of 1
[11:00:02.485]   ..$ y: num [1:5] 2 4 6 8 10
[11:00:02.485]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.485]  $ ...future.elements_ii    :List of 2
[11:00:02.485]   ..$ A: num 50
[11:00:02.485]   ..$ B: num 60
[11:00:02.485]  $ ...future.seeds_ii       : NULL
[11:00:02.485]  $ ...future.globals.maxSize: NULL
[11:00:02.485]  - attr(*, "where")=List of 11
[11:00:02.485]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:02.485]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:02.485]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:02.485]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:02.485]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:02.485]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:02.485]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:02.485]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:02.485]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:02.485]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:02.485]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:02.485]  - attr(*, "resolved")= logi FALSE
[11:00:02.485]  - attr(*, "total_size")= num 26659
[11:00:02.485]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.485]  - attr(*, "already-done")= logi TRUE
[11:00:02.493] - copied ‘...future.FUN’ to environment
[11:00:02.493] - reassign environment for ‘x_FUN’
[11:00:02.493] - copied ‘x_FUN’ to environment
[11:00:02.495] - copied ‘times’ to environment
[11:00:02.495] - copied ‘stopf’ to environment
[11:00:02.495] - copied ‘stop_if_not’ to environment
[11:00:02.495] - copied ‘dim’ to environment
[11:00:02.496] - copied ‘valid_types’ to environment
[11:00:02.496] - copied ‘future.call.arguments’ to environment
[11:00:02.496] - copied ‘...future.elements_ii’ to environment
[11:00:02.496] - copied ‘...future.seeds_ii’ to environment
[11:00:02.496] - copied ‘...future.globals.maxSize’ to environment
[11:00:02.496] assign_globals() ... done
[11:00:02.496] requestCore(): workers = 2
[11:00:02.499] MulticoreFuture started
[11:00:02.499] - Launch lazy future ... done
[11:00:02.500] run() for ‘MulticoreFuture’ ... done
[11:00:02.500] Created future:
[11:00:02.501] plan(): Setting new future strategy stack:
[11:00:02.501] List of future strategies:
[11:00:02.501] 1. sequential:
[11:00:02.501]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:02.501]    - tweaked: FALSE
[11:00:02.501]    - call: NULL
[11:00:02.503] plan(): nbrOfWorkers() = 1
[11:00:02.506] plan(): Setting new future strategy stack:
[11:00:02.507] List of future strategies:
[11:00:02.507] 1. multicore:
[11:00:02.507]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:02.507]    - tweaked: FALSE
[11:00:02.507]    - call: plan(strategy)
[11:00:02.511] plan(): nbrOfWorkers() = 2
[11:00:02.501] MulticoreFuture:
[11:00:02.501] Label: ‘future_vapply-1’
[11:00:02.501] Expression:
[11:00:02.501] {
[11:00:02.501]     do.call(function(...) {
[11:00:02.501]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.501]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.501]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.501]             on.exit(options(oopts), add = TRUE)
[11:00:02.501]         }
[11:00:02.501]         {
[11:00:02.501]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.501]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.501]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.501]             })
[11:00:02.501]         }
[11:00:02.501]     }, args = future.call.arguments)
[11:00:02.501] }
[11:00:02.501] Lazy evaluation: FALSE
[11:00:02.501] Asynchronous evaluation: TRUE
[11:00:02.501] Local evaluation: TRUE
[11:00:02.501] Environment: R_GlobalEnv
[11:00:02.501] Capture standard output: TRUE
[11:00:02.501] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:02.501] Globals: 11 objects totaling 14.66 KiB (function ‘...future.FUN’ of 5.67 KiB, function ‘x_FUN’ of 680 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:02.501] Packages: 1 packages (‘future.apply’)
[11:00:02.501] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:02.501] Resolved: TRUE
[11:00:02.501] Value: <not collected>
[11:00:02.501] Conditions captured: <none>
[11:00:02.501] Early signaling: FALSE
[11:00:02.501] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:02.501] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.512] Chunk #1 of 2 ... DONE
[11:00:02.513] Chunk #2 of 2 ...
[11:00:02.513]  - Finding globals in 'X' for chunk #2 ...
[11:00:02.513] getGlobalsAndPackages() ...
[11:00:02.513] Searching for globals...
[11:00:02.514] 
[11:00:02.514] Searching for globals ... DONE
[11:00:02.514] - globals: [0] <none>
[11:00:02.514] getGlobalsAndPackages() ... DONE
[11:00:02.515]    + additional globals found: [n=0] 
[11:00:02.515]    + additional namespaces needed: [n=0] 
[11:00:02.515]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:02.515]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:02.515]  - seeds: <none>
[11:00:02.515]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.516] getGlobalsAndPackages() ...
[11:00:02.516] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.516] Resolving globals: FALSE
[11:00:02.516] Tweak future expression to call with '...' arguments ...
[11:00:02.517] {
[11:00:02.517]     do.call(function(...) {
[11:00:02.517]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.517]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.517]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.517]             on.exit(options(oopts), add = TRUE)
[11:00:02.517]         }
[11:00:02.517]         {
[11:00:02.517]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.517]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.517]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.517]             })
[11:00:02.517]         }
[11:00:02.517]     }, args = future.call.arguments)
[11:00:02.517] }
[11:00:02.517] Tweak future expression to call with '...' arguments ... DONE
[11:00:02.519] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.519] - packages: [1] ‘future.apply’
[11:00:02.519] getGlobalsAndPackages() ... DONE
[11:00:02.520] run() for ‘Future’ ...
[11:00:02.520] - state: ‘created’
[11:00:02.520] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:02.523] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.523] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:02.524]   - Field: ‘label’
[11:00:02.524]   - Field: ‘local’
[11:00:02.524]   - Field: ‘owner’
[11:00:02.524]   - Field: ‘envir’
[11:00:02.524]   - Field: ‘workers’
[11:00:02.524]   - Field: ‘packages’
[11:00:02.524]   - Field: ‘gc’
[11:00:02.525]   - Field: ‘job’
[11:00:02.525]   - Field: ‘conditions’
[11:00:02.525]   - Field: ‘expr’
[11:00:02.525]   - Field: ‘uuid’
[11:00:02.525]   - Field: ‘seed’
[11:00:02.526]   - Field: ‘version’
[11:00:02.526]   - Field: ‘result’
[11:00:02.526]   - Field: ‘asynchronous’
[11:00:02.526]   - Field: ‘calls’
[11:00:02.526]   - Field: ‘globals’
[11:00:02.526]   - Field: ‘stdout’
[11:00:02.526]   - Field: ‘earlySignal’
[11:00:02.527]   - Field: ‘lazy’
[11:00:02.527]   - Field: ‘state’
[11:00:02.527] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:02.527] - Launch lazy future ...
[11:00:02.527] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:02.527] Packages needed by future strategies (n = 0): <none>
[11:00:02.528] {
[11:00:02.528]     {
[11:00:02.528]         {
[11:00:02.528]             ...future.startTime <- base::Sys.time()
[11:00:02.528]             {
[11:00:02.528]                 {
[11:00:02.528]                   {
[11:00:02.528]                     {
[11:00:02.528]                       {
[11:00:02.528]                         base::local({
[11:00:02.528]                           has_future <- base::requireNamespace("future", 
[11:00:02.528]                             quietly = TRUE)
[11:00:02.528]                           if (has_future) {
[11:00:02.528]                             ns <- base::getNamespace("future")
[11:00:02.528]                             version <- ns[[".package"]][["version"]]
[11:00:02.528]                             if (is.null(version)) 
[11:00:02.528]                               version <- utils::packageVersion("future")
[11:00:02.528]                           }
[11:00:02.528]                           else {
[11:00:02.528]                             version <- NULL
[11:00:02.528]                           }
[11:00:02.528]                           if (!has_future || version < "1.8.0") {
[11:00:02.528]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:02.528]                               "", base::R.version$version.string), 
[11:00:02.528]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:02.528]                                 base::R.version$platform, 8 * 
[11:00:02.528]                                   base::.Machine$sizeof.pointer), 
[11:00:02.528]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:02.528]                                 "release", "version")], collapse = " "), 
[11:00:02.528]                               hostname = base::Sys.info()[["nodename"]])
[11:00:02.528]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:02.528]                               info)
[11:00:02.528]                             info <- base::paste(info, collapse = "; ")
[11:00:02.528]                             if (!has_future) {
[11:00:02.528]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:02.528]                                 info)
[11:00:02.528]                             }
[11:00:02.528]                             else {
[11:00:02.528]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:02.528]                                 info, version)
[11:00:02.528]                             }
[11:00:02.528]                             base::stop(msg)
[11:00:02.528]                           }
[11:00:02.528]                         })
[11:00:02.528]                       }
[11:00:02.528]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:02.528]                       base::options(mc.cores = 1L)
[11:00:02.528]                     }
[11:00:02.528]                     base::local({
[11:00:02.528]                       for (pkg in "future.apply") {
[11:00:02.528]                         base::loadNamespace(pkg)
[11:00:02.528]                         base::library(pkg, character.only = TRUE)
[11:00:02.528]                       }
[11:00:02.528]                     })
[11:00:02.528]                   }
[11:00:02.528]                   ...future.strategy.old <- future::plan("list")
[11:00:02.528]                   options(future.plan = NULL)
[11:00:02.528]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.528]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:02.528]                 }
[11:00:02.528]                 ...future.workdir <- getwd()
[11:00:02.528]             }
[11:00:02.528]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:02.528]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:02.528]         }
[11:00:02.528]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:02.528]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:02.528]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:02.528]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:02.528]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:02.528]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:02.528]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:02.528]             base::names(...future.oldOptions))
[11:00:02.528]     }
[11:00:02.528]     if (FALSE) {
[11:00:02.528]     }
[11:00:02.528]     else {
[11:00:02.528]         if (TRUE) {
[11:00:02.528]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:02.528]                 open = "w")
[11:00:02.528]         }
[11:00:02.528]         else {
[11:00:02.528]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:02.528]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:02.528]         }
[11:00:02.528]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:02.528]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:02.528]             base::sink(type = "output", split = FALSE)
[11:00:02.528]             base::close(...future.stdout)
[11:00:02.528]         }, add = TRUE)
[11:00:02.528]     }
[11:00:02.528]     ...future.frame <- base::sys.nframe()
[11:00:02.528]     ...future.conditions <- base::list()
[11:00:02.528]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:02.528]     if (FALSE) {
[11:00:02.528]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:02.528]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:02.528]     }
[11:00:02.528]     ...future.result <- base::tryCatch({
[11:00:02.528]         base::withCallingHandlers({
[11:00:02.528]             ...future.value <- base::withVisible(base::local({
[11:00:02.528]                 withCallingHandlers({
[11:00:02.528]                   {
[11:00:02.528]                     do.call(function(...) {
[11:00:02.528]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.528]                       if (!identical(...future.globals.maxSize.org, 
[11:00:02.528]                         ...future.globals.maxSize)) {
[11:00:02.528]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.528]                         on.exit(options(oopts), add = TRUE)
[11:00:02.528]                       }
[11:00:02.528]                       {
[11:00:02.528]                         lapply(seq_along(...future.elements_ii), 
[11:00:02.528]                           FUN = function(jj) {
[11:00:02.528]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.528]                             ...future.FUN(...future.X_jj, ...)
[11:00:02.528]                           })
[11:00:02.528]                       }
[11:00:02.528]                     }, args = future.call.arguments)
[11:00:02.528]                   }
[11:00:02.528]                 }, immediateCondition = function(cond) {
[11:00:02.528]                   save_rds <- function (object, pathname, ...) 
[11:00:02.528]                   {
[11:00:02.528]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:02.528]                     if (file_test("-f", pathname_tmp)) {
[11:00:02.528]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.528]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:02.528]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.528]                         fi_tmp[["mtime"]])
[11:00:02.528]                     }
[11:00:02.528]                     tryCatch({
[11:00:02.528]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:02.528]                     }, error = function(ex) {
[11:00:02.528]                       msg <- conditionMessage(ex)
[11:00:02.528]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.528]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:02.528]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.528]                         fi_tmp[["mtime"]], msg)
[11:00:02.528]                       ex$message <- msg
[11:00:02.528]                       stop(ex)
[11:00:02.528]                     })
[11:00:02.528]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:02.528]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:02.528]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:02.528]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.528]                       fi <- file.info(pathname)
[11:00:02.528]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:02.528]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.528]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:02.528]                         fi[["size"]], fi[["mtime"]])
[11:00:02.528]                       stop(msg)
[11:00:02.528]                     }
[11:00:02.528]                     invisible(pathname)
[11:00:02.528]                   }
[11:00:02.528]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:02.528]                     rootPath = tempdir()) 
[11:00:02.528]                   {
[11:00:02.528]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:02.528]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:02.528]                       tmpdir = path, fileext = ".rds")
[11:00:02.528]                     save_rds(obj, file)
[11:00:02.528]                   }
[11:00:02.528]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:02.528]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.528]                   {
[11:00:02.528]                     inherits <- base::inherits
[11:00:02.528]                     invokeRestart <- base::invokeRestart
[11:00:02.528]                     is.null <- base::is.null
[11:00:02.528]                     muffled <- FALSE
[11:00:02.528]                     if (inherits(cond, "message")) {
[11:00:02.528]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:02.528]                       if (muffled) 
[11:00:02.528]                         invokeRestart("muffleMessage")
[11:00:02.528]                     }
[11:00:02.528]                     else if (inherits(cond, "warning")) {
[11:00:02.528]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:02.528]                       if (muffled) 
[11:00:02.528]                         invokeRestart("muffleWarning")
[11:00:02.528]                     }
[11:00:02.528]                     else if (inherits(cond, "condition")) {
[11:00:02.528]                       if (!is.null(pattern)) {
[11:00:02.528]                         computeRestarts <- base::computeRestarts
[11:00:02.528]                         grepl <- base::grepl
[11:00:02.528]                         restarts <- computeRestarts(cond)
[11:00:02.528]                         for (restart in restarts) {
[11:00:02.528]                           name <- restart$name
[11:00:02.528]                           if (is.null(name)) 
[11:00:02.528]                             next
[11:00:02.528]                           if (!grepl(pattern, name)) 
[11:00:02.528]                             next
[11:00:02.528]                           invokeRestart(restart)
[11:00:02.528]                           muffled <- TRUE
[11:00:02.528]                           break
[11:00:02.528]                         }
[11:00:02.528]                       }
[11:00:02.528]                     }
[11:00:02.528]                     invisible(muffled)
[11:00:02.528]                   }
[11:00:02.528]                   muffleCondition(cond)
[11:00:02.528]                 })
[11:00:02.528]             }))
[11:00:02.528]             future::FutureResult(value = ...future.value$value, 
[11:00:02.528]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.528]                   ...future.rng), globalenv = if (FALSE) 
[11:00:02.528]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:02.528]                     ...future.globalenv.names))
[11:00:02.528]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:02.528]         }, condition = base::local({
[11:00:02.528]             c <- base::c
[11:00:02.528]             inherits <- base::inherits
[11:00:02.528]             invokeRestart <- base::invokeRestart
[11:00:02.528]             length <- base::length
[11:00:02.528]             list <- base::list
[11:00:02.528]             seq.int <- base::seq.int
[11:00:02.528]             signalCondition <- base::signalCondition
[11:00:02.528]             sys.calls <- base::sys.calls
[11:00:02.528]             `[[` <- base::`[[`
[11:00:02.528]             `+` <- base::`+`
[11:00:02.528]             `<<-` <- base::`<<-`
[11:00:02.528]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:02.528]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:02.528]                   3L)]
[11:00:02.528]             }
[11:00:02.528]             function(cond) {
[11:00:02.528]                 is_error <- inherits(cond, "error")
[11:00:02.528]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:02.528]                   NULL)
[11:00:02.528]                 if (is_error) {
[11:00:02.528]                   sessionInformation <- function() {
[11:00:02.528]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:02.528]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:02.528]                       search = base::search(), system = base::Sys.info())
[11:00:02.528]                   }
[11:00:02.528]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.528]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:02.528]                     cond$call), session = sessionInformation(), 
[11:00:02.528]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:02.528]                   signalCondition(cond)
[11:00:02.528]                 }
[11:00:02.528]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:02.528]                 "immediateCondition"))) {
[11:00:02.528]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:02.528]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.528]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:02.528]                   if (TRUE && !signal) {
[11:00:02.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.528]                     {
[11:00:02.528]                       inherits <- base::inherits
[11:00:02.528]                       invokeRestart <- base::invokeRestart
[11:00:02.528]                       is.null <- base::is.null
[11:00:02.528]                       muffled <- FALSE
[11:00:02.528]                       if (inherits(cond, "message")) {
[11:00:02.528]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.528]                         if (muffled) 
[11:00:02.528]                           invokeRestart("muffleMessage")
[11:00:02.528]                       }
[11:00:02.528]                       else if (inherits(cond, "warning")) {
[11:00:02.528]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.528]                         if (muffled) 
[11:00:02.528]                           invokeRestart("muffleWarning")
[11:00:02.528]                       }
[11:00:02.528]                       else if (inherits(cond, "condition")) {
[11:00:02.528]                         if (!is.null(pattern)) {
[11:00:02.528]                           computeRestarts <- base::computeRestarts
[11:00:02.528]                           grepl <- base::grepl
[11:00:02.528]                           restarts <- computeRestarts(cond)
[11:00:02.528]                           for (restart in restarts) {
[11:00:02.528]                             name <- restart$name
[11:00:02.528]                             if (is.null(name)) 
[11:00:02.528]                               next
[11:00:02.528]                             if (!grepl(pattern, name)) 
[11:00:02.528]                               next
[11:00:02.528]                             invokeRestart(restart)
[11:00:02.528]                             muffled <- TRUE
[11:00:02.528]                             break
[11:00:02.528]                           }
[11:00:02.528]                         }
[11:00:02.528]                       }
[11:00:02.528]                       invisible(muffled)
[11:00:02.528]                     }
[11:00:02.528]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.528]                   }
[11:00:02.528]                 }
[11:00:02.528]                 else {
[11:00:02.528]                   if (TRUE) {
[11:00:02.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.528]                     {
[11:00:02.528]                       inherits <- base::inherits
[11:00:02.528]                       invokeRestart <- base::invokeRestart
[11:00:02.528]                       is.null <- base::is.null
[11:00:02.528]                       muffled <- FALSE
[11:00:02.528]                       if (inherits(cond, "message")) {
[11:00:02.528]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.528]                         if (muffled) 
[11:00:02.528]                           invokeRestart("muffleMessage")
[11:00:02.528]                       }
[11:00:02.528]                       else if (inherits(cond, "warning")) {
[11:00:02.528]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.528]                         if (muffled) 
[11:00:02.528]                           invokeRestart("muffleWarning")
[11:00:02.528]                       }
[11:00:02.528]                       else if (inherits(cond, "condition")) {
[11:00:02.528]                         if (!is.null(pattern)) {
[11:00:02.528]                           computeRestarts <- base::computeRestarts
[11:00:02.528]                           grepl <- base::grepl
[11:00:02.528]                           restarts <- computeRestarts(cond)
[11:00:02.528]                           for (restart in restarts) {
[11:00:02.528]                             name <- restart$name
[11:00:02.528]                             if (is.null(name)) 
[11:00:02.528]                               next
[11:00:02.528]                             if (!grepl(pattern, name)) 
[11:00:02.528]                               next
[11:00:02.528]                             invokeRestart(restart)
[11:00:02.528]                             muffled <- TRUE
[11:00:02.528]                             break
[11:00:02.528]                           }
[11:00:02.528]                         }
[11:00:02.528]                       }
[11:00:02.528]                       invisible(muffled)
[11:00:02.528]                     }
[11:00:02.528]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.528]                   }
[11:00:02.528]                 }
[11:00:02.528]             }
[11:00:02.528]         }))
[11:00:02.528]     }, error = function(ex) {
[11:00:02.528]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:02.528]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.528]                 ...future.rng), started = ...future.startTime, 
[11:00:02.528]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:02.528]             version = "1.8"), class = "FutureResult")
[11:00:02.528]     }, finally = {
[11:00:02.528]         if (!identical(...future.workdir, getwd())) 
[11:00:02.528]             setwd(...future.workdir)
[11:00:02.528]         {
[11:00:02.528]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:02.528]                 ...future.oldOptions$nwarnings <- NULL
[11:00:02.528]             }
[11:00:02.528]             base::options(...future.oldOptions)
[11:00:02.528]             if (.Platform$OS.type == "windows") {
[11:00:02.528]                 old_names <- names(...future.oldEnvVars)
[11:00:02.528]                 envs <- base::Sys.getenv()
[11:00:02.528]                 names <- names(envs)
[11:00:02.528]                 common <- intersect(names, old_names)
[11:00:02.528]                 added <- setdiff(names, old_names)
[11:00:02.528]                 removed <- setdiff(old_names, names)
[11:00:02.528]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:02.528]                   envs[common]]
[11:00:02.528]                 NAMES <- toupper(changed)
[11:00:02.528]                 args <- list()
[11:00:02.528]                 for (kk in seq_along(NAMES)) {
[11:00:02.528]                   name <- changed[[kk]]
[11:00:02.528]                   NAME <- NAMES[[kk]]
[11:00:02.528]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.528]                     next
[11:00:02.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.528]                 }
[11:00:02.528]                 NAMES <- toupper(added)
[11:00:02.528]                 for (kk in seq_along(NAMES)) {
[11:00:02.528]                   name <- added[[kk]]
[11:00:02.528]                   NAME <- NAMES[[kk]]
[11:00:02.528]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.528]                     next
[11:00:02.528]                   args[[name]] <- ""
[11:00:02.528]                 }
[11:00:02.528]                 NAMES <- toupper(removed)
[11:00:02.528]                 for (kk in seq_along(NAMES)) {
[11:00:02.528]                   name <- removed[[kk]]
[11:00:02.528]                   NAME <- NAMES[[kk]]
[11:00:02.528]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.528]                     next
[11:00:02.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.528]                 }
[11:00:02.528]                 if (length(args) > 0) 
[11:00:02.528]                   base::do.call(base::Sys.setenv, args = args)
[11:00:02.528]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:02.528]             }
[11:00:02.528]             else {
[11:00:02.528]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:02.528]             }
[11:00:02.528]             {
[11:00:02.528]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:02.528]                   0L) {
[11:00:02.528]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:02.528]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:02.528]                   base::options(opts)
[11:00:02.528]                 }
[11:00:02.528]                 {
[11:00:02.528]                   {
[11:00:02.528]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:02.528]                     NULL
[11:00:02.528]                   }
[11:00:02.528]                   options(future.plan = NULL)
[11:00:02.528]                   if (is.na(NA_character_)) 
[11:00:02.528]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.528]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:02.528]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:02.528]                     .init = FALSE)
[11:00:02.528]                 }
[11:00:02.528]             }
[11:00:02.528]         }
[11:00:02.528]     })
[11:00:02.528]     if (TRUE) {
[11:00:02.528]         base::sink(type = "output", split = FALSE)
[11:00:02.528]         if (TRUE) {
[11:00:02.528]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:02.528]         }
[11:00:02.528]         else {
[11:00:02.528]             ...future.result["stdout"] <- base::list(NULL)
[11:00:02.528]         }
[11:00:02.528]         base::close(...future.stdout)
[11:00:02.528]         ...future.stdout <- NULL
[11:00:02.528]     }
[11:00:02.528]     ...future.result$conditions <- ...future.conditions
[11:00:02.528]     ...future.result$finished <- base::Sys.time()
[11:00:02.528]     ...future.result
[11:00:02.528] }
[11:00:02.531] assign_globals() ...
[11:00:02.532] List of 11
[11:00:02.532]  $ ...future.FUN            :function (x, ...)  
[11:00:02.532]  $ x_FUN                    :function (x, y)  
[11:00:02.532]  $ times                    : int 15
[11:00:02.532]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:02.532]  $ stop_if_not              :function (...)  
[11:00:02.532]  $ dim                      : int [1:2] 3 5
[11:00:02.532]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:02.532]  $ future.call.arguments    :List of 1
[11:00:02.532]   ..$ y: num [1:5] 2 4 6 8 10
[11:00:02.532]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.532]  $ ...future.elements_ii    :List of 2
[11:00:02.532]   ..$ C: num 70
[11:00:02.532]   ..$ D: num 80
[11:00:02.532]  $ ...future.seeds_ii       : NULL
[11:00:02.532]  $ ...future.globals.maxSize: NULL
[11:00:02.532]  - attr(*, "where")=List of 11
[11:00:02.532]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:02.532]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:02.532]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:02.532]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:02.532]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:02.532]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:02.532]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:02.532]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:02.532]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:02.532]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:02.532]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:02.532]  - attr(*, "resolved")= logi FALSE
[11:00:02.532]  - attr(*, "total_size")= num 26659
[11:00:02.532]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.532]  - attr(*, "already-done")= logi TRUE
[11:00:02.544] - copied ‘...future.FUN’ to environment
[11:00:02.544] - reassign environment for ‘x_FUN’
[11:00:02.544] - copied ‘x_FUN’ to environment
[11:00:02.544] - copied ‘times’ to environment
[11:00:02.544] - copied ‘stopf’ to environment
[11:00:02.545] - copied ‘stop_if_not’ to environment
[11:00:02.545] - copied ‘dim’ to environment
[11:00:02.545] - copied ‘valid_types’ to environment
[11:00:02.545] - copied ‘future.call.arguments’ to environment
[11:00:02.545] - copied ‘...future.elements_ii’ to environment
[11:00:02.545] - copied ‘...future.seeds_ii’ to environment
[11:00:02.545] - copied ‘...future.globals.maxSize’ to environment
[11:00:02.545] assign_globals() ... done
[11:00:02.546] requestCore(): workers = 2
[11:00:02.548] MulticoreFuture started
[11:00:02.549] - Launch lazy future ... done
[11:00:02.549] run() for ‘MulticoreFuture’ ... done
[11:00:02.550] Created future:
[11:00:02.550] plan(): Setting new future strategy stack:
[11:00:02.551] List of future strategies:
[11:00:02.551] 1. sequential:
[11:00:02.551]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:02.551]    - tweaked: FALSE
[11:00:02.551]    - call: NULL
[11:00:02.553] plan(): nbrOfWorkers() = 1
[11:00:02.556] plan(): Setting new future strategy stack:
[11:00:02.557] List of future strategies:
[11:00:02.557] 1. multicore:
[11:00:02.557]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:02.557]    - tweaked: FALSE
[11:00:02.557]    - call: plan(strategy)
[11:00:02.561] plan(): nbrOfWorkers() = 2
[11:00:02.551] MulticoreFuture:
[11:00:02.551] Label: ‘future_vapply-2’
[11:00:02.551] Expression:
[11:00:02.551] {
[11:00:02.551]     do.call(function(...) {
[11:00:02.551]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.551]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.551]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.551]             on.exit(options(oopts), add = TRUE)
[11:00:02.551]         }
[11:00:02.551]         {
[11:00:02.551]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.551]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.551]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.551]             })
[11:00:02.551]         }
[11:00:02.551]     }, args = future.call.arguments)
[11:00:02.551] }
[11:00:02.551] Lazy evaluation: FALSE
[11:00:02.551] Asynchronous evaluation: TRUE
[11:00:02.551] Local evaluation: TRUE
[11:00:02.551] Environment: R_GlobalEnv
[11:00:02.551] Capture standard output: TRUE
[11:00:02.551] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:02.551] Globals: 11 objects totaling 14.66 KiB (function ‘...future.FUN’ of 5.67 KiB, function ‘x_FUN’ of 680 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:02.551] Packages: 1 packages (‘future.apply’)
[11:00:02.551] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:02.551] Resolved: TRUE
[11:00:02.551] Value: <not collected>
[11:00:02.551] Conditions captured: <none>
[11:00:02.551] Early signaling: FALSE
[11:00:02.551] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:02.551] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.563] Chunk #2 of 2 ... DONE
[11:00:02.563] Launching 2 futures (chunks) ... DONE
[11:00:02.563] Resolving 2 futures (chunks) ...
[11:00:02.563] resolve() on list ...
[11:00:02.563]  recursive: 0
[11:00:02.564]  length: 2
[11:00:02.564] 
[11:00:02.564] Future #1
[11:00:02.564] result() for MulticoreFuture ...
[11:00:02.566] result() for MulticoreFuture ...
[11:00:02.566] result() for MulticoreFuture ... done
[11:00:02.566] result() for MulticoreFuture ... done
[11:00:02.566] result() for MulticoreFuture ...
[11:00:02.566] result() for MulticoreFuture ... done
[11:00:02.567] signalConditionsASAP(MulticoreFuture, pos=1) ...
[11:00:02.567] - nx: 2
[11:00:02.567] - relay: TRUE
[11:00:02.567] - stdout: TRUE
[11:00:02.568] - signal: TRUE
[11:00:02.568] - resignal: FALSE
[11:00:02.568] - force: TRUE
[11:00:02.568] - relayed: [n=2] FALSE, FALSE
[11:00:02.568] - queued futures: [n=2] FALSE, FALSE
[11:00:02.569]  - until=1
[11:00:02.569]  - relaying element #1
[11:00:02.569] result() for MulticoreFuture ...
[11:00:02.569] result() for MulticoreFuture ... done
[11:00:02.569] result() for MulticoreFuture ...
[11:00:02.570] result() for MulticoreFuture ... done
[11:00:02.570] result() for MulticoreFuture ...
[11:00:02.570] result() for MulticoreFuture ... done
[11:00:02.570] result() for MulticoreFuture ...
[11:00:02.570] result() for MulticoreFuture ... done
[11:00:02.570] - relayed: [n=2] TRUE, FALSE
[11:00:02.571] - queued futures: [n=2] TRUE, FALSE
[11:00:02.571] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[11:00:02.571]  length: 1 (resolved future 1)
[11:00:02.571] Future #2
[11:00:02.571] result() for MulticoreFuture ...
[11:00:02.572] result() for MulticoreFuture ...
[11:00:02.572] result() for MulticoreFuture ... done
[11:00:02.572] result() for MulticoreFuture ... done
[11:00:02.573] result() for MulticoreFuture ...
[11:00:02.573] result() for MulticoreFuture ... done
[11:00:02.573] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:00:02.573] - nx: 2
[11:00:02.573] - relay: TRUE
[11:00:02.573] - stdout: TRUE
[11:00:02.573] - signal: TRUE
[11:00:02.573] - resignal: FALSE
[11:00:02.574] - force: TRUE
[11:00:02.574] - relayed: [n=2] TRUE, FALSE
[11:00:02.574] - queued futures: [n=2] TRUE, FALSE
[11:00:02.574]  - until=2
[11:00:02.574]  - relaying element #2
[11:00:02.574] result() for MulticoreFuture ...
[11:00:02.574] result() for MulticoreFuture ... done
[11:00:02.574] result() for MulticoreFuture ...
[11:00:02.574] result() for MulticoreFuture ... done
[11:00:02.575] result() for MulticoreFuture ...
[11:00:02.575] result() for MulticoreFuture ... done
[11:00:02.575] result() for MulticoreFuture ...
[11:00:02.575] result() for MulticoreFuture ... done
[11:00:02.575] - relayed: [n=2] TRUE, TRUE
[11:00:02.575] - queued futures: [n=2] TRUE, TRUE
[11:00:02.575] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:00:02.575]  length: 0 (resolved future 2)
[11:00:02.575] Relaying remaining futures
[11:00:02.576] signalConditionsASAP(NULL, pos=0) ...
[11:00:02.576] - nx: 2
[11:00:02.576] - relay: TRUE
[11:00:02.576] - stdout: TRUE
[11:00:02.576] - signal: TRUE
[11:00:02.576] - resignal: FALSE
[11:00:02.576] - force: TRUE
[11:00:02.576] - relayed: [n=2] TRUE, TRUE
[11:00:02.576] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:02.576] - relayed: [n=2] TRUE, TRUE
[11:00:02.577] - queued futures: [n=2] TRUE, TRUE
[11:00:02.577] signalConditionsASAP(NULL, pos=0) ... done
[11:00:02.577] resolve() on list ... DONE
[11:00:02.577] result() for MulticoreFuture ...
[11:00:02.577] result() for MulticoreFuture ... done
[11:00:02.577] result() for MulticoreFuture ...
[11:00:02.577] result() for MulticoreFuture ... done
[11:00:02.577] result() for MulticoreFuture ...
[11:00:02.577] result() for MulticoreFuture ... done
[11:00:02.578] result() for MulticoreFuture ...
[11:00:02.578] result() for MulticoreFuture ... done
[11:00:02.578]  - Number of value chunks collected: 2
[11:00:02.578] Resolving 2 futures (chunks) ... DONE
[11:00:02.578] Reducing values from 2 chunks ...
[11:00:02.578]  - Number of values collected after concatenation: 4
[11:00:02.578]  - Number of values expected: 4
[11:00:02.578] Reducing values from 2 chunks ... DONE
[11:00:02.578] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[11:00:02.580] future_lapply() ...
[11:00:02.584] Number of chunks: 2
[11:00:02.584] getGlobalsAndPackagesXApply() ...
[11:00:02.584]  - future.globals: TRUE
[11:00:02.585] getGlobalsAndPackages() ...
[11:00:02.585] Searching for globals...
[11:00:02.591] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[11:00:02.591] Searching for globals ... DONE
[11:00:02.591] Resolving globals: FALSE
[11:00:02.592] The total size of the 7 globals is 14.73 KiB (15079 bytes)
[11:00:02.592] The total size of the 7 globals exported for future expression (‘FUN()’) is 14.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (6.74 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:02.593] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:02.593] - packages: [1] ‘future.apply’
[11:00:02.593] getGlobalsAndPackages() ... DONE
[11:00:02.593]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:02.593]  - needed namespaces: [n=1] ‘future.apply’
[11:00:02.593] Finding globals ... DONE
[11:00:02.593]  - use_args: TRUE
[11:00:02.593]  - Getting '...' globals ...
[11:00:02.594] resolve() on list ...
[11:00:02.594]  recursive: 0
[11:00:02.594]  length: 1
[11:00:02.594]  elements: ‘...’
[11:00:02.594]  length: 0 (resolved future 1)
[11:00:02.594] resolve() on list ... DONE
[11:00:02.595]    - '...' content: [n=0] 
[11:00:02.595] List of 1
[11:00:02.595]  $ ...: list()
[11:00:02.595]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.595]  - attr(*, "where")=List of 1
[11:00:02.595]   ..$ ...:<environment: 0x55bbad2ab250> 
[11:00:02.595]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.595]  - attr(*, "resolved")= logi TRUE
[11:00:02.595]  - attr(*, "total_size")= num NA
[11:00:02.597]  - Getting '...' globals ... DONE
[11:00:02.597] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:02.597] List of 8
[11:00:02.597]  $ ...future.FUN:function (x, ...)  
[11:00:02.597]  $ x_FUN        :function (x)  
[11:00:02.597]  $ times        : int 1
[11:00:02.597]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:02.597]  $ stop_if_not  :function (...)  
[11:00:02.597]  $ dim          : NULL
[11:00:02.597]  $ valid_types  : chr "logical"
[11:00:02.597]  $ ...          : list()
[11:00:02.597]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.597]  - attr(*, "where")=List of 8
[11:00:02.597]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:02.597]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:02.597]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:02.597]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:02.597]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:02.597]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:02.597]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:02.597]   ..$ ...          :<environment: 0x55bbad2ab250> 
[11:00:02.597]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.597]  - attr(*, "resolved")= logi FALSE
[11:00:02.597]  - attr(*, "total_size")= num 30734
[11:00:02.603] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:02.603] getGlobalsAndPackagesXApply() ... DONE
[11:00:02.603] Number of futures (= number of chunks): 2
[11:00:02.603] Launching 2 futures (chunks) ...
[11:00:02.603] Chunk #1 of 2 ...
[11:00:02.603]  - Finding globals in 'X' for chunk #1 ...
[11:00:02.604] getGlobalsAndPackages() ...
[11:00:02.604] Searching for globals...
[11:00:02.604] 
[11:00:02.604] Searching for globals ... DONE
[11:00:02.604] - globals: [0] <none>
[11:00:02.604] getGlobalsAndPackages() ... DONE
[11:00:02.604]    + additional globals found: [n=0] 
[11:00:02.604]    + additional namespaces needed: [n=0] 
[11:00:02.604]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:02.605]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:02.605]  - seeds: <none>
[11:00:02.605]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.605] getGlobalsAndPackages() ...
[11:00:02.605] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.605] Resolving globals: FALSE
[11:00:02.605] Tweak future expression to call with '...' arguments ...
[11:00:02.605] {
[11:00:02.605]     do.call(function(...) {
[11:00:02.605]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.605]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.605]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.605]             on.exit(options(oopts), add = TRUE)
[11:00:02.605]         }
[11:00:02.605]         {
[11:00:02.605]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.605]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.605]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.605]             })
[11:00:02.605]         }
[11:00:02.605]     }, args = future.call.arguments)
[11:00:02.605] }
[11:00:02.605] Tweak future expression to call with '...' arguments ... DONE
[11:00:02.606] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.606] - packages: [1] ‘future.apply’
[11:00:02.606] getGlobalsAndPackages() ... DONE
[11:00:02.609] run() for ‘Future’ ...
[11:00:02.609] - state: ‘created’
[11:00:02.609] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:02.611] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.611] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:02.611]   - Field: ‘label’
[11:00:02.611]   - Field: ‘local’
[11:00:02.612]   - Field: ‘owner’
[11:00:02.612]   - Field: ‘envir’
[11:00:02.612]   - Field: ‘workers’
[11:00:02.612]   - Field: ‘packages’
[11:00:02.612]   - Field: ‘gc’
[11:00:02.612]   - Field: ‘job’
[11:00:02.612]   - Field: ‘conditions’
[11:00:02.612]   - Field: ‘expr’
[11:00:02.613]   - Field: ‘uuid’
[11:00:02.613]   - Field: ‘seed’
[11:00:02.613]   - Field: ‘version’
[11:00:02.613]   - Field: ‘result’
[11:00:02.613]   - Field: ‘asynchronous’
[11:00:02.613]   - Field: ‘calls’
[11:00:02.613]   - Field: ‘globals’
[11:00:02.613]   - Field: ‘stdout’
[11:00:02.613]   - Field: ‘earlySignal’
[11:00:02.614]   - Field: ‘lazy’
[11:00:02.614]   - Field: ‘state’
[11:00:02.614] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:02.614] - Launch lazy future ...
[11:00:02.614] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:02.615] Packages needed by future strategies (n = 0): <none>
[11:00:02.615] {
[11:00:02.615]     {
[11:00:02.615]         {
[11:00:02.615]             ...future.startTime <- base::Sys.time()
[11:00:02.615]             {
[11:00:02.615]                 {
[11:00:02.615]                   {
[11:00:02.615]                     {
[11:00:02.615]                       {
[11:00:02.615]                         base::local({
[11:00:02.615]                           has_future <- base::requireNamespace("future", 
[11:00:02.615]                             quietly = TRUE)
[11:00:02.615]                           if (has_future) {
[11:00:02.615]                             ns <- base::getNamespace("future")
[11:00:02.615]                             version <- ns[[".package"]][["version"]]
[11:00:02.615]                             if (is.null(version)) 
[11:00:02.615]                               version <- utils::packageVersion("future")
[11:00:02.615]                           }
[11:00:02.615]                           else {
[11:00:02.615]                             version <- NULL
[11:00:02.615]                           }
[11:00:02.615]                           if (!has_future || version < "1.8.0") {
[11:00:02.615]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:02.615]                               "", base::R.version$version.string), 
[11:00:02.615]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:02.615]                                 base::R.version$platform, 8 * 
[11:00:02.615]                                   base::.Machine$sizeof.pointer), 
[11:00:02.615]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:02.615]                                 "release", "version")], collapse = " "), 
[11:00:02.615]                               hostname = base::Sys.info()[["nodename"]])
[11:00:02.615]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:02.615]                               info)
[11:00:02.615]                             info <- base::paste(info, collapse = "; ")
[11:00:02.615]                             if (!has_future) {
[11:00:02.615]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:02.615]                                 info)
[11:00:02.615]                             }
[11:00:02.615]                             else {
[11:00:02.615]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:02.615]                                 info, version)
[11:00:02.615]                             }
[11:00:02.615]                             base::stop(msg)
[11:00:02.615]                           }
[11:00:02.615]                         })
[11:00:02.615]                       }
[11:00:02.615]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:02.615]                       base::options(mc.cores = 1L)
[11:00:02.615]                     }
[11:00:02.615]                     base::local({
[11:00:02.615]                       for (pkg in "future.apply") {
[11:00:02.615]                         base::loadNamespace(pkg)
[11:00:02.615]                         base::library(pkg, character.only = TRUE)
[11:00:02.615]                       }
[11:00:02.615]                     })
[11:00:02.615]                   }
[11:00:02.615]                   ...future.strategy.old <- future::plan("list")
[11:00:02.615]                   options(future.plan = NULL)
[11:00:02.615]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.615]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:02.615]                 }
[11:00:02.615]                 ...future.workdir <- getwd()
[11:00:02.615]             }
[11:00:02.615]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:02.615]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:02.615]         }
[11:00:02.615]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:02.615]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:02.615]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:02.615]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:02.615]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:02.615]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:02.615]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:02.615]             base::names(...future.oldOptions))
[11:00:02.615]     }
[11:00:02.615]     if (FALSE) {
[11:00:02.615]     }
[11:00:02.615]     else {
[11:00:02.615]         if (TRUE) {
[11:00:02.615]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:02.615]                 open = "w")
[11:00:02.615]         }
[11:00:02.615]         else {
[11:00:02.615]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:02.615]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:02.615]         }
[11:00:02.615]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:02.615]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:02.615]             base::sink(type = "output", split = FALSE)
[11:00:02.615]             base::close(...future.stdout)
[11:00:02.615]         }, add = TRUE)
[11:00:02.615]     }
[11:00:02.615]     ...future.frame <- base::sys.nframe()
[11:00:02.615]     ...future.conditions <- base::list()
[11:00:02.615]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:02.615]     if (FALSE) {
[11:00:02.615]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:02.615]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:02.615]     }
[11:00:02.615]     ...future.result <- base::tryCatch({
[11:00:02.615]         base::withCallingHandlers({
[11:00:02.615]             ...future.value <- base::withVisible(base::local({
[11:00:02.615]                 withCallingHandlers({
[11:00:02.615]                   {
[11:00:02.615]                     do.call(function(...) {
[11:00:02.615]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.615]                       if (!identical(...future.globals.maxSize.org, 
[11:00:02.615]                         ...future.globals.maxSize)) {
[11:00:02.615]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.615]                         on.exit(options(oopts), add = TRUE)
[11:00:02.615]                       }
[11:00:02.615]                       {
[11:00:02.615]                         lapply(seq_along(...future.elements_ii), 
[11:00:02.615]                           FUN = function(jj) {
[11:00:02.615]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.615]                             ...future.FUN(...future.X_jj, ...)
[11:00:02.615]                           })
[11:00:02.615]                       }
[11:00:02.615]                     }, args = future.call.arguments)
[11:00:02.615]                   }
[11:00:02.615]                 }, immediateCondition = function(cond) {
[11:00:02.615]                   save_rds <- function (object, pathname, ...) 
[11:00:02.615]                   {
[11:00:02.615]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:02.615]                     if (file_test("-f", pathname_tmp)) {
[11:00:02.615]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.615]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:02.615]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.615]                         fi_tmp[["mtime"]])
[11:00:02.615]                     }
[11:00:02.615]                     tryCatch({
[11:00:02.615]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:02.615]                     }, error = function(ex) {
[11:00:02.615]                       msg <- conditionMessage(ex)
[11:00:02.615]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.615]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:02.615]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.615]                         fi_tmp[["mtime"]], msg)
[11:00:02.615]                       ex$message <- msg
[11:00:02.615]                       stop(ex)
[11:00:02.615]                     })
[11:00:02.615]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:02.615]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:02.615]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:02.615]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.615]                       fi <- file.info(pathname)
[11:00:02.615]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:02.615]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.615]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:02.615]                         fi[["size"]], fi[["mtime"]])
[11:00:02.615]                       stop(msg)
[11:00:02.615]                     }
[11:00:02.615]                     invisible(pathname)
[11:00:02.615]                   }
[11:00:02.615]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:02.615]                     rootPath = tempdir()) 
[11:00:02.615]                   {
[11:00:02.615]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:02.615]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:02.615]                       tmpdir = path, fileext = ".rds")
[11:00:02.615]                     save_rds(obj, file)
[11:00:02.615]                   }
[11:00:02.615]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:02.615]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.615]                   {
[11:00:02.615]                     inherits <- base::inherits
[11:00:02.615]                     invokeRestart <- base::invokeRestart
[11:00:02.615]                     is.null <- base::is.null
[11:00:02.615]                     muffled <- FALSE
[11:00:02.615]                     if (inherits(cond, "message")) {
[11:00:02.615]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:02.615]                       if (muffled) 
[11:00:02.615]                         invokeRestart("muffleMessage")
[11:00:02.615]                     }
[11:00:02.615]                     else if (inherits(cond, "warning")) {
[11:00:02.615]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:02.615]                       if (muffled) 
[11:00:02.615]                         invokeRestart("muffleWarning")
[11:00:02.615]                     }
[11:00:02.615]                     else if (inherits(cond, "condition")) {
[11:00:02.615]                       if (!is.null(pattern)) {
[11:00:02.615]                         computeRestarts <- base::computeRestarts
[11:00:02.615]                         grepl <- base::grepl
[11:00:02.615]                         restarts <- computeRestarts(cond)
[11:00:02.615]                         for (restart in restarts) {
[11:00:02.615]                           name <- restart$name
[11:00:02.615]                           if (is.null(name)) 
[11:00:02.615]                             next
[11:00:02.615]                           if (!grepl(pattern, name)) 
[11:00:02.615]                             next
[11:00:02.615]                           invokeRestart(restart)
[11:00:02.615]                           muffled <- TRUE
[11:00:02.615]                           break
[11:00:02.615]                         }
[11:00:02.615]                       }
[11:00:02.615]                     }
[11:00:02.615]                     invisible(muffled)
[11:00:02.615]                   }
[11:00:02.615]                   muffleCondition(cond)
[11:00:02.615]                 })
[11:00:02.615]             }))
[11:00:02.615]             future::FutureResult(value = ...future.value$value, 
[11:00:02.615]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.615]                   ...future.rng), globalenv = if (FALSE) 
[11:00:02.615]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:02.615]                     ...future.globalenv.names))
[11:00:02.615]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:02.615]         }, condition = base::local({
[11:00:02.615]             c <- base::c
[11:00:02.615]             inherits <- base::inherits
[11:00:02.615]             invokeRestart <- base::invokeRestart
[11:00:02.615]             length <- base::length
[11:00:02.615]             list <- base::list
[11:00:02.615]             seq.int <- base::seq.int
[11:00:02.615]             signalCondition <- base::signalCondition
[11:00:02.615]             sys.calls <- base::sys.calls
[11:00:02.615]             `[[` <- base::`[[`
[11:00:02.615]             `+` <- base::`+`
[11:00:02.615]             `<<-` <- base::`<<-`
[11:00:02.615]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:02.615]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:02.615]                   3L)]
[11:00:02.615]             }
[11:00:02.615]             function(cond) {
[11:00:02.615]                 is_error <- inherits(cond, "error")
[11:00:02.615]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:02.615]                   NULL)
[11:00:02.615]                 if (is_error) {
[11:00:02.615]                   sessionInformation <- function() {
[11:00:02.615]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:02.615]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:02.615]                       search = base::search(), system = base::Sys.info())
[11:00:02.615]                   }
[11:00:02.615]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.615]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:02.615]                     cond$call), session = sessionInformation(), 
[11:00:02.615]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:02.615]                   signalCondition(cond)
[11:00:02.615]                 }
[11:00:02.615]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:02.615]                 "immediateCondition"))) {
[11:00:02.615]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:02.615]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.615]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:02.615]                   if (TRUE && !signal) {
[11:00:02.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.615]                     {
[11:00:02.615]                       inherits <- base::inherits
[11:00:02.615]                       invokeRestart <- base::invokeRestart
[11:00:02.615]                       is.null <- base::is.null
[11:00:02.615]                       muffled <- FALSE
[11:00:02.615]                       if (inherits(cond, "message")) {
[11:00:02.615]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.615]                         if (muffled) 
[11:00:02.615]                           invokeRestart("muffleMessage")
[11:00:02.615]                       }
[11:00:02.615]                       else if (inherits(cond, "warning")) {
[11:00:02.615]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.615]                         if (muffled) 
[11:00:02.615]                           invokeRestart("muffleWarning")
[11:00:02.615]                       }
[11:00:02.615]                       else if (inherits(cond, "condition")) {
[11:00:02.615]                         if (!is.null(pattern)) {
[11:00:02.615]                           computeRestarts <- base::computeRestarts
[11:00:02.615]                           grepl <- base::grepl
[11:00:02.615]                           restarts <- computeRestarts(cond)
[11:00:02.615]                           for (restart in restarts) {
[11:00:02.615]                             name <- restart$name
[11:00:02.615]                             if (is.null(name)) 
[11:00:02.615]                               next
[11:00:02.615]                             if (!grepl(pattern, name)) 
[11:00:02.615]                               next
[11:00:02.615]                             invokeRestart(restart)
[11:00:02.615]                             muffled <- TRUE
[11:00:02.615]                             break
[11:00:02.615]                           }
[11:00:02.615]                         }
[11:00:02.615]                       }
[11:00:02.615]                       invisible(muffled)
[11:00:02.615]                     }
[11:00:02.615]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.615]                   }
[11:00:02.615]                 }
[11:00:02.615]                 else {
[11:00:02.615]                   if (TRUE) {
[11:00:02.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.615]                     {
[11:00:02.615]                       inherits <- base::inherits
[11:00:02.615]                       invokeRestart <- base::invokeRestart
[11:00:02.615]                       is.null <- base::is.null
[11:00:02.615]                       muffled <- FALSE
[11:00:02.615]                       if (inherits(cond, "message")) {
[11:00:02.615]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.615]                         if (muffled) 
[11:00:02.615]                           invokeRestart("muffleMessage")
[11:00:02.615]                       }
[11:00:02.615]                       else if (inherits(cond, "warning")) {
[11:00:02.615]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.615]                         if (muffled) 
[11:00:02.615]                           invokeRestart("muffleWarning")
[11:00:02.615]                       }
[11:00:02.615]                       else if (inherits(cond, "condition")) {
[11:00:02.615]                         if (!is.null(pattern)) {
[11:00:02.615]                           computeRestarts <- base::computeRestarts
[11:00:02.615]                           grepl <- base::grepl
[11:00:02.615]                           restarts <- computeRestarts(cond)
[11:00:02.615]                           for (restart in restarts) {
[11:00:02.615]                             name <- restart$name
[11:00:02.615]                             if (is.null(name)) 
[11:00:02.615]                               next
[11:00:02.615]                             if (!grepl(pattern, name)) 
[11:00:02.615]                               next
[11:00:02.615]                             invokeRestart(restart)
[11:00:02.615]                             muffled <- TRUE
[11:00:02.615]                             break
[11:00:02.615]                           }
[11:00:02.615]                         }
[11:00:02.615]                       }
[11:00:02.615]                       invisible(muffled)
[11:00:02.615]                     }
[11:00:02.615]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.615]                   }
[11:00:02.615]                 }
[11:00:02.615]             }
[11:00:02.615]         }))
[11:00:02.615]     }, error = function(ex) {
[11:00:02.615]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:02.615]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.615]                 ...future.rng), started = ...future.startTime, 
[11:00:02.615]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:02.615]             version = "1.8"), class = "FutureResult")
[11:00:02.615]     }, finally = {
[11:00:02.615]         if (!identical(...future.workdir, getwd())) 
[11:00:02.615]             setwd(...future.workdir)
[11:00:02.615]         {
[11:00:02.615]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:02.615]                 ...future.oldOptions$nwarnings <- NULL
[11:00:02.615]             }
[11:00:02.615]             base::options(...future.oldOptions)
[11:00:02.615]             if (.Platform$OS.type == "windows") {
[11:00:02.615]                 old_names <- names(...future.oldEnvVars)
[11:00:02.615]                 envs <- base::Sys.getenv()
[11:00:02.615]                 names <- names(envs)
[11:00:02.615]                 common <- intersect(names, old_names)
[11:00:02.615]                 added <- setdiff(names, old_names)
[11:00:02.615]                 removed <- setdiff(old_names, names)
[11:00:02.615]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:02.615]                   envs[common]]
[11:00:02.615]                 NAMES <- toupper(changed)
[11:00:02.615]                 args <- list()
[11:00:02.615]                 for (kk in seq_along(NAMES)) {
[11:00:02.615]                   name <- changed[[kk]]
[11:00:02.615]                   NAME <- NAMES[[kk]]
[11:00:02.615]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.615]                     next
[11:00:02.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.615]                 }
[11:00:02.615]                 NAMES <- toupper(added)
[11:00:02.615]                 for (kk in seq_along(NAMES)) {
[11:00:02.615]                   name <- added[[kk]]
[11:00:02.615]                   NAME <- NAMES[[kk]]
[11:00:02.615]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.615]                     next
[11:00:02.615]                   args[[name]] <- ""
[11:00:02.615]                 }
[11:00:02.615]                 NAMES <- toupper(removed)
[11:00:02.615]                 for (kk in seq_along(NAMES)) {
[11:00:02.615]                   name <- removed[[kk]]
[11:00:02.615]                   NAME <- NAMES[[kk]]
[11:00:02.615]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.615]                     next
[11:00:02.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.615]                 }
[11:00:02.615]                 if (length(args) > 0) 
[11:00:02.615]                   base::do.call(base::Sys.setenv, args = args)
[11:00:02.615]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:02.615]             }
[11:00:02.615]             else {
[11:00:02.615]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:02.615]             }
[11:00:02.615]             {
[11:00:02.615]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:02.615]                   0L) {
[11:00:02.615]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:02.615]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:02.615]                   base::options(opts)
[11:00:02.615]                 }
[11:00:02.615]                 {
[11:00:02.615]                   {
[11:00:02.615]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:02.615]                     NULL
[11:00:02.615]                   }
[11:00:02.615]                   options(future.plan = NULL)
[11:00:02.615]                   if (is.na(NA_character_)) 
[11:00:02.615]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.615]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:02.615]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:02.615]                     .init = FALSE)
[11:00:02.615]                 }
[11:00:02.615]             }
[11:00:02.615]         }
[11:00:02.615]     })
[11:00:02.615]     if (TRUE) {
[11:00:02.615]         base::sink(type = "output", split = FALSE)
[11:00:02.615]         if (TRUE) {
[11:00:02.615]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:02.615]         }
[11:00:02.615]         else {
[11:00:02.615]             ...future.result["stdout"] <- base::list(NULL)
[11:00:02.615]         }
[11:00:02.615]         base::close(...future.stdout)
[11:00:02.615]         ...future.stdout <- NULL
[11:00:02.615]     }
[11:00:02.615]     ...future.result$conditions <- ...future.conditions
[11:00:02.615]     ...future.result$finished <- base::Sys.time()
[11:00:02.615]     ...future.result
[11:00:02.615] }
[11:00:02.618] assign_globals() ...
[11:00:02.618] List of 11
[11:00:02.618]  $ ...future.FUN            :function (x, ...)  
[11:00:02.618]  $ x_FUN                    :function (x)  
[11:00:02.618]  $ times                    : int 1
[11:00:02.618]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:02.618]  $ stop_if_not              :function (...)  
[11:00:02.618]  $ dim                      : NULL
[11:00:02.618]  $ valid_types              : chr "logical"
[11:00:02.618]  $ future.call.arguments    : list()
[11:00:02.618]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.618]  $ ...future.elements_ii    :List of 6
[11:00:02.618]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[11:00:02.618]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[11:00:02.618]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[11:00:02.618]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[11:00:02.618]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[11:00:02.618]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[11:00:02.618]  $ ...future.seeds_ii       : NULL
[11:00:02.618]  $ ...future.globals.maxSize: NULL
[11:00:02.618]  - attr(*, "where")=List of 11
[11:00:02.618]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:02.618]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:02.618]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:02.618]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:02.618]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:02.618]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:02.618]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:02.618]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:02.618]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:02.618]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:02.618]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:02.618]  - attr(*, "resolved")= logi FALSE
[11:00:02.618]  - attr(*, "total_size")= num 30734
[11:00:02.618]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.618]  - attr(*, "already-done")= logi TRUE
[11:00:02.628] - copied ‘...future.FUN’ to environment
[11:00:02.628] - copied ‘x_FUN’ to environment
[11:00:02.628] - copied ‘times’ to environment
[11:00:02.628] - copied ‘stopf’ to environment
[11:00:02.628] - copied ‘stop_if_not’ to environment
[11:00:02.628] - copied ‘dim’ to environment
[11:00:02.628] - copied ‘valid_types’ to environment
[11:00:02.628] - copied ‘future.call.arguments’ to environment
[11:00:02.629] - copied ‘...future.elements_ii’ to environment
[11:00:02.629] - copied ‘...future.seeds_ii’ to environment
[11:00:02.629] - copied ‘...future.globals.maxSize’ to environment
[11:00:02.629] assign_globals() ... done
[11:00:02.629] requestCore(): workers = 2
[11:00:02.631] MulticoreFuture started
[11:00:02.632] - Launch lazy future ... done
[11:00:02.632] run() for ‘MulticoreFuture’ ... done
[11:00:02.632] Created future:
[11:00:02.633] plan(): Setting new future strategy stack:
[11:00:02.633] List of future strategies:
[11:00:02.633] 1. sequential:
[11:00:02.633]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:02.633]    - tweaked: FALSE
[11:00:02.633]    - call: NULL
[11:00:02.634] plan(): nbrOfWorkers() = 1
[11:00:02.636] plan(): Setting new future strategy stack:
[11:00:02.636] List of future strategies:
[11:00:02.636] 1. multicore:
[11:00:02.636]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:02.636]    - tweaked: FALSE
[11:00:02.636]    - call: plan(strategy)
[11:00:02.632] MulticoreFuture:
[11:00:02.632] Label: ‘future_vapply-1’
[11:00:02.632] Expression:
[11:00:02.632] {
[11:00:02.632]     do.call(function(...) {
[11:00:02.632]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.632]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.632]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.632]             on.exit(options(oopts), add = TRUE)
[11:00:02.632]         }
[11:00:02.632]         {
[11:00:02.632]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.632]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.632]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.632]             })
[11:00:02.632]         }
[11:00:02.632]     }, args = future.call.arguments)
[11:00:02.632] }
[11:00:02.632] Lazy evaluation: FALSE
[11:00:02.632] Asynchronous evaluation: TRUE
[11:00:02.632] Local evaluation: TRUE
[11:00:02.632] Environment: R_GlobalEnv
[11:00:02.632] Capture standard output: TRUE
[11:00:02.632] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:02.632] Globals: 11 objects totaling 16.54 KiB (function ‘...future.FUN’ of 6.73 KiB, function ‘x_FUN’ of 41 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:02.632] Packages: 1 packages (‘future.apply’)
[11:00:02.632] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:02.632] Resolved: FALSE
[11:00:02.632] Value: <not collected>
[11:00:02.632] Conditions captured: <none>
[11:00:02.632] Early signaling: FALSE
[11:00:02.632] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:02.632] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.645] Chunk #1 of 2 ... DONE
[11:00:02.645] Chunk #2 of 2 ...
[11:00:02.645]  - Finding globals in 'X' for chunk #2 ...
[11:00:02.645] plan(): nbrOfWorkers() = 2
[11:00:02.646] getGlobalsAndPackages() ...
[11:00:02.646] Searching for globals...
[11:00:02.646] 
[11:00:02.649] Searching for globals ... DONE
[11:00:02.649] - globals: [0] <none>
[11:00:02.649] getGlobalsAndPackages() ... DONE
[11:00:02.649]    + additional globals found: [n=0] 
[11:00:02.650]    + additional namespaces needed: [n=0] 
[11:00:02.650]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:02.650]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:02.650]  - seeds: <none>
[11:00:02.650]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.651] getGlobalsAndPackages() ...
[11:00:02.651] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.651] Resolving globals: FALSE
[11:00:02.652] Tweak future expression to call with '...' arguments ...
[11:00:02.652] {
[11:00:02.652]     do.call(function(...) {
[11:00:02.652]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.652]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.652]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.652]             on.exit(options(oopts), add = TRUE)
[11:00:02.652]         }
[11:00:02.652]         {
[11:00:02.652]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.652]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.652]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.652]             })
[11:00:02.652]         }
[11:00:02.652]     }, args = future.call.arguments)
[11:00:02.652] }
[11:00:02.653] Tweak future expression to call with '...' arguments ... DONE
[11:00:02.654] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.654] - packages: [1] ‘future.apply’
[11:00:02.655] getGlobalsAndPackages() ... DONE
[11:00:02.655] run() for ‘Future’ ...
[11:00:02.655] - state: ‘created’
[11:00:02.656] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:02.658] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.659] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:02.659]   - Field: ‘label’
[11:00:02.659]   - Field: ‘local’
[11:00:02.659]   - Field: ‘owner’
[11:00:02.659]   - Field: ‘envir’
[11:00:02.660]   - Field: ‘workers’
[11:00:02.660]   - Field: ‘packages’
[11:00:02.660]   - Field: ‘gc’
[11:00:02.660]   - Field: ‘job’
[11:00:02.660]   - Field: ‘conditions’
[11:00:02.661]   - Field: ‘expr’
[11:00:02.661]   - Field: ‘uuid’
[11:00:02.661]   - Field: ‘seed’
[11:00:02.661]   - Field: ‘version’
[11:00:02.661]   - Field: ‘result’
[11:00:02.662]   - Field: ‘asynchronous’
[11:00:02.662]   - Field: ‘calls’
[11:00:02.662]   - Field: ‘globals’
[11:00:02.662]   - Field: ‘stdout’
[11:00:02.662]   - Field: ‘earlySignal’
[11:00:02.662]   - Field: ‘lazy’
[11:00:02.663]   - Field: ‘state’
[11:00:02.663] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:02.663] - Launch lazy future ...
[11:00:02.663] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:02.663] Packages needed by future strategies (n = 0): <none>
[11:00:02.664] {
[11:00:02.664]     {
[11:00:02.664]         {
[11:00:02.664]             ...future.startTime <- base::Sys.time()
[11:00:02.664]             {
[11:00:02.664]                 {
[11:00:02.664]                   {
[11:00:02.664]                     {
[11:00:02.664]                       {
[11:00:02.664]                         base::local({
[11:00:02.664]                           has_future <- base::requireNamespace("future", 
[11:00:02.664]                             quietly = TRUE)
[11:00:02.664]                           if (has_future) {
[11:00:02.664]                             ns <- base::getNamespace("future")
[11:00:02.664]                             version <- ns[[".package"]][["version"]]
[11:00:02.664]                             if (is.null(version)) 
[11:00:02.664]                               version <- utils::packageVersion("future")
[11:00:02.664]                           }
[11:00:02.664]                           else {
[11:00:02.664]                             version <- NULL
[11:00:02.664]                           }
[11:00:02.664]                           if (!has_future || version < "1.8.0") {
[11:00:02.664]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:02.664]                               "", base::R.version$version.string), 
[11:00:02.664]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:02.664]                                 base::R.version$platform, 8 * 
[11:00:02.664]                                   base::.Machine$sizeof.pointer), 
[11:00:02.664]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:02.664]                                 "release", "version")], collapse = " "), 
[11:00:02.664]                               hostname = base::Sys.info()[["nodename"]])
[11:00:02.664]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:02.664]                               info)
[11:00:02.664]                             info <- base::paste(info, collapse = "; ")
[11:00:02.664]                             if (!has_future) {
[11:00:02.664]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:02.664]                                 info)
[11:00:02.664]                             }
[11:00:02.664]                             else {
[11:00:02.664]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:02.664]                                 info, version)
[11:00:02.664]                             }
[11:00:02.664]                             base::stop(msg)
[11:00:02.664]                           }
[11:00:02.664]                         })
[11:00:02.664]                       }
[11:00:02.664]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:02.664]                       base::options(mc.cores = 1L)
[11:00:02.664]                     }
[11:00:02.664]                     base::local({
[11:00:02.664]                       for (pkg in "future.apply") {
[11:00:02.664]                         base::loadNamespace(pkg)
[11:00:02.664]                         base::library(pkg, character.only = TRUE)
[11:00:02.664]                       }
[11:00:02.664]                     })
[11:00:02.664]                   }
[11:00:02.664]                   ...future.strategy.old <- future::plan("list")
[11:00:02.664]                   options(future.plan = NULL)
[11:00:02.664]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.664]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:02.664]                 }
[11:00:02.664]                 ...future.workdir <- getwd()
[11:00:02.664]             }
[11:00:02.664]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:02.664]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:02.664]         }
[11:00:02.664]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:02.664]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:02.664]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:02.664]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:02.664]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:02.664]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:02.664]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:02.664]             base::names(...future.oldOptions))
[11:00:02.664]     }
[11:00:02.664]     if (FALSE) {
[11:00:02.664]     }
[11:00:02.664]     else {
[11:00:02.664]         if (TRUE) {
[11:00:02.664]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:02.664]                 open = "w")
[11:00:02.664]         }
[11:00:02.664]         else {
[11:00:02.664]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:02.664]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:02.664]         }
[11:00:02.664]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:02.664]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:02.664]             base::sink(type = "output", split = FALSE)
[11:00:02.664]             base::close(...future.stdout)
[11:00:02.664]         }, add = TRUE)
[11:00:02.664]     }
[11:00:02.664]     ...future.frame <- base::sys.nframe()
[11:00:02.664]     ...future.conditions <- base::list()
[11:00:02.664]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:02.664]     if (FALSE) {
[11:00:02.664]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:02.664]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:02.664]     }
[11:00:02.664]     ...future.result <- base::tryCatch({
[11:00:02.664]         base::withCallingHandlers({
[11:00:02.664]             ...future.value <- base::withVisible(base::local({
[11:00:02.664]                 withCallingHandlers({
[11:00:02.664]                   {
[11:00:02.664]                     do.call(function(...) {
[11:00:02.664]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.664]                       if (!identical(...future.globals.maxSize.org, 
[11:00:02.664]                         ...future.globals.maxSize)) {
[11:00:02.664]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.664]                         on.exit(options(oopts), add = TRUE)
[11:00:02.664]                       }
[11:00:02.664]                       {
[11:00:02.664]                         lapply(seq_along(...future.elements_ii), 
[11:00:02.664]                           FUN = function(jj) {
[11:00:02.664]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.664]                             ...future.FUN(...future.X_jj, ...)
[11:00:02.664]                           })
[11:00:02.664]                       }
[11:00:02.664]                     }, args = future.call.arguments)
[11:00:02.664]                   }
[11:00:02.664]                 }, immediateCondition = function(cond) {
[11:00:02.664]                   save_rds <- function (object, pathname, ...) 
[11:00:02.664]                   {
[11:00:02.664]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:02.664]                     if (file_test("-f", pathname_tmp)) {
[11:00:02.664]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.664]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:02.664]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.664]                         fi_tmp[["mtime"]])
[11:00:02.664]                     }
[11:00:02.664]                     tryCatch({
[11:00:02.664]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:02.664]                     }, error = function(ex) {
[11:00:02.664]                       msg <- conditionMessage(ex)
[11:00:02.664]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.664]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:02.664]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.664]                         fi_tmp[["mtime"]], msg)
[11:00:02.664]                       ex$message <- msg
[11:00:02.664]                       stop(ex)
[11:00:02.664]                     })
[11:00:02.664]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:02.664]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:02.664]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:02.664]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.664]                       fi <- file.info(pathname)
[11:00:02.664]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:02.664]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.664]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:02.664]                         fi[["size"]], fi[["mtime"]])
[11:00:02.664]                       stop(msg)
[11:00:02.664]                     }
[11:00:02.664]                     invisible(pathname)
[11:00:02.664]                   }
[11:00:02.664]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:02.664]                     rootPath = tempdir()) 
[11:00:02.664]                   {
[11:00:02.664]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:02.664]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:02.664]                       tmpdir = path, fileext = ".rds")
[11:00:02.664]                     save_rds(obj, file)
[11:00:02.664]                   }
[11:00:02.664]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:02.664]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.664]                   {
[11:00:02.664]                     inherits <- base::inherits
[11:00:02.664]                     invokeRestart <- base::invokeRestart
[11:00:02.664]                     is.null <- base::is.null
[11:00:02.664]                     muffled <- FALSE
[11:00:02.664]                     if (inherits(cond, "message")) {
[11:00:02.664]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:02.664]                       if (muffled) 
[11:00:02.664]                         invokeRestart("muffleMessage")
[11:00:02.664]                     }
[11:00:02.664]                     else if (inherits(cond, "warning")) {
[11:00:02.664]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:02.664]                       if (muffled) 
[11:00:02.664]                         invokeRestart("muffleWarning")
[11:00:02.664]                     }
[11:00:02.664]                     else if (inherits(cond, "condition")) {
[11:00:02.664]                       if (!is.null(pattern)) {
[11:00:02.664]                         computeRestarts <- base::computeRestarts
[11:00:02.664]                         grepl <- base::grepl
[11:00:02.664]                         restarts <- computeRestarts(cond)
[11:00:02.664]                         for (restart in restarts) {
[11:00:02.664]                           name <- restart$name
[11:00:02.664]                           if (is.null(name)) 
[11:00:02.664]                             next
[11:00:02.664]                           if (!grepl(pattern, name)) 
[11:00:02.664]                             next
[11:00:02.664]                           invokeRestart(restart)
[11:00:02.664]                           muffled <- TRUE
[11:00:02.664]                           break
[11:00:02.664]                         }
[11:00:02.664]                       }
[11:00:02.664]                     }
[11:00:02.664]                     invisible(muffled)
[11:00:02.664]                   }
[11:00:02.664]                   muffleCondition(cond)
[11:00:02.664]                 })
[11:00:02.664]             }))
[11:00:02.664]             future::FutureResult(value = ...future.value$value, 
[11:00:02.664]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.664]                   ...future.rng), globalenv = if (FALSE) 
[11:00:02.664]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:02.664]                     ...future.globalenv.names))
[11:00:02.664]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:02.664]         }, condition = base::local({
[11:00:02.664]             c <- base::c
[11:00:02.664]             inherits <- base::inherits
[11:00:02.664]             invokeRestart <- base::invokeRestart
[11:00:02.664]             length <- base::length
[11:00:02.664]             list <- base::list
[11:00:02.664]             seq.int <- base::seq.int
[11:00:02.664]             signalCondition <- base::signalCondition
[11:00:02.664]             sys.calls <- base::sys.calls
[11:00:02.664]             `[[` <- base::`[[`
[11:00:02.664]             `+` <- base::`+`
[11:00:02.664]             `<<-` <- base::`<<-`
[11:00:02.664]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:02.664]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:02.664]                   3L)]
[11:00:02.664]             }
[11:00:02.664]             function(cond) {
[11:00:02.664]                 is_error <- inherits(cond, "error")
[11:00:02.664]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:02.664]                   NULL)
[11:00:02.664]                 if (is_error) {
[11:00:02.664]                   sessionInformation <- function() {
[11:00:02.664]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:02.664]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:02.664]                       search = base::search(), system = base::Sys.info())
[11:00:02.664]                   }
[11:00:02.664]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.664]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:02.664]                     cond$call), session = sessionInformation(), 
[11:00:02.664]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:02.664]                   signalCondition(cond)
[11:00:02.664]                 }
[11:00:02.664]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:02.664]                 "immediateCondition"))) {
[11:00:02.664]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:02.664]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.664]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:02.664]                   if (TRUE && !signal) {
[11:00:02.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.664]                     {
[11:00:02.664]                       inherits <- base::inherits
[11:00:02.664]                       invokeRestart <- base::invokeRestart
[11:00:02.664]                       is.null <- base::is.null
[11:00:02.664]                       muffled <- FALSE
[11:00:02.664]                       if (inherits(cond, "message")) {
[11:00:02.664]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.664]                         if (muffled) 
[11:00:02.664]                           invokeRestart("muffleMessage")
[11:00:02.664]                       }
[11:00:02.664]                       else if (inherits(cond, "warning")) {
[11:00:02.664]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.664]                         if (muffled) 
[11:00:02.664]                           invokeRestart("muffleWarning")
[11:00:02.664]                       }
[11:00:02.664]                       else if (inherits(cond, "condition")) {
[11:00:02.664]                         if (!is.null(pattern)) {
[11:00:02.664]                           computeRestarts <- base::computeRestarts
[11:00:02.664]                           grepl <- base::grepl
[11:00:02.664]                           restarts <- computeRestarts(cond)
[11:00:02.664]                           for (restart in restarts) {
[11:00:02.664]                             name <- restart$name
[11:00:02.664]                             if (is.null(name)) 
[11:00:02.664]                               next
[11:00:02.664]                             if (!grepl(pattern, name)) 
[11:00:02.664]                               next
[11:00:02.664]                             invokeRestart(restart)
[11:00:02.664]                             muffled <- TRUE
[11:00:02.664]                             break
[11:00:02.664]                           }
[11:00:02.664]                         }
[11:00:02.664]                       }
[11:00:02.664]                       invisible(muffled)
[11:00:02.664]                     }
[11:00:02.664]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.664]                   }
[11:00:02.664]                 }
[11:00:02.664]                 else {
[11:00:02.664]                   if (TRUE) {
[11:00:02.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.664]                     {
[11:00:02.664]                       inherits <- base::inherits
[11:00:02.664]                       invokeRestart <- base::invokeRestart
[11:00:02.664]                       is.null <- base::is.null
[11:00:02.664]                       muffled <- FALSE
[11:00:02.664]                       if (inherits(cond, "message")) {
[11:00:02.664]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.664]                         if (muffled) 
[11:00:02.664]                           invokeRestart("muffleMessage")
[11:00:02.664]                       }
[11:00:02.664]                       else if (inherits(cond, "warning")) {
[11:00:02.664]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.664]                         if (muffled) 
[11:00:02.664]                           invokeRestart("muffleWarning")
[11:00:02.664]                       }
[11:00:02.664]                       else if (inherits(cond, "condition")) {
[11:00:02.664]                         if (!is.null(pattern)) {
[11:00:02.664]                           computeRestarts <- base::computeRestarts
[11:00:02.664]                           grepl <- base::grepl
[11:00:02.664]                           restarts <- computeRestarts(cond)
[11:00:02.664]                           for (restart in restarts) {
[11:00:02.664]                             name <- restart$name
[11:00:02.664]                             if (is.null(name)) 
[11:00:02.664]                               next
[11:00:02.664]                             if (!grepl(pattern, name)) 
[11:00:02.664]                               next
[11:00:02.664]                             invokeRestart(restart)
[11:00:02.664]                             muffled <- TRUE
[11:00:02.664]                             break
[11:00:02.664]                           }
[11:00:02.664]                         }
[11:00:02.664]                       }
[11:00:02.664]                       invisible(muffled)
[11:00:02.664]                     }
[11:00:02.664]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.664]                   }
[11:00:02.664]                 }
[11:00:02.664]             }
[11:00:02.664]         }))
[11:00:02.664]     }, error = function(ex) {
[11:00:02.664]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:02.664]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.664]                 ...future.rng), started = ...future.startTime, 
[11:00:02.664]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:02.664]             version = "1.8"), class = "FutureResult")
[11:00:02.664]     }, finally = {
[11:00:02.664]         if (!identical(...future.workdir, getwd())) 
[11:00:02.664]             setwd(...future.workdir)
[11:00:02.664]         {
[11:00:02.664]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:02.664]                 ...future.oldOptions$nwarnings <- NULL
[11:00:02.664]             }
[11:00:02.664]             base::options(...future.oldOptions)
[11:00:02.664]             if (.Platform$OS.type == "windows") {
[11:00:02.664]                 old_names <- names(...future.oldEnvVars)
[11:00:02.664]                 envs <- base::Sys.getenv()
[11:00:02.664]                 names <- names(envs)
[11:00:02.664]                 common <- intersect(names, old_names)
[11:00:02.664]                 added <- setdiff(names, old_names)
[11:00:02.664]                 removed <- setdiff(old_names, names)
[11:00:02.664]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:02.664]                   envs[common]]
[11:00:02.664]                 NAMES <- toupper(changed)
[11:00:02.664]                 args <- list()
[11:00:02.664]                 for (kk in seq_along(NAMES)) {
[11:00:02.664]                   name <- changed[[kk]]
[11:00:02.664]                   NAME <- NAMES[[kk]]
[11:00:02.664]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.664]                     next
[11:00:02.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.664]                 }
[11:00:02.664]                 NAMES <- toupper(added)
[11:00:02.664]                 for (kk in seq_along(NAMES)) {
[11:00:02.664]                   name <- added[[kk]]
[11:00:02.664]                   NAME <- NAMES[[kk]]
[11:00:02.664]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.664]                     next
[11:00:02.664]                   args[[name]] <- ""
[11:00:02.664]                 }
[11:00:02.664]                 NAMES <- toupper(removed)
[11:00:02.664]                 for (kk in seq_along(NAMES)) {
[11:00:02.664]                   name <- removed[[kk]]
[11:00:02.664]                   NAME <- NAMES[[kk]]
[11:00:02.664]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.664]                     next
[11:00:02.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.664]                 }
[11:00:02.664]                 if (length(args) > 0) 
[11:00:02.664]                   base::do.call(base::Sys.setenv, args = args)
[11:00:02.664]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:02.664]             }
[11:00:02.664]             else {
[11:00:02.664]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:02.664]             }
[11:00:02.664]             {
[11:00:02.664]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:02.664]                   0L) {
[11:00:02.664]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:02.664]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:02.664]                   base::options(opts)
[11:00:02.664]                 }
[11:00:02.664]                 {
[11:00:02.664]                   {
[11:00:02.664]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:02.664]                     NULL
[11:00:02.664]                   }
[11:00:02.664]                   options(future.plan = NULL)
[11:00:02.664]                   if (is.na(NA_character_)) 
[11:00:02.664]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.664]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:02.664]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:02.664]                     .init = FALSE)
[11:00:02.664]                 }
[11:00:02.664]             }
[11:00:02.664]         }
[11:00:02.664]     })
[11:00:02.664]     if (TRUE) {
[11:00:02.664]         base::sink(type = "output", split = FALSE)
[11:00:02.664]         if (TRUE) {
[11:00:02.664]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:02.664]         }
[11:00:02.664]         else {
[11:00:02.664]             ...future.result["stdout"] <- base::list(NULL)
[11:00:02.664]         }
[11:00:02.664]         base::close(...future.stdout)
[11:00:02.664]         ...future.stdout <- NULL
[11:00:02.664]     }
[11:00:02.664]     ...future.result$conditions <- ...future.conditions
[11:00:02.664]     ...future.result$finished <- base::Sys.time()
[11:00:02.664]     ...future.result
[11:00:02.664] }
[11:00:02.667] assign_globals() ...
[11:00:02.667] List of 11
[11:00:02.667]  $ ...future.FUN            :function (x, ...)  
[11:00:02.667]  $ x_FUN                    :function (x)  
[11:00:02.667]  $ times                    : int 1
[11:00:02.667]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:02.667]  $ stop_if_not              :function (...)  
[11:00:02.667]  $ dim                      : NULL
[11:00:02.667]  $ valid_types              : chr "logical"
[11:00:02.667]  $ future.call.arguments    : list()
[11:00:02.667]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.667]  $ ...future.elements_ii    :List of 5
[11:00:02.667]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[11:00:02.667]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[11:00:02.667]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[11:00:02.667]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[11:00:02.667]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[11:00:02.667]  $ ...future.seeds_ii       : NULL
[11:00:02.667]  $ ...future.globals.maxSize: NULL
[11:00:02.667]  - attr(*, "where")=List of 11
[11:00:02.667]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:02.667]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:02.667]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:02.667]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:02.667]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:02.667]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:02.667]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:02.667]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:02.667]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:02.667]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:02.667]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:02.667]  - attr(*, "resolved")= logi FALSE
[11:00:02.667]  - attr(*, "total_size")= num 30734
[11:00:02.667]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.667]  - attr(*, "already-done")= logi TRUE
[11:00:02.677] - copied ‘...future.FUN’ to environment
[11:00:02.678] - copied ‘x_FUN’ to environment
[11:00:02.678] - copied ‘times’ to environment
[11:00:02.678] - copied ‘stopf’ to environment
[11:00:02.678] - copied ‘stop_if_not’ to environment
[11:00:02.678] - copied ‘dim’ to environment
[11:00:02.678] - copied ‘valid_types’ to environment
[11:00:02.678] - copied ‘future.call.arguments’ to environment
[11:00:02.678] - copied ‘...future.elements_ii’ to environment
[11:00:02.678] - copied ‘...future.seeds_ii’ to environment
[11:00:02.678] - copied ‘...future.globals.maxSize’ to environment
[11:00:02.679] assign_globals() ... done
[11:00:02.679] requestCore(): workers = 2
[11:00:02.683] MulticoreFuture started
[11:00:02.684] - Launch lazy future ... done
[11:00:02.684] run() for ‘MulticoreFuture’ ... done
[11:00:02.685] Created future:
[11:00:02.685] plan(): Setting new future strategy stack:
[11:00:02.685] List of future strategies:
[11:00:02.685] 1. sequential:
[11:00:02.685]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:02.685]    - tweaked: FALSE
[11:00:02.685]    - call: NULL
[11:00:02.687] plan(): nbrOfWorkers() = 1
[11:00:02.690] plan(): Setting new future strategy stack:
[11:00:02.691] List of future strategies:
[11:00:02.691] 1. multicore:
[11:00:02.691]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:02.691]    - tweaked: FALSE
[11:00:02.691]    - call: plan(strategy)
[11:00:02.695] plan(): nbrOfWorkers() = 2
[11:00:02.685] MulticoreFuture:
[11:00:02.685] Label: ‘future_vapply-2’
[11:00:02.685] Expression:
[11:00:02.685] {
[11:00:02.685]     do.call(function(...) {
[11:00:02.685]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.685]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.685]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.685]             on.exit(options(oopts), add = TRUE)
[11:00:02.685]         }
[11:00:02.685]         {
[11:00:02.685]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.685]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.685]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.685]             })
[11:00:02.685]         }
[11:00:02.685]     }, args = future.call.arguments)
[11:00:02.685] }
[11:00:02.685] Lazy evaluation: FALSE
[11:00:02.685] Asynchronous evaluation: TRUE
[11:00:02.685] Local evaluation: TRUE
[11:00:02.685] Environment: R_GlobalEnv
[11:00:02.685] Capture standard output: TRUE
[11:00:02.685] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:02.685] Globals: 11 objects totaling 16.28 KiB (function ‘...future.FUN’ of 6.73 KiB, function ‘x_FUN’ of 41 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:02.685] Packages: 1 packages (‘future.apply’)
[11:00:02.685] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:02.685] Resolved: TRUE
[11:00:02.685] Value: <not collected>
[11:00:02.685] Conditions captured: <none>
[11:00:02.685] Early signaling: FALSE
[11:00:02.685] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:02.685] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.696] Chunk #2 of 2 ... DONE
[11:00:02.696] Launching 2 futures (chunks) ... DONE
[11:00:02.696] Resolving 2 futures (chunks) ...
[11:00:02.696] resolve() on list ...
[11:00:02.697]  recursive: 0
[11:00:02.697]  length: 2
[11:00:02.697] 
[11:00:02.697] Future #1
[11:00:02.697] result() for MulticoreFuture ...
[11:00:02.698] result() for MulticoreFuture ...
[11:00:02.699] result() for MulticoreFuture ... done
[11:00:02.699] result() for MulticoreFuture ... done
[11:00:02.699] result() for MulticoreFuture ...
[11:00:02.699] result() for MulticoreFuture ... done
[11:00:02.699] signalConditionsASAP(MulticoreFuture, pos=1) ...
[11:00:02.699] - nx: 2
[11:00:02.700] - relay: TRUE
[11:00:02.700] - stdout: TRUE
[11:00:02.700] - signal: TRUE
[11:00:02.700] - resignal: FALSE
[11:00:02.700] - force: TRUE
[11:00:02.701] - relayed: [n=2] FALSE, FALSE
[11:00:02.701] - queued futures: [n=2] FALSE, FALSE
[11:00:02.701]  - until=1
[11:00:02.701]  - relaying element #1
[11:00:02.701] result() for MulticoreFuture ...
[11:00:02.702] result() for MulticoreFuture ... done
[11:00:02.702] result() for MulticoreFuture ...
[11:00:02.702] result() for MulticoreFuture ... done
[11:00:02.702] result() for MulticoreFuture ...
[11:00:02.702] result() for MulticoreFuture ... done
[11:00:02.703] result() for MulticoreFuture ...
[11:00:02.703] result() for MulticoreFuture ... done
[11:00:02.703] - relayed: [n=2] TRUE, FALSE
[11:00:02.703] - queued futures: [n=2] TRUE, FALSE
[11:00:02.703] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[11:00:02.704]  length: 1 (resolved future 1)
[11:00:02.704] Future #2
[11:00:02.704] result() for MulticoreFuture ...
[11:00:02.705] result() for MulticoreFuture ...
[11:00:02.705] result() for MulticoreFuture ... done
[11:00:02.705] result() for MulticoreFuture ... done
[11:00:02.706] result() for MulticoreFuture ...
[11:00:02.706] result() for MulticoreFuture ... done
[11:00:02.706] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:00:02.706] - nx: 2
[11:00:02.706] - relay: TRUE
[11:00:02.706] - stdout: TRUE
[11:00:02.707] - signal: TRUE
[11:00:02.707] - resignal: FALSE
[11:00:02.707] - force: TRUE
[11:00:02.707] - relayed: [n=2] TRUE, FALSE
[11:00:02.707] - queued futures: [n=2] TRUE, FALSE
[11:00:02.707]  - until=2
[11:00:02.707]  - relaying element #2
[11:00:02.707] result() for MulticoreFuture ...
[11:00:02.707] result() for MulticoreFuture ... done
[11:00:02.707] result() for MulticoreFuture ...
[11:00:02.708] result() for MulticoreFuture ... done
[11:00:02.708] result() for MulticoreFuture ...
[11:00:02.708] result() for MulticoreFuture ... done
[11:00:02.708] result() for MulticoreFuture ...
[11:00:02.708] result() for MulticoreFuture ... done
[11:00:02.708] - relayed: [n=2] TRUE, TRUE
[11:00:02.708] - queued futures: [n=2] TRUE, TRUE
[11:00:02.708] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:00:02.709]  length: 0 (resolved future 2)
[11:00:02.709] Relaying remaining futures
[11:00:02.709] signalConditionsASAP(NULL, pos=0) ...
[11:00:02.709] - nx: 2
[11:00:02.709] - relay: TRUE
[11:00:02.709] - stdout: TRUE
[11:00:02.709] - signal: TRUE
[11:00:02.709] - resignal: FALSE
[11:00:02.709] - force: TRUE
[11:00:02.709] - relayed: [n=2] TRUE, TRUE
[11:00:02.710] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:02.710] - relayed: [n=2] TRUE, TRUE
[11:00:02.710] - queued futures: [n=2] TRUE, TRUE
[11:00:02.710] signalConditionsASAP(NULL, pos=0) ... done
[11:00:02.710] resolve() on list ... DONE
[11:00:02.710] result() for MulticoreFuture ...
[11:00:02.710] result() for MulticoreFuture ... done
[11:00:02.710] result() for MulticoreFuture ...
[11:00:02.710] result() for MulticoreFuture ... done
[11:00:02.710] result() for MulticoreFuture ...
[11:00:02.711] result() for MulticoreFuture ... done
[11:00:02.711] result() for MulticoreFuture ...
[11:00:02.711] result() for MulticoreFuture ... done
[11:00:02.711]  - Number of value chunks collected: 2
[11:00:02.711] Resolving 2 futures (chunks) ... DONE
[11:00:02.711] Reducing values from 2 chunks ...
[11:00:02.711]  - Number of values collected after concatenation: 11
[11:00:02.711]  - Number of values expected: 11
[11:00:02.711] Reducing values from 2 chunks ... DONE
[11:00:02.711] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[11:00:02.712] future_lapply() ...
[11:00:02.716] Number of chunks: 2
[11:00:02.716] getGlobalsAndPackagesXApply() ...
[11:00:02.716]  - future.globals: TRUE
[11:00:02.717] getGlobalsAndPackages() ...
[11:00:02.717] Searching for globals...
[11:00:02.722] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[11:00:02.722] Searching for globals ... DONE
[11:00:02.722] Resolving globals: FALSE
[11:00:02.723] The total size of the 7 globals is 11.92 KiB (12201 bytes)
[11:00:02.723] The total size of the 7 globals exported for future expression (‘FUN()’) is 11.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (3.92 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:02.723] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:02.724] - packages: [1] ‘future.apply’
[11:00:02.724] getGlobalsAndPackages() ... DONE
[11:00:02.724]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:02.724]  - needed namespaces: [n=1] ‘future.apply’
[11:00:02.724] Finding globals ... DONE
[11:00:02.724]  - use_args: TRUE
[11:00:02.724]  - Getting '...' globals ...
[11:00:02.725] resolve() on list ...
[11:00:02.725]  recursive: 0
[11:00:02.725]  length: 1
[11:00:02.725]  elements: ‘...’
[11:00:02.725]  length: 0 (resolved future 1)
[11:00:02.725] resolve() on list ... DONE
[11:00:02.725]    - '...' content: [n=0] 
[11:00:02.725] List of 1
[11:00:02.725]  $ ...: list()
[11:00:02.725]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.725]  - attr(*, "where")=List of 1
[11:00:02.725]   ..$ ...:<environment: 0x55bbacb99eb8> 
[11:00:02.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.725]  - attr(*, "resolved")= logi TRUE
[11:00:02.725]  - attr(*, "total_size")= num NA
[11:00:02.728]  - Getting '...' globals ... DONE
[11:00:02.728] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:02.728] List of 8
[11:00:02.728]  $ ...future.FUN:function (x, ...)  
[11:00:02.728]  $ x_FUN        :function (x)  
[11:00:02.728]  $ times        : int 1
[11:00:02.728]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:02.728]  $ stop_if_not  :function (...)  
[11:00:02.728]  $ dim          : NULL
[11:00:02.728]  $ valid_types  : chr [1:2] "logical" "integer"
[11:00:02.728]  $ ...          : list()
[11:00:02.728]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.728]  - attr(*, "where")=List of 8
[11:00:02.728]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:02.728]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:02.728]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:02.728]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:02.728]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:02.728]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:02.728]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:02.728]   ..$ ...          :<environment: 0x55bbacb99eb8> 
[11:00:02.728]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.728]  - attr(*, "resolved")= logi FALSE
[11:00:02.728]  - attr(*, "total_size")= num 22016
[11:00:02.733] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:02.733] getGlobalsAndPackagesXApply() ... DONE
[11:00:02.734] Number of futures (= number of chunks): 2
[11:00:02.734] Launching 2 futures (chunks) ...
[11:00:02.734] Chunk #1 of 2 ...
[11:00:02.734]  - Finding globals in 'X' for chunk #1 ...
[11:00:02.734] getGlobalsAndPackages() ...
[11:00:02.734] Searching for globals...
[11:00:02.734] 
[11:00:02.734] Searching for globals ... DONE
[11:00:02.734] - globals: [0] <none>
[11:00:02.735] getGlobalsAndPackages() ... DONE
[11:00:02.735]    + additional globals found: [n=0] 
[11:00:02.735]    + additional namespaces needed: [n=0] 
[11:00:02.735]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:02.735]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:02.735]  - seeds: <none>
[11:00:02.735]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.735] getGlobalsAndPackages() ...
[11:00:02.735] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.735] Resolving globals: FALSE
[11:00:02.735] Tweak future expression to call with '...' arguments ...
[11:00:02.736] {
[11:00:02.736]     do.call(function(...) {
[11:00:02.736]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.736]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.736]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.736]             on.exit(options(oopts), add = TRUE)
[11:00:02.736]         }
[11:00:02.736]         {
[11:00:02.736]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.736]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.736]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.736]             })
[11:00:02.736]         }
[11:00:02.736]     }, args = future.call.arguments)
[11:00:02.736] }
[11:00:02.736] Tweak future expression to call with '...' arguments ... DONE
[11:00:02.736] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.736] - packages: [1] ‘future.apply’
[11:00:02.737] getGlobalsAndPackages() ... DONE
[11:00:02.737] run() for ‘Future’ ...
[11:00:02.737] - state: ‘created’
[11:00:02.737] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:02.739] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.739] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:02.739]   - Field: ‘label’
[11:00:02.739]   - Field: ‘local’
[11:00:02.739]   - Field: ‘owner’
[11:00:02.739]   - Field: ‘envir’
[11:00:02.739]   - Field: ‘workers’
[11:00:02.739]   - Field: ‘packages’
[11:00:02.739]   - Field: ‘gc’
[11:00:02.741]   - Field: ‘job’
[11:00:02.741]   - Field: ‘conditions’
[11:00:02.741]   - Field: ‘expr’
[11:00:02.741]   - Field: ‘uuid’
[11:00:02.741]   - Field: ‘seed’
[11:00:02.741]   - Field: ‘version’
[11:00:02.741]   - Field: ‘result’
[11:00:02.741]   - Field: ‘asynchronous’
[11:00:02.742]   - Field: ‘calls’
[11:00:02.742]   - Field: ‘globals’
[11:00:02.742]   - Field: ‘stdout’
[11:00:02.742]   - Field: ‘earlySignal’
[11:00:02.742]   - Field: ‘lazy’
[11:00:02.742]   - Field: ‘state’
[11:00:02.742] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:02.742] - Launch lazy future ...
[11:00:02.742] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:02.743] Packages needed by future strategies (n = 0): <none>
[11:00:02.743] {
[11:00:02.743]     {
[11:00:02.743]         {
[11:00:02.743]             ...future.startTime <- base::Sys.time()
[11:00:02.743]             {
[11:00:02.743]                 {
[11:00:02.743]                   {
[11:00:02.743]                     {
[11:00:02.743]                       {
[11:00:02.743]                         base::local({
[11:00:02.743]                           has_future <- base::requireNamespace("future", 
[11:00:02.743]                             quietly = TRUE)
[11:00:02.743]                           if (has_future) {
[11:00:02.743]                             ns <- base::getNamespace("future")
[11:00:02.743]                             version <- ns[[".package"]][["version"]]
[11:00:02.743]                             if (is.null(version)) 
[11:00:02.743]                               version <- utils::packageVersion("future")
[11:00:02.743]                           }
[11:00:02.743]                           else {
[11:00:02.743]                             version <- NULL
[11:00:02.743]                           }
[11:00:02.743]                           if (!has_future || version < "1.8.0") {
[11:00:02.743]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:02.743]                               "", base::R.version$version.string), 
[11:00:02.743]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:02.743]                                 base::R.version$platform, 8 * 
[11:00:02.743]                                   base::.Machine$sizeof.pointer), 
[11:00:02.743]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:02.743]                                 "release", "version")], collapse = " "), 
[11:00:02.743]                               hostname = base::Sys.info()[["nodename"]])
[11:00:02.743]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:02.743]                               info)
[11:00:02.743]                             info <- base::paste(info, collapse = "; ")
[11:00:02.743]                             if (!has_future) {
[11:00:02.743]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:02.743]                                 info)
[11:00:02.743]                             }
[11:00:02.743]                             else {
[11:00:02.743]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:02.743]                                 info, version)
[11:00:02.743]                             }
[11:00:02.743]                             base::stop(msg)
[11:00:02.743]                           }
[11:00:02.743]                         })
[11:00:02.743]                       }
[11:00:02.743]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:02.743]                       base::options(mc.cores = 1L)
[11:00:02.743]                     }
[11:00:02.743]                     base::local({
[11:00:02.743]                       for (pkg in "future.apply") {
[11:00:02.743]                         base::loadNamespace(pkg)
[11:00:02.743]                         base::library(pkg, character.only = TRUE)
[11:00:02.743]                       }
[11:00:02.743]                     })
[11:00:02.743]                   }
[11:00:02.743]                   ...future.strategy.old <- future::plan("list")
[11:00:02.743]                   options(future.plan = NULL)
[11:00:02.743]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.743]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:02.743]                 }
[11:00:02.743]                 ...future.workdir <- getwd()
[11:00:02.743]             }
[11:00:02.743]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:02.743]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:02.743]         }
[11:00:02.743]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:02.743]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:02.743]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:02.743]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:02.743]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:02.743]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:02.743]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:02.743]             base::names(...future.oldOptions))
[11:00:02.743]     }
[11:00:02.743]     if (FALSE) {
[11:00:02.743]     }
[11:00:02.743]     else {
[11:00:02.743]         if (TRUE) {
[11:00:02.743]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:02.743]                 open = "w")
[11:00:02.743]         }
[11:00:02.743]         else {
[11:00:02.743]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:02.743]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:02.743]         }
[11:00:02.743]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:02.743]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:02.743]             base::sink(type = "output", split = FALSE)
[11:00:02.743]             base::close(...future.stdout)
[11:00:02.743]         }, add = TRUE)
[11:00:02.743]     }
[11:00:02.743]     ...future.frame <- base::sys.nframe()
[11:00:02.743]     ...future.conditions <- base::list()
[11:00:02.743]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:02.743]     if (FALSE) {
[11:00:02.743]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:02.743]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:02.743]     }
[11:00:02.743]     ...future.result <- base::tryCatch({
[11:00:02.743]         base::withCallingHandlers({
[11:00:02.743]             ...future.value <- base::withVisible(base::local({
[11:00:02.743]                 withCallingHandlers({
[11:00:02.743]                   {
[11:00:02.743]                     do.call(function(...) {
[11:00:02.743]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.743]                       if (!identical(...future.globals.maxSize.org, 
[11:00:02.743]                         ...future.globals.maxSize)) {
[11:00:02.743]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.743]                         on.exit(options(oopts), add = TRUE)
[11:00:02.743]                       }
[11:00:02.743]                       {
[11:00:02.743]                         lapply(seq_along(...future.elements_ii), 
[11:00:02.743]                           FUN = function(jj) {
[11:00:02.743]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.743]                             ...future.FUN(...future.X_jj, ...)
[11:00:02.743]                           })
[11:00:02.743]                       }
[11:00:02.743]                     }, args = future.call.arguments)
[11:00:02.743]                   }
[11:00:02.743]                 }, immediateCondition = function(cond) {
[11:00:02.743]                   save_rds <- function (object, pathname, ...) 
[11:00:02.743]                   {
[11:00:02.743]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:02.743]                     if (file_test("-f", pathname_tmp)) {
[11:00:02.743]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.743]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:02.743]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.743]                         fi_tmp[["mtime"]])
[11:00:02.743]                     }
[11:00:02.743]                     tryCatch({
[11:00:02.743]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:02.743]                     }, error = function(ex) {
[11:00:02.743]                       msg <- conditionMessage(ex)
[11:00:02.743]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.743]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:02.743]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.743]                         fi_tmp[["mtime"]], msg)
[11:00:02.743]                       ex$message <- msg
[11:00:02.743]                       stop(ex)
[11:00:02.743]                     })
[11:00:02.743]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:02.743]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:02.743]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:02.743]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.743]                       fi <- file.info(pathname)
[11:00:02.743]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:02.743]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.743]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:02.743]                         fi[["size"]], fi[["mtime"]])
[11:00:02.743]                       stop(msg)
[11:00:02.743]                     }
[11:00:02.743]                     invisible(pathname)
[11:00:02.743]                   }
[11:00:02.743]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:02.743]                     rootPath = tempdir()) 
[11:00:02.743]                   {
[11:00:02.743]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:02.743]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:02.743]                       tmpdir = path, fileext = ".rds")
[11:00:02.743]                     save_rds(obj, file)
[11:00:02.743]                   }
[11:00:02.743]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:02.743]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.743]                   {
[11:00:02.743]                     inherits <- base::inherits
[11:00:02.743]                     invokeRestart <- base::invokeRestart
[11:00:02.743]                     is.null <- base::is.null
[11:00:02.743]                     muffled <- FALSE
[11:00:02.743]                     if (inherits(cond, "message")) {
[11:00:02.743]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:02.743]                       if (muffled) 
[11:00:02.743]                         invokeRestart("muffleMessage")
[11:00:02.743]                     }
[11:00:02.743]                     else if (inherits(cond, "warning")) {
[11:00:02.743]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:02.743]                       if (muffled) 
[11:00:02.743]                         invokeRestart("muffleWarning")
[11:00:02.743]                     }
[11:00:02.743]                     else if (inherits(cond, "condition")) {
[11:00:02.743]                       if (!is.null(pattern)) {
[11:00:02.743]                         computeRestarts <- base::computeRestarts
[11:00:02.743]                         grepl <- base::grepl
[11:00:02.743]                         restarts <- computeRestarts(cond)
[11:00:02.743]                         for (restart in restarts) {
[11:00:02.743]                           name <- restart$name
[11:00:02.743]                           if (is.null(name)) 
[11:00:02.743]                             next
[11:00:02.743]                           if (!grepl(pattern, name)) 
[11:00:02.743]                             next
[11:00:02.743]                           invokeRestart(restart)
[11:00:02.743]                           muffled <- TRUE
[11:00:02.743]                           break
[11:00:02.743]                         }
[11:00:02.743]                       }
[11:00:02.743]                     }
[11:00:02.743]                     invisible(muffled)
[11:00:02.743]                   }
[11:00:02.743]                   muffleCondition(cond)
[11:00:02.743]                 })
[11:00:02.743]             }))
[11:00:02.743]             future::FutureResult(value = ...future.value$value, 
[11:00:02.743]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.743]                   ...future.rng), globalenv = if (FALSE) 
[11:00:02.743]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:02.743]                     ...future.globalenv.names))
[11:00:02.743]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:02.743]         }, condition = base::local({
[11:00:02.743]             c <- base::c
[11:00:02.743]             inherits <- base::inherits
[11:00:02.743]             invokeRestart <- base::invokeRestart
[11:00:02.743]             length <- base::length
[11:00:02.743]             list <- base::list
[11:00:02.743]             seq.int <- base::seq.int
[11:00:02.743]             signalCondition <- base::signalCondition
[11:00:02.743]             sys.calls <- base::sys.calls
[11:00:02.743]             `[[` <- base::`[[`
[11:00:02.743]             `+` <- base::`+`
[11:00:02.743]             `<<-` <- base::`<<-`
[11:00:02.743]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:02.743]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:02.743]                   3L)]
[11:00:02.743]             }
[11:00:02.743]             function(cond) {
[11:00:02.743]                 is_error <- inherits(cond, "error")
[11:00:02.743]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:02.743]                   NULL)
[11:00:02.743]                 if (is_error) {
[11:00:02.743]                   sessionInformation <- function() {
[11:00:02.743]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:02.743]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:02.743]                       search = base::search(), system = base::Sys.info())
[11:00:02.743]                   }
[11:00:02.743]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.743]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:02.743]                     cond$call), session = sessionInformation(), 
[11:00:02.743]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:02.743]                   signalCondition(cond)
[11:00:02.743]                 }
[11:00:02.743]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:02.743]                 "immediateCondition"))) {
[11:00:02.743]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:02.743]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.743]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:02.743]                   if (TRUE && !signal) {
[11:00:02.743]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.743]                     {
[11:00:02.743]                       inherits <- base::inherits
[11:00:02.743]                       invokeRestart <- base::invokeRestart
[11:00:02.743]                       is.null <- base::is.null
[11:00:02.743]                       muffled <- FALSE
[11:00:02.743]                       if (inherits(cond, "message")) {
[11:00:02.743]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.743]                         if (muffled) 
[11:00:02.743]                           invokeRestart("muffleMessage")
[11:00:02.743]                       }
[11:00:02.743]                       else if (inherits(cond, "warning")) {
[11:00:02.743]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.743]                         if (muffled) 
[11:00:02.743]                           invokeRestart("muffleWarning")
[11:00:02.743]                       }
[11:00:02.743]                       else if (inherits(cond, "condition")) {
[11:00:02.743]                         if (!is.null(pattern)) {
[11:00:02.743]                           computeRestarts <- base::computeRestarts
[11:00:02.743]                           grepl <- base::grepl
[11:00:02.743]                           restarts <- computeRestarts(cond)
[11:00:02.743]                           for (restart in restarts) {
[11:00:02.743]                             name <- restart$name
[11:00:02.743]                             if (is.null(name)) 
[11:00:02.743]                               next
[11:00:02.743]                             if (!grepl(pattern, name)) 
[11:00:02.743]                               next
[11:00:02.743]                             invokeRestart(restart)
[11:00:02.743]                             muffled <- TRUE
[11:00:02.743]                             break
[11:00:02.743]                           }
[11:00:02.743]                         }
[11:00:02.743]                       }
[11:00:02.743]                       invisible(muffled)
[11:00:02.743]                     }
[11:00:02.743]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.743]                   }
[11:00:02.743]                 }
[11:00:02.743]                 else {
[11:00:02.743]                   if (TRUE) {
[11:00:02.743]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.743]                     {
[11:00:02.743]                       inherits <- base::inherits
[11:00:02.743]                       invokeRestart <- base::invokeRestart
[11:00:02.743]                       is.null <- base::is.null
[11:00:02.743]                       muffled <- FALSE
[11:00:02.743]                       if (inherits(cond, "message")) {
[11:00:02.743]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.743]                         if (muffled) 
[11:00:02.743]                           invokeRestart("muffleMessage")
[11:00:02.743]                       }
[11:00:02.743]                       else if (inherits(cond, "warning")) {
[11:00:02.743]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.743]                         if (muffled) 
[11:00:02.743]                           invokeRestart("muffleWarning")
[11:00:02.743]                       }
[11:00:02.743]                       else if (inherits(cond, "condition")) {
[11:00:02.743]                         if (!is.null(pattern)) {
[11:00:02.743]                           computeRestarts <- base::computeRestarts
[11:00:02.743]                           grepl <- base::grepl
[11:00:02.743]                           restarts <- computeRestarts(cond)
[11:00:02.743]                           for (restart in restarts) {
[11:00:02.743]                             name <- restart$name
[11:00:02.743]                             if (is.null(name)) 
[11:00:02.743]                               next
[11:00:02.743]                             if (!grepl(pattern, name)) 
[11:00:02.743]                               next
[11:00:02.743]                             invokeRestart(restart)
[11:00:02.743]                             muffled <- TRUE
[11:00:02.743]                             break
[11:00:02.743]                           }
[11:00:02.743]                         }
[11:00:02.743]                       }
[11:00:02.743]                       invisible(muffled)
[11:00:02.743]                     }
[11:00:02.743]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.743]                   }
[11:00:02.743]                 }
[11:00:02.743]             }
[11:00:02.743]         }))
[11:00:02.743]     }, error = function(ex) {
[11:00:02.743]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:02.743]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.743]                 ...future.rng), started = ...future.startTime, 
[11:00:02.743]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:02.743]             version = "1.8"), class = "FutureResult")
[11:00:02.743]     }, finally = {
[11:00:02.743]         if (!identical(...future.workdir, getwd())) 
[11:00:02.743]             setwd(...future.workdir)
[11:00:02.743]         {
[11:00:02.743]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:02.743]                 ...future.oldOptions$nwarnings <- NULL
[11:00:02.743]             }
[11:00:02.743]             base::options(...future.oldOptions)
[11:00:02.743]             if (.Platform$OS.type == "windows") {
[11:00:02.743]                 old_names <- names(...future.oldEnvVars)
[11:00:02.743]                 envs <- base::Sys.getenv()
[11:00:02.743]                 names <- names(envs)
[11:00:02.743]                 common <- intersect(names, old_names)
[11:00:02.743]                 added <- setdiff(names, old_names)
[11:00:02.743]                 removed <- setdiff(old_names, names)
[11:00:02.743]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:02.743]                   envs[common]]
[11:00:02.743]                 NAMES <- toupper(changed)
[11:00:02.743]                 args <- list()
[11:00:02.743]                 for (kk in seq_along(NAMES)) {
[11:00:02.743]                   name <- changed[[kk]]
[11:00:02.743]                   NAME <- NAMES[[kk]]
[11:00:02.743]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.743]                     next
[11:00:02.743]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.743]                 }
[11:00:02.743]                 NAMES <- toupper(added)
[11:00:02.743]                 for (kk in seq_along(NAMES)) {
[11:00:02.743]                   name <- added[[kk]]
[11:00:02.743]                   NAME <- NAMES[[kk]]
[11:00:02.743]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.743]                     next
[11:00:02.743]                   args[[name]] <- ""
[11:00:02.743]                 }
[11:00:02.743]                 NAMES <- toupper(removed)
[11:00:02.743]                 for (kk in seq_along(NAMES)) {
[11:00:02.743]                   name <- removed[[kk]]
[11:00:02.743]                   NAME <- NAMES[[kk]]
[11:00:02.743]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.743]                     next
[11:00:02.743]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.743]                 }
[11:00:02.743]                 if (length(args) > 0) 
[11:00:02.743]                   base::do.call(base::Sys.setenv, args = args)
[11:00:02.743]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:02.743]             }
[11:00:02.743]             else {
[11:00:02.743]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:02.743]             }
[11:00:02.743]             {
[11:00:02.743]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:02.743]                   0L) {
[11:00:02.743]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:02.743]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:02.743]                   base::options(opts)
[11:00:02.743]                 }
[11:00:02.743]                 {
[11:00:02.743]                   {
[11:00:02.743]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:02.743]                     NULL
[11:00:02.743]                   }
[11:00:02.743]                   options(future.plan = NULL)
[11:00:02.743]                   if (is.na(NA_character_)) 
[11:00:02.743]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.743]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:02.743]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:02.743]                     .init = FALSE)
[11:00:02.743]                 }
[11:00:02.743]             }
[11:00:02.743]         }
[11:00:02.743]     })
[11:00:02.743]     if (TRUE) {
[11:00:02.743]         base::sink(type = "output", split = FALSE)
[11:00:02.743]         if (TRUE) {
[11:00:02.743]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:02.743]         }
[11:00:02.743]         else {
[11:00:02.743]             ...future.result["stdout"] <- base::list(NULL)
[11:00:02.743]         }
[11:00:02.743]         base::close(...future.stdout)
[11:00:02.743]         ...future.stdout <- NULL
[11:00:02.743]     }
[11:00:02.743]     ...future.result$conditions <- ...future.conditions
[11:00:02.743]     ...future.result$finished <- base::Sys.time()
[11:00:02.743]     ...future.result
[11:00:02.743] }
[11:00:02.746] assign_globals() ...
[11:00:02.746] List of 11
[11:00:02.746]  $ ...future.FUN            :function (x, ...)  
[11:00:02.746]  $ x_FUN                    :function (x)  
[11:00:02.746]  $ times                    : int 1
[11:00:02.746]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:02.746]  $ stop_if_not              :function (...)  
[11:00:02.746]  $ dim                      : NULL
[11:00:02.746]  $ valid_types              : chr [1:2] "logical" "integer"
[11:00:02.746]  $ future.call.arguments    : list()
[11:00:02.746]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.746]  $ ...future.elements_ii    :List of 1
[11:00:02.746]   ..$ a: num 1
[11:00:02.746]  $ ...future.seeds_ii       : NULL
[11:00:02.746]  $ ...future.globals.maxSize: NULL
[11:00:02.746]  - attr(*, "where")=List of 11
[11:00:02.746]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:02.746]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:02.746]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:02.746]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:02.746]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:02.746]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:02.746]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:02.746]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:02.746]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:02.746]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:02.746]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:02.746]  - attr(*, "resolved")= logi FALSE
[11:00:02.746]  - attr(*, "total_size")= num 22016
[11:00:02.746]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.746]  - attr(*, "already-done")= logi TRUE
[11:00:02.754] - copied ‘...future.FUN’ to environment
[11:00:02.754] - copied ‘x_FUN’ to environment
[11:00:02.755] - copied ‘times’ to environment
[11:00:02.755] - copied ‘stopf’ to environment
[11:00:02.755] - copied ‘stop_if_not’ to environment
[11:00:02.755] - copied ‘dim’ to environment
[11:00:02.755] - copied ‘valid_types’ to environment
[11:00:02.755] - copied ‘future.call.arguments’ to environment
[11:00:02.755] - copied ‘...future.elements_ii’ to environment
[11:00:02.755] - copied ‘...future.seeds_ii’ to environment
[11:00:02.755] - copied ‘...future.globals.maxSize’ to environment
[11:00:02.755] assign_globals() ... done
[11:00:02.755] requestCore(): workers = 2
[11:00:02.757] MulticoreFuture started
[11:00:02.757] - Launch lazy future ... done
[11:00:02.758] run() for ‘MulticoreFuture’ ... done
[11:00:02.758] Created future:
[11:00:02.758] plan(): Setting new future strategy stack:
[11:00:02.759] List of future strategies:
[11:00:02.759] 1. sequential:
[11:00:02.759]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:02.759]    - tweaked: FALSE
[11:00:02.759]    - call: NULL
[11:00:02.759] plan(): nbrOfWorkers() = 1
[11:00:02.762] plan(): Setting new future strategy stack:
[11:00:02.762] List of future strategies:
[11:00:02.762] 1. multicore:
[11:00:02.762]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:02.762]    - tweaked: FALSE
[11:00:02.762]    - call: plan(strategy)
[11:00:02.765] plan(): nbrOfWorkers() = 2
[11:00:02.758] MulticoreFuture:
[11:00:02.758] Label: ‘future_vapply-1’
[11:00:02.758] Expression:
[11:00:02.758] {
[11:00:02.758]     do.call(function(...) {
[11:00:02.758]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.758]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.758]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.758]             on.exit(options(oopts), add = TRUE)
[11:00:02.758]         }
[11:00:02.758]         {
[11:00:02.758]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.758]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.758]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.758]             })
[11:00:02.758]         }
[11:00:02.758]     }, args = future.call.arguments)
[11:00:02.758] }
[11:00:02.758] Lazy evaluation: FALSE
[11:00:02.758] Asynchronous evaluation: TRUE
[11:00:02.758] Local evaluation: TRUE
[11:00:02.758] Environment: R_GlobalEnv
[11:00:02.758] Capture standard output: TRUE
[11:00:02.758] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:02.758] Globals: 11 objects totaling 12.15 KiB (function ‘...future.FUN’ of 3.91 KiB, function ‘x_FUN’ of 37 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:02.758] Packages: 1 packages (‘future.apply’)
[11:00:02.758] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:02.758] Resolved: TRUE
[11:00:02.758] Value: <not collected>
[11:00:02.758] Conditions captured: <none>
[11:00:02.758] Early signaling: FALSE
[11:00:02.758] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:02.758] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.766] Chunk #1 of 2 ... DONE
[11:00:02.766] Chunk #2 of 2 ...
[11:00:02.766]  - Finding globals in 'X' for chunk #2 ...
[11:00:02.766] getGlobalsAndPackages() ...
[11:00:02.767] Searching for globals...
[11:00:02.767] 
[11:00:02.767] Searching for globals ... DONE
[11:00:02.767] - globals: [0] <none>
[11:00:02.767] getGlobalsAndPackages() ... DONE
[11:00:02.767]    + additional globals found: [n=0] 
[11:00:02.768]    + additional namespaces needed: [n=0] 
[11:00:02.768]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:02.768]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:02.768]  - seeds: <none>
[11:00:02.768]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.768] getGlobalsAndPackages() ...
[11:00:02.768] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.769] Resolving globals: FALSE
[11:00:02.769] Tweak future expression to call with '...' arguments ...
[11:00:02.769] {
[11:00:02.769]     do.call(function(...) {
[11:00:02.769]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.769]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.769]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.769]             on.exit(options(oopts), add = TRUE)
[11:00:02.769]         }
[11:00:02.769]         {
[11:00:02.769]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.769]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.769]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.769]             })
[11:00:02.769]         }
[11:00:02.769]     }, args = future.call.arguments)
[11:00:02.769] }
[11:00:02.769] Tweak future expression to call with '...' arguments ... DONE
[11:00:02.770] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.770] - packages: [1] ‘future.apply’
[11:00:02.771] getGlobalsAndPackages() ... DONE
[11:00:02.771] run() for ‘Future’ ...
[11:00:02.771] - state: ‘created’
[11:00:02.771] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:02.777] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.777] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:02.778]   - Field: ‘label’
[11:00:02.778]   - Field: ‘local’
[11:00:02.779]   - Field: ‘owner’
[11:00:02.779]   - Field: ‘envir’
[11:00:02.779]   - Field: ‘workers’
[11:00:02.780]   - Field: ‘packages’
[11:00:02.780]   - Field: ‘gc’
[11:00:02.780]   - Field: ‘job’
[11:00:02.780]   - Field: ‘conditions’
[11:00:02.781]   - Field: ‘expr’
[11:00:02.781]   - Field: ‘uuid’
[11:00:02.781]   - Field: ‘seed’
[11:00:02.781]   - Field: ‘version’
[11:00:02.782]   - Field: ‘result’
[11:00:02.782]   - Field: ‘asynchronous’
[11:00:02.782]   - Field: ‘calls’
[11:00:02.782]   - Field: ‘globals’
[11:00:02.782]   - Field: ‘stdout’
[11:00:02.783]   - Field: ‘earlySignal’
[11:00:02.783]   - Field: ‘lazy’
[11:00:02.783]   - Field: ‘state’
[11:00:02.783] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:02.783] - Launch lazy future ...
[11:00:02.784] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:02.784] Packages needed by future strategies (n = 0): <none>
[11:00:02.785] {
[11:00:02.785]     {
[11:00:02.785]         {
[11:00:02.785]             ...future.startTime <- base::Sys.time()
[11:00:02.785]             {
[11:00:02.785]                 {
[11:00:02.785]                   {
[11:00:02.785]                     {
[11:00:02.785]                       {
[11:00:02.785]                         base::local({
[11:00:02.785]                           has_future <- base::requireNamespace("future", 
[11:00:02.785]                             quietly = TRUE)
[11:00:02.785]                           if (has_future) {
[11:00:02.785]                             ns <- base::getNamespace("future")
[11:00:02.785]                             version <- ns[[".package"]][["version"]]
[11:00:02.785]                             if (is.null(version)) 
[11:00:02.785]                               version <- utils::packageVersion("future")
[11:00:02.785]                           }
[11:00:02.785]                           else {
[11:00:02.785]                             version <- NULL
[11:00:02.785]                           }
[11:00:02.785]                           if (!has_future || version < "1.8.0") {
[11:00:02.785]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:02.785]                               "", base::R.version$version.string), 
[11:00:02.785]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:02.785]                                 base::R.version$platform, 8 * 
[11:00:02.785]                                   base::.Machine$sizeof.pointer), 
[11:00:02.785]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:02.785]                                 "release", "version")], collapse = " "), 
[11:00:02.785]                               hostname = base::Sys.info()[["nodename"]])
[11:00:02.785]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:02.785]                               info)
[11:00:02.785]                             info <- base::paste(info, collapse = "; ")
[11:00:02.785]                             if (!has_future) {
[11:00:02.785]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:02.785]                                 info)
[11:00:02.785]                             }
[11:00:02.785]                             else {
[11:00:02.785]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:02.785]                                 info, version)
[11:00:02.785]                             }
[11:00:02.785]                             base::stop(msg)
[11:00:02.785]                           }
[11:00:02.785]                         })
[11:00:02.785]                       }
[11:00:02.785]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:02.785]                       base::options(mc.cores = 1L)
[11:00:02.785]                     }
[11:00:02.785]                     base::local({
[11:00:02.785]                       for (pkg in "future.apply") {
[11:00:02.785]                         base::loadNamespace(pkg)
[11:00:02.785]                         base::library(pkg, character.only = TRUE)
[11:00:02.785]                       }
[11:00:02.785]                     })
[11:00:02.785]                   }
[11:00:02.785]                   ...future.strategy.old <- future::plan("list")
[11:00:02.785]                   options(future.plan = NULL)
[11:00:02.785]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.785]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:02.785]                 }
[11:00:02.785]                 ...future.workdir <- getwd()
[11:00:02.785]             }
[11:00:02.785]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:02.785]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:02.785]         }
[11:00:02.785]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:02.785]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:02.785]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:02.785]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:02.785]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:02.785]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:02.785]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:02.785]             base::names(...future.oldOptions))
[11:00:02.785]     }
[11:00:02.785]     if (FALSE) {
[11:00:02.785]     }
[11:00:02.785]     else {
[11:00:02.785]         if (TRUE) {
[11:00:02.785]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:02.785]                 open = "w")
[11:00:02.785]         }
[11:00:02.785]         else {
[11:00:02.785]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:02.785]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:02.785]         }
[11:00:02.785]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:02.785]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:02.785]             base::sink(type = "output", split = FALSE)
[11:00:02.785]             base::close(...future.stdout)
[11:00:02.785]         }, add = TRUE)
[11:00:02.785]     }
[11:00:02.785]     ...future.frame <- base::sys.nframe()
[11:00:02.785]     ...future.conditions <- base::list()
[11:00:02.785]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:02.785]     if (FALSE) {
[11:00:02.785]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:02.785]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:02.785]     }
[11:00:02.785]     ...future.result <- base::tryCatch({
[11:00:02.785]         base::withCallingHandlers({
[11:00:02.785]             ...future.value <- base::withVisible(base::local({
[11:00:02.785]                 withCallingHandlers({
[11:00:02.785]                   {
[11:00:02.785]                     do.call(function(...) {
[11:00:02.785]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.785]                       if (!identical(...future.globals.maxSize.org, 
[11:00:02.785]                         ...future.globals.maxSize)) {
[11:00:02.785]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.785]                         on.exit(options(oopts), add = TRUE)
[11:00:02.785]                       }
[11:00:02.785]                       {
[11:00:02.785]                         lapply(seq_along(...future.elements_ii), 
[11:00:02.785]                           FUN = function(jj) {
[11:00:02.785]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.785]                             ...future.FUN(...future.X_jj, ...)
[11:00:02.785]                           })
[11:00:02.785]                       }
[11:00:02.785]                     }, args = future.call.arguments)
[11:00:02.785]                   }
[11:00:02.785]                 }, immediateCondition = function(cond) {
[11:00:02.785]                   save_rds <- function (object, pathname, ...) 
[11:00:02.785]                   {
[11:00:02.785]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:02.785]                     if (file_test("-f", pathname_tmp)) {
[11:00:02.785]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.785]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:02.785]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.785]                         fi_tmp[["mtime"]])
[11:00:02.785]                     }
[11:00:02.785]                     tryCatch({
[11:00:02.785]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:02.785]                     }, error = function(ex) {
[11:00:02.785]                       msg <- conditionMessage(ex)
[11:00:02.785]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.785]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:02.785]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.785]                         fi_tmp[["mtime"]], msg)
[11:00:02.785]                       ex$message <- msg
[11:00:02.785]                       stop(ex)
[11:00:02.785]                     })
[11:00:02.785]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:02.785]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:02.785]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:02.785]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.785]                       fi <- file.info(pathname)
[11:00:02.785]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:02.785]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.785]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:02.785]                         fi[["size"]], fi[["mtime"]])
[11:00:02.785]                       stop(msg)
[11:00:02.785]                     }
[11:00:02.785]                     invisible(pathname)
[11:00:02.785]                   }
[11:00:02.785]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:02.785]                     rootPath = tempdir()) 
[11:00:02.785]                   {
[11:00:02.785]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:02.785]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:02.785]                       tmpdir = path, fileext = ".rds")
[11:00:02.785]                     save_rds(obj, file)
[11:00:02.785]                   }
[11:00:02.785]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:02.785]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.785]                   {
[11:00:02.785]                     inherits <- base::inherits
[11:00:02.785]                     invokeRestart <- base::invokeRestart
[11:00:02.785]                     is.null <- base::is.null
[11:00:02.785]                     muffled <- FALSE
[11:00:02.785]                     if (inherits(cond, "message")) {
[11:00:02.785]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:02.785]                       if (muffled) 
[11:00:02.785]                         invokeRestart("muffleMessage")
[11:00:02.785]                     }
[11:00:02.785]                     else if (inherits(cond, "warning")) {
[11:00:02.785]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:02.785]                       if (muffled) 
[11:00:02.785]                         invokeRestart("muffleWarning")
[11:00:02.785]                     }
[11:00:02.785]                     else if (inherits(cond, "condition")) {
[11:00:02.785]                       if (!is.null(pattern)) {
[11:00:02.785]                         computeRestarts <- base::computeRestarts
[11:00:02.785]                         grepl <- base::grepl
[11:00:02.785]                         restarts <- computeRestarts(cond)
[11:00:02.785]                         for (restart in restarts) {
[11:00:02.785]                           name <- restart$name
[11:00:02.785]                           if (is.null(name)) 
[11:00:02.785]                             next
[11:00:02.785]                           if (!grepl(pattern, name)) 
[11:00:02.785]                             next
[11:00:02.785]                           invokeRestart(restart)
[11:00:02.785]                           muffled <- TRUE
[11:00:02.785]                           break
[11:00:02.785]                         }
[11:00:02.785]                       }
[11:00:02.785]                     }
[11:00:02.785]                     invisible(muffled)
[11:00:02.785]                   }
[11:00:02.785]                   muffleCondition(cond)
[11:00:02.785]                 })
[11:00:02.785]             }))
[11:00:02.785]             future::FutureResult(value = ...future.value$value, 
[11:00:02.785]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.785]                   ...future.rng), globalenv = if (FALSE) 
[11:00:02.785]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:02.785]                     ...future.globalenv.names))
[11:00:02.785]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:02.785]         }, condition = base::local({
[11:00:02.785]             c <- base::c
[11:00:02.785]             inherits <- base::inherits
[11:00:02.785]             invokeRestart <- base::invokeRestart
[11:00:02.785]             length <- base::length
[11:00:02.785]             list <- base::list
[11:00:02.785]             seq.int <- base::seq.int
[11:00:02.785]             signalCondition <- base::signalCondition
[11:00:02.785]             sys.calls <- base::sys.calls
[11:00:02.785]             `[[` <- base::`[[`
[11:00:02.785]             `+` <- base::`+`
[11:00:02.785]             `<<-` <- base::`<<-`
[11:00:02.785]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:02.785]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:02.785]                   3L)]
[11:00:02.785]             }
[11:00:02.785]             function(cond) {
[11:00:02.785]                 is_error <- inherits(cond, "error")
[11:00:02.785]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:02.785]                   NULL)
[11:00:02.785]                 if (is_error) {
[11:00:02.785]                   sessionInformation <- function() {
[11:00:02.785]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:02.785]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:02.785]                       search = base::search(), system = base::Sys.info())
[11:00:02.785]                   }
[11:00:02.785]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.785]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:02.785]                     cond$call), session = sessionInformation(), 
[11:00:02.785]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:02.785]                   signalCondition(cond)
[11:00:02.785]                 }
[11:00:02.785]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:02.785]                 "immediateCondition"))) {
[11:00:02.785]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:02.785]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.785]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:02.785]                   if (TRUE && !signal) {
[11:00:02.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.785]                     {
[11:00:02.785]                       inherits <- base::inherits
[11:00:02.785]                       invokeRestart <- base::invokeRestart
[11:00:02.785]                       is.null <- base::is.null
[11:00:02.785]                       muffled <- FALSE
[11:00:02.785]                       if (inherits(cond, "message")) {
[11:00:02.785]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.785]                         if (muffled) 
[11:00:02.785]                           invokeRestart("muffleMessage")
[11:00:02.785]                       }
[11:00:02.785]                       else if (inherits(cond, "warning")) {
[11:00:02.785]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.785]                         if (muffled) 
[11:00:02.785]                           invokeRestart("muffleWarning")
[11:00:02.785]                       }
[11:00:02.785]                       else if (inherits(cond, "condition")) {
[11:00:02.785]                         if (!is.null(pattern)) {
[11:00:02.785]                           computeRestarts <- base::computeRestarts
[11:00:02.785]                           grepl <- base::grepl
[11:00:02.785]                           restarts <- computeRestarts(cond)
[11:00:02.785]                           for (restart in restarts) {
[11:00:02.785]                             name <- restart$name
[11:00:02.785]                             if (is.null(name)) 
[11:00:02.785]                               next
[11:00:02.785]                             if (!grepl(pattern, name)) 
[11:00:02.785]                               next
[11:00:02.785]                             invokeRestart(restart)
[11:00:02.785]                             muffled <- TRUE
[11:00:02.785]                             break
[11:00:02.785]                           }
[11:00:02.785]                         }
[11:00:02.785]                       }
[11:00:02.785]                       invisible(muffled)
[11:00:02.785]                     }
[11:00:02.785]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.785]                   }
[11:00:02.785]                 }
[11:00:02.785]                 else {
[11:00:02.785]                   if (TRUE) {
[11:00:02.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.785]                     {
[11:00:02.785]                       inherits <- base::inherits
[11:00:02.785]                       invokeRestart <- base::invokeRestart
[11:00:02.785]                       is.null <- base::is.null
[11:00:02.785]                       muffled <- FALSE
[11:00:02.785]                       if (inherits(cond, "message")) {
[11:00:02.785]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.785]                         if (muffled) 
[11:00:02.785]                           invokeRestart("muffleMessage")
[11:00:02.785]                       }
[11:00:02.785]                       else if (inherits(cond, "warning")) {
[11:00:02.785]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.785]                         if (muffled) 
[11:00:02.785]                           invokeRestart("muffleWarning")
[11:00:02.785]                       }
[11:00:02.785]                       else if (inherits(cond, "condition")) {
[11:00:02.785]                         if (!is.null(pattern)) {
[11:00:02.785]                           computeRestarts <- base::computeRestarts
[11:00:02.785]                           grepl <- base::grepl
[11:00:02.785]                           restarts <- computeRestarts(cond)
[11:00:02.785]                           for (restart in restarts) {
[11:00:02.785]                             name <- restart$name
[11:00:02.785]                             if (is.null(name)) 
[11:00:02.785]                               next
[11:00:02.785]                             if (!grepl(pattern, name)) 
[11:00:02.785]                               next
[11:00:02.785]                             invokeRestart(restart)
[11:00:02.785]                             muffled <- TRUE
[11:00:02.785]                             break
[11:00:02.785]                           }
[11:00:02.785]                         }
[11:00:02.785]                       }
[11:00:02.785]                       invisible(muffled)
[11:00:02.785]                     }
[11:00:02.785]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.785]                   }
[11:00:02.785]                 }
[11:00:02.785]             }
[11:00:02.785]         }))
[11:00:02.785]     }, error = function(ex) {
[11:00:02.785]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:02.785]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.785]                 ...future.rng), started = ...future.startTime, 
[11:00:02.785]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:02.785]             version = "1.8"), class = "FutureResult")
[11:00:02.785]     }, finally = {
[11:00:02.785]         if (!identical(...future.workdir, getwd())) 
[11:00:02.785]             setwd(...future.workdir)
[11:00:02.785]         {
[11:00:02.785]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:02.785]                 ...future.oldOptions$nwarnings <- NULL
[11:00:02.785]             }
[11:00:02.785]             base::options(...future.oldOptions)
[11:00:02.785]             if (.Platform$OS.type == "windows") {
[11:00:02.785]                 old_names <- names(...future.oldEnvVars)
[11:00:02.785]                 envs <- base::Sys.getenv()
[11:00:02.785]                 names <- names(envs)
[11:00:02.785]                 common <- intersect(names, old_names)
[11:00:02.785]                 added <- setdiff(names, old_names)
[11:00:02.785]                 removed <- setdiff(old_names, names)
[11:00:02.785]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:02.785]                   envs[common]]
[11:00:02.785]                 NAMES <- toupper(changed)
[11:00:02.785]                 args <- list()
[11:00:02.785]                 for (kk in seq_along(NAMES)) {
[11:00:02.785]                   name <- changed[[kk]]
[11:00:02.785]                   NAME <- NAMES[[kk]]
[11:00:02.785]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.785]                     next
[11:00:02.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.785]                 }
[11:00:02.785]                 NAMES <- toupper(added)
[11:00:02.785]                 for (kk in seq_along(NAMES)) {
[11:00:02.785]                   name <- added[[kk]]
[11:00:02.785]                   NAME <- NAMES[[kk]]
[11:00:02.785]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.785]                     next
[11:00:02.785]                   args[[name]] <- ""
[11:00:02.785]                 }
[11:00:02.785]                 NAMES <- toupper(removed)
[11:00:02.785]                 for (kk in seq_along(NAMES)) {
[11:00:02.785]                   name <- removed[[kk]]
[11:00:02.785]                   NAME <- NAMES[[kk]]
[11:00:02.785]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.785]                     next
[11:00:02.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.785]                 }
[11:00:02.785]                 if (length(args) > 0) 
[11:00:02.785]                   base::do.call(base::Sys.setenv, args = args)
[11:00:02.785]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:02.785]             }
[11:00:02.785]             else {
[11:00:02.785]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:02.785]             }
[11:00:02.785]             {
[11:00:02.785]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:02.785]                   0L) {
[11:00:02.785]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:02.785]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:02.785]                   base::options(opts)
[11:00:02.785]                 }
[11:00:02.785]                 {
[11:00:02.785]                   {
[11:00:02.785]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:02.785]                     NULL
[11:00:02.785]                   }
[11:00:02.785]                   options(future.plan = NULL)
[11:00:02.785]                   if (is.na(NA_character_)) 
[11:00:02.785]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.785]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:02.785]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:02.785]                     .init = FALSE)
[11:00:02.785]                 }
[11:00:02.785]             }
[11:00:02.785]         }
[11:00:02.785]     })
[11:00:02.785]     if (TRUE) {
[11:00:02.785]         base::sink(type = "output", split = FALSE)
[11:00:02.785]         if (TRUE) {
[11:00:02.785]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:02.785]         }
[11:00:02.785]         else {
[11:00:02.785]             ...future.result["stdout"] <- base::list(NULL)
[11:00:02.785]         }
[11:00:02.785]         base::close(...future.stdout)
[11:00:02.785]         ...future.stdout <- NULL
[11:00:02.785]     }
[11:00:02.785]     ...future.result$conditions <- ...future.conditions
[11:00:02.785]     ...future.result$finished <- base::Sys.time()
[11:00:02.785]     ...future.result
[11:00:02.785] }
[11:00:02.788] assign_globals() ...
[11:00:02.788] List of 11
[11:00:02.788]  $ ...future.FUN            :function (x, ...)  
[11:00:02.788]  $ x_FUN                    :function (x)  
[11:00:02.788]  $ times                    : int 1
[11:00:02.788]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:02.788]  $ stop_if_not              :function (...)  
[11:00:02.788]  $ dim                      : NULL
[11:00:02.788]  $ valid_types              : chr [1:2] "logical" "integer"
[11:00:02.788]  $ future.call.arguments    : list()
[11:00:02.788]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.788]  $ ...future.elements_ii    :List of 2
[11:00:02.788]   ..$ b: num 2
[11:00:02.788]   ..$ c: num 3
[11:00:02.788]  $ ...future.seeds_ii       : NULL
[11:00:02.788]  $ ...future.globals.maxSize: NULL
[11:00:02.788]  - attr(*, "where")=List of 11
[11:00:02.788]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:02.788]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:02.788]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:02.788]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:02.788]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:02.788]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:02.788]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:02.788]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:02.788]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:02.788]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:02.788]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:02.788]  - attr(*, "resolved")= logi FALSE
[11:00:02.788]  - attr(*, "total_size")= num 22016
[11:00:02.788]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.788]  - attr(*, "already-done")= logi TRUE
[11:00:02.799] - copied ‘...future.FUN’ to environment
[11:00:02.800] - copied ‘x_FUN’ to environment
[11:00:02.800] - copied ‘times’ to environment
[11:00:02.800] - copied ‘stopf’ to environment
[11:00:02.800] - copied ‘stop_if_not’ to environment
[11:00:02.800] - copied ‘dim’ to environment
[11:00:02.800] - copied ‘valid_types’ to environment
[11:00:02.800] - copied ‘future.call.arguments’ to environment
[11:00:02.800] - copied ‘...future.elements_ii’ to environment
[11:00:02.800] - copied ‘...future.seeds_ii’ to environment
[11:00:02.800] - copied ‘...future.globals.maxSize’ to environment
[11:00:02.801] assign_globals() ... done
[11:00:02.801] requestCore(): workers = 2
[11:00:02.803] MulticoreFuture started
[11:00:02.803] - Launch lazy future ... done
[11:00:02.803] run() for ‘MulticoreFuture’ ... done
[11:00:02.804] Created future:
[11:00:02.804] plan(): Setting new future strategy stack:
[11:00:02.804] List of future strategies:
[11:00:02.804] 1. sequential:
[11:00:02.804]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:02.804]    - tweaked: FALSE
[11:00:02.804]    - call: NULL
[11:00:02.805] plan(): nbrOfWorkers() = 1
[11:00:02.807] plan(): Setting new future strategy stack:
[11:00:02.808] List of future strategies:
[11:00:02.808] 1. multicore:
[11:00:02.808]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:02.808]    - tweaked: FALSE
[11:00:02.808]    - call: plan(strategy)
[11:00:02.811] plan(): nbrOfWorkers() = 2
[11:00:02.804] MulticoreFuture:
[11:00:02.804] Label: ‘future_vapply-2’
[11:00:02.804] Expression:
[11:00:02.804] {
[11:00:02.804]     do.call(function(...) {
[11:00:02.804]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.804]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.804]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.804]             on.exit(options(oopts), add = TRUE)
[11:00:02.804]         }
[11:00:02.804]         {
[11:00:02.804]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.804]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.804]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.804]             })
[11:00:02.804]         }
[11:00:02.804]     }, args = future.call.arguments)
[11:00:02.804] }
[11:00:02.804] Lazy evaluation: FALSE
[11:00:02.804] Asynchronous evaluation: TRUE
[11:00:02.804] Local evaluation: TRUE
[11:00:02.804] Environment: R_GlobalEnv
[11:00:02.804] Capture standard output: TRUE
[11:00:02.804] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:02.804] Globals: 11 objects totaling 12.17 KiB (function ‘...future.FUN’ of 3.91 KiB, function ‘x_FUN’ of 37 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:02.804] Packages: 1 packages (‘future.apply’)
[11:00:02.804] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:02.804] Resolved: TRUE
[11:00:02.804] Value: <not collected>
[11:00:02.804] Conditions captured: <none>
[11:00:02.804] Early signaling: FALSE
[11:00:02.804] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:02.804] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.812] Chunk #2 of 2 ... DONE
[11:00:02.812] Launching 2 futures (chunks) ... DONE
[11:00:02.812] Resolving 2 futures (chunks) ...
[11:00:02.812] resolve() on list ...
[11:00:02.812]  recursive: 0
[11:00:02.813]  length: 2
[11:00:02.813] 
[11:00:02.813] Future #1
[11:00:02.813] result() for MulticoreFuture ...
[11:00:02.814] result() for MulticoreFuture ...
[11:00:02.814] result() for MulticoreFuture ... done
[11:00:02.814] result() for MulticoreFuture ... done
[11:00:02.814] result() for MulticoreFuture ...
[11:00:02.814] result() for MulticoreFuture ... done
[11:00:02.815] signalConditionsASAP(MulticoreFuture, pos=1) ...
[11:00:02.815] - nx: 2
[11:00:02.815] - relay: TRUE
[11:00:02.815] - stdout: TRUE
[11:00:02.815] - signal: TRUE
[11:00:02.815] - resignal: FALSE
[11:00:02.815] - force: TRUE
[11:00:02.816] - relayed: [n=2] FALSE, FALSE
[11:00:02.816] - queued futures: [n=2] FALSE, FALSE
[11:00:02.816]  - until=1
[11:00:02.816]  - relaying element #1
[11:00:02.816] result() for MulticoreFuture ...
[11:00:02.816] result() for MulticoreFuture ... done
[11:00:02.816] result() for MulticoreFuture ...
[11:00:02.820] result() for MulticoreFuture ... done
[11:00:02.820] result() for MulticoreFuture ...
[11:00:02.821] result() for MulticoreFuture ... done
[11:00:02.821] result() for MulticoreFuture ...
[11:00:02.822] result() for MulticoreFuture ... done
[11:00:02.822] - relayed: [n=2] TRUE, FALSE
[11:00:02.822] - queued futures: [n=2] TRUE, FALSE
[11:00:02.823] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[11:00:02.823]  length: 1 (resolved future 1)
[11:00:02.823] Future #2
[11:00:02.824] result() for MulticoreFuture ...
[11:00:02.825] result() for MulticoreFuture ...
[11:00:02.825] result() for MulticoreFuture ... done
[11:00:02.825] result() for MulticoreFuture ... done
[11:00:02.825] result() for MulticoreFuture ...
[11:00:02.826] result() for MulticoreFuture ... done
[11:00:02.826] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:00:02.826] - nx: 2
[11:00:02.826] - relay: TRUE
[11:00:02.826] - stdout: TRUE
[11:00:02.827] - signal: TRUE
[11:00:02.827] - resignal: FALSE
[11:00:02.827] - force: TRUE
[11:00:02.827] - relayed: [n=2] TRUE, FALSE
[11:00:02.827] - queued futures: [n=2] TRUE, FALSE
[11:00:02.827]  - until=2
[11:00:02.828]  - relaying element #2
[11:00:02.828] result() for MulticoreFuture ...
[11:00:02.828] result() for MulticoreFuture ... done
[11:00:02.828] result() for MulticoreFuture ...
[11:00:02.828] result() for MulticoreFuture ... done
[11:00:02.828] result() for MulticoreFuture ...
[11:00:02.828] result() for MulticoreFuture ... done
[11:00:02.829] result() for MulticoreFuture ...
[11:00:02.829] result() for MulticoreFuture ... done
[11:00:02.829] - relayed: [n=2] TRUE, TRUE
[11:00:02.829] - queued futures: [n=2] TRUE, TRUE
[11:00:02.829] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:00:02.829]  length: 0 (resolved future 2)
[11:00:02.829] Relaying remaining futures
[11:00:02.829] signalConditionsASAP(NULL, pos=0) ...
[11:00:02.830] - nx: 2
[11:00:02.830] - relay: TRUE
[11:00:02.830] - stdout: TRUE
[11:00:02.830] - signal: TRUE
[11:00:02.830] - resignal: FALSE
[11:00:02.830] - force: TRUE
[11:00:02.830] - relayed: [n=2] TRUE, TRUE
[11:00:02.830] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:02.831] - relayed: [n=2] TRUE, TRUE
[11:00:02.831] - queued futures: [n=2] TRUE, TRUE
[11:00:02.831] signalConditionsASAP(NULL, pos=0) ... done
[11:00:02.831] resolve() on list ... DONE
[11:00:02.831] result() for MulticoreFuture ...
[11:00:02.831] result() for MulticoreFuture ... done
[11:00:02.831] result() for MulticoreFuture ...
[11:00:02.832] result() for MulticoreFuture ... done
[11:00:02.832] result() for MulticoreFuture ...
[11:00:02.832] result() for MulticoreFuture ... done
[11:00:02.832] result() for MulticoreFuture ...
[11:00:02.832] result() for MulticoreFuture ... done
[11:00:02.832]  - Number of value chunks collected: 2
[11:00:02.832] Resolving 2 futures (chunks) ... DONE
[11:00:02.832] Reducing values from 2 chunks ...
[11:00:02.833]  - Number of values collected after concatenation: 3
[11:00:02.833]  - Number of values expected: 3
[11:00:02.833] Reducing values from 2 chunks ... DONE
[11:00:02.833] future_lapply() ... DONE
- exceptions ...
[11:00:02.833] future_lapply() ...
[11:00:02.837] Number of chunks: 2
[11:00:02.837] getGlobalsAndPackagesXApply() ...
[11:00:02.837]  - future.globals: TRUE
[11:00:02.837] getGlobalsAndPackages() ...
[11:00:02.837] Searching for globals...
[11:00:02.841] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[11:00:02.841] Searching for globals ... DONE
[11:00:02.841] Resolving globals: FALSE
[11:00:02.842] The total size of the 7 globals is 12.81 KiB (13119 bytes)
[11:00:02.842] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.65 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:02.842] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:02.843] - packages: [1] ‘future.apply’
[11:00:02.843] getGlobalsAndPackages() ... DONE
[11:00:02.843]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:02.843]  - needed namespaces: [n=1] ‘future.apply’
[11:00:02.843] Finding globals ... DONE
[11:00:02.843]  - use_args: TRUE
[11:00:02.843]  - Getting '...' globals ...
[11:00:02.844] resolve() on list ...
[11:00:02.844]  recursive: 0
[11:00:02.844]  length: 1
[11:00:02.844]  elements: ‘...’
[11:00:02.844]  length: 0 (resolved future 1)
[11:00:02.844] resolve() on list ... DONE
[11:00:02.844]    - '...' content: [n=0] 
[11:00:02.844] List of 1
[11:00:02.844]  $ ...: list()
[11:00:02.844]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.844]  - attr(*, "where")=List of 1
[11:00:02.844]   ..$ ...:<environment: 0x55bbac91c9b0> 
[11:00:02.844]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.844]  - attr(*, "resolved")= logi TRUE
[11:00:02.844]  - attr(*, "total_size")= num NA
[11:00:02.849]  - Getting '...' globals ... DONE
[11:00:02.849] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:02.849] List of 8
[11:00:02.849]  $ ...future.FUN:function (x, ...)  
[11:00:02.849]  $ x_FUN        :function (x)  
[11:00:02.849]  $ times        : int 2
[11:00:02.849]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:02.849]  $ stop_if_not  :function (...)  
[11:00:02.849]  $ dim          : NULL
[11:00:02.849]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:02.849]  $ ...          : list()
[11:00:02.849]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.849]  - attr(*, "where")=List of 8
[11:00:02.849]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:02.849]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:02.849]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:02.849]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:02.849]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:02.849]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:02.849]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:02.849]   ..$ ...          :<environment: 0x55bbac91c9b0> 
[11:00:02.849]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.849]  - attr(*, "resolved")= logi FALSE
[11:00:02.849]  - attr(*, "total_size")= num 23676
[11:00:02.854] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:02.854] getGlobalsAndPackagesXApply() ... DONE
[11:00:02.854] Number of futures (= number of chunks): 2
[11:00:02.855] Launching 2 futures (chunks) ...
[11:00:02.855] Chunk #1 of 2 ...
[11:00:02.855]  - Finding globals in 'X' for chunk #1 ...
[11:00:02.855] getGlobalsAndPackages() ...
[11:00:02.855] Searching for globals...
[11:00:02.855] 
[11:00:02.855] Searching for globals ... DONE
[11:00:02.855] - globals: [0] <none>
[11:00:02.855] getGlobalsAndPackages() ... DONE
[11:00:02.855]    + additional globals found: [n=0] 
[11:00:02.856]    + additional namespaces needed: [n=0] 
[11:00:02.856]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:02.856]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:02.856]  - seeds: <none>
[11:00:02.856]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.856] getGlobalsAndPackages() ...
[11:00:02.856] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.856] Resolving globals: FALSE
[11:00:02.856] Tweak future expression to call with '...' arguments ...
[11:00:02.856] {
[11:00:02.856]     do.call(function(...) {
[11:00:02.856]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.856]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.856]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.856]             on.exit(options(oopts), add = TRUE)
[11:00:02.856]         }
[11:00:02.856]         {
[11:00:02.856]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.856]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.856]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.856]             })
[11:00:02.856]         }
[11:00:02.856]     }, args = future.call.arguments)
[11:00:02.856] }
[11:00:02.857] Tweak future expression to call with '...' arguments ... DONE
[11:00:02.857] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.857] - packages: [1] ‘future.apply’
[11:00:02.857] getGlobalsAndPackages() ... DONE
[11:00:02.858] run() for ‘Future’ ...
[11:00:02.858] - state: ‘created’
[11:00:02.858] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:02.859] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.860] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:02.860]   - Field: ‘label’
[11:00:02.860]   - Field: ‘local’
[11:00:02.860]   - Field: ‘owner’
[11:00:02.860]   - Field: ‘envir’
[11:00:02.860]   - Field: ‘workers’
[11:00:02.860]   - Field: ‘packages’
[11:00:02.860]   - Field: ‘gc’
[11:00:02.860]   - Field: ‘job’
[11:00:02.860]   - Field: ‘conditions’
[11:00:02.860]   - Field: ‘expr’
[11:00:02.861]   - Field: ‘uuid’
[11:00:02.861]   - Field: ‘seed’
[11:00:02.861]   - Field: ‘version’
[11:00:02.861]   - Field: ‘result’
[11:00:02.861]   - Field: ‘asynchronous’
[11:00:02.861]   - Field: ‘calls’
[11:00:02.861]   - Field: ‘globals’
[11:00:02.861]   - Field: ‘stdout’
[11:00:02.861]   - Field: ‘earlySignal’
[11:00:02.861]   - Field: ‘lazy’
[11:00:02.861]   - Field: ‘state’
[11:00:02.861] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:02.861] - Launch lazy future ...
[11:00:02.862] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:02.862] Packages needed by future strategies (n = 0): <none>
[11:00:02.862] {
[11:00:02.862]     {
[11:00:02.862]         {
[11:00:02.862]             ...future.startTime <- base::Sys.time()
[11:00:02.862]             {
[11:00:02.862]                 {
[11:00:02.862]                   {
[11:00:02.862]                     {
[11:00:02.862]                       {
[11:00:02.862]                         base::local({
[11:00:02.862]                           has_future <- base::requireNamespace("future", 
[11:00:02.862]                             quietly = TRUE)
[11:00:02.862]                           if (has_future) {
[11:00:02.862]                             ns <- base::getNamespace("future")
[11:00:02.862]                             version <- ns[[".package"]][["version"]]
[11:00:02.862]                             if (is.null(version)) 
[11:00:02.862]                               version <- utils::packageVersion("future")
[11:00:02.862]                           }
[11:00:02.862]                           else {
[11:00:02.862]                             version <- NULL
[11:00:02.862]                           }
[11:00:02.862]                           if (!has_future || version < "1.8.0") {
[11:00:02.862]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:02.862]                               "", base::R.version$version.string), 
[11:00:02.862]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:02.862]                                 base::R.version$platform, 8 * 
[11:00:02.862]                                   base::.Machine$sizeof.pointer), 
[11:00:02.862]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:02.862]                                 "release", "version")], collapse = " "), 
[11:00:02.862]                               hostname = base::Sys.info()[["nodename"]])
[11:00:02.862]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:02.862]                               info)
[11:00:02.862]                             info <- base::paste(info, collapse = "; ")
[11:00:02.862]                             if (!has_future) {
[11:00:02.862]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:02.862]                                 info)
[11:00:02.862]                             }
[11:00:02.862]                             else {
[11:00:02.862]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:02.862]                                 info, version)
[11:00:02.862]                             }
[11:00:02.862]                             base::stop(msg)
[11:00:02.862]                           }
[11:00:02.862]                         })
[11:00:02.862]                       }
[11:00:02.862]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:02.862]                       base::options(mc.cores = 1L)
[11:00:02.862]                     }
[11:00:02.862]                     base::local({
[11:00:02.862]                       for (pkg in "future.apply") {
[11:00:02.862]                         base::loadNamespace(pkg)
[11:00:02.862]                         base::library(pkg, character.only = TRUE)
[11:00:02.862]                       }
[11:00:02.862]                     })
[11:00:02.862]                   }
[11:00:02.862]                   ...future.strategy.old <- future::plan("list")
[11:00:02.862]                   options(future.plan = NULL)
[11:00:02.862]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.862]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:02.862]                 }
[11:00:02.862]                 ...future.workdir <- getwd()
[11:00:02.862]             }
[11:00:02.862]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:02.862]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:02.862]         }
[11:00:02.862]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:02.862]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:02.862]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:02.862]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:02.862]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:02.862]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:02.862]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:02.862]             base::names(...future.oldOptions))
[11:00:02.862]     }
[11:00:02.862]     if (FALSE) {
[11:00:02.862]     }
[11:00:02.862]     else {
[11:00:02.862]         if (TRUE) {
[11:00:02.862]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:02.862]                 open = "w")
[11:00:02.862]         }
[11:00:02.862]         else {
[11:00:02.862]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:02.862]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:02.862]         }
[11:00:02.862]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:02.862]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:02.862]             base::sink(type = "output", split = FALSE)
[11:00:02.862]             base::close(...future.stdout)
[11:00:02.862]         }, add = TRUE)
[11:00:02.862]     }
[11:00:02.862]     ...future.frame <- base::sys.nframe()
[11:00:02.862]     ...future.conditions <- base::list()
[11:00:02.862]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:02.862]     if (FALSE) {
[11:00:02.862]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:02.862]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:02.862]     }
[11:00:02.862]     ...future.result <- base::tryCatch({
[11:00:02.862]         base::withCallingHandlers({
[11:00:02.862]             ...future.value <- base::withVisible(base::local({
[11:00:02.862]                 withCallingHandlers({
[11:00:02.862]                   {
[11:00:02.862]                     do.call(function(...) {
[11:00:02.862]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.862]                       if (!identical(...future.globals.maxSize.org, 
[11:00:02.862]                         ...future.globals.maxSize)) {
[11:00:02.862]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.862]                         on.exit(options(oopts), add = TRUE)
[11:00:02.862]                       }
[11:00:02.862]                       {
[11:00:02.862]                         lapply(seq_along(...future.elements_ii), 
[11:00:02.862]                           FUN = function(jj) {
[11:00:02.862]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.862]                             ...future.FUN(...future.X_jj, ...)
[11:00:02.862]                           })
[11:00:02.862]                       }
[11:00:02.862]                     }, args = future.call.arguments)
[11:00:02.862]                   }
[11:00:02.862]                 }, immediateCondition = function(cond) {
[11:00:02.862]                   save_rds <- function (object, pathname, ...) 
[11:00:02.862]                   {
[11:00:02.862]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:02.862]                     if (file_test("-f", pathname_tmp)) {
[11:00:02.862]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.862]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:02.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.862]                         fi_tmp[["mtime"]])
[11:00:02.862]                     }
[11:00:02.862]                     tryCatch({
[11:00:02.862]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:02.862]                     }, error = function(ex) {
[11:00:02.862]                       msg <- conditionMessage(ex)
[11:00:02.862]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.862]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:02.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.862]                         fi_tmp[["mtime"]], msg)
[11:00:02.862]                       ex$message <- msg
[11:00:02.862]                       stop(ex)
[11:00:02.862]                     })
[11:00:02.862]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:02.862]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:02.862]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:02.862]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.862]                       fi <- file.info(pathname)
[11:00:02.862]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:02.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.862]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:02.862]                         fi[["size"]], fi[["mtime"]])
[11:00:02.862]                       stop(msg)
[11:00:02.862]                     }
[11:00:02.862]                     invisible(pathname)
[11:00:02.862]                   }
[11:00:02.862]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:02.862]                     rootPath = tempdir()) 
[11:00:02.862]                   {
[11:00:02.862]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:02.862]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:02.862]                       tmpdir = path, fileext = ".rds")
[11:00:02.862]                     save_rds(obj, file)
[11:00:02.862]                   }
[11:00:02.862]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:02.862]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.862]                   {
[11:00:02.862]                     inherits <- base::inherits
[11:00:02.862]                     invokeRestart <- base::invokeRestart
[11:00:02.862]                     is.null <- base::is.null
[11:00:02.862]                     muffled <- FALSE
[11:00:02.862]                     if (inherits(cond, "message")) {
[11:00:02.862]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:02.862]                       if (muffled) 
[11:00:02.862]                         invokeRestart("muffleMessage")
[11:00:02.862]                     }
[11:00:02.862]                     else if (inherits(cond, "warning")) {
[11:00:02.862]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:02.862]                       if (muffled) 
[11:00:02.862]                         invokeRestart("muffleWarning")
[11:00:02.862]                     }
[11:00:02.862]                     else if (inherits(cond, "condition")) {
[11:00:02.862]                       if (!is.null(pattern)) {
[11:00:02.862]                         computeRestarts <- base::computeRestarts
[11:00:02.862]                         grepl <- base::grepl
[11:00:02.862]                         restarts <- computeRestarts(cond)
[11:00:02.862]                         for (restart in restarts) {
[11:00:02.862]                           name <- restart$name
[11:00:02.862]                           if (is.null(name)) 
[11:00:02.862]                             next
[11:00:02.862]                           if (!grepl(pattern, name)) 
[11:00:02.862]                             next
[11:00:02.862]                           invokeRestart(restart)
[11:00:02.862]                           muffled <- TRUE
[11:00:02.862]                           break
[11:00:02.862]                         }
[11:00:02.862]                       }
[11:00:02.862]                     }
[11:00:02.862]                     invisible(muffled)
[11:00:02.862]                   }
[11:00:02.862]                   muffleCondition(cond)
[11:00:02.862]                 })
[11:00:02.862]             }))
[11:00:02.862]             future::FutureResult(value = ...future.value$value, 
[11:00:02.862]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.862]                   ...future.rng), globalenv = if (FALSE) 
[11:00:02.862]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:02.862]                     ...future.globalenv.names))
[11:00:02.862]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:02.862]         }, condition = base::local({
[11:00:02.862]             c <- base::c
[11:00:02.862]             inherits <- base::inherits
[11:00:02.862]             invokeRestart <- base::invokeRestart
[11:00:02.862]             length <- base::length
[11:00:02.862]             list <- base::list
[11:00:02.862]             seq.int <- base::seq.int
[11:00:02.862]             signalCondition <- base::signalCondition
[11:00:02.862]             sys.calls <- base::sys.calls
[11:00:02.862]             `[[` <- base::`[[`
[11:00:02.862]             `+` <- base::`+`
[11:00:02.862]             `<<-` <- base::`<<-`
[11:00:02.862]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:02.862]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:02.862]                   3L)]
[11:00:02.862]             }
[11:00:02.862]             function(cond) {
[11:00:02.862]                 is_error <- inherits(cond, "error")
[11:00:02.862]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:02.862]                   NULL)
[11:00:02.862]                 if (is_error) {
[11:00:02.862]                   sessionInformation <- function() {
[11:00:02.862]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:02.862]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:02.862]                       search = base::search(), system = base::Sys.info())
[11:00:02.862]                   }
[11:00:02.862]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.862]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:02.862]                     cond$call), session = sessionInformation(), 
[11:00:02.862]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:02.862]                   signalCondition(cond)
[11:00:02.862]                 }
[11:00:02.862]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:02.862]                 "immediateCondition"))) {
[11:00:02.862]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:02.862]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.862]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:02.862]                   if (TRUE && !signal) {
[11:00:02.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.862]                     {
[11:00:02.862]                       inherits <- base::inherits
[11:00:02.862]                       invokeRestart <- base::invokeRestart
[11:00:02.862]                       is.null <- base::is.null
[11:00:02.862]                       muffled <- FALSE
[11:00:02.862]                       if (inherits(cond, "message")) {
[11:00:02.862]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.862]                         if (muffled) 
[11:00:02.862]                           invokeRestart("muffleMessage")
[11:00:02.862]                       }
[11:00:02.862]                       else if (inherits(cond, "warning")) {
[11:00:02.862]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.862]                         if (muffled) 
[11:00:02.862]                           invokeRestart("muffleWarning")
[11:00:02.862]                       }
[11:00:02.862]                       else if (inherits(cond, "condition")) {
[11:00:02.862]                         if (!is.null(pattern)) {
[11:00:02.862]                           computeRestarts <- base::computeRestarts
[11:00:02.862]                           grepl <- base::grepl
[11:00:02.862]                           restarts <- computeRestarts(cond)
[11:00:02.862]                           for (restart in restarts) {
[11:00:02.862]                             name <- restart$name
[11:00:02.862]                             if (is.null(name)) 
[11:00:02.862]                               next
[11:00:02.862]                             if (!grepl(pattern, name)) 
[11:00:02.862]                               next
[11:00:02.862]                             invokeRestart(restart)
[11:00:02.862]                             muffled <- TRUE
[11:00:02.862]                             break
[11:00:02.862]                           }
[11:00:02.862]                         }
[11:00:02.862]                       }
[11:00:02.862]                       invisible(muffled)
[11:00:02.862]                     }
[11:00:02.862]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.862]                   }
[11:00:02.862]                 }
[11:00:02.862]                 else {
[11:00:02.862]                   if (TRUE) {
[11:00:02.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.862]                     {
[11:00:02.862]                       inherits <- base::inherits
[11:00:02.862]                       invokeRestart <- base::invokeRestart
[11:00:02.862]                       is.null <- base::is.null
[11:00:02.862]                       muffled <- FALSE
[11:00:02.862]                       if (inherits(cond, "message")) {
[11:00:02.862]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.862]                         if (muffled) 
[11:00:02.862]                           invokeRestart("muffleMessage")
[11:00:02.862]                       }
[11:00:02.862]                       else if (inherits(cond, "warning")) {
[11:00:02.862]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.862]                         if (muffled) 
[11:00:02.862]                           invokeRestart("muffleWarning")
[11:00:02.862]                       }
[11:00:02.862]                       else if (inherits(cond, "condition")) {
[11:00:02.862]                         if (!is.null(pattern)) {
[11:00:02.862]                           computeRestarts <- base::computeRestarts
[11:00:02.862]                           grepl <- base::grepl
[11:00:02.862]                           restarts <- computeRestarts(cond)
[11:00:02.862]                           for (restart in restarts) {
[11:00:02.862]                             name <- restart$name
[11:00:02.862]                             if (is.null(name)) 
[11:00:02.862]                               next
[11:00:02.862]                             if (!grepl(pattern, name)) 
[11:00:02.862]                               next
[11:00:02.862]                             invokeRestart(restart)
[11:00:02.862]                             muffled <- TRUE
[11:00:02.862]                             break
[11:00:02.862]                           }
[11:00:02.862]                         }
[11:00:02.862]                       }
[11:00:02.862]                       invisible(muffled)
[11:00:02.862]                     }
[11:00:02.862]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.862]                   }
[11:00:02.862]                 }
[11:00:02.862]             }
[11:00:02.862]         }))
[11:00:02.862]     }, error = function(ex) {
[11:00:02.862]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:02.862]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.862]                 ...future.rng), started = ...future.startTime, 
[11:00:02.862]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:02.862]             version = "1.8"), class = "FutureResult")
[11:00:02.862]     }, finally = {
[11:00:02.862]         if (!identical(...future.workdir, getwd())) 
[11:00:02.862]             setwd(...future.workdir)
[11:00:02.862]         {
[11:00:02.862]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:02.862]                 ...future.oldOptions$nwarnings <- NULL
[11:00:02.862]             }
[11:00:02.862]             base::options(...future.oldOptions)
[11:00:02.862]             if (.Platform$OS.type == "windows") {
[11:00:02.862]                 old_names <- names(...future.oldEnvVars)
[11:00:02.862]                 envs <- base::Sys.getenv()
[11:00:02.862]                 names <- names(envs)
[11:00:02.862]                 common <- intersect(names, old_names)
[11:00:02.862]                 added <- setdiff(names, old_names)
[11:00:02.862]                 removed <- setdiff(old_names, names)
[11:00:02.862]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:02.862]                   envs[common]]
[11:00:02.862]                 NAMES <- toupper(changed)
[11:00:02.862]                 args <- list()
[11:00:02.862]                 for (kk in seq_along(NAMES)) {
[11:00:02.862]                   name <- changed[[kk]]
[11:00:02.862]                   NAME <- NAMES[[kk]]
[11:00:02.862]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.862]                     next
[11:00:02.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.862]                 }
[11:00:02.862]                 NAMES <- toupper(added)
[11:00:02.862]                 for (kk in seq_along(NAMES)) {
[11:00:02.862]                   name <- added[[kk]]
[11:00:02.862]                   NAME <- NAMES[[kk]]
[11:00:02.862]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.862]                     next
[11:00:02.862]                   args[[name]] <- ""
[11:00:02.862]                 }
[11:00:02.862]                 NAMES <- toupper(removed)
[11:00:02.862]                 for (kk in seq_along(NAMES)) {
[11:00:02.862]                   name <- removed[[kk]]
[11:00:02.862]                   NAME <- NAMES[[kk]]
[11:00:02.862]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.862]                     next
[11:00:02.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.862]                 }
[11:00:02.862]                 if (length(args) > 0) 
[11:00:02.862]                   base::do.call(base::Sys.setenv, args = args)
[11:00:02.862]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:02.862]             }
[11:00:02.862]             else {
[11:00:02.862]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:02.862]             }
[11:00:02.862]             {
[11:00:02.862]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:02.862]                   0L) {
[11:00:02.862]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:02.862]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:02.862]                   base::options(opts)
[11:00:02.862]                 }
[11:00:02.862]                 {
[11:00:02.862]                   {
[11:00:02.862]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:02.862]                     NULL
[11:00:02.862]                   }
[11:00:02.862]                   options(future.plan = NULL)
[11:00:02.862]                   if (is.na(NA_character_)) 
[11:00:02.862]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.862]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:02.862]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:02.862]                     .init = FALSE)
[11:00:02.862]                 }
[11:00:02.862]             }
[11:00:02.862]         }
[11:00:02.862]     })
[11:00:02.862]     if (TRUE) {
[11:00:02.862]         base::sink(type = "output", split = FALSE)
[11:00:02.862]         if (TRUE) {
[11:00:02.862]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:02.862]         }
[11:00:02.862]         else {
[11:00:02.862]             ...future.result["stdout"] <- base::list(NULL)
[11:00:02.862]         }
[11:00:02.862]         base::close(...future.stdout)
[11:00:02.862]         ...future.stdout <- NULL
[11:00:02.862]     }
[11:00:02.862]     ...future.result$conditions <- ...future.conditions
[11:00:02.862]     ...future.result$finished <- base::Sys.time()
[11:00:02.862]     ...future.result
[11:00:02.862] }
[11:00:02.865] assign_globals() ...
[11:00:02.865] List of 11
[11:00:02.865]  $ ...future.FUN            :function (x, ...)  
[11:00:02.865]  $ x_FUN                    :function (x)  
[11:00:02.865]  $ times                    : int 2
[11:00:02.865]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:02.865]  $ stop_if_not              :function (...)  
[11:00:02.865]  $ dim                      : NULL
[11:00:02.865]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:02.865]  $ future.call.arguments    : list()
[11:00:02.865]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.865]  $ ...future.elements_ii    :List of 1
[11:00:02.865]   ..$ : int 1
[11:00:02.865]  $ ...future.seeds_ii       : NULL
[11:00:02.865]  $ ...future.globals.maxSize: NULL
[11:00:02.865]  - attr(*, "where")=List of 11
[11:00:02.865]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:02.865]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:02.865]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:02.865]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:02.865]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:02.865]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:02.865]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:02.865]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:02.865]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:02.865]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:02.865]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:02.865]  - attr(*, "resolved")= logi FALSE
[11:00:02.865]  - attr(*, "total_size")= num 23676
[11:00:02.865]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.865]  - attr(*, "already-done")= logi TRUE
[11:00:02.873] - copied ‘...future.FUN’ to environment
[11:00:02.873] - copied ‘x_FUN’ to environment
[11:00:02.874] - copied ‘times’ to environment
[11:00:02.874] - copied ‘stopf’ to environment
[11:00:02.874] - copied ‘stop_if_not’ to environment
[11:00:02.874] - copied ‘dim’ to environment
[11:00:02.874] - copied ‘valid_types’ to environment
[11:00:02.874] - copied ‘future.call.arguments’ to environment
[11:00:02.874] - copied ‘...future.elements_ii’ to environment
[11:00:02.874] - copied ‘...future.seeds_ii’ to environment
[11:00:02.874] - copied ‘...future.globals.maxSize’ to environment
[11:00:02.874] assign_globals() ... done
[11:00:02.874] requestCore(): workers = 2
[11:00:02.876] MulticoreFuture started
[11:00:02.877] - Launch lazy future ... done
[11:00:02.877] run() for ‘MulticoreFuture’ ... done
[11:00:02.877] Created future:
[11:00:02.878] plan(): Setting new future strategy stack:
[11:00:02.878] List of future strategies:
[11:00:02.878] 1. sequential:
[11:00:02.878]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:02.878]    - tweaked: FALSE
[11:00:02.878]    - call: NULL
[11:00:02.879] plan(): nbrOfWorkers() = 1
[11:00:02.881] plan(): Setting new future strategy stack:
[11:00:02.881] List of future strategies:
[11:00:02.881] 1. multicore:
[11:00:02.881]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:02.881]    - tweaked: FALSE
[11:00:02.881]    - call: plan(strategy)
[11:00:02.885] plan(): nbrOfWorkers() = 2
[11:00:02.877] MulticoreFuture:
[11:00:02.877] Label: ‘future_vapply-1’
[11:00:02.877] Expression:
[11:00:02.877] {
[11:00:02.877]     do.call(function(...) {
[11:00:02.877]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.877]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.877]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.877]             on.exit(options(oopts), add = TRUE)
[11:00:02.877]         }
[11:00:02.877]         {
[11:00:02.877]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.877]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.877]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.877]             })
[11:00:02.877]         }
[11:00:02.877]     }, args = future.call.arguments)
[11:00:02.877] }
[11:00:02.877] Lazy evaluation: FALSE
[11:00:02.877] Asynchronous evaluation: TRUE
[11:00:02.877] Local evaluation: TRUE
[11:00:02.877] Environment: R_GlobalEnv
[11:00:02.877] Capture standard output: TRUE
[11:00:02.877] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:02.877] Globals: 11 objects totaling 13.00 KiB (function ‘...future.FUN’ of 4.65 KiB, function ‘x_FUN’ of 185 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:02.877] Packages: 1 packages (‘future.apply’)
[11:00:02.877] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:02.877] Resolved: FALSE
[11:00:02.877] Value: <not collected>
[11:00:02.877] Conditions captured: <none>
[11:00:02.877] Early signaling: FALSE
[11:00:02.877] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:02.877] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.890] Chunk #1 of 2 ... DONE
[11:00:02.890] Chunk #2 of 2 ...
[11:00:02.891]  - Finding globals in 'X' for chunk #2 ...
[11:00:02.891] getGlobalsAndPackages() ...
[11:00:02.891] Searching for globals...
[11:00:02.891] 
[11:00:02.892] Searching for globals ... DONE
[11:00:02.892] - globals: [0] <none>
[11:00:02.892] getGlobalsAndPackages() ... DONE
[11:00:02.892]    + additional globals found: [n=0] 
[11:00:02.892]    + additional namespaces needed: [n=0] 
[11:00:02.892]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:02.892]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:02.892]  - seeds: <none>
[11:00:02.893]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.893] getGlobalsAndPackages() ...
[11:00:02.893] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.893] Resolving globals: FALSE
[11:00:02.893] Tweak future expression to call with '...' arguments ...
[11:00:02.893] {
[11:00:02.893]     do.call(function(...) {
[11:00:02.893]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.893]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.893]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.893]             on.exit(options(oopts), add = TRUE)
[11:00:02.893]         }
[11:00:02.893]         {
[11:00:02.893]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.893]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.893]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.893]             })
[11:00:02.893]         }
[11:00:02.893]     }, args = future.call.arguments)
[11:00:02.893] }
[11:00:02.894] Tweak future expression to call with '...' arguments ... DONE
[11:00:02.894] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:02.895] - packages: [1] ‘future.apply’
[11:00:02.895] getGlobalsAndPackages() ... DONE
[11:00:02.895] run() for ‘Future’ ...
[11:00:02.895] - state: ‘created’
[11:00:02.896] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:02.898] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.898] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:02.898]   - Field: ‘label’
[11:00:02.898]   - Field: ‘local’
[11:00:02.898]   - Field: ‘owner’
[11:00:02.899]   - Field: ‘envir’
[11:00:02.899]   - Field: ‘workers’
[11:00:02.899]   - Field: ‘packages’
[11:00:02.899]   - Field: ‘gc’
[11:00:02.899]   - Field: ‘job’
[11:00:02.899]   - Field: ‘conditions’
[11:00:02.899]   - Field: ‘expr’
[11:00:02.899]   - Field: ‘uuid’
[11:00:02.900]   - Field: ‘seed’
[11:00:02.900]   - Field: ‘version’
[11:00:02.900]   - Field: ‘result’
[11:00:02.900]   - Field: ‘asynchronous’
[11:00:02.900]   - Field: ‘calls’
[11:00:02.900]   - Field: ‘globals’
[11:00:02.900]   - Field: ‘stdout’
[11:00:02.901]   - Field: ‘earlySignal’
[11:00:02.901]   - Field: ‘lazy’
[11:00:02.901]   - Field: ‘state’
[11:00:02.901] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:02.901] - Launch lazy future ...
[11:00:02.902] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:02.902] Packages needed by future strategies (n = 0): <none>
[11:00:02.905] {
[11:00:02.905]     {
[11:00:02.905]         {
[11:00:02.905]             ...future.startTime <- base::Sys.time()
[11:00:02.905]             {
[11:00:02.905]                 {
[11:00:02.905]                   {
[11:00:02.905]                     {
[11:00:02.905]                       {
[11:00:02.905]                         base::local({
[11:00:02.905]                           has_future <- base::requireNamespace("future", 
[11:00:02.905]                             quietly = TRUE)
[11:00:02.905]                           if (has_future) {
[11:00:02.905]                             ns <- base::getNamespace("future")
[11:00:02.905]                             version <- ns[[".package"]][["version"]]
[11:00:02.905]                             if (is.null(version)) 
[11:00:02.905]                               version <- utils::packageVersion("future")
[11:00:02.905]                           }
[11:00:02.905]                           else {
[11:00:02.905]                             version <- NULL
[11:00:02.905]                           }
[11:00:02.905]                           if (!has_future || version < "1.8.0") {
[11:00:02.905]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:02.905]                               "", base::R.version$version.string), 
[11:00:02.905]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:02.905]                                 base::R.version$platform, 8 * 
[11:00:02.905]                                   base::.Machine$sizeof.pointer), 
[11:00:02.905]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:02.905]                                 "release", "version")], collapse = " "), 
[11:00:02.905]                               hostname = base::Sys.info()[["nodename"]])
[11:00:02.905]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:02.905]                               info)
[11:00:02.905]                             info <- base::paste(info, collapse = "; ")
[11:00:02.905]                             if (!has_future) {
[11:00:02.905]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:02.905]                                 info)
[11:00:02.905]                             }
[11:00:02.905]                             else {
[11:00:02.905]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:02.905]                                 info, version)
[11:00:02.905]                             }
[11:00:02.905]                             base::stop(msg)
[11:00:02.905]                           }
[11:00:02.905]                         })
[11:00:02.905]                       }
[11:00:02.905]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:02.905]                       base::options(mc.cores = 1L)
[11:00:02.905]                     }
[11:00:02.905]                     base::local({
[11:00:02.905]                       for (pkg in "future.apply") {
[11:00:02.905]                         base::loadNamespace(pkg)
[11:00:02.905]                         base::library(pkg, character.only = TRUE)
[11:00:02.905]                       }
[11:00:02.905]                     })
[11:00:02.905]                   }
[11:00:02.905]                   ...future.strategy.old <- future::plan("list")
[11:00:02.905]                   options(future.plan = NULL)
[11:00:02.905]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.905]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:02.905]                 }
[11:00:02.905]                 ...future.workdir <- getwd()
[11:00:02.905]             }
[11:00:02.905]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:02.905]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:02.905]         }
[11:00:02.905]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:02.905]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:02.905]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:02.905]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:02.905]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:02.905]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:02.905]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:02.905]             base::names(...future.oldOptions))
[11:00:02.905]     }
[11:00:02.905]     if (FALSE) {
[11:00:02.905]     }
[11:00:02.905]     else {
[11:00:02.905]         if (TRUE) {
[11:00:02.905]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:02.905]                 open = "w")
[11:00:02.905]         }
[11:00:02.905]         else {
[11:00:02.905]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:02.905]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:02.905]         }
[11:00:02.905]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:02.905]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:02.905]             base::sink(type = "output", split = FALSE)
[11:00:02.905]             base::close(...future.stdout)
[11:00:02.905]         }, add = TRUE)
[11:00:02.905]     }
[11:00:02.905]     ...future.frame <- base::sys.nframe()
[11:00:02.905]     ...future.conditions <- base::list()
[11:00:02.905]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:02.905]     if (FALSE) {
[11:00:02.905]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:02.905]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:02.905]     }
[11:00:02.905]     ...future.result <- base::tryCatch({
[11:00:02.905]         base::withCallingHandlers({
[11:00:02.905]             ...future.value <- base::withVisible(base::local({
[11:00:02.905]                 withCallingHandlers({
[11:00:02.905]                   {
[11:00:02.905]                     do.call(function(...) {
[11:00:02.905]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.905]                       if (!identical(...future.globals.maxSize.org, 
[11:00:02.905]                         ...future.globals.maxSize)) {
[11:00:02.905]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.905]                         on.exit(options(oopts), add = TRUE)
[11:00:02.905]                       }
[11:00:02.905]                       {
[11:00:02.905]                         lapply(seq_along(...future.elements_ii), 
[11:00:02.905]                           FUN = function(jj) {
[11:00:02.905]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.905]                             ...future.FUN(...future.X_jj, ...)
[11:00:02.905]                           })
[11:00:02.905]                       }
[11:00:02.905]                     }, args = future.call.arguments)
[11:00:02.905]                   }
[11:00:02.905]                 }, immediateCondition = function(cond) {
[11:00:02.905]                   save_rds <- function (object, pathname, ...) 
[11:00:02.905]                   {
[11:00:02.905]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:02.905]                     if (file_test("-f", pathname_tmp)) {
[11:00:02.905]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.905]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:02.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.905]                         fi_tmp[["mtime"]])
[11:00:02.905]                     }
[11:00:02.905]                     tryCatch({
[11:00:02.905]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:02.905]                     }, error = function(ex) {
[11:00:02.905]                       msg <- conditionMessage(ex)
[11:00:02.905]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.905]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:02.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.905]                         fi_tmp[["mtime"]], msg)
[11:00:02.905]                       ex$message <- msg
[11:00:02.905]                       stop(ex)
[11:00:02.905]                     })
[11:00:02.905]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:02.905]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:02.905]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:02.905]                       fi_tmp <- file.info(pathname_tmp)
[11:00:02.905]                       fi <- file.info(pathname)
[11:00:02.905]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:02.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:02.905]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:02.905]                         fi[["size"]], fi[["mtime"]])
[11:00:02.905]                       stop(msg)
[11:00:02.905]                     }
[11:00:02.905]                     invisible(pathname)
[11:00:02.905]                   }
[11:00:02.905]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:02.905]                     rootPath = tempdir()) 
[11:00:02.905]                   {
[11:00:02.905]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:02.905]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:02.905]                       tmpdir = path, fileext = ".rds")
[11:00:02.905]                     save_rds(obj, file)
[11:00:02.905]                   }
[11:00:02.905]                   saveImmediateCondition(cond, path = "/tmp/RtmpOFhnbz/.future/immediateConditions")
[11:00:02.905]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.905]                   {
[11:00:02.905]                     inherits <- base::inherits
[11:00:02.905]                     invokeRestart <- base::invokeRestart
[11:00:02.905]                     is.null <- base::is.null
[11:00:02.905]                     muffled <- FALSE
[11:00:02.905]                     if (inherits(cond, "message")) {
[11:00:02.905]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:02.905]                       if (muffled) 
[11:00:02.905]                         invokeRestart("muffleMessage")
[11:00:02.905]                     }
[11:00:02.905]                     else if (inherits(cond, "warning")) {
[11:00:02.905]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:02.905]                       if (muffled) 
[11:00:02.905]                         invokeRestart("muffleWarning")
[11:00:02.905]                     }
[11:00:02.905]                     else if (inherits(cond, "condition")) {
[11:00:02.905]                       if (!is.null(pattern)) {
[11:00:02.905]                         computeRestarts <- base::computeRestarts
[11:00:02.905]                         grepl <- base::grepl
[11:00:02.905]                         restarts <- computeRestarts(cond)
[11:00:02.905]                         for (restart in restarts) {
[11:00:02.905]                           name <- restart$name
[11:00:02.905]                           if (is.null(name)) 
[11:00:02.905]                             next
[11:00:02.905]                           if (!grepl(pattern, name)) 
[11:00:02.905]                             next
[11:00:02.905]                           invokeRestart(restart)
[11:00:02.905]                           muffled <- TRUE
[11:00:02.905]                           break
[11:00:02.905]                         }
[11:00:02.905]                       }
[11:00:02.905]                     }
[11:00:02.905]                     invisible(muffled)
[11:00:02.905]                   }
[11:00:02.905]                   muffleCondition(cond)
[11:00:02.905]                 })
[11:00:02.905]             }))
[11:00:02.905]             future::FutureResult(value = ...future.value$value, 
[11:00:02.905]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.905]                   ...future.rng), globalenv = if (FALSE) 
[11:00:02.905]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:02.905]                     ...future.globalenv.names))
[11:00:02.905]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:02.905]         }, condition = base::local({
[11:00:02.905]             c <- base::c
[11:00:02.905]             inherits <- base::inherits
[11:00:02.905]             invokeRestart <- base::invokeRestart
[11:00:02.905]             length <- base::length
[11:00:02.905]             list <- base::list
[11:00:02.905]             seq.int <- base::seq.int
[11:00:02.905]             signalCondition <- base::signalCondition
[11:00:02.905]             sys.calls <- base::sys.calls
[11:00:02.905]             `[[` <- base::`[[`
[11:00:02.905]             `+` <- base::`+`
[11:00:02.905]             `<<-` <- base::`<<-`
[11:00:02.905]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:02.905]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:02.905]                   3L)]
[11:00:02.905]             }
[11:00:02.905]             function(cond) {
[11:00:02.905]                 is_error <- inherits(cond, "error")
[11:00:02.905]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:02.905]                   NULL)
[11:00:02.905]                 if (is_error) {
[11:00:02.905]                   sessionInformation <- function() {
[11:00:02.905]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:02.905]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:02.905]                       search = base::search(), system = base::Sys.info())
[11:00:02.905]                   }
[11:00:02.905]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.905]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:02.905]                     cond$call), session = sessionInformation(), 
[11:00:02.905]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:02.905]                   signalCondition(cond)
[11:00:02.905]                 }
[11:00:02.905]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:02.905]                 "immediateCondition"))) {
[11:00:02.905]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:02.905]                   ...future.conditions[[length(...future.conditions) + 
[11:00:02.905]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:02.905]                   if (TRUE && !signal) {
[11:00:02.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.905]                     {
[11:00:02.905]                       inherits <- base::inherits
[11:00:02.905]                       invokeRestart <- base::invokeRestart
[11:00:02.905]                       is.null <- base::is.null
[11:00:02.905]                       muffled <- FALSE
[11:00:02.905]                       if (inherits(cond, "message")) {
[11:00:02.905]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.905]                         if (muffled) 
[11:00:02.905]                           invokeRestart("muffleMessage")
[11:00:02.905]                       }
[11:00:02.905]                       else if (inherits(cond, "warning")) {
[11:00:02.905]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.905]                         if (muffled) 
[11:00:02.905]                           invokeRestart("muffleWarning")
[11:00:02.905]                       }
[11:00:02.905]                       else if (inherits(cond, "condition")) {
[11:00:02.905]                         if (!is.null(pattern)) {
[11:00:02.905]                           computeRestarts <- base::computeRestarts
[11:00:02.905]                           grepl <- base::grepl
[11:00:02.905]                           restarts <- computeRestarts(cond)
[11:00:02.905]                           for (restart in restarts) {
[11:00:02.905]                             name <- restart$name
[11:00:02.905]                             if (is.null(name)) 
[11:00:02.905]                               next
[11:00:02.905]                             if (!grepl(pattern, name)) 
[11:00:02.905]                               next
[11:00:02.905]                             invokeRestart(restart)
[11:00:02.905]                             muffled <- TRUE
[11:00:02.905]                             break
[11:00:02.905]                           }
[11:00:02.905]                         }
[11:00:02.905]                       }
[11:00:02.905]                       invisible(muffled)
[11:00:02.905]                     }
[11:00:02.905]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.905]                   }
[11:00:02.905]                 }
[11:00:02.905]                 else {
[11:00:02.905]                   if (TRUE) {
[11:00:02.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:02.905]                     {
[11:00:02.905]                       inherits <- base::inherits
[11:00:02.905]                       invokeRestart <- base::invokeRestart
[11:00:02.905]                       is.null <- base::is.null
[11:00:02.905]                       muffled <- FALSE
[11:00:02.905]                       if (inherits(cond, "message")) {
[11:00:02.905]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:02.905]                         if (muffled) 
[11:00:02.905]                           invokeRestart("muffleMessage")
[11:00:02.905]                       }
[11:00:02.905]                       else if (inherits(cond, "warning")) {
[11:00:02.905]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:02.905]                         if (muffled) 
[11:00:02.905]                           invokeRestart("muffleWarning")
[11:00:02.905]                       }
[11:00:02.905]                       else if (inherits(cond, "condition")) {
[11:00:02.905]                         if (!is.null(pattern)) {
[11:00:02.905]                           computeRestarts <- base::computeRestarts
[11:00:02.905]                           grepl <- base::grepl
[11:00:02.905]                           restarts <- computeRestarts(cond)
[11:00:02.905]                           for (restart in restarts) {
[11:00:02.905]                             name <- restart$name
[11:00:02.905]                             if (is.null(name)) 
[11:00:02.905]                               next
[11:00:02.905]                             if (!grepl(pattern, name)) 
[11:00:02.905]                               next
[11:00:02.905]                             invokeRestart(restart)
[11:00:02.905]                             muffled <- TRUE
[11:00:02.905]                             break
[11:00:02.905]                           }
[11:00:02.905]                         }
[11:00:02.905]                       }
[11:00:02.905]                       invisible(muffled)
[11:00:02.905]                     }
[11:00:02.905]                     muffleCondition(cond, pattern = "^muffle")
[11:00:02.905]                   }
[11:00:02.905]                 }
[11:00:02.905]             }
[11:00:02.905]         }))
[11:00:02.905]     }, error = function(ex) {
[11:00:02.905]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:02.905]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:02.905]                 ...future.rng), started = ...future.startTime, 
[11:00:02.905]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:02.905]             version = "1.8"), class = "FutureResult")
[11:00:02.905]     }, finally = {
[11:00:02.905]         if (!identical(...future.workdir, getwd())) 
[11:00:02.905]             setwd(...future.workdir)
[11:00:02.905]         {
[11:00:02.905]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:02.905]                 ...future.oldOptions$nwarnings <- NULL
[11:00:02.905]             }
[11:00:02.905]             base::options(...future.oldOptions)
[11:00:02.905]             if (.Platform$OS.type == "windows") {
[11:00:02.905]                 old_names <- names(...future.oldEnvVars)
[11:00:02.905]                 envs <- base::Sys.getenv()
[11:00:02.905]                 names <- names(envs)
[11:00:02.905]                 common <- intersect(names, old_names)
[11:00:02.905]                 added <- setdiff(names, old_names)
[11:00:02.905]                 removed <- setdiff(old_names, names)
[11:00:02.905]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:02.905]                   envs[common]]
[11:00:02.905]                 NAMES <- toupper(changed)
[11:00:02.905]                 args <- list()
[11:00:02.905]                 for (kk in seq_along(NAMES)) {
[11:00:02.905]                   name <- changed[[kk]]
[11:00:02.905]                   NAME <- NAMES[[kk]]
[11:00:02.905]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.905]                     next
[11:00:02.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.905]                 }
[11:00:02.905]                 NAMES <- toupper(added)
[11:00:02.905]                 for (kk in seq_along(NAMES)) {
[11:00:02.905]                   name <- added[[kk]]
[11:00:02.905]                   NAME <- NAMES[[kk]]
[11:00:02.905]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.905]                     next
[11:00:02.905]                   args[[name]] <- ""
[11:00:02.905]                 }
[11:00:02.905]                 NAMES <- toupper(removed)
[11:00:02.905]                 for (kk in seq_along(NAMES)) {
[11:00:02.905]                   name <- removed[[kk]]
[11:00:02.905]                   NAME <- NAMES[[kk]]
[11:00:02.905]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:02.905]                     next
[11:00:02.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:02.905]                 }
[11:00:02.905]                 if (length(args) > 0) 
[11:00:02.905]                   base::do.call(base::Sys.setenv, args = args)
[11:00:02.905]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:02.905]             }
[11:00:02.905]             else {
[11:00:02.905]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:02.905]             }
[11:00:02.905]             {
[11:00:02.905]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:02.905]                   0L) {
[11:00:02.905]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:02.905]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:02.905]                   base::options(opts)
[11:00:02.905]                 }
[11:00:02.905]                 {
[11:00:02.905]                   {
[11:00:02.905]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:02.905]                     NULL
[11:00:02.905]                   }
[11:00:02.905]                   options(future.plan = NULL)
[11:00:02.905]                   if (is.na(NA_character_)) 
[11:00:02.905]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:02.905]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:02.905]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:02.905]                     .init = FALSE)
[11:00:02.905]                 }
[11:00:02.905]             }
[11:00:02.905]         }
[11:00:02.905]     })
[11:00:02.905]     if (TRUE) {
[11:00:02.905]         base::sink(type = "output", split = FALSE)
[11:00:02.905]         if (TRUE) {
[11:00:02.905]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:02.905]         }
[11:00:02.905]         else {
[11:00:02.905]             ...future.result["stdout"] <- base::list(NULL)
[11:00:02.905]         }
[11:00:02.905]         base::close(...future.stdout)
[11:00:02.905]         ...future.stdout <- NULL
[11:00:02.905]     }
[11:00:02.905]     ...future.result$conditions <- ...future.conditions
[11:00:02.905]     ...future.result$finished <- base::Sys.time()
[11:00:02.905]     ...future.result
[11:00:02.905] }
[11:00:02.909] assign_globals() ...
[11:00:02.909] List of 11
[11:00:02.909]  $ ...future.FUN            :function (x, ...)  
[11:00:02.909]  $ x_FUN                    :function (x)  
[11:00:02.909]  $ times                    : int 2
[11:00:02.909]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:02.909]  $ stop_if_not              :function (...)  
[11:00:02.909]  $ dim                      : NULL
[11:00:02.909]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[11:00:02.909]  $ future.call.arguments    : list()
[11:00:02.909]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:02.909]  $ ...future.elements_ii    :List of 2
[11:00:02.909]   ..$ : int 2
[11:00:02.909]   ..$ : int 3
[11:00:02.909]  $ ...future.seeds_ii       : NULL
[11:00:02.909]  $ ...future.globals.maxSize: NULL
[11:00:02.909]  - attr(*, "where")=List of 11
[11:00:02.909]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:02.909]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[11:00:02.909]   ..$ times                    :<environment: R_EmptyEnv> 
[11:00:02.909]   ..$ stopf                    :<environment: R_EmptyEnv> 
[11:00:02.909]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[11:00:02.909]   ..$ dim                      :<environment: R_EmptyEnv> 
[11:00:02.909]   ..$ valid_types              :<environment: R_EmptyEnv> 
[11:00:02.909]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:02.909]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:02.909]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:02.909]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:02.909]  - attr(*, "resolved")= logi FALSE
[11:00:02.909]  - attr(*, "total_size")= num 23676
[11:00:02.909]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:02.909]  - attr(*, "already-done")= logi TRUE
[11:00:02.922] - copied ‘...future.FUN’ to environment
[11:00:02.922] - copied ‘x_FUN’ to environment
[11:00:02.922] - copied ‘times’ to environment
[11:00:02.922] - copied ‘stopf’ to environment
[11:00:02.922] - copied ‘stop_if_not’ to environment
[11:00:02.922] - copied ‘dim’ to environment
[11:00:02.922] - copied ‘valid_types’ to environment
[11:00:02.923] - copied ‘future.call.arguments’ to environment
[11:00:02.923] - copied ‘...future.elements_ii’ to environment
[11:00:02.923] - copied ‘...future.seeds_ii’ to environment
[11:00:02.923] - copied ‘...future.globals.maxSize’ to environment
[11:00:02.923] assign_globals() ... done
[11:00:02.923] requestCore(): workers = 2
[11:00:02.925] MulticoreFuture started
[11:00:02.926] - Launch lazy future ... done
[11:00:02.926] run() for ‘MulticoreFuture’ ... done
[11:00:02.926] Created future:
[11:00:02.927] plan(): Setting new future strategy stack:
[11:00:02.927] List of future strategies:
[11:00:02.927] 1. sequential:
[11:00:02.927]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:02.927]    - tweaked: FALSE
[11:00:02.927]    - call: NULL
[11:00:02.928] plan(): nbrOfWorkers() = 1
[11:00:02.930] plan(): Setting new future strategy stack:
[11:00:02.930] List of future strategies:
[11:00:02.930] 1. multicore:
[11:00:02.930]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:02.930]    - tweaked: FALSE
[11:00:02.930]    - call: plan(strategy)
[11:00:02.934] plan(): nbrOfWorkers() = 2
[11:00:02.926] MulticoreFuture:
[11:00:02.926] Label: ‘future_vapply-2’
[11:00:02.926] Expression:
[11:00:02.926] {
[11:00:02.926]     do.call(function(...) {
[11:00:02.926]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:02.926]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:02.926]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:02.926]             on.exit(options(oopts), add = TRUE)
[11:00:02.926]         }
[11:00:02.926]         {
[11:00:02.926]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:02.926]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:02.926]                 ...future.FUN(...future.X_jj, ...)
[11:00:02.926]             })
[11:00:02.926]         }
[11:00:02.926]     }, args = future.call.arguments)
[11:00:02.926] }
[11:00:02.926] Lazy evaluation: FALSE
[11:00:02.926] Asynchronous evaluation: TRUE
[11:00:02.926] Local evaluation: TRUE
[11:00:02.926] Environment: R_GlobalEnv
[11:00:02.926] Capture standard output: TRUE
[11:00:02.926] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:02.926] Globals: 11 objects totaling 13.01 KiB (function ‘...future.FUN’ of 4.65 KiB, function ‘x_FUN’ of 185 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:02.926] Packages: 1 packages (‘future.apply’)
[11:00:02.926] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:02.926] Resolved: FALSE
[11:00:02.926] Value: <not collected>
[11:00:02.926] Conditions captured: <none>
[11:00:02.926] Early signaling: FALSE
[11:00:02.926] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:02.926] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:02.939] Chunk #2 of 2 ... DONE
[11:00:02.939] Launching 2 futures (chunks) ... DONE
[11:00:02.939] Resolving 2 futures (chunks) ...
[11:00:02.940] resolve() on list ...
[11:00:02.940]  recursive: 0
[11:00:02.940]  length: 2
[11:00:02.940] 
[11:00:02.940] Future #1
[11:00:02.941] result() for MulticoreFuture ...
[11:00:02.952] result() for MulticoreFuture ...
[11:00:02.952] result() for MulticoreFuture ... done
[11:00:02.952] signalConditions() ...
[11:00:02.952]  - include = ‘immediateCondition’
[11:00:02.953]  - exclude = 
[11:00:02.953]  - resignal = FALSE
[11:00:02.953]  - Number of conditions: 1
[11:00:02.953] signalConditions() ... done
[11:00:02.954] result() for MulticoreFuture ... done
[11:00:02.954] result() for MulticoreFuture ...
[11:00:02.954] result() for MulticoreFuture ... done
[11:00:02.954] signalConditions() ...
[11:00:02.954]  - include = ‘immediateCondition’
[11:00:02.955]  - exclude = 
[11:00:02.955]  - resignal = FALSE
[11:00:02.955]  - Number of conditions: 1
[11:00:02.955] signalConditions() ... done
[11:00:02.955] signalConditionsASAP(MulticoreFuture, pos=1) ...
[11:00:02.956] - nx: 2
[11:00:02.956] - relay: TRUE
[11:00:02.956] - stdout: TRUE
[11:00:02.956] - signal: TRUE
[11:00:02.956] - resignal: FALSE
[11:00:02.956] - force: TRUE
[11:00:02.957] - relayed: [n=2] FALSE, FALSE
[11:00:02.957] - queued futures: [n=2] FALSE, FALSE
[11:00:02.957]  - until=1
[11:00:02.957]  - relaying element #1
[11:00:02.957] result() for MulticoreFuture ...
[11:00:02.957] result() for MulticoreFuture ... done
[11:00:02.958] result() for MulticoreFuture ...
[11:00:02.958] result() for MulticoreFuture ... done
[11:00:02.958] signalConditions() ...
[11:00:02.958]  - include = ‘immediateCondition’
[11:00:02.958]  - exclude = 
[11:00:02.958]  - resignal = FALSE
[11:00:02.958]  - Number of conditions: 1
[11:00:02.959] signalConditions() ... done
[11:00:02.959] result() for MulticoreFuture ...
[11:00:02.959] result() for MulticoreFuture ... done
[11:00:02.959] signalConditions() ...
[11:00:02.959]  - include = ‘immediateCondition’
[11:00:02.960]  - exclude = 
[11:00:02.960]  - resignal = FALSE
[11:00:02.960]  - Number of conditions: 1
[11:00:02.960] signalConditions() ... done
[11:00:02.960] result() for MulticoreFuture ...
[11:00:02.960] result() for MulticoreFuture ... done
[11:00:02.960] signalConditions() ...
[11:00:02.961]  - include = ‘condition’
[11:00:02.961]  - exclude = ‘immediateCondition’
[11:00:02.961]  - resignal = TRUE
[11:00:02.961]  - Number of conditions: 1
[11:00:02.961]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:00:02.962] signalConditions() ... done
[11:00:02.962] - relayed: [n=2] FALSE, FALSE
[11:00:02.962] - queued futures: [n=2] TRUE, FALSE
[11:00:02.962] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[11:00:02.962] plan(): Setting new future strategy stack:
[11:00:02.962] List of future strategies:
[11:00:02.962] 1. sequential:
[11:00:02.962]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:02.962]    - tweaked: FALSE
[11:00:02.962]    - call: plan(sequential)
[11:00:02.963] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[11:00:02.964] plan(): Setting new future strategy stack:
[11:00:02.964] List of future strategies:
[11:00:02.964] 1. multisession:
[11:00:02.964]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:00:02.964]    - tweaked: FALSE
[11:00:02.964]    - call: plan(strategy)
[11:00:02.964] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[11:00:02.964] multisession:
[11:00:02.964] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:00:02.964] - tweaked: FALSE
[11:00:02.964] - call: plan(strategy)
[11:00:02.969] getGlobalsAndPackages() ...
[11:00:02.969] Not searching for globals
[11:00:02.969] - globals: [0] <none>
[11:00:02.969] getGlobalsAndPackages() ... DONE
[11:00:03.459] Packages needed by the future expression (n = 0): <none>
[11:00:03.459] Packages needed by future strategies (n = 0): <none>
[11:00:03.460] {
[11:00:03.460]     {
[11:00:03.460]         {
[11:00:03.460]             ...future.startTime <- base::Sys.time()
[11:00:03.460]             {
[11:00:03.460]                 {
[11:00:03.460]                   {
[11:00:03.460]                     {
[11:00:03.460]                       base::local({
[11:00:03.460]                         has_future <- base::requireNamespace("future", 
[11:00:03.460]                           quietly = TRUE)
[11:00:03.460]                         if (has_future) {
[11:00:03.460]                           ns <- base::getNamespace("future")
[11:00:03.460]                           version <- ns[[".package"]][["version"]]
[11:00:03.460]                           if (is.null(version)) 
[11:00:03.460]                             version <- utils::packageVersion("future")
[11:00:03.460]                         }
[11:00:03.460]                         else {
[11:00:03.460]                           version <- NULL
[11:00:03.460]                         }
[11:00:03.460]                         if (!has_future || version < "1.8.0") {
[11:00:03.460]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:03.460]                             "", base::R.version$version.string), 
[11:00:03.460]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:03.460]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:03.460]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:03.460]                               "release", "version")], collapse = " "), 
[11:00:03.460]                             hostname = base::Sys.info()[["nodename"]])
[11:00:03.460]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:03.460]                             info)
[11:00:03.460]                           info <- base::paste(info, collapse = "; ")
[11:00:03.460]                           if (!has_future) {
[11:00:03.460]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:03.460]                               info)
[11:00:03.460]                           }
[11:00:03.460]                           else {
[11:00:03.460]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:03.460]                               info, version)
[11:00:03.460]                           }
[11:00:03.460]                           base::stop(msg)
[11:00:03.460]                         }
[11:00:03.460]                       })
[11:00:03.460]                     }
[11:00:03.460]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:03.460]                     base::options(mc.cores = 1L)
[11:00:03.460]                   }
[11:00:03.460]                   ...future.strategy.old <- future::plan("list")
[11:00:03.460]                   options(future.plan = NULL)
[11:00:03.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:03.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:03.460]                 }
[11:00:03.460]                 ...future.workdir <- getwd()
[11:00:03.460]             }
[11:00:03.460]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:03.460]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:03.460]         }
[11:00:03.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:03.460]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:03.460]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:03.460]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:03.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:03.460]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:03.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:03.460]             base::names(...future.oldOptions))
[11:00:03.460]     }
[11:00:03.460]     if (FALSE) {
[11:00:03.460]     }
[11:00:03.460]     else {
[11:00:03.460]         if (TRUE) {
[11:00:03.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:03.460]                 open = "w")
[11:00:03.460]         }
[11:00:03.460]         else {
[11:00:03.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:03.460]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:03.460]         }
[11:00:03.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:03.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:03.460]             base::sink(type = "output", split = FALSE)
[11:00:03.460]             base::close(...future.stdout)
[11:00:03.460]         }, add = TRUE)
[11:00:03.460]     }
[11:00:03.460]     ...future.frame <- base::sys.nframe()
[11:00:03.460]     ...future.conditions <- base::list()
[11:00:03.460]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:03.460]     if (FALSE) {
[11:00:03.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:03.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:03.460]     }
[11:00:03.460]     ...future.result <- base::tryCatch({
[11:00:03.460]         base::withCallingHandlers({
[11:00:03.460]             ...future.value <- base::withVisible(base::local({
[11:00:03.460]                 ...future.makeSendCondition <- base::local({
[11:00:03.460]                   sendCondition <- NULL
[11:00:03.460]                   function(frame = 1L) {
[11:00:03.460]                     if (is.function(sendCondition)) 
[11:00:03.460]                       return(sendCondition)
[11:00:03.460]                     ns <- getNamespace("parallel")
[11:00:03.460]                     if (exists("sendData", mode = "function", 
[11:00:03.460]                       envir = ns)) {
[11:00:03.460]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:03.460]                         envir = ns)
[11:00:03.460]                       envir <- sys.frame(frame)
[11:00:03.460]                       master <- NULL
[11:00:03.460]                       while (!identical(envir, .GlobalEnv) && 
[11:00:03.460]                         !identical(envir, emptyenv())) {
[11:00:03.460]                         if (exists("master", mode = "list", envir = envir, 
[11:00:03.460]                           inherits = FALSE)) {
[11:00:03.460]                           master <- get("master", mode = "list", 
[11:00:03.460]                             envir = envir, inherits = FALSE)
[11:00:03.460]                           if (inherits(master, c("SOCKnode", 
[11:00:03.460]                             "SOCK0node"))) {
[11:00:03.460]                             sendCondition <<- function(cond) {
[11:00:03.460]                               data <- list(type = "VALUE", value = cond, 
[11:00:03.460]                                 success = TRUE)
[11:00:03.460]                               parallel_sendData(master, data)
[11:00:03.460]                             }
[11:00:03.460]                             return(sendCondition)
[11:00:03.460]                           }
[11:00:03.460]                         }
[11:00:03.460]                         frame <- frame + 1L
[11:00:03.460]                         envir <- sys.frame(frame)
[11:00:03.460]                       }
[11:00:03.460]                     }
[11:00:03.460]                     sendCondition <<- function(cond) NULL
[11:00:03.460]                   }
[11:00:03.460]                 })
[11:00:03.460]                 withCallingHandlers({
[11:00:03.460]                   NA
[11:00:03.460]                 }, immediateCondition = function(cond) {
[11:00:03.460]                   sendCondition <- ...future.makeSendCondition()
[11:00:03.460]                   sendCondition(cond)
[11:00:03.460]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:03.460]                   {
[11:00:03.460]                     inherits <- base::inherits
[11:00:03.460]                     invokeRestart <- base::invokeRestart
[11:00:03.460]                     is.null <- base::is.null
[11:00:03.460]                     muffled <- FALSE
[11:00:03.460]                     if (inherits(cond, "message")) {
[11:00:03.460]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:03.460]                       if (muffled) 
[11:00:03.460]                         invokeRestart("muffleMessage")
[11:00:03.460]                     }
[11:00:03.460]                     else if (inherits(cond, "warning")) {
[11:00:03.460]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:03.460]                       if (muffled) 
[11:00:03.460]                         invokeRestart("muffleWarning")
[11:00:03.460]                     }
[11:00:03.460]                     else if (inherits(cond, "condition")) {
[11:00:03.460]                       if (!is.null(pattern)) {
[11:00:03.460]                         computeRestarts <- base::computeRestarts
[11:00:03.460]                         grepl <- base::grepl
[11:00:03.460]                         restarts <- computeRestarts(cond)
[11:00:03.460]                         for (restart in restarts) {
[11:00:03.460]                           name <- restart$name
[11:00:03.460]                           if (is.null(name)) 
[11:00:03.460]                             next
[11:00:03.460]                           if (!grepl(pattern, name)) 
[11:00:03.460]                             next
[11:00:03.460]                           invokeRestart(restart)
[11:00:03.460]                           muffled <- TRUE
[11:00:03.460]                           break
[11:00:03.460]                         }
[11:00:03.460]                       }
[11:00:03.460]                     }
[11:00:03.460]                     invisible(muffled)
[11:00:03.460]                   }
[11:00:03.460]                   muffleCondition(cond)
[11:00:03.460]                 })
[11:00:03.460]             }))
[11:00:03.460]             future::FutureResult(value = ...future.value$value, 
[11:00:03.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:03.460]                   ...future.rng), globalenv = if (FALSE) 
[11:00:03.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:03.460]                     ...future.globalenv.names))
[11:00:03.460]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:03.460]         }, condition = base::local({
[11:00:03.460]             c <- base::c
[11:00:03.460]             inherits <- base::inherits
[11:00:03.460]             invokeRestart <- base::invokeRestart
[11:00:03.460]             length <- base::length
[11:00:03.460]             list <- base::list
[11:00:03.460]             seq.int <- base::seq.int
[11:00:03.460]             signalCondition <- base::signalCondition
[11:00:03.460]             sys.calls <- base::sys.calls
[11:00:03.460]             `[[` <- base::`[[`
[11:00:03.460]             `+` <- base::`+`
[11:00:03.460]             `<<-` <- base::`<<-`
[11:00:03.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:03.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:03.460]                   3L)]
[11:00:03.460]             }
[11:00:03.460]             function(cond) {
[11:00:03.460]                 is_error <- inherits(cond, "error")
[11:00:03.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:03.460]                   NULL)
[11:00:03.460]                 if (is_error) {
[11:00:03.460]                   sessionInformation <- function() {
[11:00:03.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:03.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:03.460]                       search = base::search(), system = base::Sys.info())
[11:00:03.460]                   }
[11:00:03.460]                   ...future.conditions[[length(...future.conditions) + 
[11:00:03.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:03.460]                     cond$call), session = sessionInformation(), 
[11:00:03.460]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:03.460]                   signalCondition(cond)
[11:00:03.460]                 }
[11:00:03.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:03.460]                 "immediateCondition"))) {
[11:00:03.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:03.460]                   ...future.conditions[[length(...future.conditions) + 
[11:00:03.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:03.460]                   if (TRUE && !signal) {
[11:00:03.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:03.460]                     {
[11:00:03.460]                       inherits <- base::inherits
[11:00:03.460]                       invokeRestart <- base::invokeRestart
[11:00:03.460]                       is.null <- base::is.null
[11:00:03.460]                       muffled <- FALSE
[11:00:03.460]                       if (inherits(cond, "message")) {
[11:00:03.460]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:03.460]                         if (muffled) 
[11:00:03.460]                           invokeRestart("muffleMessage")
[11:00:03.460]                       }
[11:00:03.460]                       else if (inherits(cond, "warning")) {
[11:00:03.460]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:03.460]                         if (muffled) 
[11:00:03.460]                           invokeRestart("muffleWarning")
[11:00:03.460]                       }
[11:00:03.460]                       else if (inherits(cond, "condition")) {
[11:00:03.460]                         if (!is.null(pattern)) {
[11:00:03.460]                           computeRestarts <- base::computeRestarts
[11:00:03.460]                           grepl <- base::grepl
[11:00:03.460]                           restarts <- computeRestarts(cond)
[11:00:03.460]                           for (restart in restarts) {
[11:00:03.460]                             name <- restart$name
[11:00:03.460]                             if (is.null(name)) 
[11:00:03.460]                               next
[11:00:03.460]                             if (!grepl(pattern, name)) 
[11:00:03.460]                               next
[11:00:03.460]                             invokeRestart(restart)
[11:00:03.460]                             muffled <- TRUE
[11:00:03.460]                             break
[11:00:03.460]                           }
[11:00:03.460]                         }
[11:00:03.460]                       }
[11:00:03.460]                       invisible(muffled)
[11:00:03.460]                     }
[11:00:03.460]                     muffleCondition(cond, pattern = "^muffle")
[11:00:03.460]                   }
[11:00:03.460]                 }
[11:00:03.460]                 else {
[11:00:03.460]                   if (TRUE) {
[11:00:03.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:03.460]                     {
[11:00:03.460]                       inherits <- base::inherits
[11:00:03.460]                       invokeRestart <- base::invokeRestart
[11:00:03.460]                       is.null <- base::is.null
[11:00:03.460]                       muffled <- FALSE
[11:00:03.460]                       if (inherits(cond, "message")) {
[11:00:03.460]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:03.460]                         if (muffled) 
[11:00:03.460]                           invokeRestart("muffleMessage")
[11:00:03.460]                       }
[11:00:03.460]                       else if (inherits(cond, "warning")) {
[11:00:03.460]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:03.460]                         if (muffled) 
[11:00:03.460]                           invokeRestart("muffleWarning")
[11:00:03.460]                       }
[11:00:03.460]                       else if (inherits(cond, "condition")) {
[11:00:03.460]                         if (!is.null(pattern)) {
[11:00:03.460]                           computeRestarts <- base::computeRestarts
[11:00:03.460]                           grepl <- base::grepl
[11:00:03.460]                           restarts <- computeRestarts(cond)
[11:00:03.460]                           for (restart in restarts) {
[11:00:03.460]                             name <- restart$name
[11:00:03.460]                             if (is.null(name)) 
[11:00:03.460]                               next
[11:00:03.460]                             if (!grepl(pattern, name)) 
[11:00:03.460]                               next
[11:00:03.460]                             invokeRestart(restart)
[11:00:03.460]                             muffled <- TRUE
[11:00:03.460]                             break
[11:00:03.460]                           }
[11:00:03.460]                         }
[11:00:03.460]                       }
[11:00:03.460]                       invisible(muffled)
[11:00:03.460]                     }
[11:00:03.460]                     muffleCondition(cond, pattern = "^muffle")
[11:00:03.460]                   }
[11:00:03.460]                 }
[11:00:03.460]             }
[11:00:03.460]         }))
[11:00:03.460]     }, error = function(ex) {
[11:00:03.460]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:03.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:03.460]                 ...future.rng), started = ...future.startTime, 
[11:00:03.460]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:03.460]             version = "1.8"), class = "FutureResult")
[11:00:03.460]     }, finally = {
[11:00:03.460]         if (!identical(...future.workdir, getwd())) 
[11:00:03.460]             setwd(...future.workdir)
[11:00:03.460]         {
[11:00:03.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:03.460]                 ...future.oldOptions$nwarnings <- NULL
[11:00:03.460]             }
[11:00:03.460]             base::options(...future.oldOptions)
[11:00:03.460]             if (.Platform$OS.type == "windows") {
[11:00:03.460]                 old_names <- names(...future.oldEnvVars)
[11:00:03.460]                 envs <- base::Sys.getenv()
[11:00:03.460]                 names <- names(envs)
[11:00:03.460]                 common <- intersect(names, old_names)
[11:00:03.460]                 added <- setdiff(names, old_names)
[11:00:03.460]                 removed <- setdiff(old_names, names)
[11:00:03.460]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:03.460]                   envs[common]]
[11:00:03.460]                 NAMES <- toupper(changed)
[11:00:03.460]                 args <- list()
[11:00:03.460]                 for (kk in seq_along(NAMES)) {
[11:00:03.460]                   name <- changed[[kk]]
[11:00:03.460]                   NAME <- NAMES[[kk]]
[11:00:03.460]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:03.460]                     next
[11:00:03.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:03.460]                 }
[11:00:03.460]                 NAMES <- toupper(added)
[11:00:03.460]                 for (kk in seq_along(NAMES)) {
[11:00:03.460]                   name <- added[[kk]]
[11:00:03.460]                   NAME <- NAMES[[kk]]
[11:00:03.460]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:03.460]                     next
[11:00:03.460]                   args[[name]] <- ""
[11:00:03.460]                 }
[11:00:03.460]                 NAMES <- toupper(removed)
[11:00:03.460]                 for (kk in seq_along(NAMES)) {
[11:00:03.460]                   name <- removed[[kk]]
[11:00:03.460]                   NAME <- NAMES[[kk]]
[11:00:03.460]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:03.460]                     next
[11:00:03.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:03.460]                 }
[11:00:03.460]                 if (length(args) > 0) 
[11:00:03.460]                   base::do.call(base::Sys.setenv, args = args)
[11:00:03.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:03.460]             }
[11:00:03.460]             else {
[11:00:03.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:03.460]             }
[11:00:03.460]             {
[11:00:03.460]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:03.460]                   0L) {
[11:00:03.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:03.460]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:03.460]                   base::options(opts)
[11:00:03.460]                 }
[11:00:03.460]                 {
[11:00:03.460]                   {
[11:00:03.460]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:03.460]                     NULL
[11:00:03.460]                   }
[11:00:03.460]                   options(future.plan = NULL)
[11:00:03.460]                   if (is.na(NA_character_)) 
[11:00:03.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:03.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:03.460]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:03.460]                     .init = FALSE)
[11:00:03.460]                 }
[11:00:03.460]             }
[11:00:03.460]         }
[11:00:03.460]     })
[11:00:03.460]     if (TRUE) {
[11:00:03.460]         base::sink(type = "output", split = FALSE)
[11:00:03.460]         if (TRUE) {
[11:00:03.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:03.460]         }
[11:00:03.460]         else {
[11:00:03.460]             ...future.result["stdout"] <- base::list(NULL)
[11:00:03.460]         }
[11:00:03.460]         base::close(...future.stdout)
[11:00:03.460]         ...future.stdout <- NULL
[11:00:03.460]     }
[11:00:03.460]     ...future.result$conditions <- ...future.conditions
[11:00:03.460]     ...future.result$finished <- base::Sys.time()
[11:00:03.460]     ...future.result
[11:00:03.460] }
[11:00:03.511] MultisessionFuture started
[11:00:03.511] result() for ClusterFuture ...
[11:00:03.512] receiveMessageFromWorker() for ClusterFuture ...
[11:00:03.512] - Validating connection of MultisessionFuture
[11:00:03.542] - received message: FutureResult
[11:00:03.542] - Received FutureResult
[11:00:03.542] - Erased future from FutureRegistry
[11:00:03.542] result() for ClusterFuture ...
[11:00:03.543] - result already collected: FutureResult
[11:00:03.543] result() for ClusterFuture ... done
[11:00:03.543] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:03.543] result() for ClusterFuture ... done
[11:00:03.543] result() for ClusterFuture ...
[11:00:03.543] - result already collected: FutureResult
[11:00:03.543] result() for ClusterFuture ... done
[11:00:03.543] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[11:00:03.545] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[11:00:03.547] future_lapply() ...
[11:00:03.550] Number of chunks: 2
[11:00:03.550] getGlobalsAndPackagesXApply() ...
[11:00:03.551]  - future.globals: TRUE
[11:00:03.551] getGlobalsAndPackages() ...
[11:00:03.551] Searching for globals...
[11:00:03.554] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[11:00:03.554] Searching for globals ... DONE
[11:00:03.554] Resolving globals: FALSE
[11:00:03.555] The total size of the 7 globals is 12.01 KiB (12294 bytes)
[11:00:03.555] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.02 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:03.555] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:03.556] - packages: [1] ‘future.apply’
[11:00:03.556] getGlobalsAndPackages() ... DONE
[11:00:03.556]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:03.556]  - needed namespaces: [n=1] ‘future.apply’
[11:00:03.556] Finding globals ... DONE
[11:00:03.556]  - use_args: TRUE
[11:00:03.556]  - Getting '...' globals ...
[11:00:03.557] resolve() on list ...
[11:00:03.557]  recursive: 0
[11:00:03.557]  length: 1
[11:00:03.557]  elements: ‘...’
[11:00:03.557]  length: 0 (resolved future 1)
[11:00:03.557] resolve() on list ... DONE
[11:00:03.557]    - '...' content: [n=0] 
[11:00:03.557] List of 1
[11:00:03.557]  $ ...: list()
[11:00:03.557]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:03.557]  - attr(*, "where")=List of 1
[11:00:03.557]   ..$ ...:<environment: 0x55bbad218c28> 
[11:00:03.557]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:03.557]  - attr(*, "resolved")= logi TRUE
[11:00:03.557]  - attr(*, "total_size")= num NA
[11:00:03.560]  - Getting '...' globals ... DONE
[11:00:03.560] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:03.560] List of 8
[11:00:03.560]  $ ...future.FUN:function (x, ...)  
[11:00:03.560]  $ x_FUN        :function (x)  
[11:00:03.560]  $ times        : int 1
[11:00:03.560]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:03.560]  $ stop_if_not  :function (...)  
[11:00:03.560]  $ dim          : NULL
[11:00:03.560]  $ valid_types  : chr "character"
[11:00:03.560]  $ ...          : list()
[11:00:03.560]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:03.560]  - attr(*, "where")=List of 8
[11:00:03.560]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:03.560]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:03.560]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:03.560]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:03.560]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:03.560]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:03.560]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:03.560]   ..$ ...          :<environment: 0x55bbad218c28> 
[11:00:03.560]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:03.560]  - attr(*, "resolved")= logi FALSE
[11:00:03.560]  - attr(*, "total_size")= num 22333
[11:00:03.566] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:03.567] getGlobalsAndPackagesXApply() ... DONE
[11:00:03.567] Number of futures (= number of chunks): 2
[11:00:03.567] Launching 2 futures (chunks) ...
[11:00:03.567] Chunk #1 of 2 ...
[11:00:03.567]  - Finding globals in 'X' for chunk #1 ...
[11:00:03.567] getGlobalsAndPackages() ...
[11:00:03.567] Searching for globals...
[11:00:03.568] 
[11:00:03.568] Searching for globals ... DONE
[11:00:03.568] - globals: [0] <none>
[11:00:03.568] getGlobalsAndPackages() ... DONE
[11:00:03.568]    + additional globals found: [n=0] 
[11:00:03.568]    + additional namespaces needed: [n=0] 
[11:00:03.568]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:03.568]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:03.569]  - seeds: <none>
[11:00:03.569]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:03.569] getGlobalsAndPackages() ...
[11:00:03.569] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:03.569] Resolving globals: FALSE
[11:00:03.569] Tweak future expression to call with '...' arguments ...
[11:00:03.569] {
[11:00:03.569]     do.call(function(...) {
[11:00:03.569]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:03.569]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:03.569]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:03.569]             on.exit(options(oopts), add = TRUE)
[11:00:03.569]         }
[11:00:03.569]         {
[11:00:03.569]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:03.569]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:03.569]                 ...future.FUN(...future.X_jj, ...)
[11:00:03.569]             })
[11:00:03.569]         }
[11:00:03.569]     }, args = future.call.arguments)
[11:00:03.569] }
[11:00:03.570] Tweak future expression to call with '...' arguments ... DONE
[11:00:03.570] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:03.570] - packages: [1] ‘future.apply’
[11:00:03.570] getGlobalsAndPackages() ... DONE
[11:00:03.571] run() for ‘Future’ ...
[11:00:03.571] - state: ‘created’
[11:00:03.571] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:03.586] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:03.586] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:03.586]   - Field: ‘node’
[11:00:03.586]   - Field: ‘label’
[11:00:03.586]   - Field: ‘local’
[11:00:03.586]   - Field: ‘owner’
[11:00:03.586]   - Field: ‘envir’
[11:00:03.586]   - Field: ‘workers’
[11:00:03.586]   - Field: ‘packages’
[11:00:03.586]   - Field: ‘gc’
[11:00:03.587]   - Field: ‘conditions’
[11:00:03.587]   - Field: ‘persistent’
[11:00:03.587]   - Field: ‘expr’
[11:00:03.587]   - Field: ‘uuid’
[11:00:03.587]   - Field: ‘seed’
[11:00:03.587]   - Field: ‘version’
[11:00:03.587]   - Field: ‘result’
[11:00:03.587]   - Field: ‘asynchronous’
[11:00:03.587]   - Field: ‘calls’
[11:00:03.588]   - Field: ‘globals’
[11:00:03.588]   - Field: ‘stdout’
[11:00:03.588]   - Field: ‘earlySignal’
[11:00:03.588]   - Field: ‘lazy’
[11:00:03.588]   - Field: ‘state’
[11:00:03.588] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:03.588] - Launch lazy future ...
[11:00:03.588] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:03.589] Packages needed by future strategies (n = 0): <none>
[11:00:03.589] {
[11:00:03.589]     {
[11:00:03.589]         {
[11:00:03.589]             ...future.startTime <- base::Sys.time()
[11:00:03.589]             {
[11:00:03.589]                 {
[11:00:03.589]                   {
[11:00:03.589]                     {
[11:00:03.589]                       {
[11:00:03.589]                         base::local({
[11:00:03.589]                           has_future <- base::requireNamespace("future", 
[11:00:03.589]                             quietly = TRUE)
[11:00:03.589]                           if (has_future) {
[11:00:03.589]                             ns <- base::getNamespace("future")
[11:00:03.589]                             version <- ns[[".package"]][["version"]]
[11:00:03.589]                             if (is.null(version)) 
[11:00:03.589]                               version <- utils::packageVersion("future")
[11:00:03.589]                           }
[11:00:03.589]                           else {
[11:00:03.589]                             version <- NULL
[11:00:03.589]                           }
[11:00:03.589]                           if (!has_future || version < "1.8.0") {
[11:00:03.589]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:03.589]                               "", base::R.version$version.string), 
[11:00:03.589]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:03.589]                                 base::R.version$platform, 8 * 
[11:00:03.589]                                   base::.Machine$sizeof.pointer), 
[11:00:03.589]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:03.589]                                 "release", "version")], collapse = " "), 
[11:00:03.589]                               hostname = base::Sys.info()[["nodename"]])
[11:00:03.589]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:03.589]                               info)
[11:00:03.589]                             info <- base::paste(info, collapse = "; ")
[11:00:03.589]                             if (!has_future) {
[11:00:03.589]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:03.589]                                 info)
[11:00:03.589]                             }
[11:00:03.589]                             else {
[11:00:03.589]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:03.589]                                 info, version)
[11:00:03.589]                             }
[11:00:03.589]                             base::stop(msg)
[11:00:03.589]                           }
[11:00:03.589]                         })
[11:00:03.589]                       }
[11:00:03.589]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:03.589]                       base::options(mc.cores = 1L)
[11:00:03.589]                     }
[11:00:03.589]                     base::local({
[11:00:03.589]                       for (pkg in "future.apply") {
[11:00:03.589]                         base::loadNamespace(pkg)
[11:00:03.589]                         base::library(pkg, character.only = TRUE)
[11:00:03.589]                       }
[11:00:03.589]                     })
[11:00:03.589]                   }
[11:00:03.589]                   ...future.strategy.old <- future::plan("list")
[11:00:03.589]                   options(future.plan = NULL)
[11:00:03.589]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:03.589]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:03.589]                 }
[11:00:03.589]                 ...future.workdir <- getwd()
[11:00:03.589]             }
[11:00:03.589]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:03.589]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:03.589]         }
[11:00:03.589]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:03.589]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:03.589]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:03.589]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:03.589]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:03.589]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:03.589]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:03.589]             base::names(...future.oldOptions))
[11:00:03.589]     }
[11:00:03.589]     if (FALSE) {
[11:00:03.589]     }
[11:00:03.589]     else {
[11:00:03.589]         if (TRUE) {
[11:00:03.589]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:03.589]                 open = "w")
[11:00:03.589]         }
[11:00:03.589]         else {
[11:00:03.589]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:03.589]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:03.589]         }
[11:00:03.589]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:03.589]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:03.589]             base::sink(type = "output", split = FALSE)
[11:00:03.589]             base::close(...future.stdout)
[11:00:03.589]         }, add = TRUE)
[11:00:03.589]     }
[11:00:03.589]     ...future.frame <- base::sys.nframe()
[11:00:03.589]     ...future.conditions <- base::list()
[11:00:03.589]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:03.589]     if (FALSE) {
[11:00:03.589]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:03.589]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:03.589]     }
[11:00:03.589]     ...future.result <- base::tryCatch({
[11:00:03.589]         base::withCallingHandlers({
[11:00:03.589]             ...future.value <- base::withVisible(base::local({
[11:00:03.589]                 ...future.makeSendCondition <- base::local({
[11:00:03.589]                   sendCondition <- NULL
[11:00:03.589]                   function(frame = 1L) {
[11:00:03.589]                     if (is.function(sendCondition)) 
[11:00:03.589]                       return(sendCondition)
[11:00:03.589]                     ns <- getNamespace("parallel")
[11:00:03.589]                     if (exists("sendData", mode = "function", 
[11:00:03.589]                       envir = ns)) {
[11:00:03.589]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:03.589]                         envir = ns)
[11:00:03.589]                       envir <- sys.frame(frame)
[11:00:03.589]                       master <- NULL
[11:00:03.589]                       while (!identical(envir, .GlobalEnv) && 
[11:00:03.589]                         !identical(envir, emptyenv())) {
[11:00:03.589]                         if (exists("master", mode = "list", envir = envir, 
[11:00:03.589]                           inherits = FALSE)) {
[11:00:03.589]                           master <- get("master", mode = "list", 
[11:00:03.589]                             envir = envir, inherits = FALSE)
[11:00:03.589]                           if (inherits(master, c("SOCKnode", 
[11:00:03.589]                             "SOCK0node"))) {
[11:00:03.589]                             sendCondition <<- function(cond) {
[11:00:03.589]                               data <- list(type = "VALUE", value = cond, 
[11:00:03.589]                                 success = TRUE)
[11:00:03.589]                               parallel_sendData(master, data)
[11:00:03.589]                             }
[11:00:03.589]                             return(sendCondition)
[11:00:03.589]                           }
[11:00:03.589]                         }
[11:00:03.589]                         frame <- frame + 1L
[11:00:03.589]                         envir <- sys.frame(frame)
[11:00:03.589]                       }
[11:00:03.589]                     }
[11:00:03.589]                     sendCondition <<- function(cond) NULL
[11:00:03.589]                   }
[11:00:03.589]                 })
[11:00:03.589]                 withCallingHandlers({
[11:00:03.589]                   {
[11:00:03.589]                     do.call(function(...) {
[11:00:03.589]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:03.589]                       if (!identical(...future.globals.maxSize.org, 
[11:00:03.589]                         ...future.globals.maxSize)) {
[11:00:03.589]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:03.589]                         on.exit(options(oopts), add = TRUE)
[11:00:03.589]                       }
[11:00:03.589]                       {
[11:00:03.589]                         lapply(seq_along(...future.elements_ii), 
[11:00:03.589]                           FUN = function(jj) {
[11:00:03.589]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:03.589]                             ...future.FUN(...future.X_jj, ...)
[11:00:03.589]                           })
[11:00:03.589]                       }
[11:00:03.589]                     }, args = future.call.arguments)
[11:00:03.589]                   }
[11:00:03.589]                 }, immediateCondition = function(cond) {
[11:00:03.589]                   sendCondition <- ...future.makeSendCondition()
[11:00:03.589]                   sendCondition(cond)
[11:00:03.589]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:03.589]                   {
[11:00:03.589]                     inherits <- base::inherits
[11:00:03.589]                     invokeRestart <- base::invokeRestart
[11:00:03.589]                     is.null <- base::is.null
[11:00:03.589]                     muffled <- FALSE
[11:00:03.589]                     if (inherits(cond, "message")) {
[11:00:03.589]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:03.589]                       if (muffled) 
[11:00:03.589]                         invokeRestart("muffleMessage")
[11:00:03.589]                     }
[11:00:03.589]                     else if (inherits(cond, "warning")) {
[11:00:03.589]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:03.589]                       if (muffled) 
[11:00:03.589]                         invokeRestart("muffleWarning")
[11:00:03.589]                     }
[11:00:03.589]                     else if (inherits(cond, "condition")) {
[11:00:03.589]                       if (!is.null(pattern)) {
[11:00:03.589]                         computeRestarts <- base::computeRestarts
[11:00:03.589]                         grepl <- base::grepl
[11:00:03.589]                         restarts <- computeRestarts(cond)
[11:00:03.589]                         for (restart in restarts) {
[11:00:03.589]                           name <- restart$name
[11:00:03.589]                           if (is.null(name)) 
[11:00:03.589]                             next
[11:00:03.589]                           if (!grepl(pattern, name)) 
[11:00:03.589]                             next
[11:00:03.589]                           invokeRestart(restart)
[11:00:03.589]                           muffled <- TRUE
[11:00:03.589]                           break
[11:00:03.589]                         }
[11:00:03.589]                       }
[11:00:03.589]                     }
[11:00:03.589]                     invisible(muffled)
[11:00:03.589]                   }
[11:00:03.589]                   muffleCondition(cond)
[11:00:03.589]                 })
[11:00:03.589]             }))
[11:00:03.589]             future::FutureResult(value = ...future.value$value, 
[11:00:03.589]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:03.589]                   ...future.rng), globalenv = if (FALSE) 
[11:00:03.589]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:03.589]                     ...future.globalenv.names))
[11:00:03.589]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:03.589]         }, condition = base::local({
[11:00:03.589]             c <- base::c
[11:00:03.589]             inherits <- base::inherits
[11:00:03.589]             invokeRestart <- base::invokeRestart
[11:00:03.589]             length <- base::length
[11:00:03.589]             list <- base::list
[11:00:03.589]             seq.int <- base::seq.int
[11:00:03.589]             signalCondition <- base::signalCondition
[11:00:03.589]             sys.calls <- base::sys.calls
[11:00:03.589]             `[[` <- base::`[[`
[11:00:03.589]             `+` <- base::`+`
[11:00:03.589]             `<<-` <- base::`<<-`
[11:00:03.589]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:03.589]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:03.589]                   3L)]
[11:00:03.589]             }
[11:00:03.589]             function(cond) {
[11:00:03.589]                 is_error <- inherits(cond, "error")
[11:00:03.589]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:03.589]                   NULL)
[11:00:03.589]                 if (is_error) {
[11:00:03.589]                   sessionInformation <- function() {
[11:00:03.589]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:03.589]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:03.589]                       search = base::search(), system = base::Sys.info())
[11:00:03.589]                   }
[11:00:03.589]                   ...future.conditions[[length(...future.conditions) + 
[11:00:03.589]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:03.589]                     cond$call), session = sessionInformation(), 
[11:00:03.589]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:03.589]                   signalCondition(cond)
[11:00:03.589]                 }
[11:00:03.589]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:03.589]                 "immediateCondition"))) {
[11:00:03.589]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:03.589]                   ...future.conditions[[length(...future.conditions) + 
[11:00:03.589]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:03.589]                   if (TRUE && !signal) {
[11:00:03.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:03.589]                     {
[11:00:03.589]                       inherits <- base::inherits
[11:00:03.589]                       invokeRestart <- base::invokeRestart
[11:00:03.589]                       is.null <- base::is.null
[11:00:03.589]                       muffled <- FALSE
[11:00:03.589]                       if (inherits(cond, "message")) {
[11:00:03.589]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:03.589]                         if (muffled) 
[11:00:03.589]                           invokeRestart("muffleMessage")
[11:00:03.589]                       }
[11:00:03.589]                       else if (inherits(cond, "warning")) {
[11:00:03.589]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:03.589]                         if (muffled) 
[11:00:03.589]                           invokeRestart("muffleWarning")
[11:00:03.589]                       }
[11:00:03.589]                       else if (inherits(cond, "condition")) {
[11:00:03.589]                         if (!is.null(pattern)) {
[11:00:03.589]                           computeRestarts <- base::computeRestarts
[11:00:03.589]                           grepl <- base::grepl
[11:00:03.589]                           restarts <- computeRestarts(cond)
[11:00:03.589]                           for (restart in restarts) {
[11:00:03.589]                             name <- restart$name
[11:00:03.589]                             if (is.null(name)) 
[11:00:03.589]                               next
[11:00:03.589]                             if (!grepl(pattern, name)) 
[11:00:03.589]                               next
[11:00:03.589]                             invokeRestart(restart)
[11:00:03.589]                             muffled <- TRUE
[11:00:03.589]                             break
[11:00:03.589]                           }
[11:00:03.589]                         }
[11:00:03.589]                       }
[11:00:03.589]                       invisible(muffled)
[11:00:03.589]                     }
[11:00:03.589]                     muffleCondition(cond, pattern = "^muffle")
[11:00:03.589]                   }
[11:00:03.589]                 }
[11:00:03.589]                 else {
[11:00:03.589]                   if (TRUE) {
[11:00:03.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:03.589]                     {
[11:00:03.589]                       inherits <- base::inherits
[11:00:03.589]                       invokeRestart <- base::invokeRestart
[11:00:03.589]                       is.null <- base::is.null
[11:00:03.589]                       muffled <- FALSE
[11:00:03.589]                       if (inherits(cond, "message")) {
[11:00:03.589]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:03.589]                         if (muffled) 
[11:00:03.589]                           invokeRestart("muffleMessage")
[11:00:03.589]                       }
[11:00:03.589]                       else if (inherits(cond, "warning")) {
[11:00:03.589]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:03.589]                         if (muffled) 
[11:00:03.589]                           invokeRestart("muffleWarning")
[11:00:03.589]                       }
[11:00:03.589]                       else if (inherits(cond, "condition")) {
[11:00:03.589]                         if (!is.null(pattern)) {
[11:00:03.589]                           computeRestarts <- base::computeRestarts
[11:00:03.589]                           grepl <- base::grepl
[11:00:03.589]                           restarts <- computeRestarts(cond)
[11:00:03.589]                           for (restart in restarts) {
[11:00:03.589]                             name <- restart$name
[11:00:03.589]                             if (is.null(name)) 
[11:00:03.589]                               next
[11:00:03.589]                             if (!grepl(pattern, name)) 
[11:00:03.589]                               next
[11:00:03.589]                             invokeRestart(restart)
[11:00:03.589]                             muffled <- TRUE
[11:00:03.589]                             break
[11:00:03.589]                           }
[11:00:03.589]                         }
[11:00:03.589]                       }
[11:00:03.589]                       invisible(muffled)
[11:00:03.589]                     }
[11:00:03.589]                     muffleCondition(cond, pattern = "^muffle")
[11:00:03.589]                   }
[11:00:03.589]                 }
[11:00:03.589]             }
[11:00:03.589]         }))
[11:00:03.589]     }, error = function(ex) {
[11:00:03.589]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:03.589]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:03.589]                 ...future.rng), started = ...future.startTime, 
[11:00:03.589]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:03.589]             version = "1.8"), class = "FutureResult")
[11:00:03.589]     }, finally = {
[11:00:03.589]         if (!identical(...future.workdir, getwd())) 
[11:00:03.589]             setwd(...future.workdir)
[11:00:03.589]         {
[11:00:03.589]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:03.589]                 ...future.oldOptions$nwarnings <- NULL
[11:00:03.589]             }
[11:00:03.589]             base::options(...future.oldOptions)
[11:00:03.589]             if (.Platform$OS.type == "windows") {
[11:00:03.589]                 old_names <- names(...future.oldEnvVars)
[11:00:03.589]                 envs <- base::Sys.getenv()
[11:00:03.589]                 names <- names(envs)
[11:00:03.589]                 common <- intersect(names, old_names)
[11:00:03.589]                 added <- setdiff(names, old_names)
[11:00:03.589]                 removed <- setdiff(old_names, names)
[11:00:03.589]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:03.589]                   envs[common]]
[11:00:03.589]                 NAMES <- toupper(changed)
[11:00:03.589]                 args <- list()
[11:00:03.589]                 for (kk in seq_along(NAMES)) {
[11:00:03.589]                   name <- changed[[kk]]
[11:00:03.589]                   NAME <- NAMES[[kk]]
[11:00:03.589]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:03.589]                     next
[11:00:03.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:03.589]                 }
[11:00:03.589]                 NAMES <- toupper(added)
[11:00:03.589]                 for (kk in seq_along(NAMES)) {
[11:00:03.589]                   name <- added[[kk]]
[11:00:03.589]                   NAME <- NAMES[[kk]]
[11:00:03.589]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:03.589]                     next
[11:00:03.589]                   args[[name]] <- ""
[11:00:03.589]                 }
[11:00:03.589]                 NAMES <- toupper(removed)
[11:00:03.589]                 for (kk in seq_along(NAMES)) {
[11:00:03.589]                   name <- removed[[kk]]
[11:00:03.589]                   NAME <- NAMES[[kk]]
[11:00:03.589]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:03.589]                     next
[11:00:03.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:03.589]                 }
[11:00:03.589]                 if (length(args) > 0) 
[11:00:03.589]                   base::do.call(base::Sys.setenv, args = args)
[11:00:03.589]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:03.589]             }
[11:00:03.589]             else {
[11:00:03.589]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:03.589]             }
[11:00:03.589]             {
[11:00:03.589]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:03.589]                   0L) {
[11:00:03.589]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:03.589]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:03.589]                   base::options(opts)
[11:00:03.589]                 }
[11:00:03.589]                 {
[11:00:03.589]                   {
[11:00:03.589]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:03.589]                     NULL
[11:00:03.589]                   }
[11:00:03.589]                   options(future.plan = NULL)
[11:00:03.589]                   if (is.na(NA_character_)) 
[11:00:03.589]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:03.589]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:03.589]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:03.589]                     .init = FALSE)
[11:00:03.589]                 }
[11:00:03.589]             }
[11:00:03.589]         }
[11:00:03.589]     })
[11:00:03.589]     if (TRUE) {
[11:00:03.589]         base::sink(type = "output", split = FALSE)
[11:00:03.589]         if (TRUE) {
[11:00:03.589]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:03.589]         }
[11:00:03.589]         else {
[11:00:03.589]             ...future.result["stdout"] <- base::list(NULL)
[11:00:03.589]         }
[11:00:03.589]         base::close(...future.stdout)
[11:00:03.589]         ...future.stdout <- NULL
[11:00:03.589]     }
[11:00:03.589]     ...future.result$conditions <- ...future.conditions
[11:00:03.589]     ...future.result$finished <- base::Sys.time()
[11:00:03.589]     ...future.result
[11:00:03.589] }
[11:00:03.592] Exporting 11 global objects (12.52 KiB) to cluster node #1 ...
[11:00:03.593] Exporting ‘...future.FUN’ (4.02 KiB) to cluster node #1 ...
[11:00:03.634] Exporting ‘...future.FUN’ (4.02 KiB) to cluster node #1 ... DONE
[11:00:03.634] Exporting ‘x_FUN’ (36 bytes) to cluster node #1 ...
[11:00:03.634] Exporting ‘x_FUN’ (36 bytes) to cluster node #1 ... DONE
[11:00:03.634] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[11:00:03.635] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[11:00:03.635] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[11:00:03.676] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[11:00:03.676] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[11:00:03.717] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[11:00:03.717] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[11:00:03.717] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[11:00:03.717] Exporting ‘valid_types’ (48 bytes) to cluster node #1 ...
[11:00:03.718] Exporting ‘valid_types’ (48 bytes) to cluster node #1 ... DONE
[11:00:03.718] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[11:00:03.718] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[11:00:03.719] Exporting ‘...future.elements_ii’ (183 bytes) to cluster node #1 ...
[11:00:03.719] Exporting ‘...future.elements_ii’ (183 bytes) to cluster node #1 ... DONE
[11:00:03.719] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[11:00:03.719] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[11:00:03.720] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[11:00:03.720] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[11:00:03.720] Exporting 11 global objects (12.52 KiB) to cluster node #1 ... DONE
[11:00:03.721] MultisessionFuture started
[11:00:03.721] - Launch lazy future ... done
[11:00:03.721] run() for ‘MultisessionFuture’ ... done
[11:00:03.721] Created future:
[11:00:03.721] MultisessionFuture:
[11:00:03.721] Label: ‘future_vapply-1’
[11:00:03.721] Expression:
[11:00:03.721] {
[11:00:03.721]     do.call(function(...) {
[11:00:03.721]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:03.721]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:03.721]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:03.721]             on.exit(options(oopts), add = TRUE)
[11:00:03.721]         }
[11:00:03.721]         {
[11:00:03.721]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:03.721]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:03.721]                 ...future.FUN(...future.X_jj, ...)
[11:00:03.721]             })
[11:00:03.721]         }
[11:00:03.721]     }, args = future.call.arguments)
[11:00:03.721] }
[11:00:03.721] Lazy evaluation: FALSE
[11:00:03.721] Asynchronous evaluation: TRUE
[11:00:03.721] Local evaluation: TRUE
[11:00:03.721] Environment: R_GlobalEnv
[11:00:03.721] Capture standard output: TRUE
[11:00:03.721] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:03.721] Globals: 11 objects totaling 12.33 KiB (function ‘...future.FUN’ of 4.02 KiB, function ‘x_FUN’ of 36 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:03.721] Packages: 1 packages (‘future.apply’)
[11:00:03.721] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:03.721] Resolved: FALSE
[11:00:03.721] Value: <not collected>
[11:00:03.721] Conditions captured: <none>
[11:00:03.721] Early signaling: FALSE
[11:00:03.721] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:03.721] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:03.733] Chunk #1 of 2 ... DONE
[11:00:03.733] Chunk #2 of 2 ...
[11:00:03.734]  - Finding globals in 'X' for chunk #2 ...
[11:00:03.734] getGlobalsAndPackages() ...
[11:00:03.734] Searching for globals...
[11:00:03.734] 
[11:00:03.734] Searching for globals ... DONE
[11:00:03.735] - globals: [0] <none>
[11:00:03.735] getGlobalsAndPackages() ... DONE
[11:00:03.735]    + additional globals found: [n=0] 
[11:00:03.735]    + additional namespaces needed: [n=0] 
[11:00:03.735]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:03.735]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:03.735]  - seeds: <none>
[11:00:03.735]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:03.735] getGlobalsAndPackages() ...
[11:00:03.736] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:03.736] Resolving globals: FALSE
[11:00:03.736] Tweak future expression to call with '...' arguments ...
[11:00:03.736] {
[11:00:03.736]     do.call(function(...) {
[11:00:03.736]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:03.736]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:03.736]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:03.736]             on.exit(options(oopts), add = TRUE)
[11:00:03.736]         }
[11:00:03.736]         {
[11:00:03.736]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:03.736]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:03.736]                 ...future.FUN(...future.X_jj, ...)
[11:00:03.736]             })
[11:00:03.736]         }
[11:00:03.736]     }, args = future.call.arguments)
[11:00:03.736] }
[11:00:03.736] Tweak future expression to call with '...' arguments ... DONE
[11:00:03.737] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:03.737] - packages: [1] ‘future.apply’
[11:00:03.737] getGlobalsAndPackages() ... DONE
[11:00:03.737] run() for ‘Future’ ...
[11:00:03.738] - state: ‘created’
[11:00:03.738] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:03.752] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:03.752] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:03.753]   - Field: ‘node’
[11:00:03.753]   - Field: ‘label’
[11:00:03.753]   - Field: ‘local’
[11:00:03.753]   - Field: ‘owner’
[11:00:03.753]   - Field: ‘envir’
[11:00:03.753]   - Field: ‘workers’
[11:00:03.753]   - Field: ‘packages’
[11:00:03.753]   - Field: ‘gc’
[11:00:03.753]   - Field: ‘conditions’
[11:00:03.753]   - Field: ‘persistent’
[11:00:03.753]   - Field: ‘expr’
[11:00:03.754]   - Field: ‘uuid’
[11:00:03.754]   - Field: ‘seed’
[11:00:03.754]   - Field: ‘version’
[11:00:03.754]   - Field: ‘result’
[11:00:03.754]   - Field: ‘asynchronous’
[11:00:03.754]   - Field: ‘calls’
[11:00:03.754]   - Field: ‘globals’
[11:00:03.754]   - Field: ‘stdout’
[11:00:03.754]   - Field: ‘earlySignal’
[11:00:03.755]   - Field: ‘lazy’
[11:00:03.755]   - Field: ‘state’
[11:00:03.755] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:03.755] - Launch lazy future ...
[11:00:03.755] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:03.756] Packages needed by future strategies (n = 0): <none>
[11:00:03.756] {
[11:00:03.756]     {
[11:00:03.756]         {
[11:00:03.756]             ...future.startTime <- base::Sys.time()
[11:00:03.756]             {
[11:00:03.756]                 {
[11:00:03.756]                   {
[11:00:03.756]                     {
[11:00:03.756]                       {
[11:00:03.756]                         base::local({
[11:00:03.756]                           has_future <- base::requireNamespace("future", 
[11:00:03.756]                             quietly = TRUE)
[11:00:03.756]                           if (has_future) {
[11:00:03.756]                             ns <- base::getNamespace("future")
[11:00:03.756]                             version <- ns[[".package"]][["version"]]
[11:00:03.756]                             if (is.null(version)) 
[11:00:03.756]                               version <- utils::packageVersion("future")
[11:00:03.756]                           }
[11:00:03.756]                           else {
[11:00:03.756]                             version <- NULL
[11:00:03.756]                           }
[11:00:03.756]                           if (!has_future || version < "1.8.0") {
[11:00:03.756]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:03.756]                               "", base::R.version$version.string), 
[11:00:03.756]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:03.756]                                 base::R.version$platform, 8 * 
[11:00:03.756]                                   base::.Machine$sizeof.pointer), 
[11:00:03.756]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:03.756]                                 "release", "version")], collapse = " "), 
[11:00:03.756]                               hostname = base::Sys.info()[["nodename"]])
[11:00:03.756]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:03.756]                               info)
[11:00:03.756]                             info <- base::paste(info, collapse = "; ")
[11:00:03.756]                             if (!has_future) {
[11:00:03.756]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:03.756]                                 info)
[11:00:03.756]                             }
[11:00:03.756]                             else {
[11:00:03.756]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:03.756]                                 info, version)
[11:00:03.756]                             }
[11:00:03.756]                             base::stop(msg)
[11:00:03.756]                           }
[11:00:03.756]                         })
[11:00:03.756]                       }
[11:00:03.756]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:03.756]                       base::options(mc.cores = 1L)
[11:00:03.756]                     }
[11:00:03.756]                     base::local({
[11:00:03.756]                       for (pkg in "future.apply") {
[11:00:03.756]                         base::loadNamespace(pkg)
[11:00:03.756]                         base::library(pkg, character.only = TRUE)
[11:00:03.756]                       }
[11:00:03.756]                     })
[11:00:03.756]                   }
[11:00:03.756]                   ...future.strategy.old <- future::plan("list")
[11:00:03.756]                   options(future.plan = NULL)
[11:00:03.756]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:03.756]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:03.756]                 }
[11:00:03.756]                 ...future.workdir <- getwd()
[11:00:03.756]             }
[11:00:03.756]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:03.756]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:03.756]         }
[11:00:03.756]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:03.756]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:03.756]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:03.756]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:03.756]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:03.756]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:03.756]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:03.756]             base::names(...future.oldOptions))
[11:00:03.756]     }
[11:00:03.756]     if (FALSE) {
[11:00:03.756]     }
[11:00:03.756]     else {
[11:00:03.756]         if (TRUE) {
[11:00:03.756]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:03.756]                 open = "w")
[11:00:03.756]         }
[11:00:03.756]         else {
[11:00:03.756]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:03.756]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:03.756]         }
[11:00:03.756]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:03.756]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:03.756]             base::sink(type = "output", split = FALSE)
[11:00:03.756]             base::close(...future.stdout)
[11:00:03.756]         }, add = TRUE)
[11:00:03.756]     }
[11:00:03.756]     ...future.frame <- base::sys.nframe()
[11:00:03.756]     ...future.conditions <- base::list()
[11:00:03.756]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:03.756]     if (FALSE) {
[11:00:03.756]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:03.756]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:03.756]     }
[11:00:03.756]     ...future.result <- base::tryCatch({
[11:00:03.756]         base::withCallingHandlers({
[11:00:03.756]             ...future.value <- base::withVisible(base::local({
[11:00:03.756]                 ...future.makeSendCondition <- base::local({
[11:00:03.756]                   sendCondition <- NULL
[11:00:03.756]                   function(frame = 1L) {
[11:00:03.756]                     if (is.function(sendCondition)) 
[11:00:03.756]                       return(sendCondition)
[11:00:03.756]                     ns <- getNamespace("parallel")
[11:00:03.756]                     if (exists("sendData", mode = "function", 
[11:00:03.756]                       envir = ns)) {
[11:00:03.756]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:03.756]                         envir = ns)
[11:00:03.756]                       envir <- sys.frame(frame)
[11:00:03.756]                       master <- NULL
[11:00:03.756]                       while (!identical(envir, .GlobalEnv) && 
[11:00:03.756]                         !identical(envir, emptyenv())) {
[11:00:03.756]                         if (exists("master", mode = "list", envir = envir, 
[11:00:03.756]                           inherits = FALSE)) {
[11:00:03.756]                           master <- get("master", mode = "list", 
[11:00:03.756]                             envir = envir, inherits = FALSE)
[11:00:03.756]                           if (inherits(master, c("SOCKnode", 
[11:00:03.756]                             "SOCK0node"))) {
[11:00:03.756]                             sendCondition <<- function(cond) {
[11:00:03.756]                               data <- list(type = "VALUE", value = cond, 
[11:00:03.756]                                 success = TRUE)
[11:00:03.756]                               parallel_sendData(master, data)
[11:00:03.756]                             }
[11:00:03.756]                             return(sendCondition)
[11:00:03.756]                           }
[11:00:03.756]                         }
[11:00:03.756]                         frame <- frame + 1L
[11:00:03.756]                         envir <- sys.frame(frame)
[11:00:03.756]                       }
[11:00:03.756]                     }
[11:00:03.756]                     sendCondition <<- function(cond) NULL
[11:00:03.756]                   }
[11:00:03.756]                 })
[11:00:03.756]                 withCallingHandlers({
[11:00:03.756]                   {
[11:00:03.756]                     do.call(function(...) {
[11:00:03.756]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:03.756]                       if (!identical(...future.globals.maxSize.org, 
[11:00:03.756]                         ...future.globals.maxSize)) {
[11:00:03.756]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:03.756]                         on.exit(options(oopts), add = TRUE)
[11:00:03.756]                       }
[11:00:03.756]                       {
[11:00:03.756]                         lapply(seq_along(...future.elements_ii), 
[11:00:03.756]                           FUN = function(jj) {
[11:00:03.756]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:03.756]                             ...future.FUN(...future.X_jj, ...)
[11:00:03.756]                           })
[11:00:03.756]                       }
[11:00:03.756]                     }, args = future.call.arguments)
[11:00:03.756]                   }
[11:00:03.756]                 }, immediateCondition = function(cond) {
[11:00:03.756]                   sendCondition <- ...future.makeSendCondition()
[11:00:03.756]                   sendCondition(cond)
[11:00:03.756]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:03.756]                   {
[11:00:03.756]                     inherits <- base::inherits
[11:00:03.756]                     invokeRestart <- base::invokeRestart
[11:00:03.756]                     is.null <- base::is.null
[11:00:03.756]                     muffled <- FALSE
[11:00:03.756]                     if (inherits(cond, "message")) {
[11:00:03.756]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:03.756]                       if (muffled) 
[11:00:03.756]                         invokeRestart("muffleMessage")
[11:00:03.756]                     }
[11:00:03.756]                     else if (inherits(cond, "warning")) {
[11:00:03.756]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:03.756]                       if (muffled) 
[11:00:03.756]                         invokeRestart("muffleWarning")
[11:00:03.756]                     }
[11:00:03.756]                     else if (inherits(cond, "condition")) {
[11:00:03.756]                       if (!is.null(pattern)) {
[11:00:03.756]                         computeRestarts <- base::computeRestarts
[11:00:03.756]                         grepl <- base::grepl
[11:00:03.756]                         restarts <- computeRestarts(cond)
[11:00:03.756]                         for (restart in restarts) {
[11:00:03.756]                           name <- restart$name
[11:00:03.756]                           if (is.null(name)) 
[11:00:03.756]                             next
[11:00:03.756]                           if (!grepl(pattern, name)) 
[11:00:03.756]                             next
[11:00:03.756]                           invokeRestart(restart)
[11:00:03.756]                           muffled <- TRUE
[11:00:03.756]                           break
[11:00:03.756]                         }
[11:00:03.756]                       }
[11:00:03.756]                     }
[11:00:03.756]                     invisible(muffled)
[11:00:03.756]                   }
[11:00:03.756]                   muffleCondition(cond)
[11:00:03.756]                 })
[11:00:03.756]             }))
[11:00:03.756]             future::FutureResult(value = ...future.value$value, 
[11:00:03.756]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:03.756]                   ...future.rng), globalenv = if (FALSE) 
[11:00:03.756]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:03.756]                     ...future.globalenv.names))
[11:00:03.756]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:03.756]         }, condition = base::local({
[11:00:03.756]             c <- base::c
[11:00:03.756]             inherits <- base::inherits
[11:00:03.756]             invokeRestart <- base::invokeRestart
[11:00:03.756]             length <- base::length
[11:00:03.756]             list <- base::list
[11:00:03.756]             seq.int <- base::seq.int
[11:00:03.756]             signalCondition <- base::signalCondition
[11:00:03.756]             sys.calls <- base::sys.calls
[11:00:03.756]             `[[` <- base::`[[`
[11:00:03.756]             `+` <- base::`+`
[11:00:03.756]             `<<-` <- base::`<<-`
[11:00:03.756]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:03.756]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:03.756]                   3L)]
[11:00:03.756]             }
[11:00:03.756]             function(cond) {
[11:00:03.756]                 is_error <- inherits(cond, "error")
[11:00:03.756]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:03.756]                   NULL)
[11:00:03.756]                 if (is_error) {
[11:00:03.756]                   sessionInformation <- function() {
[11:00:03.756]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:03.756]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:03.756]                       search = base::search(), system = base::Sys.info())
[11:00:03.756]                   }
[11:00:03.756]                   ...future.conditions[[length(...future.conditions) + 
[11:00:03.756]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:03.756]                     cond$call), session = sessionInformation(), 
[11:00:03.756]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:03.756]                   signalCondition(cond)
[11:00:03.756]                 }
[11:00:03.756]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:03.756]                 "immediateCondition"))) {
[11:00:03.756]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:03.756]                   ...future.conditions[[length(...future.conditions) + 
[11:00:03.756]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:03.756]                   if (TRUE && !signal) {
[11:00:03.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:03.756]                     {
[11:00:03.756]                       inherits <- base::inherits
[11:00:03.756]                       invokeRestart <- base::invokeRestart
[11:00:03.756]                       is.null <- base::is.null
[11:00:03.756]                       muffled <- FALSE
[11:00:03.756]                       if (inherits(cond, "message")) {
[11:00:03.756]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:03.756]                         if (muffled) 
[11:00:03.756]                           invokeRestart("muffleMessage")
[11:00:03.756]                       }
[11:00:03.756]                       else if (inherits(cond, "warning")) {
[11:00:03.756]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:03.756]                         if (muffled) 
[11:00:03.756]                           invokeRestart("muffleWarning")
[11:00:03.756]                       }
[11:00:03.756]                       else if (inherits(cond, "condition")) {
[11:00:03.756]                         if (!is.null(pattern)) {
[11:00:03.756]                           computeRestarts <- base::computeRestarts
[11:00:03.756]                           grepl <- base::grepl
[11:00:03.756]                           restarts <- computeRestarts(cond)
[11:00:03.756]                           for (restart in restarts) {
[11:00:03.756]                             name <- restart$name
[11:00:03.756]                             if (is.null(name)) 
[11:00:03.756]                               next
[11:00:03.756]                             if (!grepl(pattern, name)) 
[11:00:03.756]                               next
[11:00:03.756]                             invokeRestart(restart)
[11:00:03.756]                             muffled <- TRUE
[11:00:03.756]                             break
[11:00:03.756]                           }
[11:00:03.756]                         }
[11:00:03.756]                       }
[11:00:03.756]                       invisible(muffled)
[11:00:03.756]                     }
[11:00:03.756]                     muffleCondition(cond, pattern = "^muffle")
[11:00:03.756]                   }
[11:00:03.756]                 }
[11:00:03.756]                 else {
[11:00:03.756]                   if (TRUE) {
[11:00:03.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:03.756]                     {
[11:00:03.756]                       inherits <- base::inherits
[11:00:03.756]                       invokeRestart <- base::invokeRestart
[11:00:03.756]                       is.null <- base::is.null
[11:00:03.756]                       muffled <- FALSE
[11:00:03.756]                       if (inherits(cond, "message")) {
[11:00:03.756]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:03.756]                         if (muffled) 
[11:00:03.756]                           invokeRestart("muffleMessage")
[11:00:03.756]                       }
[11:00:03.756]                       else if (inherits(cond, "warning")) {
[11:00:03.756]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:03.756]                         if (muffled) 
[11:00:03.756]                           invokeRestart("muffleWarning")
[11:00:03.756]                       }
[11:00:03.756]                       else if (inherits(cond, "condition")) {
[11:00:03.756]                         if (!is.null(pattern)) {
[11:00:03.756]                           computeRestarts <- base::computeRestarts
[11:00:03.756]                           grepl <- base::grepl
[11:00:03.756]                           restarts <- computeRestarts(cond)
[11:00:03.756]                           for (restart in restarts) {
[11:00:03.756]                             name <- restart$name
[11:00:03.756]                             if (is.null(name)) 
[11:00:03.756]                               next
[11:00:03.756]                             if (!grepl(pattern, name)) 
[11:00:03.756]                               next
[11:00:03.756]                             invokeRestart(restart)
[11:00:03.756]                             muffled <- TRUE
[11:00:03.756]                             break
[11:00:03.756]                           }
[11:00:03.756]                         }
[11:00:03.756]                       }
[11:00:03.756]                       invisible(muffled)
[11:00:03.756]                     }
[11:00:03.756]                     muffleCondition(cond, pattern = "^muffle")
[11:00:03.756]                   }
[11:00:03.756]                 }
[11:00:03.756]             }
[11:00:03.756]         }))
[11:00:03.756]     }, error = function(ex) {
[11:00:03.756]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:03.756]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:03.756]                 ...future.rng), started = ...future.startTime, 
[11:00:03.756]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:03.756]             version = "1.8"), class = "FutureResult")
[11:00:03.756]     }, finally = {
[11:00:03.756]         if (!identical(...future.workdir, getwd())) 
[11:00:03.756]             setwd(...future.workdir)
[11:00:03.756]         {
[11:00:03.756]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:03.756]                 ...future.oldOptions$nwarnings <- NULL
[11:00:03.756]             }
[11:00:03.756]             base::options(...future.oldOptions)
[11:00:03.756]             if (.Platform$OS.type == "windows") {
[11:00:03.756]                 old_names <- names(...future.oldEnvVars)
[11:00:03.756]                 envs <- base::Sys.getenv()
[11:00:03.756]                 names <- names(envs)
[11:00:03.756]                 common <- intersect(names, old_names)
[11:00:03.756]                 added <- setdiff(names, old_names)
[11:00:03.756]                 removed <- setdiff(old_names, names)
[11:00:03.756]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:03.756]                   envs[common]]
[11:00:03.756]                 NAMES <- toupper(changed)
[11:00:03.756]                 args <- list()
[11:00:03.756]                 for (kk in seq_along(NAMES)) {
[11:00:03.756]                   name <- changed[[kk]]
[11:00:03.756]                   NAME <- NAMES[[kk]]
[11:00:03.756]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:03.756]                     next
[11:00:03.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:03.756]                 }
[11:00:03.756]                 NAMES <- toupper(added)
[11:00:03.756]                 for (kk in seq_along(NAMES)) {
[11:00:03.756]                   name <- added[[kk]]
[11:00:03.756]                   NAME <- NAMES[[kk]]
[11:00:03.756]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:03.756]                     next
[11:00:03.756]                   args[[name]] <- ""
[11:00:03.756]                 }
[11:00:03.756]                 NAMES <- toupper(removed)
[11:00:03.756]                 for (kk in seq_along(NAMES)) {
[11:00:03.756]                   name <- removed[[kk]]
[11:00:03.756]                   NAME <- NAMES[[kk]]
[11:00:03.756]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:03.756]                     next
[11:00:03.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:03.756]                 }
[11:00:03.756]                 if (length(args) > 0) 
[11:00:03.756]                   base::do.call(base::Sys.setenv, args = args)
[11:00:03.756]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:03.756]             }
[11:00:03.756]             else {
[11:00:03.756]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:03.756]             }
[11:00:03.756]             {
[11:00:03.756]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:03.756]                   0L) {
[11:00:03.756]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:03.756]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:03.756]                   base::options(opts)
[11:00:03.756]                 }
[11:00:03.756]                 {
[11:00:03.756]                   {
[11:00:03.756]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:03.756]                     NULL
[11:00:03.756]                   }
[11:00:03.756]                   options(future.plan = NULL)
[11:00:03.756]                   if (is.na(NA_character_)) 
[11:00:03.756]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:03.756]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:03.756]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:03.756]                     .init = FALSE)
[11:00:03.756]                 }
[11:00:03.756]             }
[11:00:03.756]         }
[11:00:03.756]     })
[11:00:03.756]     if (TRUE) {
[11:00:03.756]         base::sink(type = "output", split = FALSE)
[11:00:03.756]         if (TRUE) {
[11:00:03.756]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:03.756]         }
[11:00:03.756]         else {
[11:00:03.756]             ...future.result["stdout"] <- base::list(NULL)
[11:00:03.756]         }
[11:00:03.756]         base::close(...future.stdout)
[11:00:03.756]         ...future.stdout <- NULL
[11:00:03.756]     }
[11:00:03.756]     ...future.result$conditions <- ...future.conditions
[11:00:03.756]     ...future.result$finished <- base::Sys.time()
[11:00:03.756]     ...future.result
[11:00:03.756] }
[11:00:03.809] Exporting 11 global objects (12.54 KiB) to cluster node #2 ...
[11:00:03.809] Exporting ‘...future.FUN’ (4.02 KiB) to cluster node #2 ...
[11:00:03.813] Exporting ‘...future.FUN’ (4.02 KiB) to cluster node #2 ... DONE
[11:00:03.813] Exporting ‘x_FUN’ (36 bytes) to cluster node #2 ...
[11:00:03.814] Exporting ‘x_FUN’ (36 bytes) to cluster node #2 ... DONE
[11:00:03.814] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[11:00:03.814] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[11:00:03.814] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[11:00:03.855] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[11:00:03.856] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[11:00:03.896] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[11:00:03.897] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[11:00:03.897] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[11:00:03.897] Exporting ‘valid_types’ (48 bytes) to cluster node #2 ...
[11:00:03.898] Exporting ‘valid_types’ (48 bytes) to cluster node #2 ... DONE
[11:00:03.898] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[11:00:03.898] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[11:00:03.898] Exporting ‘...future.elements_ii’ (171 bytes) to cluster node #2 ...
[11:00:03.899] Exporting ‘...future.elements_ii’ (171 bytes) to cluster node #2 ... DONE
[11:00:03.899] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[11:00:03.899] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[11:00:03.899] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[11:00:03.900] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[11:00:03.900] Exporting 11 global objects (12.54 KiB) to cluster node #2 ... DONE
[11:00:03.900] MultisessionFuture started
[11:00:03.900] - Launch lazy future ... done
[11:00:03.901] run() for ‘MultisessionFuture’ ... done
[11:00:03.901] Created future:
[11:00:03.901] MultisessionFuture:
[11:00:03.901] Label: ‘future_vapply-2’
[11:00:03.901] Expression:
[11:00:03.901] {
[11:00:03.901]     do.call(function(...) {
[11:00:03.901]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:03.901]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:03.901]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:03.901]             on.exit(options(oopts), add = TRUE)
[11:00:03.901]         }
[11:00:03.901]         {
[11:00:03.901]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:03.901]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:03.901]                 ...future.FUN(...future.X_jj, ...)
[11:00:03.901]             })
[11:00:03.901]         }
[11:00:03.901]     }, args = future.call.arguments)
[11:00:03.901] }
[11:00:03.901] Lazy evaluation: FALSE
[11:00:03.901] Asynchronous evaluation: TRUE
[11:00:03.901] Local evaluation: TRUE
[11:00:03.901] Environment: R_GlobalEnv
[11:00:03.901] Capture standard output: TRUE
[11:00:03.901] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:03.901] Globals: 11 objects totaling 12.32 KiB (function ‘...future.FUN’ of 4.02 KiB, function ‘x_FUN’ of 36 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:03.901] Packages: 1 packages (‘future.apply’)
[11:00:03.901] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:03.901] Resolved: FALSE
[11:00:03.901] Value: <not collected>
[11:00:03.901] Conditions captured: <none>
[11:00:03.901] Early signaling: FALSE
[11:00:03.901] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:03.901] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:03.913] Chunk #2 of 2 ... DONE
[11:00:03.913] Launching 2 futures (chunks) ... DONE
[11:00:03.913] Resolving 2 futures (chunks) ...
[11:00:03.913] resolve() on list ...
[11:00:03.913]  recursive: 0
[11:00:03.913]  length: 2
[11:00:03.914] 
[11:00:03.914] receiveMessageFromWorker() for ClusterFuture ...
[11:00:03.914] - Validating connection of MultisessionFuture
[11:00:03.914] - received message: FutureResult
[11:00:03.915] - Received FutureResult
[11:00:03.915] - Erased future from FutureRegistry
[11:00:03.915] result() for ClusterFuture ...
[11:00:03.915] - result already collected: FutureResult
[11:00:03.915] result() for ClusterFuture ... done
[11:00:03.915] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:03.915] Future #1
[11:00:03.915] result() for ClusterFuture ...
[11:00:03.915] - result already collected: FutureResult
[11:00:03.915] result() for ClusterFuture ... done
[11:00:03.916] result() for ClusterFuture ...
[11:00:03.916] - result already collected: FutureResult
[11:00:03.916] result() for ClusterFuture ... done
[11:00:03.916] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:00:03.916] - nx: 2
[11:00:03.916] - relay: TRUE
[11:00:03.916] - stdout: TRUE
[11:00:03.916] - signal: TRUE
[11:00:03.916] - resignal: FALSE
[11:00:03.917] - force: TRUE
[11:00:03.917] - relayed: [n=2] FALSE, FALSE
[11:00:03.917] - queued futures: [n=2] FALSE, FALSE
[11:00:03.917]  - until=1
[11:00:03.917]  - relaying element #1
[11:00:03.917] result() for ClusterFuture ...
[11:00:03.917] - result already collected: FutureResult
[11:00:03.917] result() for ClusterFuture ... done
[11:00:03.917] result() for ClusterFuture ...
[11:00:03.917] - result already collected: FutureResult
[11:00:03.918] result() for ClusterFuture ... done
[11:00:03.918] result() for ClusterFuture ...
[11:00:03.918] - result already collected: FutureResult
[11:00:03.918] result() for ClusterFuture ... done
[11:00:03.918] result() for ClusterFuture ...
[11:00:03.918] - result already collected: FutureResult
[11:00:03.918] result() for ClusterFuture ... done
[11:00:03.918] - relayed: [n=2] TRUE, FALSE
[11:00:03.918] - queued futures: [n=2] TRUE, FALSE
[11:00:03.919] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:00:03.919]  length: 1 (resolved future 1)
[11:00:03.981] receiveMessageFromWorker() for ClusterFuture ...
[11:00:03.981] - Validating connection of MultisessionFuture
[11:00:03.982] - received message: FutureResult
[11:00:03.982] - Received FutureResult
[11:00:03.982] - Erased future from FutureRegistry
[11:00:03.982] result() for ClusterFuture ...
[11:00:03.982] - result already collected: FutureResult
[11:00:03.982] result() for ClusterFuture ... done
[11:00:03.982] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:03.982] Future #2
[11:00:03.983] result() for ClusterFuture ...
[11:00:03.983] - result already collected: FutureResult
[11:00:03.983] result() for ClusterFuture ... done
[11:00:03.983] result() for ClusterFuture ...
[11:00:03.983] - result already collected: FutureResult
[11:00:03.983] result() for ClusterFuture ... done
[11:00:03.983] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:00:03.983] - nx: 2
[11:00:03.983] - relay: TRUE
[11:00:03.983] - stdout: TRUE
[11:00:03.984] - signal: TRUE
[11:00:03.984] - resignal: FALSE
[11:00:03.984] - force: TRUE
[11:00:03.984] - relayed: [n=2] TRUE, FALSE
[11:00:03.984] - queued futures: [n=2] TRUE, FALSE
[11:00:03.984]  - until=2
[11:00:03.984]  - relaying element #2
[11:00:03.984] result() for ClusterFuture ...
[11:00:03.984] - result already collected: FutureResult
[11:00:03.984] result() for ClusterFuture ... done
[11:00:03.985] result() for ClusterFuture ...
[11:00:03.985] - result already collected: FutureResult
[11:00:03.985] result() for ClusterFuture ... done
[11:00:03.985] result() for ClusterFuture ...
[11:00:03.985] - result already collected: FutureResult
[11:00:03.985] result() for ClusterFuture ... done
[11:00:03.985] result() for ClusterFuture ...
[11:00:03.985] - result already collected: FutureResult
[11:00:03.985] result() for ClusterFuture ... done
[11:00:03.986] - relayed: [n=2] TRUE, TRUE
[11:00:03.986] - queued futures: [n=2] TRUE, TRUE
[11:00:03.986] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:00:03.986]  length: 0 (resolved future 2)
[11:00:03.986] Relaying remaining futures
[11:00:03.986] signalConditionsASAP(NULL, pos=0) ...
[11:00:03.986] - nx: 2
[11:00:03.986] - relay: TRUE
[11:00:03.986] - stdout: TRUE
[11:00:03.987] - signal: TRUE
[11:00:03.987] - resignal: FALSE
[11:00:03.987] - force: TRUE
[11:00:03.987] - relayed: [n=2] TRUE, TRUE
[11:00:03.987] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:03.987] - relayed: [n=2] TRUE, TRUE
[11:00:03.987] - queued futures: [n=2] TRUE, TRUE
[11:00:03.987] signalConditionsASAP(NULL, pos=0) ... done
[11:00:03.987] resolve() on list ... DONE
[11:00:03.987] result() for ClusterFuture ...
[11:00:03.988] - result already collected: FutureResult
[11:00:03.988] result() for ClusterFuture ... done
[11:00:03.988] result() for ClusterFuture ...
[11:00:03.988] - result already collected: FutureResult
[11:00:03.988] result() for ClusterFuture ... done
[11:00:03.988] result() for ClusterFuture ...
[11:00:03.988] - result already collected: FutureResult
[11:00:03.988] result() for ClusterFuture ... done
[11:00:03.988] result() for ClusterFuture ...
[11:00:03.989] - result already collected: FutureResult
[11:00:03.989] result() for ClusterFuture ... done
[11:00:03.989]  - Number of value chunks collected: 2
[11:00:03.989] Resolving 2 futures (chunks) ... DONE
[11:00:03.989] Reducing values from 2 chunks ...
[11:00:03.989]  - Number of values collected after concatenation: 2
[11:00:03.989]  - Number of values expected: 2
[11:00:03.989] Reducing values from 2 chunks ... DONE
[11:00:03.989] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[11:00:03.991] future_lapply() ...
[11:00:03.995] Number of chunks: 2
[11:00:03.995] getGlobalsAndPackagesXApply() ...
[11:00:03.995]  - future.globals: TRUE
[11:00:03.995] getGlobalsAndPackages() ...
[11:00:03.995] Searching for globals...
[11:00:03.999] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[11:00:03.999] Searching for globals ... DONE
[11:00:04.000] Resolving globals: FALSE
[11:00:04.001] The total size of the 7 globals is 12.77 KiB (13081 bytes)
[11:00:04.001] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.77 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:04.001] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:04.001] - packages: [1] ‘future.apply’
[11:00:04.002] getGlobalsAndPackages() ... DONE
[11:00:04.004]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:04.004]  - needed namespaces: [n=1] ‘future.apply’
[11:00:04.004] Finding globals ... DONE
[11:00:04.004]  - use_args: TRUE
[11:00:04.004]  - Getting '...' globals ...
[11:00:04.004] resolve() on list ...
[11:00:04.005]  recursive: 0
[11:00:04.005]  length: 1
[11:00:04.005]  elements: ‘...’
[11:00:04.005]  length: 0 (resolved future 1)
[11:00:04.005] resolve() on list ... DONE
[11:00:04.005]    - '...' content: [n=0] 
[11:00:04.005] List of 1
[11:00:04.005]  $ ...: list()
[11:00:04.005]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:04.005]  - attr(*, "where")=List of 1
[11:00:04.005]   ..$ ...:<environment: 0x55bbb01ae708> 
[11:00:04.005]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:04.005]  - attr(*, "resolved")= logi TRUE
[11:00:04.005]  - attr(*, "total_size")= num NA
[11:00:04.007]  - Getting '...' globals ... DONE
[11:00:04.008] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:04.008] List of 8
[11:00:04.008]  $ ...future.FUN:function (x, ...)  
[11:00:04.008]  $ x_FUN        :function (x)  
[11:00:04.008]  $ times        : int 0
[11:00:04.008]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:04.008]  $ stop_if_not  :function (...)  
[11:00:04.008]  $ dim          : NULL
[11:00:04.008]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:04.008]  $ ...          : list()
[11:00:04.008]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:04.008]  - attr(*, "where")=List of 8
[11:00:04.008]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:04.008]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:04.008]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:04.008]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:04.008]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:04.008]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:04.008]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:04.008]   ..$ ...          :<environment: 0x55bbb01ae708> 
[11:00:04.008]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:04.008]  - attr(*, "resolved")= logi FALSE
[11:00:04.008]  - attr(*, "total_size")= num 23490
[11:00:04.013] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:04.013] getGlobalsAndPackagesXApply() ... DONE
[11:00:04.013] Number of futures (= number of chunks): 2
[11:00:04.013] Launching 2 futures (chunks) ...
[11:00:04.013] Chunk #1 of 2 ...
[11:00:04.013]  - Finding globals in 'X' for chunk #1 ...
[11:00:04.013] getGlobalsAndPackages() ...
[11:00:04.013] Searching for globals...
[11:00:04.014] 
[11:00:04.014] Searching for globals ... DONE
[11:00:04.014] - globals: [0] <none>
[11:00:04.014] getGlobalsAndPackages() ... DONE
[11:00:04.014]    + additional globals found: [n=0] 
[11:00:04.014]    + additional namespaces needed: [n=0] 
[11:00:04.014]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:04.014]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:04.014]  - seeds: <none>
[11:00:04.014]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:04.015] getGlobalsAndPackages() ...
[11:00:04.015] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:04.015] Resolving globals: FALSE
[11:00:04.015] Tweak future expression to call with '...' arguments ...
[11:00:04.015] {
[11:00:04.015]     do.call(function(...) {
[11:00:04.015]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:04.015]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:04.015]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:04.015]             on.exit(options(oopts), add = TRUE)
[11:00:04.015]         }
[11:00:04.015]         {
[11:00:04.015]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:04.015]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:04.015]                 ...future.FUN(...future.X_jj, ...)
[11:00:04.015]             })
[11:00:04.015]         }
[11:00:04.015]     }, args = future.call.arguments)
[11:00:04.015] }
[11:00:04.015] Tweak future expression to call with '...' arguments ... DONE
[11:00:04.016] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:04.016] - packages: [1] ‘future.apply’
[11:00:04.016] getGlobalsAndPackages() ... DONE
[11:00:04.016] run() for ‘Future’ ...
[11:00:04.016] - state: ‘created’
[11:00:04.016] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:04.031] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:04.031] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:04.031]   - Field: ‘node’
[11:00:04.031]   - Field: ‘label’
[11:00:04.032]   - Field: ‘local’
[11:00:04.032]   - Field: ‘owner’
[11:00:04.032]   - Field: ‘envir’
[11:00:04.032]   - Field: ‘workers’
[11:00:04.032]   - Field: ‘packages’
[11:00:04.032]   - Field: ‘gc’
[11:00:04.032]   - Field: ‘conditions’
[11:00:04.032]   - Field: ‘persistent’
[11:00:04.032]   - Field: ‘expr’
[11:00:04.032]   - Field: ‘uuid’
[11:00:04.032]   - Field: ‘seed’
[11:00:04.033]   - Field: ‘version’
[11:00:04.033]   - Field: ‘result’
[11:00:04.033]   - Field: ‘asynchronous’
[11:00:04.033]   - Field: ‘calls’
[11:00:04.033]   - Field: ‘globals’
[11:00:04.033]   - Field: ‘stdout’
[11:00:04.033]   - Field: ‘earlySignal’
[11:00:04.033]   - Field: ‘lazy’
[11:00:04.033]   - Field: ‘state’
[11:00:04.033] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:04.033] - Launch lazy future ...
[11:00:04.034] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:04.034] Packages needed by future strategies (n = 0): <none>
[11:00:04.034] {
[11:00:04.034]     {
[11:00:04.034]         {
[11:00:04.034]             ...future.startTime <- base::Sys.time()
[11:00:04.034]             {
[11:00:04.034]                 {
[11:00:04.034]                   {
[11:00:04.034]                     {
[11:00:04.034]                       {
[11:00:04.034]                         base::local({
[11:00:04.034]                           has_future <- base::requireNamespace("future", 
[11:00:04.034]                             quietly = TRUE)
[11:00:04.034]                           if (has_future) {
[11:00:04.034]                             ns <- base::getNamespace("future")
[11:00:04.034]                             version <- ns[[".package"]][["version"]]
[11:00:04.034]                             if (is.null(version)) 
[11:00:04.034]                               version <- utils::packageVersion("future")
[11:00:04.034]                           }
[11:00:04.034]                           else {
[11:00:04.034]                             version <- NULL
[11:00:04.034]                           }
[11:00:04.034]                           if (!has_future || version < "1.8.0") {
[11:00:04.034]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:04.034]                               "", base::R.version$version.string), 
[11:00:04.034]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:04.034]                                 base::R.version$platform, 8 * 
[11:00:04.034]                                   base::.Machine$sizeof.pointer), 
[11:00:04.034]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:04.034]                                 "release", "version")], collapse = " "), 
[11:00:04.034]                               hostname = base::Sys.info()[["nodename"]])
[11:00:04.034]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:04.034]                               info)
[11:00:04.034]                             info <- base::paste(info, collapse = "; ")
[11:00:04.034]                             if (!has_future) {
[11:00:04.034]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:04.034]                                 info)
[11:00:04.034]                             }
[11:00:04.034]                             else {
[11:00:04.034]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:04.034]                                 info, version)
[11:00:04.034]                             }
[11:00:04.034]                             base::stop(msg)
[11:00:04.034]                           }
[11:00:04.034]                         })
[11:00:04.034]                       }
[11:00:04.034]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:04.034]                       base::options(mc.cores = 1L)
[11:00:04.034]                     }
[11:00:04.034]                     base::local({
[11:00:04.034]                       for (pkg in "future.apply") {
[11:00:04.034]                         base::loadNamespace(pkg)
[11:00:04.034]                         base::library(pkg, character.only = TRUE)
[11:00:04.034]                       }
[11:00:04.034]                     })
[11:00:04.034]                   }
[11:00:04.034]                   ...future.strategy.old <- future::plan("list")
[11:00:04.034]                   options(future.plan = NULL)
[11:00:04.034]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:04.034]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:04.034]                 }
[11:00:04.034]                 ...future.workdir <- getwd()
[11:00:04.034]             }
[11:00:04.034]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:04.034]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:04.034]         }
[11:00:04.034]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:04.034]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:04.034]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:04.034]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:04.034]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:04.034]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:04.034]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:04.034]             base::names(...future.oldOptions))
[11:00:04.034]     }
[11:00:04.034]     if (FALSE) {
[11:00:04.034]     }
[11:00:04.034]     else {
[11:00:04.034]         if (TRUE) {
[11:00:04.034]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:04.034]                 open = "w")
[11:00:04.034]         }
[11:00:04.034]         else {
[11:00:04.034]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:04.034]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:04.034]         }
[11:00:04.034]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:04.034]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:04.034]             base::sink(type = "output", split = FALSE)
[11:00:04.034]             base::close(...future.stdout)
[11:00:04.034]         }, add = TRUE)
[11:00:04.034]     }
[11:00:04.034]     ...future.frame <- base::sys.nframe()
[11:00:04.034]     ...future.conditions <- base::list()
[11:00:04.034]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:04.034]     if (FALSE) {
[11:00:04.034]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:04.034]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:04.034]     }
[11:00:04.034]     ...future.result <- base::tryCatch({
[11:00:04.034]         base::withCallingHandlers({
[11:00:04.034]             ...future.value <- base::withVisible(base::local({
[11:00:04.034]                 ...future.makeSendCondition <- base::local({
[11:00:04.034]                   sendCondition <- NULL
[11:00:04.034]                   function(frame = 1L) {
[11:00:04.034]                     if (is.function(sendCondition)) 
[11:00:04.034]                       return(sendCondition)
[11:00:04.034]                     ns <- getNamespace("parallel")
[11:00:04.034]                     if (exists("sendData", mode = "function", 
[11:00:04.034]                       envir = ns)) {
[11:00:04.034]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:04.034]                         envir = ns)
[11:00:04.034]                       envir <- sys.frame(frame)
[11:00:04.034]                       master <- NULL
[11:00:04.034]                       while (!identical(envir, .GlobalEnv) && 
[11:00:04.034]                         !identical(envir, emptyenv())) {
[11:00:04.034]                         if (exists("master", mode = "list", envir = envir, 
[11:00:04.034]                           inherits = FALSE)) {
[11:00:04.034]                           master <- get("master", mode = "list", 
[11:00:04.034]                             envir = envir, inherits = FALSE)
[11:00:04.034]                           if (inherits(master, c("SOCKnode", 
[11:00:04.034]                             "SOCK0node"))) {
[11:00:04.034]                             sendCondition <<- function(cond) {
[11:00:04.034]                               data <- list(type = "VALUE", value = cond, 
[11:00:04.034]                                 success = TRUE)
[11:00:04.034]                               parallel_sendData(master, data)
[11:00:04.034]                             }
[11:00:04.034]                             return(sendCondition)
[11:00:04.034]                           }
[11:00:04.034]                         }
[11:00:04.034]                         frame <- frame + 1L
[11:00:04.034]                         envir <- sys.frame(frame)
[11:00:04.034]                       }
[11:00:04.034]                     }
[11:00:04.034]                     sendCondition <<- function(cond) NULL
[11:00:04.034]                   }
[11:00:04.034]                 })
[11:00:04.034]                 withCallingHandlers({
[11:00:04.034]                   {
[11:00:04.034]                     do.call(function(...) {
[11:00:04.034]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:04.034]                       if (!identical(...future.globals.maxSize.org, 
[11:00:04.034]                         ...future.globals.maxSize)) {
[11:00:04.034]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:04.034]                         on.exit(options(oopts), add = TRUE)
[11:00:04.034]                       }
[11:00:04.034]                       {
[11:00:04.034]                         lapply(seq_along(...future.elements_ii), 
[11:00:04.034]                           FUN = function(jj) {
[11:00:04.034]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:04.034]                             ...future.FUN(...future.X_jj, ...)
[11:00:04.034]                           })
[11:00:04.034]                       }
[11:00:04.034]                     }, args = future.call.arguments)
[11:00:04.034]                   }
[11:00:04.034]                 }, immediateCondition = function(cond) {
[11:00:04.034]                   sendCondition <- ...future.makeSendCondition()
[11:00:04.034]                   sendCondition(cond)
[11:00:04.034]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:04.034]                   {
[11:00:04.034]                     inherits <- base::inherits
[11:00:04.034]                     invokeRestart <- base::invokeRestart
[11:00:04.034]                     is.null <- base::is.null
[11:00:04.034]                     muffled <- FALSE
[11:00:04.034]                     if (inherits(cond, "message")) {
[11:00:04.034]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:04.034]                       if (muffled) 
[11:00:04.034]                         invokeRestart("muffleMessage")
[11:00:04.034]                     }
[11:00:04.034]                     else if (inherits(cond, "warning")) {
[11:00:04.034]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:04.034]                       if (muffled) 
[11:00:04.034]                         invokeRestart("muffleWarning")
[11:00:04.034]                     }
[11:00:04.034]                     else if (inherits(cond, "condition")) {
[11:00:04.034]                       if (!is.null(pattern)) {
[11:00:04.034]                         computeRestarts <- base::computeRestarts
[11:00:04.034]                         grepl <- base::grepl
[11:00:04.034]                         restarts <- computeRestarts(cond)
[11:00:04.034]                         for (restart in restarts) {
[11:00:04.034]                           name <- restart$name
[11:00:04.034]                           if (is.null(name)) 
[11:00:04.034]                             next
[11:00:04.034]                           if (!grepl(pattern, name)) 
[11:00:04.034]                             next
[11:00:04.034]                           invokeRestart(restart)
[11:00:04.034]                           muffled <- TRUE
[11:00:04.034]                           break
[11:00:04.034]                         }
[11:00:04.034]                       }
[11:00:04.034]                     }
[11:00:04.034]                     invisible(muffled)
[11:00:04.034]                   }
[11:00:04.034]                   muffleCondition(cond)
[11:00:04.034]                 })
[11:00:04.034]             }))
[11:00:04.034]             future::FutureResult(value = ...future.value$value, 
[11:00:04.034]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:04.034]                   ...future.rng), globalenv = if (FALSE) 
[11:00:04.034]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:04.034]                     ...future.globalenv.names))
[11:00:04.034]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:04.034]         }, condition = base::local({
[11:00:04.034]             c <- base::c
[11:00:04.034]             inherits <- base::inherits
[11:00:04.034]             invokeRestart <- base::invokeRestart
[11:00:04.034]             length <- base::length
[11:00:04.034]             list <- base::list
[11:00:04.034]             seq.int <- base::seq.int
[11:00:04.034]             signalCondition <- base::signalCondition
[11:00:04.034]             sys.calls <- base::sys.calls
[11:00:04.034]             `[[` <- base::`[[`
[11:00:04.034]             `+` <- base::`+`
[11:00:04.034]             `<<-` <- base::`<<-`
[11:00:04.034]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:04.034]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:04.034]                   3L)]
[11:00:04.034]             }
[11:00:04.034]             function(cond) {
[11:00:04.034]                 is_error <- inherits(cond, "error")
[11:00:04.034]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:04.034]                   NULL)
[11:00:04.034]                 if (is_error) {
[11:00:04.034]                   sessionInformation <- function() {
[11:00:04.034]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:04.034]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:04.034]                       search = base::search(), system = base::Sys.info())
[11:00:04.034]                   }
[11:00:04.034]                   ...future.conditions[[length(...future.conditions) + 
[11:00:04.034]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:04.034]                     cond$call), session = sessionInformation(), 
[11:00:04.034]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:04.034]                   signalCondition(cond)
[11:00:04.034]                 }
[11:00:04.034]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:04.034]                 "immediateCondition"))) {
[11:00:04.034]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:04.034]                   ...future.conditions[[length(...future.conditions) + 
[11:00:04.034]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:04.034]                   if (TRUE && !signal) {
[11:00:04.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:04.034]                     {
[11:00:04.034]                       inherits <- base::inherits
[11:00:04.034]                       invokeRestart <- base::invokeRestart
[11:00:04.034]                       is.null <- base::is.null
[11:00:04.034]                       muffled <- FALSE
[11:00:04.034]                       if (inherits(cond, "message")) {
[11:00:04.034]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:04.034]                         if (muffled) 
[11:00:04.034]                           invokeRestart("muffleMessage")
[11:00:04.034]                       }
[11:00:04.034]                       else if (inherits(cond, "warning")) {
[11:00:04.034]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:04.034]                         if (muffled) 
[11:00:04.034]                           invokeRestart("muffleWarning")
[11:00:04.034]                       }
[11:00:04.034]                       else if (inherits(cond, "condition")) {
[11:00:04.034]                         if (!is.null(pattern)) {
[11:00:04.034]                           computeRestarts <- base::computeRestarts
[11:00:04.034]                           grepl <- base::grepl
[11:00:04.034]                           restarts <- computeRestarts(cond)
[11:00:04.034]                           for (restart in restarts) {
[11:00:04.034]                             name <- restart$name
[11:00:04.034]                             if (is.null(name)) 
[11:00:04.034]                               next
[11:00:04.034]                             if (!grepl(pattern, name)) 
[11:00:04.034]                               next
[11:00:04.034]                             invokeRestart(restart)
[11:00:04.034]                             muffled <- TRUE
[11:00:04.034]                             break
[11:00:04.034]                           }
[11:00:04.034]                         }
[11:00:04.034]                       }
[11:00:04.034]                       invisible(muffled)
[11:00:04.034]                     }
[11:00:04.034]                     muffleCondition(cond, pattern = "^muffle")
[11:00:04.034]                   }
[11:00:04.034]                 }
[11:00:04.034]                 else {
[11:00:04.034]                   if (TRUE) {
[11:00:04.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:04.034]                     {
[11:00:04.034]                       inherits <- base::inherits
[11:00:04.034]                       invokeRestart <- base::invokeRestart
[11:00:04.034]                       is.null <- base::is.null
[11:00:04.034]                       muffled <- FALSE
[11:00:04.034]                       if (inherits(cond, "message")) {
[11:00:04.034]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:04.034]                         if (muffled) 
[11:00:04.034]                           invokeRestart("muffleMessage")
[11:00:04.034]                       }
[11:00:04.034]                       else if (inherits(cond, "warning")) {
[11:00:04.034]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:04.034]                         if (muffled) 
[11:00:04.034]                           invokeRestart("muffleWarning")
[11:00:04.034]                       }
[11:00:04.034]                       else if (inherits(cond, "condition")) {
[11:00:04.034]                         if (!is.null(pattern)) {
[11:00:04.034]                           computeRestarts <- base::computeRestarts
[11:00:04.034]                           grepl <- base::grepl
[11:00:04.034]                           restarts <- computeRestarts(cond)
[11:00:04.034]                           for (restart in restarts) {
[11:00:04.034]                             name <- restart$name
[11:00:04.034]                             if (is.null(name)) 
[11:00:04.034]                               next
[11:00:04.034]                             if (!grepl(pattern, name)) 
[11:00:04.034]                               next
[11:00:04.034]                             invokeRestart(restart)
[11:00:04.034]                             muffled <- TRUE
[11:00:04.034]                             break
[11:00:04.034]                           }
[11:00:04.034]                         }
[11:00:04.034]                       }
[11:00:04.034]                       invisible(muffled)
[11:00:04.034]                     }
[11:00:04.034]                     muffleCondition(cond, pattern = "^muffle")
[11:00:04.034]                   }
[11:00:04.034]                 }
[11:00:04.034]             }
[11:00:04.034]         }))
[11:00:04.034]     }, error = function(ex) {
[11:00:04.034]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:04.034]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:04.034]                 ...future.rng), started = ...future.startTime, 
[11:00:04.034]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:04.034]             version = "1.8"), class = "FutureResult")
[11:00:04.034]     }, finally = {
[11:00:04.034]         if (!identical(...future.workdir, getwd())) 
[11:00:04.034]             setwd(...future.workdir)
[11:00:04.034]         {
[11:00:04.034]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:04.034]                 ...future.oldOptions$nwarnings <- NULL
[11:00:04.034]             }
[11:00:04.034]             base::options(...future.oldOptions)
[11:00:04.034]             if (.Platform$OS.type == "windows") {
[11:00:04.034]                 old_names <- names(...future.oldEnvVars)
[11:00:04.034]                 envs <- base::Sys.getenv()
[11:00:04.034]                 names <- names(envs)
[11:00:04.034]                 common <- intersect(names, old_names)
[11:00:04.034]                 added <- setdiff(names, old_names)
[11:00:04.034]                 removed <- setdiff(old_names, names)
[11:00:04.034]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:04.034]                   envs[common]]
[11:00:04.034]                 NAMES <- toupper(changed)
[11:00:04.034]                 args <- list()
[11:00:04.034]                 for (kk in seq_along(NAMES)) {
[11:00:04.034]                   name <- changed[[kk]]
[11:00:04.034]                   NAME <- NAMES[[kk]]
[11:00:04.034]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:04.034]                     next
[11:00:04.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:04.034]                 }
[11:00:04.034]                 NAMES <- toupper(added)
[11:00:04.034]                 for (kk in seq_along(NAMES)) {
[11:00:04.034]                   name <- added[[kk]]
[11:00:04.034]                   NAME <- NAMES[[kk]]
[11:00:04.034]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:04.034]                     next
[11:00:04.034]                   args[[name]] <- ""
[11:00:04.034]                 }
[11:00:04.034]                 NAMES <- toupper(removed)
[11:00:04.034]                 for (kk in seq_along(NAMES)) {
[11:00:04.034]                   name <- removed[[kk]]
[11:00:04.034]                   NAME <- NAMES[[kk]]
[11:00:04.034]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:04.034]                     next
[11:00:04.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:04.034]                 }
[11:00:04.034]                 if (length(args) > 0) 
[11:00:04.034]                   base::do.call(base::Sys.setenv, args = args)
[11:00:04.034]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:04.034]             }
[11:00:04.034]             else {
[11:00:04.034]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:04.034]             }
[11:00:04.034]             {
[11:00:04.034]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:04.034]                   0L) {
[11:00:04.034]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:04.034]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:04.034]                   base::options(opts)
[11:00:04.034]                 }
[11:00:04.034]                 {
[11:00:04.034]                   {
[11:00:04.034]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:04.034]                     NULL
[11:00:04.034]                   }
[11:00:04.034]                   options(future.plan = NULL)
[11:00:04.034]                   if (is.na(NA_character_)) 
[11:00:04.034]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:04.034]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:04.034]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:04.034]                     .init = FALSE)
[11:00:04.034]                 }
[11:00:04.034]             }
[11:00:04.034]         }
[11:00:04.034]     })
[11:00:04.034]     if (TRUE) {
[11:00:04.034]         base::sink(type = "output", split = FALSE)
[11:00:04.034]         if (TRUE) {
[11:00:04.034]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:04.034]         }
[11:00:04.034]         else {
[11:00:04.034]             ...future.result["stdout"] <- base::list(NULL)
[11:00:04.034]         }
[11:00:04.034]         base::close(...future.stdout)
[11:00:04.034]         ...future.stdout <- NULL
[11:00:04.034]     }
[11:00:04.034]     ...future.result$conditions <- ...future.conditions
[11:00:04.034]     ...future.result$finished <- base::Sys.time()
[11:00:04.034]     ...future.result
[11:00:04.034] }
[11:00:04.037] Exporting 11 global objects (13.22 KiB) to cluster node #1 ...
[11:00:04.037] Exporting ‘...future.FUN’ (4.50 KiB) to cluster node #1 ...
[11:00:04.079] Exporting ‘...future.FUN’ (4.50 KiB) to cluster node #1 ... DONE
[11:00:04.079] Exporting ‘x_FUN’ (295 bytes) to cluster node #1 ...
[11:00:04.079] Exporting ‘x_FUN’ (295 bytes) to cluster node #1 ... DONE
[11:00:04.079] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[11:00:04.080] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[11:00:04.080] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[11:00:04.121] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[11:00:04.121] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[11:00:04.162] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[11:00:04.162] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[11:00:04.162] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[11:00:04.162] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[11:00:04.163] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[11:00:04.163] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[11:00:04.163] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[11:00:04.163] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ...
[11:00:04.164] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ... DONE
[11:00:04.164] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[11:00:04.164] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[11:00:04.164] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[11:00:04.164] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[11:00:04.165] Exporting 11 global objects (13.22 KiB) to cluster node #1 ... DONE
[11:00:04.165] MultisessionFuture started
[11:00:04.165] - Launch lazy future ... done
[11:00:04.165] run() for ‘MultisessionFuture’ ... done
[11:00:04.165] Created future:
[11:00:04.166] MultisessionFuture:
[11:00:04.166] Label: ‘future_vapply-1’
[11:00:04.166] Expression:
[11:00:04.166] {
[11:00:04.166]     do.call(function(...) {
[11:00:04.166]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:04.166]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:04.166]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:04.166]             on.exit(options(oopts), add = TRUE)
[11:00:04.166]         }
[11:00:04.166]         {
[11:00:04.166]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:04.166]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:04.166]                 ...future.FUN(...future.X_jj, ...)
[11:00:04.166]             })
[11:00:04.166]         }
[11:00:04.166]     }, args = future.call.arguments)
[11:00:04.166] }
[11:00:04.166] Lazy evaluation: FALSE
[11:00:04.166] Asynchronous evaluation: TRUE
[11:00:04.166] Local evaluation: TRUE
[11:00:04.166] Environment: R_GlobalEnv
[11:00:04.166] Capture standard output: TRUE
[11:00:04.166] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:04.166] Globals: 11 objects totaling 13.01 KiB (function ‘...future.FUN’ of 4.50 KiB, function ‘x_FUN’ of 295 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:04.166] Packages: 1 packages (‘future.apply’)
[11:00:04.166] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:04.166] Resolved: FALSE
[11:00:04.166] Value: <not collected>
[11:00:04.166] Conditions captured: <none>
[11:00:04.166] Early signaling: FALSE
[11:00:04.166] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:04.166] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:04.177] Chunk #1 of 2 ... DONE
[11:00:04.177] Chunk #2 of 2 ...
[11:00:04.177]  - Finding globals in 'X' for chunk #2 ...
[11:00:04.177] getGlobalsAndPackages() ...
[11:00:04.177] Searching for globals...
[11:00:04.178] 
[11:00:04.178] Searching for globals ... DONE
[11:00:04.178] - globals: [0] <none>
[11:00:04.178] getGlobalsAndPackages() ... DONE
[11:00:04.178]    + additional globals found: [n=0] 
[11:00:04.178]    + additional namespaces needed: [n=0] 
[11:00:04.178]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:04.178]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:04.178]  - seeds: <none>
[11:00:04.178]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:04.179] getGlobalsAndPackages() ...
[11:00:04.179] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:04.179] Resolving globals: FALSE
[11:00:04.179] Tweak future expression to call with '...' arguments ...
[11:00:04.179] {
[11:00:04.179]     do.call(function(...) {
[11:00:04.179]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:04.179]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:04.179]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:04.179]             on.exit(options(oopts), add = TRUE)
[11:00:04.179]         }
[11:00:04.179]         {
[11:00:04.179]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:04.179]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:04.179]                 ...future.FUN(...future.X_jj, ...)
[11:00:04.179]             })
[11:00:04.179]         }
[11:00:04.179]     }, args = future.call.arguments)
[11:00:04.179] }
[11:00:04.179] Tweak future expression to call with '...' arguments ... DONE
[11:00:04.180] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:04.180] - packages: [1] ‘future.apply’
[11:00:04.180] getGlobalsAndPackages() ... DONE
[11:00:04.180] run() for ‘Future’ ...
[11:00:04.180] - state: ‘created’
[11:00:04.180] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:04.194] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:04.194] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:04.194]   - Field: ‘node’
[11:00:04.194]   - Field: ‘label’
[11:00:04.194]   - Field: ‘local’
[11:00:04.194]   - Field: ‘owner’
[11:00:04.194]   - Field: ‘envir’
[11:00:04.195]   - Field: ‘workers’
[11:00:04.195]   - Field: ‘packages’
[11:00:04.195]   - Field: ‘gc’
[11:00:04.195]   - Field: ‘conditions’
[11:00:04.195]   - Field: ‘persistent’
[11:00:04.195]   - Field: ‘expr’
[11:00:04.195]   - Field: ‘uuid’
[11:00:04.195]   - Field: ‘seed’
[11:00:04.195]   - Field: ‘version’
[11:00:04.195]   - Field: ‘result’
[11:00:04.195]   - Field: ‘asynchronous’
[11:00:04.195]   - Field: ‘calls’
[11:00:04.196]   - Field: ‘globals’
[11:00:04.196]   - Field: ‘stdout’
[11:00:04.196]   - Field: ‘earlySignal’
[11:00:04.196]   - Field: ‘lazy’
[11:00:04.196]   - Field: ‘state’
[11:00:04.196] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:04.196] - Launch lazy future ...
[11:00:04.196] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:04.196] Packages needed by future strategies (n = 0): <none>
[11:00:04.197] {
[11:00:04.197]     {
[11:00:04.197]         {
[11:00:04.197]             ...future.startTime <- base::Sys.time()
[11:00:04.197]             {
[11:00:04.197]                 {
[11:00:04.197]                   {
[11:00:04.197]                     {
[11:00:04.197]                       {
[11:00:04.197]                         base::local({
[11:00:04.197]                           has_future <- base::requireNamespace("future", 
[11:00:04.197]                             quietly = TRUE)
[11:00:04.197]                           if (has_future) {
[11:00:04.197]                             ns <- base::getNamespace("future")
[11:00:04.197]                             version <- ns[[".package"]][["version"]]
[11:00:04.197]                             if (is.null(version)) 
[11:00:04.197]                               version <- utils::packageVersion("future")
[11:00:04.197]                           }
[11:00:04.197]                           else {
[11:00:04.197]                             version <- NULL
[11:00:04.197]                           }
[11:00:04.197]                           if (!has_future || version < "1.8.0") {
[11:00:04.197]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:04.197]                               "", base::R.version$version.string), 
[11:00:04.197]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:04.197]                                 base::R.version$platform, 8 * 
[11:00:04.197]                                   base::.Machine$sizeof.pointer), 
[11:00:04.197]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:04.197]                                 "release", "version")], collapse = " "), 
[11:00:04.197]                               hostname = base::Sys.info()[["nodename"]])
[11:00:04.197]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:04.197]                               info)
[11:00:04.197]                             info <- base::paste(info, collapse = "; ")
[11:00:04.197]                             if (!has_future) {
[11:00:04.197]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:04.197]                                 info)
[11:00:04.197]                             }
[11:00:04.197]                             else {
[11:00:04.197]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:04.197]                                 info, version)
[11:00:04.197]                             }
[11:00:04.197]                             base::stop(msg)
[11:00:04.197]                           }
[11:00:04.197]                         })
[11:00:04.197]                       }
[11:00:04.197]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:04.197]                       base::options(mc.cores = 1L)
[11:00:04.197]                     }
[11:00:04.197]                     base::local({
[11:00:04.197]                       for (pkg in "future.apply") {
[11:00:04.197]                         base::loadNamespace(pkg)
[11:00:04.197]                         base::library(pkg, character.only = TRUE)
[11:00:04.197]                       }
[11:00:04.197]                     })
[11:00:04.197]                   }
[11:00:04.197]                   ...future.strategy.old <- future::plan("list")
[11:00:04.197]                   options(future.plan = NULL)
[11:00:04.197]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:04.197]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:04.197]                 }
[11:00:04.197]                 ...future.workdir <- getwd()
[11:00:04.197]             }
[11:00:04.197]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:04.197]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:04.197]         }
[11:00:04.197]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:04.197]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:04.197]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:04.197]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:04.197]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:04.197]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:04.197]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:04.197]             base::names(...future.oldOptions))
[11:00:04.197]     }
[11:00:04.197]     if (FALSE) {
[11:00:04.197]     }
[11:00:04.197]     else {
[11:00:04.197]         if (TRUE) {
[11:00:04.197]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:04.197]                 open = "w")
[11:00:04.197]         }
[11:00:04.197]         else {
[11:00:04.197]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:04.197]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:04.197]         }
[11:00:04.197]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:04.197]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:04.197]             base::sink(type = "output", split = FALSE)
[11:00:04.197]             base::close(...future.stdout)
[11:00:04.197]         }, add = TRUE)
[11:00:04.197]     }
[11:00:04.197]     ...future.frame <- base::sys.nframe()
[11:00:04.197]     ...future.conditions <- base::list()
[11:00:04.197]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:04.197]     if (FALSE) {
[11:00:04.197]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:04.197]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:04.197]     }
[11:00:04.197]     ...future.result <- base::tryCatch({
[11:00:04.197]         base::withCallingHandlers({
[11:00:04.197]             ...future.value <- base::withVisible(base::local({
[11:00:04.197]                 ...future.makeSendCondition <- base::local({
[11:00:04.197]                   sendCondition <- NULL
[11:00:04.197]                   function(frame = 1L) {
[11:00:04.197]                     if (is.function(sendCondition)) 
[11:00:04.197]                       return(sendCondition)
[11:00:04.197]                     ns <- getNamespace("parallel")
[11:00:04.197]                     if (exists("sendData", mode = "function", 
[11:00:04.197]                       envir = ns)) {
[11:00:04.197]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:04.197]                         envir = ns)
[11:00:04.197]                       envir <- sys.frame(frame)
[11:00:04.197]                       master <- NULL
[11:00:04.197]                       while (!identical(envir, .GlobalEnv) && 
[11:00:04.197]                         !identical(envir, emptyenv())) {
[11:00:04.197]                         if (exists("master", mode = "list", envir = envir, 
[11:00:04.197]                           inherits = FALSE)) {
[11:00:04.197]                           master <- get("master", mode = "list", 
[11:00:04.197]                             envir = envir, inherits = FALSE)
[11:00:04.197]                           if (inherits(master, c("SOCKnode", 
[11:00:04.197]                             "SOCK0node"))) {
[11:00:04.197]                             sendCondition <<- function(cond) {
[11:00:04.197]                               data <- list(type = "VALUE", value = cond, 
[11:00:04.197]                                 success = TRUE)
[11:00:04.197]                               parallel_sendData(master, data)
[11:00:04.197]                             }
[11:00:04.197]                             return(sendCondition)
[11:00:04.197]                           }
[11:00:04.197]                         }
[11:00:04.197]                         frame <- frame + 1L
[11:00:04.197]                         envir <- sys.frame(frame)
[11:00:04.197]                       }
[11:00:04.197]                     }
[11:00:04.197]                     sendCondition <<- function(cond) NULL
[11:00:04.197]                   }
[11:00:04.197]                 })
[11:00:04.197]                 withCallingHandlers({
[11:00:04.197]                   {
[11:00:04.197]                     do.call(function(...) {
[11:00:04.197]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:04.197]                       if (!identical(...future.globals.maxSize.org, 
[11:00:04.197]                         ...future.globals.maxSize)) {
[11:00:04.197]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:04.197]                         on.exit(options(oopts), add = TRUE)
[11:00:04.197]                       }
[11:00:04.197]                       {
[11:00:04.197]                         lapply(seq_along(...future.elements_ii), 
[11:00:04.197]                           FUN = function(jj) {
[11:00:04.197]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:04.197]                             ...future.FUN(...future.X_jj, ...)
[11:00:04.197]                           })
[11:00:04.197]                       }
[11:00:04.197]                     }, args = future.call.arguments)
[11:00:04.197]                   }
[11:00:04.197]                 }, immediateCondition = function(cond) {
[11:00:04.197]                   sendCondition <- ...future.makeSendCondition()
[11:00:04.197]                   sendCondition(cond)
[11:00:04.197]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:04.197]                   {
[11:00:04.197]                     inherits <- base::inherits
[11:00:04.197]                     invokeRestart <- base::invokeRestart
[11:00:04.197]                     is.null <- base::is.null
[11:00:04.197]                     muffled <- FALSE
[11:00:04.197]                     if (inherits(cond, "message")) {
[11:00:04.197]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:04.197]                       if (muffled) 
[11:00:04.197]                         invokeRestart("muffleMessage")
[11:00:04.197]                     }
[11:00:04.197]                     else if (inherits(cond, "warning")) {
[11:00:04.197]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:04.197]                       if (muffled) 
[11:00:04.197]                         invokeRestart("muffleWarning")
[11:00:04.197]                     }
[11:00:04.197]                     else if (inherits(cond, "condition")) {
[11:00:04.197]                       if (!is.null(pattern)) {
[11:00:04.197]                         computeRestarts <- base::computeRestarts
[11:00:04.197]                         grepl <- base::grepl
[11:00:04.197]                         restarts <- computeRestarts(cond)
[11:00:04.197]                         for (restart in restarts) {
[11:00:04.197]                           name <- restart$name
[11:00:04.197]                           if (is.null(name)) 
[11:00:04.197]                             next
[11:00:04.197]                           if (!grepl(pattern, name)) 
[11:00:04.197]                             next
[11:00:04.197]                           invokeRestart(restart)
[11:00:04.197]                           muffled <- TRUE
[11:00:04.197]                           break
[11:00:04.197]                         }
[11:00:04.197]                       }
[11:00:04.197]                     }
[11:00:04.197]                     invisible(muffled)
[11:00:04.197]                   }
[11:00:04.197]                   muffleCondition(cond)
[11:00:04.197]                 })
[11:00:04.197]             }))
[11:00:04.197]             future::FutureResult(value = ...future.value$value, 
[11:00:04.197]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:04.197]                   ...future.rng), globalenv = if (FALSE) 
[11:00:04.197]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:04.197]                     ...future.globalenv.names))
[11:00:04.197]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:04.197]         }, condition = base::local({
[11:00:04.197]             c <- base::c
[11:00:04.197]             inherits <- base::inherits
[11:00:04.197]             invokeRestart <- base::invokeRestart
[11:00:04.197]             length <- base::length
[11:00:04.197]             list <- base::list
[11:00:04.197]             seq.int <- base::seq.int
[11:00:04.197]             signalCondition <- base::signalCondition
[11:00:04.197]             sys.calls <- base::sys.calls
[11:00:04.197]             `[[` <- base::`[[`
[11:00:04.197]             `+` <- base::`+`
[11:00:04.197]             `<<-` <- base::`<<-`
[11:00:04.197]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:04.197]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:04.197]                   3L)]
[11:00:04.197]             }
[11:00:04.197]             function(cond) {
[11:00:04.197]                 is_error <- inherits(cond, "error")
[11:00:04.197]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:04.197]                   NULL)
[11:00:04.197]                 if (is_error) {
[11:00:04.197]                   sessionInformation <- function() {
[11:00:04.197]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:04.197]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:04.197]                       search = base::search(), system = base::Sys.info())
[11:00:04.197]                   }
[11:00:04.197]                   ...future.conditions[[length(...future.conditions) + 
[11:00:04.197]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:04.197]                     cond$call), session = sessionInformation(), 
[11:00:04.197]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:04.197]                   signalCondition(cond)
[11:00:04.197]                 }
[11:00:04.197]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:04.197]                 "immediateCondition"))) {
[11:00:04.197]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:04.197]                   ...future.conditions[[length(...future.conditions) + 
[11:00:04.197]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:04.197]                   if (TRUE && !signal) {
[11:00:04.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:04.197]                     {
[11:00:04.197]                       inherits <- base::inherits
[11:00:04.197]                       invokeRestart <- base::invokeRestart
[11:00:04.197]                       is.null <- base::is.null
[11:00:04.197]                       muffled <- FALSE
[11:00:04.197]                       if (inherits(cond, "message")) {
[11:00:04.197]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:04.197]                         if (muffled) 
[11:00:04.197]                           invokeRestart("muffleMessage")
[11:00:04.197]                       }
[11:00:04.197]                       else if (inherits(cond, "warning")) {
[11:00:04.197]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:04.197]                         if (muffled) 
[11:00:04.197]                           invokeRestart("muffleWarning")
[11:00:04.197]                       }
[11:00:04.197]                       else if (inherits(cond, "condition")) {
[11:00:04.197]                         if (!is.null(pattern)) {
[11:00:04.197]                           computeRestarts <- base::computeRestarts
[11:00:04.197]                           grepl <- base::grepl
[11:00:04.197]                           restarts <- computeRestarts(cond)
[11:00:04.197]                           for (restart in restarts) {
[11:00:04.197]                             name <- restart$name
[11:00:04.197]                             if (is.null(name)) 
[11:00:04.197]                               next
[11:00:04.197]                             if (!grepl(pattern, name)) 
[11:00:04.197]                               next
[11:00:04.197]                             invokeRestart(restart)
[11:00:04.197]                             muffled <- TRUE
[11:00:04.197]                             break
[11:00:04.197]                           }
[11:00:04.197]                         }
[11:00:04.197]                       }
[11:00:04.197]                       invisible(muffled)
[11:00:04.197]                     }
[11:00:04.197]                     muffleCondition(cond, pattern = "^muffle")
[11:00:04.197]                   }
[11:00:04.197]                 }
[11:00:04.197]                 else {
[11:00:04.197]                   if (TRUE) {
[11:00:04.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:04.197]                     {
[11:00:04.197]                       inherits <- base::inherits
[11:00:04.197]                       invokeRestart <- base::invokeRestart
[11:00:04.197]                       is.null <- base::is.null
[11:00:04.197]                       muffled <- FALSE
[11:00:04.197]                       if (inherits(cond, "message")) {
[11:00:04.197]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:04.197]                         if (muffled) 
[11:00:04.197]                           invokeRestart("muffleMessage")
[11:00:04.197]                       }
[11:00:04.197]                       else if (inherits(cond, "warning")) {
[11:00:04.197]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:04.197]                         if (muffled) 
[11:00:04.197]                           invokeRestart("muffleWarning")
[11:00:04.197]                       }
[11:00:04.197]                       else if (inherits(cond, "condition")) {
[11:00:04.197]                         if (!is.null(pattern)) {
[11:00:04.197]                           computeRestarts <- base::computeRestarts
[11:00:04.197]                           grepl <- base::grepl
[11:00:04.197]                           restarts <- computeRestarts(cond)
[11:00:04.197]                           for (restart in restarts) {
[11:00:04.197]                             name <- restart$name
[11:00:04.197]                             if (is.null(name)) 
[11:00:04.197]                               next
[11:00:04.197]                             if (!grepl(pattern, name)) 
[11:00:04.197]                               next
[11:00:04.197]                             invokeRestart(restart)
[11:00:04.197]                             muffled <- TRUE
[11:00:04.197]                             break
[11:00:04.197]                           }
[11:00:04.197]                         }
[11:00:04.197]                       }
[11:00:04.197]                       invisible(muffled)
[11:00:04.197]                     }
[11:00:04.197]                     muffleCondition(cond, pattern = "^muffle")
[11:00:04.197]                   }
[11:00:04.197]                 }
[11:00:04.197]             }
[11:00:04.197]         }))
[11:00:04.197]     }, error = function(ex) {
[11:00:04.197]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:04.197]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:04.197]                 ...future.rng), started = ...future.startTime, 
[11:00:04.197]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:04.197]             version = "1.8"), class = "FutureResult")
[11:00:04.197]     }, finally = {
[11:00:04.197]         if (!identical(...future.workdir, getwd())) 
[11:00:04.197]             setwd(...future.workdir)
[11:00:04.197]         {
[11:00:04.197]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:04.197]                 ...future.oldOptions$nwarnings <- NULL
[11:00:04.197]             }
[11:00:04.197]             base::options(...future.oldOptions)
[11:00:04.197]             if (.Platform$OS.type == "windows") {
[11:00:04.197]                 old_names <- names(...future.oldEnvVars)
[11:00:04.197]                 envs <- base::Sys.getenv()
[11:00:04.197]                 names <- names(envs)
[11:00:04.197]                 common <- intersect(names, old_names)
[11:00:04.197]                 added <- setdiff(names, old_names)
[11:00:04.197]                 removed <- setdiff(old_names, names)
[11:00:04.197]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:04.197]                   envs[common]]
[11:00:04.197]                 NAMES <- toupper(changed)
[11:00:04.197]                 args <- list()
[11:00:04.197]                 for (kk in seq_along(NAMES)) {
[11:00:04.197]                   name <- changed[[kk]]
[11:00:04.197]                   NAME <- NAMES[[kk]]
[11:00:04.197]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:04.197]                     next
[11:00:04.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:04.197]                 }
[11:00:04.197]                 NAMES <- toupper(added)
[11:00:04.197]                 for (kk in seq_along(NAMES)) {
[11:00:04.197]                   name <- added[[kk]]
[11:00:04.197]                   NAME <- NAMES[[kk]]
[11:00:04.197]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:04.197]                     next
[11:00:04.197]                   args[[name]] <- ""
[11:00:04.197]                 }
[11:00:04.197]                 NAMES <- toupper(removed)
[11:00:04.197]                 for (kk in seq_along(NAMES)) {
[11:00:04.197]                   name <- removed[[kk]]
[11:00:04.197]                   NAME <- NAMES[[kk]]
[11:00:04.197]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:04.197]                     next
[11:00:04.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:04.197]                 }
[11:00:04.197]                 if (length(args) > 0) 
[11:00:04.197]                   base::do.call(base::Sys.setenv, args = args)
[11:00:04.197]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:04.197]             }
[11:00:04.197]             else {
[11:00:04.197]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:04.197]             }
[11:00:04.197]             {
[11:00:04.197]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:04.197]                   0L) {
[11:00:04.197]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:04.197]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:04.197]                   base::options(opts)
[11:00:04.197]                 }
[11:00:04.197]                 {
[11:00:04.197]                   {
[11:00:04.197]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:04.197]                     NULL
[11:00:04.197]                   }
[11:00:04.197]                   options(future.plan = NULL)
[11:00:04.197]                   if (is.na(NA_character_)) 
[11:00:04.197]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:04.197]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:04.197]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:04.197]                     .init = FALSE)
[11:00:04.197]                 }
[11:00:04.197]             }
[11:00:04.197]         }
[11:00:04.197]     })
[11:00:04.197]     if (TRUE) {
[11:00:04.197]         base::sink(type = "output", split = FALSE)
[11:00:04.197]         if (TRUE) {
[11:00:04.197]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:04.197]         }
[11:00:04.197]         else {
[11:00:04.197]             ...future.result["stdout"] <- base::list(NULL)
[11:00:04.197]         }
[11:00:04.197]         base::close(...future.stdout)
[11:00:04.197]         ...future.stdout <- NULL
[11:00:04.197]     }
[11:00:04.197]     ...future.result$conditions <- ...future.conditions
[11:00:04.197]     ...future.result$finished <- base::Sys.time()
[11:00:04.197]     ...future.result
[11:00:04.197] }
[11:00:04.200] Exporting 11 global objects (13.22 KiB) to cluster node #2 ...
[11:00:04.200] Exporting ‘...future.FUN’ (4.50 KiB) to cluster node #2 ...
[11:00:04.241] Exporting ‘...future.FUN’ (4.50 KiB) to cluster node #2 ... DONE
[11:00:04.241] Exporting ‘x_FUN’ (295 bytes) to cluster node #2 ...
[11:00:04.241] Exporting ‘x_FUN’ (295 bytes) to cluster node #2 ... DONE
[11:00:04.241] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[11:00:04.242] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[11:00:04.242] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[11:00:04.283] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[11:00:04.283] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[11:00:04.324] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[11:00:04.324] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[11:00:04.324] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[11:00:04.324] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[11:00:04.325] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[11:00:04.325] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[11:00:04.325] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[11:00:04.325] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ...
[11:00:04.326] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ... DONE
[11:00:04.326] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[11:00:04.326] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[11:00:04.326] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[11:00:04.327] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[11:00:04.327] Exporting 11 global objects (13.22 KiB) to cluster node #2 ... DONE
[11:00:04.327] MultisessionFuture started
[11:00:04.327] - Launch lazy future ... done
[11:00:04.327] run() for ‘MultisessionFuture’ ... done
[11:00:04.327] Created future:
[11:00:04.327] MultisessionFuture:
[11:00:04.327] Label: ‘future_vapply-2’
[11:00:04.327] Expression:
[11:00:04.327] {
[11:00:04.327]     do.call(function(...) {
[11:00:04.327]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:04.327]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:04.327]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:04.327]             on.exit(options(oopts), add = TRUE)
[11:00:04.327]         }
[11:00:04.327]         {
[11:00:04.327]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:04.327]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:04.327]                 ...future.FUN(...future.X_jj, ...)
[11:00:04.327]             })
[11:00:04.327]         }
[11:00:04.327]     }, args = future.call.arguments)
[11:00:04.327] }
[11:00:04.327] Lazy evaluation: FALSE
[11:00:04.327] Asynchronous evaluation: TRUE
[11:00:04.327] Local evaluation: TRUE
[11:00:04.327] Environment: R_GlobalEnv
[11:00:04.327] Capture standard output: TRUE
[11:00:04.327] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:04.327] Globals: 11 objects totaling 13.01 KiB (function ‘...future.FUN’ of 4.50 KiB, function ‘x_FUN’ of 295 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:04.327] Packages: 1 packages (‘future.apply’)
[11:00:04.327] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:04.327] Resolved: FALSE
[11:00:04.327] Value: <not collected>
[11:00:04.327] Conditions captured: <none>
[11:00:04.327] Early signaling: FALSE
[11:00:04.327] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:04.327] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:04.339] Chunk #2 of 2 ... DONE
[11:00:04.339] Launching 2 futures (chunks) ... DONE
[11:00:04.339] Resolving 2 futures (chunks) ...
[11:00:04.339] resolve() on list ...
[11:00:04.339]  recursive: 0
[11:00:04.339]  length: 2
[11:00:04.340] 
[11:00:04.340] receiveMessageFromWorker() for ClusterFuture ...
[11:00:04.340] - Validating connection of MultisessionFuture
[11:00:04.340] - received message: FutureResult
[11:00:04.340] - Received FutureResult
[11:00:04.340] - Erased future from FutureRegistry
[11:00:04.341] result() for ClusterFuture ...
[11:00:04.341] - result already collected: FutureResult
[11:00:04.341] result() for ClusterFuture ... done
[11:00:04.341] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:04.341] Future #1
[11:00:04.341] result() for ClusterFuture ...
[11:00:04.341] - result already collected: FutureResult
[11:00:04.341] result() for ClusterFuture ... done
[11:00:04.341] result() for ClusterFuture ...
[11:00:04.341] - result already collected: FutureResult
[11:00:04.341] result() for ClusterFuture ... done
[11:00:04.341] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:00:04.342] - nx: 2
[11:00:04.342] - relay: TRUE
[11:00:04.342] - stdout: TRUE
[11:00:04.342] - signal: TRUE
[11:00:04.342] - resignal: FALSE
[11:00:04.342] - force: TRUE
[11:00:04.342] - relayed: [n=2] FALSE, FALSE
[11:00:04.342] - queued futures: [n=2] FALSE, FALSE
[11:00:04.342]  - until=1
[11:00:04.342]  - relaying element #1
[11:00:04.342] result() for ClusterFuture ...
[11:00:04.342] - result already collected: FutureResult
[11:00:04.342] result() for ClusterFuture ... done
[11:00:04.343] result() for ClusterFuture ...
[11:00:04.343] - result already collected: FutureResult
[11:00:04.343] result() for ClusterFuture ... done
[11:00:04.343] result() for ClusterFuture ...
[11:00:04.343] - result already collected: FutureResult
[11:00:04.343] result() for ClusterFuture ... done
[11:00:04.343] result() for ClusterFuture ...
[11:00:04.343] - result already collected: FutureResult
[11:00:04.343] result() for ClusterFuture ... done
[11:00:04.343] - relayed: [n=2] TRUE, FALSE
[11:00:04.343] - queued futures: [n=2] TRUE, FALSE
[11:00:04.343] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:00:04.344]  length: 1 (resolved future 1)
[11:00:04.369] receiveMessageFromWorker() for ClusterFuture ...
[11:00:04.369] - Validating connection of MultisessionFuture
[11:00:04.370] - received message: FutureResult
[11:00:04.370] - Received FutureResult
[11:00:04.370] - Erased future from FutureRegistry
[11:00:04.370] result() for ClusterFuture ...
[11:00:04.370] - result already collected: FutureResult
[11:00:04.370] result() for ClusterFuture ... done
[11:00:04.370] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:04.370] Future #2
[11:00:04.370] result() for ClusterFuture ...
[11:00:04.370] - result already collected: FutureResult
[11:00:04.370] result() for ClusterFuture ... done
[11:00:04.371] result() for ClusterFuture ...
[11:00:04.371] - result already collected: FutureResult
[11:00:04.371] result() for ClusterFuture ... done
[11:00:04.371] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:00:04.371] - nx: 2
[11:00:04.371] - relay: TRUE
[11:00:04.371] - stdout: TRUE
[11:00:04.371] - signal: TRUE
[11:00:04.371] - resignal: FALSE
[11:00:04.371] - force: TRUE
[11:00:04.371] - relayed: [n=2] TRUE, FALSE
[11:00:04.371] - queued futures: [n=2] TRUE, FALSE
[11:00:04.372]  - until=2
[11:00:04.372]  - relaying element #2
[11:00:04.372] result() for ClusterFuture ...
[11:00:04.372] - result already collected: FutureResult
[11:00:04.372] result() for ClusterFuture ... done
[11:00:04.372] result() for ClusterFuture ...
[11:00:04.372] - result already collected: FutureResult
[11:00:04.372] result() for ClusterFuture ... done
[11:00:04.372] result() for ClusterFuture ...
[11:00:04.372] - result already collected: FutureResult
[11:00:04.372] result() for ClusterFuture ... done
[11:00:04.372] result() for ClusterFuture ...
[11:00:04.373] - result already collected: FutureResult
[11:00:04.373] result() for ClusterFuture ... done
[11:00:04.373] - relayed: [n=2] TRUE, TRUE
[11:00:04.373] - queued futures: [n=2] TRUE, TRUE
[11:00:04.373] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:00:04.373]  length: 0 (resolved future 2)
[11:00:04.373] Relaying remaining futures
[11:00:04.373] signalConditionsASAP(NULL, pos=0) ...
[11:00:04.373] - nx: 2
[11:00:04.373] - relay: TRUE
[11:00:04.373] - stdout: TRUE
[11:00:04.373] - signal: TRUE
[11:00:04.373] - resignal: FALSE
[11:00:04.374] - force: TRUE
[11:00:04.374] - relayed: [n=2] TRUE, TRUE
[11:00:04.374] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:04.374] - relayed: [n=2] TRUE, TRUE
[11:00:04.374] - queued futures: [n=2] TRUE, TRUE
[11:00:04.374] signalConditionsASAP(NULL, pos=0) ... done
[11:00:04.374] resolve() on list ... DONE
[11:00:04.374] result() for ClusterFuture ...
[11:00:04.374] - result already collected: FutureResult
[11:00:04.374] result() for ClusterFuture ... done
[11:00:04.374] result() for ClusterFuture ...
[11:00:04.374] - result already collected: FutureResult
[11:00:04.375] result() for ClusterFuture ... done
[11:00:04.375] result() for ClusterFuture ...
[11:00:04.375] - result already collected: FutureResult
[11:00:04.375] result() for ClusterFuture ... done
[11:00:04.375] result() for ClusterFuture ...
[11:00:04.375] - result already collected: FutureResult
[11:00:04.375] result() for ClusterFuture ... done
[11:00:04.375]  - Number of value chunks collected: 2
[11:00:04.375] Resolving 2 futures (chunks) ... DONE
[11:00:04.375] Reducing values from 2 chunks ...
[11:00:04.375]  - Number of values collected after concatenation: 10
[11:00:04.375]  - Number of values expected: 10
[11:00:04.376] Reducing values from 2 chunks ... DONE
[11:00:04.376] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[11:00:04.376] future_lapply() ...
[11:00:04.380] Number of chunks: 2
[11:00:04.380] getGlobalsAndPackagesXApply() ...
[11:00:04.380]  - future.globals: TRUE
[11:00:04.380] getGlobalsAndPackages() ...
[11:00:04.380] Searching for globals...
[11:00:04.383] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[11:00:04.383] Searching for globals ... DONE
[11:00:04.384] Resolving globals: FALSE
[11:00:04.384] The total size of the 7 globals is 12.75 KiB (13056 bytes)
[11:00:04.385] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.50 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:04.385] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:04.385] - packages: [1] ‘future.apply’
[11:00:04.385] getGlobalsAndPackages() ... DONE
[11:00:04.385]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:04.385]  - needed namespaces: [n=1] ‘future.apply’
[11:00:04.385] Finding globals ... DONE
[11:00:04.385]  - use_args: TRUE
[11:00:04.386]  - Getting '...' globals ...
[11:00:04.386] resolve() on list ...
[11:00:04.386]  recursive: 0
[11:00:04.386]  length: 1
[11:00:04.386]  elements: ‘...’
[11:00:04.386]  length: 0 (resolved future 1)
[11:00:04.386] resolve() on list ... DONE
[11:00:04.386]    - '...' content: [n=0] 
[11:00:04.386] List of 1
[11:00:04.386]  $ ...: list()
[11:00:04.386]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:04.386]  - attr(*, "where")=List of 1
[11:00:04.386]   ..$ ...:<environment: 0x55bbaf693888> 
[11:00:04.386]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:04.386]  - attr(*, "resolved")= logi TRUE
[11:00:04.386]  - attr(*, "total_size")= num NA
[11:00:04.389]  - Getting '...' globals ... DONE
[11:00:04.389] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:04.389] List of 8
[11:00:04.389]  $ ...future.FUN:function (x, ...)  
[11:00:04.389]  $ x_FUN        :function (x)  
[11:00:04.389]  $ times        : int 0
[11:00:04.389]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:04.389]  $ stop_if_not  :function (...)  
[11:00:04.389]  $ dim          : NULL
[11:00:04.389]  $ valid_types  : chr [1:2] "logical" "integer"
[11:00:04.389]  $ ...          : list()
[11:00:04.389]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:04.389]  - attr(*, "where")=List of 8
[11:00:04.389]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:04.389]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:04.389]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:04.389]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:04.389]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:04.389]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:04.389]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:04.389]   ..$ ...          :<environment: 0x55bbaf693888> 
[11:00:04.389]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:04.389]  - attr(*, "resolved")= logi FALSE
[11:00:04.389]  - attr(*, "total_size")= num 23453
[11:00:04.394] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:04.394] getGlobalsAndPackagesXApply() ... DONE
[11:00:04.394] Number of futures (= number of chunks): 2
[11:00:04.395] Launching 2 futures (chunks) ...
[11:00:04.395] Chunk #1 of 2 ...
[11:00:04.395]  - Finding globals in 'X' for chunk #1 ...
[11:00:04.395] getGlobalsAndPackages() ...
[11:00:04.395] Searching for globals...
[11:00:04.395] 
[11:00:04.395] Searching for globals ... DONE
[11:00:04.395] - globals: [0] <none>
[11:00:04.395] getGlobalsAndPackages() ... DONE
[11:00:04.395]    + additional globals found: [n=0] 
[11:00:04.396]    + additional namespaces needed: [n=0] 
[11:00:04.396]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:04.396]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:04.396]  - seeds: <none>
[11:00:04.396]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:04.396] getGlobalsAndPackages() ...
[11:00:04.396] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:04.396] Resolving globals: FALSE
[11:00:04.396] Tweak future expression to call with '...' arguments ...
[11:00:04.396] {
[11:00:04.396]     do.call(function(...) {
[11:00:04.396]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:04.396]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:04.396]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:04.396]             on.exit(options(oopts), add = TRUE)
[11:00:04.396]         }
[11:00:04.396]         {
[11:00:04.396]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:04.396]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:04.396]                 ...future.FUN(...future.X_jj, ...)
[11:00:04.396]             })
[11:00:04.396]         }
[11:00:04.396]     }, args = future.call.arguments)
[11:00:04.396] }
[11:00:04.397] Tweak future expression to call with '...' arguments ... DONE
[11:00:04.397] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:04.397] - packages: [1] ‘future.apply’
[11:00:04.397] getGlobalsAndPackages() ... DONE
[11:00:04.398] run() for ‘Future’ ...
[11:00:04.398] - state: ‘created’
[11:00:04.398] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:04.411] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:04.412] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:04.412]   - Field: ‘node’
[11:00:04.412]   - Field: ‘label’
[11:00:04.412]   - Field: ‘local’
[11:00:04.412]   - Field: ‘owner’
[11:00:04.412]   - Field: ‘envir’
[11:00:04.412]   - Field: ‘workers’
[11:00:04.412]   - Field: ‘packages’
[11:00:04.412]   - Field: ‘gc’
[11:00:04.412]   - Field: ‘conditions’
[11:00:04.413]   - Field: ‘persistent’
[11:00:04.413]   - Field: ‘expr’
[11:00:04.413]   - Field: ‘uuid’
[11:00:04.413]   - Field: ‘seed’
[11:00:04.413]   - Field: ‘version’
[11:00:04.413]   - Field: ‘result’
[11:00:04.413]   - Field: ‘asynchronous’
[11:00:04.413]   - Field: ‘calls’
[11:00:04.413]   - Field: ‘globals’
[11:00:04.413]   - Field: ‘stdout’
[11:00:04.413]   - Field: ‘earlySignal’
[11:00:04.413]   - Field: ‘lazy’
[11:00:04.414]   - Field: ‘state’
[11:00:04.414] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:04.414] - Launch lazy future ...
[11:00:04.414] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:04.414] Packages needed by future strategies (n = 0): <none>
[11:00:04.415] {
[11:00:04.415]     {
[11:00:04.415]         {
[11:00:04.415]             ...future.startTime <- base::Sys.time()
[11:00:04.415]             {
[11:00:04.415]                 {
[11:00:04.415]                   {
[11:00:04.415]                     {
[11:00:04.415]                       {
[11:00:04.415]                         base::local({
[11:00:04.415]                           has_future <- base::requireNamespace("future", 
[11:00:04.415]                             quietly = TRUE)
[11:00:04.415]                           if (has_future) {
[11:00:04.415]                             ns <- base::getNamespace("future")
[11:00:04.415]                             version <- ns[[".package"]][["version"]]
[11:00:04.415]                             if (is.null(version)) 
[11:00:04.415]                               version <- utils::packageVersion("future")
[11:00:04.415]                           }
[11:00:04.415]                           else {
[11:00:04.415]                             version <- NULL
[11:00:04.415]                           }
[11:00:04.415]                           if (!has_future || version < "1.8.0") {
[11:00:04.415]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:04.415]                               "", base::R.version$version.string), 
[11:00:04.415]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:04.415]                                 base::R.version$platform, 8 * 
[11:00:04.415]                                   base::.Machine$sizeof.pointer), 
[11:00:04.415]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:04.415]                                 "release", "version")], collapse = " "), 
[11:00:04.415]                               hostname = base::Sys.info()[["nodename"]])
[11:00:04.415]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:04.415]                               info)
[11:00:04.415]                             info <- base::paste(info, collapse = "; ")
[11:00:04.415]                             if (!has_future) {
[11:00:04.415]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:04.415]                                 info)
[11:00:04.415]                             }
[11:00:04.415]                             else {
[11:00:04.415]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:04.415]                                 info, version)
[11:00:04.415]                             }
[11:00:04.415]                             base::stop(msg)
[11:00:04.415]                           }
[11:00:04.415]                         })
[11:00:04.415]                       }
[11:00:04.415]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:04.415]                       base::options(mc.cores = 1L)
[11:00:04.415]                     }
[11:00:04.415]                     base::local({
[11:00:04.415]                       for (pkg in "future.apply") {
[11:00:04.415]                         base::loadNamespace(pkg)
[11:00:04.415]                         base::library(pkg, character.only = TRUE)
[11:00:04.415]                       }
[11:00:04.415]                     })
[11:00:04.415]                   }
[11:00:04.415]                   ...future.strategy.old <- future::plan("list")
[11:00:04.415]                   options(future.plan = NULL)
[11:00:04.415]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:04.415]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:04.415]                 }
[11:00:04.415]                 ...future.workdir <- getwd()
[11:00:04.415]             }
[11:00:04.415]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:04.415]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:04.415]         }
[11:00:04.415]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:04.415]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:04.415]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:04.415]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:04.415]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:04.415]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:04.415]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:04.415]             base::names(...future.oldOptions))
[11:00:04.415]     }
[11:00:04.415]     if (FALSE) {
[11:00:04.415]     }
[11:00:04.415]     else {
[11:00:04.415]         if (TRUE) {
[11:00:04.415]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:04.415]                 open = "w")
[11:00:04.415]         }
[11:00:04.415]         else {
[11:00:04.415]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:04.415]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:04.415]         }
[11:00:04.415]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:04.415]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:04.415]             base::sink(type = "output", split = FALSE)
[11:00:04.415]             base::close(...future.stdout)
[11:00:04.415]         }, add = TRUE)
[11:00:04.415]     }
[11:00:04.415]     ...future.frame <- base::sys.nframe()
[11:00:04.415]     ...future.conditions <- base::list()
[11:00:04.415]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:04.415]     if (FALSE) {
[11:00:04.415]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:04.415]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:04.415]     }
[11:00:04.415]     ...future.result <- base::tryCatch({
[11:00:04.415]         base::withCallingHandlers({
[11:00:04.415]             ...future.value <- base::withVisible(base::local({
[11:00:04.415]                 ...future.makeSendCondition <- base::local({
[11:00:04.415]                   sendCondition <- NULL
[11:00:04.415]                   function(frame = 1L) {
[11:00:04.415]                     if (is.function(sendCondition)) 
[11:00:04.415]                       return(sendCondition)
[11:00:04.415]                     ns <- getNamespace("parallel")
[11:00:04.415]                     if (exists("sendData", mode = "function", 
[11:00:04.415]                       envir = ns)) {
[11:00:04.415]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:04.415]                         envir = ns)
[11:00:04.415]                       envir <- sys.frame(frame)
[11:00:04.415]                       master <- NULL
[11:00:04.415]                       while (!identical(envir, .GlobalEnv) && 
[11:00:04.415]                         !identical(envir, emptyenv())) {
[11:00:04.415]                         if (exists("master", mode = "list", envir = envir, 
[11:00:04.415]                           inherits = FALSE)) {
[11:00:04.415]                           master <- get("master", mode = "list", 
[11:00:04.415]                             envir = envir, inherits = FALSE)
[11:00:04.415]                           if (inherits(master, c("SOCKnode", 
[11:00:04.415]                             "SOCK0node"))) {
[11:00:04.415]                             sendCondition <<- function(cond) {
[11:00:04.415]                               data <- list(type = "VALUE", value = cond, 
[11:00:04.415]                                 success = TRUE)
[11:00:04.415]                               parallel_sendData(master, data)
[11:00:04.415]                             }
[11:00:04.415]                             return(sendCondition)
[11:00:04.415]                           }
[11:00:04.415]                         }
[11:00:04.415]                         frame <- frame + 1L
[11:00:04.415]                         envir <- sys.frame(frame)
[11:00:04.415]                       }
[11:00:04.415]                     }
[11:00:04.415]                     sendCondition <<- function(cond) NULL
[11:00:04.415]                   }
[11:00:04.415]                 })
[11:00:04.415]                 withCallingHandlers({
[11:00:04.415]                   {
[11:00:04.415]                     do.call(function(...) {
[11:00:04.415]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:04.415]                       if (!identical(...future.globals.maxSize.org, 
[11:00:04.415]                         ...future.globals.maxSize)) {
[11:00:04.415]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:04.415]                         on.exit(options(oopts), add = TRUE)
[11:00:04.415]                       }
[11:00:04.415]                       {
[11:00:04.415]                         lapply(seq_along(...future.elements_ii), 
[11:00:04.415]                           FUN = function(jj) {
[11:00:04.415]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:04.415]                             ...future.FUN(...future.X_jj, ...)
[11:00:04.415]                           })
[11:00:04.415]                       }
[11:00:04.415]                     }, args = future.call.arguments)
[11:00:04.415]                   }
[11:00:04.415]                 }, immediateCondition = function(cond) {
[11:00:04.415]                   sendCondition <- ...future.makeSendCondition()
[11:00:04.415]                   sendCondition(cond)
[11:00:04.415]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:04.415]                   {
[11:00:04.415]                     inherits <- base::inherits
[11:00:04.415]                     invokeRestart <- base::invokeRestart
[11:00:04.415]                     is.null <- base::is.null
[11:00:04.415]                     muffled <- FALSE
[11:00:04.415]                     if (inherits(cond, "message")) {
[11:00:04.415]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:04.415]                       if (muffled) 
[11:00:04.415]                         invokeRestart("muffleMessage")
[11:00:04.415]                     }
[11:00:04.415]                     else if (inherits(cond, "warning")) {
[11:00:04.415]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:04.415]                       if (muffled) 
[11:00:04.415]                         invokeRestart("muffleWarning")
[11:00:04.415]                     }
[11:00:04.415]                     else if (inherits(cond, "condition")) {
[11:00:04.415]                       if (!is.null(pattern)) {
[11:00:04.415]                         computeRestarts <- base::computeRestarts
[11:00:04.415]                         grepl <- base::grepl
[11:00:04.415]                         restarts <- computeRestarts(cond)
[11:00:04.415]                         for (restart in restarts) {
[11:00:04.415]                           name <- restart$name
[11:00:04.415]                           if (is.null(name)) 
[11:00:04.415]                             next
[11:00:04.415]                           if (!grepl(pattern, name)) 
[11:00:04.415]                             next
[11:00:04.415]                           invokeRestart(restart)
[11:00:04.415]                           muffled <- TRUE
[11:00:04.415]                           break
[11:00:04.415]                         }
[11:00:04.415]                       }
[11:00:04.415]                     }
[11:00:04.415]                     invisible(muffled)
[11:00:04.415]                   }
[11:00:04.415]                   muffleCondition(cond)
[11:00:04.415]                 })
[11:00:04.415]             }))
[11:00:04.415]             future::FutureResult(value = ...future.value$value, 
[11:00:04.415]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:04.415]                   ...future.rng), globalenv = if (FALSE) 
[11:00:04.415]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:04.415]                     ...future.globalenv.names))
[11:00:04.415]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:04.415]         }, condition = base::local({
[11:00:04.415]             c <- base::c
[11:00:04.415]             inherits <- base::inherits
[11:00:04.415]             invokeRestart <- base::invokeRestart
[11:00:04.415]             length <- base::length
[11:00:04.415]             list <- base::list
[11:00:04.415]             seq.int <- base::seq.int
[11:00:04.415]             signalCondition <- base::signalCondition
[11:00:04.415]             sys.calls <- base::sys.calls
[11:00:04.415]             `[[` <- base::`[[`
[11:00:04.415]             `+` <- base::`+`
[11:00:04.415]             `<<-` <- base::`<<-`
[11:00:04.415]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:04.415]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:04.415]                   3L)]
[11:00:04.415]             }
[11:00:04.415]             function(cond) {
[11:00:04.415]                 is_error <- inherits(cond, "error")
[11:00:04.415]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:04.415]                   NULL)
[11:00:04.415]                 if (is_error) {
[11:00:04.415]                   sessionInformation <- function() {
[11:00:04.415]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:04.415]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:04.415]                       search = base::search(), system = base::Sys.info())
[11:00:04.415]                   }
[11:00:04.415]                   ...future.conditions[[length(...future.conditions) + 
[11:00:04.415]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:04.415]                     cond$call), session = sessionInformation(), 
[11:00:04.415]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:04.415]                   signalCondition(cond)
[11:00:04.415]                 }
[11:00:04.415]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:04.415]                 "immediateCondition"))) {
[11:00:04.415]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:04.415]                   ...future.conditions[[length(...future.conditions) + 
[11:00:04.415]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:04.415]                   if (TRUE && !signal) {
[11:00:04.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:04.415]                     {
[11:00:04.415]                       inherits <- base::inherits
[11:00:04.415]                       invokeRestart <- base::invokeRestart
[11:00:04.415]                       is.null <- base::is.null
[11:00:04.415]                       muffled <- FALSE
[11:00:04.415]                       if (inherits(cond, "message")) {
[11:00:04.415]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:04.415]                         if (muffled) 
[11:00:04.415]                           invokeRestart("muffleMessage")
[11:00:04.415]                       }
[11:00:04.415]                       else if (inherits(cond, "warning")) {
[11:00:04.415]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:04.415]                         if (muffled) 
[11:00:04.415]                           invokeRestart("muffleWarning")
[11:00:04.415]                       }
[11:00:04.415]                       else if (inherits(cond, "condition")) {
[11:00:04.415]                         if (!is.null(pattern)) {
[11:00:04.415]                           computeRestarts <- base::computeRestarts
[11:00:04.415]                           grepl <- base::grepl
[11:00:04.415]                           restarts <- computeRestarts(cond)
[11:00:04.415]                           for (restart in restarts) {
[11:00:04.415]                             name <- restart$name
[11:00:04.415]                             if (is.null(name)) 
[11:00:04.415]                               next
[11:00:04.415]                             if (!grepl(pattern, name)) 
[11:00:04.415]                               next
[11:00:04.415]                             invokeRestart(restart)
[11:00:04.415]                             muffled <- TRUE
[11:00:04.415]                             break
[11:00:04.415]                           }
[11:00:04.415]                         }
[11:00:04.415]                       }
[11:00:04.415]                       invisible(muffled)
[11:00:04.415]                     }
[11:00:04.415]                     muffleCondition(cond, pattern = "^muffle")
[11:00:04.415]                   }
[11:00:04.415]                 }
[11:00:04.415]                 else {
[11:00:04.415]                   if (TRUE) {
[11:00:04.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:04.415]                     {
[11:00:04.415]                       inherits <- base::inherits
[11:00:04.415]                       invokeRestart <- base::invokeRestart
[11:00:04.415]                       is.null <- base::is.null
[11:00:04.415]                       muffled <- FALSE
[11:00:04.415]                       if (inherits(cond, "message")) {
[11:00:04.415]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:04.415]                         if (muffled) 
[11:00:04.415]                           invokeRestart("muffleMessage")
[11:00:04.415]                       }
[11:00:04.415]                       else if (inherits(cond, "warning")) {
[11:00:04.415]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:04.415]                         if (muffled) 
[11:00:04.415]                           invokeRestart("muffleWarning")
[11:00:04.415]                       }
[11:00:04.415]                       else if (inherits(cond, "condition")) {
[11:00:04.415]                         if (!is.null(pattern)) {
[11:00:04.415]                           computeRestarts <- base::computeRestarts
[11:00:04.415]                           grepl <- base::grepl
[11:00:04.415]                           restarts <- computeRestarts(cond)
[11:00:04.415]                           for (restart in restarts) {
[11:00:04.415]                             name <- restart$name
[11:00:04.415]                             if (is.null(name)) 
[11:00:04.415]                               next
[11:00:04.415]                             if (!grepl(pattern, name)) 
[11:00:04.415]                               next
[11:00:04.415]                             invokeRestart(restart)
[11:00:04.415]                             muffled <- TRUE
[11:00:04.415]                             break
[11:00:04.415]                           }
[11:00:04.415]                         }
[11:00:04.415]                       }
[11:00:04.415]                       invisible(muffled)
[11:00:04.415]                     }
[11:00:04.415]                     muffleCondition(cond, pattern = "^muffle")
[11:00:04.415]                   }
[11:00:04.415]                 }
[11:00:04.415]             }
[11:00:04.415]         }))
[11:00:04.415]     }, error = function(ex) {
[11:00:04.415]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:04.415]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:04.415]                 ...future.rng), started = ...future.startTime, 
[11:00:04.415]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:04.415]             version = "1.8"), class = "FutureResult")
[11:00:04.415]     }, finally = {
[11:00:04.415]         if (!identical(...future.workdir, getwd())) 
[11:00:04.415]             setwd(...future.workdir)
[11:00:04.415]         {
[11:00:04.415]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:04.415]                 ...future.oldOptions$nwarnings <- NULL
[11:00:04.415]             }
[11:00:04.415]             base::options(...future.oldOptions)
[11:00:04.415]             if (.Platform$OS.type == "windows") {
[11:00:04.415]                 old_names <- names(...future.oldEnvVars)
[11:00:04.415]                 envs <- base::Sys.getenv()
[11:00:04.415]                 names <- names(envs)
[11:00:04.415]                 common <- intersect(names, old_names)
[11:00:04.415]                 added <- setdiff(names, old_names)
[11:00:04.415]                 removed <- setdiff(old_names, names)
[11:00:04.415]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:04.415]                   envs[common]]
[11:00:04.415]                 NAMES <- toupper(changed)
[11:00:04.415]                 args <- list()
[11:00:04.415]                 for (kk in seq_along(NAMES)) {
[11:00:04.415]                   name <- changed[[kk]]
[11:00:04.415]                   NAME <- NAMES[[kk]]
[11:00:04.415]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:04.415]                     next
[11:00:04.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:04.415]                 }
[11:00:04.415]                 NAMES <- toupper(added)
[11:00:04.415]                 for (kk in seq_along(NAMES)) {
[11:00:04.415]                   name <- added[[kk]]
[11:00:04.415]                   NAME <- NAMES[[kk]]
[11:00:04.415]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:04.415]                     next
[11:00:04.415]                   args[[name]] <- ""
[11:00:04.415]                 }
[11:00:04.415]                 NAMES <- toupper(removed)
[11:00:04.415]                 for (kk in seq_along(NAMES)) {
[11:00:04.415]                   name <- removed[[kk]]
[11:00:04.415]                   NAME <- NAMES[[kk]]
[11:00:04.415]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:04.415]                     next
[11:00:04.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:04.415]                 }
[11:00:04.415]                 if (length(args) > 0) 
[11:00:04.415]                   base::do.call(base::Sys.setenv, args = args)
[11:00:04.415]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:04.415]             }
[11:00:04.415]             else {
[11:00:04.415]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:04.415]             }
[11:00:04.415]             {
[11:00:04.415]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:04.415]                   0L) {
[11:00:04.415]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:04.415]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:04.415]                   base::options(opts)
[11:00:04.415]                 }
[11:00:04.415]                 {
[11:00:04.415]                   {
[11:00:04.415]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:04.415]                     NULL
[11:00:04.415]                   }
[11:00:04.415]                   options(future.plan = NULL)
[11:00:04.415]                   if (is.na(NA_character_)) 
[11:00:04.415]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:04.415]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:04.415]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:04.415]                     .init = FALSE)
[11:00:04.415]                 }
[11:00:04.415]             }
[11:00:04.415]         }
[11:00:04.415]     })
[11:00:04.415]     if (TRUE) {
[11:00:04.415]         base::sink(type = "output", split = FALSE)
[11:00:04.415]         if (TRUE) {
[11:00:04.415]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:04.415]         }
[11:00:04.415]         else {
[11:00:04.415]             ...future.result["stdout"] <- base::list(NULL)
[11:00:04.415]         }
[11:00:04.415]         base::close(...future.stdout)
[11:00:04.415]         ...future.stdout <- NULL
[11:00:04.415]     }
[11:00:04.415]     ...future.result$conditions <- ...future.conditions
[11:00:04.415]     ...future.result$finished <- base::Sys.time()
[11:00:04.415]     ...future.result
[11:00:04.415] }
[11:00:04.417] Exporting 11 global objects (13.20 KiB) to cluster node #1 ...
[11:00:04.418] Exporting ‘...future.FUN’ (4.49 KiB) to cluster node #1 ...
[11:00:04.459] Exporting ‘...future.FUN’ (4.49 KiB) to cluster node #1 ... DONE
[11:00:04.459] Exporting ‘x_FUN’ (296 bytes) to cluster node #1 ...
[11:00:04.459] Exporting ‘x_FUN’ (296 bytes) to cluster node #1 ... DONE
[11:00:04.459] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[11:00:04.460] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[11:00:04.462] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[11:00:04.503] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[11:00:04.503] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[11:00:04.544] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[11:00:04.544] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[11:00:04.544] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[11:00:04.544] Exporting ‘valid_types’ (61 bytes) to cluster node #1 ...
[11:00:04.545] Exporting ‘valid_types’ (61 bytes) to cluster node #1 ... DONE
[11:00:04.545] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[11:00:04.545] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[11:00:04.545] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ...
[11:00:04.546] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ... DONE
[11:00:04.546] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[11:00:04.546] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[11:00:04.546] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[11:00:04.547] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[11:00:04.547] Exporting 11 global objects (13.20 KiB) to cluster node #1 ... DONE
[11:00:04.547] MultisessionFuture started
[11:00:04.547] - Launch lazy future ... done
[11:00:04.548] run() for ‘MultisessionFuture’ ... done
[11:00:04.548] Created future:
[11:00:04.548] MultisessionFuture:
[11:00:04.548] Label: ‘future_vapply-1’
[11:00:04.548] Expression:
[11:00:04.548] {
[11:00:04.548]     do.call(function(...) {
[11:00:04.548]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:04.548]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:04.548]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:04.548]             on.exit(options(oopts), add = TRUE)
[11:00:04.548]         }
[11:00:04.548]         {
[11:00:04.548]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:04.548]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:04.548]                 ...future.FUN(...future.X_jj, ...)
[11:00:04.548]             })
[11:00:04.548]         }
[11:00:04.548]     }, args = future.call.arguments)
[11:00:04.548] }
[11:00:04.548] Lazy evaluation: FALSE
[11:00:04.548] Asynchronous evaluation: TRUE
[11:00:04.548] Local evaluation: TRUE
[11:00:04.548] Environment: R_GlobalEnv
[11:00:04.548] Capture standard output: TRUE
[11:00:04.548] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:04.548] Globals: 11 objects totaling 12.98 KiB (function ‘...future.FUN’ of 4.49 KiB, function ‘x_FUN’ of 296 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:04.548] Packages: 1 packages (‘future.apply’)
[11:00:04.548] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:04.548] Resolved: FALSE
[11:00:04.548] Value: <not collected>
[11:00:04.548] Conditions captured: <none>
[11:00:04.548] Early signaling: FALSE
[11:00:04.548] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:04.548] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:04.559] Chunk #1 of 2 ... DONE
[11:00:04.559] Chunk #2 of 2 ...
[11:00:04.559]  - Finding globals in 'X' for chunk #2 ...
[11:00:04.560] getGlobalsAndPackages() ...
[11:00:04.560] Searching for globals...
[11:00:04.560] 
[11:00:04.560] Searching for globals ... DONE
[11:00:04.560] - globals: [0] <none>
[11:00:04.560] getGlobalsAndPackages() ... DONE
[11:00:04.560]    + additional globals found: [n=0] 
[11:00:04.560]    + additional namespaces needed: [n=0] 
[11:00:04.560]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:04.560]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:04.561]  - seeds: <none>
[11:00:04.561]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:04.561] getGlobalsAndPackages() ...
[11:00:04.561] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:04.561] Resolving globals: FALSE
[11:00:04.561] Tweak future expression to call with '...' arguments ...
[11:00:04.561] {
[11:00:04.561]     do.call(function(...) {
[11:00:04.561]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:04.561]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:04.561]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:04.561]             on.exit(options(oopts), add = TRUE)
[11:00:04.561]         }
[11:00:04.561]         {
[11:00:04.561]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:04.561]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:04.561]                 ...future.FUN(...future.X_jj, ...)
[11:00:04.561]             })
[11:00:04.561]         }
[11:00:04.561]     }, args = future.call.arguments)
[11:00:04.561] }
[11:00:04.561] Tweak future expression to call with '...' arguments ... DONE
[11:00:04.562] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:04.562] - packages: [1] ‘future.apply’
[11:00:04.562] getGlobalsAndPackages() ... DONE
[11:00:04.562] run() for ‘Future’ ...
[11:00:04.562] - state: ‘created’
[11:00:04.563] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:04.576] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:04.576] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:04.577]   - Field: ‘node’
[11:00:04.577]   - Field: ‘label’
[11:00:04.577]   - Field: ‘local’
[11:00:04.577]   - Field: ‘owner’
[11:00:04.577]   - Field: ‘envir’
[11:00:04.577]   - Field: ‘workers’
[11:00:04.577]   - Field: ‘packages’
[11:00:04.577]   - Field: ‘gc’
[11:00:04.577]   - Field: ‘conditions’
[11:00:04.577]   - Field: ‘persistent’
[11:00:04.577]   - Field: ‘expr’
[11:00:04.577]   - Field: ‘uuid’
[11:00:04.578]   - Field: ‘seed’
[11:00:04.578]   - Field: ‘version’
[11:00:04.578]   - Field: ‘result’
[11:00:04.578]   - Field: ‘asynchronous’
[11:00:04.578]   - Field: ‘calls’
[11:00:04.578]   - Field: ‘globals’
[11:00:04.578]   - Field: ‘stdout’
[11:00:04.578]   - Field: ‘earlySignal’
[11:00:04.578]   - Field: ‘lazy’
[11:00:04.578]   - Field: ‘state’
[11:00:04.578] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:04.579] - Launch lazy future ...
[11:00:04.579] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:04.579] Packages needed by future strategies (n = 0): <none>
[11:00:04.579] {
[11:00:04.579]     {
[11:00:04.579]         {
[11:00:04.579]             ...future.startTime <- base::Sys.time()
[11:00:04.579]             {
[11:00:04.579]                 {
[11:00:04.579]                   {
[11:00:04.579]                     {
[11:00:04.579]                       {
[11:00:04.579]                         base::local({
[11:00:04.579]                           has_future <- base::requireNamespace("future", 
[11:00:04.579]                             quietly = TRUE)
[11:00:04.579]                           if (has_future) {
[11:00:04.579]                             ns <- base::getNamespace("future")
[11:00:04.579]                             version <- ns[[".package"]][["version"]]
[11:00:04.579]                             if (is.null(version)) 
[11:00:04.579]                               version <- utils::packageVersion("future")
[11:00:04.579]                           }
[11:00:04.579]                           else {
[11:00:04.579]                             version <- NULL
[11:00:04.579]                           }
[11:00:04.579]                           if (!has_future || version < "1.8.0") {
[11:00:04.579]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:04.579]                               "", base::R.version$version.string), 
[11:00:04.579]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:04.579]                                 base::R.version$platform, 8 * 
[11:00:04.579]                                   base::.Machine$sizeof.pointer), 
[11:00:04.579]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:04.579]                                 "release", "version")], collapse = " "), 
[11:00:04.579]                               hostname = base::Sys.info()[["nodename"]])
[11:00:04.579]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:04.579]                               info)
[11:00:04.579]                             info <- base::paste(info, collapse = "; ")
[11:00:04.579]                             if (!has_future) {
[11:00:04.579]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:04.579]                                 info)
[11:00:04.579]                             }
[11:00:04.579]                             else {
[11:00:04.579]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:04.579]                                 info, version)
[11:00:04.579]                             }
[11:00:04.579]                             base::stop(msg)
[11:00:04.579]                           }
[11:00:04.579]                         })
[11:00:04.579]                       }
[11:00:04.579]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:04.579]                       base::options(mc.cores = 1L)
[11:00:04.579]                     }
[11:00:04.579]                     base::local({
[11:00:04.579]                       for (pkg in "future.apply") {
[11:00:04.579]                         base::loadNamespace(pkg)
[11:00:04.579]                         base::library(pkg, character.only = TRUE)
[11:00:04.579]                       }
[11:00:04.579]                     })
[11:00:04.579]                   }
[11:00:04.579]                   ...future.strategy.old <- future::plan("list")
[11:00:04.579]                   options(future.plan = NULL)
[11:00:04.579]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:04.579]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:04.579]                 }
[11:00:04.579]                 ...future.workdir <- getwd()
[11:00:04.579]             }
[11:00:04.579]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:04.579]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:04.579]         }
[11:00:04.579]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:04.579]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:04.579]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:04.579]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:04.579]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:04.579]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:04.579]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:04.579]             base::names(...future.oldOptions))
[11:00:04.579]     }
[11:00:04.579]     if (FALSE) {
[11:00:04.579]     }
[11:00:04.579]     else {
[11:00:04.579]         if (TRUE) {
[11:00:04.579]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:04.579]                 open = "w")
[11:00:04.579]         }
[11:00:04.579]         else {
[11:00:04.579]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:04.579]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:04.579]         }
[11:00:04.579]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:04.579]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:04.579]             base::sink(type = "output", split = FALSE)
[11:00:04.579]             base::close(...future.stdout)
[11:00:04.579]         }, add = TRUE)
[11:00:04.579]     }
[11:00:04.579]     ...future.frame <- base::sys.nframe()
[11:00:04.579]     ...future.conditions <- base::list()
[11:00:04.579]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:04.579]     if (FALSE) {
[11:00:04.579]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:04.579]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:04.579]     }
[11:00:04.579]     ...future.result <- base::tryCatch({
[11:00:04.579]         base::withCallingHandlers({
[11:00:04.579]             ...future.value <- base::withVisible(base::local({
[11:00:04.579]                 ...future.makeSendCondition <- base::local({
[11:00:04.579]                   sendCondition <- NULL
[11:00:04.579]                   function(frame = 1L) {
[11:00:04.579]                     if (is.function(sendCondition)) 
[11:00:04.579]                       return(sendCondition)
[11:00:04.579]                     ns <- getNamespace("parallel")
[11:00:04.579]                     if (exists("sendData", mode = "function", 
[11:00:04.579]                       envir = ns)) {
[11:00:04.579]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:04.579]                         envir = ns)
[11:00:04.579]                       envir <- sys.frame(frame)
[11:00:04.579]                       master <- NULL
[11:00:04.579]                       while (!identical(envir, .GlobalEnv) && 
[11:00:04.579]                         !identical(envir, emptyenv())) {
[11:00:04.579]                         if (exists("master", mode = "list", envir = envir, 
[11:00:04.579]                           inherits = FALSE)) {
[11:00:04.579]                           master <- get("master", mode = "list", 
[11:00:04.579]                             envir = envir, inherits = FALSE)
[11:00:04.579]                           if (inherits(master, c("SOCKnode", 
[11:00:04.579]                             "SOCK0node"))) {
[11:00:04.579]                             sendCondition <<- function(cond) {
[11:00:04.579]                               data <- list(type = "VALUE", value = cond, 
[11:00:04.579]                                 success = TRUE)
[11:00:04.579]                               parallel_sendData(master, data)
[11:00:04.579]                             }
[11:00:04.579]                             return(sendCondition)
[11:00:04.579]                           }
[11:00:04.579]                         }
[11:00:04.579]                         frame <- frame + 1L
[11:00:04.579]                         envir <- sys.frame(frame)
[11:00:04.579]                       }
[11:00:04.579]                     }
[11:00:04.579]                     sendCondition <<- function(cond) NULL
[11:00:04.579]                   }
[11:00:04.579]                 })
[11:00:04.579]                 withCallingHandlers({
[11:00:04.579]                   {
[11:00:04.579]                     do.call(function(...) {
[11:00:04.579]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:04.579]                       if (!identical(...future.globals.maxSize.org, 
[11:00:04.579]                         ...future.globals.maxSize)) {
[11:00:04.579]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:04.579]                         on.exit(options(oopts), add = TRUE)
[11:00:04.579]                       }
[11:00:04.579]                       {
[11:00:04.579]                         lapply(seq_along(...future.elements_ii), 
[11:00:04.579]                           FUN = function(jj) {
[11:00:04.579]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:04.579]                             ...future.FUN(...future.X_jj, ...)
[11:00:04.579]                           })
[11:00:04.579]                       }
[11:00:04.579]                     }, args = future.call.arguments)
[11:00:04.579]                   }
[11:00:04.579]                 }, immediateCondition = function(cond) {
[11:00:04.579]                   sendCondition <- ...future.makeSendCondition()
[11:00:04.579]                   sendCondition(cond)
[11:00:04.579]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:04.579]                   {
[11:00:04.579]                     inherits <- base::inherits
[11:00:04.579]                     invokeRestart <- base::invokeRestart
[11:00:04.579]                     is.null <- base::is.null
[11:00:04.579]                     muffled <- FALSE
[11:00:04.579]                     if (inherits(cond, "message")) {
[11:00:04.579]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:04.579]                       if (muffled) 
[11:00:04.579]                         invokeRestart("muffleMessage")
[11:00:04.579]                     }
[11:00:04.579]                     else if (inherits(cond, "warning")) {
[11:00:04.579]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:04.579]                       if (muffled) 
[11:00:04.579]                         invokeRestart("muffleWarning")
[11:00:04.579]                     }
[11:00:04.579]                     else if (inherits(cond, "condition")) {
[11:00:04.579]                       if (!is.null(pattern)) {
[11:00:04.579]                         computeRestarts <- base::computeRestarts
[11:00:04.579]                         grepl <- base::grepl
[11:00:04.579]                         restarts <- computeRestarts(cond)
[11:00:04.579]                         for (restart in restarts) {
[11:00:04.579]                           name <- restart$name
[11:00:04.579]                           if (is.null(name)) 
[11:00:04.579]                             next
[11:00:04.579]                           if (!grepl(pattern, name)) 
[11:00:04.579]                             next
[11:00:04.579]                           invokeRestart(restart)
[11:00:04.579]                           muffled <- TRUE
[11:00:04.579]                           break
[11:00:04.579]                         }
[11:00:04.579]                       }
[11:00:04.579]                     }
[11:00:04.579]                     invisible(muffled)
[11:00:04.579]                   }
[11:00:04.579]                   muffleCondition(cond)
[11:00:04.579]                 })
[11:00:04.579]             }))
[11:00:04.579]             future::FutureResult(value = ...future.value$value, 
[11:00:04.579]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:04.579]                   ...future.rng), globalenv = if (FALSE) 
[11:00:04.579]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:04.579]                     ...future.globalenv.names))
[11:00:04.579]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:04.579]         }, condition = base::local({
[11:00:04.579]             c <- base::c
[11:00:04.579]             inherits <- base::inherits
[11:00:04.579]             invokeRestart <- base::invokeRestart
[11:00:04.579]             length <- base::length
[11:00:04.579]             list <- base::list
[11:00:04.579]             seq.int <- base::seq.int
[11:00:04.579]             signalCondition <- base::signalCondition
[11:00:04.579]             sys.calls <- base::sys.calls
[11:00:04.579]             `[[` <- base::`[[`
[11:00:04.579]             `+` <- base::`+`
[11:00:04.579]             `<<-` <- base::`<<-`
[11:00:04.579]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:04.579]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:04.579]                   3L)]
[11:00:04.579]             }
[11:00:04.579]             function(cond) {
[11:00:04.579]                 is_error <- inherits(cond, "error")
[11:00:04.579]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:04.579]                   NULL)
[11:00:04.579]                 if (is_error) {
[11:00:04.579]                   sessionInformation <- function() {
[11:00:04.579]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:04.579]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:04.579]                       search = base::search(), system = base::Sys.info())
[11:00:04.579]                   }
[11:00:04.579]                   ...future.conditions[[length(...future.conditions) + 
[11:00:04.579]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:04.579]                     cond$call), session = sessionInformation(), 
[11:00:04.579]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:04.579]                   signalCondition(cond)
[11:00:04.579]                 }
[11:00:04.579]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:04.579]                 "immediateCondition"))) {
[11:00:04.579]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:04.579]                   ...future.conditions[[length(...future.conditions) + 
[11:00:04.579]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:04.579]                   if (TRUE && !signal) {
[11:00:04.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:04.579]                     {
[11:00:04.579]                       inherits <- base::inherits
[11:00:04.579]                       invokeRestart <- base::invokeRestart
[11:00:04.579]                       is.null <- base::is.null
[11:00:04.579]                       muffled <- FALSE
[11:00:04.579]                       if (inherits(cond, "message")) {
[11:00:04.579]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:04.579]                         if (muffled) 
[11:00:04.579]                           invokeRestart("muffleMessage")
[11:00:04.579]                       }
[11:00:04.579]                       else if (inherits(cond, "warning")) {
[11:00:04.579]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:04.579]                         if (muffled) 
[11:00:04.579]                           invokeRestart("muffleWarning")
[11:00:04.579]                       }
[11:00:04.579]                       else if (inherits(cond, "condition")) {
[11:00:04.579]                         if (!is.null(pattern)) {
[11:00:04.579]                           computeRestarts <- base::computeRestarts
[11:00:04.579]                           grepl <- base::grepl
[11:00:04.579]                           restarts <- computeRestarts(cond)
[11:00:04.579]                           for (restart in restarts) {
[11:00:04.579]                             name <- restart$name
[11:00:04.579]                             if (is.null(name)) 
[11:00:04.579]                               next
[11:00:04.579]                             if (!grepl(pattern, name)) 
[11:00:04.579]                               next
[11:00:04.579]                             invokeRestart(restart)
[11:00:04.579]                             muffled <- TRUE
[11:00:04.579]                             break
[11:00:04.579]                           }
[11:00:04.579]                         }
[11:00:04.579]                       }
[11:00:04.579]                       invisible(muffled)
[11:00:04.579]                     }
[11:00:04.579]                     muffleCondition(cond, pattern = "^muffle")
[11:00:04.579]                   }
[11:00:04.579]                 }
[11:00:04.579]                 else {
[11:00:04.579]                   if (TRUE) {
[11:00:04.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:04.579]                     {
[11:00:04.579]                       inherits <- base::inherits
[11:00:04.579]                       invokeRestart <- base::invokeRestart
[11:00:04.579]                       is.null <- base::is.null
[11:00:04.579]                       muffled <- FALSE
[11:00:04.579]                       if (inherits(cond, "message")) {
[11:00:04.579]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:04.579]                         if (muffled) 
[11:00:04.579]                           invokeRestart("muffleMessage")
[11:00:04.579]                       }
[11:00:04.579]                       else if (inherits(cond, "warning")) {
[11:00:04.579]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:04.579]                         if (muffled) 
[11:00:04.579]                           invokeRestart("muffleWarning")
[11:00:04.579]                       }
[11:00:04.579]                       else if (inherits(cond, "condition")) {
[11:00:04.579]                         if (!is.null(pattern)) {
[11:00:04.579]                           computeRestarts <- base::computeRestarts
[11:00:04.579]                           grepl <- base::grepl
[11:00:04.579]                           restarts <- computeRestarts(cond)
[11:00:04.579]                           for (restart in restarts) {
[11:00:04.579]                             name <- restart$name
[11:00:04.579]                             if (is.null(name)) 
[11:00:04.579]                               next
[11:00:04.579]                             if (!grepl(pattern, name)) 
[11:00:04.579]                               next
[11:00:04.579]                             invokeRestart(restart)
[11:00:04.579]                             muffled <- TRUE
[11:00:04.579]                             break
[11:00:04.579]                           }
[11:00:04.579]                         }
[11:00:04.579]                       }
[11:00:04.579]                       invisible(muffled)
[11:00:04.579]                     }
[11:00:04.579]                     muffleCondition(cond, pattern = "^muffle")
[11:00:04.579]                   }
[11:00:04.579]                 }
[11:00:04.579]             }
[11:00:04.579]         }))
[11:00:04.579]     }, error = function(ex) {
[11:00:04.579]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:04.579]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:04.579]                 ...future.rng), started = ...future.startTime, 
[11:00:04.579]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:04.579]             version = "1.8"), class = "FutureResult")
[11:00:04.579]     }, finally = {
[11:00:04.579]         if (!identical(...future.workdir, getwd())) 
[11:00:04.579]             setwd(...future.workdir)
[11:00:04.579]         {
[11:00:04.579]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:04.579]                 ...future.oldOptions$nwarnings <- NULL
[11:00:04.579]             }
[11:00:04.579]             base::options(...future.oldOptions)
[11:00:04.579]             if (.Platform$OS.type == "windows") {
[11:00:04.579]                 old_names <- names(...future.oldEnvVars)
[11:00:04.579]                 envs <- base::Sys.getenv()
[11:00:04.579]                 names <- names(envs)
[11:00:04.579]                 common <- intersect(names, old_names)
[11:00:04.579]                 added <- setdiff(names, old_names)
[11:00:04.579]                 removed <- setdiff(old_names, names)
[11:00:04.579]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:04.579]                   envs[common]]
[11:00:04.579]                 NAMES <- toupper(changed)
[11:00:04.579]                 args <- list()
[11:00:04.579]                 for (kk in seq_along(NAMES)) {
[11:00:04.579]                   name <- changed[[kk]]
[11:00:04.579]                   NAME <- NAMES[[kk]]
[11:00:04.579]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:04.579]                     next
[11:00:04.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:04.579]                 }
[11:00:04.579]                 NAMES <- toupper(added)
[11:00:04.579]                 for (kk in seq_along(NAMES)) {
[11:00:04.579]                   name <- added[[kk]]
[11:00:04.579]                   NAME <- NAMES[[kk]]
[11:00:04.579]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:04.579]                     next
[11:00:04.579]                   args[[name]] <- ""
[11:00:04.579]                 }
[11:00:04.579]                 NAMES <- toupper(removed)
[11:00:04.579]                 for (kk in seq_along(NAMES)) {
[11:00:04.579]                   name <- removed[[kk]]
[11:00:04.579]                   NAME <- NAMES[[kk]]
[11:00:04.579]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:04.579]                     next
[11:00:04.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:04.579]                 }
[11:00:04.579]                 if (length(args) > 0) 
[11:00:04.579]                   base::do.call(base::Sys.setenv, args = args)
[11:00:04.579]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:04.579]             }
[11:00:04.579]             else {
[11:00:04.579]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:04.579]             }
[11:00:04.579]             {
[11:00:04.579]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:04.579]                   0L) {
[11:00:04.579]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:04.579]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:04.579]                   base::options(opts)
[11:00:04.579]                 }
[11:00:04.579]                 {
[11:00:04.579]                   {
[11:00:04.579]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:04.579]                     NULL
[11:00:04.579]                   }
[11:00:04.579]                   options(future.plan = NULL)
[11:00:04.579]                   if (is.na(NA_character_)) 
[11:00:04.579]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:04.579]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:04.579]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:04.579]                     .init = FALSE)
[11:00:04.579]                 }
[11:00:04.579]             }
[11:00:04.579]         }
[11:00:04.579]     })
[11:00:04.579]     if (TRUE) {
[11:00:04.579]         base::sink(type = "output", split = FALSE)
[11:00:04.579]         if (TRUE) {
[11:00:04.579]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:04.579]         }
[11:00:04.579]         else {
[11:00:04.579]             ...future.result["stdout"] <- base::list(NULL)
[11:00:04.579]         }
[11:00:04.579]         base::close(...future.stdout)
[11:00:04.579]         ...future.stdout <- NULL
[11:00:04.579]     }
[11:00:04.579]     ...future.result$conditions <- ...future.conditions
[11:00:04.579]     ...future.result$finished <- base::Sys.time()
[11:00:04.579]     ...future.result
[11:00:04.579] }
[11:00:04.582] Exporting 11 global objects (13.20 KiB) to cluster node #2 ...
[11:00:04.582] Exporting ‘...future.FUN’ (4.49 KiB) to cluster node #2 ...
[11:00:04.624] Exporting ‘...future.FUN’ (4.49 KiB) to cluster node #2 ... DONE
[11:00:04.624] Exporting ‘x_FUN’ (296 bytes) to cluster node #2 ...
[11:00:04.624] Exporting ‘x_FUN’ (296 bytes) to cluster node #2 ... DONE
[11:00:04.624] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[11:00:04.625] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[11:00:04.625] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[11:00:04.666] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[11:00:04.666] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[11:00:04.707] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[11:00:04.707] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[11:00:04.707] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[11:00:04.707] Exporting ‘valid_types’ (61 bytes) to cluster node #2 ...
[11:00:04.708] Exporting ‘valid_types’ (61 bytes) to cluster node #2 ... DONE
[11:00:04.708] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[11:00:04.708] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[11:00:04.708] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ...
[11:00:04.709] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ... DONE
[11:00:04.709] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[11:00:04.709] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[11:00:04.709] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[11:00:04.710] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[11:00:04.710] Exporting 11 global objects (13.20 KiB) to cluster node #2 ... DONE
[11:00:04.710] MultisessionFuture started
[11:00:04.710] - Launch lazy future ... done
[11:00:04.710] run() for ‘MultisessionFuture’ ... done
[11:00:04.711] Created future:
[11:00:04.711] MultisessionFuture:
[11:00:04.711] Label: ‘future_vapply-2’
[11:00:04.711] Expression:
[11:00:04.711] {
[11:00:04.711]     do.call(function(...) {
[11:00:04.711]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:04.711]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:04.711]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:04.711]             on.exit(options(oopts), add = TRUE)
[11:00:04.711]         }
[11:00:04.711]         {
[11:00:04.711]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:04.711]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:04.711]                 ...future.FUN(...future.X_jj, ...)
[11:00:04.711]             })
[11:00:04.711]         }
[11:00:04.711]     }, args = future.call.arguments)
[11:00:04.711] }
[11:00:04.711] Lazy evaluation: FALSE
[11:00:04.711] Asynchronous evaluation: TRUE
[11:00:04.711] Local evaluation: TRUE
[11:00:04.711] Environment: R_GlobalEnv
[11:00:04.711] Capture standard output: TRUE
[11:00:04.711] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:04.711] Globals: 11 objects totaling 12.98 KiB (function ‘...future.FUN’ of 4.49 KiB, function ‘x_FUN’ of 296 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:04.711] Packages: 1 packages (‘future.apply’)
[11:00:04.711] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:04.711] Resolved: FALSE
[11:00:04.711] Value: <not collected>
[11:00:04.711] Conditions captured: <none>
[11:00:04.711] Early signaling: FALSE
[11:00:04.711] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:04.711] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:04.722] Chunk #2 of 2 ... DONE
[11:00:04.722] Launching 2 futures (chunks) ... DONE
[11:00:04.722] Resolving 2 futures (chunks) ...
[11:00:04.722] resolve() on list ...
[11:00:04.723]  recursive: 0
[11:00:04.723]  length: 2
[11:00:04.723] 
[11:00:04.723] receiveMessageFromWorker() for ClusterFuture ...
[11:00:04.723] - Validating connection of MultisessionFuture
[11:00:04.723] - received message: FutureResult
[11:00:04.724] - Received FutureResult
[11:00:04.724] - Erased future from FutureRegistry
[11:00:04.724] result() for ClusterFuture ...
[11:00:04.724] - result already collected: FutureResult
[11:00:04.724] result() for ClusterFuture ... done
[11:00:04.724] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:04.724] Future #1
[11:00:04.724] result() for ClusterFuture ...
[11:00:04.724] - result already collected: FutureResult
[11:00:04.724] result() for ClusterFuture ... done
[11:00:04.724] result() for ClusterFuture ...
[11:00:04.725] - result already collected: FutureResult
[11:00:04.725] result() for ClusterFuture ... done
[11:00:04.725] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:00:04.725] - nx: 2
[11:00:04.725] - relay: TRUE
[11:00:04.725] - stdout: TRUE
[11:00:04.725] - signal: TRUE
[11:00:04.725] - resignal: FALSE
[11:00:04.725] - force: TRUE
[11:00:04.725] - relayed: [n=2] FALSE, FALSE
[11:00:04.725] - queued futures: [n=2] FALSE, FALSE
[11:00:04.725]  - until=1
[11:00:04.725]  - relaying element #1
[11:00:04.726] result() for ClusterFuture ...
[11:00:04.726] - result already collected: FutureResult
[11:00:04.726] result() for ClusterFuture ... done
[11:00:04.726] result() for ClusterFuture ...
[11:00:04.726] - result already collected: FutureResult
[11:00:04.726] result() for ClusterFuture ... done
[11:00:04.726] result() for ClusterFuture ...
[11:00:04.726] - result already collected: FutureResult
[11:00:04.726] result() for ClusterFuture ... done
[11:00:04.726] result() for ClusterFuture ...
[11:00:04.726] - result already collected: FutureResult
[11:00:04.726] result() for ClusterFuture ... done
[11:00:04.727] - relayed: [n=2] TRUE, FALSE
[11:00:04.727] - queued futures: [n=2] TRUE, FALSE
[11:00:04.727] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:00:04.727]  length: 1 (resolved future 1)
[11:00:04.752] receiveMessageFromWorker() for ClusterFuture ...
[11:00:04.752] - Validating connection of MultisessionFuture
[11:00:04.753] - received message: FutureResult
[11:00:04.753] - Received FutureResult
[11:00:04.753] - Erased future from FutureRegistry
[11:00:04.753] result() for ClusterFuture ...
[11:00:04.753] - result already collected: FutureResult
[11:00:04.753] result() for ClusterFuture ... done
[11:00:04.753] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:04.753] Future #2
[11:00:04.753] result() for ClusterFuture ...
[11:00:04.753] - result already collected: FutureResult
[11:00:04.753] result() for ClusterFuture ... done
[11:00:04.754] result() for ClusterFuture ...
[11:00:04.754] - result already collected: FutureResult
[11:00:04.754] result() for ClusterFuture ... done
[11:00:04.754] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:00:04.754] - nx: 2
[11:00:04.754] - relay: TRUE
[11:00:04.754] - stdout: TRUE
[11:00:04.754] - signal: TRUE
[11:00:04.754] - resignal: FALSE
[11:00:04.754] - force: TRUE
[11:00:04.754] - relayed: [n=2] TRUE, FALSE
[11:00:04.754] - queued futures: [n=2] TRUE, FALSE
[11:00:04.754]  - until=2
[11:00:04.755]  - relaying element #2
[11:00:04.755] result() for ClusterFuture ...
[11:00:04.755] - result already collected: FutureResult
[11:00:04.755] result() for ClusterFuture ... done
[11:00:04.755] result() for ClusterFuture ...
[11:00:04.755] - result already collected: FutureResult
[11:00:04.755] result() for ClusterFuture ... done
[11:00:04.755] result() for ClusterFuture ...
[11:00:04.755] - result already collected: FutureResult
[11:00:04.755] result() for ClusterFuture ... done
[11:00:04.755] result() for ClusterFuture ...
[11:00:04.756] - result already collected: FutureResult
[11:00:04.756] result() for ClusterFuture ... done
[11:00:04.756] - relayed: [n=2] TRUE, TRUE
[11:00:04.756] - queued futures: [n=2] TRUE, TRUE
[11:00:04.756] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:00:04.756]  length: 0 (resolved future 2)
[11:00:04.756] Relaying remaining futures
[11:00:04.756] signalConditionsASAP(NULL, pos=0) ...
[11:00:04.756] - nx: 2
[11:00:04.756] - relay: TRUE
[11:00:04.756] - stdout: TRUE
[11:00:04.756] - signal: TRUE
[11:00:04.756] - resignal: FALSE
[11:00:04.757] - force: TRUE
[11:00:04.757] - relayed: [n=2] TRUE, TRUE
[11:00:04.757] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:04.757] - relayed: [n=2] TRUE, TRUE
[11:00:04.757] - queued futures: [n=2] TRUE, TRUE
[11:00:04.757] signalConditionsASAP(NULL, pos=0) ... done
[11:00:04.757] resolve() on list ... DONE
[11:00:04.757] result() for ClusterFuture ...
[11:00:04.757] - result already collected: FutureResult
[11:00:04.757] result() for ClusterFuture ... done
[11:00:04.757] result() for ClusterFuture ...
[11:00:04.757] - result already collected: FutureResult
[11:00:04.758] result() for ClusterFuture ... done
[11:00:04.758] result() for ClusterFuture ...
[11:00:04.758] - result already collected: FutureResult
[11:00:04.758] result() for ClusterFuture ... done
[11:00:04.758] result() for ClusterFuture ...
[11:00:04.758] - result already collected: FutureResult
[11:00:04.758] result() for ClusterFuture ... done
[11:00:04.758]  - Number of value chunks collected: 2
[11:00:04.758] Resolving 2 futures (chunks) ... DONE
[11:00:04.758] Reducing values from 2 chunks ...
[11:00:04.758]  - Number of values collected after concatenation: 10
[11:00:04.758]  - Number of values expected: 10
[11:00:04.759] Reducing values from 2 chunks ... DONE
[11:00:04.759] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[11:00:04.759] future_lapply() ...
[11:00:04.763] Number of chunks: 2
[11:00:04.763] getGlobalsAndPackagesXApply() ...
[11:00:04.763]  - future.globals: TRUE
[11:00:04.763] getGlobalsAndPackages() ...
[11:00:04.763] Searching for globals...
[11:00:04.766] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[11:00:04.766] Searching for globals ... DONE
[11:00:04.766] Resolving globals: FALSE
[11:00:04.767] The total size of the 7 globals is 12.08 KiB (12367 bytes)
[11:00:04.767] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (4.07 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:04.767] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:04.768] - packages: [1] ‘future.apply’
[11:00:04.768] getGlobalsAndPackages() ... DONE
[11:00:04.768]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:04.768]  - needed namespaces: [n=1] ‘future.apply’
[11:00:04.768] Finding globals ... DONE
[11:00:04.768]  - use_args: TRUE
[11:00:04.768]  - Getting '...' globals ...
[11:00:04.768] resolve() on list ...
[11:00:04.769]  recursive: 0
[11:00:04.769]  length: 1
[11:00:04.769]  elements: ‘...’
[11:00:04.769]  length: 0 (resolved future 1)
[11:00:04.769] resolve() on list ... DONE
[11:00:04.769]    - '...' content: [n=0] 
[11:00:04.769] List of 1
[11:00:04.769]  $ ...: list()
[11:00:04.769]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:04.769]  - attr(*, "where")=List of 1
[11:00:04.769]   ..$ ...:<environment: 0x55bbaeb3c278> 
[11:00:04.769]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:04.769]  - attr(*, "resolved")= logi TRUE
[11:00:04.769]  - attr(*, "total_size")= num NA
[11:00:04.772]  - Getting '...' globals ... DONE
[11:00:04.772] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:04.772] List of 8
[11:00:04.772]  $ ...future.FUN:function (x, ...)  
[11:00:04.772]  $ x_FUN        :function (x)  
[11:00:04.772]  $ times        : int 1
[11:00:04.772]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:04.772]  $ stop_if_not  :function (...)  
[11:00:04.772]  $ dim          : NULL
[11:00:04.772]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:04.772]  $ ...          : list()
[11:00:04.772]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:04.772]  - attr(*, "where")=List of 8
[11:00:04.772]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:04.772]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:04.772]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:04.772]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:04.772]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:04.772]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:04.772]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:04.772]   ..$ ...          :<environment: 0x55bbaeb3c278> 
[11:00:04.772]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:04.772]  - attr(*, "resolved")= logi FALSE
[11:00:04.772]  - attr(*, "total_size")= num 22322
[11:00:04.777] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:04.777] getGlobalsAndPackagesXApply() ... DONE
[11:00:04.777] Number of futures (= number of chunks): 2
[11:00:04.777] Launching 2 futures (chunks) ...
[11:00:04.777] Chunk #1 of 2 ...
[11:00:04.778]  - Finding globals in 'X' for chunk #1 ...
[11:00:04.778] getGlobalsAndPackages() ...
[11:00:04.778] Searching for globals...
[11:00:04.778] 
[11:00:04.778] Searching for globals ... DONE
[11:00:04.778] - globals: [0] <none>
[11:00:04.778] getGlobalsAndPackages() ... DONE
[11:00:04.778]    + additional globals found: [n=0] 
[11:00:04.778]    + additional namespaces needed: [n=0] 
[11:00:04.778]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:04.778]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:04.779]  - seeds: <none>
[11:00:04.779]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:04.779] getGlobalsAndPackages() ...
[11:00:04.779] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:04.779] Resolving globals: FALSE
[11:00:04.779] Tweak future expression to call with '...' arguments ...
[11:00:04.779] {
[11:00:04.779]     do.call(function(...) {
[11:00:04.779]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:04.779]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:04.779]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:04.779]             on.exit(options(oopts), add = TRUE)
[11:00:04.779]         }
[11:00:04.779]         {
[11:00:04.779]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:04.779]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:04.779]                 ...future.FUN(...future.X_jj, ...)
[11:00:04.779]             })
[11:00:04.779]         }
[11:00:04.779]     }, args = future.call.arguments)
[11:00:04.779] }
[11:00:04.779] Tweak future expression to call with '...' arguments ... DONE
[11:00:04.780] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:04.780] - packages: [1] ‘future.apply’
[11:00:04.780] getGlobalsAndPackages() ... DONE
[11:00:04.780] run() for ‘Future’ ...
[11:00:04.780] - state: ‘created’
[11:00:04.781] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:04.794] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:04.794] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:04.794]   - Field: ‘node’
[11:00:04.795]   - Field: ‘label’
[11:00:04.795]   - Field: ‘local’
[11:00:04.795]   - Field: ‘owner’
[11:00:04.795]   - Field: ‘envir’
[11:00:04.795]   - Field: ‘workers’
[11:00:04.795]   - Field: ‘packages’
[11:00:04.795]   - Field: ‘gc’
[11:00:04.795]   - Field: ‘conditions’
[11:00:04.795]   - Field: ‘persistent’
[11:00:04.795]   - Field: ‘expr’
[11:00:04.795]   - Field: ‘uuid’
[11:00:04.796]   - Field: ‘seed’
[11:00:04.796]   - Field: ‘version’
[11:00:04.796]   - Field: ‘result’
[11:00:04.796]   - Field: ‘asynchronous’
[11:00:04.796]   - Field: ‘calls’
[11:00:04.796]   - Field: ‘globals’
[11:00:04.796]   - Field: ‘stdout’
[11:00:04.796]   - Field: ‘earlySignal’
[11:00:04.796]   - Field: ‘lazy’
[11:00:04.796]   - Field: ‘state’
[11:00:04.796] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:04.796] - Launch lazy future ...
[11:00:04.797] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:04.797] Packages needed by future strategies (n = 0): <none>
[11:00:04.797] {
[11:00:04.797]     {
[11:00:04.797]         {
[11:00:04.797]             ...future.startTime <- base::Sys.time()
[11:00:04.797]             {
[11:00:04.797]                 {
[11:00:04.797]                   {
[11:00:04.797]                     {
[11:00:04.797]                       {
[11:00:04.797]                         base::local({
[11:00:04.797]                           has_future <- base::requireNamespace("future", 
[11:00:04.797]                             quietly = TRUE)
[11:00:04.797]                           if (has_future) {
[11:00:04.797]                             ns <- base::getNamespace("future")
[11:00:04.797]                             version <- ns[[".package"]][["version"]]
[11:00:04.797]                             if (is.null(version)) 
[11:00:04.797]                               version <- utils::packageVersion("future")
[11:00:04.797]                           }
[11:00:04.797]                           else {
[11:00:04.797]                             version <- NULL
[11:00:04.797]                           }
[11:00:04.797]                           if (!has_future || version < "1.8.0") {
[11:00:04.797]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:04.797]                               "", base::R.version$version.string), 
[11:00:04.797]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:04.797]                                 base::R.version$platform, 8 * 
[11:00:04.797]                                   base::.Machine$sizeof.pointer), 
[11:00:04.797]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:04.797]                                 "release", "version")], collapse = " "), 
[11:00:04.797]                               hostname = base::Sys.info()[["nodename"]])
[11:00:04.797]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:04.797]                               info)
[11:00:04.797]                             info <- base::paste(info, collapse = "; ")
[11:00:04.797]                             if (!has_future) {
[11:00:04.797]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:04.797]                                 info)
[11:00:04.797]                             }
[11:00:04.797]                             else {
[11:00:04.797]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:04.797]                                 info, version)
[11:00:04.797]                             }
[11:00:04.797]                             base::stop(msg)
[11:00:04.797]                           }
[11:00:04.797]                         })
[11:00:04.797]                       }
[11:00:04.797]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:04.797]                       base::options(mc.cores = 1L)
[11:00:04.797]                     }
[11:00:04.797]                     base::local({
[11:00:04.797]                       for (pkg in "future.apply") {
[11:00:04.797]                         base::loadNamespace(pkg)
[11:00:04.797]                         base::library(pkg, character.only = TRUE)
[11:00:04.797]                       }
[11:00:04.797]                     })
[11:00:04.797]                   }
[11:00:04.797]                   ...future.strategy.old <- future::plan("list")
[11:00:04.797]                   options(future.plan = NULL)
[11:00:04.797]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:04.797]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:04.797]                 }
[11:00:04.797]                 ...future.workdir <- getwd()
[11:00:04.797]             }
[11:00:04.797]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:04.797]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:04.797]         }
[11:00:04.797]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:04.797]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:04.797]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:04.797]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:04.797]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:04.797]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:04.797]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:04.797]             base::names(...future.oldOptions))
[11:00:04.797]     }
[11:00:04.797]     if (FALSE) {
[11:00:04.797]     }
[11:00:04.797]     else {
[11:00:04.797]         if (TRUE) {
[11:00:04.797]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:04.797]                 open = "w")
[11:00:04.797]         }
[11:00:04.797]         else {
[11:00:04.797]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:04.797]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:04.797]         }
[11:00:04.797]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:04.797]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:04.797]             base::sink(type = "output", split = FALSE)
[11:00:04.797]             base::close(...future.stdout)
[11:00:04.797]         }, add = TRUE)
[11:00:04.797]     }
[11:00:04.797]     ...future.frame <- base::sys.nframe()
[11:00:04.797]     ...future.conditions <- base::list()
[11:00:04.797]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:04.797]     if (FALSE) {
[11:00:04.797]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:04.797]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:04.797]     }
[11:00:04.797]     ...future.result <- base::tryCatch({
[11:00:04.797]         base::withCallingHandlers({
[11:00:04.797]             ...future.value <- base::withVisible(base::local({
[11:00:04.797]                 ...future.makeSendCondition <- base::local({
[11:00:04.797]                   sendCondition <- NULL
[11:00:04.797]                   function(frame = 1L) {
[11:00:04.797]                     if (is.function(sendCondition)) 
[11:00:04.797]                       return(sendCondition)
[11:00:04.797]                     ns <- getNamespace("parallel")
[11:00:04.797]                     if (exists("sendData", mode = "function", 
[11:00:04.797]                       envir = ns)) {
[11:00:04.797]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:04.797]                         envir = ns)
[11:00:04.797]                       envir <- sys.frame(frame)
[11:00:04.797]                       master <- NULL
[11:00:04.797]                       while (!identical(envir, .GlobalEnv) && 
[11:00:04.797]                         !identical(envir, emptyenv())) {
[11:00:04.797]                         if (exists("master", mode = "list", envir = envir, 
[11:00:04.797]                           inherits = FALSE)) {
[11:00:04.797]                           master <- get("master", mode = "list", 
[11:00:04.797]                             envir = envir, inherits = FALSE)
[11:00:04.797]                           if (inherits(master, c("SOCKnode", 
[11:00:04.797]                             "SOCK0node"))) {
[11:00:04.797]                             sendCondition <<- function(cond) {
[11:00:04.797]                               data <- list(type = "VALUE", value = cond, 
[11:00:04.797]                                 success = TRUE)
[11:00:04.797]                               parallel_sendData(master, data)
[11:00:04.797]                             }
[11:00:04.797]                             return(sendCondition)
[11:00:04.797]                           }
[11:00:04.797]                         }
[11:00:04.797]                         frame <- frame + 1L
[11:00:04.797]                         envir <- sys.frame(frame)
[11:00:04.797]                       }
[11:00:04.797]                     }
[11:00:04.797]                     sendCondition <<- function(cond) NULL
[11:00:04.797]                   }
[11:00:04.797]                 })
[11:00:04.797]                 withCallingHandlers({
[11:00:04.797]                   {
[11:00:04.797]                     do.call(function(...) {
[11:00:04.797]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:04.797]                       if (!identical(...future.globals.maxSize.org, 
[11:00:04.797]                         ...future.globals.maxSize)) {
[11:00:04.797]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:04.797]                         on.exit(options(oopts), add = TRUE)
[11:00:04.797]                       }
[11:00:04.797]                       {
[11:00:04.797]                         lapply(seq_along(...future.elements_ii), 
[11:00:04.797]                           FUN = function(jj) {
[11:00:04.797]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:04.797]                             ...future.FUN(...future.X_jj, ...)
[11:00:04.797]                           })
[11:00:04.797]                       }
[11:00:04.797]                     }, args = future.call.arguments)
[11:00:04.797]                   }
[11:00:04.797]                 }, immediateCondition = function(cond) {
[11:00:04.797]                   sendCondition <- ...future.makeSendCondition()
[11:00:04.797]                   sendCondition(cond)
[11:00:04.797]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:04.797]                   {
[11:00:04.797]                     inherits <- base::inherits
[11:00:04.797]                     invokeRestart <- base::invokeRestart
[11:00:04.797]                     is.null <- base::is.null
[11:00:04.797]                     muffled <- FALSE
[11:00:04.797]                     if (inherits(cond, "message")) {
[11:00:04.797]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:04.797]                       if (muffled) 
[11:00:04.797]                         invokeRestart("muffleMessage")
[11:00:04.797]                     }
[11:00:04.797]                     else if (inherits(cond, "warning")) {
[11:00:04.797]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:04.797]                       if (muffled) 
[11:00:04.797]                         invokeRestart("muffleWarning")
[11:00:04.797]                     }
[11:00:04.797]                     else if (inherits(cond, "condition")) {
[11:00:04.797]                       if (!is.null(pattern)) {
[11:00:04.797]                         computeRestarts <- base::computeRestarts
[11:00:04.797]                         grepl <- base::grepl
[11:00:04.797]                         restarts <- computeRestarts(cond)
[11:00:04.797]                         for (restart in restarts) {
[11:00:04.797]                           name <- restart$name
[11:00:04.797]                           if (is.null(name)) 
[11:00:04.797]                             next
[11:00:04.797]                           if (!grepl(pattern, name)) 
[11:00:04.797]                             next
[11:00:04.797]                           invokeRestart(restart)
[11:00:04.797]                           muffled <- TRUE
[11:00:04.797]                           break
[11:00:04.797]                         }
[11:00:04.797]                       }
[11:00:04.797]                     }
[11:00:04.797]                     invisible(muffled)
[11:00:04.797]                   }
[11:00:04.797]                   muffleCondition(cond)
[11:00:04.797]                 })
[11:00:04.797]             }))
[11:00:04.797]             future::FutureResult(value = ...future.value$value, 
[11:00:04.797]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:04.797]                   ...future.rng), globalenv = if (FALSE) 
[11:00:04.797]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:04.797]                     ...future.globalenv.names))
[11:00:04.797]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:04.797]         }, condition = base::local({
[11:00:04.797]             c <- base::c
[11:00:04.797]             inherits <- base::inherits
[11:00:04.797]             invokeRestart <- base::invokeRestart
[11:00:04.797]             length <- base::length
[11:00:04.797]             list <- base::list
[11:00:04.797]             seq.int <- base::seq.int
[11:00:04.797]             signalCondition <- base::signalCondition
[11:00:04.797]             sys.calls <- base::sys.calls
[11:00:04.797]             `[[` <- base::`[[`
[11:00:04.797]             `+` <- base::`+`
[11:00:04.797]             `<<-` <- base::`<<-`
[11:00:04.797]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:04.797]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:04.797]                   3L)]
[11:00:04.797]             }
[11:00:04.797]             function(cond) {
[11:00:04.797]                 is_error <- inherits(cond, "error")
[11:00:04.797]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:04.797]                   NULL)
[11:00:04.797]                 if (is_error) {
[11:00:04.797]                   sessionInformation <- function() {
[11:00:04.797]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:04.797]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:04.797]                       search = base::search(), system = base::Sys.info())
[11:00:04.797]                   }
[11:00:04.797]                   ...future.conditions[[length(...future.conditions) + 
[11:00:04.797]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:04.797]                     cond$call), session = sessionInformation(), 
[11:00:04.797]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:04.797]                   signalCondition(cond)
[11:00:04.797]                 }
[11:00:04.797]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:04.797]                 "immediateCondition"))) {
[11:00:04.797]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:04.797]                   ...future.conditions[[length(...future.conditions) + 
[11:00:04.797]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:04.797]                   if (TRUE && !signal) {
[11:00:04.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:04.797]                     {
[11:00:04.797]                       inherits <- base::inherits
[11:00:04.797]                       invokeRestart <- base::invokeRestart
[11:00:04.797]                       is.null <- base::is.null
[11:00:04.797]                       muffled <- FALSE
[11:00:04.797]                       if (inherits(cond, "message")) {
[11:00:04.797]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:04.797]                         if (muffled) 
[11:00:04.797]                           invokeRestart("muffleMessage")
[11:00:04.797]                       }
[11:00:04.797]                       else if (inherits(cond, "warning")) {
[11:00:04.797]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:04.797]                         if (muffled) 
[11:00:04.797]                           invokeRestart("muffleWarning")
[11:00:04.797]                       }
[11:00:04.797]                       else if (inherits(cond, "condition")) {
[11:00:04.797]                         if (!is.null(pattern)) {
[11:00:04.797]                           computeRestarts <- base::computeRestarts
[11:00:04.797]                           grepl <- base::grepl
[11:00:04.797]                           restarts <- computeRestarts(cond)
[11:00:04.797]                           for (restart in restarts) {
[11:00:04.797]                             name <- restart$name
[11:00:04.797]                             if (is.null(name)) 
[11:00:04.797]                               next
[11:00:04.797]                             if (!grepl(pattern, name)) 
[11:00:04.797]                               next
[11:00:04.797]                             invokeRestart(restart)
[11:00:04.797]                             muffled <- TRUE
[11:00:04.797]                             break
[11:00:04.797]                           }
[11:00:04.797]                         }
[11:00:04.797]                       }
[11:00:04.797]                       invisible(muffled)
[11:00:04.797]                     }
[11:00:04.797]                     muffleCondition(cond, pattern = "^muffle")
[11:00:04.797]                   }
[11:00:04.797]                 }
[11:00:04.797]                 else {
[11:00:04.797]                   if (TRUE) {
[11:00:04.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:04.797]                     {
[11:00:04.797]                       inherits <- base::inherits
[11:00:04.797]                       invokeRestart <- base::invokeRestart
[11:00:04.797]                       is.null <- base::is.null
[11:00:04.797]                       muffled <- FALSE
[11:00:04.797]                       if (inherits(cond, "message")) {
[11:00:04.797]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:04.797]                         if (muffled) 
[11:00:04.797]                           invokeRestart("muffleMessage")
[11:00:04.797]                       }
[11:00:04.797]                       else if (inherits(cond, "warning")) {
[11:00:04.797]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:04.797]                         if (muffled) 
[11:00:04.797]                           invokeRestart("muffleWarning")
[11:00:04.797]                       }
[11:00:04.797]                       else if (inherits(cond, "condition")) {
[11:00:04.797]                         if (!is.null(pattern)) {
[11:00:04.797]                           computeRestarts <- base::computeRestarts
[11:00:04.797]                           grepl <- base::grepl
[11:00:04.797]                           restarts <- computeRestarts(cond)
[11:00:04.797]                           for (restart in restarts) {
[11:00:04.797]                             name <- restart$name
[11:00:04.797]                             if (is.null(name)) 
[11:00:04.797]                               next
[11:00:04.797]                             if (!grepl(pattern, name)) 
[11:00:04.797]                               next
[11:00:04.797]                             invokeRestart(restart)
[11:00:04.797]                             muffled <- TRUE
[11:00:04.797]                             break
[11:00:04.797]                           }
[11:00:04.797]                         }
[11:00:04.797]                       }
[11:00:04.797]                       invisible(muffled)
[11:00:04.797]                     }
[11:00:04.797]                     muffleCondition(cond, pattern = "^muffle")
[11:00:04.797]                   }
[11:00:04.797]                 }
[11:00:04.797]             }
[11:00:04.797]         }))
[11:00:04.797]     }, error = function(ex) {
[11:00:04.797]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:04.797]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:04.797]                 ...future.rng), started = ...future.startTime, 
[11:00:04.797]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:04.797]             version = "1.8"), class = "FutureResult")
[11:00:04.797]     }, finally = {
[11:00:04.797]         if (!identical(...future.workdir, getwd())) 
[11:00:04.797]             setwd(...future.workdir)
[11:00:04.797]         {
[11:00:04.797]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:04.797]                 ...future.oldOptions$nwarnings <- NULL
[11:00:04.797]             }
[11:00:04.797]             base::options(...future.oldOptions)
[11:00:04.797]             if (.Platform$OS.type == "windows") {
[11:00:04.797]                 old_names <- names(...future.oldEnvVars)
[11:00:04.797]                 envs <- base::Sys.getenv()
[11:00:04.797]                 names <- names(envs)
[11:00:04.797]                 common <- intersect(names, old_names)
[11:00:04.797]                 added <- setdiff(names, old_names)
[11:00:04.797]                 removed <- setdiff(old_names, names)
[11:00:04.797]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:04.797]                   envs[common]]
[11:00:04.797]                 NAMES <- toupper(changed)
[11:00:04.797]                 args <- list()
[11:00:04.797]                 for (kk in seq_along(NAMES)) {
[11:00:04.797]                   name <- changed[[kk]]
[11:00:04.797]                   NAME <- NAMES[[kk]]
[11:00:04.797]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:04.797]                     next
[11:00:04.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:04.797]                 }
[11:00:04.797]                 NAMES <- toupper(added)
[11:00:04.797]                 for (kk in seq_along(NAMES)) {
[11:00:04.797]                   name <- added[[kk]]
[11:00:04.797]                   NAME <- NAMES[[kk]]
[11:00:04.797]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:04.797]                     next
[11:00:04.797]                   args[[name]] <- ""
[11:00:04.797]                 }
[11:00:04.797]                 NAMES <- toupper(removed)
[11:00:04.797]                 for (kk in seq_along(NAMES)) {
[11:00:04.797]                   name <- removed[[kk]]
[11:00:04.797]                   NAME <- NAMES[[kk]]
[11:00:04.797]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:04.797]                     next
[11:00:04.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:04.797]                 }
[11:00:04.797]                 if (length(args) > 0) 
[11:00:04.797]                   base::do.call(base::Sys.setenv, args = args)
[11:00:04.797]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:04.797]             }
[11:00:04.797]             else {
[11:00:04.797]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:04.797]             }
[11:00:04.797]             {
[11:00:04.797]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:04.797]                   0L) {
[11:00:04.797]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:04.797]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:04.797]                   base::options(opts)
[11:00:04.797]                 }
[11:00:04.797]                 {
[11:00:04.797]                   {
[11:00:04.797]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:04.797]                     NULL
[11:00:04.797]                   }
[11:00:04.797]                   options(future.plan = NULL)
[11:00:04.797]                   if (is.na(NA_character_)) 
[11:00:04.797]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:04.797]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:04.797]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:04.797]                     .init = FALSE)
[11:00:04.797]                 }
[11:00:04.797]             }
[11:00:04.797]         }
[11:00:04.797]     })
[11:00:04.797]     if (TRUE) {
[11:00:04.797]         base::sink(type = "output", split = FALSE)
[11:00:04.797]         if (TRUE) {
[11:00:04.797]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:04.797]         }
[11:00:04.797]         else {
[11:00:04.797]             ...future.result["stdout"] <- base::list(NULL)
[11:00:04.797]         }
[11:00:04.797]         base::close(...future.stdout)
[11:00:04.797]         ...future.stdout <- NULL
[11:00:04.797]     }
[11:00:04.797]     ...future.result$conditions <- ...future.conditions
[11:00:04.797]     ...future.result$finished <- base::Sys.time()
[11:00:04.797]     ...future.result
[11:00:04.797] }
[11:00:04.800] Exporting 11 global objects (12.56 KiB) to cluster node #1 ...
[11:00:04.800] Exporting ‘...future.FUN’ (4.06 KiB) to cluster node #1 ...
[11:00:04.842] Exporting ‘...future.FUN’ (4.06 KiB) to cluster node #1 ... DONE
[11:00:04.842] Exporting ‘x_FUN’ (35 bytes) to cluster node #1 ...
[11:00:04.842] Exporting ‘x_FUN’ (35 bytes) to cluster node #1 ... DONE
[11:00:04.842] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[11:00:04.843] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[11:00:04.843] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[11:00:04.883] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[11:00:04.884] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[11:00:04.925] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[11:00:04.925] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[11:00:04.925] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[11:00:04.925] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[11:00:04.926] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[11:00:04.926] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[11:00:04.926] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[11:00:04.926] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ...
[11:00:04.927] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ... DONE
[11:00:04.927] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[11:00:04.927] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[11:00:04.927] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[11:00:04.928] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[11:00:04.928] Exporting 11 global objects (12.56 KiB) to cluster node #1 ... DONE
[11:00:04.928] MultisessionFuture started
[11:00:04.928] - Launch lazy future ... done
[11:00:04.928] run() for ‘MultisessionFuture’ ... done
[11:00:04.928] Created future:
[11:00:04.928] MultisessionFuture:
[11:00:04.928] Label: ‘future_vapply-1’
[11:00:04.928] Expression:
[11:00:04.928] {
[11:00:04.928]     do.call(function(...) {
[11:00:04.928]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:04.928]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:04.928]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:04.928]             on.exit(options(oopts), add = TRUE)
[11:00:04.928]         }
[11:00:04.928]         {
[11:00:04.928]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:04.928]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:04.928]                 ...future.FUN(...future.X_jj, ...)
[11:00:04.928]             })
[11:00:04.928]         }
[11:00:04.928]     }, args = future.call.arguments)
[11:00:04.928] }
[11:00:04.928] Lazy evaluation: FALSE
[11:00:04.928] Asynchronous evaluation: TRUE
[11:00:04.928] Local evaluation: TRUE
[11:00:04.928] Environment: R_GlobalEnv
[11:00:04.928] Capture standard output: TRUE
[11:00:04.928] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:04.928] Globals: 11 objects totaling 12.31 KiB (function ‘...future.FUN’ of 4.06 KiB, function ‘x_FUN’ of 35 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:04.928] Packages: 1 packages (‘future.apply’)
[11:00:04.928] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:04.928] Resolved: FALSE
[11:00:04.928] Value: <not collected>
[11:00:04.928] Conditions captured: <none>
[11:00:04.928] Early signaling: FALSE
[11:00:04.928] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:04.928] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:04.940] Chunk #1 of 2 ... DONE
[11:00:04.940] Chunk #2 of 2 ...
[11:00:04.940]  - Finding globals in 'X' for chunk #2 ...
[11:00:04.940] getGlobalsAndPackages() ...
[11:00:04.940] Searching for globals...
[11:00:04.941] 
[11:00:04.941] Searching for globals ... DONE
[11:00:04.941] - globals: [0] <none>
[11:00:04.941] getGlobalsAndPackages() ... DONE
[11:00:04.941]    + additional globals found: [n=0] 
[11:00:04.941]    + additional namespaces needed: [n=0] 
[11:00:04.941]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:04.941]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:04.941]  - seeds: <none>
[11:00:04.941]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:04.941] getGlobalsAndPackages() ...
[11:00:04.942] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:04.942] Resolving globals: FALSE
[11:00:04.942] Tweak future expression to call with '...' arguments ...
[11:00:04.942] {
[11:00:04.942]     do.call(function(...) {
[11:00:04.942]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:04.942]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:04.942]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:04.942]             on.exit(options(oopts), add = TRUE)
[11:00:04.942]         }
[11:00:04.942]         {
[11:00:04.942]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:04.942]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:04.942]                 ...future.FUN(...future.X_jj, ...)
[11:00:04.942]             })
[11:00:04.942]         }
[11:00:04.942]     }, args = future.call.arguments)
[11:00:04.942] }
[11:00:04.942] Tweak future expression to call with '...' arguments ... DONE
[11:00:04.943] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:04.943] - packages: [1] ‘future.apply’
[11:00:04.943] getGlobalsAndPackages() ... DONE
[11:00:04.943] run() for ‘Future’ ...
[11:00:04.943] - state: ‘created’
[11:00:04.943] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:04.957] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:04.957] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:04.957]   - Field: ‘node’
[11:00:04.957]   - Field: ‘label’
[11:00:04.957]   - Field: ‘local’
[11:00:04.957]   - Field: ‘owner’
[11:00:04.958]   - Field: ‘envir’
[11:00:04.958]   - Field: ‘workers’
[11:00:04.958]   - Field: ‘packages’
[11:00:04.958]   - Field: ‘gc’
[11:00:04.958]   - Field: ‘conditions’
[11:00:04.958]   - Field: ‘persistent’
[11:00:04.958]   - Field: ‘expr’
[11:00:04.958]   - Field: ‘uuid’
[11:00:04.958]   - Field: ‘seed’
[11:00:04.958]   - Field: ‘version’
[11:00:04.958]   - Field: ‘result’
[11:00:04.958]   - Field: ‘asynchronous’
[11:00:04.959]   - Field: ‘calls’
[11:00:04.959]   - Field: ‘globals’
[11:00:04.959]   - Field: ‘stdout’
[11:00:04.959]   - Field: ‘earlySignal’
[11:00:04.959]   - Field: ‘lazy’
[11:00:04.959]   - Field: ‘state’
[11:00:04.959] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:04.959] - Launch lazy future ...
[11:00:04.959] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:04.960] Packages needed by future strategies (n = 0): <none>
[11:00:04.960] {
[11:00:04.960]     {
[11:00:04.960]         {
[11:00:04.960]             ...future.startTime <- base::Sys.time()
[11:00:04.960]             {
[11:00:04.960]                 {
[11:00:04.960]                   {
[11:00:04.960]                     {
[11:00:04.960]                       {
[11:00:04.960]                         base::local({
[11:00:04.960]                           has_future <- base::requireNamespace("future", 
[11:00:04.960]                             quietly = TRUE)
[11:00:04.960]                           if (has_future) {
[11:00:04.960]                             ns <- base::getNamespace("future")
[11:00:04.960]                             version <- ns[[".package"]][["version"]]
[11:00:04.960]                             if (is.null(version)) 
[11:00:04.960]                               version <- utils::packageVersion("future")
[11:00:04.960]                           }
[11:00:04.960]                           else {
[11:00:04.960]                             version <- NULL
[11:00:04.960]                           }
[11:00:04.960]                           if (!has_future || version < "1.8.0") {
[11:00:04.960]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:04.960]                               "", base::R.version$version.string), 
[11:00:04.960]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:04.960]                                 base::R.version$platform, 8 * 
[11:00:04.960]                                   base::.Machine$sizeof.pointer), 
[11:00:04.960]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:04.960]                                 "release", "version")], collapse = " "), 
[11:00:04.960]                               hostname = base::Sys.info()[["nodename"]])
[11:00:04.960]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:04.960]                               info)
[11:00:04.960]                             info <- base::paste(info, collapse = "; ")
[11:00:04.960]                             if (!has_future) {
[11:00:04.960]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:04.960]                                 info)
[11:00:04.960]                             }
[11:00:04.960]                             else {
[11:00:04.960]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:04.960]                                 info, version)
[11:00:04.960]                             }
[11:00:04.960]                             base::stop(msg)
[11:00:04.960]                           }
[11:00:04.960]                         })
[11:00:04.960]                       }
[11:00:04.960]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:04.960]                       base::options(mc.cores = 1L)
[11:00:04.960]                     }
[11:00:04.960]                     base::local({
[11:00:04.960]                       for (pkg in "future.apply") {
[11:00:04.960]                         base::loadNamespace(pkg)
[11:00:04.960]                         base::library(pkg, character.only = TRUE)
[11:00:04.960]                       }
[11:00:04.960]                     })
[11:00:04.960]                   }
[11:00:04.960]                   ...future.strategy.old <- future::plan("list")
[11:00:04.960]                   options(future.plan = NULL)
[11:00:04.960]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:04.960]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:04.960]                 }
[11:00:04.960]                 ...future.workdir <- getwd()
[11:00:04.960]             }
[11:00:04.960]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:04.960]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:04.960]         }
[11:00:04.960]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:04.960]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:04.960]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:04.960]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:04.960]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:04.960]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:04.960]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:04.960]             base::names(...future.oldOptions))
[11:00:04.960]     }
[11:00:04.960]     if (FALSE) {
[11:00:04.960]     }
[11:00:04.960]     else {
[11:00:04.960]         if (TRUE) {
[11:00:04.960]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:04.960]                 open = "w")
[11:00:04.960]         }
[11:00:04.960]         else {
[11:00:04.960]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:04.960]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:04.960]         }
[11:00:04.960]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:04.960]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:04.960]             base::sink(type = "output", split = FALSE)
[11:00:04.960]             base::close(...future.stdout)
[11:00:04.960]         }, add = TRUE)
[11:00:04.960]     }
[11:00:04.960]     ...future.frame <- base::sys.nframe()
[11:00:04.960]     ...future.conditions <- base::list()
[11:00:04.960]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:04.960]     if (FALSE) {
[11:00:04.960]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:04.960]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:04.960]     }
[11:00:04.960]     ...future.result <- base::tryCatch({
[11:00:04.960]         base::withCallingHandlers({
[11:00:04.960]             ...future.value <- base::withVisible(base::local({
[11:00:04.960]                 ...future.makeSendCondition <- base::local({
[11:00:04.960]                   sendCondition <- NULL
[11:00:04.960]                   function(frame = 1L) {
[11:00:04.960]                     if (is.function(sendCondition)) 
[11:00:04.960]                       return(sendCondition)
[11:00:04.960]                     ns <- getNamespace("parallel")
[11:00:04.960]                     if (exists("sendData", mode = "function", 
[11:00:04.960]                       envir = ns)) {
[11:00:04.960]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:04.960]                         envir = ns)
[11:00:04.960]                       envir <- sys.frame(frame)
[11:00:04.960]                       master <- NULL
[11:00:04.960]                       while (!identical(envir, .GlobalEnv) && 
[11:00:04.960]                         !identical(envir, emptyenv())) {
[11:00:04.960]                         if (exists("master", mode = "list", envir = envir, 
[11:00:04.960]                           inherits = FALSE)) {
[11:00:04.960]                           master <- get("master", mode = "list", 
[11:00:04.960]                             envir = envir, inherits = FALSE)
[11:00:04.960]                           if (inherits(master, c("SOCKnode", 
[11:00:04.960]                             "SOCK0node"))) {
[11:00:04.960]                             sendCondition <<- function(cond) {
[11:00:04.960]                               data <- list(type = "VALUE", value = cond, 
[11:00:04.960]                                 success = TRUE)
[11:00:04.960]                               parallel_sendData(master, data)
[11:00:04.960]                             }
[11:00:04.960]                             return(sendCondition)
[11:00:04.960]                           }
[11:00:04.960]                         }
[11:00:04.960]                         frame <- frame + 1L
[11:00:04.960]                         envir <- sys.frame(frame)
[11:00:04.960]                       }
[11:00:04.960]                     }
[11:00:04.960]                     sendCondition <<- function(cond) NULL
[11:00:04.960]                   }
[11:00:04.960]                 })
[11:00:04.960]                 withCallingHandlers({
[11:00:04.960]                   {
[11:00:04.960]                     do.call(function(...) {
[11:00:04.960]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:04.960]                       if (!identical(...future.globals.maxSize.org, 
[11:00:04.960]                         ...future.globals.maxSize)) {
[11:00:04.960]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:04.960]                         on.exit(options(oopts), add = TRUE)
[11:00:04.960]                       }
[11:00:04.960]                       {
[11:00:04.960]                         lapply(seq_along(...future.elements_ii), 
[11:00:04.960]                           FUN = function(jj) {
[11:00:04.960]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:04.960]                             ...future.FUN(...future.X_jj, ...)
[11:00:04.960]                           })
[11:00:04.960]                       }
[11:00:04.960]                     }, args = future.call.arguments)
[11:00:04.960]                   }
[11:00:04.960]                 }, immediateCondition = function(cond) {
[11:00:04.960]                   sendCondition <- ...future.makeSendCondition()
[11:00:04.960]                   sendCondition(cond)
[11:00:04.960]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:04.960]                   {
[11:00:04.960]                     inherits <- base::inherits
[11:00:04.960]                     invokeRestart <- base::invokeRestart
[11:00:04.960]                     is.null <- base::is.null
[11:00:04.960]                     muffled <- FALSE
[11:00:04.960]                     if (inherits(cond, "message")) {
[11:00:04.960]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:04.960]                       if (muffled) 
[11:00:04.960]                         invokeRestart("muffleMessage")
[11:00:04.960]                     }
[11:00:04.960]                     else if (inherits(cond, "warning")) {
[11:00:04.960]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:04.960]                       if (muffled) 
[11:00:04.960]                         invokeRestart("muffleWarning")
[11:00:04.960]                     }
[11:00:04.960]                     else if (inherits(cond, "condition")) {
[11:00:04.960]                       if (!is.null(pattern)) {
[11:00:04.960]                         computeRestarts <- base::computeRestarts
[11:00:04.960]                         grepl <- base::grepl
[11:00:04.960]                         restarts <- computeRestarts(cond)
[11:00:04.960]                         for (restart in restarts) {
[11:00:04.960]                           name <- restart$name
[11:00:04.960]                           if (is.null(name)) 
[11:00:04.960]                             next
[11:00:04.960]                           if (!grepl(pattern, name)) 
[11:00:04.960]                             next
[11:00:04.960]                           invokeRestart(restart)
[11:00:04.960]                           muffled <- TRUE
[11:00:04.960]                           break
[11:00:04.960]                         }
[11:00:04.960]                       }
[11:00:04.960]                     }
[11:00:04.960]                     invisible(muffled)
[11:00:04.960]                   }
[11:00:04.960]                   muffleCondition(cond)
[11:00:04.960]                 })
[11:00:04.960]             }))
[11:00:04.960]             future::FutureResult(value = ...future.value$value, 
[11:00:04.960]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:04.960]                   ...future.rng), globalenv = if (FALSE) 
[11:00:04.960]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:04.960]                     ...future.globalenv.names))
[11:00:04.960]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:04.960]         }, condition = base::local({
[11:00:04.960]             c <- base::c
[11:00:04.960]             inherits <- base::inherits
[11:00:04.960]             invokeRestart <- base::invokeRestart
[11:00:04.960]             length <- base::length
[11:00:04.960]             list <- base::list
[11:00:04.960]             seq.int <- base::seq.int
[11:00:04.960]             signalCondition <- base::signalCondition
[11:00:04.960]             sys.calls <- base::sys.calls
[11:00:04.960]             `[[` <- base::`[[`
[11:00:04.960]             `+` <- base::`+`
[11:00:04.960]             `<<-` <- base::`<<-`
[11:00:04.960]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:04.960]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:04.960]                   3L)]
[11:00:04.960]             }
[11:00:04.960]             function(cond) {
[11:00:04.960]                 is_error <- inherits(cond, "error")
[11:00:04.960]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:04.960]                   NULL)
[11:00:04.960]                 if (is_error) {
[11:00:04.960]                   sessionInformation <- function() {
[11:00:04.960]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:04.960]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:04.960]                       search = base::search(), system = base::Sys.info())
[11:00:04.960]                   }
[11:00:04.960]                   ...future.conditions[[length(...future.conditions) + 
[11:00:04.960]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:04.960]                     cond$call), session = sessionInformation(), 
[11:00:04.960]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:04.960]                   signalCondition(cond)
[11:00:04.960]                 }
[11:00:04.960]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:04.960]                 "immediateCondition"))) {
[11:00:04.960]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:04.960]                   ...future.conditions[[length(...future.conditions) + 
[11:00:04.960]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:04.960]                   if (TRUE && !signal) {
[11:00:04.960]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:04.960]                     {
[11:00:04.960]                       inherits <- base::inherits
[11:00:04.960]                       invokeRestart <- base::invokeRestart
[11:00:04.960]                       is.null <- base::is.null
[11:00:04.960]                       muffled <- FALSE
[11:00:04.960]                       if (inherits(cond, "message")) {
[11:00:04.960]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:04.960]                         if (muffled) 
[11:00:04.960]                           invokeRestart("muffleMessage")
[11:00:04.960]                       }
[11:00:04.960]                       else if (inherits(cond, "warning")) {
[11:00:04.960]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:04.960]                         if (muffled) 
[11:00:04.960]                           invokeRestart("muffleWarning")
[11:00:04.960]                       }
[11:00:04.960]                       else if (inherits(cond, "condition")) {
[11:00:04.960]                         if (!is.null(pattern)) {
[11:00:04.960]                           computeRestarts <- base::computeRestarts
[11:00:04.960]                           grepl <- base::grepl
[11:00:04.960]                           restarts <- computeRestarts(cond)
[11:00:04.960]                           for (restart in restarts) {
[11:00:04.960]                             name <- restart$name
[11:00:04.960]                             if (is.null(name)) 
[11:00:04.960]                               next
[11:00:04.960]                             if (!grepl(pattern, name)) 
[11:00:04.960]                               next
[11:00:04.960]                             invokeRestart(restart)
[11:00:04.960]                             muffled <- TRUE
[11:00:04.960]                             break
[11:00:04.960]                           }
[11:00:04.960]                         }
[11:00:04.960]                       }
[11:00:04.960]                       invisible(muffled)
[11:00:04.960]                     }
[11:00:04.960]                     muffleCondition(cond, pattern = "^muffle")
[11:00:04.960]                   }
[11:00:04.960]                 }
[11:00:04.960]                 else {
[11:00:04.960]                   if (TRUE) {
[11:00:04.960]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:04.960]                     {
[11:00:04.960]                       inherits <- base::inherits
[11:00:04.960]                       invokeRestart <- base::invokeRestart
[11:00:04.960]                       is.null <- base::is.null
[11:00:04.960]                       muffled <- FALSE
[11:00:04.960]                       if (inherits(cond, "message")) {
[11:00:04.960]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:04.960]                         if (muffled) 
[11:00:04.960]                           invokeRestart("muffleMessage")
[11:00:04.960]                       }
[11:00:04.960]                       else if (inherits(cond, "warning")) {
[11:00:04.960]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:04.960]                         if (muffled) 
[11:00:04.960]                           invokeRestart("muffleWarning")
[11:00:04.960]                       }
[11:00:04.960]                       else if (inherits(cond, "condition")) {
[11:00:04.960]                         if (!is.null(pattern)) {
[11:00:04.960]                           computeRestarts <- base::computeRestarts
[11:00:04.960]                           grepl <- base::grepl
[11:00:04.960]                           restarts <- computeRestarts(cond)
[11:00:04.960]                           for (restart in restarts) {
[11:00:04.960]                             name <- restart$name
[11:00:04.960]                             if (is.null(name)) 
[11:00:04.960]                               next
[11:00:04.960]                             if (!grepl(pattern, name)) 
[11:00:04.960]                               next
[11:00:04.960]                             invokeRestart(restart)
[11:00:04.960]                             muffled <- TRUE
[11:00:04.960]                             break
[11:00:04.960]                           }
[11:00:04.960]                         }
[11:00:04.960]                       }
[11:00:04.960]                       invisible(muffled)
[11:00:04.960]                     }
[11:00:04.960]                     muffleCondition(cond, pattern = "^muffle")
[11:00:04.960]                   }
[11:00:04.960]                 }
[11:00:04.960]             }
[11:00:04.960]         }))
[11:00:04.960]     }, error = function(ex) {
[11:00:04.960]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:04.960]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:04.960]                 ...future.rng), started = ...future.startTime, 
[11:00:04.960]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:04.960]             version = "1.8"), class = "FutureResult")
[11:00:04.960]     }, finally = {
[11:00:04.960]         if (!identical(...future.workdir, getwd())) 
[11:00:04.960]             setwd(...future.workdir)
[11:00:04.960]         {
[11:00:04.960]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:04.960]                 ...future.oldOptions$nwarnings <- NULL
[11:00:04.960]             }
[11:00:04.960]             base::options(...future.oldOptions)
[11:00:04.960]             if (.Platform$OS.type == "windows") {
[11:00:04.960]                 old_names <- names(...future.oldEnvVars)
[11:00:04.960]                 envs <- base::Sys.getenv()
[11:00:04.960]                 names <- names(envs)
[11:00:04.960]                 common <- intersect(names, old_names)
[11:00:04.960]                 added <- setdiff(names, old_names)
[11:00:04.960]                 removed <- setdiff(old_names, names)
[11:00:04.960]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:04.960]                   envs[common]]
[11:00:04.960]                 NAMES <- toupper(changed)
[11:00:04.960]                 args <- list()
[11:00:04.960]                 for (kk in seq_along(NAMES)) {
[11:00:04.960]                   name <- changed[[kk]]
[11:00:04.960]                   NAME <- NAMES[[kk]]
[11:00:04.960]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:04.960]                     next
[11:00:04.960]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:04.960]                 }
[11:00:04.960]                 NAMES <- toupper(added)
[11:00:04.960]                 for (kk in seq_along(NAMES)) {
[11:00:04.960]                   name <- added[[kk]]
[11:00:04.960]                   NAME <- NAMES[[kk]]
[11:00:04.960]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:04.960]                     next
[11:00:04.960]                   args[[name]] <- ""
[11:00:04.960]                 }
[11:00:04.960]                 NAMES <- toupper(removed)
[11:00:04.960]                 for (kk in seq_along(NAMES)) {
[11:00:04.960]                   name <- removed[[kk]]
[11:00:04.960]                   NAME <- NAMES[[kk]]
[11:00:04.960]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:04.960]                     next
[11:00:04.960]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:04.960]                 }
[11:00:04.960]                 if (length(args) > 0) 
[11:00:04.960]                   base::do.call(base::Sys.setenv, args = args)
[11:00:04.960]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:04.960]             }
[11:00:04.960]             else {
[11:00:04.960]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:04.960]             }
[11:00:04.960]             {
[11:00:04.960]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:04.960]                   0L) {
[11:00:04.960]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:04.960]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:04.960]                   base::options(opts)
[11:00:04.960]                 }
[11:00:04.960]                 {
[11:00:04.960]                   {
[11:00:04.960]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:04.960]                     NULL
[11:00:04.960]                   }
[11:00:04.960]                   options(future.plan = NULL)
[11:00:04.960]                   if (is.na(NA_character_)) 
[11:00:04.960]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:04.960]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:04.960]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:04.960]                     .init = FALSE)
[11:00:04.960]                 }
[11:00:04.960]             }
[11:00:04.960]         }
[11:00:04.960]     })
[11:00:04.960]     if (TRUE) {
[11:00:04.960]         base::sink(type = "output", split = FALSE)
[11:00:04.960]         if (TRUE) {
[11:00:04.960]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:04.960]         }
[11:00:04.960]         else {
[11:00:04.960]             ...future.result["stdout"] <- base::list(NULL)
[11:00:04.960]         }
[11:00:04.960]         base::close(...future.stdout)
[11:00:04.960]         ...future.stdout <- NULL
[11:00:04.960]     }
[11:00:04.960]     ...future.result$conditions <- ...future.conditions
[11:00:04.960]     ...future.result$finished <- base::Sys.time()
[11:00:04.960]     ...future.result
[11:00:04.960] }
[11:00:04.963] Exporting 11 global objects (12.56 KiB) to cluster node #2 ...
[11:00:04.963] Exporting ‘...future.FUN’ (4.06 KiB) to cluster node #2 ...
[11:00:05.004] Exporting ‘...future.FUN’ (4.06 KiB) to cluster node #2 ... DONE
[11:00:05.004] Exporting ‘x_FUN’ (35 bytes) to cluster node #2 ...
[11:00:05.004] Exporting ‘x_FUN’ (35 bytes) to cluster node #2 ... DONE
[11:00:05.004] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[11:00:05.005] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[11:00:05.005] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[11:00:05.046] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[11:00:05.046] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[11:00:05.087] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[11:00:05.087] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[11:00:05.087] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[11:00:05.087] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[11:00:05.088] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[11:00:05.088] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[11:00:05.088] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[11:00:05.088] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ...
[11:00:05.089] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ... DONE
[11:00:05.089] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[11:00:05.089] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[11:00:05.089] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[11:00:05.090] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[11:00:05.090] Exporting 11 global objects (12.56 KiB) to cluster node #2 ... DONE
[11:00:05.090] MultisessionFuture started
[11:00:05.091] - Launch lazy future ... done
[11:00:05.091] run() for ‘MultisessionFuture’ ... done
[11:00:05.091] Created future:
[11:00:05.091] MultisessionFuture:
[11:00:05.091] Label: ‘future_vapply-2’
[11:00:05.091] Expression:
[11:00:05.091] {
[11:00:05.091]     do.call(function(...) {
[11:00:05.091]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:05.091]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:05.091]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:05.091]             on.exit(options(oopts), add = TRUE)
[11:00:05.091]         }
[11:00:05.091]         {
[11:00:05.091]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:05.091]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:05.091]                 ...future.FUN(...future.X_jj, ...)
[11:00:05.091]             })
[11:00:05.091]         }
[11:00:05.091]     }, args = future.call.arguments)
[11:00:05.091] }
[11:00:05.091] Lazy evaluation: FALSE
[11:00:05.091] Asynchronous evaluation: TRUE
[11:00:05.091] Local evaluation: TRUE
[11:00:05.091] Environment: R_GlobalEnv
[11:00:05.091] Capture standard output: TRUE
[11:00:05.091] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:05.091] Globals: 11 objects totaling 12.31 KiB (function ‘...future.FUN’ of 4.06 KiB, function ‘x_FUN’ of 35 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:05.091] Packages: 1 packages (‘future.apply’)
[11:00:05.091] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:05.091] Resolved: FALSE
[11:00:05.091] Value: <not collected>
[11:00:05.091] Conditions captured: <none>
[11:00:05.091] Early signaling: FALSE
[11:00:05.091] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:05.091] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:05.102] Chunk #2 of 2 ... DONE
[11:00:05.102] Launching 2 futures (chunks) ... DONE
[11:00:05.103] Resolving 2 futures (chunks) ...
[11:00:05.103] resolve() on list ...
[11:00:05.103]  recursive: 0
[11:00:05.103]  length: 2
[11:00:05.103] 
[11:00:05.104] receiveMessageFromWorker() for ClusterFuture ...
[11:00:05.104] - Validating connection of MultisessionFuture
[11:00:05.104] - received message: FutureResult
[11:00:05.104] - Received FutureResult
[11:00:05.104] - Erased future from FutureRegistry
[11:00:05.104] result() for ClusterFuture ...
[11:00:05.104] - result already collected: FutureResult
[11:00:05.104] result() for ClusterFuture ... done
[11:00:05.104] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:05.104] Future #1
[11:00:05.105] result() for ClusterFuture ...
[11:00:05.105] - result already collected: FutureResult
[11:00:05.105] result() for ClusterFuture ... done
[11:00:05.105] result() for ClusterFuture ...
[11:00:05.105] - result already collected: FutureResult
[11:00:05.105] result() for ClusterFuture ... done
[11:00:05.105] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:00:05.105] - nx: 2
[11:00:05.105] - relay: TRUE
[11:00:05.105] - stdout: TRUE
[11:00:05.107] - signal: TRUE
[11:00:05.107] - resignal: FALSE
[11:00:05.107] - force: TRUE
[11:00:05.108] - relayed: [n=2] FALSE, FALSE
[11:00:05.108] - queued futures: [n=2] FALSE, FALSE
[11:00:05.108]  - until=1
[11:00:05.108]  - relaying element #1
[11:00:05.108] result() for ClusterFuture ...
[11:00:05.108] - result already collected: FutureResult
[11:00:05.108] result() for ClusterFuture ... done
[11:00:05.108] result() for ClusterFuture ...
[11:00:05.108] - result already collected: FutureResult
[11:00:05.108] result() for ClusterFuture ... done
[11:00:05.108] result() for ClusterFuture ...
[11:00:05.108] - result already collected: FutureResult
[11:00:05.109] result() for ClusterFuture ... done
[11:00:05.109] result() for ClusterFuture ...
[11:00:05.109] - result already collected: FutureResult
[11:00:05.109] result() for ClusterFuture ... done
[11:00:05.109] - relayed: [n=2] TRUE, FALSE
[11:00:05.109] - queued futures: [n=2] TRUE, FALSE
[11:00:05.109] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:00:05.109]  length: 1 (resolved future 1)
[11:00:05.132] receiveMessageFromWorker() for ClusterFuture ...
[11:00:05.132] - Validating connection of MultisessionFuture
[11:00:05.133] - received message: FutureResult
[11:00:05.133] - Received FutureResult
[11:00:05.133] - Erased future from FutureRegistry
[11:00:05.133] result() for ClusterFuture ...
[11:00:05.133] - result already collected: FutureResult
[11:00:05.133] result() for ClusterFuture ... done
[11:00:05.133] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:05.133] Future #2
[11:00:05.133] result() for ClusterFuture ...
[11:00:05.133] - result already collected: FutureResult
[11:00:05.133] result() for ClusterFuture ... done
[11:00:05.134] result() for ClusterFuture ...
[11:00:05.134] - result already collected: FutureResult
[11:00:05.134] result() for ClusterFuture ... done
[11:00:05.134] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:00:05.134] - nx: 2
[11:00:05.134] - relay: TRUE
[11:00:05.134] - stdout: TRUE
[11:00:05.134] - signal: TRUE
[11:00:05.134] - resignal: FALSE
[11:00:05.134] - force: TRUE
[11:00:05.134] - relayed: [n=2] TRUE, FALSE
[11:00:05.134] - queued futures: [n=2] TRUE, FALSE
[11:00:05.134]  - until=2
[11:00:05.135]  - relaying element #2
[11:00:05.135] result() for ClusterFuture ...
[11:00:05.135] - result already collected: FutureResult
[11:00:05.135] result() for ClusterFuture ... done
[11:00:05.135] result() for ClusterFuture ...
[11:00:05.135] - result already collected: FutureResult
[11:00:05.135] result() for ClusterFuture ... done
[11:00:05.135] result() for ClusterFuture ...
[11:00:05.135] - result already collected: FutureResult
[11:00:05.135] result() for ClusterFuture ... done
[11:00:05.135] result() for ClusterFuture ...
[11:00:05.135] - result already collected: FutureResult
[11:00:05.136] result() for ClusterFuture ... done
[11:00:05.136] - relayed: [n=2] TRUE, TRUE
[11:00:05.136] - queued futures: [n=2] TRUE, TRUE
[11:00:05.136] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:00:05.136]  length: 0 (resolved future 2)
[11:00:05.136] Relaying remaining futures
[11:00:05.136] signalConditionsASAP(NULL, pos=0) ...
[11:00:05.136] - nx: 2
[11:00:05.136] - relay: TRUE
[11:00:05.136] - stdout: TRUE
[11:00:05.136] - signal: TRUE
[11:00:05.136] - resignal: FALSE
[11:00:05.136] - force: TRUE
[11:00:05.137] - relayed: [n=2] TRUE, TRUE
[11:00:05.137] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:05.137] - relayed: [n=2] TRUE, TRUE
[11:00:05.137] - queued futures: [n=2] TRUE, TRUE
[11:00:05.137] signalConditionsASAP(NULL, pos=0) ... done
[11:00:05.137] resolve() on list ... DONE
[11:00:05.137] result() for ClusterFuture ...
[11:00:05.137] - result already collected: FutureResult
[11:00:05.137] result() for ClusterFuture ... done
[11:00:05.137] result() for ClusterFuture ...
[11:00:05.137] - result already collected: FutureResult
[11:00:05.137] result() for ClusterFuture ... done
[11:00:05.138] result() for ClusterFuture ...
[11:00:05.138] - result already collected: FutureResult
[11:00:05.138] result() for ClusterFuture ... done
[11:00:05.138] result() for ClusterFuture ...
[11:00:05.138] - result already collected: FutureResult
[11:00:05.138] result() for ClusterFuture ... done
[11:00:05.138]  - Number of value chunks collected: 2
[11:00:05.138] Resolving 2 futures (chunks) ... DONE
[11:00:05.138] Reducing values from 2 chunks ...
[11:00:05.138]  - Number of values collected after concatenation: 10
[11:00:05.138]  - Number of values expected: 10
[11:00:05.139] Reducing values from 2 chunks ... DONE
[11:00:05.139] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[11:00:05.139] future_lapply() ...
[11:00:05.143] Number of chunks: 2
[11:00:05.143] getGlobalsAndPackagesXApply() ...
[11:00:05.143]  - future.globals: TRUE
[11:00:05.143] getGlobalsAndPackages() ...
[11:00:05.143] Searching for globals...
[11:00:05.146] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[11:00:05.147] Searching for globals ... DONE
[11:00:05.147] Resolving globals: FALSE
[11:00:05.148] The total size of the 7 globals is 13.34 KiB (13657 bytes)
[11:00:05.148] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.89 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:05.148] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:05.148] - packages: [1] ‘future.apply’
[11:00:05.148] getGlobalsAndPackages() ... DONE
[11:00:05.149]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:05.149]  - needed namespaces: [n=1] ‘future.apply’
[11:00:05.149] Finding globals ... DONE
[11:00:05.149]  - use_args: TRUE
[11:00:05.149]  - Getting '...' globals ...
[11:00:05.149] resolve() on list ...
[11:00:05.149]  recursive: 0
[11:00:05.149]  length: 1
[11:00:05.149]  elements: ‘...’
[11:00:05.150]  length: 0 (resolved future 1)
[11:00:05.150] resolve() on list ... DONE
[11:00:05.150]    - '...' content: [n=0] 
[11:00:05.150] List of 1
[11:00:05.150]  $ ...: list()
[11:00:05.150]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:05.150]  - attr(*, "where")=List of 1
[11:00:05.150]   ..$ ...:<environment: 0x55bbad5bae08> 
[11:00:05.150]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:05.150]  - attr(*, "resolved")= logi TRUE
[11:00:05.150]  - attr(*, "total_size")= num NA
[11:00:05.152]  - Getting '...' globals ... DONE
[11:00:05.152] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:05.152] List of 8
[11:00:05.152]  $ ...future.FUN:function (x, ...)  
[11:00:05.152]  $ x_FUN        :function (x)  
[11:00:05.152]  $ times        : int 2
[11:00:05.152]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:05.152]  $ stop_if_not  :function (...)  
[11:00:05.152]  $ dim          : NULL
[11:00:05.152]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:05.152]  $ ...          : list()
[11:00:05.152]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:05.152]  - attr(*, "where")=List of 8
[11:00:05.152]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:05.152]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:05.152]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:05.152]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:05.152]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:05.152]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:05.152]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:05.152]   ..$ ...          :<environment: 0x55bbad5bae08> 
[11:00:05.152]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:05.152]  - attr(*, "resolved")= logi FALSE
[11:00:05.152]  - attr(*, "total_size")= num 24454
[11:00:05.157] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:05.158] getGlobalsAndPackagesXApply() ... DONE
[11:00:05.158] Number of futures (= number of chunks): 2
[11:00:05.158] Launching 2 futures (chunks) ...
[11:00:05.158] Chunk #1 of 2 ...
[11:00:05.158]  - Finding globals in 'X' for chunk #1 ...
[11:00:05.158] getGlobalsAndPackages() ...
[11:00:05.158] Searching for globals...
[11:00:05.159] 
[11:00:05.159] Searching for globals ... DONE
[11:00:05.159] - globals: [0] <none>
[11:00:05.159] getGlobalsAndPackages() ... DONE
[11:00:05.159]    + additional globals found: [n=0] 
[11:00:05.159]    + additional namespaces needed: [n=0] 
[11:00:05.159]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:05.159]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:05.159]  - seeds: <none>
[11:00:05.159]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:05.159] getGlobalsAndPackages() ...
[11:00:05.160] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:05.160] Resolving globals: FALSE
[11:00:05.160] Tweak future expression to call with '...' arguments ...
[11:00:05.160] {
[11:00:05.160]     do.call(function(...) {
[11:00:05.160]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:05.160]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:05.160]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:05.160]             on.exit(options(oopts), add = TRUE)
[11:00:05.160]         }
[11:00:05.160]         {
[11:00:05.160]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:05.160]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:05.160]                 ...future.FUN(...future.X_jj, ...)
[11:00:05.160]             })
[11:00:05.160]         }
[11:00:05.160]     }, args = future.call.arguments)
[11:00:05.160] }
[11:00:05.160] Tweak future expression to call with '...' arguments ... DONE
[11:00:05.161] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:05.161] - packages: [1] ‘future.apply’
[11:00:05.161] getGlobalsAndPackages() ... DONE
[11:00:05.161] run() for ‘Future’ ...
[11:00:05.161] - state: ‘created’
[11:00:05.161] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:05.175] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:05.175] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:05.175]   - Field: ‘node’
[11:00:05.176]   - Field: ‘label’
[11:00:05.176]   - Field: ‘local’
[11:00:05.176]   - Field: ‘owner’
[11:00:05.176]   - Field: ‘envir’
[11:00:05.176]   - Field: ‘workers’
[11:00:05.176]   - Field: ‘packages’
[11:00:05.176]   - Field: ‘gc’
[11:00:05.176]   - Field: ‘conditions’
[11:00:05.176]   - Field: ‘persistent’
[11:00:05.176]   - Field: ‘expr’
[11:00:05.176]   - Field: ‘uuid’
[11:00:05.176]   - Field: ‘seed’
[11:00:05.177]   - Field: ‘version’
[11:00:05.177]   - Field: ‘result’
[11:00:05.177]   - Field: ‘asynchronous’
[11:00:05.177]   - Field: ‘calls’
[11:00:05.177]   - Field: ‘globals’
[11:00:05.177]   - Field: ‘stdout’
[11:00:05.177]   - Field: ‘earlySignal’
[11:00:05.177]   - Field: ‘lazy’
[11:00:05.177]   - Field: ‘state’
[11:00:05.177] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:05.177] - Launch lazy future ...
[11:00:05.178] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:05.178] Packages needed by future strategies (n = 0): <none>
[11:00:05.178] {
[11:00:05.178]     {
[11:00:05.178]         {
[11:00:05.178]             ...future.startTime <- base::Sys.time()
[11:00:05.178]             {
[11:00:05.178]                 {
[11:00:05.178]                   {
[11:00:05.178]                     {
[11:00:05.178]                       {
[11:00:05.178]                         base::local({
[11:00:05.178]                           has_future <- base::requireNamespace("future", 
[11:00:05.178]                             quietly = TRUE)
[11:00:05.178]                           if (has_future) {
[11:00:05.178]                             ns <- base::getNamespace("future")
[11:00:05.178]                             version <- ns[[".package"]][["version"]]
[11:00:05.178]                             if (is.null(version)) 
[11:00:05.178]                               version <- utils::packageVersion("future")
[11:00:05.178]                           }
[11:00:05.178]                           else {
[11:00:05.178]                             version <- NULL
[11:00:05.178]                           }
[11:00:05.178]                           if (!has_future || version < "1.8.0") {
[11:00:05.178]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:05.178]                               "", base::R.version$version.string), 
[11:00:05.178]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:05.178]                                 base::R.version$platform, 8 * 
[11:00:05.178]                                   base::.Machine$sizeof.pointer), 
[11:00:05.178]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:05.178]                                 "release", "version")], collapse = " "), 
[11:00:05.178]                               hostname = base::Sys.info()[["nodename"]])
[11:00:05.178]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:05.178]                               info)
[11:00:05.178]                             info <- base::paste(info, collapse = "; ")
[11:00:05.178]                             if (!has_future) {
[11:00:05.178]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:05.178]                                 info)
[11:00:05.178]                             }
[11:00:05.178]                             else {
[11:00:05.178]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:05.178]                                 info, version)
[11:00:05.178]                             }
[11:00:05.178]                             base::stop(msg)
[11:00:05.178]                           }
[11:00:05.178]                         })
[11:00:05.178]                       }
[11:00:05.178]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:05.178]                       base::options(mc.cores = 1L)
[11:00:05.178]                     }
[11:00:05.178]                     base::local({
[11:00:05.178]                       for (pkg in "future.apply") {
[11:00:05.178]                         base::loadNamespace(pkg)
[11:00:05.178]                         base::library(pkg, character.only = TRUE)
[11:00:05.178]                       }
[11:00:05.178]                     })
[11:00:05.178]                   }
[11:00:05.178]                   ...future.strategy.old <- future::plan("list")
[11:00:05.178]                   options(future.plan = NULL)
[11:00:05.178]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:05.178]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:05.178]                 }
[11:00:05.178]                 ...future.workdir <- getwd()
[11:00:05.178]             }
[11:00:05.178]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:05.178]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:05.178]         }
[11:00:05.178]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:05.178]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:05.178]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:05.178]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:05.178]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:05.178]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:05.178]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:05.178]             base::names(...future.oldOptions))
[11:00:05.178]     }
[11:00:05.178]     if (FALSE) {
[11:00:05.178]     }
[11:00:05.178]     else {
[11:00:05.178]         if (TRUE) {
[11:00:05.178]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:05.178]                 open = "w")
[11:00:05.178]         }
[11:00:05.178]         else {
[11:00:05.178]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:05.178]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:05.178]         }
[11:00:05.178]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:05.178]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:05.178]             base::sink(type = "output", split = FALSE)
[11:00:05.178]             base::close(...future.stdout)
[11:00:05.178]         }, add = TRUE)
[11:00:05.178]     }
[11:00:05.178]     ...future.frame <- base::sys.nframe()
[11:00:05.178]     ...future.conditions <- base::list()
[11:00:05.178]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:05.178]     if (FALSE) {
[11:00:05.178]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:05.178]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:05.178]     }
[11:00:05.178]     ...future.result <- base::tryCatch({
[11:00:05.178]         base::withCallingHandlers({
[11:00:05.178]             ...future.value <- base::withVisible(base::local({
[11:00:05.178]                 ...future.makeSendCondition <- base::local({
[11:00:05.178]                   sendCondition <- NULL
[11:00:05.178]                   function(frame = 1L) {
[11:00:05.178]                     if (is.function(sendCondition)) 
[11:00:05.178]                       return(sendCondition)
[11:00:05.178]                     ns <- getNamespace("parallel")
[11:00:05.178]                     if (exists("sendData", mode = "function", 
[11:00:05.178]                       envir = ns)) {
[11:00:05.178]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:05.178]                         envir = ns)
[11:00:05.178]                       envir <- sys.frame(frame)
[11:00:05.178]                       master <- NULL
[11:00:05.178]                       while (!identical(envir, .GlobalEnv) && 
[11:00:05.178]                         !identical(envir, emptyenv())) {
[11:00:05.178]                         if (exists("master", mode = "list", envir = envir, 
[11:00:05.178]                           inherits = FALSE)) {
[11:00:05.178]                           master <- get("master", mode = "list", 
[11:00:05.178]                             envir = envir, inherits = FALSE)
[11:00:05.178]                           if (inherits(master, c("SOCKnode", 
[11:00:05.178]                             "SOCK0node"))) {
[11:00:05.178]                             sendCondition <<- function(cond) {
[11:00:05.178]                               data <- list(type = "VALUE", value = cond, 
[11:00:05.178]                                 success = TRUE)
[11:00:05.178]                               parallel_sendData(master, data)
[11:00:05.178]                             }
[11:00:05.178]                             return(sendCondition)
[11:00:05.178]                           }
[11:00:05.178]                         }
[11:00:05.178]                         frame <- frame + 1L
[11:00:05.178]                         envir <- sys.frame(frame)
[11:00:05.178]                       }
[11:00:05.178]                     }
[11:00:05.178]                     sendCondition <<- function(cond) NULL
[11:00:05.178]                   }
[11:00:05.178]                 })
[11:00:05.178]                 withCallingHandlers({
[11:00:05.178]                   {
[11:00:05.178]                     do.call(function(...) {
[11:00:05.178]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:05.178]                       if (!identical(...future.globals.maxSize.org, 
[11:00:05.178]                         ...future.globals.maxSize)) {
[11:00:05.178]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:05.178]                         on.exit(options(oopts), add = TRUE)
[11:00:05.178]                       }
[11:00:05.178]                       {
[11:00:05.178]                         lapply(seq_along(...future.elements_ii), 
[11:00:05.178]                           FUN = function(jj) {
[11:00:05.178]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:05.178]                             ...future.FUN(...future.X_jj, ...)
[11:00:05.178]                           })
[11:00:05.178]                       }
[11:00:05.178]                     }, args = future.call.arguments)
[11:00:05.178]                   }
[11:00:05.178]                 }, immediateCondition = function(cond) {
[11:00:05.178]                   sendCondition <- ...future.makeSendCondition()
[11:00:05.178]                   sendCondition(cond)
[11:00:05.178]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:05.178]                   {
[11:00:05.178]                     inherits <- base::inherits
[11:00:05.178]                     invokeRestart <- base::invokeRestart
[11:00:05.178]                     is.null <- base::is.null
[11:00:05.178]                     muffled <- FALSE
[11:00:05.178]                     if (inherits(cond, "message")) {
[11:00:05.178]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:05.178]                       if (muffled) 
[11:00:05.178]                         invokeRestart("muffleMessage")
[11:00:05.178]                     }
[11:00:05.178]                     else if (inherits(cond, "warning")) {
[11:00:05.178]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:05.178]                       if (muffled) 
[11:00:05.178]                         invokeRestart("muffleWarning")
[11:00:05.178]                     }
[11:00:05.178]                     else if (inherits(cond, "condition")) {
[11:00:05.178]                       if (!is.null(pattern)) {
[11:00:05.178]                         computeRestarts <- base::computeRestarts
[11:00:05.178]                         grepl <- base::grepl
[11:00:05.178]                         restarts <- computeRestarts(cond)
[11:00:05.178]                         for (restart in restarts) {
[11:00:05.178]                           name <- restart$name
[11:00:05.178]                           if (is.null(name)) 
[11:00:05.178]                             next
[11:00:05.178]                           if (!grepl(pattern, name)) 
[11:00:05.178]                             next
[11:00:05.178]                           invokeRestart(restart)
[11:00:05.178]                           muffled <- TRUE
[11:00:05.178]                           break
[11:00:05.178]                         }
[11:00:05.178]                       }
[11:00:05.178]                     }
[11:00:05.178]                     invisible(muffled)
[11:00:05.178]                   }
[11:00:05.178]                   muffleCondition(cond)
[11:00:05.178]                 })
[11:00:05.178]             }))
[11:00:05.178]             future::FutureResult(value = ...future.value$value, 
[11:00:05.178]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:05.178]                   ...future.rng), globalenv = if (FALSE) 
[11:00:05.178]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:05.178]                     ...future.globalenv.names))
[11:00:05.178]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:05.178]         }, condition = base::local({
[11:00:05.178]             c <- base::c
[11:00:05.178]             inherits <- base::inherits
[11:00:05.178]             invokeRestart <- base::invokeRestart
[11:00:05.178]             length <- base::length
[11:00:05.178]             list <- base::list
[11:00:05.178]             seq.int <- base::seq.int
[11:00:05.178]             signalCondition <- base::signalCondition
[11:00:05.178]             sys.calls <- base::sys.calls
[11:00:05.178]             `[[` <- base::`[[`
[11:00:05.178]             `+` <- base::`+`
[11:00:05.178]             `<<-` <- base::`<<-`
[11:00:05.178]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:05.178]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:05.178]                   3L)]
[11:00:05.178]             }
[11:00:05.178]             function(cond) {
[11:00:05.178]                 is_error <- inherits(cond, "error")
[11:00:05.178]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:05.178]                   NULL)
[11:00:05.178]                 if (is_error) {
[11:00:05.178]                   sessionInformation <- function() {
[11:00:05.178]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:05.178]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:05.178]                       search = base::search(), system = base::Sys.info())
[11:00:05.178]                   }
[11:00:05.178]                   ...future.conditions[[length(...future.conditions) + 
[11:00:05.178]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:05.178]                     cond$call), session = sessionInformation(), 
[11:00:05.178]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:05.178]                   signalCondition(cond)
[11:00:05.178]                 }
[11:00:05.178]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:05.178]                 "immediateCondition"))) {
[11:00:05.178]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:05.178]                   ...future.conditions[[length(...future.conditions) + 
[11:00:05.178]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:05.178]                   if (TRUE && !signal) {
[11:00:05.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:05.178]                     {
[11:00:05.178]                       inherits <- base::inherits
[11:00:05.178]                       invokeRestart <- base::invokeRestart
[11:00:05.178]                       is.null <- base::is.null
[11:00:05.178]                       muffled <- FALSE
[11:00:05.178]                       if (inherits(cond, "message")) {
[11:00:05.178]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:05.178]                         if (muffled) 
[11:00:05.178]                           invokeRestart("muffleMessage")
[11:00:05.178]                       }
[11:00:05.178]                       else if (inherits(cond, "warning")) {
[11:00:05.178]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:05.178]                         if (muffled) 
[11:00:05.178]                           invokeRestart("muffleWarning")
[11:00:05.178]                       }
[11:00:05.178]                       else if (inherits(cond, "condition")) {
[11:00:05.178]                         if (!is.null(pattern)) {
[11:00:05.178]                           computeRestarts <- base::computeRestarts
[11:00:05.178]                           grepl <- base::grepl
[11:00:05.178]                           restarts <- computeRestarts(cond)
[11:00:05.178]                           for (restart in restarts) {
[11:00:05.178]                             name <- restart$name
[11:00:05.178]                             if (is.null(name)) 
[11:00:05.178]                               next
[11:00:05.178]                             if (!grepl(pattern, name)) 
[11:00:05.178]                               next
[11:00:05.178]                             invokeRestart(restart)
[11:00:05.178]                             muffled <- TRUE
[11:00:05.178]                             break
[11:00:05.178]                           }
[11:00:05.178]                         }
[11:00:05.178]                       }
[11:00:05.178]                       invisible(muffled)
[11:00:05.178]                     }
[11:00:05.178]                     muffleCondition(cond, pattern = "^muffle")
[11:00:05.178]                   }
[11:00:05.178]                 }
[11:00:05.178]                 else {
[11:00:05.178]                   if (TRUE) {
[11:00:05.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:05.178]                     {
[11:00:05.178]                       inherits <- base::inherits
[11:00:05.178]                       invokeRestart <- base::invokeRestart
[11:00:05.178]                       is.null <- base::is.null
[11:00:05.178]                       muffled <- FALSE
[11:00:05.178]                       if (inherits(cond, "message")) {
[11:00:05.178]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:05.178]                         if (muffled) 
[11:00:05.178]                           invokeRestart("muffleMessage")
[11:00:05.178]                       }
[11:00:05.178]                       else if (inherits(cond, "warning")) {
[11:00:05.178]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:05.178]                         if (muffled) 
[11:00:05.178]                           invokeRestart("muffleWarning")
[11:00:05.178]                       }
[11:00:05.178]                       else if (inherits(cond, "condition")) {
[11:00:05.178]                         if (!is.null(pattern)) {
[11:00:05.178]                           computeRestarts <- base::computeRestarts
[11:00:05.178]                           grepl <- base::grepl
[11:00:05.178]                           restarts <- computeRestarts(cond)
[11:00:05.178]                           for (restart in restarts) {
[11:00:05.178]                             name <- restart$name
[11:00:05.178]                             if (is.null(name)) 
[11:00:05.178]                               next
[11:00:05.178]                             if (!grepl(pattern, name)) 
[11:00:05.178]                               next
[11:00:05.178]                             invokeRestart(restart)
[11:00:05.178]                             muffled <- TRUE
[11:00:05.178]                             break
[11:00:05.178]                           }
[11:00:05.178]                         }
[11:00:05.178]                       }
[11:00:05.178]                       invisible(muffled)
[11:00:05.178]                     }
[11:00:05.178]                     muffleCondition(cond, pattern = "^muffle")
[11:00:05.178]                   }
[11:00:05.178]                 }
[11:00:05.178]             }
[11:00:05.178]         }))
[11:00:05.178]     }, error = function(ex) {
[11:00:05.178]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:05.178]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:05.178]                 ...future.rng), started = ...future.startTime, 
[11:00:05.178]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:05.178]             version = "1.8"), class = "FutureResult")
[11:00:05.178]     }, finally = {
[11:00:05.178]         if (!identical(...future.workdir, getwd())) 
[11:00:05.178]             setwd(...future.workdir)
[11:00:05.178]         {
[11:00:05.178]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:05.178]                 ...future.oldOptions$nwarnings <- NULL
[11:00:05.178]             }
[11:00:05.178]             base::options(...future.oldOptions)
[11:00:05.178]             if (.Platform$OS.type == "windows") {
[11:00:05.178]                 old_names <- names(...future.oldEnvVars)
[11:00:05.178]                 envs <- base::Sys.getenv()
[11:00:05.178]                 names <- names(envs)
[11:00:05.178]                 common <- intersect(names, old_names)
[11:00:05.178]                 added <- setdiff(names, old_names)
[11:00:05.178]                 removed <- setdiff(old_names, names)
[11:00:05.178]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:05.178]                   envs[common]]
[11:00:05.178]                 NAMES <- toupper(changed)
[11:00:05.178]                 args <- list()
[11:00:05.178]                 for (kk in seq_along(NAMES)) {
[11:00:05.178]                   name <- changed[[kk]]
[11:00:05.178]                   NAME <- NAMES[[kk]]
[11:00:05.178]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:05.178]                     next
[11:00:05.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:05.178]                 }
[11:00:05.178]                 NAMES <- toupper(added)
[11:00:05.178]                 for (kk in seq_along(NAMES)) {
[11:00:05.178]                   name <- added[[kk]]
[11:00:05.178]                   NAME <- NAMES[[kk]]
[11:00:05.178]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:05.178]                     next
[11:00:05.178]                   args[[name]] <- ""
[11:00:05.178]                 }
[11:00:05.178]                 NAMES <- toupper(removed)
[11:00:05.178]                 for (kk in seq_along(NAMES)) {
[11:00:05.178]                   name <- removed[[kk]]
[11:00:05.178]                   NAME <- NAMES[[kk]]
[11:00:05.178]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:05.178]                     next
[11:00:05.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:05.178]                 }
[11:00:05.178]                 if (length(args) > 0) 
[11:00:05.178]                   base::do.call(base::Sys.setenv, args = args)
[11:00:05.178]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:05.178]             }
[11:00:05.178]             else {
[11:00:05.178]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:05.178]             }
[11:00:05.178]             {
[11:00:05.178]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:05.178]                   0L) {
[11:00:05.178]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:05.178]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:05.178]                   base::options(opts)
[11:00:05.178]                 }
[11:00:05.178]                 {
[11:00:05.178]                   {
[11:00:05.178]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:05.178]                     NULL
[11:00:05.178]                   }
[11:00:05.178]                   options(future.plan = NULL)
[11:00:05.178]                   if (is.na(NA_character_)) 
[11:00:05.178]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:05.178]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:05.178]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:05.178]                     .init = FALSE)
[11:00:05.178]                 }
[11:00:05.178]             }
[11:00:05.178]         }
[11:00:05.178]     })
[11:00:05.178]     if (TRUE) {
[11:00:05.178]         base::sink(type = "output", split = FALSE)
[11:00:05.178]         if (TRUE) {
[11:00:05.178]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:05.178]         }
[11:00:05.178]         else {
[11:00:05.178]             ...future.result["stdout"] <- base::list(NULL)
[11:00:05.178]         }
[11:00:05.178]         base::close(...future.stdout)
[11:00:05.178]         ...future.stdout <- NULL
[11:00:05.178]     }
[11:00:05.178]     ...future.result$conditions <- ...future.conditions
[11:00:05.178]     ...future.result$finished <- base::Sys.time()
[11:00:05.178]     ...future.result
[11:00:05.178] }
[11:00:05.181] Exporting 11 global objects (13.78 KiB) to cluster node #1 ...
[11:00:05.181] Exporting ‘...future.FUN’ (4.88 KiB) to cluster node #1 ...
[11:00:05.223] Exporting ‘...future.FUN’ (4.88 KiB) to cluster node #1 ... DONE
[11:00:05.223] Exporting ‘x_FUN’ (483 bytes) to cluster node #1 ...
[11:00:05.223] Exporting ‘x_FUN’ (483 bytes) to cluster node #1 ... DONE
[11:00:05.223] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[11:00:05.224] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[11:00:05.224] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[11:00:05.265] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[11:00:05.265] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[11:00:05.306] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[11:00:05.306] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[11:00:05.306] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[11:00:05.306] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[11:00:05.307] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[11:00:05.307] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[11:00:05.307] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[11:00:05.307] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ...
[11:00:05.308] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ... DONE
[11:00:05.308] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[11:00:05.308] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[11:00:05.308] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[11:00:05.309] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[11:00:05.309] Exporting 11 global objects (13.78 KiB) to cluster node #1 ... DONE
[11:00:05.309] MultisessionFuture started
[11:00:05.309] - Launch lazy future ... done
[11:00:05.309] run() for ‘MultisessionFuture’ ... done
[11:00:05.309] Created future:
[11:00:05.309] MultisessionFuture:
[11:00:05.309] Label: ‘future_vapply-1’
[11:00:05.309] Expression:
[11:00:05.309] {
[11:00:05.309]     do.call(function(...) {
[11:00:05.309]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:05.309]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:05.309]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:05.309]             on.exit(options(oopts), add = TRUE)
[11:00:05.309]         }
[11:00:05.309]         {
[11:00:05.309]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:05.309]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:05.309]                 ...future.FUN(...future.X_jj, ...)
[11:00:05.309]             })
[11:00:05.309]         }
[11:00:05.309]     }, args = future.call.arguments)
[11:00:05.309] }
[11:00:05.309] Lazy evaluation: FALSE
[11:00:05.309] Asynchronous evaluation: TRUE
[11:00:05.309] Local evaluation: TRUE
[11:00:05.309] Environment: R_GlobalEnv
[11:00:05.309] Capture standard output: TRUE
[11:00:05.309] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:05.309] Globals: 11 objects totaling 13.57 KiB (function ‘...future.FUN’ of 4.88 KiB, function ‘x_FUN’ of 483 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:05.309] Packages: 1 packages (‘future.apply’)
[11:00:05.309] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:05.309] Resolved: FALSE
[11:00:05.309] Value: <not collected>
[11:00:05.309] Conditions captured: <none>
[11:00:05.309] Early signaling: FALSE
[11:00:05.309] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:05.309] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:05.321] Chunk #1 of 2 ... DONE
[11:00:05.321] Chunk #2 of 2 ...
[11:00:05.321]  - Finding globals in 'X' for chunk #2 ...
[11:00:05.321] getGlobalsAndPackages() ...
[11:00:05.321] Searching for globals...
[11:00:05.322] 
[11:00:05.322] Searching for globals ... DONE
[11:00:05.322] - globals: [0] <none>
[11:00:05.322] getGlobalsAndPackages() ... DONE
[11:00:05.322]    + additional globals found: [n=0] 
[11:00:05.322]    + additional namespaces needed: [n=0] 
[11:00:05.322]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:05.322]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:05.322]  - seeds: <none>
[11:00:05.322]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:05.322] getGlobalsAndPackages() ...
[11:00:05.323] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:05.323] Resolving globals: FALSE
[11:00:05.323] Tweak future expression to call with '...' arguments ...
[11:00:05.323] {
[11:00:05.323]     do.call(function(...) {
[11:00:05.323]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:05.323]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:05.323]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:05.323]             on.exit(options(oopts), add = TRUE)
[11:00:05.323]         }
[11:00:05.323]         {
[11:00:05.323]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:05.323]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:05.323]                 ...future.FUN(...future.X_jj, ...)
[11:00:05.323]             })
[11:00:05.323]         }
[11:00:05.323]     }, args = future.call.arguments)
[11:00:05.323] }
[11:00:05.323] Tweak future expression to call with '...' arguments ... DONE
[11:00:05.324] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:05.324] - packages: [1] ‘future.apply’
[11:00:05.324] getGlobalsAndPackages() ... DONE
[11:00:05.324] run() for ‘Future’ ...
[11:00:05.324] - state: ‘created’
[11:00:05.324] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:05.338] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:05.338] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:05.338]   - Field: ‘node’
[11:00:05.338]   - Field: ‘label’
[11:00:05.338]   - Field: ‘local’
[11:00:05.338]   - Field: ‘owner’
[11:00:05.338]   - Field: ‘envir’
[11:00:05.338]   - Field: ‘workers’
[11:00:05.339]   - Field: ‘packages’
[11:00:05.339]   - Field: ‘gc’
[11:00:05.339]   - Field: ‘conditions’
[11:00:05.339]   - Field: ‘persistent’
[11:00:05.339]   - Field: ‘expr’
[11:00:05.339]   - Field: ‘uuid’
[11:00:05.339]   - Field: ‘seed’
[11:00:05.339]   - Field: ‘version’
[11:00:05.339]   - Field: ‘result’
[11:00:05.339]   - Field: ‘asynchronous’
[11:00:05.339]   - Field: ‘calls’
[11:00:05.339]   - Field: ‘globals’
[11:00:05.340]   - Field: ‘stdout’
[11:00:05.340]   - Field: ‘earlySignal’
[11:00:05.340]   - Field: ‘lazy’
[11:00:05.340]   - Field: ‘state’
[11:00:05.340] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:05.340] - Launch lazy future ...
[11:00:05.340] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:05.340] Packages needed by future strategies (n = 0): <none>
[11:00:05.341] {
[11:00:05.341]     {
[11:00:05.341]         {
[11:00:05.341]             ...future.startTime <- base::Sys.time()
[11:00:05.341]             {
[11:00:05.341]                 {
[11:00:05.341]                   {
[11:00:05.341]                     {
[11:00:05.341]                       {
[11:00:05.341]                         base::local({
[11:00:05.341]                           has_future <- base::requireNamespace("future", 
[11:00:05.341]                             quietly = TRUE)
[11:00:05.341]                           if (has_future) {
[11:00:05.341]                             ns <- base::getNamespace("future")
[11:00:05.341]                             version <- ns[[".package"]][["version"]]
[11:00:05.341]                             if (is.null(version)) 
[11:00:05.341]                               version <- utils::packageVersion("future")
[11:00:05.341]                           }
[11:00:05.341]                           else {
[11:00:05.341]                             version <- NULL
[11:00:05.341]                           }
[11:00:05.341]                           if (!has_future || version < "1.8.0") {
[11:00:05.341]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:05.341]                               "", base::R.version$version.string), 
[11:00:05.341]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:05.341]                                 base::R.version$platform, 8 * 
[11:00:05.341]                                   base::.Machine$sizeof.pointer), 
[11:00:05.341]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:05.341]                                 "release", "version")], collapse = " "), 
[11:00:05.341]                               hostname = base::Sys.info()[["nodename"]])
[11:00:05.341]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:05.341]                               info)
[11:00:05.341]                             info <- base::paste(info, collapse = "; ")
[11:00:05.341]                             if (!has_future) {
[11:00:05.341]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:05.341]                                 info)
[11:00:05.341]                             }
[11:00:05.341]                             else {
[11:00:05.341]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:05.341]                                 info, version)
[11:00:05.341]                             }
[11:00:05.341]                             base::stop(msg)
[11:00:05.341]                           }
[11:00:05.341]                         })
[11:00:05.341]                       }
[11:00:05.341]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:05.341]                       base::options(mc.cores = 1L)
[11:00:05.341]                     }
[11:00:05.341]                     base::local({
[11:00:05.341]                       for (pkg in "future.apply") {
[11:00:05.341]                         base::loadNamespace(pkg)
[11:00:05.341]                         base::library(pkg, character.only = TRUE)
[11:00:05.341]                       }
[11:00:05.341]                     })
[11:00:05.341]                   }
[11:00:05.341]                   ...future.strategy.old <- future::plan("list")
[11:00:05.341]                   options(future.plan = NULL)
[11:00:05.341]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:05.341]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:05.341]                 }
[11:00:05.341]                 ...future.workdir <- getwd()
[11:00:05.341]             }
[11:00:05.341]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:05.341]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:05.341]         }
[11:00:05.341]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:05.341]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:05.341]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:05.341]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:05.341]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:05.341]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:05.341]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:05.341]             base::names(...future.oldOptions))
[11:00:05.341]     }
[11:00:05.341]     if (FALSE) {
[11:00:05.341]     }
[11:00:05.341]     else {
[11:00:05.341]         if (TRUE) {
[11:00:05.341]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:05.341]                 open = "w")
[11:00:05.341]         }
[11:00:05.341]         else {
[11:00:05.341]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:05.341]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:05.341]         }
[11:00:05.341]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:05.341]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:05.341]             base::sink(type = "output", split = FALSE)
[11:00:05.341]             base::close(...future.stdout)
[11:00:05.341]         }, add = TRUE)
[11:00:05.341]     }
[11:00:05.341]     ...future.frame <- base::sys.nframe()
[11:00:05.341]     ...future.conditions <- base::list()
[11:00:05.341]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:05.341]     if (FALSE) {
[11:00:05.341]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:05.341]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:05.341]     }
[11:00:05.341]     ...future.result <- base::tryCatch({
[11:00:05.341]         base::withCallingHandlers({
[11:00:05.341]             ...future.value <- base::withVisible(base::local({
[11:00:05.341]                 ...future.makeSendCondition <- base::local({
[11:00:05.341]                   sendCondition <- NULL
[11:00:05.341]                   function(frame = 1L) {
[11:00:05.341]                     if (is.function(sendCondition)) 
[11:00:05.341]                       return(sendCondition)
[11:00:05.341]                     ns <- getNamespace("parallel")
[11:00:05.341]                     if (exists("sendData", mode = "function", 
[11:00:05.341]                       envir = ns)) {
[11:00:05.341]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:05.341]                         envir = ns)
[11:00:05.341]                       envir <- sys.frame(frame)
[11:00:05.341]                       master <- NULL
[11:00:05.341]                       while (!identical(envir, .GlobalEnv) && 
[11:00:05.341]                         !identical(envir, emptyenv())) {
[11:00:05.341]                         if (exists("master", mode = "list", envir = envir, 
[11:00:05.341]                           inherits = FALSE)) {
[11:00:05.341]                           master <- get("master", mode = "list", 
[11:00:05.341]                             envir = envir, inherits = FALSE)
[11:00:05.341]                           if (inherits(master, c("SOCKnode", 
[11:00:05.341]                             "SOCK0node"))) {
[11:00:05.341]                             sendCondition <<- function(cond) {
[11:00:05.341]                               data <- list(type = "VALUE", value = cond, 
[11:00:05.341]                                 success = TRUE)
[11:00:05.341]                               parallel_sendData(master, data)
[11:00:05.341]                             }
[11:00:05.341]                             return(sendCondition)
[11:00:05.341]                           }
[11:00:05.341]                         }
[11:00:05.341]                         frame <- frame + 1L
[11:00:05.341]                         envir <- sys.frame(frame)
[11:00:05.341]                       }
[11:00:05.341]                     }
[11:00:05.341]                     sendCondition <<- function(cond) NULL
[11:00:05.341]                   }
[11:00:05.341]                 })
[11:00:05.341]                 withCallingHandlers({
[11:00:05.341]                   {
[11:00:05.341]                     do.call(function(...) {
[11:00:05.341]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:05.341]                       if (!identical(...future.globals.maxSize.org, 
[11:00:05.341]                         ...future.globals.maxSize)) {
[11:00:05.341]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:05.341]                         on.exit(options(oopts), add = TRUE)
[11:00:05.341]                       }
[11:00:05.341]                       {
[11:00:05.341]                         lapply(seq_along(...future.elements_ii), 
[11:00:05.341]                           FUN = function(jj) {
[11:00:05.341]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:05.341]                             ...future.FUN(...future.X_jj, ...)
[11:00:05.341]                           })
[11:00:05.341]                       }
[11:00:05.341]                     }, args = future.call.arguments)
[11:00:05.341]                   }
[11:00:05.341]                 }, immediateCondition = function(cond) {
[11:00:05.341]                   sendCondition <- ...future.makeSendCondition()
[11:00:05.341]                   sendCondition(cond)
[11:00:05.341]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:05.341]                   {
[11:00:05.341]                     inherits <- base::inherits
[11:00:05.341]                     invokeRestart <- base::invokeRestart
[11:00:05.341]                     is.null <- base::is.null
[11:00:05.341]                     muffled <- FALSE
[11:00:05.341]                     if (inherits(cond, "message")) {
[11:00:05.341]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:05.341]                       if (muffled) 
[11:00:05.341]                         invokeRestart("muffleMessage")
[11:00:05.341]                     }
[11:00:05.341]                     else if (inherits(cond, "warning")) {
[11:00:05.341]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:05.341]                       if (muffled) 
[11:00:05.341]                         invokeRestart("muffleWarning")
[11:00:05.341]                     }
[11:00:05.341]                     else if (inherits(cond, "condition")) {
[11:00:05.341]                       if (!is.null(pattern)) {
[11:00:05.341]                         computeRestarts <- base::computeRestarts
[11:00:05.341]                         grepl <- base::grepl
[11:00:05.341]                         restarts <- computeRestarts(cond)
[11:00:05.341]                         for (restart in restarts) {
[11:00:05.341]                           name <- restart$name
[11:00:05.341]                           if (is.null(name)) 
[11:00:05.341]                             next
[11:00:05.341]                           if (!grepl(pattern, name)) 
[11:00:05.341]                             next
[11:00:05.341]                           invokeRestart(restart)
[11:00:05.341]                           muffled <- TRUE
[11:00:05.341]                           break
[11:00:05.341]                         }
[11:00:05.341]                       }
[11:00:05.341]                     }
[11:00:05.341]                     invisible(muffled)
[11:00:05.341]                   }
[11:00:05.341]                   muffleCondition(cond)
[11:00:05.341]                 })
[11:00:05.341]             }))
[11:00:05.341]             future::FutureResult(value = ...future.value$value, 
[11:00:05.341]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:05.341]                   ...future.rng), globalenv = if (FALSE) 
[11:00:05.341]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:05.341]                     ...future.globalenv.names))
[11:00:05.341]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:05.341]         }, condition = base::local({
[11:00:05.341]             c <- base::c
[11:00:05.341]             inherits <- base::inherits
[11:00:05.341]             invokeRestart <- base::invokeRestart
[11:00:05.341]             length <- base::length
[11:00:05.341]             list <- base::list
[11:00:05.341]             seq.int <- base::seq.int
[11:00:05.341]             signalCondition <- base::signalCondition
[11:00:05.341]             sys.calls <- base::sys.calls
[11:00:05.341]             `[[` <- base::`[[`
[11:00:05.341]             `+` <- base::`+`
[11:00:05.341]             `<<-` <- base::`<<-`
[11:00:05.341]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:05.341]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:05.341]                   3L)]
[11:00:05.341]             }
[11:00:05.341]             function(cond) {
[11:00:05.341]                 is_error <- inherits(cond, "error")
[11:00:05.341]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:05.341]                   NULL)
[11:00:05.341]                 if (is_error) {
[11:00:05.341]                   sessionInformation <- function() {
[11:00:05.341]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:05.341]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:05.341]                       search = base::search(), system = base::Sys.info())
[11:00:05.341]                   }
[11:00:05.341]                   ...future.conditions[[length(...future.conditions) + 
[11:00:05.341]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:05.341]                     cond$call), session = sessionInformation(), 
[11:00:05.341]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:05.341]                   signalCondition(cond)
[11:00:05.341]                 }
[11:00:05.341]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:05.341]                 "immediateCondition"))) {
[11:00:05.341]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:05.341]                   ...future.conditions[[length(...future.conditions) + 
[11:00:05.341]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:05.341]                   if (TRUE && !signal) {
[11:00:05.341]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:05.341]                     {
[11:00:05.341]                       inherits <- base::inherits
[11:00:05.341]                       invokeRestart <- base::invokeRestart
[11:00:05.341]                       is.null <- base::is.null
[11:00:05.341]                       muffled <- FALSE
[11:00:05.341]                       if (inherits(cond, "message")) {
[11:00:05.341]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:05.341]                         if (muffled) 
[11:00:05.341]                           invokeRestart("muffleMessage")
[11:00:05.341]                       }
[11:00:05.341]                       else if (inherits(cond, "warning")) {
[11:00:05.341]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:05.341]                         if (muffled) 
[11:00:05.341]                           invokeRestart("muffleWarning")
[11:00:05.341]                       }
[11:00:05.341]                       else if (inherits(cond, "condition")) {
[11:00:05.341]                         if (!is.null(pattern)) {
[11:00:05.341]                           computeRestarts <- base::computeRestarts
[11:00:05.341]                           grepl <- base::grepl
[11:00:05.341]                           restarts <- computeRestarts(cond)
[11:00:05.341]                           for (restart in restarts) {
[11:00:05.341]                             name <- restart$name
[11:00:05.341]                             if (is.null(name)) 
[11:00:05.341]                               next
[11:00:05.341]                             if (!grepl(pattern, name)) 
[11:00:05.341]                               next
[11:00:05.341]                             invokeRestart(restart)
[11:00:05.341]                             muffled <- TRUE
[11:00:05.341]                             break
[11:00:05.341]                           }
[11:00:05.341]                         }
[11:00:05.341]                       }
[11:00:05.341]                       invisible(muffled)
[11:00:05.341]                     }
[11:00:05.341]                     muffleCondition(cond, pattern = "^muffle")
[11:00:05.341]                   }
[11:00:05.341]                 }
[11:00:05.341]                 else {
[11:00:05.341]                   if (TRUE) {
[11:00:05.341]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:05.341]                     {
[11:00:05.341]                       inherits <- base::inherits
[11:00:05.341]                       invokeRestart <- base::invokeRestart
[11:00:05.341]                       is.null <- base::is.null
[11:00:05.341]                       muffled <- FALSE
[11:00:05.341]                       if (inherits(cond, "message")) {
[11:00:05.341]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:05.341]                         if (muffled) 
[11:00:05.341]                           invokeRestart("muffleMessage")
[11:00:05.341]                       }
[11:00:05.341]                       else if (inherits(cond, "warning")) {
[11:00:05.341]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:05.341]                         if (muffled) 
[11:00:05.341]                           invokeRestart("muffleWarning")
[11:00:05.341]                       }
[11:00:05.341]                       else if (inherits(cond, "condition")) {
[11:00:05.341]                         if (!is.null(pattern)) {
[11:00:05.341]                           computeRestarts <- base::computeRestarts
[11:00:05.341]                           grepl <- base::grepl
[11:00:05.341]                           restarts <- computeRestarts(cond)
[11:00:05.341]                           for (restart in restarts) {
[11:00:05.341]                             name <- restart$name
[11:00:05.341]                             if (is.null(name)) 
[11:00:05.341]                               next
[11:00:05.341]                             if (!grepl(pattern, name)) 
[11:00:05.341]                               next
[11:00:05.341]                             invokeRestart(restart)
[11:00:05.341]                             muffled <- TRUE
[11:00:05.341]                             break
[11:00:05.341]                           }
[11:00:05.341]                         }
[11:00:05.341]                       }
[11:00:05.341]                       invisible(muffled)
[11:00:05.341]                     }
[11:00:05.341]                     muffleCondition(cond, pattern = "^muffle")
[11:00:05.341]                   }
[11:00:05.341]                 }
[11:00:05.341]             }
[11:00:05.341]         }))
[11:00:05.341]     }, error = function(ex) {
[11:00:05.341]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:05.341]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:05.341]                 ...future.rng), started = ...future.startTime, 
[11:00:05.341]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:05.341]             version = "1.8"), class = "FutureResult")
[11:00:05.341]     }, finally = {
[11:00:05.341]         if (!identical(...future.workdir, getwd())) 
[11:00:05.341]             setwd(...future.workdir)
[11:00:05.341]         {
[11:00:05.341]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:05.341]                 ...future.oldOptions$nwarnings <- NULL
[11:00:05.341]             }
[11:00:05.341]             base::options(...future.oldOptions)
[11:00:05.341]             if (.Platform$OS.type == "windows") {
[11:00:05.341]                 old_names <- names(...future.oldEnvVars)
[11:00:05.341]                 envs <- base::Sys.getenv()
[11:00:05.341]                 names <- names(envs)
[11:00:05.341]                 common <- intersect(names, old_names)
[11:00:05.341]                 added <- setdiff(names, old_names)
[11:00:05.341]                 removed <- setdiff(old_names, names)
[11:00:05.341]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:05.341]                   envs[common]]
[11:00:05.341]                 NAMES <- toupper(changed)
[11:00:05.341]                 args <- list()
[11:00:05.341]                 for (kk in seq_along(NAMES)) {
[11:00:05.341]                   name <- changed[[kk]]
[11:00:05.341]                   NAME <- NAMES[[kk]]
[11:00:05.341]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:05.341]                     next
[11:00:05.341]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:05.341]                 }
[11:00:05.341]                 NAMES <- toupper(added)
[11:00:05.341]                 for (kk in seq_along(NAMES)) {
[11:00:05.341]                   name <- added[[kk]]
[11:00:05.341]                   NAME <- NAMES[[kk]]
[11:00:05.341]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:05.341]                     next
[11:00:05.341]                   args[[name]] <- ""
[11:00:05.341]                 }
[11:00:05.341]                 NAMES <- toupper(removed)
[11:00:05.341]                 for (kk in seq_along(NAMES)) {
[11:00:05.341]                   name <- removed[[kk]]
[11:00:05.341]                   NAME <- NAMES[[kk]]
[11:00:05.341]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:05.341]                     next
[11:00:05.341]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:05.341]                 }
[11:00:05.341]                 if (length(args) > 0) 
[11:00:05.341]                   base::do.call(base::Sys.setenv, args = args)
[11:00:05.341]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:05.341]             }
[11:00:05.341]             else {
[11:00:05.341]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:05.341]             }
[11:00:05.341]             {
[11:00:05.341]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:05.341]                   0L) {
[11:00:05.341]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:05.341]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:05.341]                   base::options(opts)
[11:00:05.341]                 }
[11:00:05.341]                 {
[11:00:05.341]                   {
[11:00:05.341]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:05.341]                     NULL
[11:00:05.341]                   }
[11:00:05.341]                   options(future.plan = NULL)
[11:00:05.341]                   if (is.na(NA_character_)) 
[11:00:05.341]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:05.341]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:05.341]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:05.341]                     .init = FALSE)
[11:00:05.341]                 }
[11:00:05.341]             }
[11:00:05.341]         }
[11:00:05.341]     })
[11:00:05.341]     if (TRUE) {
[11:00:05.341]         base::sink(type = "output", split = FALSE)
[11:00:05.341]         if (TRUE) {
[11:00:05.341]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:05.341]         }
[11:00:05.341]         else {
[11:00:05.341]             ...future.result["stdout"] <- base::list(NULL)
[11:00:05.341]         }
[11:00:05.341]         base::close(...future.stdout)
[11:00:05.341]         ...future.stdout <- NULL
[11:00:05.341]     }
[11:00:05.341]     ...future.result$conditions <- ...future.conditions
[11:00:05.341]     ...future.result$finished <- base::Sys.time()
[11:00:05.341]     ...future.result
[11:00:05.341] }
[11:00:05.344] Exporting 11 global objects (13.78 KiB) to cluster node #2 ...
[11:00:05.344] Exporting ‘...future.FUN’ (4.88 KiB) to cluster node #2 ...
[11:00:05.385] Exporting ‘...future.FUN’ (4.88 KiB) to cluster node #2 ... DONE
[11:00:05.385] Exporting ‘x_FUN’ (483 bytes) to cluster node #2 ...
[11:00:05.385] Exporting ‘x_FUN’ (483 bytes) to cluster node #2 ... DONE
[11:00:05.385] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[11:00:05.386] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[11:00:05.386] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[11:00:05.426] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[11:00:05.427] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[11:00:05.468] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[11:00:05.468] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[11:00:05.468] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[11:00:05.468] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[11:00:05.469] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[11:00:05.469] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[11:00:05.469] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[11:00:05.469] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ...
[11:00:05.470] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ... DONE
[11:00:05.470] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[11:00:05.470] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[11:00:05.470] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[11:00:05.471] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[11:00:05.471] Exporting 11 global objects (13.78 KiB) to cluster node #2 ... DONE
[11:00:05.471] MultisessionFuture started
[11:00:05.471] - Launch lazy future ... done
[11:00:05.471] run() for ‘MultisessionFuture’ ... done
[11:00:05.472] Created future:
[11:00:05.472] MultisessionFuture:
[11:00:05.472] Label: ‘future_vapply-2’
[11:00:05.472] Expression:
[11:00:05.472] {
[11:00:05.472]     do.call(function(...) {
[11:00:05.472]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:05.472]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:05.472]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:05.472]             on.exit(options(oopts), add = TRUE)
[11:00:05.472]         }
[11:00:05.472]         {
[11:00:05.472]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:05.472]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:05.472]                 ...future.FUN(...future.X_jj, ...)
[11:00:05.472]             })
[11:00:05.472]         }
[11:00:05.472]     }, args = future.call.arguments)
[11:00:05.472] }
[11:00:05.472] Lazy evaluation: FALSE
[11:00:05.472] Asynchronous evaluation: TRUE
[11:00:05.472] Local evaluation: TRUE
[11:00:05.472] Environment: R_GlobalEnv
[11:00:05.472] Capture standard output: TRUE
[11:00:05.472] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:05.472] Globals: 11 objects totaling 13.57 KiB (function ‘...future.FUN’ of 4.88 KiB, function ‘x_FUN’ of 483 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:05.472] Packages: 1 packages (‘future.apply’)
[11:00:05.472] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:05.472] Resolved: FALSE
[11:00:05.472] Value: <not collected>
[11:00:05.472] Conditions captured: <none>
[11:00:05.472] Early signaling: FALSE
[11:00:05.472] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:05.472] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:05.483] Chunk #2 of 2 ... DONE
[11:00:05.483] Launching 2 futures (chunks) ... DONE
[11:00:05.483] Resolving 2 futures (chunks) ...
[11:00:05.483] resolve() on list ...
[11:00:05.483]  recursive: 0
[11:00:05.484]  length: 2
[11:00:05.484] 
[11:00:05.484] receiveMessageFromWorker() for ClusterFuture ...
[11:00:05.484] - Validating connection of MultisessionFuture
[11:00:05.484] - received message: FutureResult
[11:00:05.484] - Received FutureResult
[11:00:05.485] - Erased future from FutureRegistry
[11:00:05.485] result() for ClusterFuture ...
[11:00:05.485] - result already collected: FutureResult
[11:00:05.485] result() for ClusterFuture ... done
[11:00:05.485] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:05.485] Future #1
[11:00:05.485] result() for ClusterFuture ...
[11:00:05.485] - result already collected: FutureResult
[11:00:05.485] result() for ClusterFuture ... done
[11:00:05.485] result() for ClusterFuture ...
[11:00:05.485] - result already collected: FutureResult
[11:00:05.485] result() for ClusterFuture ... done
[11:00:05.486] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:00:05.486] - nx: 2
[11:00:05.486] - relay: TRUE
[11:00:05.486] - stdout: TRUE
[11:00:05.486] - signal: TRUE
[11:00:05.486] - resignal: FALSE
[11:00:05.486] - force: TRUE
[11:00:05.486] - relayed: [n=2] FALSE, FALSE
[11:00:05.486] - queued futures: [n=2] FALSE, FALSE
[11:00:05.486]  - until=1
[11:00:05.486]  - relaying element #1
[11:00:05.486] result() for ClusterFuture ...
[11:00:05.487] - result already collected: FutureResult
[11:00:05.487] result() for ClusterFuture ... done
[11:00:05.487] result() for ClusterFuture ...
[11:00:05.487] - result already collected: FutureResult
[11:00:05.487] result() for ClusterFuture ... done
[11:00:05.487] result() for ClusterFuture ...
[11:00:05.487] - result already collected: FutureResult
[11:00:05.487] result() for ClusterFuture ... done
[11:00:05.487] result() for ClusterFuture ...
[11:00:05.487] - result already collected: FutureResult
[11:00:05.487] result() for ClusterFuture ... done
[11:00:05.487] - relayed: [n=2] TRUE, FALSE
[11:00:05.487] - queued futures: [n=2] TRUE, FALSE
[11:00:05.488] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:00:05.488]  length: 1 (resolved future 1)
[11:00:05.513] receiveMessageFromWorker() for ClusterFuture ...
[11:00:05.513] - Validating connection of MultisessionFuture
[11:00:05.514] - received message: FutureResult
[11:00:05.514] - Received FutureResult
[11:00:05.514] - Erased future from FutureRegistry
[11:00:05.514] result() for ClusterFuture ...
[11:00:05.514] - result already collected: FutureResult
[11:00:05.514] result() for ClusterFuture ... done
[11:00:05.514] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:05.514] Future #2
[11:00:05.514] result() for ClusterFuture ...
[11:00:05.514] - result already collected: FutureResult
[11:00:05.515] result() for ClusterFuture ... done
[11:00:05.515] result() for ClusterFuture ...
[11:00:05.515] - result already collected: FutureResult
[11:00:05.515] result() for ClusterFuture ... done
[11:00:05.515] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:00:05.515] - nx: 2
[11:00:05.515] - relay: TRUE
[11:00:05.515] - stdout: TRUE
[11:00:05.515] - signal: TRUE
[11:00:05.515] - resignal: FALSE
[11:00:05.515] - force: TRUE
[11:00:05.515] - relayed: [n=2] TRUE, FALSE
[11:00:05.516] - queued futures: [n=2] TRUE, FALSE
[11:00:05.516]  - until=2
[11:00:05.516]  - relaying element #2
[11:00:05.516] result() for ClusterFuture ...
[11:00:05.516] - result already collected: FutureResult
[11:00:05.516] result() for ClusterFuture ... done
[11:00:05.516] result() for ClusterFuture ...
[11:00:05.516] - result already collected: FutureResult
[11:00:05.516] result() for ClusterFuture ... done
[11:00:05.516] result() for ClusterFuture ...
[11:00:05.516] - result already collected: FutureResult
[11:00:05.516] result() for ClusterFuture ... done
[11:00:05.517] result() for ClusterFuture ...
[11:00:05.517] - result already collected: FutureResult
[11:00:05.517] result() for ClusterFuture ... done
[11:00:05.517] - relayed: [n=2] TRUE, TRUE
[11:00:05.517] - queued futures: [n=2] TRUE, TRUE
[11:00:05.517] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:00:05.517]  length: 0 (resolved future 2)
[11:00:05.517] Relaying remaining futures
[11:00:05.517] signalConditionsASAP(NULL, pos=0) ...
[11:00:05.517] - nx: 2
[11:00:05.517] - relay: TRUE
[11:00:05.517] - stdout: TRUE
[11:00:05.517] - signal: TRUE
[11:00:05.518] - resignal: FALSE
[11:00:05.518] - force: TRUE
[11:00:05.518] - relayed: [n=2] TRUE, TRUE
[11:00:05.518] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:05.518] - relayed: [n=2] TRUE, TRUE
[11:00:05.518] - queued futures: [n=2] TRUE, TRUE
[11:00:05.518] signalConditionsASAP(NULL, pos=0) ... done
[11:00:05.518] resolve() on list ... DONE
[11:00:05.518] result() for ClusterFuture ...
[11:00:05.518] - result already collected: FutureResult
[11:00:05.518] result() for ClusterFuture ... done
[11:00:05.519] result() for ClusterFuture ...
[11:00:05.519] - result already collected: FutureResult
[11:00:05.519] result() for ClusterFuture ... done
[11:00:05.519] result() for ClusterFuture ...
[11:00:05.519] - result already collected: FutureResult
[11:00:05.519] result() for ClusterFuture ... done
[11:00:05.519] result() for ClusterFuture ...
[11:00:05.519] - result already collected: FutureResult
[11:00:05.519] result() for ClusterFuture ... done
[11:00:05.519]  - Number of value chunks collected: 2
[11:00:05.519] Resolving 2 futures (chunks) ... DONE
[11:00:05.519] Reducing values from 2 chunks ...
[11:00:05.519]  - Number of values collected after concatenation: 10
[11:00:05.520]  - Number of values expected: 10
[11:00:05.520] Reducing values from 2 chunks ... DONE
[11:00:05.520] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[11:00:05.521] future_lapply() ...
[11:00:05.524] Number of chunks: 2
[11:00:05.524] getGlobalsAndPackagesXApply() ...
[11:00:05.524]  - future.globals: TRUE
[11:00:05.524] getGlobalsAndPackages() ...
[11:00:05.524] Searching for globals...
[11:00:05.527] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[11:00:05.528] Searching for globals ... DONE
[11:00:05.528] Resolving globals: FALSE
[11:00:05.528] The total size of the 7 globals is 13.59 KiB (13914 bytes)
[11:00:05.529] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.59 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.06 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:05.529] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:05.529] - packages: [1] ‘future.apply’
[11:00:05.529] getGlobalsAndPackages() ... DONE
[11:00:05.529]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:05.529]  - needed namespaces: [n=1] ‘future.apply’
[11:00:05.530] Finding globals ... DONE
[11:00:05.530]  - use_args: TRUE
[11:00:05.530]  - Getting '...' globals ...
[11:00:05.532] resolve() on list ...
[11:00:05.532]  recursive: 0
[11:00:05.532]  length: 1
[11:00:05.532]  elements: ‘...’
[11:00:05.532]  length: 0 (resolved future 1)
[11:00:05.532] resolve() on list ... DONE
[11:00:05.532]    - '...' content: [n=0] 
[11:00:05.533] List of 1
[11:00:05.533]  $ ...: list()
[11:00:05.533]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:05.533]  - attr(*, "where")=List of 1
[11:00:05.533]   ..$ ...:<environment: 0x55bbb010d018> 
[11:00:05.533]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:05.533]  - attr(*, "resolved")= logi TRUE
[11:00:05.533]  - attr(*, "total_size")= num NA
[11:00:05.535]  - Getting '...' globals ... DONE
[11:00:05.535] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:05.535] List of 8
[11:00:05.535]  $ ...future.FUN:function (x, ...)  
[11:00:05.535]  $ x_FUN        :function (x)  
[11:00:05.535]  $ times        : int 4
[11:00:05.535]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:05.535]  $ stop_if_not  :function (...)  
[11:00:05.535]  $ dim          : int [1:2] 2 2
[11:00:05.535]  $ valid_types  : chr [1:2] "logical" "integer"
[11:00:05.535]  $ ...          : list()
[11:00:05.535]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:05.535]  - attr(*, "where")=List of 8
[11:00:05.535]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:05.535]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:05.535]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:05.535]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:05.535]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:05.535]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:05.535]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:05.535]   ..$ ...          :<environment: 0x55bbb010d018> 
[11:00:05.535]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:05.535]  - attr(*, "resolved")= logi FALSE
[11:00:05.535]  - attr(*, "total_size")= num 24886
[11:00:05.540] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:05.540] getGlobalsAndPackagesXApply() ... DONE
[11:00:05.541] Number of futures (= number of chunks): 2
[11:00:05.541] Launching 2 futures (chunks) ...
[11:00:05.541] Chunk #1 of 2 ...
[11:00:05.541]  - Finding globals in 'X' for chunk #1 ...
[11:00:05.541] getGlobalsAndPackages() ...
[11:00:05.541] Searching for globals...
[11:00:05.541] 
[11:00:05.541] Searching for globals ... DONE
[11:00:05.541] - globals: [0] <none>
[11:00:05.542] getGlobalsAndPackages() ... DONE
[11:00:05.542]    + additional globals found: [n=0] 
[11:00:05.542]    + additional namespaces needed: [n=0] 
[11:00:05.542]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:05.542]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:05.542]  - seeds: <none>
[11:00:05.542]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:05.542] getGlobalsAndPackages() ...
[11:00:05.542] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:05.542] Resolving globals: FALSE
[11:00:05.543] Tweak future expression to call with '...' arguments ...
[11:00:05.543] {
[11:00:05.543]     do.call(function(...) {
[11:00:05.543]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:05.543]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:05.543]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:05.543]             on.exit(options(oopts), add = TRUE)
[11:00:05.543]         }
[11:00:05.543]         {
[11:00:05.543]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:05.543]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:05.543]                 ...future.FUN(...future.X_jj, ...)
[11:00:05.543]             })
[11:00:05.543]         }
[11:00:05.543]     }, args = future.call.arguments)
[11:00:05.543] }
[11:00:05.543] Tweak future expression to call with '...' arguments ... DONE
[11:00:05.543] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:05.543] - packages: [1] ‘future.apply’
[11:00:05.544] getGlobalsAndPackages() ... DONE
[11:00:05.544] run() for ‘Future’ ...
[11:00:05.544] - state: ‘created’
[11:00:05.544] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:05.559] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:05.559] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:05.559]   - Field: ‘node’
[11:00:05.559]   - Field: ‘label’
[11:00:05.560]   - Field: ‘local’
[11:00:05.560]   - Field: ‘owner’
[11:00:05.560]   - Field: ‘envir’
[11:00:05.560]   - Field: ‘workers’
[11:00:05.560]   - Field: ‘packages’
[11:00:05.560]   - Field: ‘gc’
[11:00:05.560]   - Field: ‘conditions’
[11:00:05.560]   - Field: ‘persistent’
[11:00:05.560]   - Field: ‘expr’
[11:00:05.560]   - Field: ‘uuid’
[11:00:05.560]   - Field: ‘seed’
[11:00:05.561]   - Field: ‘version’
[11:00:05.561]   - Field: ‘result’
[11:00:05.561]   - Field: ‘asynchronous’
[11:00:05.561]   - Field: ‘calls’
[11:00:05.561]   - Field: ‘globals’
[11:00:05.561]   - Field: ‘stdout’
[11:00:05.561]   - Field: ‘earlySignal’
[11:00:05.561]   - Field: ‘lazy’
[11:00:05.561]   - Field: ‘state’
[11:00:05.561] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:05.561] - Launch lazy future ...
[11:00:05.562] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:05.562] Packages needed by future strategies (n = 0): <none>
[11:00:05.562] {
[11:00:05.562]     {
[11:00:05.562]         {
[11:00:05.562]             ...future.startTime <- base::Sys.time()
[11:00:05.562]             {
[11:00:05.562]                 {
[11:00:05.562]                   {
[11:00:05.562]                     {
[11:00:05.562]                       {
[11:00:05.562]                         base::local({
[11:00:05.562]                           has_future <- base::requireNamespace("future", 
[11:00:05.562]                             quietly = TRUE)
[11:00:05.562]                           if (has_future) {
[11:00:05.562]                             ns <- base::getNamespace("future")
[11:00:05.562]                             version <- ns[[".package"]][["version"]]
[11:00:05.562]                             if (is.null(version)) 
[11:00:05.562]                               version <- utils::packageVersion("future")
[11:00:05.562]                           }
[11:00:05.562]                           else {
[11:00:05.562]                             version <- NULL
[11:00:05.562]                           }
[11:00:05.562]                           if (!has_future || version < "1.8.0") {
[11:00:05.562]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:05.562]                               "", base::R.version$version.string), 
[11:00:05.562]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:05.562]                                 base::R.version$platform, 8 * 
[11:00:05.562]                                   base::.Machine$sizeof.pointer), 
[11:00:05.562]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:05.562]                                 "release", "version")], collapse = " "), 
[11:00:05.562]                               hostname = base::Sys.info()[["nodename"]])
[11:00:05.562]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:05.562]                               info)
[11:00:05.562]                             info <- base::paste(info, collapse = "; ")
[11:00:05.562]                             if (!has_future) {
[11:00:05.562]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:05.562]                                 info)
[11:00:05.562]                             }
[11:00:05.562]                             else {
[11:00:05.562]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:05.562]                                 info, version)
[11:00:05.562]                             }
[11:00:05.562]                             base::stop(msg)
[11:00:05.562]                           }
[11:00:05.562]                         })
[11:00:05.562]                       }
[11:00:05.562]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:05.562]                       base::options(mc.cores = 1L)
[11:00:05.562]                     }
[11:00:05.562]                     base::local({
[11:00:05.562]                       for (pkg in "future.apply") {
[11:00:05.562]                         base::loadNamespace(pkg)
[11:00:05.562]                         base::library(pkg, character.only = TRUE)
[11:00:05.562]                       }
[11:00:05.562]                     })
[11:00:05.562]                   }
[11:00:05.562]                   ...future.strategy.old <- future::plan("list")
[11:00:05.562]                   options(future.plan = NULL)
[11:00:05.562]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:05.562]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:05.562]                 }
[11:00:05.562]                 ...future.workdir <- getwd()
[11:00:05.562]             }
[11:00:05.562]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:05.562]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:05.562]         }
[11:00:05.562]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:05.562]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:05.562]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:05.562]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:05.562]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:05.562]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:05.562]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:05.562]             base::names(...future.oldOptions))
[11:00:05.562]     }
[11:00:05.562]     if (FALSE) {
[11:00:05.562]     }
[11:00:05.562]     else {
[11:00:05.562]         if (TRUE) {
[11:00:05.562]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:05.562]                 open = "w")
[11:00:05.562]         }
[11:00:05.562]         else {
[11:00:05.562]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:05.562]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:05.562]         }
[11:00:05.562]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:05.562]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:05.562]             base::sink(type = "output", split = FALSE)
[11:00:05.562]             base::close(...future.stdout)
[11:00:05.562]         }, add = TRUE)
[11:00:05.562]     }
[11:00:05.562]     ...future.frame <- base::sys.nframe()
[11:00:05.562]     ...future.conditions <- base::list()
[11:00:05.562]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:05.562]     if (FALSE) {
[11:00:05.562]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:05.562]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:05.562]     }
[11:00:05.562]     ...future.result <- base::tryCatch({
[11:00:05.562]         base::withCallingHandlers({
[11:00:05.562]             ...future.value <- base::withVisible(base::local({
[11:00:05.562]                 ...future.makeSendCondition <- base::local({
[11:00:05.562]                   sendCondition <- NULL
[11:00:05.562]                   function(frame = 1L) {
[11:00:05.562]                     if (is.function(sendCondition)) 
[11:00:05.562]                       return(sendCondition)
[11:00:05.562]                     ns <- getNamespace("parallel")
[11:00:05.562]                     if (exists("sendData", mode = "function", 
[11:00:05.562]                       envir = ns)) {
[11:00:05.562]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:05.562]                         envir = ns)
[11:00:05.562]                       envir <- sys.frame(frame)
[11:00:05.562]                       master <- NULL
[11:00:05.562]                       while (!identical(envir, .GlobalEnv) && 
[11:00:05.562]                         !identical(envir, emptyenv())) {
[11:00:05.562]                         if (exists("master", mode = "list", envir = envir, 
[11:00:05.562]                           inherits = FALSE)) {
[11:00:05.562]                           master <- get("master", mode = "list", 
[11:00:05.562]                             envir = envir, inherits = FALSE)
[11:00:05.562]                           if (inherits(master, c("SOCKnode", 
[11:00:05.562]                             "SOCK0node"))) {
[11:00:05.562]                             sendCondition <<- function(cond) {
[11:00:05.562]                               data <- list(type = "VALUE", value = cond, 
[11:00:05.562]                                 success = TRUE)
[11:00:05.562]                               parallel_sendData(master, data)
[11:00:05.562]                             }
[11:00:05.562]                             return(sendCondition)
[11:00:05.562]                           }
[11:00:05.562]                         }
[11:00:05.562]                         frame <- frame + 1L
[11:00:05.562]                         envir <- sys.frame(frame)
[11:00:05.562]                       }
[11:00:05.562]                     }
[11:00:05.562]                     sendCondition <<- function(cond) NULL
[11:00:05.562]                   }
[11:00:05.562]                 })
[11:00:05.562]                 withCallingHandlers({
[11:00:05.562]                   {
[11:00:05.562]                     do.call(function(...) {
[11:00:05.562]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:05.562]                       if (!identical(...future.globals.maxSize.org, 
[11:00:05.562]                         ...future.globals.maxSize)) {
[11:00:05.562]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:05.562]                         on.exit(options(oopts), add = TRUE)
[11:00:05.562]                       }
[11:00:05.562]                       {
[11:00:05.562]                         lapply(seq_along(...future.elements_ii), 
[11:00:05.562]                           FUN = function(jj) {
[11:00:05.562]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:05.562]                             ...future.FUN(...future.X_jj, ...)
[11:00:05.562]                           })
[11:00:05.562]                       }
[11:00:05.562]                     }, args = future.call.arguments)
[11:00:05.562]                   }
[11:00:05.562]                 }, immediateCondition = function(cond) {
[11:00:05.562]                   sendCondition <- ...future.makeSendCondition()
[11:00:05.562]                   sendCondition(cond)
[11:00:05.562]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:05.562]                   {
[11:00:05.562]                     inherits <- base::inherits
[11:00:05.562]                     invokeRestart <- base::invokeRestart
[11:00:05.562]                     is.null <- base::is.null
[11:00:05.562]                     muffled <- FALSE
[11:00:05.562]                     if (inherits(cond, "message")) {
[11:00:05.562]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:05.562]                       if (muffled) 
[11:00:05.562]                         invokeRestart("muffleMessage")
[11:00:05.562]                     }
[11:00:05.562]                     else if (inherits(cond, "warning")) {
[11:00:05.562]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:05.562]                       if (muffled) 
[11:00:05.562]                         invokeRestart("muffleWarning")
[11:00:05.562]                     }
[11:00:05.562]                     else if (inherits(cond, "condition")) {
[11:00:05.562]                       if (!is.null(pattern)) {
[11:00:05.562]                         computeRestarts <- base::computeRestarts
[11:00:05.562]                         grepl <- base::grepl
[11:00:05.562]                         restarts <- computeRestarts(cond)
[11:00:05.562]                         for (restart in restarts) {
[11:00:05.562]                           name <- restart$name
[11:00:05.562]                           if (is.null(name)) 
[11:00:05.562]                             next
[11:00:05.562]                           if (!grepl(pattern, name)) 
[11:00:05.562]                             next
[11:00:05.562]                           invokeRestart(restart)
[11:00:05.562]                           muffled <- TRUE
[11:00:05.562]                           break
[11:00:05.562]                         }
[11:00:05.562]                       }
[11:00:05.562]                     }
[11:00:05.562]                     invisible(muffled)
[11:00:05.562]                   }
[11:00:05.562]                   muffleCondition(cond)
[11:00:05.562]                 })
[11:00:05.562]             }))
[11:00:05.562]             future::FutureResult(value = ...future.value$value, 
[11:00:05.562]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:05.562]                   ...future.rng), globalenv = if (FALSE) 
[11:00:05.562]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:05.562]                     ...future.globalenv.names))
[11:00:05.562]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:05.562]         }, condition = base::local({
[11:00:05.562]             c <- base::c
[11:00:05.562]             inherits <- base::inherits
[11:00:05.562]             invokeRestart <- base::invokeRestart
[11:00:05.562]             length <- base::length
[11:00:05.562]             list <- base::list
[11:00:05.562]             seq.int <- base::seq.int
[11:00:05.562]             signalCondition <- base::signalCondition
[11:00:05.562]             sys.calls <- base::sys.calls
[11:00:05.562]             `[[` <- base::`[[`
[11:00:05.562]             `+` <- base::`+`
[11:00:05.562]             `<<-` <- base::`<<-`
[11:00:05.562]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:05.562]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:05.562]                   3L)]
[11:00:05.562]             }
[11:00:05.562]             function(cond) {
[11:00:05.562]                 is_error <- inherits(cond, "error")
[11:00:05.562]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:05.562]                   NULL)
[11:00:05.562]                 if (is_error) {
[11:00:05.562]                   sessionInformation <- function() {
[11:00:05.562]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:05.562]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:05.562]                       search = base::search(), system = base::Sys.info())
[11:00:05.562]                   }
[11:00:05.562]                   ...future.conditions[[length(...future.conditions) + 
[11:00:05.562]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:05.562]                     cond$call), session = sessionInformation(), 
[11:00:05.562]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:05.562]                   signalCondition(cond)
[11:00:05.562]                 }
[11:00:05.562]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:05.562]                 "immediateCondition"))) {
[11:00:05.562]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:05.562]                   ...future.conditions[[length(...future.conditions) + 
[11:00:05.562]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:05.562]                   if (TRUE && !signal) {
[11:00:05.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:05.562]                     {
[11:00:05.562]                       inherits <- base::inherits
[11:00:05.562]                       invokeRestart <- base::invokeRestart
[11:00:05.562]                       is.null <- base::is.null
[11:00:05.562]                       muffled <- FALSE
[11:00:05.562]                       if (inherits(cond, "message")) {
[11:00:05.562]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:05.562]                         if (muffled) 
[11:00:05.562]                           invokeRestart("muffleMessage")
[11:00:05.562]                       }
[11:00:05.562]                       else if (inherits(cond, "warning")) {
[11:00:05.562]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:05.562]                         if (muffled) 
[11:00:05.562]                           invokeRestart("muffleWarning")
[11:00:05.562]                       }
[11:00:05.562]                       else if (inherits(cond, "condition")) {
[11:00:05.562]                         if (!is.null(pattern)) {
[11:00:05.562]                           computeRestarts <- base::computeRestarts
[11:00:05.562]                           grepl <- base::grepl
[11:00:05.562]                           restarts <- computeRestarts(cond)
[11:00:05.562]                           for (restart in restarts) {
[11:00:05.562]                             name <- restart$name
[11:00:05.562]                             if (is.null(name)) 
[11:00:05.562]                               next
[11:00:05.562]                             if (!grepl(pattern, name)) 
[11:00:05.562]                               next
[11:00:05.562]                             invokeRestart(restart)
[11:00:05.562]                             muffled <- TRUE
[11:00:05.562]                             break
[11:00:05.562]                           }
[11:00:05.562]                         }
[11:00:05.562]                       }
[11:00:05.562]                       invisible(muffled)
[11:00:05.562]                     }
[11:00:05.562]                     muffleCondition(cond, pattern = "^muffle")
[11:00:05.562]                   }
[11:00:05.562]                 }
[11:00:05.562]                 else {
[11:00:05.562]                   if (TRUE) {
[11:00:05.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:05.562]                     {
[11:00:05.562]                       inherits <- base::inherits
[11:00:05.562]                       invokeRestart <- base::invokeRestart
[11:00:05.562]                       is.null <- base::is.null
[11:00:05.562]                       muffled <- FALSE
[11:00:05.562]                       if (inherits(cond, "message")) {
[11:00:05.562]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:05.562]                         if (muffled) 
[11:00:05.562]                           invokeRestart("muffleMessage")
[11:00:05.562]                       }
[11:00:05.562]                       else if (inherits(cond, "warning")) {
[11:00:05.562]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:05.562]                         if (muffled) 
[11:00:05.562]                           invokeRestart("muffleWarning")
[11:00:05.562]                       }
[11:00:05.562]                       else if (inherits(cond, "condition")) {
[11:00:05.562]                         if (!is.null(pattern)) {
[11:00:05.562]                           computeRestarts <- base::computeRestarts
[11:00:05.562]                           grepl <- base::grepl
[11:00:05.562]                           restarts <- computeRestarts(cond)
[11:00:05.562]                           for (restart in restarts) {
[11:00:05.562]                             name <- restart$name
[11:00:05.562]                             if (is.null(name)) 
[11:00:05.562]                               next
[11:00:05.562]                             if (!grepl(pattern, name)) 
[11:00:05.562]                               next
[11:00:05.562]                             invokeRestart(restart)
[11:00:05.562]                             muffled <- TRUE
[11:00:05.562]                             break
[11:00:05.562]                           }
[11:00:05.562]                         }
[11:00:05.562]                       }
[11:00:05.562]                       invisible(muffled)
[11:00:05.562]                     }
[11:00:05.562]                     muffleCondition(cond, pattern = "^muffle")
[11:00:05.562]                   }
[11:00:05.562]                 }
[11:00:05.562]             }
[11:00:05.562]         }))
[11:00:05.562]     }, error = function(ex) {
[11:00:05.562]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:05.562]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:05.562]                 ...future.rng), started = ...future.startTime, 
[11:00:05.562]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:05.562]             version = "1.8"), class = "FutureResult")
[11:00:05.562]     }, finally = {
[11:00:05.562]         if (!identical(...future.workdir, getwd())) 
[11:00:05.562]             setwd(...future.workdir)
[11:00:05.562]         {
[11:00:05.562]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:05.562]                 ...future.oldOptions$nwarnings <- NULL
[11:00:05.562]             }
[11:00:05.562]             base::options(...future.oldOptions)
[11:00:05.562]             if (.Platform$OS.type == "windows") {
[11:00:05.562]                 old_names <- names(...future.oldEnvVars)
[11:00:05.562]                 envs <- base::Sys.getenv()
[11:00:05.562]                 names <- names(envs)
[11:00:05.562]                 common <- intersect(names, old_names)
[11:00:05.562]                 added <- setdiff(names, old_names)
[11:00:05.562]                 removed <- setdiff(old_names, names)
[11:00:05.562]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:05.562]                   envs[common]]
[11:00:05.562]                 NAMES <- toupper(changed)
[11:00:05.562]                 args <- list()
[11:00:05.562]                 for (kk in seq_along(NAMES)) {
[11:00:05.562]                   name <- changed[[kk]]
[11:00:05.562]                   NAME <- NAMES[[kk]]
[11:00:05.562]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:05.562]                     next
[11:00:05.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:05.562]                 }
[11:00:05.562]                 NAMES <- toupper(added)
[11:00:05.562]                 for (kk in seq_along(NAMES)) {
[11:00:05.562]                   name <- added[[kk]]
[11:00:05.562]                   NAME <- NAMES[[kk]]
[11:00:05.562]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:05.562]                     next
[11:00:05.562]                   args[[name]] <- ""
[11:00:05.562]                 }
[11:00:05.562]                 NAMES <- toupper(removed)
[11:00:05.562]                 for (kk in seq_along(NAMES)) {
[11:00:05.562]                   name <- removed[[kk]]
[11:00:05.562]                   NAME <- NAMES[[kk]]
[11:00:05.562]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:05.562]                     next
[11:00:05.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:05.562]                 }
[11:00:05.562]                 if (length(args) > 0) 
[11:00:05.562]                   base::do.call(base::Sys.setenv, args = args)
[11:00:05.562]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:05.562]             }
[11:00:05.562]             else {
[11:00:05.562]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:05.562]             }
[11:00:05.562]             {
[11:00:05.562]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:05.562]                   0L) {
[11:00:05.562]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:05.562]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:05.562]                   base::options(opts)
[11:00:05.562]                 }
[11:00:05.562]                 {
[11:00:05.562]                   {
[11:00:05.562]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:05.562]                     NULL
[11:00:05.562]                   }
[11:00:05.562]                   options(future.plan = NULL)
[11:00:05.562]                   if (is.na(NA_character_)) 
[11:00:05.562]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:05.562]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:05.562]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:05.562]                     .init = FALSE)
[11:00:05.562]                 }
[11:00:05.562]             }
[11:00:05.562]         }
[11:00:05.562]     })
[11:00:05.562]     if (TRUE) {
[11:00:05.562]         base::sink(type = "output", split = FALSE)
[11:00:05.562]         if (TRUE) {
[11:00:05.562]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:05.562]         }
[11:00:05.562]         else {
[11:00:05.562]             ...future.result["stdout"] <- base::list(NULL)
[11:00:05.562]         }
[11:00:05.562]         base::close(...future.stdout)
[11:00:05.562]         ...future.stdout <- NULL
[11:00:05.562]     }
[11:00:05.562]     ...future.result$conditions <- ...future.conditions
[11:00:05.562]     ...future.result$finished <- base::Sys.time()
[11:00:05.562]     ...future.result
[11:00:05.562] }
[11:00:05.565] Exporting 11 global objects (14.01 KiB) to cluster node #1 ...
[11:00:05.565] Exporting ‘...future.FUN’ (5.05 KiB) to cluster node #1 ...
[11:00:05.607] Exporting ‘...future.FUN’ (5.05 KiB) to cluster node #1 ... DONE
[11:00:05.607] Exporting ‘x_FUN’ (567 bytes) to cluster node #1 ...
[11:00:05.607] Exporting ‘x_FUN’ (567 bytes) to cluster node #1 ... DONE
[11:00:05.607] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[11:00:05.608] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[11:00:05.608] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[11:00:05.649] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[11:00:05.649] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[11:00:05.690] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[11:00:05.690] Exporting ‘dim’ (39 bytes) to cluster node #1 ...
[11:00:05.690] Exporting ‘dim’ (39 bytes) to cluster node #1 ... DONE
[11:00:05.690] Exporting ‘valid_types’ (61 bytes) to cluster node #1 ...
[11:00:05.691] Exporting ‘valid_types’ (61 bytes) to cluster node #1 ... DONE
[11:00:05.691] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[11:00:05.691] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[11:00:05.691] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ...
[11:00:05.692] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ... DONE
[11:00:05.692] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[11:00:05.692] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[11:00:05.692] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[11:00:05.693] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[11:00:05.693] Exporting 11 global objects (14.01 KiB) to cluster node #1 ... DONE
[11:00:05.693] MultisessionFuture started
[11:00:05.693] - Launch lazy future ... done
[11:00:05.693] run() for ‘MultisessionFuture’ ... done
[11:00:05.693] Created future:
[11:00:05.694] MultisessionFuture:
[11:00:05.694] Label: ‘future_vapply-1’
[11:00:05.694] Expression:
[11:00:05.694] {
[11:00:05.694]     do.call(function(...) {
[11:00:05.694]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:05.694]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:05.694]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:05.694]             on.exit(options(oopts), add = TRUE)
[11:00:05.694]         }
[11:00:05.694]         {
[11:00:05.694]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:05.694]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:05.694]                 ...future.FUN(...future.X_jj, ...)
[11:00:05.694]             })
[11:00:05.694]         }
[11:00:05.694]     }, args = future.call.arguments)
[11:00:05.694] }
[11:00:05.694] Lazy evaluation: FALSE
[11:00:05.694] Asynchronous evaluation: TRUE
[11:00:05.694] Local evaluation: TRUE
[11:00:05.694] Environment: R_GlobalEnv
[11:00:05.694] Capture standard output: TRUE
[11:00:05.694] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:05.694] Globals: 11 objects totaling 13.82 KiB (function ‘...future.FUN’ of 5.05 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:05.694] Packages: 1 packages (‘future.apply’)
[11:00:05.694] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:05.694] Resolved: FALSE
[11:00:05.694] Value: <not collected>
[11:00:05.694] Conditions captured: <none>
[11:00:05.694] Early signaling: FALSE
[11:00:05.694] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:05.694] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:05.705] Chunk #1 of 2 ... DONE
[11:00:05.705] Chunk #2 of 2 ...
[11:00:05.705]  - Finding globals in 'X' for chunk #2 ...
[11:00:05.705] getGlobalsAndPackages() ...
[11:00:05.705] Searching for globals...
[11:00:05.706] 
[11:00:05.706] Searching for globals ... DONE
[11:00:05.706] - globals: [0] <none>
[11:00:05.706] getGlobalsAndPackages() ... DONE
[11:00:05.706]    + additional globals found: [n=0] 
[11:00:05.706]    + additional namespaces needed: [n=0] 
[11:00:05.706]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:05.706]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:05.706]  - seeds: <none>
[11:00:05.707]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:05.707] getGlobalsAndPackages() ...
[11:00:05.707] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:05.707] Resolving globals: FALSE
[11:00:05.707] Tweak future expression to call with '...' arguments ...
[11:00:05.707] {
[11:00:05.707]     do.call(function(...) {
[11:00:05.707]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:05.707]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:05.707]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:05.707]             on.exit(options(oopts), add = TRUE)
[11:00:05.707]         }
[11:00:05.707]         {
[11:00:05.707]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:05.707]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:05.707]                 ...future.FUN(...future.X_jj, ...)
[11:00:05.707]             })
[11:00:05.707]         }
[11:00:05.707]     }, args = future.call.arguments)
[11:00:05.707] }
[11:00:05.707] Tweak future expression to call with '...' arguments ... DONE
[11:00:05.708] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:05.708] - packages: [1] ‘future.apply’
[11:00:05.708] getGlobalsAndPackages() ... DONE
[11:00:05.708] run() for ‘Future’ ...
[11:00:05.708] - state: ‘created’
[11:00:05.708] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:05.722] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:05.722] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:05.722]   - Field: ‘node’
[11:00:05.722]   - Field: ‘label’
[11:00:05.722]   - Field: ‘local’
[11:00:05.722]   - Field: ‘owner’
[11:00:05.722]   - Field: ‘envir’
[11:00:05.723]   - Field: ‘workers’
[11:00:05.723]   - Field: ‘packages’
[11:00:05.723]   - Field: ‘gc’
[11:00:05.723]   - Field: ‘conditions’
[11:00:05.723]   - Field: ‘persistent’
[11:00:05.723]   - Field: ‘expr’
[11:00:05.723]   - Field: ‘uuid’
[11:00:05.723]   - Field: ‘seed’
[11:00:05.723]   - Field: ‘version’
[11:00:05.723]   - Field: ‘result’
[11:00:05.723]   - Field: ‘asynchronous’
[11:00:05.723]   - Field: ‘calls’
[11:00:05.724]   - Field: ‘globals’
[11:00:05.724]   - Field: ‘stdout’
[11:00:05.724]   - Field: ‘earlySignal’
[11:00:05.724]   - Field: ‘lazy’
[11:00:05.724]   - Field: ‘state’
[11:00:05.724] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:05.724] - Launch lazy future ...
[11:00:05.724] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:05.724] Packages needed by future strategies (n = 0): <none>
[11:00:05.725] {
[11:00:05.725]     {
[11:00:05.725]         {
[11:00:05.725]             ...future.startTime <- base::Sys.time()
[11:00:05.725]             {
[11:00:05.725]                 {
[11:00:05.725]                   {
[11:00:05.725]                     {
[11:00:05.725]                       {
[11:00:05.725]                         base::local({
[11:00:05.725]                           has_future <- base::requireNamespace("future", 
[11:00:05.725]                             quietly = TRUE)
[11:00:05.725]                           if (has_future) {
[11:00:05.725]                             ns <- base::getNamespace("future")
[11:00:05.725]                             version <- ns[[".package"]][["version"]]
[11:00:05.725]                             if (is.null(version)) 
[11:00:05.725]                               version <- utils::packageVersion("future")
[11:00:05.725]                           }
[11:00:05.725]                           else {
[11:00:05.725]                             version <- NULL
[11:00:05.725]                           }
[11:00:05.725]                           if (!has_future || version < "1.8.0") {
[11:00:05.725]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:05.725]                               "", base::R.version$version.string), 
[11:00:05.725]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:05.725]                                 base::R.version$platform, 8 * 
[11:00:05.725]                                   base::.Machine$sizeof.pointer), 
[11:00:05.725]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:05.725]                                 "release", "version")], collapse = " "), 
[11:00:05.725]                               hostname = base::Sys.info()[["nodename"]])
[11:00:05.725]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:05.725]                               info)
[11:00:05.725]                             info <- base::paste(info, collapse = "; ")
[11:00:05.725]                             if (!has_future) {
[11:00:05.725]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:05.725]                                 info)
[11:00:05.725]                             }
[11:00:05.725]                             else {
[11:00:05.725]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:05.725]                                 info, version)
[11:00:05.725]                             }
[11:00:05.725]                             base::stop(msg)
[11:00:05.725]                           }
[11:00:05.725]                         })
[11:00:05.725]                       }
[11:00:05.725]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:05.725]                       base::options(mc.cores = 1L)
[11:00:05.725]                     }
[11:00:05.725]                     base::local({
[11:00:05.725]                       for (pkg in "future.apply") {
[11:00:05.725]                         base::loadNamespace(pkg)
[11:00:05.725]                         base::library(pkg, character.only = TRUE)
[11:00:05.725]                       }
[11:00:05.725]                     })
[11:00:05.725]                   }
[11:00:05.725]                   ...future.strategy.old <- future::plan("list")
[11:00:05.725]                   options(future.plan = NULL)
[11:00:05.725]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:05.725]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:05.725]                 }
[11:00:05.725]                 ...future.workdir <- getwd()
[11:00:05.725]             }
[11:00:05.725]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:05.725]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:05.725]         }
[11:00:05.725]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:05.725]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:05.725]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:05.725]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:05.725]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:05.725]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:05.725]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:05.725]             base::names(...future.oldOptions))
[11:00:05.725]     }
[11:00:05.725]     if (FALSE) {
[11:00:05.725]     }
[11:00:05.725]     else {
[11:00:05.725]         if (TRUE) {
[11:00:05.725]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:05.725]                 open = "w")
[11:00:05.725]         }
[11:00:05.725]         else {
[11:00:05.725]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:05.725]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:05.725]         }
[11:00:05.725]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:05.725]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:05.725]             base::sink(type = "output", split = FALSE)
[11:00:05.725]             base::close(...future.stdout)
[11:00:05.725]         }, add = TRUE)
[11:00:05.725]     }
[11:00:05.725]     ...future.frame <- base::sys.nframe()
[11:00:05.725]     ...future.conditions <- base::list()
[11:00:05.725]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:05.725]     if (FALSE) {
[11:00:05.725]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:05.725]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:05.725]     }
[11:00:05.725]     ...future.result <- base::tryCatch({
[11:00:05.725]         base::withCallingHandlers({
[11:00:05.725]             ...future.value <- base::withVisible(base::local({
[11:00:05.725]                 ...future.makeSendCondition <- base::local({
[11:00:05.725]                   sendCondition <- NULL
[11:00:05.725]                   function(frame = 1L) {
[11:00:05.725]                     if (is.function(sendCondition)) 
[11:00:05.725]                       return(sendCondition)
[11:00:05.725]                     ns <- getNamespace("parallel")
[11:00:05.725]                     if (exists("sendData", mode = "function", 
[11:00:05.725]                       envir = ns)) {
[11:00:05.725]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:05.725]                         envir = ns)
[11:00:05.725]                       envir <- sys.frame(frame)
[11:00:05.725]                       master <- NULL
[11:00:05.725]                       while (!identical(envir, .GlobalEnv) && 
[11:00:05.725]                         !identical(envir, emptyenv())) {
[11:00:05.725]                         if (exists("master", mode = "list", envir = envir, 
[11:00:05.725]                           inherits = FALSE)) {
[11:00:05.725]                           master <- get("master", mode = "list", 
[11:00:05.725]                             envir = envir, inherits = FALSE)
[11:00:05.725]                           if (inherits(master, c("SOCKnode", 
[11:00:05.725]                             "SOCK0node"))) {
[11:00:05.725]                             sendCondition <<- function(cond) {
[11:00:05.725]                               data <- list(type = "VALUE", value = cond, 
[11:00:05.725]                                 success = TRUE)
[11:00:05.725]                               parallel_sendData(master, data)
[11:00:05.725]                             }
[11:00:05.725]                             return(sendCondition)
[11:00:05.725]                           }
[11:00:05.725]                         }
[11:00:05.725]                         frame <- frame + 1L
[11:00:05.725]                         envir <- sys.frame(frame)
[11:00:05.725]                       }
[11:00:05.725]                     }
[11:00:05.725]                     sendCondition <<- function(cond) NULL
[11:00:05.725]                   }
[11:00:05.725]                 })
[11:00:05.725]                 withCallingHandlers({
[11:00:05.725]                   {
[11:00:05.725]                     do.call(function(...) {
[11:00:05.725]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:05.725]                       if (!identical(...future.globals.maxSize.org, 
[11:00:05.725]                         ...future.globals.maxSize)) {
[11:00:05.725]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:05.725]                         on.exit(options(oopts), add = TRUE)
[11:00:05.725]                       }
[11:00:05.725]                       {
[11:00:05.725]                         lapply(seq_along(...future.elements_ii), 
[11:00:05.725]                           FUN = function(jj) {
[11:00:05.725]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:05.725]                             ...future.FUN(...future.X_jj, ...)
[11:00:05.725]                           })
[11:00:05.725]                       }
[11:00:05.725]                     }, args = future.call.arguments)
[11:00:05.725]                   }
[11:00:05.725]                 }, immediateCondition = function(cond) {
[11:00:05.725]                   sendCondition <- ...future.makeSendCondition()
[11:00:05.725]                   sendCondition(cond)
[11:00:05.725]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:05.725]                   {
[11:00:05.725]                     inherits <- base::inherits
[11:00:05.725]                     invokeRestart <- base::invokeRestart
[11:00:05.725]                     is.null <- base::is.null
[11:00:05.725]                     muffled <- FALSE
[11:00:05.725]                     if (inherits(cond, "message")) {
[11:00:05.725]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:05.725]                       if (muffled) 
[11:00:05.725]                         invokeRestart("muffleMessage")
[11:00:05.725]                     }
[11:00:05.725]                     else if (inherits(cond, "warning")) {
[11:00:05.725]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:05.725]                       if (muffled) 
[11:00:05.725]                         invokeRestart("muffleWarning")
[11:00:05.725]                     }
[11:00:05.725]                     else if (inherits(cond, "condition")) {
[11:00:05.725]                       if (!is.null(pattern)) {
[11:00:05.725]                         computeRestarts <- base::computeRestarts
[11:00:05.725]                         grepl <- base::grepl
[11:00:05.725]                         restarts <- computeRestarts(cond)
[11:00:05.725]                         for (restart in restarts) {
[11:00:05.725]                           name <- restart$name
[11:00:05.725]                           if (is.null(name)) 
[11:00:05.725]                             next
[11:00:05.725]                           if (!grepl(pattern, name)) 
[11:00:05.725]                             next
[11:00:05.725]                           invokeRestart(restart)
[11:00:05.725]                           muffled <- TRUE
[11:00:05.725]                           break
[11:00:05.725]                         }
[11:00:05.725]                       }
[11:00:05.725]                     }
[11:00:05.725]                     invisible(muffled)
[11:00:05.725]                   }
[11:00:05.725]                   muffleCondition(cond)
[11:00:05.725]                 })
[11:00:05.725]             }))
[11:00:05.725]             future::FutureResult(value = ...future.value$value, 
[11:00:05.725]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:05.725]                   ...future.rng), globalenv = if (FALSE) 
[11:00:05.725]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:05.725]                     ...future.globalenv.names))
[11:00:05.725]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:05.725]         }, condition = base::local({
[11:00:05.725]             c <- base::c
[11:00:05.725]             inherits <- base::inherits
[11:00:05.725]             invokeRestart <- base::invokeRestart
[11:00:05.725]             length <- base::length
[11:00:05.725]             list <- base::list
[11:00:05.725]             seq.int <- base::seq.int
[11:00:05.725]             signalCondition <- base::signalCondition
[11:00:05.725]             sys.calls <- base::sys.calls
[11:00:05.725]             `[[` <- base::`[[`
[11:00:05.725]             `+` <- base::`+`
[11:00:05.725]             `<<-` <- base::`<<-`
[11:00:05.725]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:05.725]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:05.725]                   3L)]
[11:00:05.725]             }
[11:00:05.725]             function(cond) {
[11:00:05.725]                 is_error <- inherits(cond, "error")
[11:00:05.725]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:05.725]                   NULL)
[11:00:05.725]                 if (is_error) {
[11:00:05.725]                   sessionInformation <- function() {
[11:00:05.725]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:05.725]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:05.725]                       search = base::search(), system = base::Sys.info())
[11:00:05.725]                   }
[11:00:05.725]                   ...future.conditions[[length(...future.conditions) + 
[11:00:05.725]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:05.725]                     cond$call), session = sessionInformation(), 
[11:00:05.725]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:05.725]                   signalCondition(cond)
[11:00:05.725]                 }
[11:00:05.725]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:05.725]                 "immediateCondition"))) {
[11:00:05.725]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:05.725]                   ...future.conditions[[length(...future.conditions) + 
[11:00:05.725]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:05.725]                   if (TRUE && !signal) {
[11:00:05.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:05.725]                     {
[11:00:05.725]                       inherits <- base::inherits
[11:00:05.725]                       invokeRestart <- base::invokeRestart
[11:00:05.725]                       is.null <- base::is.null
[11:00:05.725]                       muffled <- FALSE
[11:00:05.725]                       if (inherits(cond, "message")) {
[11:00:05.725]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:05.725]                         if (muffled) 
[11:00:05.725]                           invokeRestart("muffleMessage")
[11:00:05.725]                       }
[11:00:05.725]                       else if (inherits(cond, "warning")) {
[11:00:05.725]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:05.725]                         if (muffled) 
[11:00:05.725]                           invokeRestart("muffleWarning")
[11:00:05.725]                       }
[11:00:05.725]                       else if (inherits(cond, "condition")) {
[11:00:05.725]                         if (!is.null(pattern)) {
[11:00:05.725]                           computeRestarts <- base::computeRestarts
[11:00:05.725]                           grepl <- base::grepl
[11:00:05.725]                           restarts <- computeRestarts(cond)
[11:00:05.725]                           for (restart in restarts) {
[11:00:05.725]                             name <- restart$name
[11:00:05.725]                             if (is.null(name)) 
[11:00:05.725]                               next
[11:00:05.725]                             if (!grepl(pattern, name)) 
[11:00:05.725]                               next
[11:00:05.725]                             invokeRestart(restart)
[11:00:05.725]                             muffled <- TRUE
[11:00:05.725]                             break
[11:00:05.725]                           }
[11:00:05.725]                         }
[11:00:05.725]                       }
[11:00:05.725]                       invisible(muffled)
[11:00:05.725]                     }
[11:00:05.725]                     muffleCondition(cond, pattern = "^muffle")
[11:00:05.725]                   }
[11:00:05.725]                 }
[11:00:05.725]                 else {
[11:00:05.725]                   if (TRUE) {
[11:00:05.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:05.725]                     {
[11:00:05.725]                       inherits <- base::inherits
[11:00:05.725]                       invokeRestart <- base::invokeRestart
[11:00:05.725]                       is.null <- base::is.null
[11:00:05.725]                       muffled <- FALSE
[11:00:05.725]                       if (inherits(cond, "message")) {
[11:00:05.725]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:05.725]                         if (muffled) 
[11:00:05.725]                           invokeRestart("muffleMessage")
[11:00:05.725]                       }
[11:00:05.725]                       else if (inherits(cond, "warning")) {
[11:00:05.725]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:05.725]                         if (muffled) 
[11:00:05.725]                           invokeRestart("muffleWarning")
[11:00:05.725]                       }
[11:00:05.725]                       else if (inherits(cond, "condition")) {
[11:00:05.725]                         if (!is.null(pattern)) {
[11:00:05.725]                           computeRestarts <- base::computeRestarts
[11:00:05.725]                           grepl <- base::grepl
[11:00:05.725]                           restarts <- computeRestarts(cond)
[11:00:05.725]                           for (restart in restarts) {
[11:00:05.725]                             name <- restart$name
[11:00:05.725]                             if (is.null(name)) 
[11:00:05.725]                               next
[11:00:05.725]                             if (!grepl(pattern, name)) 
[11:00:05.725]                               next
[11:00:05.725]                             invokeRestart(restart)
[11:00:05.725]                             muffled <- TRUE
[11:00:05.725]                             break
[11:00:05.725]                           }
[11:00:05.725]                         }
[11:00:05.725]                       }
[11:00:05.725]                       invisible(muffled)
[11:00:05.725]                     }
[11:00:05.725]                     muffleCondition(cond, pattern = "^muffle")
[11:00:05.725]                   }
[11:00:05.725]                 }
[11:00:05.725]             }
[11:00:05.725]         }))
[11:00:05.725]     }, error = function(ex) {
[11:00:05.725]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:05.725]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:05.725]                 ...future.rng), started = ...future.startTime, 
[11:00:05.725]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:05.725]             version = "1.8"), class = "FutureResult")
[11:00:05.725]     }, finally = {
[11:00:05.725]         if (!identical(...future.workdir, getwd())) 
[11:00:05.725]             setwd(...future.workdir)
[11:00:05.725]         {
[11:00:05.725]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:05.725]                 ...future.oldOptions$nwarnings <- NULL
[11:00:05.725]             }
[11:00:05.725]             base::options(...future.oldOptions)
[11:00:05.725]             if (.Platform$OS.type == "windows") {
[11:00:05.725]                 old_names <- names(...future.oldEnvVars)
[11:00:05.725]                 envs <- base::Sys.getenv()
[11:00:05.725]                 names <- names(envs)
[11:00:05.725]                 common <- intersect(names, old_names)
[11:00:05.725]                 added <- setdiff(names, old_names)
[11:00:05.725]                 removed <- setdiff(old_names, names)
[11:00:05.725]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:05.725]                   envs[common]]
[11:00:05.725]                 NAMES <- toupper(changed)
[11:00:05.725]                 args <- list()
[11:00:05.725]                 for (kk in seq_along(NAMES)) {
[11:00:05.725]                   name <- changed[[kk]]
[11:00:05.725]                   NAME <- NAMES[[kk]]
[11:00:05.725]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:05.725]                     next
[11:00:05.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:05.725]                 }
[11:00:05.725]                 NAMES <- toupper(added)
[11:00:05.725]                 for (kk in seq_along(NAMES)) {
[11:00:05.725]                   name <- added[[kk]]
[11:00:05.725]                   NAME <- NAMES[[kk]]
[11:00:05.725]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:05.725]                     next
[11:00:05.725]                   args[[name]] <- ""
[11:00:05.725]                 }
[11:00:05.725]                 NAMES <- toupper(removed)
[11:00:05.725]                 for (kk in seq_along(NAMES)) {
[11:00:05.725]                   name <- removed[[kk]]
[11:00:05.725]                   NAME <- NAMES[[kk]]
[11:00:05.725]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:05.725]                     next
[11:00:05.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:05.725]                 }
[11:00:05.725]                 if (length(args) > 0) 
[11:00:05.725]                   base::do.call(base::Sys.setenv, args = args)
[11:00:05.725]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:05.725]             }
[11:00:05.725]             else {
[11:00:05.725]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:05.725]             }
[11:00:05.725]             {
[11:00:05.725]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:05.725]                   0L) {
[11:00:05.725]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:05.725]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:05.725]                   base::options(opts)
[11:00:05.725]                 }
[11:00:05.725]                 {
[11:00:05.725]                   {
[11:00:05.725]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:05.725]                     NULL
[11:00:05.725]                   }
[11:00:05.725]                   options(future.plan = NULL)
[11:00:05.725]                   if (is.na(NA_character_)) 
[11:00:05.725]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:05.725]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:05.725]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:05.725]                     .init = FALSE)
[11:00:05.725]                 }
[11:00:05.725]             }
[11:00:05.725]         }
[11:00:05.725]     })
[11:00:05.725]     if (TRUE) {
[11:00:05.725]         base::sink(type = "output", split = FALSE)
[11:00:05.725]         if (TRUE) {
[11:00:05.725]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:05.725]         }
[11:00:05.725]         else {
[11:00:05.725]             ...future.result["stdout"] <- base::list(NULL)
[11:00:05.725]         }
[11:00:05.725]         base::close(...future.stdout)
[11:00:05.725]         ...future.stdout <- NULL
[11:00:05.725]     }
[11:00:05.725]     ...future.result$conditions <- ...future.conditions
[11:00:05.725]     ...future.result$finished <- base::Sys.time()
[11:00:05.725]     ...future.result
[11:00:05.725] }
[11:00:05.728] Exporting 11 global objects (14.01 KiB) to cluster node #2 ...
[11:00:05.728] Exporting ‘...future.FUN’ (5.05 KiB) to cluster node #2 ...
[11:00:05.769] Exporting ‘...future.FUN’ (5.05 KiB) to cluster node #2 ... DONE
[11:00:05.769] Exporting ‘x_FUN’ (567 bytes) to cluster node #2 ...
[11:00:05.769] Exporting ‘x_FUN’ (567 bytes) to cluster node #2 ... DONE
[11:00:05.769] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[11:00:05.770] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[11:00:05.770] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[11:00:05.811] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[11:00:05.811] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[11:00:05.851] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[11:00:05.852] Exporting ‘dim’ (39 bytes) to cluster node #2 ...
[11:00:05.852] Exporting ‘dim’ (39 bytes) to cluster node #2 ... DONE
[11:00:05.852] Exporting ‘valid_types’ (61 bytes) to cluster node #2 ...
[11:00:05.852] Exporting ‘valid_types’ (61 bytes) to cluster node #2 ... DONE
[11:00:05.853] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[11:00:05.853] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[11:00:05.853] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ...
[11:00:05.853] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ... DONE
[11:00:05.854] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[11:00:05.854] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[11:00:05.854] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[11:00:05.854] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[11:00:05.854] Exporting 11 global objects (14.01 KiB) to cluster node #2 ... DONE
[11:00:05.855] MultisessionFuture started
[11:00:05.855] - Launch lazy future ... done
[11:00:05.855] run() for ‘MultisessionFuture’ ... done
[11:00:05.855] Created future:
[11:00:05.855] MultisessionFuture:
[11:00:05.855] Label: ‘future_vapply-2’
[11:00:05.855] Expression:
[11:00:05.855] {
[11:00:05.855]     do.call(function(...) {
[11:00:05.855]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:05.855]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:05.855]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:05.855]             on.exit(options(oopts), add = TRUE)
[11:00:05.855]         }
[11:00:05.855]         {
[11:00:05.855]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:05.855]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:05.855]                 ...future.FUN(...future.X_jj, ...)
[11:00:05.855]             })
[11:00:05.855]         }
[11:00:05.855]     }, args = future.call.arguments)
[11:00:05.855] }
[11:00:05.855] Lazy evaluation: FALSE
[11:00:05.855] Asynchronous evaluation: TRUE
[11:00:05.855] Local evaluation: TRUE
[11:00:05.855] Environment: R_GlobalEnv
[11:00:05.855] Capture standard output: TRUE
[11:00:05.855] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:05.855] Globals: 11 objects totaling 13.82 KiB (function ‘...future.FUN’ of 5.05 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:05.855] Packages: 1 packages (‘future.apply’)
[11:00:05.855] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:05.855] Resolved: FALSE
[11:00:05.855] Value: <not collected>
[11:00:05.855] Conditions captured: <none>
[11:00:05.855] Early signaling: FALSE
[11:00:05.855] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:05.855] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:05.867] Chunk #2 of 2 ... DONE
[11:00:05.867] Launching 2 futures (chunks) ... DONE
[11:00:05.867] Resolving 2 futures (chunks) ...
[11:00:05.867] resolve() on list ...
[11:00:05.867]  recursive: 0
[11:00:05.867]  length: 2
[11:00:05.867] 
[11:00:05.868] receiveMessageFromWorker() for ClusterFuture ...
[11:00:05.868] - Validating connection of MultisessionFuture
[11:00:05.868] - received message: FutureResult
[11:00:05.868] - Received FutureResult
[11:00:05.868] - Erased future from FutureRegistry
[11:00:05.868] result() for ClusterFuture ...
[11:00:05.868] - result already collected: FutureResult
[11:00:05.869] result() for ClusterFuture ... done
[11:00:05.869] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:05.869] Future #1
[11:00:05.869] result() for ClusterFuture ...
[11:00:05.869] - result already collected: FutureResult
[11:00:05.869] result() for ClusterFuture ... done
[11:00:05.869] result() for ClusterFuture ...
[11:00:05.869] - result already collected: FutureResult
[11:00:05.869] result() for ClusterFuture ... done
[11:00:05.869] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:00:05.869] - nx: 2
[11:00:05.869] - relay: TRUE
[11:00:05.870] - stdout: TRUE
[11:00:05.870] - signal: TRUE
[11:00:05.870] - resignal: FALSE
[11:00:05.870] - force: TRUE
[11:00:05.870] - relayed: [n=2] FALSE, FALSE
[11:00:05.870] - queued futures: [n=2] FALSE, FALSE
[11:00:05.870]  - until=1
[11:00:05.870]  - relaying element #1
[11:00:05.870] result() for ClusterFuture ...
[11:00:05.870] - result already collected: FutureResult
[11:00:05.870] result() for ClusterFuture ... done
[11:00:05.870] result() for ClusterFuture ...
[11:00:05.871] - result already collected: FutureResult
[11:00:05.871] result() for ClusterFuture ... done
[11:00:05.871] result() for ClusterFuture ...
[11:00:05.871] - result already collected: FutureResult
[11:00:05.871] result() for ClusterFuture ... done
[11:00:05.871] result() for ClusterFuture ...
[11:00:05.871] - result already collected: FutureResult
[11:00:05.871] result() for ClusterFuture ... done
[11:00:05.871] - relayed: [n=2] TRUE, FALSE
[11:00:05.871] - queued futures: [n=2] TRUE, FALSE
[11:00:05.871] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:00:05.871]  length: 1 (resolved future 1)
[11:00:05.897] receiveMessageFromWorker() for ClusterFuture ...
[11:00:05.897] - Validating connection of MultisessionFuture
[11:00:05.898] - received message: FutureResult
[11:00:05.898] - Received FutureResult
[11:00:05.898] - Erased future from FutureRegistry
[11:00:05.898] result() for ClusterFuture ...
[11:00:05.898] - result already collected: FutureResult
[11:00:05.898] result() for ClusterFuture ... done
[11:00:05.898] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:05.898] Future #2
[11:00:05.898] result() for ClusterFuture ...
[11:00:05.898] - result already collected: FutureResult
[11:00:05.898] result() for ClusterFuture ... done
[11:00:05.899] result() for ClusterFuture ...
[11:00:05.899] - result already collected: FutureResult
[11:00:05.899] result() for ClusterFuture ... done
[11:00:05.899] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:00:05.899] - nx: 2
[11:00:05.899] - relay: TRUE
[11:00:05.899] - stdout: TRUE
[11:00:05.899] - signal: TRUE
[11:00:05.899] - resignal: FALSE
[11:00:05.899] - force: TRUE
[11:00:05.899] - relayed: [n=2] TRUE, FALSE
[11:00:05.899] - queued futures: [n=2] TRUE, FALSE
[11:00:05.899]  - until=2
[11:00:05.900]  - relaying element #2
[11:00:05.900] result() for ClusterFuture ...
[11:00:05.900] - result already collected: FutureResult
[11:00:05.900] result() for ClusterFuture ... done
[11:00:05.900] result() for ClusterFuture ...
[11:00:05.900] - result already collected: FutureResult
[11:00:05.900] result() for ClusterFuture ... done
[11:00:05.900] result() for ClusterFuture ...
[11:00:05.900] - result already collected: FutureResult
[11:00:05.900] result() for ClusterFuture ... done
[11:00:05.900] result() for ClusterFuture ...
[11:00:05.901] - result already collected: FutureResult
[11:00:05.901] result() for ClusterFuture ... done
[11:00:05.901] - relayed: [n=2] TRUE, TRUE
[11:00:05.901] - queued futures: [n=2] TRUE, TRUE
[11:00:05.901] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:00:05.901]  length: 0 (resolved future 2)
[11:00:05.901] Relaying remaining futures
[11:00:05.901] signalConditionsASAP(NULL, pos=0) ...
[11:00:05.901] - nx: 2
[11:00:05.901] - relay: TRUE
[11:00:05.901] - stdout: TRUE
[11:00:05.901] - signal: TRUE
[11:00:05.901] - resignal: FALSE
[11:00:05.902] - force: TRUE
[11:00:05.902] - relayed: [n=2] TRUE, TRUE
[11:00:05.902] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:05.902] - relayed: [n=2] TRUE, TRUE
[11:00:05.902] - queued futures: [n=2] TRUE, TRUE
[11:00:05.902] signalConditionsASAP(NULL, pos=0) ... done
[11:00:05.902] resolve() on list ... DONE
[11:00:05.902] result() for ClusterFuture ...
[11:00:05.902] - result already collected: FutureResult
[11:00:05.902] result() for ClusterFuture ... done
[11:00:05.902] result() for ClusterFuture ...
[11:00:05.902] - result already collected: FutureResult
[11:00:05.903] result() for ClusterFuture ... done
[11:00:05.903] result() for ClusterFuture ...
[11:00:05.903] - result already collected: FutureResult
[11:00:05.903] result() for ClusterFuture ... done
[11:00:05.903] result() for ClusterFuture ...
[11:00:05.903] - result already collected: FutureResult
[11:00:05.903] result() for ClusterFuture ... done
[11:00:05.903]  - Number of value chunks collected: 2
[11:00:05.903] Resolving 2 futures (chunks) ... DONE
[11:00:05.903] Reducing values from 2 chunks ...
[11:00:05.903]  - Number of values collected after concatenation: 10
[11:00:05.903]  - Number of values expected: 10
[11:00:05.904] Reducing values from 2 chunks ... DONE
[11:00:05.904] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[11:00:05.905] future_lapply() ...
[11:00:05.908] Number of chunks: 2
[11:00:05.908] getGlobalsAndPackagesXApply() ...
[11:00:05.908]  - future.globals: TRUE
[11:00:05.908] getGlobalsAndPackages() ...
[11:00:05.908] Searching for globals...
[11:00:05.911] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[11:00:05.911] Searching for globals ... DONE
[11:00:05.911] Resolving globals: FALSE
[11:00:05.912] The total size of the 7 globals is 13.63 KiB (13957 bytes)
[11:00:05.913] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.63 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.09 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:05.913] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:05.913] - packages: [1] ‘future.apply’
[11:00:05.913] getGlobalsAndPackages() ... DONE
[11:00:05.913]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:05.913]  - needed namespaces: [n=1] ‘future.apply’
[11:00:05.913] Finding globals ... DONE
[11:00:05.913]  - use_args: TRUE
[11:00:05.914]  - Getting '...' globals ...
[11:00:05.914] resolve() on list ...
[11:00:05.914]  recursive: 0
[11:00:05.914]  length: 1
[11:00:05.914]  elements: ‘...’
[11:00:05.914]  length: 0 (resolved future 1)
[11:00:05.914] resolve() on list ... DONE
[11:00:05.914]    - '...' content: [n=0] 
[11:00:05.914] List of 1
[11:00:05.914]  $ ...: list()
[11:00:05.914]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:05.914]  - attr(*, "where")=List of 1
[11:00:05.914]   ..$ ...:<environment: 0x55bbaf673268> 
[11:00:05.914]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:05.914]  - attr(*, "resolved")= logi TRUE
[11:00:05.914]  - attr(*, "total_size")= num NA
[11:00:05.917]  - Getting '...' globals ... DONE
[11:00:05.917] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:05.917] List of 8
[11:00:05.917]  $ ...future.FUN:function (x, ...)  
[11:00:05.917]  $ x_FUN        :function (x)  
[11:00:05.917]  $ times        : int 4
[11:00:05.917]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:05.917]  $ stop_if_not  :function (...)  
[11:00:05.917]  $ dim          : int [1:2] 2 2
[11:00:05.917]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:05.917]  $ ...          : list()
[11:00:05.917]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:05.917]  - attr(*, "where")=List of 8
[11:00:05.917]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:05.917]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:05.917]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:05.917]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:05.917]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:05.917]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:05.917]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:05.917]   ..$ ...          :<environment: 0x55bbaf673268> 
[11:00:05.917]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:05.917]  - attr(*, "resolved")= logi FALSE
[11:00:05.917]  - attr(*, "total_size")= num 24958
[11:00:05.922] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:05.922] getGlobalsAndPackagesXApply() ... DONE
[11:00:05.923] Number of futures (= number of chunks): 2
[11:00:05.923] Launching 2 futures (chunks) ...
[11:00:05.923] Chunk #1 of 2 ...
[11:00:05.923]  - Finding globals in 'X' for chunk #1 ...
[11:00:05.923] getGlobalsAndPackages() ...
[11:00:05.923] Searching for globals...
[11:00:05.923] 
[11:00:05.923] Searching for globals ... DONE
[11:00:05.923] - globals: [0] <none>
[11:00:05.924] getGlobalsAndPackages() ... DONE
[11:00:05.924]    + additional globals found: [n=0] 
[11:00:05.924]    + additional namespaces needed: [n=0] 
[11:00:05.924]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:05.924]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:05.924]  - seeds: <none>
[11:00:05.924]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:05.924] getGlobalsAndPackages() ...
[11:00:05.924] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:05.924] Resolving globals: FALSE
[11:00:05.924] Tweak future expression to call with '...' arguments ...
[11:00:05.925] {
[11:00:05.925]     do.call(function(...) {
[11:00:05.925]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:05.925]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:05.925]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:05.925]             on.exit(options(oopts), add = TRUE)
[11:00:05.925]         }
[11:00:05.925]         {
[11:00:05.925]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:05.925]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:05.925]                 ...future.FUN(...future.X_jj, ...)
[11:00:05.925]             })
[11:00:05.925]         }
[11:00:05.925]     }, args = future.call.arguments)
[11:00:05.925] }
[11:00:05.925] Tweak future expression to call with '...' arguments ... DONE
[11:00:05.925] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:05.925] - packages: [1] ‘future.apply’
[11:00:05.925] getGlobalsAndPackages() ... DONE
[11:00:05.926] run() for ‘Future’ ...
[11:00:05.926] - state: ‘created’
[11:00:05.926] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:05.939] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:05.940] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:05.940]   - Field: ‘node’
[11:00:05.940]   - Field: ‘label’
[11:00:05.940]   - Field: ‘local’
[11:00:05.940]   - Field: ‘owner’
[11:00:05.940]   - Field: ‘envir’
[11:00:05.940]   - Field: ‘workers’
[11:00:05.940]   - Field: ‘packages’
[11:00:05.940]   - Field: ‘gc’
[11:00:05.940]   - Field: ‘conditions’
[11:00:05.940]   - Field: ‘persistent’
[11:00:05.941]   - Field: ‘expr’
[11:00:05.941]   - Field: ‘uuid’
[11:00:05.941]   - Field: ‘seed’
[11:00:05.941]   - Field: ‘version’
[11:00:05.941]   - Field: ‘result’
[11:00:05.941]   - Field: ‘asynchronous’
[11:00:05.941]   - Field: ‘calls’
[11:00:05.941]   - Field: ‘globals’
[11:00:05.941]   - Field: ‘stdout’
[11:00:05.941]   - Field: ‘earlySignal’
[11:00:05.941]   - Field: ‘lazy’
[11:00:05.941]   - Field: ‘state’
[11:00:05.942] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:05.942] - Launch lazy future ...
[11:00:05.942] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:05.942] Packages needed by future strategies (n = 0): <none>
[11:00:05.942] {
[11:00:05.942]     {
[11:00:05.942]         {
[11:00:05.942]             ...future.startTime <- base::Sys.time()
[11:00:05.942]             {
[11:00:05.942]                 {
[11:00:05.942]                   {
[11:00:05.942]                     {
[11:00:05.942]                       {
[11:00:05.942]                         base::local({
[11:00:05.942]                           has_future <- base::requireNamespace("future", 
[11:00:05.942]                             quietly = TRUE)
[11:00:05.942]                           if (has_future) {
[11:00:05.942]                             ns <- base::getNamespace("future")
[11:00:05.942]                             version <- ns[[".package"]][["version"]]
[11:00:05.942]                             if (is.null(version)) 
[11:00:05.942]                               version <- utils::packageVersion("future")
[11:00:05.942]                           }
[11:00:05.942]                           else {
[11:00:05.942]                             version <- NULL
[11:00:05.942]                           }
[11:00:05.942]                           if (!has_future || version < "1.8.0") {
[11:00:05.942]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:05.942]                               "", base::R.version$version.string), 
[11:00:05.942]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:05.942]                                 base::R.version$platform, 8 * 
[11:00:05.942]                                   base::.Machine$sizeof.pointer), 
[11:00:05.942]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:05.942]                                 "release", "version")], collapse = " "), 
[11:00:05.942]                               hostname = base::Sys.info()[["nodename"]])
[11:00:05.942]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:05.942]                               info)
[11:00:05.942]                             info <- base::paste(info, collapse = "; ")
[11:00:05.942]                             if (!has_future) {
[11:00:05.942]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:05.942]                                 info)
[11:00:05.942]                             }
[11:00:05.942]                             else {
[11:00:05.942]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:05.942]                                 info, version)
[11:00:05.942]                             }
[11:00:05.942]                             base::stop(msg)
[11:00:05.942]                           }
[11:00:05.942]                         })
[11:00:05.942]                       }
[11:00:05.942]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:05.942]                       base::options(mc.cores = 1L)
[11:00:05.942]                     }
[11:00:05.942]                     base::local({
[11:00:05.942]                       for (pkg in "future.apply") {
[11:00:05.942]                         base::loadNamespace(pkg)
[11:00:05.942]                         base::library(pkg, character.only = TRUE)
[11:00:05.942]                       }
[11:00:05.942]                     })
[11:00:05.942]                   }
[11:00:05.942]                   ...future.strategy.old <- future::plan("list")
[11:00:05.942]                   options(future.plan = NULL)
[11:00:05.942]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:05.942]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:05.942]                 }
[11:00:05.942]                 ...future.workdir <- getwd()
[11:00:05.942]             }
[11:00:05.942]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:05.942]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:05.942]         }
[11:00:05.942]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:05.942]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:05.942]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:05.942]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:05.942]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:05.942]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:05.942]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:05.942]             base::names(...future.oldOptions))
[11:00:05.942]     }
[11:00:05.942]     if (FALSE) {
[11:00:05.942]     }
[11:00:05.942]     else {
[11:00:05.942]         if (TRUE) {
[11:00:05.942]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:05.942]                 open = "w")
[11:00:05.942]         }
[11:00:05.942]         else {
[11:00:05.942]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:05.942]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:05.942]         }
[11:00:05.942]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:05.942]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:05.942]             base::sink(type = "output", split = FALSE)
[11:00:05.942]             base::close(...future.stdout)
[11:00:05.942]         }, add = TRUE)
[11:00:05.942]     }
[11:00:05.942]     ...future.frame <- base::sys.nframe()
[11:00:05.942]     ...future.conditions <- base::list()
[11:00:05.942]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:05.942]     if (FALSE) {
[11:00:05.942]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:05.942]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:05.942]     }
[11:00:05.942]     ...future.result <- base::tryCatch({
[11:00:05.942]         base::withCallingHandlers({
[11:00:05.942]             ...future.value <- base::withVisible(base::local({
[11:00:05.942]                 ...future.makeSendCondition <- base::local({
[11:00:05.942]                   sendCondition <- NULL
[11:00:05.942]                   function(frame = 1L) {
[11:00:05.942]                     if (is.function(sendCondition)) 
[11:00:05.942]                       return(sendCondition)
[11:00:05.942]                     ns <- getNamespace("parallel")
[11:00:05.942]                     if (exists("sendData", mode = "function", 
[11:00:05.942]                       envir = ns)) {
[11:00:05.942]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:05.942]                         envir = ns)
[11:00:05.942]                       envir <- sys.frame(frame)
[11:00:05.942]                       master <- NULL
[11:00:05.942]                       while (!identical(envir, .GlobalEnv) && 
[11:00:05.942]                         !identical(envir, emptyenv())) {
[11:00:05.942]                         if (exists("master", mode = "list", envir = envir, 
[11:00:05.942]                           inherits = FALSE)) {
[11:00:05.942]                           master <- get("master", mode = "list", 
[11:00:05.942]                             envir = envir, inherits = FALSE)
[11:00:05.942]                           if (inherits(master, c("SOCKnode", 
[11:00:05.942]                             "SOCK0node"))) {
[11:00:05.942]                             sendCondition <<- function(cond) {
[11:00:05.942]                               data <- list(type = "VALUE", value = cond, 
[11:00:05.942]                                 success = TRUE)
[11:00:05.942]                               parallel_sendData(master, data)
[11:00:05.942]                             }
[11:00:05.942]                             return(sendCondition)
[11:00:05.942]                           }
[11:00:05.942]                         }
[11:00:05.942]                         frame <- frame + 1L
[11:00:05.942]                         envir <- sys.frame(frame)
[11:00:05.942]                       }
[11:00:05.942]                     }
[11:00:05.942]                     sendCondition <<- function(cond) NULL
[11:00:05.942]                   }
[11:00:05.942]                 })
[11:00:05.942]                 withCallingHandlers({
[11:00:05.942]                   {
[11:00:05.942]                     do.call(function(...) {
[11:00:05.942]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:05.942]                       if (!identical(...future.globals.maxSize.org, 
[11:00:05.942]                         ...future.globals.maxSize)) {
[11:00:05.942]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:05.942]                         on.exit(options(oopts), add = TRUE)
[11:00:05.942]                       }
[11:00:05.942]                       {
[11:00:05.942]                         lapply(seq_along(...future.elements_ii), 
[11:00:05.942]                           FUN = function(jj) {
[11:00:05.942]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:05.942]                             ...future.FUN(...future.X_jj, ...)
[11:00:05.942]                           })
[11:00:05.942]                       }
[11:00:05.942]                     }, args = future.call.arguments)
[11:00:05.942]                   }
[11:00:05.942]                 }, immediateCondition = function(cond) {
[11:00:05.942]                   sendCondition <- ...future.makeSendCondition()
[11:00:05.942]                   sendCondition(cond)
[11:00:05.942]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:05.942]                   {
[11:00:05.942]                     inherits <- base::inherits
[11:00:05.942]                     invokeRestart <- base::invokeRestart
[11:00:05.942]                     is.null <- base::is.null
[11:00:05.942]                     muffled <- FALSE
[11:00:05.942]                     if (inherits(cond, "message")) {
[11:00:05.942]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:05.942]                       if (muffled) 
[11:00:05.942]                         invokeRestart("muffleMessage")
[11:00:05.942]                     }
[11:00:05.942]                     else if (inherits(cond, "warning")) {
[11:00:05.942]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:05.942]                       if (muffled) 
[11:00:05.942]                         invokeRestart("muffleWarning")
[11:00:05.942]                     }
[11:00:05.942]                     else if (inherits(cond, "condition")) {
[11:00:05.942]                       if (!is.null(pattern)) {
[11:00:05.942]                         computeRestarts <- base::computeRestarts
[11:00:05.942]                         grepl <- base::grepl
[11:00:05.942]                         restarts <- computeRestarts(cond)
[11:00:05.942]                         for (restart in restarts) {
[11:00:05.942]                           name <- restart$name
[11:00:05.942]                           if (is.null(name)) 
[11:00:05.942]                             next
[11:00:05.942]                           if (!grepl(pattern, name)) 
[11:00:05.942]                             next
[11:00:05.942]                           invokeRestart(restart)
[11:00:05.942]                           muffled <- TRUE
[11:00:05.942]                           break
[11:00:05.942]                         }
[11:00:05.942]                       }
[11:00:05.942]                     }
[11:00:05.942]                     invisible(muffled)
[11:00:05.942]                   }
[11:00:05.942]                   muffleCondition(cond)
[11:00:05.942]                 })
[11:00:05.942]             }))
[11:00:05.942]             future::FutureResult(value = ...future.value$value, 
[11:00:05.942]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:05.942]                   ...future.rng), globalenv = if (FALSE) 
[11:00:05.942]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:05.942]                     ...future.globalenv.names))
[11:00:05.942]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:05.942]         }, condition = base::local({
[11:00:05.942]             c <- base::c
[11:00:05.942]             inherits <- base::inherits
[11:00:05.942]             invokeRestart <- base::invokeRestart
[11:00:05.942]             length <- base::length
[11:00:05.942]             list <- base::list
[11:00:05.942]             seq.int <- base::seq.int
[11:00:05.942]             signalCondition <- base::signalCondition
[11:00:05.942]             sys.calls <- base::sys.calls
[11:00:05.942]             `[[` <- base::`[[`
[11:00:05.942]             `+` <- base::`+`
[11:00:05.942]             `<<-` <- base::`<<-`
[11:00:05.942]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:05.942]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:05.942]                   3L)]
[11:00:05.942]             }
[11:00:05.942]             function(cond) {
[11:00:05.942]                 is_error <- inherits(cond, "error")
[11:00:05.942]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:05.942]                   NULL)
[11:00:05.942]                 if (is_error) {
[11:00:05.942]                   sessionInformation <- function() {
[11:00:05.942]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:05.942]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:05.942]                       search = base::search(), system = base::Sys.info())
[11:00:05.942]                   }
[11:00:05.942]                   ...future.conditions[[length(...future.conditions) + 
[11:00:05.942]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:05.942]                     cond$call), session = sessionInformation(), 
[11:00:05.942]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:05.942]                   signalCondition(cond)
[11:00:05.942]                 }
[11:00:05.942]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:05.942]                 "immediateCondition"))) {
[11:00:05.942]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:05.942]                   ...future.conditions[[length(...future.conditions) + 
[11:00:05.942]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:05.942]                   if (TRUE && !signal) {
[11:00:05.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:05.942]                     {
[11:00:05.942]                       inherits <- base::inherits
[11:00:05.942]                       invokeRestart <- base::invokeRestart
[11:00:05.942]                       is.null <- base::is.null
[11:00:05.942]                       muffled <- FALSE
[11:00:05.942]                       if (inherits(cond, "message")) {
[11:00:05.942]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:05.942]                         if (muffled) 
[11:00:05.942]                           invokeRestart("muffleMessage")
[11:00:05.942]                       }
[11:00:05.942]                       else if (inherits(cond, "warning")) {
[11:00:05.942]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:05.942]                         if (muffled) 
[11:00:05.942]                           invokeRestart("muffleWarning")
[11:00:05.942]                       }
[11:00:05.942]                       else if (inherits(cond, "condition")) {
[11:00:05.942]                         if (!is.null(pattern)) {
[11:00:05.942]                           computeRestarts <- base::computeRestarts
[11:00:05.942]                           grepl <- base::grepl
[11:00:05.942]                           restarts <- computeRestarts(cond)
[11:00:05.942]                           for (restart in restarts) {
[11:00:05.942]                             name <- restart$name
[11:00:05.942]                             if (is.null(name)) 
[11:00:05.942]                               next
[11:00:05.942]                             if (!grepl(pattern, name)) 
[11:00:05.942]                               next
[11:00:05.942]                             invokeRestart(restart)
[11:00:05.942]                             muffled <- TRUE
[11:00:05.942]                             break
[11:00:05.942]                           }
[11:00:05.942]                         }
[11:00:05.942]                       }
[11:00:05.942]                       invisible(muffled)
[11:00:05.942]                     }
[11:00:05.942]                     muffleCondition(cond, pattern = "^muffle")
[11:00:05.942]                   }
[11:00:05.942]                 }
[11:00:05.942]                 else {
[11:00:05.942]                   if (TRUE) {
[11:00:05.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:05.942]                     {
[11:00:05.942]                       inherits <- base::inherits
[11:00:05.942]                       invokeRestart <- base::invokeRestart
[11:00:05.942]                       is.null <- base::is.null
[11:00:05.942]                       muffled <- FALSE
[11:00:05.942]                       if (inherits(cond, "message")) {
[11:00:05.942]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:05.942]                         if (muffled) 
[11:00:05.942]                           invokeRestart("muffleMessage")
[11:00:05.942]                       }
[11:00:05.942]                       else if (inherits(cond, "warning")) {
[11:00:05.942]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:05.942]                         if (muffled) 
[11:00:05.942]                           invokeRestart("muffleWarning")
[11:00:05.942]                       }
[11:00:05.942]                       else if (inherits(cond, "condition")) {
[11:00:05.942]                         if (!is.null(pattern)) {
[11:00:05.942]                           computeRestarts <- base::computeRestarts
[11:00:05.942]                           grepl <- base::grepl
[11:00:05.942]                           restarts <- computeRestarts(cond)
[11:00:05.942]                           for (restart in restarts) {
[11:00:05.942]                             name <- restart$name
[11:00:05.942]                             if (is.null(name)) 
[11:00:05.942]                               next
[11:00:05.942]                             if (!grepl(pattern, name)) 
[11:00:05.942]                               next
[11:00:05.942]                             invokeRestart(restart)
[11:00:05.942]                             muffled <- TRUE
[11:00:05.942]                             break
[11:00:05.942]                           }
[11:00:05.942]                         }
[11:00:05.942]                       }
[11:00:05.942]                       invisible(muffled)
[11:00:05.942]                     }
[11:00:05.942]                     muffleCondition(cond, pattern = "^muffle")
[11:00:05.942]                   }
[11:00:05.942]                 }
[11:00:05.942]             }
[11:00:05.942]         }))
[11:00:05.942]     }, error = function(ex) {
[11:00:05.942]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:05.942]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:05.942]                 ...future.rng), started = ...future.startTime, 
[11:00:05.942]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:05.942]             version = "1.8"), class = "FutureResult")
[11:00:05.942]     }, finally = {
[11:00:05.942]         if (!identical(...future.workdir, getwd())) 
[11:00:05.942]             setwd(...future.workdir)
[11:00:05.942]         {
[11:00:05.942]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:05.942]                 ...future.oldOptions$nwarnings <- NULL
[11:00:05.942]             }
[11:00:05.942]             base::options(...future.oldOptions)
[11:00:05.942]             if (.Platform$OS.type == "windows") {
[11:00:05.942]                 old_names <- names(...future.oldEnvVars)
[11:00:05.942]                 envs <- base::Sys.getenv()
[11:00:05.942]                 names <- names(envs)
[11:00:05.942]                 common <- intersect(names, old_names)
[11:00:05.942]                 added <- setdiff(names, old_names)
[11:00:05.942]                 removed <- setdiff(old_names, names)
[11:00:05.942]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:05.942]                   envs[common]]
[11:00:05.942]                 NAMES <- toupper(changed)
[11:00:05.942]                 args <- list()
[11:00:05.942]                 for (kk in seq_along(NAMES)) {
[11:00:05.942]                   name <- changed[[kk]]
[11:00:05.942]                   NAME <- NAMES[[kk]]
[11:00:05.942]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:05.942]                     next
[11:00:05.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:05.942]                 }
[11:00:05.942]                 NAMES <- toupper(added)
[11:00:05.942]                 for (kk in seq_along(NAMES)) {
[11:00:05.942]                   name <- added[[kk]]
[11:00:05.942]                   NAME <- NAMES[[kk]]
[11:00:05.942]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:05.942]                     next
[11:00:05.942]                   args[[name]] <- ""
[11:00:05.942]                 }
[11:00:05.942]                 NAMES <- toupper(removed)
[11:00:05.942]                 for (kk in seq_along(NAMES)) {
[11:00:05.942]                   name <- removed[[kk]]
[11:00:05.942]                   NAME <- NAMES[[kk]]
[11:00:05.942]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:05.942]                     next
[11:00:05.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:05.942]                 }
[11:00:05.942]                 if (length(args) > 0) 
[11:00:05.942]                   base::do.call(base::Sys.setenv, args = args)
[11:00:05.942]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:05.942]             }
[11:00:05.942]             else {
[11:00:05.942]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:05.942]             }
[11:00:05.942]             {
[11:00:05.942]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:05.942]                   0L) {
[11:00:05.942]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:05.942]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:05.942]                   base::options(opts)
[11:00:05.942]                 }
[11:00:05.942]                 {
[11:00:05.942]                   {
[11:00:05.942]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:05.942]                     NULL
[11:00:05.942]                   }
[11:00:05.942]                   options(future.plan = NULL)
[11:00:05.942]                   if (is.na(NA_character_)) 
[11:00:05.942]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:05.942]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:05.942]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:05.942]                     .init = FALSE)
[11:00:05.942]                 }
[11:00:05.942]             }
[11:00:05.942]         }
[11:00:05.942]     })
[11:00:05.942]     if (TRUE) {
[11:00:05.942]         base::sink(type = "output", split = FALSE)
[11:00:05.942]         if (TRUE) {
[11:00:05.942]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:05.942]         }
[11:00:05.942]         else {
[11:00:05.942]             ...future.result["stdout"] <- base::list(NULL)
[11:00:05.942]         }
[11:00:05.942]         base::close(...future.stdout)
[11:00:05.942]         ...future.stdout <- NULL
[11:00:05.942]     }
[11:00:05.942]     ...future.result$conditions <- ...future.conditions
[11:00:05.942]     ...future.result$finished <- base::Sys.time()
[11:00:05.942]     ...future.result
[11:00:05.942] }
[11:00:05.945] Exporting 11 global objects (14.06 KiB) to cluster node #1 ...
[11:00:05.945] Exporting ‘...future.FUN’ (5.08 KiB) to cluster node #1 ...
[11:00:05.989] Exporting ‘...future.FUN’ (5.08 KiB) to cluster node #1 ... DONE
[11:00:05.989] Exporting ‘x_FUN’ (567 bytes) to cluster node #1 ...
[11:00:05.989] Exporting ‘x_FUN’ (567 bytes) to cluster node #1 ... DONE
[11:00:05.989] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[11:00:05.990] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[11:00:05.990] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[11:00:06.031] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[11:00:06.031] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[11:00:06.072] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[11:00:06.072] Exporting ‘dim’ (39 bytes) to cluster node #1 ...
[11:00:06.072] Exporting ‘dim’ (39 bytes) to cluster node #1 ... DONE
[11:00:06.072] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[11:00:06.073] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[11:00:06.073] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[11:00:06.073] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[11:00:06.073] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ...
[11:00:06.074] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ... DONE
[11:00:06.074] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[11:00:06.074] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[11:00:06.074] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[11:00:06.074] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[11:00:06.075] Exporting 11 global objects (14.06 KiB) to cluster node #1 ... DONE
[11:00:06.075] MultisessionFuture started
[11:00:06.075] - Launch lazy future ... done
[11:00:06.075] run() for ‘MultisessionFuture’ ... done
[11:00:06.075] Created future:
[11:00:06.075] MultisessionFuture:
[11:00:06.075] Label: ‘future_vapply-1’
[11:00:06.075] Expression:
[11:00:06.075] {
[11:00:06.075]     do.call(function(...) {
[11:00:06.075]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:06.075]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:06.075]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:06.075]             on.exit(options(oopts), add = TRUE)
[11:00:06.075]         }
[11:00:06.075]         {
[11:00:06.075]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:06.075]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:06.075]                 ...future.FUN(...future.X_jj, ...)
[11:00:06.075]             })
[11:00:06.075]         }
[11:00:06.075]     }, args = future.call.arguments)
[11:00:06.075] }
[11:00:06.075] Lazy evaluation: FALSE
[11:00:06.075] Asynchronous evaluation: TRUE
[11:00:06.075] Local evaluation: TRUE
[11:00:06.075] Environment: R_GlobalEnv
[11:00:06.075] Capture standard output: TRUE
[11:00:06.075] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:06.075] Globals: 11 objects totaling 13.86 KiB (function ‘...future.FUN’ of 5.08 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:06.075] Packages: 1 packages (‘future.apply’)
[11:00:06.075] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:06.075] Resolved: FALSE
[11:00:06.075] Value: <not collected>
[11:00:06.075] Conditions captured: <none>
[11:00:06.075] Early signaling: FALSE
[11:00:06.075] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:06.075] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:06.087] Chunk #1 of 2 ... DONE
[11:00:06.087] Chunk #2 of 2 ...
[11:00:06.087]  - Finding globals in 'X' for chunk #2 ...
[11:00:06.087] getGlobalsAndPackages() ...
[11:00:06.087] Searching for globals...
[11:00:06.087] 
[11:00:06.088] Searching for globals ... DONE
[11:00:06.088] - globals: [0] <none>
[11:00:06.088] getGlobalsAndPackages() ... DONE
[11:00:06.088]    + additional globals found: [n=0] 
[11:00:06.088]    + additional namespaces needed: [n=0] 
[11:00:06.088]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:06.088]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:06.088]  - seeds: <none>
[11:00:06.088]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:06.088] getGlobalsAndPackages() ...
[11:00:06.088] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:06.089] Resolving globals: FALSE
[11:00:06.089] Tweak future expression to call with '...' arguments ...
[11:00:06.089] {
[11:00:06.089]     do.call(function(...) {
[11:00:06.089]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:06.089]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:06.089]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:06.089]             on.exit(options(oopts), add = TRUE)
[11:00:06.089]         }
[11:00:06.089]         {
[11:00:06.089]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:06.089]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:06.089]                 ...future.FUN(...future.X_jj, ...)
[11:00:06.089]             })
[11:00:06.089]         }
[11:00:06.089]     }, args = future.call.arguments)
[11:00:06.089] }
[11:00:06.089] Tweak future expression to call with '...' arguments ... DONE
[11:00:06.089] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:06.090] - packages: [1] ‘future.apply’
[11:00:06.090] getGlobalsAndPackages() ... DONE
[11:00:06.090] run() for ‘Future’ ...
[11:00:06.090] - state: ‘created’
[11:00:06.090] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:06.104] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:06.104] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:06.104]   - Field: ‘node’
[11:00:06.104]   - Field: ‘label’
[11:00:06.104]   - Field: ‘local’
[11:00:06.104]   - Field: ‘owner’
[11:00:06.104]   - Field: ‘envir’
[11:00:06.104]   - Field: ‘workers’
[11:00:06.104]   - Field: ‘packages’
[11:00:06.104]   - Field: ‘gc’
[11:00:06.105]   - Field: ‘conditions’
[11:00:06.105]   - Field: ‘persistent’
[11:00:06.105]   - Field: ‘expr’
[11:00:06.105]   - Field: ‘uuid’
[11:00:06.105]   - Field: ‘seed’
[11:00:06.105]   - Field: ‘version’
[11:00:06.105]   - Field: ‘result’
[11:00:06.105]   - Field: ‘asynchronous’
[11:00:06.105]   - Field: ‘calls’
[11:00:06.105]   - Field: ‘globals’
[11:00:06.105]   - Field: ‘stdout’
[11:00:06.106]   - Field: ‘earlySignal’
[11:00:06.106]   - Field: ‘lazy’
[11:00:06.106]   - Field: ‘state’
[11:00:06.106] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:06.106] - Launch lazy future ...
[11:00:06.106] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:06.106] Packages needed by future strategies (n = 0): <none>
[11:00:06.107] {
[11:00:06.107]     {
[11:00:06.107]         {
[11:00:06.107]             ...future.startTime <- base::Sys.time()
[11:00:06.107]             {
[11:00:06.107]                 {
[11:00:06.107]                   {
[11:00:06.107]                     {
[11:00:06.107]                       {
[11:00:06.107]                         base::local({
[11:00:06.107]                           has_future <- base::requireNamespace("future", 
[11:00:06.107]                             quietly = TRUE)
[11:00:06.107]                           if (has_future) {
[11:00:06.107]                             ns <- base::getNamespace("future")
[11:00:06.107]                             version <- ns[[".package"]][["version"]]
[11:00:06.107]                             if (is.null(version)) 
[11:00:06.107]                               version <- utils::packageVersion("future")
[11:00:06.107]                           }
[11:00:06.107]                           else {
[11:00:06.107]                             version <- NULL
[11:00:06.107]                           }
[11:00:06.107]                           if (!has_future || version < "1.8.0") {
[11:00:06.107]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:06.107]                               "", base::R.version$version.string), 
[11:00:06.107]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:06.107]                                 base::R.version$platform, 8 * 
[11:00:06.107]                                   base::.Machine$sizeof.pointer), 
[11:00:06.107]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:06.107]                                 "release", "version")], collapse = " "), 
[11:00:06.107]                               hostname = base::Sys.info()[["nodename"]])
[11:00:06.107]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:06.107]                               info)
[11:00:06.107]                             info <- base::paste(info, collapse = "; ")
[11:00:06.107]                             if (!has_future) {
[11:00:06.107]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:06.107]                                 info)
[11:00:06.107]                             }
[11:00:06.107]                             else {
[11:00:06.107]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:06.107]                                 info, version)
[11:00:06.107]                             }
[11:00:06.107]                             base::stop(msg)
[11:00:06.107]                           }
[11:00:06.107]                         })
[11:00:06.107]                       }
[11:00:06.107]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:06.107]                       base::options(mc.cores = 1L)
[11:00:06.107]                     }
[11:00:06.107]                     base::local({
[11:00:06.107]                       for (pkg in "future.apply") {
[11:00:06.107]                         base::loadNamespace(pkg)
[11:00:06.107]                         base::library(pkg, character.only = TRUE)
[11:00:06.107]                       }
[11:00:06.107]                     })
[11:00:06.107]                   }
[11:00:06.107]                   ...future.strategy.old <- future::plan("list")
[11:00:06.107]                   options(future.plan = NULL)
[11:00:06.107]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:06.107]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:06.107]                 }
[11:00:06.107]                 ...future.workdir <- getwd()
[11:00:06.107]             }
[11:00:06.107]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:06.107]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:06.107]         }
[11:00:06.107]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:06.107]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:06.107]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:06.107]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:06.107]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:06.107]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:06.107]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:06.107]             base::names(...future.oldOptions))
[11:00:06.107]     }
[11:00:06.107]     if (FALSE) {
[11:00:06.107]     }
[11:00:06.107]     else {
[11:00:06.107]         if (TRUE) {
[11:00:06.107]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:06.107]                 open = "w")
[11:00:06.107]         }
[11:00:06.107]         else {
[11:00:06.107]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:06.107]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:06.107]         }
[11:00:06.107]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:06.107]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:06.107]             base::sink(type = "output", split = FALSE)
[11:00:06.107]             base::close(...future.stdout)
[11:00:06.107]         }, add = TRUE)
[11:00:06.107]     }
[11:00:06.107]     ...future.frame <- base::sys.nframe()
[11:00:06.107]     ...future.conditions <- base::list()
[11:00:06.107]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:06.107]     if (FALSE) {
[11:00:06.107]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:06.107]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:06.107]     }
[11:00:06.107]     ...future.result <- base::tryCatch({
[11:00:06.107]         base::withCallingHandlers({
[11:00:06.107]             ...future.value <- base::withVisible(base::local({
[11:00:06.107]                 ...future.makeSendCondition <- base::local({
[11:00:06.107]                   sendCondition <- NULL
[11:00:06.107]                   function(frame = 1L) {
[11:00:06.107]                     if (is.function(sendCondition)) 
[11:00:06.107]                       return(sendCondition)
[11:00:06.107]                     ns <- getNamespace("parallel")
[11:00:06.107]                     if (exists("sendData", mode = "function", 
[11:00:06.107]                       envir = ns)) {
[11:00:06.107]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:06.107]                         envir = ns)
[11:00:06.107]                       envir <- sys.frame(frame)
[11:00:06.107]                       master <- NULL
[11:00:06.107]                       while (!identical(envir, .GlobalEnv) && 
[11:00:06.107]                         !identical(envir, emptyenv())) {
[11:00:06.107]                         if (exists("master", mode = "list", envir = envir, 
[11:00:06.107]                           inherits = FALSE)) {
[11:00:06.107]                           master <- get("master", mode = "list", 
[11:00:06.107]                             envir = envir, inherits = FALSE)
[11:00:06.107]                           if (inherits(master, c("SOCKnode", 
[11:00:06.107]                             "SOCK0node"))) {
[11:00:06.107]                             sendCondition <<- function(cond) {
[11:00:06.107]                               data <- list(type = "VALUE", value = cond, 
[11:00:06.107]                                 success = TRUE)
[11:00:06.107]                               parallel_sendData(master, data)
[11:00:06.107]                             }
[11:00:06.107]                             return(sendCondition)
[11:00:06.107]                           }
[11:00:06.107]                         }
[11:00:06.107]                         frame <- frame + 1L
[11:00:06.107]                         envir <- sys.frame(frame)
[11:00:06.107]                       }
[11:00:06.107]                     }
[11:00:06.107]                     sendCondition <<- function(cond) NULL
[11:00:06.107]                   }
[11:00:06.107]                 })
[11:00:06.107]                 withCallingHandlers({
[11:00:06.107]                   {
[11:00:06.107]                     do.call(function(...) {
[11:00:06.107]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:06.107]                       if (!identical(...future.globals.maxSize.org, 
[11:00:06.107]                         ...future.globals.maxSize)) {
[11:00:06.107]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:06.107]                         on.exit(options(oopts), add = TRUE)
[11:00:06.107]                       }
[11:00:06.107]                       {
[11:00:06.107]                         lapply(seq_along(...future.elements_ii), 
[11:00:06.107]                           FUN = function(jj) {
[11:00:06.107]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:06.107]                             ...future.FUN(...future.X_jj, ...)
[11:00:06.107]                           })
[11:00:06.107]                       }
[11:00:06.107]                     }, args = future.call.arguments)
[11:00:06.107]                   }
[11:00:06.107]                 }, immediateCondition = function(cond) {
[11:00:06.107]                   sendCondition <- ...future.makeSendCondition()
[11:00:06.107]                   sendCondition(cond)
[11:00:06.107]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:06.107]                   {
[11:00:06.107]                     inherits <- base::inherits
[11:00:06.107]                     invokeRestart <- base::invokeRestart
[11:00:06.107]                     is.null <- base::is.null
[11:00:06.107]                     muffled <- FALSE
[11:00:06.107]                     if (inherits(cond, "message")) {
[11:00:06.107]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:06.107]                       if (muffled) 
[11:00:06.107]                         invokeRestart("muffleMessage")
[11:00:06.107]                     }
[11:00:06.107]                     else if (inherits(cond, "warning")) {
[11:00:06.107]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:06.107]                       if (muffled) 
[11:00:06.107]                         invokeRestart("muffleWarning")
[11:00:06.107]                     }
[11:00:06.107]                     else if (inherits(cond, "condition")) {
[11:00:06.107]                       if (!is.null(pattern)) {
[11:00:06.107]                         computeRestarts <- base::computeRestarts
[11:00:06.107]                         grepl <- base::grepl
[11:00:06.107]                         restarts <- computeRestarts(cond)
[11:00:06.107]                         for (restart in restarts) {
[11:00:06.107]                           name <- restart$name
[11:00:06.107]                           if (is.null(name)) 
[11:00:06.107]                             next
[11:00:06.107]                           if (!grepl(pattern, name)) 
[11:00:06.107]                             next
[11:00:06.107]                           invokeRestart(restart)
[11:00:06.107]                           muffled <- TRUE
[11:00:06.107]                           break
[11:00:06.107]                         }
[11:00:06.107]                       }
[11:00:06.107]                     }
[11:00:06.107]                     invisible(muffled)
[11:00:06.107]                   }
[11:00:06.107]                   muffleCondition(cond)
[11:00:06.107]                 })
[11:00:06.107]             }))
[11:00:06.107]             future::FutureResult(value = ...future.value$value, 
[11:00:06.107]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:06.107]                   ...future.rng), globalenv = if (FALSE) 
[11:00:06.107]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:06.107]                     ...future.globalenv.names))
[11:00:06.107]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:06.107]         }, condition = base::local({
[11:00:06.107]             c <- base::c
[11:00:06.107]             inherits <- base::inherits
[11:00:06.107]             invokeRestart <- base::invokeRestart
[11:00:06.107]             length <- base::length
[11:00:06.107]             list <- base::list
[11:00:06.107]             seq.int <- base::seq.int
[11:00:06.107]             signalCondition <- base::signalCondition
[11:00:06.107]             sys.calls <- base::sys.calls
[11:00:06.107]             `[[` <- base::`[[`
[11:00:06.107]             `+` <- base::`+`
[11:00:06.107]             `<<-` <- base::`<<-`
[11:00:06.107]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:06.107]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:06.107]                   3L)]
[11:00:06.107]             }
[11:00:06.107]             function(cond) {
[11:00:06.107]                 is_error <- inherits(cond, "error")
[11:00:06.107]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:06.107]                   NULL)
[11:00:06.107]                 if (is_error) {
[11:00:06.107]                   sessionInformation <- function() {
[11:00:06.107]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:06.107]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:06.107]                       search = base::search(), system = base::Sys.info())
[11:00:06.107]                   }
[11:00:06.107]                   ...future.conditions[[length(...future.conditions) + 
[11:00:06.107]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:06.107]                     cond$call), session = sessionInformation(), 
[11:00:06.107]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:06.107]                   signalCondition(cond)
[11:00:06.107]                 }
[11:00:06.107]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:06.107]                 "immediateCondition"))) {
[11:00:06.107]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:06.107]                   ...future.conditions[[length(...future.conditions) + 
[11:00:06.107]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:06.107]                   if (TRUE && !signal) {
[11:00:06.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:06.107]                     {
[11:00:06.107]                       inherits <- base::inherits
[11:00:06.107]                       invokeRestart <- base::invokeRestart
[11:00:06.107]                       is.null <- base::is.null
[11:00:06.107]                       muffled <- FALSE
[11:00:06.107]                       if (inherits(cond, "message")) {
[11:00:06.107]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:06.107]                         if (muffled) 
[11:00:06.107]                           invokeRestart("muffleMessage")
[11:00:06.107]                       }
[11:00:06.107]                       else if (inherits(cond, "warning")) {
[11:00:06.107]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:06.107]                         if (muffled) 
[11:00:06.107]                           invokeRestart("muffleWarning")
[11:00:06.107]                       }
[11:00:06.107]                       else if (inherits(cond, "condition")) {
[11:00:06.107]                         if (!is.null(pattern)) {
[11:00:06.107]                           computeRestarts <- base::computeRestarts
[11:00:06.107]                           grepl <- base::grepl
[11:00:06.107]                           restarts <- computeRestarts(cond)
[11:00:06.107]                           for (restart in restarts) {
[11:00:06.107]                             name <- restart$name
[11:00:06.107]                             if (is.null(name)) 
[11:00:06.107]                               next
[11:00:06.107]                             if (!grepl(pattern, name)) 
[11:00:06.107]                               next
[11:00:06.107]                             invokeRestart(restart)
[11:00:06.107]                             muffled <- TRUE
[11:00:06.107]                             break
[11:00:06.107]                           }
[11:00:06.107]                         }
[11:00:06.107]                       }
[11:00:06.107]                       invisible(muffled)
[11:00:06.107]                     }
[11:00:06.107]                     muffleCondition(cond, pattern = "^muffle")
[11:00:06.107]                   }
[11:00:06.107]                 }
[11:00:06.107]                 else {
[11:00:06.107]                   if (TRUE) {
[11:00:06.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:06.107]                     {
[11:00:06.107]                       inherits <- base::inherits
[11:00:06.107]                       invokeRestart <- base::invokeRestart
[11:00:06.107]                       is.null <- base::is.null
[11:00:06.107]                       muffled <- FALSE
[11:00:06.107]                       if (inherits(cond, "message")) {
[11:00:06.107]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:06.107]                         if (muffled) 
[11:00:06.107]                           invokeRestart("muffleMessage")
[11:00:06.107]                       }
[11:00:06.107]                       else if (inherits(cond, "warning")) {
[11:00:06.107]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:06.107]                         if (muffled) 
[11:00:06.107]                           invokeRestart("muffleWarning")
[11:00:06.107]                       }
[11:00:06.107]                       else if (inherits(cond, "condition")) {
[11:00:06.107]                         if (!is.null(pattern)) {
[11:00:06.107]                           computeRestarts <- base::computeRestarts
[11:00:06.107]                           grepl <- base::grepl
[11:00:06.107]                           restarts <- computeRestarts(cond)
[11:00:06.107]                           for (restart in restarts) {
[11:00:06.107]                             name <- restart$name
[11:00:06.107]                             if (is.null(name)) 
[11:00:06.107]                               next
[11:00:06.107]                             if (!grepl(pattern, name)) 
[11:00:06.107]                               next
[11:00:06.107]                             invokeRestart(restart)
[11:00:06.107]                             muffled <- TRUE
[11:00:06.107]                             break
[11:00:06.107]                           }
[11:00:06.107]                         }
[11:00:06.107]                       }
[11:00:06.107]                       invisible(muffled)
[11:00:06.107]                     }
[11:00:06.107]                     muffleCondition(cond, pattern = "^muffle")
[11:00:06.107]                   }
[11:00:06.107]                 }
[11:00:06.107]             }
[11:00:06.107]         }))
[11:00:06.107]     }, error = function(ex) {
[11:00:06.107]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:06.107]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:06.107]                 ...future.rng), started = ...future.startTime, 
[11:00:06.107]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:06.107]             version = "1.8"), class = "FutureResult")
[11:00:06.107]     }, finally = {
[11:00:06.107]         if (!identical(...future.workdir, getwd())) 
[11:00:06.107]             setwd(...future.workdir)
[11:00:06.107]         {
[11:00:06.107]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:06.107]                 ...future.oldOptions$nwarnings <- NULL
[11:00:06.107]             }
[11:00:06.107]             base::options(...future.oldOptions)
[11:00:06.107]             if (.Platform$OS.type == "windows") {
[11:00:06.107]                 old_names <- names(...future.oldEnvVars)
[11:00:06.107]                 envs <- base::Sys.getenv()
[11:00:06.107]                 names <- names(envs)
[11:00:06.107]                 common <- intersect(names, old_names)
[11:00:06.107]                 added <- setdiff(names, old_names)
[11:00:06.107]                 removed <- setdiff(old_names, names)
[11:00:06.107]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:06.107]                   envs[common]]
[11:00:06.107]                 NAMES <- toupper(changed)
[11:00:06.107]                 args <- list()
[11:00:06.107]                 for (kk in seq_along(NAMES)) {
[11:00:06.107]                   name <- changed[[kk]]
[11:00:06.107]                   NAME <- NAMES[[kk]]
[11:00:06.107]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:06.107]                     next
[11:00:06.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:06.107]                 }
[11:00:06.107]                 NAMES <- toupper(added)
[11:00:06.107]                 for (kk in seq_along(NAMES)) {
[11:00:06.107]                   name <- added[[kk]]
[11:00:06.107]                   NAME <- NAMES[[kk]]
[11:00:06.107]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:06.107]                     next
[11:00:06.107]                   args[[name]] <- ""
[11:00:06.107]                 }
[11:00:06.107]                 NAMES <- toupper(removed)
[11:00:06.107]                 for (kk in seq_along(NAMES)) {
[11:00:06.107]                   name <- removed[[kk]]
[11:00:06.107]                   NAME <- NAMES[[kk]]
[11:00:06.107]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:06.107]                     next
[11:00:06.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:06.107]                 }
[11:00:06.107]                 if (length(args) > 0) 
[11:00:06.107]                   base::do.call(base::Sys.setenv, args = args)
[11:00:06.107]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:06.107]             }
[11:00:06.107]             else {
[11:00:06.107]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:06.107]             }
[11:00:06.107]             {
[11:00:06.107]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:06.107]                   0L) {
[11:00:06.107]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:06.107]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:06.107]                   base::options(opts)
[11:00:06.107]                 }
[11:00:06.107]                 {
[11:00:06.107]                   {
[11:00:06.107]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:06.107]                     NULL
[11:00:06.107]                   }
[11:00:06.107]                   options(future.plan = NULL)
[11:00:06.107]                   if (is.na(NA_character_)) 
[11:00:06.107]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:06.107]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:06.107]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:06.107]                     .init = FALSE)
[11:00:06.107]                 }
[11:00:06.107]             }
[11:00:06.107]         }
[11:00:06.107]     })
[11:00:06.107]     if (TRUE) {
[11:00:06.107]         base::sink(type = "output", split = FALSE)
[11:00:06.107]         if (TRUE) {
[11:00:06.107]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:06.107]         }
[11:00:06.107]         else {
[11:00:06.107]             ...future.result["stdout"] <- base::list(NULL)
[11:00:06.107]         }
[11:00:06.107]         base::close(...future.stdout)
[11:00:06.107]         ...future.stdout <- NULL
[11:00:06.107]     }
[11:00:06.107]     ...future.result$conditions <- ...future.conditions
[11:00:06.107]     ...future.result$finished <- base::Sys.time()
[11:00:06.107]     ...future.result
[11:00:06.107] }
[11:00:06.110] Exporting 11 global objects (14.06 KiB) to cluster node #2 ...
[11:00:06.110] Exporting ‘...future.FUN’ (5.08 KiB) to cluster node #2 ...
[11:00:06.151] Exporting ‘...future.FUN’ (5.08 KiB) to cluster node #2 ... DONE
[11:00:06.151] Exporting ‘x_FUN’ (567 bytes) to cluster node #2 ...
[11:00:06.151] Exporting ‘x_FUN’ (567 bytes) to cluster node #2 ... DONE
[11:00:06.151] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[11:00:06.152] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[11:00:06.152] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[11:00:06.193] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[11:00:06.193] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[11:00:06.234] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[11:00:06.234] Exporting ‘dim’ (39 bytes) to cluster node #2 ...
[11:00:06.234] Exporting ‘dim’ (39 bytes) to cluster node #2 ... DONE
[11:00:06.234] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[11:00:06.235] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[11:00:06.235] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[11:00:06.235] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[11:00:06.235] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ...
[11:00:06.236] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ... DONE
[11:00:06.236] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[11:00:06.236] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[11:00:06.236] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[11:00:06.237] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[11:00:06.237] Exporting 11 global objects (14.06 KiB) to cluster node #2 ... DONE
[11:00:06.237] MultisessionFuture started
[11:00:06.237] - Launch lazy future ... done
[11:00:06.238] run() for ‘MultisessionFuture’ ... done
[11:00:06.238] Created future:
[11:00:06.238] MultisessionFuture:
[11:00:06.238] Label: ‘future_vapply-2’
[11:00:06.238] Expression:
[11:00:06.238] {
[11:00:06.238]     do.call(function(...) {
[11:00:06.238]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:06.238]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:06.238]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:06.238]             on.exit(options(oopts), add = TRUE)
[11:00:06.238]         }
[11:00:06.238]         {
[11:00:06.238]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:06.238]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:06.238]                 ...future.FUN(...future.X_jj, ...)
[11:00:06.238]             })
[11:00:06.238]         }
[11:00:06.238]     }, args = future.call.arguments)
[11:00:06.238] }
[11:00:06.238] Lazy evaluation: FALSE
[11:00:06.238] Asynchronous evaluation: TRUE
[11:00:06.238] Local evaluation: TRUE
[11:00:06.238] Environment: R_GlobalEnv
[11:00:06.238] Capture standard output: TRUE
[11:00:06.238] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:06.238] Globals: 11 objects totaling 13.86 KiB (function ‘...future.FUN’ of 5.08 KiB, function ‘x_FUN’ of 567 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:06.238] Packages: 1 packages (‘future.apply’)
[11:00:06.238] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:06.238] Resolved: FALSE
[11:00:06.238] Value: <not collected>
[11:00:06.238] Conditions captured: <none>
[11:00:06.238] Early signaling: FALSE
[11:00:06.238] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:06.238] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:06.249] Chunk #2 of 2 ... DONE
[11:00:06.249] Launching 2 futures (chunks) ... DONE
[11:00:06.249] Resolving 2 futures (chunks) ...
[11:00:06.250] resolve() on list ...
[11:00:06.250]  recursive: 0
[11:00:06.250]  length: 2
[11:00:06.250] 
[11:00:06.250] receiveMessageFromWorker() for ClusterFuture ...
[11:00:06.250] - Validating connection of MultisessionFuture
[11:00:06.251] - received message: FutureResult
[11:00:06.251] - Received FutureResult
[11:00:06.251] - Erased future from FutureRegistry
[11:00:06.251] result() for ClusterFuture ...
[11:00:06.251] - result already collected: FutureResult
[11:00:06.251] result() for ClusterFuture ... done
[11:00:06.251] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:06.251] Future #1
[11:00:06.251] result() for ClusterFuture ...
[11:00:06.251] - result already collected: FutureResult
[11:00:06.251] result() for ClusterFuture ... done
[11:00:06.251] result() for ClusterFuture ...
[11:00:06.252] - result already collected: FutureResult
[11:00:06.252] result() for ClusterFuture ... done
[11:00:06.252] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:00:06.252] - nx: 2
[11:00:06.252] - relay: TRUE
[11:00:06.252] - stdout: TRUE
[11:00:06.252] - signal: TRUE
[11:00:06.252] - resignal: FALSE
[11:00:06.252] - force: TRUE
[11:00:06.252] - relayed: [n=2] FALSE, FALSE
[11:00:06.252] - queued futures: [n=2] FALSE, FALSE
[11:00:06.252]  - until=1
[11:00:06.252]  - relaying element #1
[11:00:06.253] result() for ClusterFuture ...
[11:00:06.253] - result already collected: FutureResult
[11:00:06.253] result() for ClusterFuture ... done
[11:00:06.253] result() for ClusterFuture ...
[11:00:06.253] - result already collected: FutureResult
[11:00:06.253] result() for ClusterFuture ... done
[11:00:06.253] result() for ClusterFuture ...
[11:00:06.253] - result already collected: FutureResult
[11:00:06.253] result() for ClusterFuture ... done
[11:00:06.253] result() for ClusterFuture ...
[11:00:06.253] - result already collected: FutureResult
[11:00:06.253] result() for ClusterFuture ... done
[11:00:06.254] - relayed: [n=2] TRUE, FALSE
[11:00:06.254] - queued futures: [n=2] TRUE, FALSE
[11:00:06.254] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:00:06.254]  length: 1 (resolved future 1)
[11:00:06.279] receiveMessageFromWorker() for ClusterFuture ...
[11:00:06.280] - Validating connection of MultisessionFuture
[11:00:06.280] - received message: FutureResult
[11:00:06.280] - Received FutureResult
[11:00:06.280] - Erased future from FutureRegistry
[11:00:06.280] result() for ClusterFuture ...
[11:00:06.280] - result already collected: FutureResult
[11:00:06.280] result() for ClusterFuture ... done
[11:00:06.280] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:06.280] Future #2
[11:00:06.281] result() for ClusterFuture ...
[11:00:06.281] - result already collected: FutureResult
[11:00:06.281] result() for ClusterFuture ... done
[11:00:06.281] result() for ClusterFuture ...
[11:00:06.281] - result already collected: FutureResult
[11:00:06.281] result() for ClusterFuture ... done
[11:00:06.281] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:00:06.281] - nx: 2
[11:00:06.281] - relay: TRUE
[11:00:06.281] - stdout: TRUE
[11:00:06.281] - signal: TRUE
[11:00:06.281] - resignal: FALSE
[11:00:06.281] - force: TRUE
[11:00:06.282] - relayed: [n=2] TRUE, FALSE
[11:00:06.282] - queued futures: [n=2] TRUE, FALSE
[11:00:06.282]  - until=2
[11:00:06.282]  - relaying element #2
[11:00:06.282] result() for ClusterFuture ...
[11:00:06.282] - result already collected: FutureResult
[11:00:06.282] result() for ClusterFuture ... done
[11:00:06.282] result() for ClusterFuture ...
[11:00:06.282] - result already collected: FutureResult
[11:00:06.282] result() for ClusterFuture ... done
[11:00:06.282] result() for ClusterFuture ...
[11:00:06.282] - result already collected: FutureResult
[11:00:06.283] result() for ClusterFuture ... done
[11:00:06.283] result() for ClusterFuture ...
[11:00:06.283] - result already collected: FutureResult
[11:00:06.283] result() for ClusterFuture ... done
[11:00:06.283] - relayed: [n=2] TRUE, TRUE
[11:00:06.283] - queued futures: [n=2] TRUE, TRUE
[11:00:06.283] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:00:06.283]  length: 0 (resolved future 2)
[11:00:06.283] Relaying remaining futures
[11:00:06.283] signalConditionsASAP(NULL, pos=0) ...
[11:00:06.283] - nx: 2
[11:00:06.283] - relay: TRUE
[11:00:06.284] - stdout: TRUE
[11:00:06.284] - signal: TRUE
[11:00:06.284] - resignal: FALSE
[11:00:06.284] - force: TRUE
[11:00:06.284] - relayed: [n=2] TRUE, TRUE
[11:00:06.284] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:06.284] - relayed: [n=2] TRUE, TRUE
[11:00:06.284] - queued futures: [n=2] TRUE, TRUE
[11:00:06.284] signalConditionsASAP(NULL, pos=0) ... done
[11:00:06.284] resolve() on list ... DONE
[11:00:06.284] result() for ClusterFuture ...
[11:00:06.284] - result already collected: FutureResult
[11:00:06.285] result() for ClusterFuture ... done
[11:00:06.285] result() for ClusterFuture ...
[11:00:06.285] - result already collected: FutureResult
[11:00:06.285] result() for ClusterFuture ... done
[11:00:06.285] result() for ClusterFuture ...
[11:00:06.285] - result already collected: FutureResult
[11:00:06.285] result() for ClusterFuture ... done
[11:00:06.285] result() for ClusterFuture ...
[11:00:06.285] - result already collected: FutureResult
[11:00:06.285] result() for ClusterFuture ... done
[11:00:06.285]  - Number of value chunks collected: 2
[11:00:06.285] Resolving 2 futures (chunks) ... DONE
[11:00:06.286] Reducing values from 2 chunks ...
[11:00:06.286]  - Number of values collected after concatenation: 10
[11:00:06.286]  - Number of values expected: 10
[11:00:06.286] Reducing values from 2 chunks ... DONE
[11:00:06.286] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[11:00:06.288] future_lapply() ...
[11:00:06.291] Number of chunks: 2
[11:00:06.291] getGlobalsAndPackagesXApply() ...
[11:00:06.291]  - future.globals: TRUE
[11:00:06.291] getGlobalsAndPackages() ...
[11:00:06.291] Searching for globals...
[11:00:06.295] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[11:00:06.295] Searching for globals ... DONE
[11:00:06.295] Resolving globals: FALSE
[11:00:06.296] The total size of the 7 globals is 16.05 KiB (16436 bytes)
[11:00:06.296] The total size of the 7 globals exported for future expression (‘FUN()’) is 16.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (6.71 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:06.296] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:06.297] - packages: [1] ‘future.apply’
[11:00:06.297] getGlobalsAndPackages() ... DONE
[11:00:06.297]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:06.297]  - needed namespaces: [n=1] ‘future.apply’
[11:00:06.297] Finding globals ... DONE
[11:00:06.297]  - use_args: TRUE
[11:00:06.297]  - Getting '...' globals ...
[11:00:06.297] resolve() on list ...
[11:00:06.297]  recursive: 0
[11:00:06.298]  length: 1
[11:00:06.298]  elements: ‘...’
[11:00:06.298]  length: 0 (resolved future 1)
[11:00:06.298] resolve() on list ... DONE
[11:00:06.298]    - '...' content: [n=0] 
[11:00:06.298] List of 1
[11:00:06.298]  $ ...: list()
[11:00:06.298]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:06.298]  - attr(*, "where")=List of 1
[11:00:06.298]   ..$ ...:<environment: 0x55bbaec26a18> 
[11:00:06.298]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:06.298]  - attr(*, "resolved")= logi TRUE
[11:00:06.298]  - attr(*, "total_size")= num NA
[11:00:06.300]  - Getting '...' globals ... DONE
[11:00:06.300] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:06.301] List of 8
[11:00:06.301]  $ ...future.FUN:function (x, ...)  
[11:00:06.301]  $ x_FUN        :function (x)  
[11:00:06.301]  $ times        : int 4
[11:00:06.301]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:06.301]  $ stop_if_not  :function (...)  
[11:00:06.301]  $ dim          : int [1:2] 2 2
[11:00:06.301]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:06.301]  $ ...          : list()
[11:00:06.301]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:06.301]  - attr(*, "where")=List of 8
[11:00:06.301]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:06.301]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:06.301]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:06.301]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:06.301]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:06.301]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:06.301]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:06.301]   ..$ ...          :<environment: 0x55bbaec26a18> 
[11:00:06.301]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:06.301]  - attr(*, "resolved")= logi FALSE
[11:00:06.301]  - attr(*, "total_size")= num 29094
[11:00:06.306] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:06.306] getGlobalsAndPackagesXApply() ... DONE
[11:00:06.306] Number of futures (= number of chunks): 2
[11:00:06.306] Launching 2 futures (chunks) ...
[11:00:06.306] Chunk #1 of 2 ...
[11:00:06.306]  - Finding globals in 'X' for chunk #1 ...
[11:00:06.307] getGlobalsAndPackages() ...
[11:00:06.307] Searching for globals...
[11:00:06.307] 
[11:00:06.307] Searching for globals ... DONE
[11:00:06.307] - globals: [0] <none>
[11:00:06.307] getGlobalsAndPackages() ... DONE
[11:00:06.307]    + additional globals found: [n=0] 
[11:00:06.307]    + additional namespaces needed: [n=0] 
[11:00:06.307]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:06.307]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:06.308]  - seeds: <none>
[11:00:06.308]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:06.308] getGlobalsAndPackages() ...
[11:00:06.308] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:06.308] Resolving globals: FALSE
[11:00:06.308] Tweak future expression to call with '...' arguments ...
[11:00:06.308] {
[11:00:06.308]     do.call(function(...) {
[11:00:06.308]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:06.308]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:06.308]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:06.308]             on.exit(options(oopts), add = TRUE)
[11:00:06.308]         }
[11:00:06.308]         {
[11:00:06.308]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:06.308]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:06.308]                 ...future.FUN(...future.X_jj, ...)
[11:00:06.308]             })
[11:00:06.308]         }
[11:00:06.308]     }, args = future.call.arguments)
[11:00:06.308] }
[11:00:06.308] Tweak future expression to call with '...' arguments ... DONE
[11:00:06.309] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:06.309] - packages: [1] ‘future.apply’
[11:00:06.309] getGlobalsAndPackages() ... DONE
[11:00:06.309] run() for ‘Future’ ...
[11:00:06.309] - state: ‘created’
[11:00:06.310] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:06.323] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:06.323] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:06.323]   - Field: ‘node’
[11:00:06.324]   - Field: ‘label’
[11:00:06.324]   - Field: ‘local’
[11:00:06.324]   - Field: ‘owner’
[11:00:06.324]   - Field: ‘envir’
[11:00:06.324]   - Field: ‘workers’
[11:00:06.324]   - Field: ‘packages’
[11:00:06.324]   - Field: ‘gc’
[11:00:06.324]   - Field: ‘conditions’
[11:00:06.324]   - Field: ‘persistent’
[11:00:06.324]   - Field: ‘expr’
[11:00:06.324]   - Field: ‘uuid’
[11:00:06.324]   - Field: ‘seed’
[11:00:06.325]   - Field: ‘version’
[11:00:06.325]   - Field: ‘result’
[11:00:06.325]   - Field: ‘asynchronous’
[11:00:06.325]   - Field: ‘calls’
[11:00:06.325]   - Field: ‘globals’
[11:00:06.325]   - Field: ‘stdout’
[11:00:06.325]   - Field: ‘earlySignal’
[11:00:06.325]   - Field: ‘lazy’
[11:00:06.325]   - Field: ‘state’
[11:00:06.325] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:06.325] - Launch lazy future ...
[11:00:06.326] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:06.326] Packages needed by future strategies (n = 0): <none>
[11:00:06.326] {
[11:00:06.326]     {
[11:00:06.326]         {
[11:00:06.326]             ...future.startTime <- base::Sys.time()
[11:00:06.326]             {
[11:00:06.326]                 {
[11:00:06.326]                   {
[11:00:06.326]                     {
[11:00:06.326]                       {
[11:00:06.326]                         base::local({
[11:00:06.326]                           has_future <- base::requireNamespace("future", 
[11:00:06.326]                             quietly = TRUE)
[11:00:06.326]                           if (has_future) {
[11:00:06.326]                             ns <- base::getNamespace("future")
[11:00:06.326]                             version <- ns[[".package"]][["version"]]
[11:00:06.326]                             if (is.null(version)) 
[11:00:06.326]                               version <- utils::packageVersion("future")
[11:00:06.326]                           }
[11:00:06.326]                           else {
[11:00:06.326]                             version <- NULL
[11:00:06.326]                           }
[11:00:06.326]                           if (!has_future || version < "1.8.0") {
[11:00:06.326]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:06.326]                               "", base::R.version$version.string), 
[11:00:06.326]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:06.326]                                 base::R.version$platform, 8 * 
[11:00:06.326]                                   base::.Machine$sizeof.pointer), 
[11:00:06.326]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:06.326]                                 "release", "version")], collapse = " "), 
[11:00:06.326]                               hostname = base::Sys.info()[["nodename"]])
[11:00:06.326]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:06.326]                               info)
[11:00:06.326]                             info <- base::paste(info, collapse = "; ")
[11:00:06.326]                             if (!has_future) {
[11:00:06.326]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:06.326]                                 info)
[11:00:06.326]                             }
[11:00:06.326]                             else {
[11:00:06.326]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:06.326]                                 info, version)
[11:00:06.326]                             }
[11:00:06.326]                             base::stop(msg)
[11:00:06.326]                           }
[11:00:06.326]                         })
[11:00:06.326]                       }
[11:00:06.326]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:06.326]                       base::options(mc.cores = 1L)
[11:00:06.326]                     }
[11:00:06.326]                     base::local({
[11:00:06.326]                       for (pkg in "future.apply") {
[11:00:06.326]                         base::loadNamespace(pkg)
[11:00:06.326]                         base::library(pkg, character.only = TRUE)
[11:00:06.326]                       }
[11:00:06.326]                     })
[11:00:06.326]                   }
[11:00:06.326]                   ...future.strategy.old <- future::plan("list")
[11:00:06.326]                   options(future.plan = NULL)
[11:00:06.326]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:06.326]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:06.326]                 }
[11:00:06.326]                 ...future.workdir <- getwd()
[11:00:06.326]             }
[11:00:06.326]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:06.326]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:06.326]         }
[11:00:06.326]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:06.326]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:06.326]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:06.326]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:06.326]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:06.326]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:06.326]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:06.326]             base::names(...future.oldOptions))
[11:00:06.326]     }
[11:00:06.326]     if (FALSE) {
[11:00:06.326]     }
[11:00:06.326]     else {
[11:00:06.326]         if (TRUE) {
[11:00:06.326]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:06.326]                 open = "w")
[11:00:06.326]         }
[11:00:06.326]         else {
[11:00:06.326]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:06.326]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:06.326]         }
[11:00:06.326]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:06.326]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:06.326]             base::sink(type = "output", split = FALSE)
[11:00:06.326]             base::close(...future.stdout)
[11:00:06.326]         }, add = TRUE)
[11:00:06.326]     }
[11:00:06.326]     ...future.frame <- base::sys.nframe()
[11:00:06.326]     ...future.conditions <- base::list()
[11:00:06.326]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:06.326]     if (FALSE) {
[11:00:06.326]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:06.326]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:06.326]     }
[11:00:06.326]     ...future.result <- base::tryCatch({
[11:00:06.326]         base::withCallingHandlers({
[11:00:06.326]             ...future.value <- base::withVisible(base::local({
[11:00:06.326]                 ...future.makeSendCondition <- base::local({
[11:00:06.326]                   sendCondition <- NULL
[11:00:06.326]                   function(frame = 1L) {
[11:00:06.326]                     if (is.function(sendCondition)) 
[11:00:06.326]                       return(sendCondition)
[11:00:06.326]                     ns <- getNamespace("parallel")
[11:00:06.326]                     if (exists("sendData", mode = "function", 
[11:00:06.326]                       envir = ns)) {
[11:00:06.326]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:06.326]                         envir = ns)
[11:00:06.326]                       envir <- sys.frame(frame)
[11:00:06.326]                       master <- NULL
[11:00:06.326]                       while (!identical(envir, .GlobalEnv) && 
[11:00:06.326]                         !identical(envir, emptyenv())) {
[11:00:06.326]                         if (exists("master", mode = "list", envir = envir, 
[11:00:06.326]                           inherits = FALSE)) {
[11:00:06.326]                           master <- get("master", mode = "list", 
[11:00:06.326]                             envir = envir, inherits = FALSE)
[11:00:06.326]                           if (inherits(master, c("SOCKnode", 
[11:00:06.326]                             "SOCK0node"))) {
[11:00:06.326]                             sendCondition <<- function(cond) {
[11:00:06.326]                               data <- list(type = "VALUE", value = cond, 
[11:00:06.326]                                 success = TRUE)
[11:00:06.326]                               parallel_sendData(master, data)
[11:00:06.326]                             }
[11:00:06.326]                             return(sendCondition)
[11:00:06.326]                           }
[11:00:06.326]                         }
[11:00:06.326]                         frame <- frame + 1L
[11:00:06.326]                         envir <- sys.frame(frame)
[11:00:06.326]                       }
[11:00:06.326]                     }
[11:00:06.326]                     sendCondition <<- function(cond) NULL
[11:00:06.326]                   }
[11:00:06.326]                 })
[11:00:06.326]                 withCallingHandlers({
[11:00:06.326]                   {
[11:00:06.326]                     do.call(function(...) {
[11:00:06.326]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:06.326]                       if (!identical(...future.globals.maxSize.org, 
[11:00:06.326]                         ...future.globals.maxSize)) {
[11:00:06.326]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:06.326]                         on.exit(options(oopts), add = TRUE)
[11:00:06.326]                       }
[11:00:06.326]                       {
[11:00:06.326]                         lapply(seq_along(...future.elements_ii), 
[11:00:06.326]                           FUN = function(jj) {
[11:00:06.326]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:06.326]                             ...future.FUN(...future.X_jj, ...)
[11:00:06.326]                           })
[11:00:06.326]                       }
[11:00:06.326]                     }, args = future.call.arguments)
[11:00:06.326]                   }
[11:00:06.326]                 }, immediateCondition = function(cond) {
[11:00:06.326]                   sendCondition <- ...future.makeSendCondition()
[11:00:06.326]                   sendCondition(cond)
[11:00:06.326]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:06.326]                   {
[11:00:06.326]                     inherits <- base::inherits
[11:00:06.326]                     invokeRestart <- base::invokeRestart
[11:00:06.326]                     is.null <- base::is.null
[11:00:06.326]                     muffled <- FALSE
[11:00:06.326]                     if (inherits(cond, "message")) {
[11:00:06.326]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:06.326]                       if (muffled) 
[11:00:06.326]                         invokeRestart("muffleMessage")
[11:00:06.326]                     }
[11:00:06.326]                     else if (inherits(cond, "warning")) {
[11:00:06.326]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:06.326]                       if (muffled) 
[11:00:06.326]                         invokeRestart("muffleWarning")
[11:00:06.326]                     }
[11:00:06.326]                     else if (inherits(cond, "condition")) {
[11:00:06.326]                       if (!is.null(pattern)) {
[11:00:06.326]                         computeRestarts <- base::computeRestarts
[11:00:06.326]                         grepl <- base::grepl
[11:00:06.326]                         restarts <- computeRestarts(cond)
[11:00:06.326]                         for (restart in restarts) {
[11:00:06.326]                           name <- restart$name
[11:00:06.326]                           if (is.null(name)) 
[11:00:06.326]                             next
[11:00:06.326]                           if (!grepl(pattern, name)) 
[11:00:06.326]                             next
[11:00:06.326]                           invokeRestart(restart)
[11:00:06.326]                           muffled <- TRUE
[11:00:06.326]                           break
[11:00:06.326]                         }
[11:00:06.326]                       }
[11:00:06.326]                     }
[11:00:06.326]                     invisible(muffled)
[11:00:06.326]                   }
[11:00:06.326]                   muffleCondition(cond)
[11:00:06.326]                 })
[11:00:06.326]             }))
[11:00:06.326]             future::FutureResult(value = ...future.value$value, 
[11:00:06.326]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:06.326]                   ...future.rng), globalenv = if (FALSE) 
[11:00:06.326]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:06.326]                     ...future.globalenv.names))
[11:00:06.326]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:06.326]         }, condition = base::local({
[11:00:06.326]             c <- base::c
[11:00:06.326]             inherits <- base::inherits
[11:00:06.326]             invokeRestart <- base::invokeRestart
[11:00:06.326]             length <- base::length
[11:00:06.326]             list <- base::list
[11:00:06.326]             seq.int <- base::seq.int
[11:00:06.326]             signalCondition <- base::signalCondition
[11:00:06.326]             sys.calls <- base::sys.calls
[11:00:06.326]             `[[` <- base::`[[`
[11:00:06.326]             `+` <- base::`+`
[11:00:06.326]             `<<-` <- base::`<<-`
[11:00:06.326]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:06.326]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:06.326]                   3L)]
[11:00:06.326]             }
[11:00:06.326]             function(cond) {
[11:00:06.326]                 is_error <- inherits(cond, "error")
[11:00:06.326]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:06.326]                   NULL)
[11:00:06.326]                 if (is_error) {
[11:00:06.326]                   sessionInformation <- function() {
[11:00:06.326]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:06.326]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:06.326]                       search = base::search(), system = base::Sys.info())
[11:00:06.326]                   }
[11:00:06.326]                   ...future.conditions[[length(...future.conditions) + 
[11:00:06.326]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:06.326]                     cond$call), session = sessionInformation(), 
[11:00:06.326]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:06.326]                   signalCondition(cond)
[11:00:06.326]                 }
[11:00:06.326]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:06.326]                 "immediateCondition"))) {
[11:00:06.326]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:06.326]                   ...future.conditions[[length(...future.conditions) + 
[11:00:06.326]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:06.326]                   if (TRUE && !signal) {
[11:00:06.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:06.326]                     {
[11:00:06.326]                       inherits <- base::inherits
[11:00:06.326]                       invokeRestart <- base::invokeRestart
[11:00:06.326]                       is.null <- base::is.null
[11:00:06.326]                       muffled <- FALSE
[11:00:06.326]                       if (inherits(cond, "message")) {
[11:00:06.326]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:06.326]                         if (muffled) 
[11:00:06.326]                           invokeRestart("muffleMessage")
[11:00:06.326]                       }
[11:00:06.326]                       else if (inherits(cond, "warning")) {
[11:00:06.326]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:06.326]                         if (muffled) 
[11:00:06.326]                           invokeRestart("muffleWarning")
[11:00:06.326]                       }
[11:00:06.326]                       else if (inherits(cond, "condition")) {
[11:00:06.326]                         if (!is.null(pattern)) {
[11:00:06.326]                           computeRestarts <- base::computeRestarts
[11:00:06.326]                           grepl <- base::grepl
[11:00:06.326]                           restarts <- computeRestarts(cond)
[11:00:06.326]                           for (restart in restarts) {
[11:00:06.326]                             name <- restart$name
[11:00:06.326]                             if (is.null(name)) 
[11:00:06.326]                               next
[11:00:06.326]                             if (!grepl(pattern, name)) 
[11:00:06.326]                               next
[11:00:06.326]                             invokeRestart(restart)
[11:00:06.326]                             muffled <- TRUE
[11:00:06.326]                             break
[11:00:06.326]                           }
[11:00:06.326]                         }
[11:00:06.326]                       }
[11:00:06.326]                       invisible(muffled)
[11:00:06.326]                     }
[11:00:06.326]                     muffleCondition(cond, pattern = "^muffle")
[11:00:06.326]                   }
[11:00:06.326]                 }
[11:00:06.326]                 else {
[11:00:06.326]                   if (TRUE) {
[11:00:06.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:06.326]                     {
[11:00:06.326]                       inherits <- base::inherits
[11:00:06.326]                       invokeRestart <- base::invokeRestart
[11:00:06.326]                       is.null <- base::is.null
[11:00:06.326]                       muffled <- FALSE
[11:00:06.326]                       if (inherits(cond, "message")) {
[11:00:06.326]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:06.326]                         if (muffled) 
[11:00:06.326]                           invokeRestart("muffleMessage")
[11:00:06.326]                       }
[11:00:06.326]                       else if (inherits(cond, "warning")) {
[11:00:06.326]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:06.326]                         if (muffled) 
[11:00:06.326]                           invokeRestart("muffleWarning")
[11:00:06.326]                       }
[11:00:06.326]                       else if (inherits(cond, "condition")) {
[11:00:06.326]                         if (!is.null(pattern)) {
[11:00:06.326]                           computeRestarts <- base::computeRestarts
[11:00:06.326]                           grepl <- base::grepl
[11:00:06.326]                           restarts <- computeRestarts(cond)
[11:00:06.326]                           for (restart in restarts) {
[11:00:06.326]                             name <- restart$name
[11:00:06.326]                             if (is.null(name)) 
[11:00:06.326]                               next
[11:00:06.326]                             if (!grepl(pattern, name)) 
[11:00:06.326]                               next
[11:00:06.326]                             invokeRestart(restart)
[11:00:06.326]                             muffled <- TRUE
[11:00:06.326]                             break
[11:00:06.326]                           }
[11:00:06.326]                         }
[11:00:06.326]                       }
[11:00:06.326]                       invisible(muffled)
[11:00:06.326]                     }
[11:00:06.326]                     muffleCondition(cond, pattern = "^muffle")
[11:00:06.326]                   }
[11:00:06.326]                 }
[11:00:06.326]             }
[11:00:06.326]         }))
[11:00:06.326]     }, error = function(ex) {
[11:00:06.326]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:06.326]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:06.326]                 ...future.rng), started = ...future.startTime, 
[11:00:06.326]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:06.326]             version = "1.8"), class = "FutureResult")
[11:00:06.326]     }, finally = {
[11:00:06.326]         if (!identical(...future.workdir, getwd())) 
[11:00:06.326]             setwd(...future.workdir)
[11:00:06.326]         {
[11:00:06.326]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:06.326]                 ...future.oldOptions$nwarnings <- NULL
[11:00:06.326]             }
[11:00:06.326]             base::options(...future.oldOptions)
[11:00:06.326]             if (.Platform$OS.type == "windows") {
[11:00:06.326]                 old_names <- names(...future.oldEnvVars)
[11:00:06.326]                 envs <- base::Sys.getenv()
[11:00:06.326]                 names <- names(envs)
[11:00:06.326]                 common <- intersect(names, old_names)
[11:00:06.326]                 added <- setdiff(names, old_names)
[11:00:06.326]                 removed <- setdiff(old_names, names)
[11:00:06.326]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:06.326]                   envs[common]]
[11:00:06.326]                 NAMES <- toupper(changed)
[11:00:06.326]                 args <- list()
[11:00:06.326]                 for (kk in seq_along(NAMES)) {
[11:00:06.326]                   name <- changed[[kk]]
[11:00:06.326]                   NAME <- NAMES[[kk]]
[11:00:06.326]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:06.326]                     next
[11:00:06.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:06.326]                 }
[11:00:06.326]                 NAMES <- toupper(added)
[11:00:06.326]                 for (kk in seq_along(NAMES)) {
[11:00:06.326]                   name <- added[[kk]]
[11:00:06.326]                   NAME <- NAMES[[kk]]
[11:00:06.326]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:06.326]                     next
[11:00:06.326]                   args[[name]] <- ""
[11:00:06.326]                 }
[11:00:06.326]                 NAMES <- toupper(removed)
[11:00:06.326]                 for (kk in seq_along(NAMES)) {
[11:00:06.326]                   name <- removed[[kk]]
[11:00:06.326]                   NAME <- NAMES[[kk]]
[11:00:06.326]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:06.326]                     next
[11:00:06.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:06.326]                 }
[11:00:06.326]                 if (length(args) > 0) 
[11:00:06.326]                   base::do.call(base::Sys.setenv, args = args)
[11:00:06.326]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:06.326]             }
[11:00:06.326]             else {
[11:00:06.326]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:06.326]             }
[11:00:06.326]             {
[11:00:06.326]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:06.326]                   0L) {
[11:00:06.326]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:06.326]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:06.326]                   base::options(opts)
[11:00:06.326]                 }
[11:00:06.326]                 {
[11:00:06.326]                   {
[11:00:06.326]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:06.326]                     NULL
[11:00:06.326]                   }
[11:00:06.326]                   options(future.plan = NULL)
[11:00:06.326]                   if (is.na(NA_character_)) 
[11:00:06.326]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:06.326]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:06.326]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:06.326]                     .init = FALSE)
[11:00:06.326]                 }
[11:00:06.326]             }
[11:00:06.326]         }
[11:00:06.326]     })
[11:00:06.326]     if (TRUE) {
[11:00:06.326]         base::sink(type = "output", split = FALSE)
[11:00:06.326]         if (TRUE) {
[11:00:06.326]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:06.326]         }
[11:00:06.326]         else {
[11:00:06.326]             ...future.result["stdout"] <- base::list(NULL)
[11:00:06.326]         }
[11:00:06.326]         base::close(...future.stdout)
[11:00:06.326]         ...future.stdout <- NULL
[11:00:06.326]     }
[11:00:06.326]     ...future.result$conditions <- ...future.conditions
[11:00:06.326]     ...future.result$finished <- base::Sys.time()
[11:00:06.326]     ...future.result
[11:00:06.326] }
[11:00:06.329] Exporting 11 global objects (16.42 KiB) to cluster node #1 ...
[11:00:06.329] Exporting ‘...future.FUN’ (6.70 KiB) to cluster node #1 ...
[11:00:06.371] Exporting ‘...future.FUN’ (6.70 KiB) to cluster node #1 ... DONE
[11:00:06.371] Exporting ‘x_FUN’ (1.36 KiB) to cluster node #1 ...
[11:00:06.371] Exporting ‘x_FUN’ (1.36 KiB) to cluster node #1 ... DONE
[11:00:06.371] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[11:00:06.372] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[11:00:06.372] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[11:00:06.413] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[11:00:06.413] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[11:00:06.454] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[11:00:06.454] Exporting ‘dim’ (39 bytes) to cluster node #1 ...
[11:00:06.454] Exporting ‘dim’ (39 bytes) to cluster node #1 ... DONE
[11:00:06.454] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[11:00:06.455] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[11:00:06.455] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[11:00:06.455] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[11:00:06.455] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ...
[11:00:06.456] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #1 ... DONE
[11:00:06.456] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[11:00:06.456] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[11:00:06.456] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[11:00:06.457] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[11:00:06.457] Exporting 11 global objects (16.42 KiB) to cluster node #1 ... DONE
[11:00:06.457] MultisessionFuture started
[11:00:06.457] - Launch lazy future ... done
[11:00:06.457] run() for ‘MultisessionFuture’ ... done
[11:00:06.457] Created future:
[11:00:06.457] MultisessionFuture:
[11:00:06.457] Label: ‘future_vapply-1’
[11:00:06.457] Expression:
[11:00:06.457] {
[11:00:06.457]     do.call(function(...) {
[11:00:06.457]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:06.457]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:06.457]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:06.457]             on.exit(options(oopts), add = TRUE)
[11:00:06.457]         }
[11:00:06.457]         {
[11:00:06.457]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:06.457]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:06.457]                 ...future.FUN(...future.X_jj, ...)
[11:00:06.457]             })
[11:00:06.457]         }
[11:00:06.457]     }, args = future.call.arguments)
[11:00:06.457] }
[11:00:06.457] Lazy evaluation: FALSE
[11:00:06.457] Asynchronous evaluation: TRUE
[11:00:06.457] Local evaluation: TRUE
[11:00:06.457] Environment: R_GlobalEnv
[11:00:06.457] Capture standard output: TRUE
[11:00:06.457] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:06.457] Globals: 11 objects totaling 16.28 KiB (function ‘...future.FUN’ of 6.70 KiB, function ‘x_FUN’ of 1.36 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:06.457] Packages: 1 packages (‘future.apply’)
[11:00:06.457] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:06.457] Resolved: FALSE
[11:00:06.457] Value: <not collected>
[11:00:06.457] Conditions captured: <none>
[11:00:06.457] Early signaling: FALSE
[11:00:06.457] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:06.457] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:06.469] Chunk #1 of 2 ... DONE
[11:00:06.469] Chunk #2 of 2 ...
[11:00:06.469]  - Finding globals in 'X' for chunk #2 ...
[11:00:06.469] getGlobalsAndPackages() ...
[11:00:06.469] Searching for globals...
[11:00:06.470] 
[11:00:06.470] Searching for globals ... DONE
[11:00:06.470] - globals: [0] <none>
[11:00:06.470] getGlobalsAndPackages() ... DONE
[11:00:06.470]    + additional globals found: [n=0] 
[11:00:06.470]    + additional namespaces needed: [n=0] 
[11:00:06.470]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:06.470]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:06.470]  - seeds: <none>
[11:00:06.470]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:06.470] getGlobalsAndPackages() ...
[11:00:06.471] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:06.471] Resolving globals: FALSE
[11:00:06.471] Tweak future expression to call with '...' arguments ...
[11:00:06.471] {
[11:00:06.471]     do.call(function(...) {
[11:00:06.471]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:06.471]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:06.471]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:06.471]             on.exit(options(oopts), add = TRUE)
[11:00:06.471]         }
[11:00:06.471]         {
[11:00:06.471]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:06.471]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:06.471]                 ...future.FUN(...future.X_jj, ...)
[11:00:06.471]             })
[11:00:06.471]         }
[11:00:06.471]     }, args = future.call.arguments)
[11:00:06.471] }
[11:00:06.471] Tweak future expression to call with '...' arguments ... DONE
[11:00:06.472] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:06.472] - packages: [1] ‘future.apply’
[11:00:06.472] getGlobalsAndPackages() ... DONE
[11:00:06.472] run() for ‘Future’ ...
[11:00:06.472] - state: ‘created’
[11:00:06.472] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:06.486] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:06.486] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:06.486]   - Field: ‘node’
[11:00:06.486]   - Field: ‘label’
[11:00:06.486]   - Field: ‘local’
[11:00:06.486]   - Field: ‘owner’
[11:00:06.486]   - Field: ‘envir’
[11:00:06.487]   - Field: ‘workers’
[11:00:06.487]   - Field: ‘packages’
[11:00:06.487]   - Field: ‘gc’
[11:00:06.487]   - Field: ‘conditions’
[11:00:06.487]   - Field: ‘persistent’
[11:00:06.487]   - Field: ‘expr’
[11:00:06.487]   - Field: ‘uuid’
[11:00:06.487]   - Field: ‘seed’
[11:00:06.487]   - Field: ‘version’
[11:00:06.487]   - Field: ‘result’
[11:00:06.487]   - Field: ‘asynchronous’
[11:00:06.487]   - Field: ‘calls’
[11:00:06.488]   - Field: ‘globals’
[11:00:06.488]   - Field: ‘stdout’
[11:00:06.488]   - Field: ‘earlySignal’
[11:00:06.488]   - Field: ‘lazy’
[11:00:06.488]   - Field: ‘state’
[11:00:06.488] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:06.488] - Launch lazy future ...
[11:00:06.488] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:06.488] Packages needed by future strategies (n = 0): <none>
[11:00:06.489] {
[11:00:06.489]     {
[11:00:06.489]         {
[11:00:06.489]             ...future.startTime <- base::Sys.time()
[11:00:06.489]             {
[11:00:06.489]                 {
[11:00:06.489]                   {
[11:00:06.489]                     {
[11:00:06.489]                       {
[11:00:06.489]                         base::local({
[11:00:06.489]                           has_future <- base::requireNamespace("future", 
[11:00:06.489]                             quietly = TRUE)
[11:00:06.489]                           if (has_future) {
[11:00:06.489]                             ns <- base::getNamespace("future")
[11:00:06.489]                             version <- ns[[".package"]][["version"]]
[11:00:06.489]                             if (is.null(version)) 
[11:00:06.489]                               version <- utils::packageVersion("future")
[11:00:06.489]                           }
[11:00:06.489]                           else {
[11:00:06.489]                             version <- NULL
[11:00:06.489]                           }
[11:00:06.489]                           if (!has_future || version < "1.8.0") {
[11:00:06.489]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:06.489]                               "", base::R.version$version.string), 
[11:00:06.489]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:06.489]                                 base::R.version$platform, 8 * 
[11:00:06.489]                                   base::.Machine$sizeof.pointer), 
[11:00:06.489]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:06.489]                                 "release", "version")], collapse = " "), 
[11:00:06.489]                               hostname = base::Sys.info()[["nodename"]])
[11:00:06.489]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:06.489]                               info)
[11:00:06.489]                             info <- base::paste(info, collapse = "; ")
[11:00:06.489]                             if (!has_future) {
[11:00:06.489]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:06.489]                                 info)
[11:00:06.489]                             }
[11:00:06.489]                             else {
[11:00:06.489]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:06.489]                                 info, version)
[11:00:06.489]                             }
[11:00:06.489]                             base::stop(msg)
[11:00:06.489]                           }
[11:00:06.489]                         })
[11:00:06.489]                       }
[11:00:06.489]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:06.489]                       base::options(mc.cores = 1L)
[11:00:06.489]                     }
[11:00:06.489]                     base::local({
[11:00:06.489]                       for (pkg in "future.apply") {
[11:00:06.489]                         base::loadNamespace(pkg)
[11:00:06.489]                         base::library(pkg, character.only = TRUE)
[11:00:06.489]                       }
[11:00:06.489]                     })
[11:00:06.489]                   }
[11:00:06.489]                   ...future.strategy.old <- future::plan("list")
[11:00:06.489]                   options(future.plan = NULL)
[11:00:06.489]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:06.489]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:06.489]                 }
[11:00:06.489]                 ...future.workdir <- getwd()
[11:00:06.489]             }
[11:00:06.489]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:06.489]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:06.489]         }
[11:00:06.489]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:06.489]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:06.489]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:06.489]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:06.489]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:06.489]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:06.489]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:06.489]             base::names(...future.oldOptions))
[11:00:06.489]     }
[11:00:06.489]     if (FALSE) {
[11:00:06.489]     }
[11:00:06.489]     else {
[11:00:06.489]         if (TRUE) {
[11:00:06.489]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:06.489]                 open = "w")
[11:00:06.489]         }
[11:00:06.489]         else {
[11:00:06.489]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:06.489]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:06.489]         }
[11:00:06.489]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:06.489]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:06.489]             base::sink(type = "output", split = FALSE)
[11:00:06.489]             base::close(...future.stdout)
[11:00:06.489]         }, add = TRUE)
[11:00:06.489]     }
[11:00:06.489]     ...future.frame <- base::sys.nframe()
[11:00:06.489]     ...future.conditions <- base::list()
[11:00:06.489]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:06.489]     if (FALSE) {
[11:00:06.489]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:06.489]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:06.489]     }
[11:00:06.489]     ...future.result <- base::tryCatch({
[11:00:06.489]         base::withCallingHandlers({
[11:00:06.489]             ...future.value <- base::withVisible(base::local({
[11:00:06.489]                 ...future.makeSendCondition <- base::local({
[11:00:06.489]                   sendCondition <- NULL
[11:00:06.489]                   function(frame = 1L) {
[11:00:06.489]                     if (is.function(sendCondition)) 
[11:00:06.489]                       return(sendCondition)
[11:00:06.489]                     ns <- getNamespace("parallel")
[11:00:06.489]                     if (exists("sendData", mode = "function", 
[11:00:06.489]                       envir = ns)) {
[11:00:06.489]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:06.489]                         envir = ns)
[11:00:06.489]                       envir <- sys.frame(frame)
[11:00:06.489]                       master <- NULL
[11:00:06.489]                       while (!identical(envir, .GlobalEnv) && 
[11:00:06.489]                         !identical(envir, emptyenv())) {
[11:00:06.489]                         if (exists("master", mode = "list", envir = envir, 
[11:00:06.489]                           inherits = FALSE)) {
[11:00:06.489]                           master <- get("master", mode = "list", 
[11:00:06.489]                             envir = envir, inherits = FALSE)
[11:00:06.489]                           if (inherits(master, c("SOCKnode", 
[11:00:06.489]                             "SOCK0node"))) {
[11:00:06.489]                             sendCondition <<- function(cond) {
[11:00:06.489]                               data <- list(type = "VALUE", value = cond, 
[11:00:06.489]                                 success = TRUE)
[11:00:06.489]                               parallel_sendData(master, data)
[11:00:06.489]                             }
[11:00:06.489]                             return(sendCondition)
[11:00:06.489]                           }
[11:00:06.489]                         }
[11:00:06.489]                         frame <- frame + 1L
[11:00:06.489]                         envir <- sys.frame(frame)
[11:00:06.489]                       }
[11:00:06.489]                     }
[11:00:06.489]                     sendCondition <<- function(cond) NULL
[11:00:06.489]                   }
[11:00:06.489]                 })
[11:00:06.489]                 withCallingHandlers({
[11:00:06.489]                   {
[11:00:06.489]                     do.call(function(...) {
[11:00:06.489]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:06.489]                       if (!identical(...future.globals.maxSize.org, 
[11:00:06.489]                         ...future.globals.maxSize)) {
[11:00:06.489]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:06.489]                         on.exit(options(oopts), add = TRUE)
[11:00:06.489]                       }
[11:00:06.489]                       {
[11:00:06.489]                         lapply(seq_along(...future.elements_ii), 
[11:00:06.489]                           FUN = function(jj) {
[11:00:06.489]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:06.489]                             ...future.FUN(...future.X_jj, ...)
[11:00:06.489]                           })
[11:00:06.489]                       }
[11:00:06.489]                     }, args = future.call.arguments)
[11:00:06.489]                   }
[11:00:06.489]                 }, immediateCondition = function(cond) {
[11:00:06.489]                   sendCondition <- ...future.makeSendCondition()
[11:00:06.489]                   sendCondition(cond)
[11:00:06.489]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:06.489]                   {
[11:00:06.489]                     inherits <- base::inherits
[11:00:06.489]                     invokeRestart <- base::invokeRestart
[11:00:06.489]                     is.null <- base::is.null
[11:00:06.489]                     muffled <- FALSE
[11:00:06.489]                     if (inherits(cond, "message")) {
[11:00:06.489]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:06.489]                       if (muffled) 
[11:00:06.489]                         invokeRestart("muffleMessage")
[11:00:06.489]                     }
[11:00:06.489]                     else if (inherits(cond, "warning")) {
[11:00:06.489]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:06.489]                       if (muffled) 
[11:00:06.489]                         invokeRestart("muffleWarning")
[11:00:06.489]                     }
[11:00:06.489]                     else if (inherits(cond, "condition")) {
[11:00:06.489]                       if (!is.null(pattern)) {
[11:00:06.489]                         computeRestarts <- base::computeRestarts
[11:00:06.489]                         grepl <- base::grepl
[11:00:06.489]                         restarts <- computeRestarts(cond)
[11:00:06.489]                         for (restart in restarts) {
[11:00:06.489]                           name <- restart$name
[11:00:06.489]                           if (is.null(name)) 
[11:00:06.489]                             next
[11:00:06.489]                           if (!grepl(pattern, name)) 
[11:00:06.489]                             next
[11:00:06.489]                           invokeRestart(restart)
[11:00:06.489]                           muffled <- TRUE
[11:00:06.489]                           break
[11:00:06.489]                         }
[11:00:06.489]                       }
[11:00:06.489]                     }
[11:00:06.489]                     invisible(muffled)
[11:00:06.489]                   }
[11:00:06.489]                   muffleCondition(cond)
[11:00:06.489]                 })
[11:00:06.489]             }))
[11:00:06.489]             future::FutureResult(value = ...future.value$value, 
[11:00:06.489]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:06.489]                   ...future.rng), globalenv = if (FALSE) 
[11:00:06.489]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:06.489]                     ...future.globalenv.names))
[11:00:06.489]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:06.489]         }, condition = base::local({
[11:00:06.489]             c <- base::c
[11:00:06.489]             inherits <- base::inherits
[11:00:06.489]             invokeRestart <- base::invokeRestart
[11:00:06.489]             length <- base::length
[11:00:06.489]             list <- base::list
[11:00:06.489]             seq.int <- base::seq.int
[11:00:06.489]             signalCondition <- base::signalCondition
[11:00:06.489]             sys.calls <- base::sys.calls
[11:00:06.489]             `[[` <- base::`[[`
[11:00:06.489]             `+` <- base::`+`
[11:00:06.489]             `<<-` <- base::`<<-`
[11:00:06.489]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:06.489]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:06.489]                   3L)]
[11:00:06.489]             }
[11:00:06.489]             function(cond) {
[11:00:06.489]                 is_error <- inherits(cond, "error")
[11:00:06.489]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:06.489]                   NULL)
[11:00:06.489]                 if (is_error) {
[11:00:06.489]                   sessionInformation <- function() {
[11:00:06.489]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:06.489]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:06.489]                       search = base::search(), system = base::Sys.info())
[11:00:06.489]                   }
[11:00:06.489]                   ...future.conditions[[length(...future.conditions) + 
[11:00:06.489]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:06.489]                     cond$call), session = sessionInformation(), 
[11:00:06.489]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:06.489]                   signalCondition(cond)
[11:00:06.489]                 }
[11:00:06.489]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:06.489]                 "immediateCondition"))) {
[11:00:06.489]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:06.489]                   ...future.conditions[[length(...future.conditions) + 
[11:00:06.489]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:06.489]                   if (TRUE && !signal) {
[11:00:06.489]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:06.489]                     {
[11:00:06.489]                       inherits <- base::inherits
[11:00:06.489]                       invokeRestart <- base::invokeRestart
[11:00:06.489]                       is.null <- base::is.null
[11:00:06.489]                       muffled <- FALSE
[11:00:06.489]                       if (inherits(cond, "message")) {
[11:00:06.489]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:06.489]                         if (muffled) 
[11:00:06.489]                           invokeRestart("muffleMessage")
[11:00:06.489]                       }
[11:00:06.489]                       else if (inherits(cond, "warning")) {
[11:00:06.489]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:06.489]                         if (muffled) 
[11:00:06.489]                           invokeRestart("muffleWarning")
[11:00:06.489]                       }
[11:00:06.489]                       else if (inherits(cond, "condition")) {
[11:00:06.489]                         if (!is.null(pattern)) {
[11:00:06.489]                           computeRestarts <- base::computeRestarts
[11:00:06.489]                           grepl <- base::grepl
[11:00:06.489]                           restarts <- computeRestarts(cond)
[11:00:06.489]                           for (restart in restarts) {
[11:00:06.489]                             name <- restart$name
[11:00:06.489]                             if (is.null(name)) 
[11:00:06.489]                               next
[11:00:06.489]                             if (!grepl(pattern, name)) 
[11:00:06.489]                               next
[11:00:06.489]                             invokeRestart(restart)
[11:00:06.489]                             muffled <- TRUE
[11:00:06.489]                             break
[11:00:06.489]                           }
[11:00:06.489]                         }
[11:00:06.489]                       }
[11:00:06.489]                       invisible(muffled)
[11:00:06.489]                     }
[11:00:06.489]                     muffleCondition(cond, pattern = "^muffle")
[11:00:06.489]                   }
[11:00:06.489]                 }
[11:00:06.489]                 else {
[11:00:06.489]                   if (TRUE) {
[11:00:06.489]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:06.489]                     {
[11:00:06.489]                       inherits <- base::inherits
[11:00:06.489]                       invokeRestart <- base::invokeRestart
[11:00:06.489]                       is.null <- base::is.null
[11:00:06.489]                       muffled <- FALSE
[11:00:06.489]                       if (inherits(cond, "message")) {
[11:00:06.489]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:06.489]                         if (muffled) 
[11:00:06.489]                           invokeRestart("muffleMessage")
[11:00:06.489]                       }
[11:00:06.489]                       else if (inherits(cond, "warning")) {
[11:00:06.489]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:06.489]                         if (muffled) 
[11:00:06.489]                           invokeRestart("muffleWarning")
[11:00:06.489]                       }
[11:00:06.489]                       else if (inherits(cond, "condition")) {
[11:00:06.489]                         if (!is.null(pattern)) {
[11:00:06.489]                           computeRestarts <- base::computeRestarts
[11:00:06.489]                           grepl <- base::grepl
[11:00:06.489]                           restarts <- computeRestarts(cond)
[11:00:06.489]                           for (restart in restarts) {
[11:00:06.489]                             name <- restart$name
[11:00:06.489]                             if (is.null(name)) 
[11:00:06.489]                               next
[11:00:06.489]                             if (!grepl(pattern, name)) 
[11:00:06.489]                               next
[11:00:06.489]                             invokeRestart(restart)
[11:00:06.489]                             muffled <- TRUE
[11:00:06.489]                             break
[11:00:06.489]                           }
[11:00:06.489]                         }
[11:00:06.489]                       }
[11:00:06.489]                       invisible(muffled)
[11:00:06.489]                     }
[11:00:06.489]                     muffleCondition(cond, pattern = "^muffle")
[11:00:06.489]                   }
[11:00:06.489]                 }
[11:00:06.489]             }
[11:00:06.489]         }))
[11:00:06.489]     }, error = function(ex) {
[11:00:06.489]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:06.489]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:06.489]                 ...future.rng), started = ...future.startTime, 
[11:00:06.489]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:06.489]             version = "1.8"), class = "FutureResult")
[11:00:06.489]     }, finally = {
[11:00:06.489]         if (!identical(...future.workdir, getwd())) 
[11:00:06.489]             setwd(...future.workdir)
[11:00:06.489]         {
[11:00:06.489]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:06.489]                 ...future.oldOptions$nwarnings <- NULL
[11:00:06.489]             }
[11:00:06.489]             base::options(...future.oldOptions)
[11:00:06.489]             if (.Platform$OS.type == "windows") {
[11:00:06.489]                 old_names <- names(...future.oldEnvVars)
[11:00:06.489]                 envs <- base::Sys.getenv()
[11:00:06.489]                 names <- names(envs)
[11:00:06.489]                 common <- intersect(names, old_names)
[11:00:06.489]                 added <- setdiff(names, old_names)
[11:00:06.489]                 removed <- setdiff(old_names, names)
[11:00:06.489]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:06.489]                   envs[common]]
[11:00:06.489]                 NAMES <- toupper(changed)
[11:00:06.489]                 args <- list()
[11:00:06.489]                 for (kk in seq_along(NAMES)) {
[11:00:06.489]                   name <- changed[[kk]]
[11:00:06.489]                   NAME <- NAMES[[kk]]
[11:00:06.489]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:06.489]                     next
[11:00:06.489]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:06.489]                 }
[11:00:06.489]                 NAMES <- toupper(added)
[11:00:06.489]                 for (kk in seq_along(NAMES)) {
[11:00:06.489]                   name <- added[[kk]]
[11:00:06.489]                   NAME <- NAMES[[kk]]
[11:00:06.489]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:06.489]                     next
[11:00:06.489]                   args[[name]] <- ""
[11:00:06.489]                 }
[11:00:06.489]                 NAMES <- toupper(removed)
[11:00:06.489]                 for (kk in seq_along(NAMES)) {
[11:00:06.489]                   name <- removed[[kk]]
[11:00:06.489]                   NAME <- NAMES[[kk]]
[11:00:06.489]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:06.489]                     next
[11:00:06.489]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:06.489]                 }
[11:00:06.489]                 if (length(args) > 0) 
[11:00:06.489]                   base::do.call(base::Sys.setenv, args = args)
[11:00:06.489]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:06.489]             }
[11:00:06.489]             else {
[11:00:06.489]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:06.489]             }
[11:00:06.489]             {
[11:00:06.489]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:06.489]                   0L) {
[11:00:06.489]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:06.489]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:06.489]                   base::options(opts)
[11:00:06.489]                 }
[11:00:06.489]                 {
[11:00:06.489]                   {
[11:00:06.489]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:06.489]                     NULL
[11:00:06.489]                   }
[11:00:06.489]                   options(future.plan = NULL)
[11:00:06.489]                   if (is.na(NA_character_)) 
[11:00:06.489]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:06.489]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:06.489]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:06.489]                     .init = FALSE)
[11:00:06.489]                 }
[11:00:06.489]             }
[11:00:06.489]         }
[11:00:06.489]     })
[11:00:06.489]     if (TRUE) {
[11:00:06.489]         base::sink(type = "output", split = FALSE)
[11:00:06.489]         if (TRUE) {
[11:00:06.489]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:06.489]         }
[11:00:06.489]         else {
[11:00:06.489]             ...future.result["stdout"] <- base::list(NULL)
[11:00:06.489]         }
[11:00:06.489]         base::close(...future.stdout)
[11:00:06.489]         ...future.stdout <- NULL
[11:00:06.489]     }
[11:00:06.489]     ...future.result$conditions <- ...future.conditions
[11:00:06.489]     ...future.result$finished <- base::Sys.time()
[11:00:06.489]     ...future.result
[11:00:06.489] }
[11:00:06.492] Exporting 11 global objects (16.42 KiB) to cluster node #2 ...
[11:00:06.492] Exporting ‘...future.FUN’ (6.70 KiB) to cluster node #2 ...
[11:00:06.533] Exporting ‘...future.FUN’ (6.70 KiB) to cluster node #2 ... DONE
[11:00:06.533] Exporting ‘x_FUN’ (1.36 KiB) to cluster node #2 ...
[11:00:06.533] Exporting ‘x_FUN’ (1.36 KiB) to cluster node #2 ... DONE
[11:00:06.533] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[11:00:06.534] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[11:00:06.534] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[11:00:06.575] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[11:00:06.575] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[11:00:06.616] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[11:00:06.616] Exporting ‘dim’ (39 bytes) to cluster node #2 ...
[11:00:06.616] Exporting ‘dim’ (39 bytes) to cluster node #2 ... DONE
[11:00:06.616] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[11:00:06.617] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[11:00:06.617] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[11:00:06.617] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[11:00:06.617] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ...
[11:00:06.618] Exporting ‘...future.elements_ii’ (91 bytes) to cluster node #2 ... DONE
[11:00:06.618] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[11:00:06.618] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[11:00:06.618] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[11:00:06.619] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[11:00:06.621] Exporting 11 global objects (16.42 KiB) to cluster node #2 ... DONE
[11:00:06.622] MultisessionFuture started
[11:00:06.622] - Launch lazy future ... done
[11:00:06.622] run() for ‘MultisessionFuture’ ... done
[11:00:06.622] Created future:
[11:00:06.622] MultisessionFuture:
[11:00:06.622] Label: ‘future_vapply-2’
[11:00:06.622] Expression:
[11:00:06.622] {
[11:00:06.622]     do.call(function(...) {
[11:00:06.622]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:06.622]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:06.622]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:06.622]             on.exit(options(oopts), add = TRUE)
[11:00:06.622]         }
[11:00:06.622]         {
[11:00:06.622]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:06.622]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:06.622]                 ...future.FUN(...future.X_jj, ...)
[11:00:06.622]             })
[11:00:06.622]         }
[11:00:06.622]     }, args = future.call.arguments)
[11:00:06.622] }
[11:00:06.622] Lazy evaluation: FALSE
[11:00:06.622] Asynchronous evaluation: TRUE
[11:00:06.622] Local evaluation: TRUE
[11:00:06.622] Environment: R_GlobalEnv
[11:00:06.622] Capture standard output: TRUE
[11:00:06.622] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:06.622] Globals: 11 objects totaling 16.28 KiB (function ‘...future.FUN’ of 6.70 KiB, function ‘x_FUN’ of 1.36 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:06.622] Packages: 1 packages (‘future.apply’)
[11:00:06.622] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:06.622] Resolved: FALSE
[11:00:06.622] Value: <not collected>
[11:00:06.622] Conditions captured: <none>
[11:00:06.622] Early signaling: FALSE
[11:00:06.622] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:06.622] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:06.633] Chunk #2 of 2 ... DONE
[11:00:06.634] Launching 2 futures (chunks) ... DONE
[11:00:06.634] Resolving 2 futures (chunks) ...
[11:00:06.634] resolve() on list ...
[11:00:06.634]  recursive: 0
[11:00:06.634]  length: 2
[11:00:06.634] 
[11:00:06.634] receiveMessageFromWorker() for ClusterFuture ...
[11:00:06.635] - Validating connection of MultisessionFuture
[11:00:06.635] - received message: FutureResult
[11:00:06.635] - Received FutureResult
[11:00:06.635] - Erased future from FutureRegistry
[11:00:06.635] result() for ClusterFuture ...
[11:00:06.635] - result already collected: FutureResult
[11:00:06.635] result() for ClusterFuture ... done
[11:00:06.635] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:06.635] Future #1
[11:00:06.635] result() for ClusterFuture ...
[11:00:06.636] - result already collected: FutureResult
[11:00:06.636] result() for ClusterFuture ... done
[11:00:06.636] result() for ClusterFuture ...
[11:00:06.636] - result already collected: FutureResult
[11:00:06.636] result() for ClusterFuture ... done
[11:00:06.636] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:00:06.636] - nx: 2
[11:00:06.636] - relay: TRUE
[11:00:06.636] - stdout: TRUE
[11:00:06.636] - signal: TRUE
[11:00:06.636] - resignal: FALSE
[11:00:06.636] - force: TRUE
[11:00:06.636] - relayed: [n=2] FALSE, FALSE
[11:00:06.637] - queued futures: [n=2] FALSE, FALSE
[11:00:06.637]  - until=1
[11:00:06.637]  - relaying element #1
[11:00:06.637] result() for ClusterFuture ...
[11:00:06.637] - result already collected: FutureResult
[11:00:06.637] result() for ClusterFuture ... done
[11:00:06.637] result() for ClusterFuture ...
[11:00:06.637] - result already collected: FutureResult
[11:00:06.637] result() for ClusterFuture ... done
[11:00:06.637] result() for ClusterFuture ...
[11:00:06.637] - result already collected: FutureResult
[11:00:06.637] result() for ClusterFuture ... done
[11:00:06.638] result() for ClusterFuture ...
[11:00:06.638] - result already collected: FutureResult
[11:00:06.638] result() for ClusterFuture ... done
[11:00:06.638] - relayed: [n=2] TRUE, FALSE
[11:00:06.638] - queued futures: [n=2] TRUE, FALSE
[11:00:06.638] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:00:06.638]  length: 1 (resolved future 1)
[11:00:06.663] receiveMessageFromWorker() for ClusterFuture ...
[11:00:06.664] - Validating connection of MultisessionFuture
[11:00:06.664] - received message: FutureResult
[11:00:06.664] - Received FutureResult
[11:00:06.664] - Erased future from FutureRegistry
[11:00:06.664] result() for ClusterFuture ...
[11:00:06.664] - result already collected: FutureResult
[11:00:06.664] result() for ClusterFuture ... done
[11:00:06.664] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:06.664] Future #2
[11:00:06.664] result() for ClusterFuture ...
[11:00:06.665] - result already collected: FutureResult
[11:00:06.665] result() for ClusterFuture ... done
[11:00:06.665] result() for ClusterFuture ...
[11:00:06.665] - result already collected: FutureResult
[11:00:06.665] result() for ClusterFuture ... done
[11:00:06.665] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:00:06.665] - nx: 2
[11:00:06.665] - relay: TRUE
[11:00:06.665] - stdout: TRUE
[11:00:06.665] - signal: TRUE
[11:00:06.665] - resignal: FALSE
[11:00:06.665] - force: TRUE
[11:00:06.666] - relayed: [n=2] TRUE, FALSE
[11:00:06.666] - queued futures: [n=2] TRUE, FALSE
[11:00:06.666]  - until=2
[11:00:06.666]  - relaying element #2
[11:00:06.666] result() for ClusterFuture ...
[11:00:06.666] - result already collected: FutureResult
[11:00:06.666] result() for ClusterFuture ... done
[11:00:06.666] result() for ClusterFuture ...
[11:00:06.666] - result already collected: FutureResult
[11:00:06.666] result() for ClusterFuture ... done
[11:00:06.666] result() for ClusterFuture ...
[11:00:06.666] - result already collected: FutureResult
[11:00:06.667] result() for ClusterFuture ... done
[11:00:06.667] result() for ClusterFuture ...
[11:00:06.667] - result already collected: FutureResult
[11:00:06.667] result() for ClusterFuture ... done
[11:00:06.667] - relayed: [n=2] TRUE, TRUE
[11:00:06.667] - queued futures: [n=2] TRUE, TRUE
[11:00:06.667] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:00:06.667]  length: 0 (resolved future 2)
[11:00:06.667] Relaying remaining futures
[11:00:06.667] signalConditionsASAP(NULL, pos=0) ...
[11:00:06.667] - nx: 2
[11:00:06.667] - relay: TRUE
[11:00:06.668] - stdout: TRUE
[11:00:06.668] - signal: TRUE
[11:00:06.668] - resignal: FALSE
[11:00:06.668] - force: TRUE
[11:00:06.668] - relayed: [n=2] TRUE, TRUE
[11:00:06.668] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:06.668] - relayed: [n=2] TRUE, TRUE
[11:00:06.668] - queued futures: [n=2] TRUE, TRUE
[11:00:06.668] signalConditionsASAP(NULL, pos=0) ... done
[11:00:06.668] resolve() on list ... DONE
[11:00:06.668] result() for ClusterFuture ...
[11:00:06.669] - result already collected: FutureResult
[11:00:06.669] result() for ClusterFuture ... done
[11:00:06.669] result() for ClusterFuture ...
[11:00:06.669] - result already collected: FutureResult
[11:00:06.669] result() for ClusterFuture ... done
[11:00:06.669] result() for ClusterFuture ...
[11:00:06.669] - result already collected: FutureResult
[11:00:06.669] result() for ClusterFuture ... done
[11:00:06.669] result() for ClusterFuture ...
[11:00:06.669] - result already collected: FutureResult
[11:00:06.669] result() for ClusterFuture ... done
[11:00:06.669]  - Number of value chunks collected: 2
[11:00:06.670] Resolving 2 futures (chunks) ... DONE
[11:00:06.670] Reducing values from 2 chunks ...
[11:00:06.670]  - Number of values collected after concatenation: 10
[11:00:06.670]  - Number of values expected: 10
[11:00:06.670] Reducing values from 2 chunks ... DONE
[11:00:06.670] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[11:00:06.672] future_lapply() ...
[11:00:06.675] Number of chunks: 2
[11:00:06.675] getGlobalsAndPackagesXApply() ...
[11:00:06.675]  - future.globals: TRUE
[11:00:06.676] getGlobalsAndPackages() ...
[11:00:06.676] Searching for globals...
[11:00:06.679] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[11:00:06.679] Searching for globals ... DONE
[11:00:06.679] Resolving globals: FALSE
[11:00:06.680] The total size of the 7 globals is 13.03 KiB (13339 bytes)
[11:00:06.680] The total size of the 7 globals exported for future expression (‘FUN()’) is 13.03 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.75 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:06.680] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:06.681] - packages: [2] ‘stats’, ‘future.apply’
[11:00:06.681] getGlobalsAndPackages() ... DONE
[11:00:06.681]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:06.681]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[11:00:06.681] Finding globals ... DONE
[11:00:06.681]  - use_args: TRUE
[11:00:06.681]  - Getting '...' globals ...
[11:00:06.681] resolve() on list ...
[11:00:06.682]  recursive: 0
[11:00:06.682]  length: 1
[11:00:06.682]  elements: ‘...’
[11:00:06.682]  length: 0 (resolved future 1)
[11:00:06.682] resolve() on list ... DONE
[11:00:06.682]    - '...' content: [n=0] 
[11:00:06.682] List of 1
[11:00:06.682]  $ ...: list()
[11:00:06.682]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:06.682]  - attr(*, "where")=List of 1
[11:00:06.682]   ..$ ...:<environment: 0x55bbac8ee818> 
[11:00:06.682]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:06.682]  - attr(*, "resolved")= logi TRUE
[11:00:06.682]  - attr(*, "total_size")= num NA
[11:00:06.684]  - Getting '...' globals ... DONE
[11:00:06.685] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:06.685] List of 8
[11:00:06.685]  $ ...future.FUN:function (x, ...)  
[11:00:06.685]  $ x_FUN        :function (x, ...)  
[11:00:06.685]  $ times        : int 5
[11:00:06.685]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:06.685]  $ stop_if_not  :function (...)  
[11:00:06.685]  $ dim          : NULL
[11:00:06.685]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:06.685]  $ ...          : list()
[11:00:06.685]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:06.685]  - attr(*, "where")=List of 8
[11:00:06.685]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:06.685]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:06.685]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:06.685]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:06.685]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:06.685]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:06.685]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:06.685]   ..$ ...          :<environment: 0x55bbac8ee818> 
[11:00:06.685]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:06.685]  - attr(*, "resolved")= logi FALSE
[11:00:06.685]  - attr(*, "total_size")= num 24127
[11:00:06.690] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[11:00:06.690] getGlobalsAndPackagesXApply() ... DONE
[11:00:06.690] Number of futures (= number of chunks): 2
[11:00:06.690] Launching 2 futures (chunks) ...
[11:00:06.690] Chunk #1 of 2 ...
[11:00:06.690]  - Finding globals in 'X' for chunk #1 ...
[11:00:06.690] getGlobalsAndPackages() ...
[11:00:06.691] Searching for globals...
[11:00:06.691] 
[11:00:06.691] Searching for globals ... DONE
[11:00:06.691] - globals: [0] <none>
[11:00:06.691] getGlobalsAndPackages() ... DONE
[11:00:06.691]    + additional globals found: [n=0] 
[11:00:06.691]    + additional namespaces needed: [n=0] 
[11:00:06.691]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:06.691]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:06.691]  - seeds: <none>
[11:00:06.691]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:06.692] getGlobalsAndPackages() ...
[11:00:06.692] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:06.692] Resolving globals: FALSE
[11:00:06.692] Tweak future expression to call with '...' arguments ...
[11:00:06.692] {
[11:00:06.692]     do.call(function(...) {
[11:00:06.692]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:06.692]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:06.692]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:06.692]             on.exit(options(oopts), add = TRUE)
[11:00:06.692]         }
[11:00:06.692]         {
[11:00:06.692]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:06.692]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:06.692]                 ...future.FUN(...future.X_jj, ...)
[11:00:06.692]             })
[11:00:06.692]         }
[11:00:06.692]     }, args = future.call.arguments)
[11:00:06.692] }
[11:00:06.692] Tweak future expression to call with '...' arguments ... DONE
[11:00:06.693] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:06.693] - packages: [2] ‘stats’, ‘future.apply’
[11:00:06.693] getGlobalsAndPackages() ... DONE
[11:00:06.693] run() for ‘Future’ ...
[11:00:06.693] - state: ‘created’
[11:00:06.693] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:06.707] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:06.707] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:06.708]   - Field: ‘node’
[11:00:06.708]   - Field: ‘label’
[11:00:06.708]   - Field: ‘local’
[11:00:06.708]   - Field: ‘owner’
[11:00:06.708]   - Field: ‘envir’
[11:00:06.708]   - Field: ‘workers’
[11:00:06.708]   - Field: ‘packages’
[11:00:06.708]   - Field: ‘gc’
[11:00:06.708]   - Field: ‘conditions’
[11:00:06.708]   - Field: ‘persistent’
[11:00:06.708]   - Field: ‘expr’
[11:00:06.708]   - Field: ‘uuid’
[11:00:06.709]   - Field: ‘seed’
[11:00:06.709]   - Field: ‘version’
[11:00:06.709]   - Field: ‘result’
[11:00:06.709]   - Field: ‘asynchronous’
[11:00:06.709]   - Field: ‘calls’
[11:00:06.709]   - Field: ‘globals’
[11:00:06.709]   - Field: ‘stdout’
[11:00:06.709]   - Field: ‘earlySignal’
[11:00:06.709]   - Field: ‘lazy’
[11:00:06.709]   - Field: ‘state’
[11:00:06.709] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:06.709] - Launch lazy future ...
[11:00:06.710] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[11:00:06.710] Packages needed by future strategies (n = 0): <none>
[11:00:06.710] {
[11:00:06.710]     {
[11:00:06.710]         {
[11:00:06.710]             ...future.startTime <- base::Sys.time()
[11:00:06.710]             {
[11:00:06.710]                 {
[11:00:06.710]                   {
[11:00:06.710]                     {
[11:00:06.710]                       {
[11:00:06.710]                         base::local({
[11:00:06.710]                           has_future <- base::requireNamespace("future", 
[11:00:06.710]                             quietly = TRUE)
[11:00:06.710]                           if (has_future) {
[11:00:06.710]                             ns <- base::getNamespace("future")
[11:00:06.710]                             version <- ns[[".package"]][["version"]]
[11:00:06.710]                             if (is.null(version)) 
[11:00:06.710]                               version <- utils::packageVersion("future")
[11:00:06.710]                           }
[11:00:06.710]                           else {
[11:00:06.710]                             version <- NULL
[11:00:06.710]                           }
[11:00:06.710]                           if (!has_future || version < "1.8.0") {
[11:00:06.710]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:06.710]                               "", base::R.version$version.string), 
[11:00:06.710]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:06.710]                                 base::R.version$platform, 8 * 
[11:00:06.710]                                   base::.Machine$sizeof.pointer), 
[11:00:06.710]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:06.710]                                 "release", "version")], collapse = " "), 
[11:00:06.710]                               hostname = base::Sys.info()[["nodename"]])
[11:00:06.710]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:06.710]                               info)
[11:00:06.710]                             info <- base::paste(info, collapse = "; ")
[11:00:06.710]                             if (!has_future) {
[11:00:06.710]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:06.710]                                 info)
[11:00:06.710]                             }
[11:00:06.710]                             else {
[11:00:06.710]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:06.710]                                 info, version)
[11:00:06.710]                             }
[11:00:06.710]                             base::stop(msg)
[11:00:06.710]                           }
[11:00:06.710]                         })
[11:00:06.710]                       }
[11:00:06.710]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:06.710]                       base::options(mc.cores = 1L)
[11:00:06.710]                     }
[11:00:06.710]                     base::local({
[11:00:06.710]                       for (pkg in c("stats", "future.apply")) {
[11:00:06.710]                         base::loadNamespace(pkg)
[11:00:06.710]                         base::library(pkg, character.only = TRUE)
[11:00:06.710]                       }
[11:00:06.710]                     })
[11:00:06.710]                   }
[11:00:06.710]                   ...future.strategy.old <- future::plan("list")
[11:00:06.710]                   options(future.plan = NULL)
[11:00:06.710]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:06.710]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:06.710]                 }
[11:00:06.710]                 ...future.workdir <- getwd()
[11:00:06.710]             }
[11:00:06.710]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:06.710]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:06.710]         }
[11:00:06.710]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:06.710]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:06.710]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:06.710]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:06.710]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:06.710]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:06.710]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:06.710]             base::names(...future.oldOptions))
[11:00:06.710]     }
[11:00:06.710]     if (FALSE) {
[11:00:06.710]     }
[11:00:06.710]     else {
[11:00:06.710]         if (TRUE) {
[11:00:06.710]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:06.710]                 open = "w")
[11:00:06.710]         }
[11:00:06.710]         else {
[11:00:06.710]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:06.710]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:06.710]         }
[11:00:06.710]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:06.710]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:06.710]             base::sink(type = "output", split = FALSE)
[11:00:06.710]             base::close(...future.stdout)
[11:00:06.710]         }, add = TRUE)
[11:00:06.710]     }
[11:00:06.710]     ...future.frame <- base::sys.nframe()
[11:00:06.710]     ...future.conditions <- base::list()
[11:00:06.710]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:06.710]     if (FALSE) {
[11:00:06.710]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:06.710]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:06.710]     }
[11:00:06.710]     ...future.result <- base::tryCatch({
[11:00:06.710]         base::withCallingHandlers({
[11:00:06.710]             ...future.value <- base::withVisible(base::local({
[11:00:06.710]                 ...future.makeSendCondition <- base::local({
[11:00:06.710]                   sendCondition <- NULL
[11:00:06.710]                   function(frame = 1L) {
[11:00:06.710]                     if (is.function(sendCondition)) 
[11:00:06.710]                       return(sendCondition)
[11:00:06.710]                     ns <- getNamespace("parallel")
[11:00:06.710]                     if (exists("sendData", mode = "function", 
[11:00:06.710]                       envir = ns)) {
[11:00:06.710]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:06.710]                         envir = ns)
[11:00:06.710]                       envir <- sys.frame(frame)
[11:00:06.710]                       master <- NULL
[11:00:06.710]                       while (!identical(envir, .GlobalEnv) && 
[11:00:06.710]                         !identical(envir, emptyenv())) {
[11:00:06.710]                         if (exists("master", mode = "list", envir = envir, 
[11:00:06.710]                           inherits = FALSE)) {
[11:00:06.710]                           master <- get("master", mode = "list", 
[11:00:06.710]                             envir = envir, inherits = FALSE)
[11:00:06.710]                           if (inherits(master, c("SOCKnode", 
[11:00:06.710]                             "SOCK0node"))) {
[11:00:06.710]                             sendCondition <<- function(cond) {
[11:00:06.710]                               data <- list(type = "VALUE", value = cond, 
[11:00:06.710]                                 success = TRUE)
[11:00:06.710]                               parallel_sendData(master, data)
[11:00:06.710]                             }
[11:00:06.710]                             return(sendCondition)
[11:00:06.710]                           }
[11:00:06.710]                         }
[11:00:06.710]                         frame <- frame + 1L
[11:00:06.710]                         envir <- sys.frame(frame)
[11:00:06.710]                       }
[11:00:06.710]                     }
[11:00:06.710]                     sendCondition <<- function(cond) NULL
[11:00:06.710]                   }
[11:00:06.710]                 })
[11:00:06.710]                 withCallingHandlers({
[11:00:06.710]                   {
[11:00:06.710]                     do.call(function(...) {
[11:00:06.710]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:06.710]                       if (!identical(...future.globals.maxSize.org, 
[11:00:06.710]                         ...future.globals.maxSize)) {
[11:00:06.710]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:06.710]                         on.exit(options(oopts), add = TRUE)
[11:00:06.710]                       }
[11:00:06.710]                       {
[11:00:06.710]                         lapply(seq_along(...future.elements_ii), 
[11:00:06.710]                           FUN = function(jj) {
[11:00:06.710]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:06.710]                             ...future.FUN(...future.X_jj, ...)
[11:00:06.710]                           })
[11:00:06.710]                       }
[11:00:06.710]                     }, args = future.call.arguments)
[11:00:06.710]                   }
[11:00:06.710]                 }, immediateCondition = function(cond) {
[11:00:06.710]                   sendCondition <- ...future.makeSendCondition()
[11:00:06.710]                   sendCondition(cond)
[11:00:06.710]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:06.710]                   {
[11:00:06.710]                     inherits <- base::inherits
[11:00:06.710]                     invokeRestart <- base::invokeRestart
[11:00:06.710]                     is.null <- base::is.null
[11:00:06.710]                     muffled <- FALSE
[11:00:06.710]                     if (inherits(cond, "message")) {
[11:00:06.710]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:06.710]                       if (muffled) 
[11:00:06.710]                         invokeRestart("muffleMessage")
[11:00:06.710]                     }
[11:00:06.710]                     else if (inherits(cond, "warning")) {
[11:00:06.710]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:06.710]                       if (muffled) 
[11:00:06.710]                         invokeRestart("muffleWarning")
[11:00:06.710]                     }
[11:00:06.710]                     else if (inherits(cond, "condition")) {
[11:00:06.710]                       if (!is.null(pattern)) {
[11:00:06.710]                         computeRestarts <- base::computeRestarts
[11:00:06.710]                         grepl <- base::grepl
[11:00:06.710]                         restarts <- computeRestarts(cond)
[11:00:06.710]                         for (restart in restarts) {
[11:00:06.710]                           name <- restart$name
[11:00:06.710]                           if (is.null(name)) 
[11:00:06.710]                             next
[11:00:06.710]                           if (!grepl(pattern, name)) 
[11:00:06.710]                             next
[11:00:06.710]                           invokeRestart(restart)
[11:00:06.710]                           muffled <- TRUE
[11:00:06.710]                           break
[11:00:06.710]                         }
[11:00:06.710]                       }
[11:00:06.710]                     }
[11:00:06.710]                     invisible(muffled)
[11:00:06.710]                   }
[11:00:06.710]                   muffleCondition(cond)
[11:00:06.710]                 })
[11:00:06.710]             }))
[11:00:06.710]             future::FutureResult(value = ...future.value$value, 
[11:00:06.710]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:06.710]                   ...future.rng), globalenv = if (FALSE) 
[11:00:06.710]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:06.710]                     ...future.globalenv.names))
[11:00:06.710]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:06.710]         }, condition = base::local({
[11:00:06.710]             c <- base::c
[11:00:06.710]             inherits <- base::inherits
[11:00:06.710]             invokeRestart <- base::invokeRestart
[11:00:06.710]             length <- base::length
[11:00:06.710]             list <- base::list
[11:00:06.710]             seq.int <- base::seq.int
[11:00:06.710]             signalCondition <- base::signalCondition
[11:00:06.710]             sys.calls <- base::sys.calls
[11:00:06.710]             `[[` <- base::`[[`
[11:00:06.710]             `+` <- base::`+`
[11:00:06.710]             `<<-` <- base::`<<-`
[11:00:06.710]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:06.710]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:06.710]                   3L)]
[11:00:06.710]             }
[11:00:06.710]             function(cond) {
[11:00:06.710]                 is_error <- inherits(cond, "error")
[11:00:06.710]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:06.710]                   NULL)
[11:00:06.710]                 if (is_error) {
[11:00:06.710]                   sessionInformation <- function() {
[11:00:06.710]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:06.710]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:06.710]                       search = base::search(), system = base::Sys.info())
[11:00:06.710]                   }
[11:00:06.710]                   ...future.conditions[[length(...future.conditions) + 
[11:00:06.710]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:06.710]                     cond$call), session = sessionInformation(), 
[11:00:06.710]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:06.710]                   signalCondition(cond)
[11:00:06.710]                 }
[11:00:06.710]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:06.710]                 "immediateCondition"))) {
[11:00:06.710]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:06.710]                   ...future.conditions[[length(...future.conditions) + 
[11:00:06.710]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:06.710]                   if (TRUE && !signal) {
[11:00:06.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:06.710]                     {
[11:00:06.710]                       inherits <- base::inherits
[11:00:06.710]                       invokeRestart <- base::invokeRestart
[11:00:06.710]                       is.null <- base::is.null
[11:00:06.710]                       muffled <- FALSE
[11:00:06.710]                       if (inherits(cond, "message")) {
[11:00:06.710]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:06.710]                         if (muffled) 
[11:00:06.710]                           invokeRestart("muffleMessage")
[11:00:06.710]                       }
[11:00:06.710]                       else if (inherits(cond, "warning")) {
[11:00:06.710]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:06.710]                         if (muffled) 
[11:00:06.710]                           invokeRestart("muffleWarning")
[11:00:06.710]                       }
[11:00:06.710]                       else if (inherits(cond, "condition")) {
[11:00:06.710]                         if (!is.null(pattern)) {
[11:00:06.710]                           computeRestarts <- base::computeRestarts
[11:00:06.710]                           grepl <- base::grepl
[11:00:06.710]                           restarts <- computeRestarts(cond)
[11:00:06.710]                           for (restart in restarts) {
[11:00:06.710]                             name <- restart$name
[11:00:06.710]                             if (is.null(name)) 
[11:00:06.710]                               next
[11:00:06.710]                             if (!grepl(pattern, name)) 
[11:00:06.710]                               next
[11:00:06.710]                             invokeRestart(restart)
[11:00:06.710]                             muffled <- TRUE
[11:00:06.710]                             break
[11:00:06.710]                           }
[11:00:06.710]                         }
[11:00:06.710]                       }
[11:00:06.710]                       invisible(muffled)
[11:00:06.710]                     }
[11:00:06.710]                     muffleCondition(cond, pattern = "^muffle")
[11:00:06.710]                   }
[11:00:06.710]                 }
[11:00:06.710]                 else {
[11:00:06.710]                   if (TRUE) {
[11:00:06.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:06.710]                     {
[11:00:06.710]                       inherits <- base::inherits
[11:00:06.710]                       invokeRestart <- base::invokeRestart
[11:00:06.710]                       is.null <- base::is.null
[11:00:06.710]                       muffled <- FALSE
[11:00:06.710]                       if (inherits(cond, "message")) {
[11:00:06.710]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:06.710]                         if (muffled) 
[11:00:06.710]                           invokeRestart("muffleMessage")
[11:00:06.710]                       }
[11:00:06.710]                       else if (inherits(cond, "warning")) {
[11:00:06.710]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:06.710]                         if (muffled) 
[11:00:06.710]                           invokeRestart("muffleWarning")
[11:00:06.710]                       }
[11:00:06.710]                       else if (inherits(cond, "condition")) {
[11:00:06.710]                         if (!is.null(pattern)) {
[11:00:06.710]                           computeRestarts <- base::computeRestarts
[11:00:06.710]                           grepl <- base::grepl
[11:00:06.710]                           restarts <- computeRestarts(cond)
[11:00:06.710]                           for (restart in restarts) {
[11:00:06.710]                             name <- restart$name
[11:00:06.710]                             if (is.null(name)) 
[11:00:06.710]                               next
[11:00:06.710]                             if (!grepl(pattern, name)) 
[11:00:06.710]                               next
[11:00:06.710]                             invokeRestart(restart)
[11:00:06.710]                             muffled <- TRUE
[11:00:06.710]                             break
[11:00:06.710]                           }
[11:00:06.710]                         }
[11:00:06.710]                       }
[11:00:06.710]                       invisible(muffled)
[11:00:06.710]                     }
[11:00:06.710]                     muffleCondition(cond, pattern = "^muffle")
[11:00:06.710]                   }
[11:00:06.710]                 }
[11:00:06.710]             }
[11:00:06.710]         }))
[11:00:06.710]     }, error = function(ex) {
[11:00:06.710]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:06.710]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:06.710]                 ...future.rng), started = ...future.startTime, 
[11:00:06.710]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:06.710]             version = "1.8"), class = "FutureResult")
[11:00:06.710]     }, finally = {
[11:00:06.710]         if (!identical(...future.workdir, getwd())) 
[11:00:06.710]             setwd(...future.workdir)
[11:00:06.710]         {
[11:00:06.710]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:06.710]                 ...future.oldOptions$nwarnings <- NULL
[11:00:06.710]             }
[11:00:06.710]             base::options(...future.oldOptions)
[11:00:06.710]             if (.Platform$OS.type == "windows") {
[11:00:06.710]                 old_names <- names(...future.oldEnvVars)
[11:00:06.710]                 envs <- base::Sys.getenv()
[11:00:06.710]                 names <- names(envs)
[11:00:06.710]                 common <- intersect(names, old_names)
[11:00:06.710]                 added <- setdiff(names, old_names)
[11:00:06.710]                 removed <- setdiff(old_names, names)
[11:00:06.710]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:06.710]                   envs[common]]
[11:00:06.710]                 NAMES <- toupper(changed)
[11:00:06.710]                 args <- list()
[11:00:06.710]                 for (kk in seq_along(NAMES)) {
[11:00:06.710]                   name <- changed[[kk]]
[11:00:06.710]                   NAME <- NAMES[[kk]]
[11:00:06.710]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:06.710]                     next
[11:00:06.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:06.710]                 }
[11:00:06.710]                 NAMES <- toupper(added)
[11:00:06.710]                 for (kk in seq_along(NAMES)) {
[11:00:06.710]                   name <- added[[kk]]
[11:00:06.710]                   NAME <- NAMES[[kk]]
[11:00:06.710]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:06.710]                     next
[11:00:06.710]                   args[[name]] <- ""
[11:00:06.710]                 }
[11:00:06.710]                 NAMES <- toupper(removed)
[11:00:06.710]                 for (kk in seq_along(NAMES)) {
[11:00:06.710]                   name <- removed[[kk]]
[11:00:06.710]                   NAME <- NAMES[[kk]]
[11:00:06.710]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:06.710]                     next
[11:00:06.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:06.710]                 }
[11:00:06.710]                 if (length(args) > 0) 
[11:00:06.710]                   base::do.call(base::Sys.setenv, args = args)
[11:00:06.710]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:06.710]             }
[11:00:06.710]             else {
[11:00:06.710]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:06.710]             }
[11:00:06.710]             {
[11:00:06.710]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:06.710]                   0L) {
[11:00:06.710]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:06.710]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:06.710]                   base::options(opts)
[11:00:06.710]                 }
[11:00:06.710]                 {
[11:00:06.710]                   {
[11:00:06.710]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:06.710]                     NULL
[11:00:06.710]                   }
[11:00:06.710]                   options(future.plan = NULL)
[11:00:06.710]                   if (is.na(NA_character_)) 
[11:00:06.710]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:06.710]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:06.710]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:06.710]                     .init = FALSE)
[11:00:06.710]                 }
[11:00:06.710]             }
[11:00:06.710]         }
[11:00:06.710]     })
[11:00:06.710]     if (TRUE) {
[11:00:06.710]         base::sink(type = "output", split = FALSE)
[11:00:06.710]         if (TRUE) {
[11:00:06.710]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:06.710]         }
[11:00:06.710]         else {
[11:00:06.710]             ...future.result["stdout"] <- base::list(NULL)
[11:00:06.710]         }
[11:00:06.710]         base::close(...future.stdout)
[11:00:06.710]         ...future.stdout <- NULL
[11:00:06.710]     }
[11:00:06.710]     ...future.result$conditions <- ...future.conditions
[11:00:06.710]     ...future.result$finished <- base::Sys.time()
[11:00:06.710]     ...future.result
[11:00:06.710] }
[11:00:06.713] Exporting 11 global objects (13.46 KiB) to cluster node #1 ...
[11:00:06.713] Exporting ‘...future.FUN’ (4.74 KiB) to cluster node #1 ...
[11:00:06.755] Exporting ‘...future.FUN’ (4.74 KiB) to cluster node #1 ... DONE
[11:00:06.755] Exporting ‘x_FUN’ (311 bytes) to cluster node #1 ...
[11:00:06.755] Exporting ‘x_FUN’ (311 bytes) to cluster node #1 ... DONE
[11:00:06.755] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[11:00:06.756] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[11:00:06.756] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[11:00:06.797] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[11:00:06.797] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[11:00:06.838] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[11:00:06.838] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[11:00:06.838] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[11:00:06.838] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[11:00:06.839] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[11:00:06.839] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[11:00:06.839] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[11:00:06.839] Exporting ‘...future.elements_ii’ (183 bytes) to cluster node #1 ...
[11:00:06.840] Exporting ‘...future.elements_ii’ (183 bytes) to cluster node #1 ... DONE
[11:00:06.840] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[11:00:06.840] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[11:00:06.840] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[11:00:06.840] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[11:00:06.841] Exporting 11 global objects (13.46 KiB) to cluster node #1 ... DONE
[11:00:06.841] MultisessionFuture started
[11:00:06.841] - Launch lazy future ... done
[11:00:06.841] run() for ‘MultisessionFuture’ ... done
[11:00:06.841] Created future:
[11:00:06.841] MultisessionFuture:
[11:00:06.841] Label: ‘future_vapply-1’
[11:00:06.841] Expression:
[11:00:06.841] {
[11:00:06.841]     do.call(function(...) {
[11:00:06.841]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:06.841]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:06.841]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:06.841]             on.exit(options(oopts), add = TRUE)
[11:00:06.841]         }
[11:00:06.841]         {
[11:00:06.841]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:06.841]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:06.841]                 ...future.FUN(...future.X_jj, ...)
[11:00:06.841]             })
[11:00:06.841]         }
[11:00:06.841]     }, args = future.call.arguments)
[11:00:06.841] }
[11:00:06.841] Lazy evaluation: FALSE
[11:00:06.841] Asynchronous evaluation: TRUE
[11:00:06.841] Local evaluation: TRUE
[11:00:06.841] Environment: R_GlobalEnv
[11:00:06.841] Capture standard output: TRUE
[11:00:06.841] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:06.841] Globals: 11 objects totaling 13.35 KiB (function ‘...future.FUN’ of 4.74 KiB, function ‘x_FUN’ of 311 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:06.841] Packages: 2 packages (‘stats’, ‘future.apply’)
[11:00:06.841] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:06.841] Resolved: FALSE
[11:00:06.841] Value: <not collected>
[11:00:06.841] Conditions captured: <none>
[11:00:06.841] Early signaling: FALSE
[11:00:06.841] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:06.841] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:06.853] Chunk #1 of 2 ... DONE
[11:00:06.853] Chunk #2 of 2 ...
[11:00:06.853]  - Finding globals in 'X' for chunk #2 ...
[11:00:06.853] getGlobalsAndPackages() ...
[11:00:06.853] Searching for globals...
[11:00:06.854] 
[11:00:06.854] Searching for globals ... DONE
[11:00:06.854] - globals: [0] <none>
[11:00:06.854] getGlobalsAndPackages() ... DONE
[11:00:06.854]    + additional globals found: [n=0] 
[11:00:06.854]    + additional namespaces needed: [n=0] 
[11:00:06.854]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:06.854]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:06.854]  - seeds: <none>
[11:00:06.854]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:06.855] getGlobalsAndPackages() ...
[11:00:06.855] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:06.855] Resolving globals: FALSE
[11:00:06.855] Tweak future expression to call with '...' arguments ...
[11:00:06.855] {
[11:00:06.855]     do.call(function(...) {
[11:00:06.855]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:06.855]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:06.855]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:06.855]             on.exit(options(oopts), add = TRUE)
[11:00:06.855]         }
[11:00:06.855]         {
[11:00:06.855]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:06.855]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:06.855]                 ...future.FUN(...future.X_jj, ...)
[11:00:06.855]             })
[11:00:06.855]         }
[11:00:06.855]     }, args = future.call.arguments)
[11:00:06.855] }
[11:00:06.855] Tweak future expression to call with '...' arguments ... DONE
[11:00:06.856] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:06.856] - packages: [2] ‘stats’, ‘future.apply’
[11:00:06.856] getGlobalsAndPackages() ... DONE
[11:00:06.856] run() for ‘Future’ ...
[11:00:06.856] - state: ‘created’
[11:00:06.856] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:06.870] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:06.870] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:06.870]   - Field: ‘node’
[11:00:06.870]   - Field: ‘label’
[11:00:06.870]   - Field: ‘local’
[11:00:06.870]   - Field: ‘owner’
[11:00:06.871]   - Field: ‘envir’
[11:00:06.871]   - Field: ‘workers’
[11:00:06.871]   - Field: ‘packages’
[11:00:06.871]   - Field: ‘gc’
[11:00:06.871]   - Field: ‘conditions’
[11:00:06.871]   - Field: ‘persistent’
[11:00:06.871]   - Field: ‘expr’
[11:00:06.871]   - Field: ‘uuid’
[11:00:06.871]   - Field: ‘seed’
[11:00:06.871]   - Field: ‘version’
[11:00:06.871]   - Field: ‘result’
[11:00:06.871]   - Field: ‘asynchronous’
[11:00:06.872]   - Field: ‘calls’
[11:00:06.872]   - Field: ‘globals’
[11:00:06.872]   - Field: ‘stdout’
[11:00:06.872]   - Field: ‘earlySignal’
[11:00:06.872]   - Field: ‘lazy’
[11:00:06.872]   - Field: ‘state’
[11:00:06.872] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:06.872] - Launch lazy future ...
[11:00:06.872] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[11:00:06.873] Packages needed by future strategies (n = 0): <none>
[11:00:06.873] {
[11:00:06.873]     {
[11:00:06.873]         {
[11:00:06.873]             ...future.startTime <- base::Sys.time()
[11:00:06.873]             {
[11:00:06.873]                 {
[11:00:06.873]                   {
[11:00:06.873]                     {
[11:00:06.873]                       {
[11:00:06.873]                         base::local({
[11:00:06.873]                           has_future <- base::requireNamespace("future", 
[11:00:06.873]                             quietly = TRUE)
[11:00:06.873]                           if (has_future) {
[11:00:06.873]                             ns <- base::getNamespace("future")
[11:00:06.873]                             version <- ns[[".package"]][["version"]]
[11:00:06.873]                             if (is.null(version)) 
[11:00:06.873]                               version <- utils::packageVersion("future")
[11:00:06.873]                           }
[11:00:06.873]                           else {
[11:00:06.873]                             version <- NULL
[11:00:06.873]                           }
[11:00:06.873]                           if (!has_future || version < "1.8.0") {
[11:00:06.873]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:06.873]                               "", base::R.version$version.string), 
[11:00:06.873]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:06.873]                                 base::R.version$platform, 8 * 
[11:00:06.873]                                   base::.Machine$sizeof.pointer), 
[11:00:06.873]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:06.873]                                 "release", "version")], collapse = " "), 
[11:00:06.873]                               hostname = base::Sys.info()[["nodename"]])
[11:00:06.873]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:06.873]                               info)
[11:00:06.873]                             info <- base::paste(info, collapse = "; ")
[11:00:06.873]                             if (!has_future) {
[11:00:06.873]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:06.873]                                 info)
[11:00:06.873]                             }
[11:00:06.873]                             else {
[11:00:06.873]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:06.873]                                 info, version)
[11:00:06.873]                             }
[11:00:06.873]                             base::stop(msg)
[11:00:06.873]                           }
[11:00:06.873]                         })
[11:00:06.873]                       }
[11:00:06.873]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:06.873]                       base::options(mc.cores = 1L)
[11:00:06.873]                     }
[11:00:06.873]                     base::local({
[11:00:06.873]                       for (pkg in c("stats", "future.apply")) {
[11:00:06.873]                         base::loadNamespace(pkg)
[11:00:06.873]                         base::library(pkg, character.only = TRUE)
[11:00:06.873]                       }
[11:00:06.873]                     })
[11:00:06.873]                   }
[11:00:06.873]                   ...future.strategy.old <- future::plan("list")
[11:00:06.873]                   options(future.plan = NULL)
[11:00:06.873]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:06.873]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:06.873]                 }
[11:00:06.873]                 ...future.workdir <- getwd()
[11:00:06.873]             }
[11:00:06.873]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:06.873]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:06.873]         }
[11:00:06.873]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:06.873]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:06.873]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:06.873]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:06.873]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:06.873]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:06.873]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:06.873]             base::names(...future.oldOptions))
[11:00:06.873]     }
[11:00:06.873]     if (FALSE) {
[11:00:06.873]     }
[11:00:06.873]     else {
[11:00:06.873]         if (TRUE) {
[11:00:06.873]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:06.873]                 open = "w")
[11:00:06.873]         }
[11:00:06.873]         else {
[11:00:06.873]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:06.873]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:06.873]         }
[11:00:06.873]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:06.873]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:06.873]             base::sink(type = "output", split = FALSE)
[11:00:06.873]             base::close(...future.stdout)
[11:00:06.873]         }, add = TRUE)
[11:00:06.873]     }
[11:00:06.873]     ...future.frame <- base::sys.nframe()
[11:00:06.873]     ...future.conditions <- base::list()
[11:00:06.873]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:06.873]     if (FALSE) {
[11:00:06.873]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:06.873]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:06.873]     }
[11:00:06.873]     ...future.result <- base::tryCatch({
[11:00:06.873]         base::withCallingHandlers({
[11:00:06.873]             ...future.value <- base::withVisible(base::local({
[11:00:06.873]                 ...future.makeSendCondition <- base::local({
[11:00:06.873]                   sendCondition <- NULL
[11:00:06.873]                   function(frame = 1L) {
[11:00:06.873]                     if (is.function(sendCondition)) 
[11:00:06.873]                       return(sendCondition)
[11:00:06.873]                     ns <- getNamespace("parallel")
[11:00:06.873]                     if (exists("sendData", mode = "function", 
[11:00:06.873]                       envir = ns)) {
[11:00:06.873]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:06.873]                         envir = ns)
[11:00:06.873]                       envir <- sys.frame(frame)
[11:00:06.873]                       master <- NULL
[11:00:06.873]                       while (!identical(envir, .GlobalEnv) && 
[11:00:06.873]                         !identical(envir, emptyenv())) {
[11:00:06.873]                         if (exists("master", mode = "list", envir = envir, 
[11:00:06.873]                           inherits = FALSE)) {
[11:00:06.873]                           master <- get("master", mode = "list", 
[11:00:06.873]                             envir = envir, inherits = FALSE)
[11:00:06.873]                           if (inherits(master, c("SOCKnode", 
[11:00:06.873]                             "SOCK0node"))) {
[11:00:06.873]                             sendCondition <<- function(cond) {
[11:00:06.873]                               data <- list(type = "VALUE", value = cond, 
[11:00:06.873]                                 success = TRUE)
[11:00:06.873]                               parallel_sendData(master, data)
[11:00:06.873]                             }
[11:00:06.873]                             return(sendCondition)
[11:00:06.873]                           }
[11:00:06.873]                         }
[11:00:06.873]                         frame <- frame + 1L
[11:00:06.873]                         envir <- sys.frame(frame)
[11:00:06.873]                       }
[11:00:06.873]                     }
[11:00:06.873]                     sendCondition <<- function(cond) NULL
[11:00:06.873]                   }
[11:00:06.873]                 })
[11:00:06.873]                 withCallingHandlers({
[11:00:06.873]                   {
[11:00:06.873]                     do.call(function(...) {
[11:00:06.873]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:06.873]                       if (!identical(...future.globals.maxSize.org, 
[11:00:06.873]                         ...future.globals.maxSize)) {
[11:00:06.873]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:06.873]                         on.exit(options(oopts), add = TRUE)
[11:00:06.873]                       }
[11:00:06.873]                       {
[11:00:06.873]                         lapply(seq_along(...future.elements_ii), 
[11:00:06.873]                           FUN = function(jj) {
[11:00:06.873]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:06.873]                             ...future.FUN(...future.X_jj, ...)
[11:00:06.873]                           })
[11:00:06.873]                       }
[11:00:06.873]                     }, args = future.call.arguments)
[11:00:06.873]                   }
[11:00:06.873]                 }, immediateCondition = function(cond) {
[11:00:06.873]                   sendCondition <- ...future.makeSendCondition()
[11:00:06.873]                   sendCondition(cond)
[11:00:06.873]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:06.873]                   {
[11:00:06.873]                     inherits <- base::inherits
[11:00:06.873]                     invokeRestart <- base::invokeRestart
[11:00:06.873]                     is.null <- base::is.null
[11:00:06.873]                     muffled <- FALSE
[11:00:06.873]                     if (inherits(cond, "message")) {
[11:00:06.873]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:06.873]                       if (muffled) 
[11:00:06.873]                         invokeRestart("muffleMessage")
[11:00:06.873]                     }
[11:00:06.873]                     else if (inherits(cond, "warning")) {
[11:00:06.873]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:06.873]                       if (muffled) 
[11:00:06.873]                         invokeRestart("muffleWarning")
[11:00:06.873]                     }
[11:00:06.873]                     else if (inherits(cond, "condition")) {
[11:00:06.873]                       if (!is.null(pattern)) {
[11:00:06.873]                         computeRestarts <- base::computeRestarts
[11:00:06.873]                         grepl <- base::grepl
[11:00:06.873]                         restarts <- computeRestarts(cond)
[11:00:06.873]                         for (restart in restarts) {
[11:00:06.873]                           name <- restart$name
[11:00:06.873]                           if (is.null(name)) 
[11:00:06.873]                             next
[11:00:06.873]                           if (!grepl(pattern, name)) 
[11:00:06.873]                             next
[11:00:06.873]                           invokeRestart(restart)
[11:00:06.873]                           muffled <- TRUE
[11:00:06.873]                           break
[11:00:06.873]                         }
[11:00:06.873]                       }
[11:00:06.873]                     }
[11:00:06.873]                     invisible(muffled)
[11:00:06.873]                   }
[11:00:06.873]                   muffleCondition(cond)
[11:00:06.873]                 })
[11:00:06.873]             }))
[11:00:06.873]             future::FutureResult(value = ...future.value$value, 
[11:00:06.873]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:06.873]                   ...future.rng), globalenv = if (FALSE) 
[11:00:06.873]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:06.873]                     ...future.globalenv.names))
[11:00:06.873]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:06.873]         }, condition = base::local({
[11:00:06.873]             c <- base::c
[11:00:06.873]             inherits <- base::inherits
[11:00:06.873]             invokeRestart <- base::invokeRestart
[11:00:06.873]             length <- base::length
[11:00:06.873]             list <- base::list
[11:00:06.873]             seq.int <- base::seq.int
[11:00:06.873]             signalCondition <- base::signalCondition
[11:00:06.873]             sys.calls <- base::sys.calls
[11:00:06.873]             `[[` <- base::`[[`
[11:00:06.873]             `+` <- base::`+`
[11:00:06.873]             `<<-` <- base::`<<-`
[11:00:06.873]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:06.873]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:06.873]                   3L)]
[11:00:06.873]             }
[11:00:06.873]             function(cond) {
[11:00:06.873]                 is_error <- inherits(cond, "error")
[11:00:06.873]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:06.873]                   NULL)
[11:00:06.873]                 if (is_error) {
[11:00:06.873]                   sessionInformation <- function() {
[11:00:06.873]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:06.873]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:06.873]                       search = base::search(), system = base::Sys.info())
[11:00:06.873]                   }
[11:00:06.873]                   ...future.conditions[[length(...future.conditions) + 
[11:00:06.873]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:06.873]                     cond$call), session = sessionInformation(), 
[11:00:06.873]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:06.873]                   signalCondition(cond)
[11:00:06.873]                 }
[11:00:06.873]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:06.873]                 "immediateCondition"))) {
[11:00:06.873]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:06.873]                   ...future.conditions[[length(...future.conditions) + 
[11:00:06.873]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:06.873]                   if (TRUE && !signal) {
[11:00:06.873]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:06.873]                     {
[11:00:06.873]                       inherits <- base::inherits
[11:00:06.873]                       invokeRestart <- base::invokeRestart
[11:00:06.873]                       is.null <- base::is.null
[11:00:06.873]                       muffled <- FALSE
[11:00:06.873]                       if (inherits(cond, "message")) {
[11:00:06.873]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:06.873]                         if (muffled) 
[11:00:06.873]                           invokeRestart("muffleMessage")
[11:00:06.873]                       }
[11:00:06.873]                       else if (inherits(cond, "warning")) {
[11:00:06.873]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:06.873]                         if (muffled) 
[11:00:06.873]                           invokeRestart("muffleWarning")
[11:00:06.873]                       }
[11:00:06.873]                       else if (inherits(cond, "condition")) {
[11:00:06.873]                         if (!is.null(pattern)) {
[11:00:06.873]                           computeRestarts <- base::computeRestarts
[11:00:06.873]                           grepl <- base::grepl
[11:00:06.873]                           restarts <- computeRestarts(cond)
[11:00:06.873]                           for (restart in restarts) {
[11:00:06.873]                             name <- restart$name
[11:00:06.873]                             if (is.null(name)) 
[11:00:06.873]                               next
[11:00:06.873]                             if (!grepl(pattern, name)) 
[11:00:06.873]                               next
[11:00:06.873]                             invokeRestart(restart)
[11:00:06.873]                             muffled <- TRUE
[11:00:06.873]                             break
[11:00:06.873]                           }
[11:00:06.873]                         }
[11:00:06.873]                       }
[11:00:06.873]                       invisible(muffled)
[11:00:06.873]                     }
[11:00:06.873]                     muffleCondition(cond, pattern = "^muffle")
[11:00:06.873]                   }
[11:00:06.873]                 }
[11:00:06.873]                 else {
[11:00:06.873]                   if (TRUE) {
[11:00:06.873]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:06.873]                     {
[11:00:06.873]                       inherits <- base::inherits
[11:00:06.873]                       invokeRestart <- base::invokeRestart
[11:00:06.873]                       is.null <- base::is.null
[11:00:06.873]                       muffled <- FALSE
[11:00:06.873]                       if (inherits(cond, "message")) {
[11:00:06.873]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:06.873]                         if (muffled) 
[11:00:06.873]                           invokeRestart("muffleMessage")
[11:00:06.873]                       }
[11:00:06.873]                       else if (inherits(cond, "warning")) {
[11:00:06.873]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:06.873]                         if (muffled) 
[11:00:06.873]                           invokeRestart("muffleWarning")
[11:00:06.873]                       }
[11:00:06.873]                       else if (inherits(cond, "condition")) {
[11:00:06.873]                         if (!is.null(pattern)) {
[11:00:06.873]                           computeRestarts <- base::computeRestarts
[11:00:06.873]                           grepl <- base::grepl
[11:00:06.873]                           restarts <- computeRestarts(cond)
[11:00:06.873]                           for (restart in restarts) {
[11:00:06.873]                             name <- restart$name
[11:00:06.873]                             if (is.null(name)) 
[11:00:06.873]                               next
[11:00:06.873]                             if (!grepl(pattern, name)) 
[11:00:06.873]                               next
[11:00:06.873]                             invokeRestart(restart)
[11:00:06.873]                             muffled <- TRUE
[11:00:06.873]                             break
[11:00:06.873]                           }
[11:00:06.873]                         }
[11:00:06.873]                       }
[11:00:06.873]                       invisible(muffled)
[11:00:06.873]                     }
[11:00:06.873]                     muffleCondition(cond, pattern = "^muffle")
[11:00:06.873]                   }
[11:00:06.873]                 }
[11:00:06.873]             }
[11:00:06.873]         }))
[11:00:06.873]     }, error = function(ex) {
[11:00:06.873]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:06.873]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:06.873]                 ...future.rng), started = ...future.startTime, 
[11:00:06.873]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:06.873]             version = "1.8"), class = "FutureResult")
[11:00:06.873]     }, finally = {
[11:00:06.873]         if (!identical(...future.workdir, getwd())) 
[11:00:06.873]             setwd(...future.workdir)
[11:00:06.873]         {
[11:00:06.873]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:06.873]                 ...future.oldOptions$nwarnings <- NULL
[11:00:06.873]             }
[11:00:06.873]             base::options(...future.oldOptions)
[11:00:06.873]             if (.Platform$OS.type == "windows") {
[11:00:06.873]                 old_names <- names(...future.oldEnvVars)
[11:00:06.873]                 envs <- base::Sys.getenv()
[11:00:06.873]                 names <- names(envs)
[11:00:06.873]                 common <- intersect(names, old_names)
[11:00:06.873]                 added <- setdiff(names, old_names)
[11:00:06.873]                 removed <- setdiff(old_names, names)
[11:00:06.873]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:06.873]                   envs[common]]
[11:00:06.873]                 NAMES <- toupper(changed)
[11:00:06.873]                 args <- list()
[11:00:06.873]                 for (kk in seq_along(NAMES)) {
[11:00:06.873]                   name <- changed[[kk]]
[11:00:06.873]                   NAME <- NAMES[[kk]]
[11:00:06.873]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:06.873]                     next
[11:00:06.873]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:06.873]                 }
[11:00:06.873]                 NAMES <- toupper(added)
[11:00:06.873]                 for (kk in seq_along(NAMES)) {
[11:00:06.873]                   name <- added[[kk]]
[11:00:06.873]                   NAME <- NAMES[[kk]]
[11:00:06.873]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:06.873]                     next
[11:00:06.873]                   args[[name]] <- ""
[11:00:06.873]                 }
[11:00:06.873]                 NAMES <- toupper(removed)
[11:00:06.873]                 for (kk in seq_along(NAMES)) {
[11:00:06.873]                   name <- removed[[kk]]
[11:00:06.873]                   NAME <- NAMES[[kk]]
[11:00:06.873]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:06.873]                     next
[11:00:06.873]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:06.873]                 }
[11:00:06.873]                 if (length(args) > 0) 
[11:00:06.873]                   base::do.call(base::Sys.setenv, args = args)
[11:00:06.873]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:06.873]             }
[11:00:06.873]             else {
[11:00:06.873]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:06.873]             }
[11:00:06.873]             {
[11:00:06.873]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:06.873]                   0L) {
[11:00:06.873]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:06.873]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:06.873]                   base::options(opts)
[11:00:06.873]                 }
[11:00:06.873]                 {
[11:00:06.873]                   {
[11:00:06.873]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:06.873]                     NULL
[11:00:06.873]                   }
[11:00:06.873]                   options(future.plan = NULL)
[11:00:06.873]                   if (is.na(NA_character_)) 
[11:00:06.873]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:06.873]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:06.873]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:06.873]                     .init = FALSE)
[11:00:06.873]                 }
[11:00:06.873]             }
[11:00:06.873]         }
[11:00:06.873]     })
[11:00:06.873]     if (TRUE) {
[11:00:06.873]         base::sink(type = "output", split = FALSE)
[11:00:06.873]         if (TRUE) {
[11:00:06.873]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:06.873]         }
[11:00:06.873]         else {
[11:00:06.873]             ...future.result["stdout"] <- base::list(NULL)
[11:00:06.873]         }
[11:00:06.873]         base::close(...future.stdout)
[11:00:06.873]         ...future.stdout <- NULL
[11:00:06.873]     }
[11:00:06.873]     ...future.result$conditions <- ...future.conditions
[11:00:06.873]     ...future.result$finished <- base::Sys.time()
[11:00:06.873]     ...future.result
[11:00:06.873] }
[11:00:06.876] Exporting 11 global objects (13.49 KiB) to cluster node #2 ...
[11:00:06.876] Exporting ‘...future.FUN’ (4.74 KiB) to cluster node #2 ...
[11:00:06.917] Exporting ‘...future.FUN’ (4.74 KiB) to cluster node #2 ... DONE
[11:00:06.917] Exporting ‘x_FUN’ (311 bytes) to cluster node #2 ...
[11:00:06.917] Exporting ‘x_FUN’ (311 bytes) to cluster node #2 ... DONE
[11:00:06.917] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[11:00:06.918] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[11:00:06.918] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[11:00:06.959] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[11:00:06.959] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[11:00:07.000] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[11:00:07.000] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[11:00:07.000] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[11:00:07.000] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[11:00:07.001] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[11:00:07.001] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[11:00:07.001] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[11:00:07.001] Exporting ‘...future.elements_ii’ (177 bytes) to cluster node #2 ...
[11:00:07.002] Exporting ‘...future.elements_ii’ (177 bytes) to cluster node #2 ... DONE
[11:00:07.002] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[11:00:07.002] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[11:00:07.002] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[11:00:07.003] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[11:00:07.003] Exporting 11 global objects (13.49 KiB) to cluster node #2 ... DONE
[11:00:07.003] MultisessionFuture started
[11:00:07.003] - Launch lazy future ... done
[11:00:07.003] run() for ‘MultisessionFuture’ ... done
[11:00:07.004] Created future:
[11:00:07.004] MultisessionFuture:
[11:00:07.004] Label: ‘future_vapply-2’
[11:00:07.004] Expression:
[11:00:07.004] {
[11:00:07.004]     do.call(function(...) {
[11:00:07.004]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:07.004]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:07.004]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:07.004]             on.exit(options(oopts), add = TRUE)
[11:00:07.004]         }
[11:00:07.004]         {
[11:00:07.004]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:07.004]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:07.004]                 ...future.FUN(...future.X_jj, ...)
[11:00:07.004]             })
[11:00:07.004]         }
[11:00:07.004]     }, args = future.call.arguments)
[11:00:07.004] }
[11:00:07.004] Lazy evaluation: FALSE
[11:00:07.004] Asynchronous evaluation: TRUE
[11:00:07.004] Local evaluation: TRUE
[11:00:07.004] Environment: R_GlobalEnv
[11:00:07.004] Capture standard output: TRUE
[11:00:07.004] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:07.004] Globals: 11 objects totaling 13.34 KiB (function ‘...future.FUN’ of 4.74 KiB, function ‘x_FUN’ of 311 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:07.004] Packages: 2 packages (‘stats’, ‘future.apply’)
[11:00:07.004] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:07.004] Resolved: FALSE
[11:00:07.004] Value: <not collected>
[11:00:07.004] Conditions captured: <none>
[11:00:07.004] Early signaling: FALSE
[11:00:07.004] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:07.004] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:07.015] Chunk #2 of 2 ... DONE
[11:00:07.015] Launching 2 futures (chunks) ... DONE
[11:00:07.015] Resolving 2 futures (chunks) ...
[11:00:07.015] resolve() on list ...
[11:00:07.015]  recursive: 0
[11:00:07.016]  length: 2
[11:00:07.016] 
[11:00:07.016] receiveMessageFromWorker() for ClusterFuture ...
[11:00:07.016] - Validating connection of MultisessionFuture
[11:00:07.016] - received message: FutureResult
[11:00:07.016] - Received FutureResult
[11:00:07.017] - Erased future from FutureRegistry
[11:00:07.017] result() for ClusterFuture ...
[11:00:07.017] - result already collected: FutureResult
[11:00:07.017] result() for ClusterFuture ... done
[11:00:07.017] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:07.017] Future #1
[11:00:07.017] result() for ClusterFuture ...
[11:00:07.017] - result already collected: FutureResult
[11:00:07.017] result() for ClusterFuture ... done
[11:00:07.017] result() for ClusterFuture ...
[11:00:07.017] - result already collected: FutureResult
[11:00:07.017] result() for ClusterFuture ... done
[11:00:07.018] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:00:07.018] - nx: 2
[11:00:07.018] - relay: TRUE
[11:00:07.018] - stdout: TRUE
[11:00:07.018] - signal: TRUE
[11:00:07.018] - resignal: FALSE
[11:00:07.018] - force: TRUE
[11:00:07.018] - relayed: [n=2] FALSE, FALSE
[11:00:07.018] - queued futures: [n=2] FALSE, FALSE
[11:00:07.018]  - until=1
[11:00:07.018]  - relaying element #1
[11:00:07.018] result() for ClusterFuture ...
[11:00:07.019] - result already collected: FutureResult
[11:00:07.019] result() for ClusterFuture ... done
[11:00:07.019] result() for ClusterFuture ...
[11:00:07.019] - result already collected: FutureResult
[11:00:07.019] result() for ClusterFuture ... done
[11:00:07.019] result() for ClusterFuture ...
[11:00:07.019] - result already collected: FutureResult
[11:00:07.019] result() for ClusterFuture ... done
[11:00:07.019] result() for ClusterFuture ...
[11:00:07.019] - result already collected: FutureResult
[11:00:07.019] result() for ClusterFuture ... done
[11:00:07.019] - relayed: [n=2] TRUE, FALSE
[11:00:07.019] - queued futures: [n=2] TRUE, FALSE
[11:00:07.020] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:00:07.020]  length: 1 (resolved future 1)
[11:00:07.047] receiveMessageFromWorker() for ClusterFuture ...
[11:00:07.047] - Validating connection of MultisessionFuture
[11:00:07.047] - received message: FutureResult
[11:00:07.047] - Received FutureResult
[11:00:07.048] - Erased future from FutureRegistry
[11:00:07.048] result() for ClusterFuture ...
[11:00:07.048] - result already collected: FutureResult
[11:00:07.048] result() for ClusterFuture ... done
[11:00:07.048] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:07.048] Future #2
[11:00:07.048] result() for ClusterFuture ...
[11:00:07.048] - result already collected: FutureResult
[11:00:07.048] result() for ClusterFuture ... done
[11:00:07.048] result() for ClusterFuture ...
[11:00:07.048] - result already collected: FutureResult
[11:00:07.048] result() for ClusterFuture ... done
[11:00:07.049] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:00:07.049] - nx: 2
[11:00:07.049] - relay: TRUE
[11:00:07.049] - stdout: TRUE
[11:00:07.049] - signal: TRUE
[11:00:07.049] - resignal: FALSE
[11:00:07.049] - force: TRUE
[11:00:07.049] - relayed: [n=2] TRUE, FALSE
[11:00:07.049] - queued futures: [n=2] TRUE, FALSE
[11:00:07.049]  - until=2
[11:00:07.049]  - relaying element #2
[11:00:07.049] result() for ClusterFuture ...
[11:00:07.050] - result already collected: FutureResult
[11:00:07.050] result() for ClusterFuture ... done
[11:00:07.050] result() for ClusterFuture ...
[11:00:07.050] - result already collected: FutureResult
[11:00:07.050] result() for ClusterFuture ... done
[11:00:07.050] result() for ClusterFuture ...
[11:00:07.050] - result already collected: FutureResult
[11:00:07.050] result() for ClusterFuture ... done
[11:00:07.050] result() for ClusterFuture ...
[11:00:07.050] - result already collected: FutureResult
[11:00:07.050] result() for ClusterFuture ... done
[11:00:07.050] - relayed: [n=2] TRUE, TRUE
[11:00:07.051] - queued futures: [n=2] TRUE, TRUE
[11:00:07.051] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:00:07.051]  length: 0 (resolved future 2)
[11:00:07.051] Relaying remaining futures
[11:00:07.051] signalConditionsASAP(NULL, pos=0) ...
[11:00:07.051] - nx: 2
[11:00:07.051] - relay: TRUE
[11:00:07.051] - stdout: TRUE
[11:00:07.051] - signal: TRUE
[11:00:07.051] - resignal: FALSE
[11:00:07.051] - force: TRUE
[11:00:07.051] - relayed: [n=2] TRUE, TRUE
[11:00:07.051] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:07.052] - relayed: [n=2] TRUE, TRUE
[11:00:07.052] - queued futures: [n=2] TRUE, TRUE
[11:00:07.052] signalConditionsASAP(NULL, pos=0) ... done
[11:00:07.052] resolve() on list ... DONE
[11:00:07.052] result() for ClusterFuture ...
[11:00:07.052] - result already collected: FutureResult
[11:00:07.052] result() for ClusterFuture ... done
[11:00:07.052] result() for ClusterFuture ...
[11:00:07.052] - result already collected: FutureResult
[11:00:07.052] result() for ClusterFuture ... done
[11:00:07.052] result() for ClusterFuture ...
[11:00:07.053] - result already collected: FutureResult
[11:00:07.053] result() for ClusterFuture ... done
[11:00:07.053] result() for ClusterFuture ...
[11:00:07.053] - result already collected: FutureResult
[11:00:07.053] result() for ClusterFuture ... done
[11:00:07.053]  - Number of value chunks collected: 2
[11:00:07.053] Resolving 2 futures (chunks) ... DONE
[11:00:07.053] Reducing values from 2 chunks ...
[11:00:07.053]  - Number of values collected after concatenation: 3
[11:00:07.053]  - Number of values expected: 3
[11:00:07.053] Reducing values from 2 chunks ... DONE
[11:00:07.053] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[11:00:07.055] future_lapply() ...
[11:00:07.096] Number of chunks: 2
[11:00:07.096] getGlobalsAndPackagesXApply() ...
[11:00:07.096]  - future.globals: TRUE
[11:00:07.096] getGlobalsAndPackages() ...
[11:00:07.096] Searching for globals...
[11:00:07.101] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[11:00:07.101] Searching for globals ... DONE
[11:00:07.101] Resolving globals: FALSE
[11:00:07.102] The total size of the 1 globals is 4.67 KiB (4777 bytes)
[11:00:07.102] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.67 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.67 KiB of class ‘function’)
[11:00:07.102] - globals: [1] ‘FUN’
[11:00:07.102] - packages: [1] ‘stats’
[11:00:07.103] getGlobalsAndPackages() ... DONE
[11:00:07.103]  - globals found/used: [n=1] ‘FUN’
[11:00:07.103]  - needed namespaces: [n=1] ‘stats’
[11:00:07.103] Finding globals ... DONE
[11:00:07.103]  - use_args: TRUE
[11:00:07.103]  - Getting '...' globals ...
[11:00:07.103] resolve() on list ...
[11:00:07.103]  recursive: 0
[11:00:07.104]  length: 1
[11:00:07.104]  elements: ‘...’
[11:00:07.104]  length: 0 (resolved future 1)
[11:00:07.104] resolve() on list ... DONE
[11:00:07.104]    - '...' content: [n=0] 
[11:00:07.104] List of 1
[11:00:07.104]  $ ...: list()
[11:00:07.104]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:07.104]  - attr(*, "where")=List of 1
[11:00:07.104]   ..$ ...:<environment: 0x55bbb04196f0> 
[11:00:07.104]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:07.104]  - attr(*, "resolved")= logi TRUE
[11:00:07.104]  - attr(*, "total_size")= num NA
[11:00:07.106]  - Getting '...' globals ... DONE
[11:00:07.106] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[11:00:07.107] List of 2
[11:00:07.107]  $ ...future.FUN:function (x, na.rm = TRUE)  
[11:00:07.107]  $ ...          : list()
[11:00:07.107]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:07.107]  - attr(*, "where")=List of 2
[11:00:07.107]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:07.107]   ..$ ...          :<environment: 0x55bbb04196f0> 
[11:00:07.107]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:07.107]  - attr(*, "resolved")= logi FALSE
[11:00:07.107]  - attr(*, "total_size")= num 18895
[11:00:07.109] Packages to be attached in all futures: [n=1] ‘stats’
[11:00:07.109] getGlobalsAndPackagesXApply() ... DONE
[11:00:07.109] Number of futures (= number of chunks): 2
[11:00:07.109] Launching 2 futures (chunks) ...
[11:00:07.110] Chunk #1 of 2 ...
[11:00:07.110]  - Finding globals in 'X' for chunk #1 ...
[11:00:07.110] getGlobalsAndPackages() ...
[11:00:07.110] Searching for globals...
[11:00:07.110] 
[11:00:07.110] Searching for globals ... DONE
[11:00:07.110] - globals: [0] <none>
[11:00:07.110] getGlobalsAndPackages() ... DONE
[11:00:07.110]    + additional globals found: [n=0] 
[11:00:07.111]    + additional namespaces needed: [n=0] 
[11:00:07.111]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:07.111]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:07.111]  - seeds: <none>
[11:00:07.111]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:07.111] getGlobalsAndPackages() ...
[11:00:07.111] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:07.111] Resolving globals: FALSE
[11:00:07.111] Tweak future expression to call with '...' arguments ...
[11:00:07.111] {
[11:00:07.111]     do.call(function(...) {
[11:00:07.111]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:07.111]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:07.111]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:07.111]             on.exit(options(oopts), add = TRUE)
[11:00:07.111]         }
[11:00:07.111]         {
[11:00:07.111]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:07.111]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:07.111]                 ...future.FUN(...future.X_jj, ...)
[11:00:07.111]             })
[11:00:07.111]         }
[11:00:07.111]     }, args = future.call.arguments)
[11:00:07.111] }
[11:00:07.112] Tweak future expression to call with '...' arguments ... DONE
[11:00:07.112] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:07.112] - packages: [1] ‘stats’
[11:00:07.112] getGlobalsAndPackages() ... DONE
[11:00:07.112] run() for ‘Future’ ...
[11:00:07.113] - state: ‘created’
[11:00:07.113] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:07.126] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:07.126] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:07.126]   - Field: ‘node’
[11:00:07.126]   - Field: ‘label’
[11:00:07.126]   - Field: ‘local’
[11:00:07.127]   - Field: ‘owner’
[11:00:07.127]   - Field: ‘envir’
[11:00:07.127]   - Field: ‘workers’
[11:00:07.127]   - Field: ‘packages’
[11:00:07.127]   - Field: ‘gc’
[11:00:07.127]   - Field: ‘conditions’
[11:00:07.127]   - Field: ‘persistent’
[11:00:07.127]   - Field: ‘expr’
[11:00:07.127]   - Field: ‘uuid’
[11:00:07.127]   - Field: ‘seed’
[11:00:07.127]   - Field: ‘version’
[11:00:07.127]   - Field: ‘result’
[11:00:07.128]   - Field: ‘asynchronous’
[11:00:07.128]   - Field: ‘calls’
[11:00:07.128]   - Field: ‘globals’
[11:00:07.128]   - Field: ‘stdout’
[11:00:07.128]   - Field: ‘earlySignal’
[11:00:07.128]   - Field: ‘lazy’
[11:00:07.128]   - Field: ‘state’
[11:00:07.128] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:07.128] - Launch lazy future ...
[11:00:07.128] Packages needed by the future expression (n = 1): ‘stats’
[11:00:07.129] Packages needed by future strategies (n = 0): <none>
[11:00:07.129] {
[11:00:07.129]     {
[11:00:07.129]         {
[11:00:07.129]             ...future.startTime <- base::Sys.time()
[11:00:07.129]             {
[11:00:07.129]                 {
[11:00:07.129]                   {
[11:00:07.129]                     {
[11:00:07.129]                       {
[11:00:07.129]                         base::local({
[11:00:07.129]                           has_future <- base::requireNamespace("future", 
[11:00:07.129]                             quietly = TRUE)
[11:00:07.129]                           if (has_future) {
[11:00:07.129]                             ns <- base::getNamespace("future")
[11:00:07.129]                             version <- ns[[".package"]][["version"]]
[11:00:07.129]                             if (is.null(version)) 
[11:00:07.129]                               version <- utils::packageVersion("future")
[11:00:07.129]                           }
[11:00:07.129]                           else {
[11:00:07.129]                             version <- NULL
[11:00:07.129]                           }
[11:00:07.129]                           if (!has_future || version < "1.8.0") {
[11:00:07.129]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:07.129]                               "", base::R.version$version.string), 
[11:00:07.129]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:07.129]                                 base::R.version$platform, 8 * 
[11:00:07.129]                                   base::.Machine$sizeof.pointer), 
[11:00:07.129]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:07.129]                                 "release", "version")], collapse = " "), 
[11:00:07.129]                               hostname = base::Sys.info()[["nodename"]])
[11:00:07.129]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:07.129]                               info)
[11:00:07.129]                             info <- base::paste(info, collapse = "; ")
[11:00:07.129]                             if (!has_future) {
[11:00:07.129]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:07.129]                                 info)
[11:00:07.129]                             }
[11:00:07.129]                             else {
[11:00:07.129]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:07.129]                                 info, version)
[11:00:07.129]                             }
[11:00:07.129]                             base::stop(msg)
[11:00:07.129]                           }
[11:00:07.129]                         })
[11:00:07.129]                       }
[11:00:07.129]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:07.129]                       base::options(mc.cores = 1L)
[11:00:07.129]                     }
[11:00:07.129]                     base::local({
[11:00:07.129]                       for (pkg in "stats") {
[11:00:07.129]                         base::loadNamespace(pkg)
[11:00:07.129]                         base::library(pkg, character.only = TRUE)
[11:00:07.129]                       }
[11:00:07.129]                     })
[11:00:07.129]                   }
[11:00:07.129]                   ...future.strategy.old <- future::plan("list")
[11:00:07.129]                   options(future.plan = NULL)
[11:00:07.129]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:07.129]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:07.129]                 }
[11:00:07.129]                 ...future.workdir <- getwd()
[11:00:07.129]             }
[11:00:07.129]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:07.129]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:07.129]         }
[11:00:07.129]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:07.129]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:07.129]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:07.129]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:07.129]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:07.129]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:07.129]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:07.129]             base::names(...future.oldOptions))
[11:00:07.129]     }
[11:00:07.129]     if (FALSE) {
[11:00:07.129]     }
[11:00:07.129]     else {
[11:00:07.129]         if (TRUE) {
[11:00:07.129]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:07.129]                 open = "w")
[11:00:07.129]         }
[11:00:07.129]         else {
[11:00:07.129]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:07.129]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:07.129]         }
[11:00:07.129]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:07.129]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:07.129]             base::sink(type = "output", split = FALSE)
[11:00:07.129]             base::close(...future.stdout)
[11:00:07.129]         }, add = TRUE)
[11:00:07.129]     }
[11:00:07.129]     ...future.frame <- base::sys.nframe()
[11:00:07.129]     ...future.conditions <- base::list()
[11:00:07.129]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:07.129]     if (FALSE) {
[11:00:07.129]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:07.129]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:07.129]     }
[11:00:07.129]     ...future.result <- base::tryCatch({
[11:00:07.129]         base::withCallingHandlers({
[11:00:07.129]             ...future.value <- base::withVisible(base::local({
[11:00:07.129]                 ...future.makeSendCondition <- base::local({
[11:00:07.129]                   sendCondition <- NULL
[11:00:07.129]                   function(frame = 1L) {
[11:00:07.129]                     if (is.function(sendCondition)) 
[11:00:07.129]                       return(sendCondition)
[11:00:07.129]                     ns <- getNamespace("parallel")
[11:00:07.129]                     if (exists("sendData", mode = "function", 
[11:00:07.129]                       envir = ns)) {
[11:00:07.129]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:07.129]                         envir = ns)
[11:00:07.129]                       envir <- sys.frame(frame)
[11:00:07.129]                       master <- NULL
[11:00:07.129]                       while (!identical(envir, .GlobalEnv) && 
[11:00:07.129]                         !identical(envir, emptyenv())) {
[11:00:07.129]                         if (exists("master", mode = "list", envir = envir, 
[11:00:07.129]                           inherits = FALSE)) {
[11:00:07.129]                           master <- get("master", mode = "list", 
[11:00:07.129]                             envir = envir, inherits = FALSE)
[11:00:07.129]                           if (inherits(master, c("SOCKnode", 
[11:00:07.129]                             "SOCK0node"))) {
[11:00:07.129]                             sendCondition <<- function(cond) {
[11:00:07.129]                               data <- list(type = "VALUE", value = cond, 
[11:00:07.129]                                 success = TRUE)
[11:00:07.129]                               parallel_sendData(master, data)
[11:00:07.129]                             }
[11:00:07.129]                             return(sendCondition)
[11:00:07.129]                           }
[11:00:07.129]                         }
[11:00:07.129]                         frame <- frame + 1L
[11:00:07.129]                         envir <- sys.frame(frame)
[11:00:07.129]                       }
[11:00:07.129]                     }
[11:00:07.129]                     sendCondition <<- function(cond) NULL
[11:00:07.129]                   }
[11:00:07.129]                 })
[11:00:07.129]                 withCallingHandlers({
[11:00:07.129]                   {
[11:00:07.129]                     do.call(function(...) {
[11:00:07.129]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:07.129]                       if (!identical(...future.globals.maxSize.org, 
[11:00:07.129]                         ...future.globals.maxSize)) {
[11:00:07.129]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:07.129]                         on.exit(options(oopts), add = TRUE)
[11:00:07.129]                       }
[11:00:07.129]                       {
[11:00:07.129]                         lapply(seq_along(...future.elements_ii), 
[11:00:07.129]                           FUN = function(jj) {
[11:00:07.129]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:07.129]                             ...future.FUN(...future.X_jj, ...)
[11:00:07.129]                           })
[11:00:07.129]                       }
[11:00:07.129]                     }, args = future.call.arguments)
[11:00:07.129]                   }
[11:00:07.129]                 }, immediateCondition = function(cond) {
[11:00:07.129]                   sendCondition <- ...future.makeSendCondition()
[11:00:07.129]                   sendCondition(cond)
[11:00:07.129]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:07.129]                   {
[11:00:07.129]                     inherits <- base::inherits
[11:00:07.129]                     invokeRestart <- base::invokeRestart
[11:00:07.129]                     is.null <- base::is.null
[11:00:07.129]                     muffled <- FALSE
[11:00:07.129]                     if (inherits(cond, "message")) {
[11:00:07.129]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:07.129]                       if (muffled) 
[11:00:07.129]                         invokeRestart("muffleMessage")
[11:00:07.129]                     }
[11:00:07.129]                     else if (inherits(cond, "warning")) {
[11:00:07.129]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:07.129]                       if (muffled) 
[11:00:07.129]                         invokeRestart("muffleWarning")
[11:00:07.129]                     }
[11:00:07.129]                     else if (inherits(cond, "condition")) {
[11:00:07.129]                       if (!is.null(pattern)) {
[11:00:07.129]                         computeRestarts <- base::computeRestarts
[11:00:07.129]                         grepl <- base::grepl
[11:00:07.129]                         restarts <- computeRestarts(cond)
[11:00:07.129]                         for (restart in restarts) {
[11:00:07.129]                           name <- restart$name
[11:00:07.129]                           if (is.null(name)) 
[11:00:07.129]                             next
[11:00:07.129]                           if (!grepl(pattern, name)) 
[11:00:07.129]                             next
[11:00:07.129]                           invokeRestart(restart)
[11:00:07.129]                           muffled <- TRUE
[11:00:07.129]                           break
[11:00:07.129]                         }
[11:00:07.129]                       }
[11:00:07.129]                     }
[11:00:07.129]                     invisible(muffled)
[11:00:07.129]                   }
[11:00:07.129]                   muffleCondition(cond)
[11:00:07.129]                 })
[11:00:07.129]             }))
[11:00:07.129]             future::FutureResult(value = ...future.value$value, 
[11:00:07.129]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:07.129]                   ...future.rng), globalenv = if (FALSE) 
[11:00:07.129]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:07.129]                     ...future.globalenv.names))
[11:00:07.129]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:07.129]         }, condition = base::local({
[11:00:07.129]             c <- base::c
[11:00:07.129]             inherits <- base::inherits
[11:00:07.129]             invokeRestart <- base::invokeRestart
[11:00:07.129]             length <- base::length
[11:00:07.129]             list <- base::list
[11:00:07.129]             seq.int <- base::seq.int
[11:00:07.129]             signalCondition <- base::signalCondition
[11:00:07.129]             sys.calls <- base::sys.calls
[11:00:07.129]             `[[` <- base::`[[`
[11:00:07.129]             `+` <- base::`+`
[11:00:07.129]             `<<-` <- base::`<<-`
[11:00:07.129]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:07.129]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:07.129]                   3L)]
[11:00:07.129]             }
[11:00:07.129]             function(cond) {
[11:00:07.129]                 is_error <- inherits(cond, "error")
[11:00:07.129]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:07.129]                   NULL)
[11:00:07.129]                 if (is_error) {
[11:00:07.129]                   sessionInformation <- function() {
[11:00:07.129]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:07.129]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:07.129]                       search = base::search(), system = base::Sys.info())
[11:00:07.129]                   }
[11:00:07.129]                   ...future.conditions[[length(...future.conditions) + 
[11:00:07.129]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:07.129]                     cond$call), session = sessionInformation(), 
[11:00:07.129]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:07.129]                   signalCondition(cond)
[11:00:07.129]                 }
[11:00:07.129]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:07.129]                 "immediateCondition"))) {
[11:00:07.129]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:07.129]                   ...future.conditions[[length(...future.conditions) + 
[11:00:07.129]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:07.129]                   if (TRUE && !signal) {
[11:00:07.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:07.129]                     {
[11:00:07.129]                       inherits <- base::inherits
[11:00:07.129]                       invokeRestart <- base::invokeRestart
[11:00:07.129]                       is.null <- base::is.null
[11:00:07.129]                       muffled <- FALSE
[11:00:07.129]                       if (inherits(cond, "message")) {
[11:00:07.129]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:07.129]                         if (muffled) 
[11:00:07.129]                           invokeRestart("muffleMessage")
[11:00:07.129]                       }
[11:00:07.129]                       else if (inherits(cond, "warning")) {
[11:00:07.129]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:07.129]                         if (muffled) 
[11:00:07.129]                           invokeRestart("muffleWarning")
[11:00:07.129]                       }
[11:00:07.129]                       else if (inherits(cond, "condition")) {
[11:00:07.129]                         if (!is.null(pattern)) {
[11:00:07.129]                           computeRestarts <- base::computeRestarts
[11:00:07.129]                           grepl <- base::grepl
[11:00:07.129]                           restarts <- computeRestarts(cond)
[11:00:07.129]                           for (restart in restarts) {
[11:00:07.129]                             name <- restart$name
[11:00:07.129]                             if (is.null(name)) 
[11:00:07.129]                               next
[11:00:07.129]                             if (!grepl(pattern, name)) 
[11:00:07.129]                               next
[11:00:07.129]                             invokeRestart(restart)
[11:00:07.129]                             muffled <- TRUE
[11:00:07.129]                             break
[11:00:07.129]                           }
[11:00:07.129]                         }
[11:00:07.129]                       }
[11:00:07.129]                       invisible(muffled)
[11:00:07.129]                     }
[11:00:07.129]                     muffleCondition(cond, pattern = "^muffle")
[11:00:07.129]                   }
[11:00:07.129]                 }
[11:00:07.129]                 else {
[11:00:07.129]                   if (TRUE) {
[11:00:07.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:07.129]                     {
[11:00:07.129]                       inherits <- base::inherits
[11:00:07.129]                       invokeRestart <- base::invokeRestart
[11:00:07.129]                       is.null <- base::is.null
[11:00:07.129]                       muffled <- FALSE
[11:00:07.129]                       if (inherits(cond, "message")) {
[11:00:07.129]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:07.129]                         if (muffled) 
[11:00:07.129]                           invokeRestart("muffleMessage")
[11:00:07.129]                       }
[11:00:07.129]                       else if (inherits(cond, "warning")) {
[11:00:07.129]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:07.129]                         if (muffled) 
[11:00:07.129]                           invokeRestart("muffleWarning")
[11:00:07.129]                       }
[11:00:07.129]                       else if (inherits(cond, "condition")) {
[11:00:07.129]                         if (!is.null(pattern)) {
[11:00:07.129]                           computeRestarts <- base::computeRestarts
[11:00:07.129]                           grepl <- base::grepl
[11:00:07.129]                           restarts <- computeRestarts(cond)
[11:00:07.129]                           for (restart in restarts) {
[11:00:07.129]                             name <- restart$name
[11:00:07.129]                             if (is.null(name)) 
[11:00:07.129]                               next
[11:00:07.129]                             if (!grepl(pattern, name)) 
[11:00:07.129]                               next
[11:00:07.129]                             invokeRestart(restart)
[11:00:07.129]                             muffled <- TRUE
[11:00:07.129]                             break
[11:00:07.129]                           }
[11:00:07.129]                         }
[11:00:07.129]                       }
[11:00:07.129]                       invisible(muffled)
[11:00:07.129]                     }
[11:00:07.129]                     muffleCondition(cond, pattern = "^muffle")
[11:00:07.129]                   }
[11:00:07.129]                 }
[11:00:07.129]             }
[11:00:07.129]         }))
[11:00:07.129]     }, error = function(ex) {
[11:00:07.129]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:07.129]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:07.129]                 ...future.rng), started = ...future.startTime, 
[11:00:07.129]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:07.129]             version = "1.8"), class = "FutureResult")
[11:00:07.129]     }, finally = {
[11:00:07.129]         if (!identical(...future.workdir, getwd())) 
[11:00:07.129]             setwd(...future.workdir)
[11:00:07.129]         {
[11:00:07.129]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:07.129]                 ...future.oldOptions$nwarnings <- NULL
[11:00:07.129]             }
[11:00:07.129]             base::options(...future.oldOptions)
[11:00:07.129]             if (.Platform$OS.type == "windows") {
[11:00:07.129]                 old_names <- names(...future.oldEnvVars)
[11:00:07.129]                 envs <- base::Sys.getenv()
[11:00:07.129]                 names <- names(envs)
[11:00:07.129]                 common <- intersect(names, old_names)
[11:00:07.129]                 added <- setdiff(names, old_names)
[11:00:07.129]                 removed <- setdiff(old_names, names)
[11:00:07.129]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:07.129]                   envs[common]]
[11:00:07.129]                 NAMES <- toupper(changed)
[11:00:07.129]                 args <- list()
[11:00:07.129]                 for (kk in seq_along(NAMES)) {
[11:00:07.129]                   name <- changed[[kk]]
[11:00:07.129]                   NAME <- NAMES[[kk]]
[11:00:07.129]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:07.129]                     next
[11:00:07.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:07.129]                 }
[11:00:07.129]                 NAMES <- toupper(added)
[11:00:07.129]                 for (kk in seq_along(NAMES)) {
[11:00:07.129]                   name <- added[[kk]]
[11:00:07.129]                   NAME <- NAMES[[kk]]
[11:00:07.129]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:07.129]                     next
[11:00:07.129]                   args[[name]] <- ""
[11:00:07.129]                 }
[11:00:07.129]                 NAMES <- toupper(removed)
[11:00:07.129]                 for (kk in seq_along(NAMES)) {
[11:00:07.129]                   name <- removed[[kk]]
[11:00:07.129]                   NAME <- NAMES[[kk]]
[11:00:07.129]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:07.129]                     next
[11:00:07.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:07.129]                 }
[11:00:07.129]                 if (length(args) > 0) 
[11:00:07.129]                   base::do.call(base::Sys.setenv, args = args)
[11:00:07.129]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:07.129]             }
[11:00:07.129]             else {
[11:00:07.129]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:07.129]             }
[11:00:07.129]             {
[11:00:07.129]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:07.129]                   0L) {
[11:00:07.129]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:07.129]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:07.129]                   base::options(opts)
[11:00:07.129]                 }
[11:00:07.129]                 {
[11:00:07.129]                   {
[11:00:07.129]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:07.129]                     NULL
[11:00:07.129]                   }
[11:00:07.129]                   options(future.plan = NULL)
[11:00:07.129]                   if (is.na(NA_character_)) 
[11:00:07.129]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:07.129]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:07.129]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:07.129]                     .init = FALSE)
[11:00:07.129]                 }
[11:00:07.129]             }
[11:00:07.129]         }
[11:00:07.129]     })
[11:00:07.129]     if (TRUE) {
[11:00:07.129]         base::sink(type = "output", split = FALSE)
[11:00:07.129]         if (TRUE) {
[11:00:07.129]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:07.129]         }
[11:00:07.129]         else {
[11:00:07.129]             ...future.result["stdout"] <- base::list(NULL)
[11:00:07.129]         }
[11:00:07.129]         base::close(...future.stdout)
[11:00:07.129]         ...future.stdout <- NULL
[11:00:07.129]     }
[11:00:07.129]     ...future.result$conditions <- ...future.conditions
[11:00:07.129]     ...future.result$finished <- base::Sys.time()
[11:00:07.129]     ...future.result
[11:00:07.129] }
[11:00:07.132] Exporting 5 global objects (5.62 KiB) to cluster node #1 ...
[11:00:07.132] Exporting ‘...future.FUN’ (4.67 KiB) to cluster node #1 ...
[11:00:07.173] Exporting ‘...future.FUN’ (4.67 KiB) to cluster node #1 ... DONE
[11:00:07.173] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[11:00:07.173] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[11:00:07.173] Exporting ‘...future.elements_ii’ (369 bytes) to cluster node #1 ...
[11:00:07.174] Exporting ‘...future.elements_ii’ (369 bytes) to cluster node #1 ... DONE
[11:00:07.174] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[11:00:07.174] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[11:00:07.174] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[11:00:07.175] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[11:00:07.175] Exporting 5 global objects (5.62 KiB) to cluster node #1 ... DONE
[11:00:07.175] MultisessionFuture started
[11:00:07.175] - Launch lazy future ... done
[11:00:07.175] run() for ‘MultisessionFuture’ ... done
[11:00:07.176] Created future:
[11:00:07.176] MultisessionFuture:
[11:00:07.176] Label: ‘future_sapply-1’
[11:00:07.176] Expression:
[11:00:07.176] {
[11:00:07.176]     do.call(function(...) {
[11:00:07.176]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:07.176]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:07.176]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:07.176]             on.exit(options(oopts), add = TRUE)
[11:00:07.176]         }
[11:00:07.176]         {
[11:00:07.176]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:07.176]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:07.176]                 ...future.FUN(...future.X_jj, ...)
[11:00:07.176]             })
[11:00:07.176]         }
[11:00:07.176]     }, args = future.call.arguments)
[11:00:07.176] }
[11:00:07.176] Lazy evaluation: FALSE
[11:00:07.176] Asynchronous evaluation: TRUE
[11:00:07.176] Local evaluation: TRUE
[11:00:07.176] Environment: R_GlobalEnv
[11:00:07.176] Capture standard output: TRUE
[11:00:07.176] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:07.176] Globals: 5 objects totaling 5.17 KiB (function ‘...future.FUN’ of 4.67 KiB, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 369 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:07.176] Packages: 1 packages (‘stats’)
[11:00:07.176] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:07.176] Resolved: FALSE
[11:00:07.176] Value: <not collected>
[11:00:07.176] Conditions captured: <none>
[11:00:07.176] Early signaling: FALSE
[11:00:07.176] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:07.176] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:07.187] Chunk #1 of 2 ... DONE
[11:00:07.187] Chunk #2 of 2 ...
[11:00:07.187]  - Finding globals in 'X' for chunk #2 ...
[11:00:07.187] getGlobalsAndPackages() ...
[11:00:07.187] Searching for globals...
[11:00:07.188] 
[11:00:07.188] Searching for globals ... DONE
[11:00:07.188] - globals: [0] <none>
[11:00:07.188] getGlobalsAndPackages() ... DONE
[11:00:07.188]    + additional globals found: [n=0] 
[11:00:07.188]    + additional namespaces needed: [n=0] 
[11:00:07.188]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:07.188]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:07.188]  - seeds: <none>
[11:00:07.188]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:07.189] getGlobalsAndPackages() ...
[11:00:07.189] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:07.189] Resolving globals: FALSE
[11:00:07.189] Tweak future expression to call with '...' arguments ...
[11:00:07.189] {
[11:00:07.189]     do.call(function(...) {
[11:00:07.189]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:07.189]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:07.189]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:07.189]             on.exit(options(oopts), add = TRUE)
[11:00:07.189]         }
[11:00:07.189]         {
[11:00:07.189]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:07.189]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:07.189]                 ...future.FUN(...future.X_jj, ...)
[11:00:07.189]             })
[11:00:07.189]         }
[11:00:07.189]     }, args = future.call.arguments)
[11:00:07.189] }
[11:00:07.189] Tweak future expression to call with '...' arguments ... DONE
[11:00:07.189] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:07.190] - packages: [1] ‘stats’
[11:00:07.190] getGlobalsAndPackages() ... DONE
[11:00:07.190] run() for ‘Future’ ...
[11:00:07.190] - state: ‘created’
[11:00:07.190] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:07.203] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:07.204] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:07.204]   - Field: ‘node’
[11:00:07.204]   - Field: ‘label’
[11:00:07.204]   - Field: ‘local’
[11:00:07.204]   - Field: ‘owner’
[11:00:07.204]   - Field: ‘envir’
[11:00:07.204]   - Field: ‘workers’
[11:00:07.204]   - Field: ‘packages’
[11:00:07.204]   - Field: ‘gc’
[11:00:07.204]   - Field: ‘conditions’
[11:00:07.204]   - Field: ‘persistent’
[11:00:07.205]   - Field: ‘expr’
[11:00:07.205]   - Field: ‘uuid’
[11:00:07.205]   - Field: ‘seed’
[11:00:07.205]   - Field: ‘version’
[11:00:07.205]   - Field: ‘result’
[11:00:07.205]   - Field: ‘asynchronous’
[11:00:07.205]   - Field: ‘calls’
[11:00:07.205]   - Field: ‘globals’
[11:00:07.205]   - Field: ‘stdout’
[11:00:07.205]   - Field: ‘earlySignal’
[11:00:07.205]   - Field: ‘lazy’
[11:00:07.205]   - Field: ‘state’
[11:00:07.205] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:07.206] - Launch lazy future ...
[11:00:07.206] Packages needed by the future expression (n = 1): ‘stats’
[11:00:07.206] Packages needed by future strategies (n = 0): <none>
[11:00:07.206] {
[11:00:07.206]     {
[11:00:07.206]         {
[11:00:07.206]             ...future.startTime <- base::Sys.time()
[11:00:07.206]             {
[11:00:07.206]                 {
[11:00:07.206]                   {
[11:00:07.206]                     {
[11:00:07.206]                       {
[11:00:07.206]                         base::local({
[11:00:07.206]                           has_future <- base::requireNamespace("future", 
[11:00:07.206]                             quietly = TRUE)
[11:00:07.206]                           if (has_future) {
[11:00:07.206]                             ns <- base::getNamespace("future")
[11:00:07.206]                             version <- ns[[".package"]][["version"]]
[11:00:07.206]                             if (is.null(version)) 
[11:00:07.206]                               version <- utils::packageVersion("future")
[11:00:07.206]                           }
[11:00:07.206]                           else {
[11:00:07.206]                             version <- NULL
[11:00:07.206]                           }
[11:00:07.206]                           if (!has_future || version < "1.8.0") {
[11:00:07.206]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:07.206]                               "", base::R.version$version.string), 
[11:00:07.206]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:07.206]                                 base::R.version$platform, 8 * 
[11:00:07.206]                                   base::.Machine$sizeof.pointer), 
[11:00:07.206]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:07.206]                                 "release", "version")], collapse = " "), 
[11:00:07.206]                               hostname = base::Sys.info()[["nodename"]])
[11:00:07.206]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:07.206]                               info)
[11:00:07.206]                             info <- base::paste(info, collapse = "; ")
[11:00:07.206]                             if (!has_future) {
[11:00:07.206]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:07.206]                                 info)
[11:00:07.206]                             }
[11:00:07.206]                             else {
[11:00:07.206]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:07.206]                                 info, version)
[11:00:07.206]                             }
[11:00:07.206]                             base::stop(msg)
[11:00:07.206]                           }
[11:00:07.206]                         })
[11:00:07.206]                       }
[11:00:07.206]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:07.206]                       base::options(mc.cores = 1L)
[11:00:07.206]                     }
[11:00:07.206]                     base::local({
[11:00:07.206]                       for (pkg in "stats") {
[11:00:07.206]                         base::loadNamespace(pkg)
[11:00:07.206]                         base::library(pkg, character.only = TRUE)
[11:00:07.206]                       }
[11:00:07.206]                     })
[11:00:07.206]                   }
[11:00:07.206]                   ...future.strategy.old <- future::plan("list")
[11:00:07.206]                   options(future.plan = NULL)
[11:00:07.206]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:07.206]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:07.206]                 }
[11:00:07.206]                 ...future.workdir <- getwd()
[11:00:07.206]             }
[11:00:07.206]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:07.206]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:07.206]         }
[11:00:07.206]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:07.206]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:07.206]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:07.206]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:07.206]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:07.206]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:07.206]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:07.206]             base::names(...future.oldOptions))
[11:00:07.206]     }
[11:00:07.206]     if (FALSE) {
[11:00:07.206]     }
[11:00:07.206]     else {
[11:00:07.206]         if (TRUE) {
[11:00:07.206]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:07.206]                 open = "w")
[11:00:07.206]         }
[11:00:07.206]         else {
[11:00:07.206]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:07.206]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:07.206]         }
[11:00:07.206]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:07.206]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:07.206]             base::sink(type = "output", split = FALSE)
[11:00:07.206]             base::close(...future.stdout)
[11:00:07.206]         }, add = TRUE)
[11:00:07.206]     }
[11:00:07.206]     ...future.frame <- base::sys.nframe()
[11:00:07.206]     ...future.conditions <- base::list()
[11:00:07.206]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:07.206]     if (FALSE) {
[11:00:07.206]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:07.206]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:07.206]     }
[11:00:07.206]     ...future.result <- base::tryCatch({
[11:00:07.206]         base::withCallingHandlers({
[11:00:07.206]             ...future.value <- base::withVisible(base::local({
[11:00:07.206]                 ...future.makeSendCondition <- base::local({
[11:00:07.206]                   sendCondition <- NULL
[11:00:07.206]                   function(frame = 1L) {
[11:00:07.206]                     if (is.function(sendCondition)) 
[11:00:07.206]                       return(sendCondition)
[11:00:07.206]                     ns <- getNamespace("parallel")
[11:00:07.206]                     if (exists("sendData", mode = "function", 
[11:00:07.206]                       envir = ns)) {
[11:00:07.206]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:07.206]                         envir = ns)
[11:00:07.206]                       envir <- sys.frame(frame)
[11:00:07.206]                       master <- NULL
[11:00:07.206]                       while (!identical(envir, .GlobalEnv) && 
[11:00:07.206]                         !identical(envir, emptyenv())) {
[11:00:07.206]                         if (exists("master", mode = "list", envir = envir, 
[11:00:07.206]                           inherits = FALSE)) {
[11:00:07.206]                           master <- get("master", mode = "list", 
[11:00:07.206]                             envir = envir, inherits = FALSE)
[11:00:07.206]                           if (inherits(master, c("SOCKnode", 
[11:00:07.206]                             "SOCK0node"))) {
[11:00:07.206]                             sendCondition <<- function(cond) {
[11:00:07.206]                               data <- list(type = "VALUE", value = cond, 
[11:00:07.206]                                 success = TRUE)
[11:00:07.206]                               parallel_sendData(master, data)
[11:00:07.206]                             }
[11:00:07.206]                             return(sendCondition)
[11:00:07.206]                           }
[11:00:07.206]                         }
[11:00:07.206]                         frame <- frame + 1L
[11:00:07.206]                         envir <- sys.frame(frame)
[11:00:07.206]                       }
[11:00:07.206]                     }
[11:00:07.206]                     sendCondition <<- function(cond) NULL
[11:00:07.206]                   }
[11:00:07.206]                 })
[11:00:07.206]                 withCallingHandlers({
[11:00:07.206]                   {
[11:00:07.206]                     do.call(function(...) {
[11:00:07.206]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:07.206]                       if (!identical(...future.globals.maxSize.org, 
[11:00:07.206]                         ...future.globals.maxSize)) {
[11:00:07.206]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:07.206]                         on.exit(options(oopts), add = TRUE)
[11:00:07.206]                       }
[11:00:07.206]                       {
[11:00:07.206]                         lapply(seq_along(...future.elements_ii), 
[11:00:07.206]                           FUN = function(jj) {
[11:00:07.206]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:07.206]                             ...future.FUN(...future.X_jj, ...)
[11:00:07.206]                           })
[11:00:07.206]                       }
[11:00:07.206]                     }, args = future.call.arguments)
[11:00:07.206]                   }
[11:00:07.206]                 }, immediateCondition = function(cond) {
[11:00:07.206]                   sendCondition <- ...future.makeSendCondition()
[11:00:07.206]                   sendCondition(cond)
[11:00:07.206]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:07.206]                   {
[11:00:07.206]                     inherits <- base::inherits
[11:00:07.206]                     invokeRestart <- base::invokeRestart
[11:00:07.206]                     is.null <- base::is.null
[11:00:07.206]                     muffled <- FALSE
[11:00:07.206]                     if (inherits(cond, "message")) {
[11:00:07.206]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:07.206]                       if (muffled) 
[11:00:07.206]                         invokeRestart("muffleMessage")
[11:00:07.206]                     }
[11:00:07.206]                     else if (inherits(cond, "warning")) {
[11:00:07.206]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:07.206]                       if (muffled) 
[11:00:07.206]                         invokeRestart("muffleWarning")
[11:00:07.206]                     }
[11:00:07.206]                     else if (inherits(cond, "condition")) {
[11:00:07.206]                       if (!is.null(pattern)) {
[11:00:07.206]                         computeRestarts <- base::computeRestarts
[11:00:07.206]                         grepl <- base::grepl
[11:00:07.206]                         restarts <- computeRestarts(cond)
[11:00:07.206]                         for (restart in restarts) {
[11:00:07.206]                           name <- restart$name
[11:00:07.206]                           if (is.null(name)) 
[11:00:07.206]                             next
[11:00:07.206]                           if (!grepl(pattern, name)) 
[11:00:07.206]                             next
[11:00:07.206]                           invokeRestart(restart)
[11:00:07.206]                           muffled <- TRUE
[11:00:07.206]                           break
[11:00:07.206]                         }
[11:00:07.206]                       }
[11:00:07.206]                     }
[11:00:07.206]                     invisible(muffled)
[11:00:07.206]                   }
[11:00:07.206]                   muffleCondition(cond)
[11:00:07.206]                 })
[11:00:07.206]             }))
[11:00:07.206]             future::FutureResult(value = ...future.value$value, 
[11:00:07.206]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:07.206]                   ...future.rng), globalenv = if (FALSE) 
[11:00:07.206]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:07.206]                     ...future.globalenv.names))
[11:00:07.206]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:07.206]         }, condition = base::local({
[11:00:07.206]             c <- base::c
[11:00:07.206]             inherits <- base::inherits
[11:00:07.206]             invokeRestart <- base::invokeRestart
[11:00:07.206]             length <- base::length
[11:00:07.206]             list <- base::list
[11:00:07.206]             seq.int <- base::seq.int
[11:00:07.206]             signalCondition <- base::signalCondition
[11:00:07.206]             sys.calls <- base::sys.calls
[11:00:07.206]             `[[` <- base::`[[`
[11:00:07.206]             `+` <- base::`+`
[11:00:07.206]             `<<-` <- base::`<<-`
[11:00:07.206]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:07.206]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:07.206]                   3L)]
[11:00:07.206]             }
[11:00:07.206]             function(cond) {
[11:00:07.206]                 is_error <- inherits(cond, "error")
[11:00:07.206]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:07.206]                   NULL)
[11:00:07.206]                 if (is_error) {
[11:00:07.206]                   sessionInformation <- function() {
[11:00:07.206]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:07.206]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:07.206]                       search = base::search(), system = base::Sys.info())
[11:00:07.206]                   }
[11:00:07.206]                   ...future.conditions[[length(...future.conditions) + 
[11:00:07.206]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:07.206]                     cond$call), session = sessionInformation(), 
[11:00:07.206]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:07.206]                   signalCondition(cond)
[11:00:07.206]                 }
[11:00:07.206]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:07.206]                 "immediateCondition"))) {
[11:00:07.206]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:07.206]                   ...future.conditions[[length(...future.conditions) + 
[11:00:07.206]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:07.206]                   if (TRUE && !signal) {
[11:00:07.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:07.206]                     {
[11:00:07.206]                       inherits <- base::inherits
[11:00:07.206]                       invokeRestart <- base::invokeRestart
[11:00:07.206]                       is.null <- base::is.null
[11:00:07.206]                       muffled <- FALSE
[11:00:07.206]                       if (inherits(cond, "message")) {
[11:00:07.206]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:07.206]                         if (muffled) 
[11:00:07.206]                           invokeRestart("muffleMessage")
[11:00:07.206]                       }
[11:00:07.206]                       else if (inherits(cond, "warning")) {
[11:00:07.206]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:07.206]                         if (muffled) 
[11:00:07.206]                           invokeRestart("muffleWarning")
[11:00:07.206]                       }
[11:00:07.206]                       else if (inherits(cond, "condition")) {
[11:00:07.206]                         if (!is.null(pattern)) {
[11:00:07.206]                           computeRestarts <- base::computeRestarts
[11:00:07.206]                           grepl <- base::grepl
[11:00:07.206]                           restarts <- computeRestarts(cond)
[11:00:07.206]                           for (restart in restarts) {
[11:00:07.206]                             name <- restart$name
[11:00:07.206]                             if (is.null(name)) 
[11:00:07.206]                               next
[11:00:07.206]                             if (!grepl(pattern, name)) 
[11:00:07.206]                               next
[11:00:07.206]                             invokeRestart(restart)
[11:00:07.206]                             muffled <- TRUE
[11:00:07.206]                             break
[11:00:07.206]                           }
[11:00:07.206]                         }
[11:00:07.206]                       }
[11:00:07.206]                       invisible(muffled)
[11:00:07.206]                     }
[11:00:07.206]                     muffleCondition(cond, pattern = "^muffle")
[11:00:07.206]                   }
[11:00:07.206]                 }
[11:00:07.206]                 else {
[11:00:07.206]                   if (TRUE) {
[11:00:07.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:07.206]                     {
[11:00:07.206]                       inherits <- base::inherits
[11:00:07.206]                       invokeRestart <- base::invokeRestart
[11:00:07.206]                       is.null <- base::is.null
[11:00:07.206]                       muffled <- FALSE
[11:00:07.206]                       if (inherits(cond, "message")) {
[11:00:07.206]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:07.206]                         if (muffled) 
[11:00:07.206]                           invokeRestart("muffleMessage")
[11:00:07.206]                       }
[11:00:07.206]                       else if (inherits(cond, "warning")) {
[11:00:07.206]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:07.206]                         if (muffled) 
[11:00:07.206]                           invokeRestart("muffleWarning")
[11:00:07.206]                       }
[11:00:07.206]                       else if (inherits(cond, "condition")) {
[11:00:07.206]                         if (!is.null(pattern)) {
[11:00:07.206]                           computeRestarts <- base::computeRestarts
[11:00:07.206]                           grepl <- base::grepl
[11:00:07.206]                           restarts <- computeRestarts(cond)
[11:00:07.206]                           for (restart in restarts) {
[11:00:07.206]                             name <- restart$name
[11:00:07.206]                             if (is.null(name)) 
[11:00:07.206]                               next
[11:00:07.206]                             if (!grepl(pattern, name)) 
[11:00:07.206]                               next
[11:00:07.206]                             invokeRestart(restart)
[11:00:07.206]                             muffled <- TRUE
[11:00:07.206]                             break
[11:00:07.206]                           }
[11:00:07.206]                         }
[11:00:07.206]                       }
[11:00:07.206]                       invisible(muffled)
[11:00:07.206]                     }
[11:00:07.206]                     muffleCondition(cond, pattern = "^muffle")
[11:00:07.206]                   }
[11:00:07.206]                 }
[11:00:07.206]             }
[11:00:07.206]         }))
[11:00:07.206]     }, error = function(ex) {
[11:00:07.206]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:07.206]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:07.206]                 ...future.rng), started = ...future.startTime, 
[11:00:07.206]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:07.206]             version = "1.8"), class = "FutureResult")
[11:00:07.206]     }, finally = {
[11:00:07.206]         if (!identical(...future.workdir, getwd())) 
[11:00:07.206]             setwd(...future.workdir)
[11:00:07.206]         {
[11:00:07.206]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:07.206]                 ...future.oldOptions$nwarnings <- NULL
[11:00:07.206]             }
[11:00:07.206]             base::options(...future.oldOptions)
[11:00:07.206]             if (.Platform$OS.type == "windows") {
[11:00:07.206]                 old_names <- names(...future.oldEnvVars)
[11:00:07.206]                 envs <- base::Sys.getenv()
[11:00:07.206]                 names <- names(envs)
[11:00:07.206]                 common <- intersect(names, old_names)
[11:00:07.206]                 added <- setdiff(names, old_names)
[11:00:07.206]                 removed <- setdiff(old_names, names)
[11:00:07.206]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:07.206]                   envs[common]]
[11:00:07.206]                 NAMES <- toupper(changed)
[11:00:07.206]                 args <- list()
[11:00:07.206]                 for (kk in seq_along(NAMES)) {
[11:00:07.206]                   name <- changed[[kk]]
[11:00:07.206]                   NAME <- NAMES[[kk]]
[11:00:07.206]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:07.206]                     next
[11:00:07.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:07.206]                 }
[11:00:07.206]                 NAMES <- toupper(added)
[11:00:07.206]                 for (kk in seq_along(NAMES)) {
[11:00:07.206]                   name <- added[[kk]]
[11:00:07.206]                   NAME <- NAMES[[kk]]
[11:00:07.206]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:07.206]                     next
[11:00:07.206]                   args[[name]] <- ""
[11:00:07.206]                 }
[11:00:07.206]                 NAMES <- toupper(removed)
[11:00:07.206]                 for (kk in seq_along(NAMES)) {
[11:00:07.206]                   name <- removed[[kk]]
[11:00:07.206]                   NAME <- NAMES[[kk]]
[11:00:07.206]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:07.206]                     next
[11:00:07.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:07.206]                 }
[11:00:07.206]                 if (length(args) > 0) 
[11:00:07.206]                   base::do.call(base::Sys.setenv, args = args)
[11:00:07.206]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:07.206]             }
[11:00:07.206]             else {
[11:00:07.206]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:07.206]             }
[11:00:07.206]             {
[11:00:07.206]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:07.206]                   0L) {
[11:00:07.206]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:07.206]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:07.206]                   base::options(opts)
[11:00:07.206]                 }
[11:00:07.206]                 {
[11:00:07.206]                   {
[11:00:07.206]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:07.206]                     NULL
[11:00:07.206]                   }
[11:00:07.206]                   options(future.plan = NULL)
[11:00:07.206]                   if (is.na(NA_character_)) 
[11:00:07.206]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:07.206]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:07.206]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:07.206]                     .init = FALSE)
[11:00:07.206]                 }
[11:00:07.206]             }
[11:00:07.206]         }
[11:00:07.206]     })
[11:00:07.206]     if (TRUE) {
[11:00:07.206]         base::sink(type = "output", split = FALSE)
[11:00:07.206]         if (TRUE) {
[11:00:07.206]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:07.206]         }
[11:00:07.206]         else {
[11:00:07.206]             ...future.result["stdout"] <- base::list(NULL)
[11:00:07.206]         }
[11:00:07.206]         base::close(...future.stdout)
[11:00:07.206]         ...future.stdout <- NULL
[11:00:07.206]     }
[11:00:07.206]     ...future.result$conditions <- ...future.conditions
[11:00:07.206]     ...future.result$finished <- base::Sys.time()
[11:00:07.206]     ...future.result
[11:00:07.206] }
[11:00:07.209] Exporting 5 global objects (5.55 KiB) to cluster node #2 ...
[11:00:07.209] Exporting ‘...future.FUN’ (4.67 KiB) to cluster node #2 ...
[11:00:07.251] Exporting ‘...future.FUN’ (4.67 KiB) to cluster node #2 ... DONE
[11:00:07.251] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[11:00:07.251] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[11:00:07.251] Exporting ‘...future.elements_ii’ (293 bytes) to cluster node #2 ...
[11:00:07.252] Exporting ‘...future.elements_ii’ (293 bytes) to cluster node #2 ... DONE
[11:00:07.252] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[11:00:07.252] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[11:00:07.252] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[11:00:07.253] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[11:00:07.253] Exporting 5 global objects (5.55 KiB) to cluster node #2 ... DONE
[11:00:07.253] MultisessionFuture started
[11:00:07.253] - Launch lazy future ... done
[11:00:07.254] run() for ‘MultisessionFuture’ ... done
[11:00:07.254] Created future:
[11:00:07.254] MultisessionFuture:
[11:00:07.254] Label: ‘future_sapply-2’
[11:00:07.254] Expression:
[11:00:07.254] {
[11:00:07.254]     do.call(function(...) {
[11:00:07.254]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:07.254]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:07.254]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:07.254]             on.exit(options(oopts), add = TRUE)
[11:00:07.254]         }
[11:00:07.254]         {
[11:00:07.254]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:07.254]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:07.254]                 ...future.FUN(...future.X_jj, ...)
[11:00:07.254]             })
[11:00:07.254]         }
[11:00:07.254]     }, args = future.call.arguments)
[11:00:07.254] }
[11:00:07.254] Lazy evaluation: FALSE
[11:00:07.254] Asynchronous evaluation: TRUE
[11:00:07.254] Local evaluation: TRUE
[11:00:07.254] Environment: R_GlobalEnv
[11:00:07.254] Capture standard output: TRUE
[11:00:07.254] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:07.254] Globals: 5 objects totaling 5.10 KiB (function ‘...future.FUN’ of 4.67 KiB, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 293 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:07.254] Packages: 1 packages (‘stats’)
[11:00:07.254] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:07.254] Resolved: FALSE
[11:00:07.254] Value: <not collected>
[11:00:07.254] Conditions captured: <none>
[11:00:07.254] Early signaling: FALSE
[11:00:07.254] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:07.254] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:07.265] Chunk #2 of 2 ... DONE
[11:00:07.265] Launching 2 futures (chunks) ... DONE
[11:00:07.265] Resolving 2 futures (chunks) ...
[11:00:07.265] resolve() on list ...
[11:00:07.266]  recursive: 0
[11:00:07.266]  length: 2
[11:00:07.266] 
[11:00:07.266] receiveMessageFromWorker() for ClusterFuture ...
[11:00:07.266] - Validating connection of MultisessionFuture
[11:00:07.266] - received message: FutureResult
[11:00:07.267] - Received FutureResult
[11:00:07.267] - Erased future from FutureRegistry
[11:00:07.267] result() for ClusterFuture ...
[11:00:07.267] - result already collected: FutureResult
[11:00:07.267] result() for ClusterFuture ... done
[11:00:07.267] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:07.267] Future #1
[11:00:07.267] result() for ClusterFuture ...
[11:00:07.267] - result already collected: FutureResult
[11:00:07.267] result() for ClusterFuture ... done
[11:00:07.267] result() for ClusterFuture ...
[11:00:07.267] - result already collected: FutureResult
[11:00:07.267] result() for ClusterFuture ... done
[11:00:07.268] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:00:07.268] - nx: 2
[11:00:07.268] - relay: TRUE
[11:00:07.268] - stdout: TRUE
[11:00:07.268] - signal: TRUE
[11:00:07.268] - resignal: FALSE
[11:00:07.268] - force: TRUE
[11:00:07.268] - relayed: [n=2] FALSE, FALSE
[11:00:07.268] - queued futures: [n=2] FALSE, FALSE
[11:00:07.268]  - until=1
[11:00:07.268]  - relaying element #1
[11:00:07.268] result() for ClusterFuture ...
[11:00:07.269] - result already collected: FutureResult
[11:00:07.269] result() for ClusterFuture ... done
[11:00:07.269] result() for ClusterFuture ...
[11:00:07.269] - result already collected: FutureResult
[11:00:07.269] result() for ClusterFuture ... done
[11:00:07.269] result() for ClusterFuture ...
[11:00:07.269] - result already collected: FutureResult
[11:00:07.269] result() for ClusterFuture ... done
[11:00:07.269] result() for ClusterFuture ...
[11:00:07.269] - result already collected: FutureResult
[11:00:07.269] result() for ClusterFuture ... done
[11:00:07.269] - relayed: [n=2] TRUE, FALSE
[11:00:07.269] - queued futures: [n=2] TRUE, FALSE
[11:00:07.270] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:00:07.270]  length: 1 (resolved future 1)
[11:00:07.295] receiveMessageFromWorker() for ClusterFuture ...
[11:00:07.296] - Validating connection of MultisessionFuture
[11:00:07.296] - received message: FutureResult
[11:00:07.296] - Received FutureResult
[11:00:07.296] - Erased future from FutureRegistry
[11:00:07.296] result() for ClusterFuture ...
[11:00:07.296] - result already collected: FutureResult
[11:00:07.296] result() for ClusterFuture ... done
[11:00:07.296] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:07.296] Future #2
[11:00:07.297] result() for ClusterFuture ...
[11:00:07.297] - result already collected: FutureResult
[11:00:07.297] result() for ClusterFuture ... done
[11:00:07.297] result() for ClusterFuture ...
[11:00:07.297] - result already collected: FutureResult
[11:00:07.297] result() for ClusterFuture ... done
[11:00:07.297] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:00:07.297] - nx: 2
[11:00:07.297] - relay: TRUE
[11:00:07.297] - stdout: TRUE
[11:00:07.297] - signal: TRUE
[11:00:07.297] - resignal: FALSE
[11:00:07.297] - force: TRUE
[11:00:07.298] - relayed: [n=2] TRUE, FALSE
[11:00:07.298] - queued futures: [n=2] TRUE, FALSE
[11:00:07.298]  - until=2
[11:00:07.298]  - relaying element #2
[11:00:07.298] result() for ClusterFuture ...
[11:00:07.298] - result already collected: FutureResult
[11:00:07.298] result() for ClusterFuture ... done
[11:00:07.298] result() for ClusterFuture ...
[11:00:07.298] - result already collected: FutureResult
[11:00:07.298] result() for ClusterFuture ... done
[11:00:07.298] result() for ClusterFuture ...
[11:00:07.299] - result already collected: FutureResult
[11:00:07.299] result() for ClusterFuture ... done
[11:00:07.299] result() for ClusterFuture ...
[11:00:07.299] - result already collected: FutureResult
[11:00:07.299] result() for ClusterFuture ... done
[11:00:07.299] - relayed: [n=2] TRUE, TRUE
[11:00:07.299] - queued futures: [n=2] TRUE, TRUE
[11:00:07.299] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:00:07.299]  length: 0 (resolved future 2)
[11:00:07.299] Relaying remaining futures
[11:00:07.300] signalConditionsASAP(NULL, pos=0) ...
[11:00:07.300] - nx: 2
[11:00:07.300] - relay: TRUE
[11:00:07.300] - stdout: TRUE
[11:00:07.300] - signal: TRUE
[11:00:07.300] - resignal: FALSE
[11:00:07.300] - force: TRUE
[11:00:07.300] - relayed: [n=2] TRUE, TRUE
[11:00:07.300] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:07.300] - relayed: [n=2] TRUE, TRUE
[11:00:07.300] - queued futures: [n=2] TRUE, TRUE
[11:00:07.301] signalConditionsASAP(NULL, pos=0) ... done
[11:00:07.301] resolve() on list ... DONE
[11:00:07.301] result() for ClusterFuture ...
[11:00:07.301] - result already collected: FutureResult
[11:00:07.301] result() for ClusterFuture ... done
[11:00:07.301] result() for ClusterFuture ...
[11:00:07.301] - result already collected: FutureResult
[11:00:07.301] result() for ClusterFuture ... done
[11:00:07.301] result() for ClusterFuture ...
[11:00:07.301] - result already collected: FutureResult
[11:00:07.302] result() for ClusterFuture ... done
[11:00:07.302] result() for ClusterFuture ...
[11:00:07.302] - result already collected: FutureResult
[11:00:07.302] result() for ClusterFuture ... done
[11:00:07.302]  - Number of value chunks collected: 2
[11:00:07.302] Resolving 2 futures (chunks) ... DONE
[11:00:07.302] Reducing values from 2 chunks ...
[11:00:07.302]  - Number of values collected after concatenation: 7
[11:00:07.302]  - Number of values expected: 7
[11:00:07.303] Reducing values from 2 chunks ... DONE
[11:00:07.303] future_lapply() ... DONE
[11:00:07.303] future_lapply() ...
[11:00:07.307] Number of chunks: 2
[11:00:07.307] getGlobalsAndPackagesXApply() ...
[11:00:07.307]  - future.globals: TRUE
[11:00:07.307] getGlobalsAndPackages() ...
[11:00:07.307] Searching for globals...
[11:00:07.314] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[11:00:07.315] Searching for globals ... DONE
[11:00:07.315] Resolving globals: FALSE
[11:00:07.316] The total size of the 7 globals is 26.71 KiB (27354 bytes)
[11:00:07.317] The total size of the 7 globals exported for future expression (‘FUN()’) is 26.71 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (14.07 KiB of class ‘function’), ‘x_FUN’ (4.67 KiB of class ‘function’) and ‘stop_if_not’ (4.51 KiB of class ‘function’)
[11:00:07.317] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:07.317] - packages: [2] ‘stats’, ‘future.apply’
[11:00:07.317] getGlobalsAndPackages() ... DONE
[11:00:07.317]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:07.317]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[11:00:07.317] Finding globals ... DONE
[11:00:07.317]  - use_args: TRUE
[11:00:07.317]  - Getting '...' globals ...
[11:00:07.318] resolve() on list ...
[11:00:07.318]  recursive: 0
[11:00:07.318]  length: 1
[11:00:07.318]  elements: ‘...’
[11:00:07.318]  length: 0 (resolved future 1)
[11:00:07.318] resolve() on list ... DONE
[11:00:07.318]    - '...' content: [n=0] 
[11:00:07.318] List of 1
[11:00:07.318]  $ ...: list()
[11:00:07.318]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:07.318]  - attr(*, "where")=List of 1
[11:00:07.318]   ..$ ...:<environment: 0x55bbae96d878> 
[11:00:07.318]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:07.318]  - attr(*, "resolved")= logi TRUE
[11:00:07.318]  - attr(*, "total_size")= num NA
[11:00:07.321]  - Getting '...' globals ... DONE
[11:00:07.321] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:07.321] List of 8
[11:00:07.321]  $ ...future.FUN:function (x, ...)  
[11:00:07.321]  $ x_FUN        :function (x, na.rm = TRUE)  
[11:00:07.321]  $ times        : int 5
[11:00:07.321]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:07.321]  $ stop_if_not  :function (...)  
[11:00:07.321]  $ dim          : NULL
[11:00:07.321]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:07.321]  $ ...          : list()
[11:00:07.321]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:07.321]  - attr(*, "where")=List of 8
[11:00:07.321]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:07.321]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:07.321]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:07.321]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:07.321]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:07.321]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:07.321]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:07.321]   ..$ ...          :<environment: 0x55bbae96d878> 
[11:00:07.321]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:07.321]  - attr(*, "resolved")= logi FALSE
[11:00:07.321]  - attr(*, "total_size")= num 48005
[11:00:07.326] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[11:00:07.326] getGlobalsAndPackagesXApply() ... DONE
[11:00:07.327] Number of futures (= number of chunks): 2
[11:00:07.327] Launching 2 futures (chunks) ...
[11:00:07.327] Chunk #1 of 2 ...
[11:00:07.327]  - Finding globals in 'X' for chunk #1 ...
[11:00:07.327] getGlobalsAndPackages() ...
[11:00:07.327] Searching for globals...
[11:00:07.327] 
[11:00:07.327] Searching for globals ... DONE
[11:00:07.328] - globals: [0] <none>
[11:00:07.328] getGlobalsAndPackages() ... DONE
[11:00:07.328]    + additional globals found: [n=0] 
[11:00:07.328]    + additional namespaces needed: [n=0] 
[11:00:07.328]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:07.328]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:07.330]  - seeds: <none>
[11:00:07.330]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:07.330] getGlobalsAndPackages() ...
[11:00:07.330] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:07.330] Resolving globals: FALSE
[11:00:07.330] Tweak future expression to call with '...' arguments ...
[11:00:07.330] {
[11:00:07.330]     do.call(function(...) {
[11:00:07.330]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:07.330]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:07.330]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:07.330]             on.exit(options(oopts), add = TRUE)
[11:00:07.330]         }
[11:00:07.330]         {
[11:00:07.330]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:07.330]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:07.330]                 ...future.FUN(...future.X_jj, ...)
[11:00:07.330]             })
[11:00:07.330]         }
[11:00:07.330]     }, args = future.call.arguments)
[11:00:07.330] }
[11:00:07.331] Tweak future expression to call with '...' arguments ... DONE
[11:00:07.331] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:07.331] - packages: [2] ‘stats’, ‘future.apply’
[11:00:07.331] getGlobalsAndPackages() ... DONE
[11:00:07.332] run() for ‘Future’ ...
[11:00:07.332] - state: ‘created’
[11:00:07.332] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:07.346] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:07.346] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:07.346]   - Field: ‘node’
[11:00:07.346]   - Field: ‘label’
[11:00:07.346]   - Field: ‘local’
[11:00:07.346]   - Field: ‘owner’
[11:00:07.346]   - Field: ‘envir’
[11:00:07.346]   - Field: ‘workers’
[11:00:07.346]   - Field: ‘packages’
[11:00:07.346]   - Field: ‘gc’
[11:00:07.347]   - Field: ‘conditions’
[11:00:07.347]   - Field: ‘persistent’
[11:00:07.347]   - Field: ‘expr’
[11:00:07.347]   - Field: ‘uuid’
[11:00:07.347]   - Field: ‘seed’
[11:00:07.347]   - Field: ‘version’
[11:00:07.347]   - Field: ‘result’
[11:00:07.347]   - Field: ‘asynchronous’
[11:00:07.347]   - Field: ‘calls’
[11:00:07.347]   - Field: ‘globals’
[11:00:07.347]   - Field: ‘stdout’
[11:00:07.347]   - Field: ‘earlySignal’
[11:00:07.348]   - Field: ‘lazy’
[11:00:07.348]   - Field: ‘state’
[11:00:07.348] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:07.348] - Launch lazy future ...
[11:00:07.348] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[11:00:07.348] Packages needed by future strategies (n = 0): <none>
[11:00:07.349] {
[11:00:07.349]     {
[11:00:07.349]         {
[11:00:07.349]             ...future.startTime <- base::Sys.time()
[11:00:07.349]             {
[11:00:07.349]                 {
[11:00:07.349]                   {
[11:00:07.349]                     {
[11:00:07.349]                       {
[11:00:07.349]                         base::local({
[11:00:07.349]                           has_future <- base::requireNamespace("future", 
[11:00:07.349]                             quietly = TRUE)
[11:00:07.349]                           if (has_future) {
[11:00:07.349]                             ns <- base::getNamespace("future")
[11:00:07.349]                             version <- ns[[".package"]][["version"]]
[11:00:07.349]                             if (is.null(version)) 
[11:00:07.349]                               version <- utils::packageVersion("future")
[11:00:07.349]                           }
[11:00:07.349]                           else {
[11:00:07.349]                             version <- NULL
[11:00:07.349]                           }
[11:00:07.349]                           if (!has_future || version < "1.8.0") {
[11:00:07.349]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:07.349]                               "", base::R.version$version.string), 
[11:00:07.349]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:07.349]                                 base::R.version$platform, 8 * 
[11:00:07.349]                                   base::.Machine$sizeof.pointer), 
[11:00:07.349]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:07.349]                                 "release", "version")], collapse = " "), 
[11:00:07.349]                               hostname = base::Sys.info()[["nodename"]])
[11:00:07.349]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:07.349]                               info)
[11:00:07.349]                             info <- base::paste(info, collapse = "; ")
[11:00:07.349]                             if (!has_future) {
[11:00:07.349]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:07.349]                                 info)
[11:00:07.349]                             }
[11:00:07.349]                             else {
[11:00:07.349]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:07.349]                                 info, version)
[11:00:07.349]                             }
[11:00:07.349]                             base::stop(msg)
[11:00:07.349]                           }
[11:00:07.349]                         })
[11:00:07.349]                       }
[11:00:07.349]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:07.349]                       base::options(mc.cores = 1L)
[11:00:07.349]                     }
[11:00:07.349]                     base::local({
[11:00:07.349]                       for (pkg in c("stats", "future.apply")) {
[11:00:07.349]                         base::loadNamespace(pkg)
[11:00:07.349]                         base::library(pkg, character.only = TRUE)
[11:00:07.349]                       }
[11:00:07.349]                     })
[11:00:07.349]                   }
[11:00:07.349]                   ...future.strategy.old <- future::plan("list")
[11:00:07.349]                   options(future.plan = NULL)
[11:00:07.349]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:07.349]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:07.349]                 }
[11:00:07.349]                 ...future.workdir <- getwd()
[11:00:07.349]             }
[11:00:07.349]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:07.349]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:07.349]         }
[11:00:07.349]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:07.349]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:07.349]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:07.349]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:07.349]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:07.349]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:07.349]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:07.349]             base::names(...future.oldOptions))
[11:00:07.349]     }
[11:00:07.349]     if (FALSE) {
[11:00:07.349]     }
[11:00:07.349]     else {
[11:00:07.349]         if (TRUE) {
[11:00:07.349]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:07.349]                 open = "w")
[11:00:07.349]         }
[11:00:07.349]         else {
[11:00:07.349]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:07.349]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:07.349]         }
[11:00:07.349]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:07.349]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:07.349]             base::sink(type = "output", split = FALSE)
[11:00:07.349]             base::close(...future.stdout)
[11:00:07.349]         }, add = TRUE)
[11:00:07.349]     }
[11:00:07.349]     ...future.frame <- base::sys.nframe()
[11:00:07.349]     ...future.conditions <- base::list()
[11:00:07.349]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:07.349]     if (FALSE) {
[11:00:07.349]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:07.349]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:07.349]     }
[11:00:07.349]     ...future.result <- base::tryCatch({
[11:00:07.349]         base::withCallingHandlers({
[11:00:07.349]             ...future.value <- base::withVisible(base::local({
[11:00:07.349]                 ...future.makeSendCondition <- base::local({
[11:00:07.349]                   sendCondition <- NULL
[11:00:07.349]                   function(frame = 1L) {
[11:00:07.349]                     if (is.function(sendCondition)) 
[11:00:07.349]                       return(sendCondition)
[11:00:07.349]                     ns <- getNamespace("parallel")
[11:00:07.349]                     if (exists("sendData", mode = "function", 
[11:00:07.349]                       envir = ns)) {
[11:00:07.349]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:07.349]                         envir = ns)
[11:00:07.349]                       envir <- sys.frame(frame)
[11:00:07.349]                       master <- NULL
[11:00:07.349]                       while (!identical(envir, .GlobalEnv) && 
[11:00:07.349]                         !identical(envir, emptyenv())) {
[11:00:07.349]                         if (exists("master", mode = "list", envir = envir, 
[11:00:07.349]                           inherits = FALSE)) {
[11:00:07.349]                           master <- get("master", mode = "list", 
[11:00:07.349]                             envir = envir, inherits = FALSE)
[11:00:07.349]                           if (inherits(master, c("SOCKnode", 
[11:00:07.349]                             "SOCK0node"))) {
[11:00:07.349]                             sendCondition <<- function(cond) {
[11:00:07.349]                               data <- list(type = "VALUE", value = cond, 
[11:00:07.349]                                 success = TRUE)
[11:00:07.349]                               parallel_sendData(master, data)
[11:00:07.349]                             }
[11:00:07.349]                             return(sendCondition)
[11:00:07.349]                           }
[11:00:07.349]                         }
[11:00:07.349]                         frame <- frame + 1L
[11:00:07.349]                         envir <- sys.frame(frame)
[11:00:07.349]                       }
[11:00:07.349]                     }
[11:00:07.349]                     sendCondition <<- function(cond) NULL
[11:00:07.349]                   }
[11:00:07.349]                 })
[11:00:07.349]                 withCallingHandlers({
[11:00:07.349]                   {
[11:00:07.349]                     do.call(function(...) {
[11:00:07.349]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:07.349]                       if (!identical(...future.globals.maxSize.org, 
[11:00:07.349]                         ...future.globals.maxSize)) {
[11:00:07.349]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:07.349]                         on.exit(options(oopts), add = TRUE)
[11:00:07.349]                       }
[11:00:07.349]                       {
[11:00:07.349]                         lapply(seq_along(...future.elements_ii), 
[11:00:07.349]                           FUN = function(jj) {
[11:00:07.349]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:07.349]                             ...future.FUN(...future.X_jj, ...)
[11:00:07.349]                           })
[11:00:07.349]                       }
[11:00:07.349]                     }, args = future.call.arguments)
[11:00:07.349]                   }
[11:00:07.349]                 }, immediateCondition = function(cond) {
[11:00:07.349]                   sendCondition <- ...future.makeSendCondition()
[11:00:07.349]                   sendCondition(cond)
[11:00:07.349]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:07.349]                   {
[11:00:07.349]                     inherits <- base::inherits
[11:00:07.349]                     invokeRestart <- base::invokeRestart
[11:00:07.349]                     is.null <- base::is.null
[11:00:07.349]                     muffled <- FALSE
[11:00:07.349]                     if (inherits(cond, "message")) {
[11:00:07.349]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:07.349]                       if (muffled) 
[11:00:07.349]                         invokeRestart("muffleMessage")
[11:00:07.349]                     }
[11:00:07.349]                     else if (inherits(cond, "warning")) {
[11:00:07.349]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:07.349]                       if (muffled) 
[11:00:07.349]                         invokeRestart("muffleWarning")
[11:00:07.349]                     }
[11:00:07.349]                     else if (inherits(cond, "condition")) {
[11:00:07.349]                       if (!is.null(pattern)) {
[11:00:07.349]                         computeRestarts <- base::computeRestarts
[11:00:07.349]                         grepl <- base::grepl
[11:00:07.349]                         restarts <- computeRestarts(cond)
[11:00:07.349]                         for (restart in restarts) {
[11:00:07.349]                           name <- restart$name
[11:00:07.349]                           if (is.null(name)) 
[11:00:07.349]                             next
[11:00:07.349]                           if (!grepl(pattern, name)) 
[11:00:07.349]                             next
[11:00:07.349]                           invokeRestart(restart)
[11:00:07.349]                           muffled <- TRUE
[11:00:07.349]                           break
[11:00:07.349]                         }
[11:00:07.349]                       }
[11:00:07.349]                     }
[11:00:07.349]                     invisible(muffled)
[11:00:07.349]                   }
[11:00:07.349]                   muffleCondition(cond)
[11:00:07.349]                 })
[11:00:07.349]             }))
[11:00:07.349]             future::FutureResult(value = ...future.value$value, 
[11:00:07.349]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:07.349]                   ...future.rng), globalenv = if (FALSE) 
[11:00:07.349]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:07.349]                     ...future.globalenv.names))
[11:00:07.349]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:07.349]         }, condition = base::local({
[11:00:07.349]             c <- base::c
[11:00:07.349]             inherits <- base::inherits
[11:00:07.349]             invokeRestart <- base::invokeRestart
[11:00:07.349]             length <- base::length
[11:00:07.349]             list <- base::list
[11:00:07.349]             seq.int <- base::seq.int
[11:00:07.349]             signalCondition <- base::signalCondition
[11:00:07.349]             sys.calls <- base::sys.calls
[11:00:07.349]             `[[` <- base::`[[`
[11:00:07.349]             `+` <- base::`+`
[11:00:07.349]             `<<-` <- base::`<<-`
[11:00:07.349]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:07.349]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:07.349]                   3L)]
[11:00:07.349]             }
[11:00:07.349]             function(cond) {
[11:00:07.349]                 is_error <- inherits(cond, "error")
[11:00:07.349]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:07.349]                   NULL)
[11:00:07.349]                 if (is_error) {
[11:00:07.349]                   sessionInformation <- function() {
[11:00:07.349]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:07.349]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:07.349]                       search = base::search(), system = base::Sys.info())
[11:00:07.349]                   }
[11:00:07.349]                   ...future.conditions[[length(...future.conditions) + 
[11:00:07.349]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:07.349]                     cond$call), session = sessionInformation(), 
[11:00:07.349]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:07.349]                   signalCondition(cond)
[11:00:07.349]                 }
[11:00:07.349]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:07.349]                 "immediateCondition"))) {
[11:00:07.349]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:07.349]                   ...future.conditions[[length(...future.conditions) + 
[11:00:07.349]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:07.349]                   if (TRUE && !signal) {
[11:00:07.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:07.349]                     {
[11:00:07.349]                       inherits <- base::inherits
[11:00:07.349]                       invokeRestart <- base::invokeRestart
[11:00:07.349]                       is.null <- base::is.null
[11:00:07.349]                       muffled <- FALSE
[11:00:07.349]                       if (inherits(cond, "message")) {
[11:00:07.349]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:07.349]                         if (muffled) 
[11:00:07.349]                           invokeRestart("muffleMessage")
[11:00:07.349]                       }
[11:00:07.349]                       else if (inherits(cond, "warning")) {
[11:00:07.349]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:07.349]                         if (muffled) 
[11:00:07.349]                           invokeRestart("muffleWarning")
[11:00:07.349]                       }
[11:00:07.349]                       else if (inherits(cond, "condition")) {
[11:00:07.349]                         if (!is.null(pattern)) {
[11:00:07.349]                           computeRestarts <- base::computeRestarts
[11:00:07.349]                           grepl <- base::grepl
[11:00:07.349]                           restarts <- computeRestarts(cond)
[11:00:07.349]                           for (restart in restarts) {
[11:00:07.349]                             name <- restart$name
[11:00:07.349]                             if (is.null(name)) 
[11:00:07.349]                               next
[11:00:07.349]                             if (!grepl(pattern, name)) 
[11:00:07.349]                               next
[11:00:07.349]                             invokeRestart(restart)
[11:00:07.349]                             muffled <- TRUE
[11:00:07.349]                             break
[11:00:07.349]                           }
[11:00:07.349]                         }
[11:00:07.349]                       }
[11:00:07.349]                       invisible(muffled)
[11:00:07.349]                     }
[11:00:07.349]                     muffleCondition(cond, pattern = "^muffle")
[11:00:07.349]                   }
[11:00:07.349]                 }
[11:00:07.349]                 else {
[11:00:07.349]                   if (TRUE) {
[11:00:07.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:07.349]                     {
[11:00:07.349]                       inherits <- base::inherits
[11:00:07.349]                       invokeRestart <- base::invokeRestart
[11:00:07.349]                       is.null <- base::is.null
[11:00:07.349]                       muffled <- FALSE
[11:00:07.349]                       if (inherits(cond, "message")) {
[11:00:07.349]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:07.349]                         if (muffled) 
[11:00:07.349]                           invokeRestart("muffleMessage")
[11:00:07.349]                       }
[11:00:07.349]                       else if (inherits(cond, "warning")) {
[11:00:07.349]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:07.349]                         if (muffled) 
[11:00:07.349]                           invokeRestart("muffleWarning")
[11:00:07.349]                       }
[11:00:07.349]                       else if (inherits(cond, "condition")) {
[11:00:07.349]                         if (!is.null(pattern)) {
[11:00:07.349]                           computeRestarts <- base::computeRestarts
[11:00:07.349]                           grepl <- base::grepl
[11:00:07.349]                           restarts <- computeRestarts(cond)
[11:00:07.349]                           for (restart in restarts) {
[11:00:07.349]                             name <- restart$name
[11:00:07.349]                             if (is.null(name)) 
[11:00:07.349]                               next
[11:00:07.349]                             if (!grepl(pattern, name)) 
[11:00:07.349]                               next
[11:00:07.349]                             invokeRestart(restart)
[11:00:07.349]                             muffled <- TRUE
[11:00:07.349]                             break
[11:00:07.349]                           }
[11:00:07.349]                         }
[11:00:07.349]                       }
[11:00:07.349]                       invisible(muffled)
[11:00:07.349]                     }
[11:00:07.349]                     muffleCondition(cond, pattern = "^muffle")
[11:00:07.349]                   }
[11:00:07.349]                 }
[11:00:07.349]             }
[11:00:07.349]         }))
[11:00:07.349]     }, error = function(ex) {
[11:00:07.349]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:07.349]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:07.349]                 ...future.rng), started = ...future.startTime, 
[11:00:07.349]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:07.349]             version = "1.8"), class = "FutureResult")
[11:00:07.349]     }, finally = {
[11:00:07.349]         if (!identical(...future.workdir, getwd())) 
[11:00:07.349]             setwd(...future.workdir)
[11:00:07.349]         {
[11:00:07.349]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:07.349]                 ...future.oldOptions$nwarnings <- NULL
[11:00:07.349]             }
[11:00:07.349]             base::options(...future.oldOptions)
[11:00:07.349]             if (.Platform$OS.type == "windows") {
[11:00:07.349]                 old_names <- names(...future.oldEnvVars)
[11:00:07.349]                 envs <- base::Sys.getenv()
[11:00:07.349]                 names <- names(envs)
[11:00:07.349]                 common <- intersect(names, old_names)
[11:00:07.349]                 added <- setdiff(names, old_names)
[11:00:07.349]                 removed <- setdiff(old_names, names)
[11:00:07.349]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:07.349]                   envs[common]]
[11:00:07.349]                 NAMES <- toupper(changed)
[11:00:07.349]                 args <- list()
[11:00:07.349]                 for (kk in seq_along(NAMES)) {
[11:00:07.349]                   name <- changed[[kk]]
[11:00:07.349]                   NAME <- NAMES[[kk]]
[11:00:07.349]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:07.349]                     next
[11:00:07.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:07.349]                 }
[11:00:07.349]                 NAMES <- toupper(added)
[11:00:07.349]                 for (kk in seq_along(NAMES)) {
[11:00:07.349]                   name <- added[[kk]]
[11:00:07.349]                   NAME <- NAMES[[kk]]
[11:00:07.349]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:07.349]                     next
[11:00:07.349]                   args[[name]] <- ""
[11:00:07.349]                 }
[11:00:07.349]                 NAMES <- toupper(removed)
[11:00:07.349]                 for (kk in seq_along(NAMES)) {
[11:00:07.349]                   name <- removed[[kk]]
[11:00:07.349]                   NAME <- NAMES[[kk]]
[11:00:07.349]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:07.349]                     next
[11:00:07.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:07.349]                 }
[11:00:07.349]                 if (length(args) > 0) 
[11:00:07.349]                   base::do.call(base::Sys.setenv, args = args)
[11:00:07.349]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:07.349]             }
[11:00:07.349]             else {
[11:00:07.349]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:07.349]             }
[11:00:07.349]             {
[11:00:07.349]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:07.349]                   0L) {
[11:00:07.349]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:07.349]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:07.349]                   base::options(opts)
[11:00:07.349]                 }
[11:00:07.349]                 {
[11:00:07.349]                   {
[11:00:07.349]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:07.349]                     NULL
[11:00:07.349]                   }
[11:00:07.349]                   options(future.plan = NULL)
[11:00:07.349]                   if (is.na(NA_character_)) 
[11:00:07.349]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:07.349]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:07.349]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:07.349]                     .init = FALSE)
[11:00:07.349]                 }
[11:00:07.349]             }
[11:00:07.349]         }
[11:00:07.349]     })
[11:00:07.349]     if (TRUE) {
[11:00:07.349]         base::sink(type = "output", split = FALSE)
[11:00:07.349]         if (TRUE) {
[11:00:07.349]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:07.349]         }
[11:00:07.349]         else {
[11:00:07.349]             ...future.result["stdout"] <- base::list(NULL)
[11:00:07.349]         }
[11:00:07.349]         base::close(...future.stdout)
[11:00:07.349]         ...future.stdout <- NULL
[11:00:07.349]     }
[11:00:07.349]     ...future.result$conditions <- ...future.conditions
[11:00:07.349]     ...future.result$finished <- base::Sys.time()
[11:00:07.349]     ...future.result
[11:00:07.349] }
[11:00:07.351] Exporting 11 global objects (27.06 KiB) to cluster node #1 ...
[11:00:07.352] Exporting ‘...future.FUN’ (14.07 KiB) to cluster node #1 ...
[11:00:07.393] Exporting ‘...future.FUN’ (14.07 KiB) to cluster node #1 ... DONE
[11:00:07.393] Exporting ‘x_FUN’ (4.67 KiB) to cluster node #1 ...
[11:00:07.434] Exporting ‘x_FUN’ (4.67 KiB) to cluster node #1 ... DONE
[11:00:07.434] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[11:00:07.434] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[11:00:07.434] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[11:00:07.475] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[11:00:07.476] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[11:00:07.517] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[11:00:07.517] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[11:00:07.517] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[11:00:07.517] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[11:00:07.518] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[11:00:07.518] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[11:00:07.518] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[11:00:07.518] Exporting ‘...future.elements_ii’ (369 bytes) to cluster node #1 ...
[11:00:07.519] Exporting ‘...future.elements_ii’ (369 bytes) to cluster node #1 ... DONE
[11:00:07.519] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[11:00:07.519] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[11:00:07.519] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[11:00:07.519] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[11:00:07.520] Exporting 11 global objects (27.06 KiB) to cluster node #1 ... DONE
[11:00:07.520] MultisessionFuture started
[11:00:07.520] - Launch lazy future ... done
[11:00:07.520] run() for ‘MultisessionFuture’ ... done
[11:00:07.520] Created future:
[11:00:07.520] MultisessionFuture:
[11:00:07.520] Label: ‘future_vapply-1’
[11:00:07.520] Expression:
[11:00:07.520] {
[11:00:07.520]     do.call(function(...) {
[11:00:07.520]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:07.520]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:07.520]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:07.520]             on.exit(options(oopts), add = TRUE)
[11:00:07.520]         }
[11:00:07.520]         {
[11:00:07.520]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:07.520]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:07.520]                 ...future.FUN(...future.X_jj, ...)
[11:00:07.520]             })
[11:00:07.520]         }
[11:00:07.520]     }, args = future.call.arguments)
[11:00:07.520] }
[11:00:07.520] Lazy evaluation: FALSE
[11:00:07.520] Asynchronous evaluation: TRUE
[11:00:07.520] Local evaluation: TRUE
[11:00:07.520] Environment: R_GlobalEnv
[11:00:07.520] Capture standard output: TRUE
[11:00:07.520] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:07.520] Globals: 11 objects totaling 27.22 KiB (function ‘...future.FUN’ of 14.07 KiB, function ‘x_FUN’ of 4.67 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:07.520] Packages: 2 packages (‘stats’, ‘future.apply’)
[11:00:07.520] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:07.520] Resolved: FALSE
[11:00:07.520] Value: <not collected>
[11:00:07.520] Conditions captured: <none>
[11:00:07.520] Early signaling: FALSE
[11:00:07.520] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:07.520] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:07.532] Chunk #1 of 2 ... DONE
[11:00:07.532] Chunk #2 of 2 ...
[11:00:07.532]  - Finding globals in 'X' for chunk #2 ...
[11:00:07.532] getGlobalsAndPackages() ...
[11:00:07.532] Searching for globals...
[11:00:07.533] 
[11:00:07.533] Searching for globals ... DONE
[11:00:07.533] - globals: [0] <none>
[11:00:07.533] getGlobalsAndPackages() ... DONE
[11:00:07.533]    + additional globals found: [n=0] 
[11:00:07.533]    + additional namespaces needed: [n=0] 
[11:00:07.533]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:07.533]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:07.533]  - seeds: <none>
[11:00:07.533]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:07.533] getGlobalsAndPackages() ...
[11:00:07.534] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:07.534] Resolving globals: FALSE
[11:00:07.534] Tweak future expression to call with '...' arguments ...
[11:00:07.534] {
[11:00:07.534]     do.call(function(...) {
[11:00:07.534]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:07.534]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:07.534]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:07.534]             on.exit(options(oopts), add = TRUE)
[11:00:07.534]         }
[11:00:07.534]         {
[11:00:07.534]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:07.534]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:07.534]                 ...future.FUN(...future.X_jj, ...)
[11:00:07.534]             })
[11:00:07.534]         }
[11:00:07.534]     }, args = future.call.arguments)
[11:00:07.534] }
[11:00:07.534] Tweak future expression to call with '...' arguments ... DONE
[11:00:07.535] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:07.535] - packages: [2] ‘stats’, ‘future.apply’
[11:00:07.535] getGlobalsAndPackages() ... DONE
[11:00:07.535] run() for ‘Future’ ...
[11:00:07.535] - state: ‘created’
[11:00:07.535] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:07.548] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:07.549] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:07.549]   - Field: ‘node’
[11:00:07.549]   - Field: ‘label’
[11:00:07.549]   - Field: ‘local’
[11:00:07.549]   - Field: ‘owner’
[11:00:07.549]   - Field: ‘envir’
[11:00:07.549]   - Field: ‘workers’
[11:00:07.549]   - Field: ‘packages’
[11:00:07.549]   - Field: ‘gc’
[11:00:07.549]   - Field: ‘conditions’
[11:00:07.549]   - Field: ‘persistent’
[11:00:07.550]   - Field: ‘expr’
[11:00:07.550]   - Field: ‘uuid’
[11:00:07.550]   - Field: ‘seed’
[11:00:07.550]   - Field: ‘version’
[11:00:07.550]   - Field: ‘result’
[11:00:07.550]   - Field: ‘asynchronous’
[11:00:07.550]   - Field: ‘calls’
[11:00:07.550]   - Field: ‘globals’
[11:00:07.550]   - Field: ‘stdout’
[11:00:07.550]   - Field: ‘earlySignal’
[11:00:07.550]   - Field: ‘lazy’
[11:00:07.550]   - Field: ‘state’
[11:00:07.550] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:07.551] - Launch lazy future ...
[11:00:07.551] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[11:00:07.551] Packages needed by future strategies (n = 0): <none>
[11:00:07.551] {
[11:00:07.551]     {
[11:00:07.551]         {
[11:00:07.551]             ...future.startTime <- base::Sys.time()
[11:00:07.551]             {
[11:00:07.551]                 {
[11:00:07.551]                   {
[11:00:07.551]                     {
[11:00:07.551]                       {
[11:00:07.551]                         base::local({
[11:00:07.551]                           has_future <- base::requireNamespace("future", 
[11:00:07.551]                             quietly = TRUE)
[11:00:07.551]                           if (has_future) {
[11:00:07.551]                             ns <- base::getNamespace("future")
[11:00:07.551]                             version <- ns[[".package"]][["version"]]
[11:00:07.551]                             if (is.null(version)) 
[11:00:07.551]                               version <- utils::packageVersion("future")
[11:00:07.551]                           }
[11:00:07.551]                           else {
[11:00:07.551]                             version <- NULL
[11:00:07.551]                           }
[11:00:07.551]                           if (!has_future || version < "1.8.0") {
[11:00:07.551]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:07.551]                               "", base::R.version$version.string), 
[11:00:07.551]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:07.551]                                 base::R.version$platform, 8 * 
[11:00:07.551]                                   base::.Machine$sizeof.pointer), 
[11:00:07.551]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:07.551]                                 "release", "version")], collapse = " "), 
[11:00:07.551]                               hostname = base::Sys.info()[["nodename"]])
[11:00:07.551]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:07.551]                               info)
[11:00:07.551]                             info <- base::paste(info, collapse = "; ")
[11:00:07.551]                             if (!has_future) {
[11:00:07.551]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:07.551]                                 info)
[11:00:07.551]                             }
[11:00:07.551]                             else {
[11:00:07.551]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:07.551]                                 info, version)
[11:00:07.551]                             }
[11:00:07.551]                             base::stop(msg)
[11:00:07.551]                           }
[11:00:07.551]                         })
[11:00:07.551]                       }
[11:00:07.551]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:07.551]                       base::options(mc.cores = 1L)
[11:00:07.551]                     }
[11:00:07.551]                     base::local({
[11:00:07.551]                       for (pkg in c("stats", "future.apply")) {
[11:00:07.551]                         base::loadNamespace(pkg)
[11:00:07.551]                         base::library(pkg, character.only = TRUE)
[11:00:07.551]                       }
[11:00:07.551]                     })
[11:00:07.551]                   }
[11:00:07.551]                   ...future.strategy.old <- future::plan("list")
[11:00:07.551]                   options(future.plan = NULL)
[11:00:07.551]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:07.551]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:07.551]                 }
[11:00:07.551]                 ...future.workdir <- getwd()
[11:00:07.551]             }
[11:00:07.551]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:07.551]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:07.551]         }
[11:00:07.551]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:07.551]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:07.551]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:07.551]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:07.551]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:07.551]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:07.551]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:07.551]             base::names(...future.oldOptions))
[11:00:07.551]     }
[11:00:07.551]     if (FALSE) {
[11:00:07.551]     }
[11:00:07.551]     else {
[11:00:07.551]         if (TRUE) {
[11:00:07.551]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:07.551]                 open = "w")
[11:00:07.551]         }
[11:00:07.551]         else {
[11:00:07.551]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:07.551]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:07.551]         }
[11:00:07.551]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:07.551]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:07.551]             base::sink(type = "output", split = FALSE)
[11:00:07.551]             base::close(...future.stdout)
[11:00:07.551]         }, add = TRUE)
[11:00:07.551]     }
[11:00:07.551]     ...future.frame <- base::sys.nframe()
[11:00:07.551]     ...future.conditions <- base::list()
[11:00:07.551]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:07.551]     if (FALSE) {
[11:00:07.551]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:07.551]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:07.551]     }
[11:00:07.551]     ...future.result <- base::tryCatch({
[11:00:07.551]         base::withCallingHandlers({
[11:00:07.551]             ...future.value <- base::withVisible(base::local({
[11:00:07.551]                 ...future.makeSendCondition <- base::local({
[11:00:07.551]                   sendCondition <- NULL
[11:00:07.551]                   function(frame = 1L) {
[11:00:07.551]                     if (is.function(sendCondition)) 
[11:00:07.551]                       return(sendCondition)
[11:00:07.551]                     ns <- getNamespace("parallel")
[11:00:07.551]                     if (exists("sendData", mode = "function", 
[11:00:07.551]                       envir = ns)) {
[11:00:07.551]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:07.551]                         envir = ns)
[11:00:07.551]                       envir <- sys.frame(frame)
[11:00:07.551]                       master <- NULL
[11:00:07.551]                       while (!identical(envir, .GlobalEnv) && 
[11:00:07.551]                         !identical(envir, emptyenv())) {
[11:00:07.551]                         if (exists("master", mode = "list", envir = envir, 
[11:00:07.551]                           inherits = FALSE)) {
[11:00:07.551]                           master <- get("master", mode = "list", 
[11:00:07.551]                             envir = envir, inherits = FALSE)
[11:00:07.551]                           if (inherits(master, c("SOCKnode", 
[11:00:07.551]                             "SOCK0node"))) {
[11:00:07.551]                             sendCondition <<- function(cond) {
[11:00:07.551]                               data <- list(type = "VALUE", value = cond, 
[11:00:07.551]                                 success = TRUE)
[11:00:07.551]                               parallel_sendData(master, data)
[11:00:07.551]                             }
[11:00:07.551]                             return(sendCondition)
[11:00:07.551]                           }
[11:00:07.551]                         }
[11:00:07.551]                         frame <- frame + 1L
[11:00:07.551]                         envir <- sys.frame(frame)
[11:00:07.551]                       }
[11:00:07.551]                     }
[11:00:07.551]                     sendCondition <<- function(cond) NULL
[11:00:07.551]                   }
[11:00:07.551]                 })
[11:00:07.551]                 withCallingHandlers({
[11:00:07.551]                   {
[11:00:07.551]                     do.call(function(...) {
[11:00:07.551]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:07.551]                       if (!identical(...future.globals.maxSize.org, 
[11:00:07.551]                         ...future.globals.maxSize)) {
[11:00:07.551]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:07.551]                         on.exit(options(oopts), add = TRUE)
[11:00:07.551]                       }
[11:00:07.551]                       {
[11:00:07.551]                         lapply(seq_along(...future.elements_ii), 
[11:00:07.551]                           FUN = function(jj) {
[11:00:07.551]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:07.551]                             ...future.FUN(...future.X_jj, ...)
[11:00:07.551]                           })
[11:00:07.551]                       }
[11:00:07.551]                     }, args = future.call.arguments)
[11:00:07.551]                   }
[11:00:07.551]                 }, immediateCondition = function(cond) {
[11:00:07.551]                   sendCondition <- ...future.makeSendCondition()
[11:00:07.551]                   sendCondition(cond)
[11:00:07.551]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:07.551]                   {
[11:00:07.551]                     inherits <- base::inherits
[11:00:07.551]                     invokeRestart <- base::invokeRestart
[11:00:07.551]                     is.null <- base::is.null
[11:00:07.551]                     muffled <- FALSE
[11:00:07.551]                     if (inherits(cond, "message")) {
[11:00:07.551]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:07.551]                       if (muffled) 
[11:00:07.551]                         invokeRestart("muffleMessage")
[11:00:07.551]                     }
[11:00:07.551]                     else if (inherits(cond, "warning")) {
[11:00:07.551]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:07.551]                       if (muffled) 
[11:00:07.551]                         invokeRestart("muffleWarning")
[11:00:07.551]                     }
[11:00:07.551]                     else if (inherits(cond, "condition")) {
[11:00:07.551]                       if (!is.null(pattern)) {
[11:00:07.551]                         computeRestarts <- base::computeRestarts
[11:00:07.551]                         grepl <- base::grepl
[11:00:07.551]                         restarts <- computeRestarts(cond)
[11:00:07.551]                         for (restart in restarts) {
[11:00:07.551]                           name <- restart$name
[11:00:07.551]                           if (is.null(name)) 
[11:00:07.551]                             next
[11:00:07.551]                           if (!grepl(pattern, name)) 
[11:00:07.551]                             next
[11:00:07.551]                           invokeRestart(restart)
[11:00:07.551]                           muffled <- TRUE
[11:00:07.551]                           break
[11:00:07.551]                         }
[11:00:07.551]                       }
[11:00:07.551]                     }
[11:00:07.551]                     invisible(muffled)
[11:00:07.551]                   }
[11:00:07.551]                   muffleCondition(cond)
[11:00:07.551]                 })
[11:00:07.551]             }))
[11:00:07.551]             future::FutureResult(value = ...future.value$value, 
[11:00:07.551]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:07.551]                   ...future.rng), globalenv = if (FALSE) 
[11:00:07.551]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:07.551]                     ...future.globalenv.names))
[11:00:07.551]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:07.551]         }, condition = base::local({
[11:00:07.551]             c <- base::c
[11:00:07.551]             inherits <- base::inherits
[11:00:07.551]             invokeRestart <- base::invokeRestart
[11:00:07.551]             length <- base::length
[11:00:07.551]             list <- base::list
[11:00:07.551]             seq.int <- base::seq.int
[11:00:07.551]             signalCondition <- base::signalCondition
[11:00:07.551]             sys.calls <- base::sys.calls
[11:00:07.551]             `[[` <- base::`[[`
[11:00:07.551]             `+` <- base::`+`
[11:00:07.551]             `<<-` <- base::`<<-`
[11:00:07.551]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:07.551]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:07.551]                   3L)]
[11:00:07.551]             }
[11:00:07.551]             function(cond) {
[11:00:07.551]                 is_error <- inherits(cond, "error")
[11:00:07.551]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:07.551]                   NULL)
[11:00:07.551]                 if (is_error) {
[11:00:07.551]                   sessionInformation <- function() {
[11:00:07.551]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:07.551]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:07.551]                       search = base::search(), system = base::Sys.info())
[11:00:07.551]                   }
[11:00:07.551]                   ...future.conditions[[length(...future.conditions) + 
[11:00:07.551]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:07.551]                     cond$call), session = sessionInformation(), 
[11:00:07.551]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:07.551]                   signalCondition(cond)
[11:00:07.551]                 }
[11:00:07.551]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:07.551]                 "immediateCondition"))) {
[11:00:07.551]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:07.551]                   ...future.conditions[[length(...future.conditions) + 
[11:00:07.551]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:07.551]                   if (TRUE && !signal) {
[11:00:07.551]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:07.551]                     {
[11:00:07.551]                       inherits <- base::inherits
[11:00:07.551]                       invokeRestart <- base::invokeRestart
[11:00:07.551]                       is.null <- base::is.null
[11:00:07.551]                       muffled <- FALSE
[11:00:07.551]                       if (inherits(cond, "message")) {
[11:00:07.551]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:07.551]                         if (muffled) 
[11:00:07.551]                           invokeRestart("muffleMessage")
[11:00:07.551]                       }
[11:00:07.551]                       else if (inherits(cond, "warning")) {
[11:00:07.551]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:07.551]                         if (muffled) 
[11:00:07.551]                           invokeRestart("muffleWarning")
[11:00:07.551]                       }
[11:00:07.551]                       else if (inherits(cond, "condition")) {
[11:00:07.551]                         if (!is.null(pattern)) {
[11:00:07.551]                           computeRestarts <- base::computeRestarts
[11:00:07.551]                           grepl <- base::grepl
[11:00:07.551]                           restarts <- computeRestarts(cond)
[11:00:07.551]                           for (restart in restarts) {
[11:00:07.551]                             name <- restart$name
[11:00:07.551]                             if (is.null(name)) 
[11:00:07.551]                               next
[11:00:07.551]                             if (!grepl(pattern, name)) 
[11:00:07.551]                               next
[11:00:07.551]                             invokeRestart(restart)
[11:00:07.551]                             muffled <- TRUE
[11:00:07.551]                             break
[11:00:07.551]                           }
[11:00:07.551]                         }
[11:00:07.551]                       }
[11:00:07.551]                       invisible(muffled)
[11:00:07.551]                     }
[11:00:07.551]                     muffleCondition(cond, pattern = "^muffle")
[11:00:07.551]                   }
[11:00:07.551]                 }
[11:00:07.551]                 else {
[11:00:07.551]                   if (TRUE) {
[11:00:07.551]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:07.551]                     {
[11:00:07.551]                       inherits <- base::inherits
[11:00:07.551]                       invokeRestart <- base::invokeRestart
[11:00:07.551]                       is.null <- base::is.null
[11:00:07.551]                       muffled <- FALSE
[11:00:07.551]                       if (inherits(cond, "message")) {
[11:00:07.551]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:07.551]                         if (muffled) 
[11:00:07.551]                           invokeRestart("muffleMessage")
[11:00:07.551]                       }
[11:00:07.551]                       else if (inherits(cond, "warning")) {
[11:00:07.551]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:07.551]                         if (muffled) 
[11:00:07.551]                           invokeRestart("muffleWarning")
[11:00:07.551]                       }
[11:00:07.551]                       else if (inherits(cond, "condition")) {
[11:00:07.551]                         if (!is.null(pattern)) {
[11:00:07.551]                           computeRestarts <- base::computeRestarts
[11:00:07.551]                           grepl <- base::grepl
[11:00:07.551]                           restarts <- computeRestarts(cond)
[11:00:07.551]                           for (restart in restarts) {
[11:00:07.551]                             name <- restart$name
[11:00:07.551]                             if (is.null(name)) 
[11:00:07.551]                               next
[11:00:07.551]                             if (!grepl(pattern, name)) 
[11:00:07.551]                               next
[11:00:07.551]                             invokeRestart(restart)
[11:00:07.551]                             muffled <- TRUE
[11:00:07.551]                             break
[11:00:07.551]                           }
[11:00:07.551]                         }
[11:00:07.551]                       }
[11:00:07.551]                       invisible(muffled)
[11:00:07.551]                     }
[11:00:07.551]                     muffleCondition(cond, pattern = "^muffle")
[11:00:07.551]                   }
[11:00:07.551]                 }
[11:00:07.551]             }
[11:00:07.551]         }))
[11:00:07.551]     }, error = function(ex) {
[11:00:07.551]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:07.551]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:07.551]                 ...future.rng), started = ...future.startTime, 
[11:00:07.551]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:07.551]             version = "1.8"), class = "FutureResult")
[11:00:07.551]     }, finally = {
[11:00:07.551]         if (!identical(...future.workdir, getwd())) 
[11:00:07.551]             setwd(...future.workdir)
[11:00:07.551]         {
[11:00:07.551]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:07.551]                 ...future.oldOptions$nwarnings <- NULL
[11:00:07.551]             }
[11:00:07.551]             base::options(...future.oldOptions)
[11:00:07.551]             if (.Platform$OS.type == "windows") {
[11:00:07.551]                 old_names <- names(...future.oldEnvVars)
[11:00:07.551]                 envs <- base::Sys.getenv()
[11:00:07.551]                 names <- names(envs)
[11:00:07.551]                 common <- intersect(names, old_names)
[11:00:07.551]                 added <- setdiff(names, old_names)
[11:00:07.551]                 removed <- setdiff(old_names, names)
[11:00:07.551]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:07.551]                   envs[common]]
[11:00:07.551]                 NAMES <- toupper(changed)
[11:00:07.551]                 args <- list()
[11:00:07.551]                 for (kk in seq_along(NAMES)) {
[11:00:07.551]                   name <- changed[[kk]]
[11:00:07.551]                   NAME <- NAMES[[kk]]
[11:00:07.551]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:07.551]                     next
[11:00:07.551]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:07.551]                 }
[11:00:07.551]                 NAMES <- toupper(added)
[11:00:07.551]                 for (kk in seq_along(NAMES)) {
[11:00:07.551]                   name <- added[[kk]]
[11:00:07.551]                   NAME <- NAMES[[kk]]
[11:00:07.551]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:07.551]                     next
[11:00:07.551]                   args[[name]] <- ""
[11:00:07.551]                 }
[11:00:07.551]                 NAMES <- toupper(removed)
[11:00:07.551]                 for (kk in seq_along(NAMES)) {
[11:00:07.551]                   name <- removed[[kk]]
[11:00:07.551]                   NAME <- NAMES[[kk]]
[11:00:07.551]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:07.551]                     next
[11:00:07.551]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:07.551]                 }
[11:00:07.551]                 if (length(args) > 0) 
[11:00:07.551]                   base::do.call(base::Sys.setenv, args = args)
[11:00:07.551]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:07.551]             }
[11:00:07.551]             else {
[11:00:07.551]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:07.551]             }
[11:00:07.551]             {
[11:00:07.551]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:07.551]                   0L) {
[11:00:07.551]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:07.551]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:07.551]                   base::options(opts)
[11:00:07.551]                 }
[11:00:07.551]                 {
[11:00:07.551]                   {
[11:00:07.551]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:07.551]                     NULL
[11:00:07.551]                   }
[11:00:07.551]                   options(future.plan = NULL)
[11:00:07.551]                   if (is.na(NA_character_)) 
[11:00:07.551]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:07.551]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:07.551]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:07.551]                     .init = FALSE)
[11:00:07.551]                 }
[11:00:07.551]             }
[11:00:07.551]         }
[11:00:07.551]     })
[11:00:07.551]     if (TRUE) {
[11:00:07.551]         base::sink(type = "output", split = FALSE)
[11:00:07.551]         if (TRUE) {
[11:00:07.551]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:07.551]         }
[11:00:07.551]         else {
[11:00:07.551]             ...future.result["stdout"] <- base::list(NULL)
[11:00:07.551]         }
[11:00:07.551]         base::close(...future.stdout)
[11:00:07.551]         ...future.stdout <- NULL
[11:00:07.551]     }
[11:00:07.551]     ...future.result$conditions <- ...future.conditions
[11:00:07.551]     ...future.result$finished <- base::Sys.time()
[11:00:07.551]     ...future.result
[11:00:07.551] }
[11:00:07.554] Exporting 11 global objects (26.98 KiB) to cluster node #2 ...
[11:00:07.554] Exporting ‘...future.FUN’ (14.07 KiB) to cluster node #2 ...
[11:00:07.596] Exporting ‘...future.FUN’ (14.07 KiB) to cluster node #2 ... DONE
[11:00:07.596] Exporting ‘x_FUN’ (4.67 KiB) to cluster node #2 ...
[11:00:07.637] Exporting ‘x_FUN’ (4.67 KiB) to cluster node #2 ... DONE
[11:00:07.637] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[11:00:07.637] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[11:00:07.637] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[11:00:07.678] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[11:00:07.679] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[11:00:07.720] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[11:00:07.720] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[11:00:07.720] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[11:00:07.720] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[11:00:07.721] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[11:00:07.721] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[11:00:07.721] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[11:00:07.721] Exporting ‘...future.elements_ii’ (293 bytes) to cluster node #2 ...
[11:00:07.722] Exporting ‘...future.elements_ii’ (293 bytes) to cluster node #2 ... DONE
[11:00:07.722] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[11:00:07.722] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[11:00:07.722] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[11:00:07.723] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[11:00:07.723] Exporting 11 global objects (26.98 KiB) to cluster node #2 ... DONE
[11:00:07.723] MultisessionFuture started
[11:00:07.723] - Launch lazy future ... done
[11:00:07.723] run() for ‘MultisessionFuture’ ... done
[11:00:07.724] Created future:
[11:00:07.724] MultisessionFuture:
[11:00:07.724] Label: ‘future_vapply-2’
[11:00:07.724] Expression:
[11:00:07.724] {
[11:00:07.724]     do.call(function(...) {
[11:00:07.724]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:07.724]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:07.724]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:07.724]             on.exit(options(oopts), add = TRUE)
[11:00:07.724]         }
[11:00:07.724]         {
[11:00:07.724]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:07.724]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:07.724]                 ...future.FUN(...future.X_jj, ...)
[11:00:07.724]             })
[11:00:07.724]         }
[11:00:07.724]     }, args = future.call.arguments)
[11:00:07.724] }
[11:00:07.724] Lazy evaluation: FALSE
[11:00:07.724] Asynchronous evaluation: TRUE
[11:00:07.724] Local evaluation: TRUE
[11:00:07.724] Environment: R_GlobalEnv
[11:00:07.724] Capture standard output: TRUE
[11:00:07.724] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:07.724] Globals: 11 objects totaling 27.14 KiB (function ‘...future.FUN’ of 14.07 KiB, function ‘x_FUN’ of 4.67 KiB, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:07.724] Packages: 2 packages (‘stats’, ‘future.apply’)
[11:00:07.724] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:07.724] Resolved: FALSE
[11:00:07.724] Value: <not collected>
[11:00:07.724] Conditions captured: <none>
[11:00:07.724] Early signaling: FALSE
[11:00:07.724] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:07.724] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:07.735] Chunk #2 of 2 ... DONE
[11:00:07.735] Launching 2 futures (chunks) ... DONE
[11:00:07.735] Resolving 2 futures (chunks) ...
[11:00:07.735] resolve() on list ...
[11:00:07.736]  recursive: 0
[11:00:07.736]  length: 2
[11:00:07.736] 
[11:00:07.736] receiveMessageFromWorker() for ClusterFuture ...
[11:00:07.736] - Validating connection of MultisessionFuture
[11:00:07.736] - received message: FutureResult
[11:00:07.737] - Received FutureResult
[11:00:07.737] - Erased future from FutureRegistry
[11:00:07.737] result() for ClusterFuture ...
[11:00:07.737] - result already collected: FutureResult
[11:00:07.737] result() for ClusterFuture ... done
[11:00:07.737] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:07.737] Future #1
[11:00:07.737] result() for ClusterFuture ...
[11:00:07.737] - result already collected: FutureResult
[11:00:07.737] result() for ClusterFuture ... done
[11:00:07.737] result() for ClusterFuture ...
[11:00:07.737] - result already collected: FutureResult
[11:00:07.737] result() for ClusterFuture ... done
[11:00:07.738] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:00:07.738] - nx: 2
[11:00:07.738] - relay: TRUE
[11:00:07.738] - stdout: TRUE
[11:00:07.738] - signal: TRUE
[11:00:07.738] - resignal: FALSE
[11:00:07.738] - force: TRUE
[11:00:07.738] - relayed: [n=2] FALSE, FALSE
[11:00:07.738] - queued futures: [n=2] FALSE, FALSE
[11:00:07.738]  - until=1
[11:00:07.738]  - relaying element #1
[11:00:07.738] result() for ClusterFuture ...
[11:00:07.739] - result already collected: FutureResult
[11:00:07.739] result() for ClusterFuture ... done
[11:00:07.739] result() for ClusterFuture ...
[11:00:07.739] - result already collected: FutureResult
[11:00:07.739] result() for ClusterFuture ... done
[11:00:07.739] result() for ClusterFuture ...
[11:00:07.739] - result already collected: FutureResult
[11:00:07.739] result() for ClusterFuture ... done
[11:00:07.739] result() for ClusterFuture ...
[11:00:07.739] - result already collected: FutureResult
[11:00:07.739] result() for ClusterFuture ... done
[11:00:07.739] - relayed: [n=2] TRUE, FALSE
[11:00:07.739] - queued futures: [n=2] TRUE, FALSE
[11:00:07.740] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:00:07.740]  length: 1 (resolved future 1)
[11:00:07.766] receiveMessageFromWorker() for ClusterFuture ...
[11:00:07.766] - Validating connection of MultisessionFuture
[11:00:07.766] - received message: FutureResult
[11:00:07.766] - Received FutureResult
[11:00:07.766] - Erased future from FutureRegistry
[11:00:07.766] result() for ClusterFuture ...
[11:00:07.766] - result already collected: FutureResult
[11:00:07.766] result() for ClusterFuture ... done
[11:00:07.766] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:07.766] Future #2
[11:00:07.767] result() for ClusterFuture ...
[11:00:07.767] - result already collected: FutureResult
[11:00:07.767] result() for ClusterFuture ... done
[11:00:07.767] result() for ClusterFuture ...
[11:00:07.767] - result already collected: FutureResult
[11:00:07.767] result() for ClusterFuture ... done
[11:00:07.767] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:00:07.767] - nx: 2
[11:00:07.767] - relay: TRUE
[11:00:07.767] - stdout: TRUE
[11:00:07.767] - signal: TRUE
[11:00:07.767] - resignal: FALSE
[11:00:07.767] - force: TRUE
[11:00:07.768] - relayed: [n=2] TRUE, FALSE
[11:00:07.768] - queued futures: [n=2] TRUE, FALSE
[11:00:07.768]  - until=2
[11:00:07.768]  - relaying element #2
[11:00:07.768] result() for ClusterFuture ...
[11:00:07.768] - result already collected: FutureResult
[11:00:07.768] result() for ClusterFuture ... done
[11:00:07.768] result() for ClusterFuture ...
[11:00:07.768] - result already collected: FutureResult
[11:00:07.768] result() for ClusterFuture ... done
[11:00:07.768] result() for ClusterFuture ...
[11:00:07.768] - result already collected: FutureResult
[11:00:07.769] result() for ClusterFuture ... done
[11:00:07.769] result() for ClusterFuture ...
[11:00:07.769] - result already collected: FutureResult
[11:00:07.769] result() for ClusterFuture ... done
[11:00:07.769] - relayed: [n=2] TRUE, TRUE
[11:00:07.769] - queued futures: [n=2] TRUE, TRUE
[11:00:07.769] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:00:07.769]  length: 0 (resolved future 2)
[11:00:07.769] Relaying remaining futures
[11:00:07.769] signalConditionsASAP(NULL, pos=0) ...
[11:00:07.769] - nx: 2
[11:00:07.769] - relay: TRUE
[11:00:07.769] - stdout: TRUE
[11:00:07.770] - signal: TRUE
[11:00:07.770] - resignal: FALSE
[11:00:07.770] - force: TRUE
[11:00:07.770] - relayed: [n=2] TRUE, TRUE
[11:00:07.770] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:07.770] - relayed: [n=2] TRUE, TRUE
[11:00:07.770] - queued futures: [n=2] TRUE, TRUE
[11:00:07.770] signalConditionsASAP(NULL, pos=0) ... done
[11:00:07.770] resolve() on list ... DONE
[11:00:07.770] result() for ClusterFuture ...
[11:00:07.770] - result already collected: FutureResult
[11:00:07.770] result() for ClusterFuture ... done
[11:00:07.770] result() for ClusterFuture ...
[11:00:07.771] - result already collected: FutureResult
[11:00:07.771] result() for ClusterFuture ... done
[11:00:07.771] result() for ClusterFuture ...
[11:00:07.771] - result already collected: FutureResult
[11:00:07.771] result() for ClusterFuture ... done
[11:00:07.771] result() for ClusterFuture ...
[11:00:07.771] - result already collected: FutureResult
[11:00:07.771] result() for ClusterFuture ... done
[11:00:07.771]  - Number of value chunks collected: 2
[11:00:07.771] Resolving 2 futures (chunks) ... DONE
[11:00:07.771] Reducing values from 2 chunks ...
[11:00:07.771]  - Number of values collected after concatenation: 7
[11:00:07.771]  - Number of values expected: 7
[11:00:07.772] Reducing values from 2 chunks ... DONE
[11:00:07.772] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[11:00:07.773] future_lapply() ...
[11:00:07.775] Number of chunks: 2
[11:00:07.775] getGlobalsAndPackagesXApply() ...
[11:00:07.775]  - future.globals: TRUE
[11:00:07.775] getGlobalsAndPackages() ...
[11:00:07.775] Searching for globals...
[11:00:07.777] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[11:00:07.777] Searching for globals ... DONE
[11:00:07.777] Resolving globals: FALSE
[11:00:07.777] The total size of the 1 globals is 680 bytes (680 bytes)
[11:00:07.777] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 680 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (680 bytes of class ‘function’)
[11:00:07.778] - globals: [1] ‘FUN’
[11:00:07.778] 
[11:00:07.778] getGlobalsAndPackages() ... DONE
[11:00:07.778]  - globals found/used: [n=1] ‘FUN’
[11:00:07.778]  - needed namespaces: [n=0] 
[11:00:07.778] Finding globals ... DONE
[11:00:07.778]  - use_args: TRUE
[11:00:07.778]  - Getting '...' globals ...
[11:00:07.778] resolve() on list ...
[11:00:07.778]  recursive: 0
[11:00:07.779]  length: 1
[11:00:07.779]  elements: ‘...’
[11:00:07.779]  length: 0 (resolved future 1)
[11:00:07.779] resolve() on list ... DONE
[11:00:07.779]    - '...' content: [n=1] ‘y’
[11:00:07.779] List of 1
[11:00:07.779]  $ ...:List of 1
[11:00:07.779]   ..$ y: num [1:5] 2 4 6 8 10
[11:00:07.779]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:07.779]  - attr(*, "where")=List of 1
[11:00:07.779]   ..$ ...:<environment: 0x55bbaf0c0928> 
[11:00:07.779]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:07.779]  - attr(*, "resolved")= logi TRUE
[11:00:07.779]  - attr(*, "total_size")= num NA
[11:00:07.782]  - Getting '...' globals ... DONE
[11:00:07.782] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[11:00:07.782] List of 2
[11:00:07.782]  $ ...future.FUN:function (x, y)  
[11:00:07.782]  $ ...          :List of 1
[11:00:07.782]   ..$ y: num [1:5] 2 4 6 8 10
[11:00:07.782]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:07.782]  - attr(*, "where")=List of 2
[11:00:07.782]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:07.782]   ..$ ...          :<environment: 0x55bbaf0c0928> 
[11:00:07.782]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:07.782]  - attr(*, "resolved")= logi FALSE
[11:00:07.782]  - attr(*, "total_size")= num 7318
[11:00:07.785] Packages to be attached in all futures: [n=0] 
[11:00:07.785] getGlobalsAndPackagesXApply() ... DONE
[11:00:07.785] Number of futures (= number of chunks): 2
[11:00:07.785] Launching 2 futures (chunks) ...
[11:00:07.785] Chunk #1 of 2 ...
[11:00:07.785]  - Finding globals in 'X' for chunk #1 ...
[11:00:07.785] getGlobalsAndPackages() ...
[11:00:07.785] Searching for globals...
[11:00:07.786] 
[11:00:07.786] Searching for globals ... DONE
[11:00:07.786] - globals: [0] <none>
[11:00:07.786] getGlobalsAndPackages() ... DONE
[11:00:07.786]    + additional globals found: [n=0] 
[11:00:07.786]    + additional namespaces needed: [n=0] 
[11:00:07.786]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:07.786]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:07.786]  - seeds: <none>
[11:00:07.786]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:07.786] getGlobalsAndPackages() ...
[11:00:07.787] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:07.787] Resolving globals: FALSE
[11:00:07.787] Tweak future expression to call with '...' arguments ...
[11:00:07.787] {
[11:00:07.787]     do.call(function(...) {
[11:00:07.787]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:07.787]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:07.787]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:07.787]             on.exit(options(oopts), add = TRUE)
[11:00:07.787]         }
[11:00:07.787]         {
[11:00:07.787]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:07.787]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:07.787]                 ...future.FUN(...future.X_jj, ...)
[11:00:07.787]             })
[11:00:07.787]         }
[11:00:07.787]     }, args = future.call.arguments)
[11:00:07.787] }
[11:00:07.787] Tweak future expression to call with '...' arguments ... DONE
[11:00:07.787] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:07.788] 
[11:00:07.788] getGlobalsAndPackages() ... DONE
[11:00:07.788] run() for ‘Future’ ...
[11:00:07.788] - state: ‘created’
[11:00:07.788] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:07.803] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:07.803] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:07.803]   - Field: ‘node’
[11:00:07.803]   - Field: ‘label’
[11:00:07.803]   - Field: ‘local’
[11:00:07.803]   - Field: ‘owner’
[11:00:07.803]   - Field: ‘envir’
[11:00:07.803]   - Field: ‘workers’
[11:00:07.803]   - Field: ‘packages’
[11:00:07.804]   - Field: ‘gc’
[11:00:07.804]   - Field: ‘conditions’
[11:00:07.804]   - Field: ‘persistent’
[11:00:07.804]   - Field: ‘expr’
[11:00:07.804]   - Field: ‘uuid’
[11:00:07.804]   - Field: ‘seed’
[11:00:07.804]   - Field: ‘version’
[11:00:07.804]   - Field: ‘result’
[11:00:07.804]   - Field: ‘asynchronous’
[11:00:07.804]   - Field: ‘calls’
[11:00:07.804]   - Field: ‘globals’
[11:00:07.804]   - Field: ‘stdout’
[11:00:07.805]   - Field: ‘earlySignal’
[11:00:07.805]   - Field: ‘lazy’
[11:00:07.805]   - Field: ‘state’
[11:00:07.805] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:07.805] - Launch lazy future ...
[11:00:07.805] Packages needed by the future expression (n = 0): <none>
[11:00:07.805] Packages needed by future strategies (n = 0): <none>
[11:00:07.806] {
[11:00:07.806]     {
[11:00:07.806]         {
[11:00:07.806]             ...future.startTime <- base::Sys.time()
[11:00:07.806]             {
[11:00:07.806]                 {
[11:00:07.806]                   {
[11:00:07.806]                     {
[11:00:07.806]                       base::local({
[11:00:07.806]                         has_future <- base::requireNamespace("future", 
[11:00:07.806]                           quietly = TRUE)
[11:00:07.806]                         if (has_future) {
[11:00:07.806]                           ns <- base::getNamespace("future")
[11:00:07.806]                           version <- ns[[".package"]][["version"]]
[11:00:07.806]                           if (is.null(version)) 
[11:00:07.806]                             version <- utils::packageVersion("future")
[11:00:07.806]                         }
[11:00:07.806]                         else {
[11:00:07.806]                           version <- NULL
[11:00:07.806]                         }
[11:00:07.806]                         if (!has_future || version < "1.8.0") {
[11:00:07.806]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:07.806]                             "", base::R.version$version.string), 
[11:00:07.806]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:07.806]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:07.806]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:07.806]                               "release", "version")], collapse = " "), 
[11:00:07.806]                             hostname = base::Sys.info()[["nodename"]])
[11:00:07.806]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:07.806]                             info)
[11:00:07.806]                           info <- base::paste(info, collapse = "; ")
[11:00:07.806]                           if (!has_future) {
[11:00:07.806]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:07.806]                               info)
[11:00:07.806]                           }
[11:00:07.806]                           else {
[11:00:07.806]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:07.806]                               info, version)
[11:00:07.806]                           }
[11:00:07.806]                           base::stop(msg)
[11:00:07.806]                         }
[11:00:07.806]                       })
[11:00:07.806]                     }
[11:00:07.806]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:07.806]                     base::options(mc.cores = 1L)
[11:00:07.806]                   }
[11:00:07.806]                   ...future.strategy.old <- future::plan("list")
[11:00:07.806]                   options(future.plan = NULL)
[11:00:07.806]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:07.806]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:07.806]                 }
[11:00:07.806]                 ...future.workdir <- getwd()
[11:00:07.806]             }
[11:00:07.806]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:07.806]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:07.806]         }
[11:00:07.806]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:07.806]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:07.806]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:07.806]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:07.806]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:07.806]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:07.806]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:07.806]             base::names(...future.oldOptions))
[11:00:07.806]     }
[11:00:07.806]     if (FALSE) {
[11:00:07.806]     }
[11:00:07.806]     else {
[11:00:07.806]         if (TRUE) {
[11:00:07.806]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:07.806]                 open = "w")
[11:00:07.806]         }
[11:00:07.806]         else {
[11:00:07.806]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:07.806]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:07.806]         }
[11:00:07.806]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:07.806]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:07.806]             base::sink(type = "output", split = FALSE)
[11:00:07.806]             base::close(...future.stdout)
[11:00:07.806]         }, add = TRUE)
[11:00:07.806]     }
[11:00:07.806]     ...future.frame <- base::sys.nframe()
[11:00:07.806]     ...future.conditions <- base::list()
[11:00:07.806]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:07.806]     if (FALSE) {
[11:00:07.806]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:07.806]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:07.806]     }
[11:00:07.806]     ...future.result <- base::tryCatch({
[11:00:07.806]         base::withCallingHandlers({
[11:00:07.806]             ...future.value <- base::withVisible(base::local({
[11:00:07.806]                 ...future.makeSendCondition <- base::local({
[11:00:07.806]                   sendCondition <- NULL
[11:00:07.806]                   function(frame = 1L) {
[11:00:07.806]                     if (is.function(sendCondition)) 
[11:00:07.806]                       return(sendCondition)
[11:00:07.806]                     ns <- getNamespace("parallel")
[11:00:07.806]                     if (exists("sendData", mode = "function", 
[11:00:07.806]                       envir = ns)) {
[11:00:07.806]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:07.806]                         envir = ns)
[11:00:07.806]                       envir <- sys.frame(frame)
[11:00:07.806]                       master <- NULL
[11:00:07.806]                       while (!identical(envir, .GlobalEnv) && 
[11:00:07.806]                         !identical(envir, emptyenv())) {
[11:00:07.806]                         if (exists("master", mode = "list", envir = envir, 
[11:00:07.806]                           inherits = FALSE)) {
[11:00:07.806]                           master <- get("master", mode = "list", 
[11:00:07.806]                             envir = envir, inherits = FALSE)
[11:00:07.806]                           if (inherits(master, c("SOCKnode", 
[11:00:07.806]                             "SOCK0node"))) {
[11:00:07.806]                             sendCondition <<- function(cond) {
[11:00:07.806]                               data <- list(type = "VALUE", value = cond, 
[11:00:07.806]                                 success = TRUE)
[11:00:07.806]                               parallel_sendData(master, data)
[11:00:07.806]                             }
[11:00:07.806]                             return(sendCondition)
[11:00:07.806]                           }
[11:00:07.806]                         }
[11:00:07.806]                         frame <- frame + 1L
[11:00:07.806]                         envir <- sys.frame(frame)
[11:00:07.806]                       }
[11:00:07.806]                     }
[11:00:07.806]                     sendCondition <<- function(cond) NULL
[11:00:07.806]                   }
[11:00:07.806]                 })
[11:00:07.806]                 withCallingHandlers({
[11:00:07.806]                   {
[11:00:07.806]                     do.call(function(...) {
[11:00:07.806]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:07.806]                       if (!identical(...future.globals.maxSize.org, 
[11:00:07.806]                         ...future.globals.maxSize)) {
[11:00:07.806]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:07.806]                         on.exit(options(oopts), add = TRUE)
[11:00:07.806]                       }
[11:00:07.806]                       {
[11:00:07.806]                         lapply(seq_along(...future.elements_ii), 
[11:00:07.806]                           FUN = function(jj) {
[11:00:07.806]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:07.806]                             ...future.FUN(...future.X_jj, ...)
[11:00:07.806]                           })
[11:00:07.806]                       }
[11:00:07.806]                     }, args = future.call.arguments)
[11:00:07.806]                   }
[11:00:07.806]                 }, immediateCondition = function(cond) {
[11:00:07.806]                   sendCondition <- ...future.makeSendCondition()
[11:00:07.806]                   sendCondition(cond)
[11:00:07.806]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:07.806]                   {
[11:00:07.806]                     inherits <- base::inherits
[11:00:07.806]                     invokeRestart <- base::invokeRestart
[11:00:07.806]                     is.null <- base::is.null
[11:00:07.806]                     muffled <- FALSE
[11:00:07.806]                     if (inherits(cond, "message")) {
[11:00:07.806]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:07.806]                       if (muffled) 
[11:00:07.806]                         invokeRestart("muffleMessage")
[11:00:07.806]                     }
[11:00:07.806]                     else if (inherits(cond, "warning")) {
[11:00:07.806]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:07.806]                       if (muffled) 
[11:00:07.806]                         invokeRestart("muffleWarning")
[11:00:07.806]                     }
[11:00:07.806]                     else if (inherits(cond, "condition")) {
[11:00:07.806]                       if (!is.null(pattern)) {
[11:00:07.806]                         computeRestarts <- base::computeRestarts
[11:00:07.806]                         grepl <- base::grepl
[11:00:07.806]                         restarts <- computeRestarts(cond)
[11:00:07.806]                         for (restart in restarts) {
[11:00:07.806]                           name <- restart$name
[11:00:07.806]                           if (is.null(name)) 
[11:00:07.806]                             next
[11:00:07.806]                           if (!grepl(pattern, name)) 
[11:00:07.806]                             next
[11:00:07.806]                           invokeRestart(restart)
[11:00:07.806]                           muffled <- TRUE
[11:00:07.806]                           break
[11:00:07.806]                         }
[11:00:07.806]                       }
[11:00:07.806]                     }
[11:00:07.806]                     invisible(muffled)
[11:00:07.806]                   }
[11:00:07.806]                   muffleCondition(cond)
[11:00:07.806]                 })
[11:00:07.806]             }))
[11:00:07.806]             future::FutureResult(value = ...future.value$value, 
[11:00:07.806]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:07.806]                   ...future.rng), globalenv = if (FALSE) 
[11:00:07.806]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:07.806]                     ...future.globalenv.names))
[11:00:07.806]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:07.806]         }, condition = base::local({
[11:00:07.806]             c <- base::c
[11:00:07.806]             inherits <- base::inherits
[11:00:07.806]             invokeRestart <- base::invokeRestart
[11:00:07.806]             length <- base::length
[11:00:07.806]             list <- base::list
[11:00:07.806]             seq.int <- base::seq.int
[11:00:07.806]             signalCondition <- base::signalCondition
[11:00:07.806]             sys.calls <- base::sys.calls
[11:00:07.806]             `[[` <- base::`[[`
[11:00:07.806]             `+` <- base::`+`
[11:00:07.806]             `<<-` <- base::`<<-`
[11:00:07.806]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:07.806]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:07.806]                   3L)]
[11:00:07.806]             }
[11:00:07.806]             function(cond) {
[11:00:07.806]                 is_error <- inherits(cond, "error")
[11:00:07.806]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:07.806]                   NULL)
[11:00:07.806]                 if (is_error) {
[11:00:07.806]                   sessionInformation <- function() {
[11:00:07.806]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:07.806]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:07.806]                       search = base::search(), system = base::Sys.info())
[11:00:07.806]                   }
[11:00:07.806]                   ...future.conditions[[length(...future.conditions) + 
[11:00:07.806]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:07.806]                     cond$call), session = sessionInformation(), 
[11:00:07.806]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:07.806]                   signalCondition(cond)
[11:00:07.806]                 }
[11:00:07.806]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:07.806]                 "immediateCondition"))) {
[11:00:07.806]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:07.806]                   ...future.conditions[[length(...future.conditions) + 
[11:00:07.806]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:07.806]                   if (TRUE && !signal) {
[11:00:07.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:07.806]                     {
[11:00:07.806]                       inherits <- base::inherits
[11:00:07.806]                       invokeRestart <- base::invokeRestart
[11:00:07.806]                       is.null <- base::is.null
[11:00:07.806]                       muffled <- FALSE
[11:00:07.806]                       if (inherits(cond, "message")) {
[11:00:07.806]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:07.806]                         if (muffled) 
[11:00:07.806]                           invokeRestart("muffleMessage")
[11:00:07.806]                       }
[11:00:07.806]                       else if (inherits(cond, "warning")) {
[11:00:07.806]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:07.806]                         if (muffled) 
[11:00:07.806]                           invokeRestart("muffleWarning")
[11:00:07.806]                       }
[11:00:07.806]                       else if (inherits(cond, "condition")) {
[11:00:07.806]                         if (!is.null(pattern)) {
[11:00:07.806]                           computeRestarts <- base::computeRestarts
[11:00:07.806]                           grepl <- base::grepl
[11:00:07.806]                           restarts <- computeRestarts(cond)
[11:00:07.806]                           for (restart in restarts) {
[11:00:07.806]                             name <- restart$name
[11:00:07.806]                             if (is.null(name)) 
[11:00:07.806]                               next
[11:00:07.806]                             if (!grepl(pattern, name)) 
[11:00:07.806]                               next
[11:00:07.806]                             invokeRestart(restart)
[11:00:07.806]                             muffled <- TRUE
[11:00:07.806]                             break
[11:00:07.806]                           }
[11:00:07.806]                         }
[11:00:07.806]                       }
[11:00:07.806]                       invisible(muffled)
[11:00:07.806]                     }
[11:00:07.806]                     muffleCondition(cond, pattern = "^muffle")
[11:00:07.806]                   }
[11:00:07.806]                 }
[11:00:07.806]                 else {
[11:00:07.806]                   if (TRUE) {
[11:00:07.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:07.806]                     {
[11:00:07.806]                       inherits <- base::inherits
[11:00:07.806]                       invokeRestart <- base::invokeRestart
[11:00:07.806]                       is.null <- base::is.null
[11:00:07.806]                       muffled <- FALSE
[11:00:07.806]                       if (inherits(cond, "message")) {
[11:00:07.806]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:07.806]                         if (muffled) 
[11:00:07.806]                           invokeRestart("muffleMessage")
[11:00:07.806]                       }
[11:00:07.806]                       else if (inherits(cond, "warning")) {
[11:00:07.806]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:07.806]                         if (muffled) 
[11:00:07.806]                           invokeRestart("muffleWarning")
[11:00:07.806]                       }
[11:00:07.806]                       else if (inherits(cond, "condition")) {
[11:00:07.806]                         if (!is.null(pattern)) {
[11:00:07.806]                           computeRestarts <- base::computeRestarts
[11:00:07.806]                           grepl <- base::grepl
[11:00:07.806]                           restarts <- computeRestarts(cond)
[11:00:07.806]                           for (restart in restarts) {
[11:00:07.806]                             name <- restart$name
[11:00:07.806]                             if (is.null(name)) 
[11:00:07.806]                               next
[11:00:07.806]                             if (!grepl(pattern, name)) 
[11:00:07.806]                               next
[11:00:07.806]                             invokeRestart(restart)
[11:00:07.806]                             muffled <- TRUE
[11:00:07.806]                             break
[11:00:07.806]                           }
[11:00:07.806]                         }
[11:00:07.806]                       }
[11:00:07.806]                       invisible(muffled)
[11:00:07.806]                     }
[11:00:07.806]                     muffleCondition(cond, pattern = "^muffle")
[11:00:07.806]                   }
[11:00:07.806]                 }
[11:00:07.806]             }
[11:00:07.806]         }))
[11:00:07.806]     }, error = function(ex) {
[11:00:07.806]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:07.806]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:07.806]                 ...future.rng), started = ...future.startTime, 
[11:00:07.806]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:07.806]             version = "1.8"), class = "FutureResult")
[11:00:07.806]     }, finally = {
[11:00:07.806]         if (!identical(...future.workdir, getwd())) 
[11:00:07.806]             setwd(...future.workdir)
[11:00:07.806]         {
[11:00:07.806]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:07.806]                 ...future.oldOptions$nwarnings <- NULL
[11:00:07.806]             }
[11:00:07.806]             base::options(...future.oldOptions)
[11:00:07.806]             if (.Platform$OS.type == "windows") {
[11:00:07.806]                 old_names <- names(...future.oldEnvVars)
[11:00:07.806]                 envs <- base::Sys.getenv()
[11:00:07.806]                 names <- names(envs)
[11:00:07.806]                 common <- intersect(names, old_names)
[11:00:07.806]                 added <- setdiff(names, old_names)
[11:00:07.806]                 removed <- setdiff(old_names, names)
[11:00:07.806]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:07.806]                   envs[common]]
[11:00:07.806]                 NAMES <- toupper(changed)
[11:00:07.806]                 args <- list()
[11:00:07.806]                 for (kk in seq_along(NAMES)) {
[11:00:07.806]                   name <- changed[[kk]]
[11:00:07.806]                   NAME <- NAMES[[kk]]
[11:00:07.806]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:07.806]                     next
[11:00:07.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:07.806]                 }
[11:00:07.806]                 NAMES <- toupper(added)
[11:00:07.806]                 for (kk in seq_along(NAMES)) {
[11:00:07.806]                   name <- added[[kk]]
[11:00:07.806]                   NAME <- NAMES[[kk]]
[11:00:07.806]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:07.806]                     next
[11:00:07.806]                   args[[name]] <- ""
[11:00:07.806]                 }
[11:00:07.806]                 NAMES <- toupper(removed)
[11:00:07.806]                 for (kk in seq_along(NAMES)) {
[11:00:07.806]                   name <- removed[[kk]]
[11:00:07.806]                   NAME <- NAMES[[kk]]
[11:00:07.806]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:07.806]                     next
[11:00:07.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:07.806]                 }
[11:00:07.806]                 if (length(args) > 0) 
[11:00:07.806]                   base::do.call(base::Sys.setenv, args = args)
[11:00:07.806]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:07.806]             }
[11:00:07.806]             else {
[11:00:07.806]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:07.806]             }
[11:00:07.806]             {
[11:00:07.806]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:07.806]                   0L) {
[11:00:07.806]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:07.806]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:07.806]                   base::options(opts)
[11:00:07.806]                 }
[11:00:07.806]                 {
[11:00:07.806]                   {
[11:00:07.806]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:07.806]                     NULL
[11:00:07.806]                   }
[11:00:07.806]                   options(future.plan = NULL)
[11:00:07.806]                   if (is.na(NA_character_)) 
[11:00:07.806]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:07.806]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:07.806]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:07.806]                     .init = FALSE)
[11:00:07.806]                 }
[11:00:07.806]             }
[11:00:07.806]         }
[11:00:07.806]     })
[11:00:07.806]     if (TRUE) {
[11:00:07.806]         base::sink(type = "output", split = FALSE)
[11:00:07.806]         if (TRUE) {
[11:00:07.806]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:07.806]         }
[11:00:07.806]         else {
[11:00:07.806]             ...future.result["stdout"] <- base::list(NULL)
[11:00:07.806]         }
[11:00:07.806]         base::close(...future.stdout)
[11:00:07.806]         ...future.stdout <- NULL
[11:00:07.806]     }
[11:00:07.806]     ...future.result$conditions <- ...future.conditions
[11:00:07.806]     ...future.result$finished <- base::Sys.time()
[11:00:07.806]     ...future.result
[11:00:07.806] }
[11:00:07.808] Exporting 5 global objects (1.43 KiB) to cluster node #1 ...
[11:00:07.808] Exporting ‘...future.FUN’ (680 bytes) to cluster node #1 ...
[11:00:07.809] Exporting ‘...future.FUN’ (680 bytes) to cluster node #1 ... DONE
[11:00:07.809] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #1 ...
[11:00:07.809] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #1 ... DONE
[11:00:07.809] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #1 ...
[11:00:07.810] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #1 ... DONE
[11:00:07.810] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[11:00:07.810] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[11:00:07.810] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[11:00:07.810] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[11:00:07.810] Exporting 5 global objects (1.43 KiB) to cluster node #1 ... DONE
[11:00:07.811] MultisessionFuture started
[11:00:07.811] - Launch lazy future ... done
[11:00:07.811] run() for ‘MultisessionFuture’ ... done
[11:00:07.811] Created future:
[11:00:07.811] MultisessionFuture:
[11:00:07.811] Label: ‘future_sapply-1’
[11:00:07.811] Expression:
[11:00:07.811] {
[11:00:07.811]     do.call(function(...) {
[11:00:07.811]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:07.811]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:07.811]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:07.811]             on.exit(options(oopts), add = TRUE)
[11:00:07.811]         }
[11:00:07.811]         {
[11:00:07.811]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:07.811]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:07.811]                 ...future.FUN(...future.X_jj, ...)
[11:00:07.811]             })
[11:00:07.811]         }
[11:00:07.811]     }, args = future.call.arguments)
[11:00:07.811] }
[11:00:07.811] Lazy evaluation: FALSE
[11:00:07.811] Asynchronous evaluation: TRUE
[11:00:07.811] Local evaluation: TRUE
[11:00:07.811] Environment: R_GlobalEnv
[11:00:07.811] Capture standard output: TRUE
[11:00:07.811] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:07.811] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 680 bytes, DotDotDotList ‘future.call.arguments’ of 183 bytes, list ‘...future.elements_ii’ of 114 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:07.811] Packages: <none>
[11:00:07.811] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:07.811] Resolved: FALSE
[11:00:07.811] Value: <not collected>
[11:00:07.811] Conditions captured: <none>
[11:00:07.811] Early signaling: FALSE
[11:00:07.811] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:07.811] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:07.823] Chunk #1 of 2 ... DONE
[11:00:07.823] Chunk #2 of 2 ...
[11:00:07.823]  - Finding globals in 'X' for chunk #2 ...
[11:00:07.823] getGlobalsAndPackages() ...
[11:00:07.823] Searching for globals...
[11:00:07.823] 
[11:00:07.823] Searching for globals ... DONE
[11:00:07.823] - globals: [0] <none>
[11:00:07.823] getGlobalsAndPackages() ... DONE
[11:00:07.823]    + additional globals found: [n=0] 
[11:00:07.824]    + additional namespaces needed: [n=0] 
[11:00:07.824]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:07.824]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:07.824]  - seeds: <none>
[11:00:07.824]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:07.824] getGlobalsAndPackages() ...
[11:00:07.824] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:07.824] Resolving globals: FALSE
[11:00:07.824] Tweak future expression to call with '...' arguments ...
[11:00:07.824] {
[11:00:07.824]     do.call(function(...) {
[11:00:07.824]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:07.824]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:07.824]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:07.824]             on.exit(options(oopts), add = TRUE)
[11:00:07.824]         }
[11:00:07.824]         {
[11:00:07.824]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:07.824]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:07.824]                 ...future.FUN(...future.X_jj, ...)
[11:00:07.824]             })
[11:00:07.824]         }
[11:00:07.824]     }, args = future.call.arguments)
[11:00:07.824] }
[11:00:07.825] Tweak future expression to call with '...' arguments ... DONE
[11:00:07.825] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:07.825] 
[11:00:07.825] getGlobalsAndPackages() ... DONE
[11:00:07.825] run() for ‘Future’ ...
[11:00:07.825] - state: ‘created’
[11:00:07.826] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:07.840] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:07.840] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:07.840]   - Field: ‘node’
[11:00:07.840]   - Field: ‘label’
[11:00:07.840]   - Field: ‘local’
[11:00:07.840]   - Field: ‘owner’
[11:00:07.840]   - Field: ‘envir’
[11:00:07.840]   - Field: ‘workers’
[11:00:07.840]   - Field: ‘packages’
[11:00:07.840]   - Field: ‘gc’
[11:00:07.841]   - Field: ‘conditions’
[11:00:07.841]   - Field: ‘persistent’
[11:00:07.841]   - Field: ‘expr’
[11:00:07.841]   - Field: ‘uuid’
[11:00:07.841]   - Field: ‘seed’
[11:00:07.841]   - Field: ‘version’
[11:00:07.841]   - Field: ‘result’
[11:00:07.841]   - Field: ‘asynchronous’
[11:00:07.841]   - Field: ‘calls’
[11:00:07.841]   - Field: ‘globals’
[11:00:07.841]   - Field: ‘stdout’
[11:00:07.841]   - Field: ‘earlySignal’
[11:00:07.842]   - Field: ‘lazy’
[11:00:07.842]   - Field: ‘state’
[11:00:07.842] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:07.842] - Launch lazy future ...
[11:00:07.842] Packages needed by the future expression (n = 0): <none>
[11:00:07.842] Packages needed by future strategies (n = 0): <none>
[11:00:07.843] {
[11:00:07.843]     {
[11:00:07.843]         {
[11:00:07.843]             ...future.startTime <- base::Sys.time()
[11:00:07.843]             {
[11:00:07.843]                 {
[11:00:07.843]                   {
[11:00:07.843]                     {
[11:00:07.843]                       base::local({
[11:00:07.843]                         has_future <- base::requireNamespace("future", 
[11:00:07.843]                           quietly = TRUE)
[11:00:07.843]                         if (has_future) {
[11:00:07.843]                           ns <- base::getNamespace("future")
[11:00:07.843]                           version <- ns[[".package"]][["version"]]
[11:00:07.843]                           if (is.null(version)) 
[11:00:07.843]                             version <- utils::packageVersion("future")
[11:00:07.843]                         }
[11:00:07.843]                         else {
[11:00:07.843]                           version <- NULL
[11:00:07.843]                         }
[11:00:07.843]                         if (!has_future || version < "1.8.0") {
[11:00:07.843]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:07.843]                             "", base::R.version$version.string), 
[11:00:07.843]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:07.843]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:07.843]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:07.843]                               "release", "version")], collapse = " "), 
[11:00:07.843]                             hostname = base::Sys.info()[["nodename"]])
[11:00:07.843]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:07.843]                             info)
[11:00:07.843]                           info <- base::paste(info, collapse = "; ")
[11:00:07.843]                           if (!has_future) {
[11:00:07.843]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:07.843]                               info)
[11:00:07.843]                           }
[11:00:07.843]                           else {
[11:00:07.843]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:07.843]                               info, version)
[11:00:07.843]                           }
[11:00:07.843]                           base::stop(msg)
[11:00:07.843]                         }
[11:00:07.843]                       })
[11:00:07.843]                     }
[11:00:07.843]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:07.843]                     base::options(mc.cores = 1L)
[11:00:07.843]                   }
[11:00:07.843]                   ...future.strategy.old <- future::plan("list")
[11:00:07.843]                   options(future.plan = NULL)
[11:00:07.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:07.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:07.843]                 }
[11:00:07.843]                 ...future.workdir <- getwd()
[11:00:07.843]             }
[11:00:07.843]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:07.843]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:07.843]         }
[11:00:07.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:07.843]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:07.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:07.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:07.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:07.843]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:07.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:07.843]             base::names(...future.oldOptions))
[11:00:07.843]     }
[11:00:07.843]     if (FALSE) {
[11:00:07.843]     }
[11:00:07.843]     else {
[11:00:07.843]         if (TRUE) {
[11:00:07.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:07.843]                 open = "w")
[11:00:07.843]         }
[11:00:07.843]         else {
[11:00:07.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:07.843]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:07.843]         }
[11:00:07.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:07.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:07.843]             base::sink(type = "output", split = FALSE)
[11:00:07.843]             base::close(...future.stdout)
[11:00:07.843]         }, add = TRUE)
[11:00:07.843]     }
[11:00:07.843]     ...future.frame <- base::sys.nframe()
[11:00:07.843]     ...future.conditions <- base::list()
[11:00:07.843]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:07.843]     if (FALSE) {
[11:00:07.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:07.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:07.843]     }
[11:00:07.843]     ...future.result <- base::tryCatch({
[11:00:07.843]         base::withCallingHandlers({
[11:00:07.843]             ...future.value <- base::withVisible(base::local({
[11:00:07.843]                 ...future.makeSendCondition <- base::local({
[11:00:07.843]                   sendCondition <- NULL
[11:00:07.843]                   function(frame = 1L) {
[11:00:07.843]                     if (is.function(sendCondition)) 
[11:00:07.843]                       return(sendCondition)
[11:00:07.843]                     ns <- getNamespace("parallel")
[11:00:07.843]                     if (exists("sendData", mode = "function", 
[11:00:07.843]                       envir = ns)) {
[11:00:07.843]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:07.843]                         envir = ns)
[11:00:07.843]                       envir <- sys.frame(frame)
[11:00:07.843]                       master <- NULL
[11:00:07.843]                       while (!identical(envir, .GlobalEnv) && 
[11:00:07.843]                         !identical(envir, emptyenv())) {
[11:00:07.843]                         if (exists("master", mode = "list", envir = envir, 
[11:00:07.843]                           inherits = FALSE)) {
[11:00:07.843]                           master <- get("master", mode = "list", 
[11:00:07.843]                             envir = envir, inherits = FALSE)
[11:00:07.843]                           if (inherits(master, c("SOCKnode", 
[11:00:07.843]                             "SOCK0node"))) {
[11:00:07.843]                             sendCondition <<- function(cond) {
[11:00:07.843]                               data <- list(type = "VALUE", value = cond, 
[11:00:07.843]                                 success = TRUE)
[11:00:07.843]                               parallel_sendData(master, data)
[11:00:07.843]                             }
[11:00:07.843]                             return(sendCondition)
[11:00:07.843]                           }
[11:00:07.843]                         }
[11:00:07.843]                         frame <- frame + 1L
[11:00:07.843]                         envir <- sys.frame(frame)
[11:00:07.843]                       }
[11:00:07.843]                     }
[11:00:07.843]                     sendCondition <<- function(cond) NULL
[11:00:07.843]                   }
[11:00:07.843]                 })
[11:00:07.843]                 withCallingHandlers({
[11:00:07.843]                   {
[11:00:07.843]                     do.call(function(...) {
[11:00:07.843]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:07.843]                       if (!identical(...future.globals.maxSize.org, 
[11:00:07.843]                         ...future.globals.maxSize)) {
[11:00:07.843]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:07.843]                         on.exit(options(oopts), add = TRUE)
[11:00:07.843]                       }
[11:00:07.843]                       {
[11:00:07.843]                         lapply(seq_along(...future.elements_ii), 
[11:00:07.843]                           FUN = function(jj) {
[11:00:07.843]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:07.843]                             ...future.FUN(...future.X_jj, ...)
[11:00:07.843]                           })
[11:00:07.843]                       }
[11:00:07.843]                     }, args = future.call.arguments)
[11:00:07.843]                   }
[11:00:07.843]                 }, immediateCondition = function(cond) {
[11:00:07.843]                   sendCondition <- ...future.makeSendCondition()
[11:00:07.843]                   sendCondition(cond)
[11:00:07.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:07.843]                   {
[11:00:07.843]                     inherits <- base::inherits
[11:00:07.843]                     invokeRestart <- base::invokeRestart
[11:00:07.843]                     is.null <- base::is.null
[11:00:07.843]                     muffled <- FALSE
[11:00:07.843]                     if (inherits(cond, "message")) {
[11:00:07.843]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:07.843]                       if (muffled) 
[11:00:07.843]                         invokeRestart("muffleMessage")
[11:00:07.843]                     }
[11:00:07.843]                     else if (inherits(cond, "warning")) {
[11:00:07.843]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:07.843]                       if (muffled) 
[11:00:07.843]                         invokeRestart("muffleWarning")
[11:00:07.843]                     }
[11:00:07.843]                     else if (inherits(cond, "condition")) {
[11:00:07.843]                       if (!is.null(pattern)) {
[11:00:07.843]                         computeRestarts <- base::computeRestarts
[11:00:07.843]                         grepl <- base::grepl
[11:00:07.843]                         restarts <- computeRestarts(cond)
[11:00:07.843]                         for (restart in restarts) {
[11:00:07.843]                           name <- restart$name
[11:00:07.843]                           if (is.null(name)) 
[11:00:07.843]                             next
[11:00:07.843]                           if (!grepl(pattern, name)) 
[11:00:07.843]                             next
[11:00:07.843]                           invokeRestart(restart)
[11:00:07.843]                           muffled <- TRUE
[11:00:07.843]                           break
[11:00:07.843]                         }
[11:00:07.843]                       }
[11:00:07.843]                     }
[11:00:07.843]                     invisible(muffled)
[11:00:07.843]                   }
[11:00:07.843]                   muffleCondition(cond)
[11:00:07.843]                 })
[11:00:07.843]             }))
[11:00:07.843]             future::FutureResult(value = ...future.value$value, 
[11:00:07.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:07.843]                   ...future.rng), globalenv = if (FALSE) 
[11:00:07.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:07.843]                     ...future.globalenv.names))
[11:00:07.843]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:07.843]         }, condition = base::local({
[11:00:07.843]             c <- base::c
[11:00:07.843]             inherits <- base::inherits
[11:00:07.843]             invokeRestart <- base::invokeRestart
[11:00:07.843]             length <- base::length
[11:00:07.843]             list <- base::list
[11:00:07.843]             seq.int <- base::seq.int
[11:00:07.843]             signalCondition <- base::signalCondition
[11:00:07.843]             sys.calls <- base::sys.calls
[11:00:07.843]             `[[` <- base::`[[`
[11:00:07.843]             `+` <- base::`+`
[11:00:07.843]             `<<-` <- base::`<<-`
[11:00:07.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:07.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:07.843]                   3L)]
[11:00:07.843]             }
[11:00:07.843]             function(cond) {
[11:00:07.843]                 is_error <- inherits(cond, "error")
[11:00:07.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:07.843]                   NULL)
[11:00:07.843]                 if (is_error) {
[11:00:07.843]                   sessionInformation <- function() {
[11:00:07.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:07.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:07.843]                       search = base::search(), system = base::Sys.info())
[11:00:07.843]                   }
[11:00:07.843]                   ...future.conditions[[length(...future.conditions) + 
[11:00:07.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:07.843]                     cond$call), session = sessionInformation(), 
[11:00:07.843]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:07.843]                   signalCondition(cond)
[11:00:07.843]                 }
[11:00:07.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:07.843]                 "immediateCondition"))) {
[11:00:07.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:07.843]                   ...future.conditions[[length(...future.conditions) + 
[11:00:07.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:07.843]                   if (TRUE && !signal) {
[11:00:07.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:07.843]                     {
[11:00:07.843]                       inherits <- base::inherits
[11:00:07.843]                       invokeRestart <- base::invokeRestart
[11:00:07.843]                       is.null <- base::is.null
[11:00:07.843]                       muffled <- FALSE
[11:00:07.843]                       if (inherits(cond, "message")) {
[11:00:07.843]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:07.843]                         if (muffled) 
[11:00:07.843]                           invokeRestart("muffleMessage")
[11:00:07.843]                       }
[11:00:07.843]                       else if (inherits(cond, "warning")) {
[11:00:07.843]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:07.843]                         if (muffled) 
[11:00:07.843]                           invokeRestart("muffleWarning")
[11:00:07.843]                       }
[11:00:07.843]                       else if (inherits(cond, "condition")) {
[11:00:07.843]                         if (!is.null(pattern)) {
[11:00:07.843]                           computeRestarts <- base::computeRestarts
[11:00:07.843]                           grepl <- base::grepl
[11:00:07.843]                           restarts <- computeRestarts(cond)
[11:00:07.843]                           for (restart in restarts) {
[11:00:07.843]                             name <- restart$name
[11:00:07.843]                             if (is.null(name)) 
[11:00:07.843]                               next
[11:00:07.843]                             if (!grepl(pattern, name)) 
[11:00:07.843]                               next
[11:00:07.843]                             invokeRestart(restart)
[11:00:07.843]                             muffled <- TRUE
[11:00:07.843]                             break
[11:00:07.843]                           }
[11:00:07.843]                         }
[11:00:07.843]                       }
[11:00:07.843]                       invisible(muffled)
[11:00:07.843]                     }
[11:00:07.843]                     muffleCondition(cond, pattern = "^muffle")
[11:00:07.843]                   }
[11:00:07.843]                 }
[11:00:07.843]                 else {
[11:00:07.843]                   if (TRUE) {
[11:00:07.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:07.843]                     {
[11:00:07.843]                       inherits <- base::inherits
[11:00:07.843]                       invokeRestart <- base::invokeRestart
[11:00:07.843]                       is.null <- base::is.null
[11:00:07.843]                       muffled <- FALSE
[11:00:07.843]                       if (inherits(cond, "message")) {
[11:00:07.843]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:07.843]                         if (muffled) 
[11:00:07.843]                           invokeRestart("muffleMessage")
[11:00:07.843]                       }
[11:00:07.843]                       else if (inherits(cond, "warning")) {
[11:00:07.843]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:07.843]                         if (muffled) 
[11:00:07.843]                           invokeRestart("muffleWarning")
[11:00:07.843]                       }
[11:00:07.843]                       else if (inherits(cond, "condition")) {
[11:00:07.843]                         if (!is.null(pattern)) {
[11:00:07.843]                           computeRestarts <- base::computeRestarts
[11:00:07.843]                           grepl <- base::grepl
[11:00:07.843]                           restarts <- computeRestarts(cond)
[11:00:07.843]                           for (restart in restarts) {
[11:00:07.843]                             name <- restart$name
[11:00:07.843]                             if (is.null(name)) 
[11:00:07.843]                               next
[11:00:07.843]                             if (!grepl(pattern, name)) 
[11:00:07.843]                               next
[11:00:07.843]                             invokeRestart(restart)
[11:00:07.843]                             muffled <- TRUE
[11:00:07.843]                             break
[11:00:07.843]                           }
[11:00:07.843]                         }
[11:00:07.843]                       }
[11:00:07.843]                       invisible(muffled)
[11:00:07.843]                     }
[11:00:07.843]                     muffleCondition(cond, pattern = "^muffle")
[11:00:07.843]                   }
[11:00:07.843]                 }
[11:00:07.843]             }
[11:00:07.843]         }))
[11:00:07.843]     }, error = function(ex) {
[11:00:07.843]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:07.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:07.843]                 ...future.rng), started = ...future.startTime, 
[11:00:07.843]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:07.843]             version = "1.8"), class = "FutureResult")
[11:00:07.843]     }, finally = {
[11:00:07.843]         if (!identical(...future.workdir, getwd())) 
[11:00:07.843]             setwd(...future.workdir)
[11:00:07.843]         {
[11:00:07.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:07.843]                 ...future.oldOptions$nwarnings <- NULL
[11:00:07.843]             }
[11:00:07.843]             base::options(...future.oldOptions)
[11:00:07.843]             if (.Platform$OS.type == "windows") {
[11:00:07.843]                 old_names <- names(...future.oldEnvVars)
[11:00:07.843]                 envs <- base::Sys.getenv()
[11:00:07.843]                 names <- names(envs)
[11:00:07.843]                 common <- intersect(names, old_names)
[11:00:07.843]                 added <- setdiff(names, old_names)
[11:00:07.843]                 removed <- setdiff(old_names, names)
[11:00:07.843]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:07.843]                   envs[common]]
[11:00:07.843]                 NAMES <- toupper(changed)
[11:00:07.843]                 args <- list()
[11:00:07.843]                 for (kk in seq_along(NAMES)) {
[11:00:07.843]                   name <- changed[[kk]]
[11:00:07.843]                   NAME <- NAMES[[kk]]
[11:00:07.843]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:07.843]                     next
[11:00:07.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:07.843]                 }
[11:00:07.843]                 NAMES <- toupper(added)
[11:00:07.843]                 for (kk in seq_along(NAMES)) {
[11:00:07.843]                   name <- added[[kk]]
[11:00:07.843]                   NAME <- NAMES[[kk]]
[11:00:07.843]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:07.843]                     next
[11:00:07.843]                   args[[name]] <- ""
[11:00:07.843]                 }
[11:00:07.843]                 NAMES <- toupper(removed)
[11:00:07.843]                 for (kk in seq_along(NAMES)) {
[11:00:07.843]                   name <- removed[[kk]]
[11:00:07.843]                   NAME <- NAMES[[kk]]
[11:00:07.843]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:07.843]                     next
[11:00:07.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:07.843]                 }
[11:00:07.843]                 if (length(args) > 0) 
[11:00:07.843]                   base::do.call(base::Sys.setenv, args = args)
[11:00:07.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:07.843]             }
[11:00:07.843]             else {
[11:00:07.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:07.843]             }
[11:00:07.843]             {
[11:00:07.843]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:07.843]                   0L) {
[11:00:07.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:07.843]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:07.843]                   base::options(opts)
[11:00:07.843]                 }
[11:00:07.843]                 {
[11:00:07.843]                   {
[11:00:07.843]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:07.843]                     NULL
[11:00:07.843]                   }
[11:00:07.843]                   options(future.plan = NULL)
[11:00:07.843]                   if (is.na(NA_character_)) 
[11:00:07.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:07.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:07.843]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:07.843]                     .init = FALSE)
[11:00:07.843]                 }
[11:00:07.843]             }
[11:00:07.843]         }
[11:00:07.843]     })
[11:00:07.843]     if (TRUE) {
[11:00:07.843]         base::sink(type = "output", split = FALSE)
[11:00:07.843]         if (TRUE) {
[11:00:07.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:07.843]         }
[11:00:07.843]         else {
[11:00:07.843]             ...future.result["stdout"] <- base::list(NULL)
[11:00:07.843]         }
[11:00:07.843]         base::close(...future.stdout)
[11:00:07.843]         ...future.stdout <- NULL
[11:00:07.843]     }
[11:00:07.843]     ...future.result$conditions <- ...future.conditions
[11:00:07.843]     ...future.result$finished <- base::Sys.time()
[11:00:07.843]     ...future.result
[11:00:07.843] }
[11:00:07.845] Exporting 5 global objects (1.43 KiB) to cluster node #2 ...
[11:00:07.845] Exporting ‘...future.FUN’ (680 bytes) to cluster node #2 ...
[11:00:07.846] Exporting ‘...future.FUN’ (680 bytes) to cluster node #2 ... DONE
[11:00:07.846] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #2 ...
[11:00:07.846] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #2 ... DONE
[11:00:07.846] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #2 ...
[11:00:07.847] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #2 ... DONE
[11:00:07.847] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[11:00:07.847] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[11:00:07.847] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[11:00:07.848] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[11:00:07.848] Exporting 5 global objects (1.43 KiB) to cluster node #2 ... DONE
[11:00:07.848] MultisessionFuture started
[11:00:07.848] - Launch lazy future ... done
[11:00:07.849] run() for ‘MultisessionFuture’ ... done
[11:00:07.849] Created future:
[11:00:07.849] MultisessionFuture:
[11:00:07.849] Label: ‘future_sapply-2’
[11:00:07.849] Expression:
[11:00:07.849] {
[11:00:07.849]     do.call(function(...) {
[11:00:07.849]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:07.849]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:07.849]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:07.849]             on.exit(options(oopts), add = TRUE)
[11:00:07.849]         }
[11:00:07.849]         {
[11:00:07.849]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:07.849]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:07.849]                 ...future.FUN(...future.X_jj, ...)
[11:00:07.849]             })
[11:00:07.849]         }
[11:00:07.849]     }, args = future.call.arguments)
[11:00:07.849] }
[11:00:07.849] Lazy evaluation: FALSE
[11:00:07.849] Asynchronous evaluation: TRUE
[11:00:07.849] Local evaluation: TRUE
[11:00:07.849] Environment: R_GlobalEnv
[11:00:07.849] Capture standard output: TRUE
[11:00:07.849] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:07.849] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 680 bytes, DotDotDotList ‘future.call.arguments’ of 183 bytes, list ‘...future.elements_ii’ of 114 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:07.849] Packages: <none>
[11:00:07.849] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:07.849] Resolved: FALSE
[11:00:07.849] Value: <not collected>
[11:00:07.849] Conditions captured: <none>
[11:00:07.849] Early signaling: FALSE
[11:00:07.849] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:07.849] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:07.860] Chunk #2 of 2 ... DONE
[11:00:07.860] Launching 2 futures (chunks) ... DONE
[11:00:07.860] Resolving 2 futures (chunks) ...
[11:00:07.860] resolve() on list ...
[11:00:07.860]  recursive: 0
[11:00:07.861]  length: 2
[11:00:07.861] 
[11:00:07.861] receiveMessageFromWorker() for ClusterFuture ...
[11:00:07.861] - Validating connection of MultisessionFuture
[11:00:07.861] - received message: FutureResult
[11:00:07.861] - Received FutureResult
[11:00:07.862] - Erased future from FutureRegistry
[11:00:07.862] result() for ClusterFuture ...
[11:00:07.862] - result already collected: FutureResult
[11:00:07.862] result() for ClusterFuture ... done
[11:00:07.862] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:07.862] Future #1
[11:00:07.862] result() for ClusterFuture ...
[11:00:07.862] - result already collected: FutureResult
[11:00:07.862] result() for ClusterFuture ... done
[11:00:07.862] result() for ClusterFuture ...
[11:00:07.862] - result already collected: FutureResult
[11:00:07.862] result() for ClusterFuture ... done
[11:00:07.863] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:00:07.863] - nx: 2
[11:00:07.863] - relay: TRUE
[11:00:07.863] - stdout: TRUE
[11:00:07.863] - signal: TRUE
[11:00:07.863] - resignal: FALSE
[11:00:07.863] - force: TRUE
[11:00:07.863] - relayed: [n=2] FALSE, FALSE
[11:00:07.863] - queued futures: [n=2] FALSE, FALSE
[11:00:07.863]  - until=1
[11:00:07.863]  - relaying element #1
[11:00:07.865] result() for ClusterFuture ...
[11:00:07.865] - result already collected: FutureResult
[11:00:07.865] result() for ClusterFuture ... done
[11:00:07.865] result() for ClusterFuture ...
[11:00:07.866] - result already collected: FutureResult
[11:00:07.866] result() for ClusterFuture ... done
[11:00:07.866] result() for ClusterFuture ...
[11:00:07.866] - result already collected: FutureResult
[11:00:07.866] result() for ClusterFuture ... done
[11:00:07.866] result() for ClusterFuture ...
[11:00:07.866] - result already collected: FutureResult
[11:00:07.866] result() for ClusterFuture ... done
[11:00:07.866] - relayed: [n=2] TRUE, FALSE
[11:00:07.866] - queued futures: [n=2] TRUE, FALSE
[11:00:07.866] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:00:07.866]  length: 1 (resolved future 1)
[11:00:07.890] receiveMessageFromWorker() for ClusterFuture ...
[11:00:07.890] - Validating connection of MultisessionFuture
[11:00:07.891] - received message: FutureResult
[11:00:07.891] - Received FutureResult
[11:00:07.891] - Erased future from FutureRegistry
[11:00:07.891] result() for ClusterFuture ...
[11:00:07.891] - result already collected: FutureResult
[11:00:07.891] result() for ClusterFuture ... done
[11:00:07.891] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:07.891] Future #2
[11:00:07.891] result() for ClusterFuture ...
[11:00:07.891] - result already collected: FutureResult
[11:00:07.891] result() for ClusterFuture ... done
[11:00:07.892] result() for ClusterFuture ...
[11:00:07.892] - result already collected: FutureResult
[11:00:07.892] result() for ClusterFuture ... done
[11:00:07.892] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:00:07.892] - nx: 2
[11:00:07.892] - relay: TRUE
[11:00:07.892] - stdout: TRUE
[11:00:07.892] - signal: TRUE
[11:00:07.892] - resignal: FALSE
[11:00:07.892] - force: TRUE
[11:00:07.892] - relayed: [n=2] TRUE, FALSE
[11:00:07.892] - queued futures: [n=2] TRUE, FALSE
[11:00:07.892]  - until=2
[11:00:07.893]  - relaying element #2
[11:00:07.893] result() for ClusterFuture ...
[11:00:07.893] - result already collected: FutureResult
[11:00:07.893] result() for ClusterFuture ... done
[11:00:07.893] result() for ClusterFuture ...
[11:00:07.893] - result already collected: FutureResult
[11:00:07.893] result() for ClusterFuture ... done
[11:00:07.893] result() for ClusterFuture ...
[11:00:07.893] - result already collected: FutureResult
[11:00:07.893] result() for ClusterFuture ... done
[11:00:07.893] result() for ClusterFuture ...
[11:00:07.893] - result already collected: FutureResult
[11:00:07.894] result() for ClusterFuture ... done
[11:00:07.894] - relayed: [n=2] TRUE, TRUE
[11:00:07.894] - queued futures: [n=2] TRUE, TRUE
[11:00:07.894] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:00:07.894]  length: 0 (resolved future 2)
[11:00:07.894] Relaying remaining futures
[11:00:07.894] signalConditionsASAP(NULL, pos=0) ...
[11:00:07.894] - nx: 2
[11:00:07.894] - relay: TRUE
[11:00:07.894] - stdout: TRUE
[11:00:07.894] - signal: TRUE
[11:00:07.894] - resignal: FALSE
[11:00:07.895] - force: TRUE
[11:00:07.895] - relayed: [n=2] TRUE, TRUE
[11:00:07.895] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:07.895] - relayed: [n=2] TRUE, TRUE
[11:00:07.895] - queued futures: [n=2] TRUE, TRUE
[11:00:07.895] signalConditionsASAP(NULL, pos=0) ... done
[11:00:07.895] resolve() on list ... DONE
[11:00:07.895] result() for ClusterFuture ...
[11:00:07.895] - result already collected: FutureResult
[11:00:07.895] result() for ClusterFuture ... done
[11:00:07.895] result() for ClusterFuture ...
[11:00:07.895] - result already collected: FutureResult
[11:00:07.896] result() for ClusterFuture ... done
[11:00:07.896] result() for ClusterFuture ...
[11:00:07.896] - result already collected: FutureResult
[11:00:07.896] result() for ClusterFuture ... done
[11:00:07.896] result() for ClusterFuture ...
[11:00:07.896] - result already collected: FutureResult
[11:00:07.896] result() for ClusterFuture ... done
[11:00:07.896]  - Number of value chunks collected: 2
[11:00:07.896] Resolving 2 futures (chunks) ... DONE
[11:00:07.896] Reducing values from 2 chunks ...
[11:00:07.896]  - Number of values collected after concatenation: 4
[11:00:07.896]  - Number of values expected: 4
[11:00:07.897] Reducing values from 2 chunks ... DONE
[11:00:07.897] future_lapply() ... DONE
[11:00:07.897] future_lapply() ...
[11:00:07.900] Number of chunks: 2
[11:00:07.900] getGlobalsAndPackagesXApply() ...
[11:00:07.900]  - future.globals: TRUE
[11:00:07.900] getGlobalsAndPackages() ...
[11:00:07.900] Searching for globals...
[11:00:07.904] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[11:00:07.904] Searching for globals ... DONE
[11:00:07.904] Resolving globals: FALSE
[11:00:07.905] The total size of the 7 globals is 14.32 KiB (14666 bytes)
[11:00:07.905] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 14.32 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (5.67 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:07.905] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:07.905] - packages: [1] ‘future.apply’
[11:00:07.905] getGlobalsAndPackages() ... DONE
[11:00:07.906]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:07.906]  - needed namespaces: [n=1] ‘future.apply’
[11:00:07.906] Finding globals ... DONE
[11:00:07.906]  - use_args: TRUE
[11:00:07.906]  - Getting '...' globals ...
[11:00:07.906] resolve() on list ...
[11:00:07.906]  recursive: 0
[11:00:07.906]  length: 1
[11:00:07.906]  elements: ‘...’
[11:00:07.907]  length: 0 (resolved future 1)
[11:00:07.907] resolve() on list ... DONE
[11:00:07.907]    - '...' content: [n=1] ‘y’
[11:00:07.907] List of 1
[11:00:07.907]  $ ...:List of 1
[11:00:07.907]   ..$ y: num [1:5] 2 4 6 8 10
[11:00:07.907]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:07.907]  - attr(*, "where")=List of 1
[11:00:07.907]   ..$ ...:<environment: 0x55bbb0183ab8> 
[11:00:07.907]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:07.907]  - attr(*, "resolved")= logi TRUE
[11:00:07.907]  - attr(*, "total_size")= num NA
[11:00:07.909]  - Getting '...' globals ... DONE
[11:00:07.910] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:07.910] List of 8
[11:00:07.910]  $ ...future.FUN:function (x, ...)  
[11:00:07.910]  $ x_FUN        :function (x, y)  
[11:00:07.910]  $ times        : int 15
[11:00:07.910]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:07.910]  $ stop_if_not  :function (...)  
[11:00:07.910]  $ dim          : int [1:2] 3 5
[11:00:07.910]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:07.910]  $ ...          :List of 1
[11:00:07.910]   ..$ y: num [1:5] 2 4 6 8 10
[11:00:07.910]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:07.910]  - attr(*, "where")=List of 8
[11:00:07.910]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:07.910]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:07.910]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:07.910]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:07.910]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:07.910]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:07.910]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:07.910]   ..$ ...          :<environment: 0x55bbb0183ab8> 
[11:00:07.910]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:07.910]  - attr(*, "resolved")= logi FALSE
[11:00:07.910]  - attr(*, "total_size")= num 26659
[11:00:07.915] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:07.915] getGlobalsAndPackagesXApply() ... DONE
[11:00:07.915] Number of futures (= number of chunks): 2
[11:00:07.916] Launching 2 futures (chunks) ...
[11:00:07.916] Chunk #1 of 2 ...
[11:00:07.916]  - Finding globals in 'X' for chunk #1 ...
[11:00:07.916] getGlobalsAndPackages() ...
[11:00:07.916] Searching for globals...
[11:00:07.916] 
[11:00:07.916] Searching for globals ... DONE
[11:00:07.916] - globals: [0] <none>
[11:00:07.916] getGlobalsAndPackages() ... DONE
[11:00:07.917]    + additional globals found: [n=0] 
[11:00:07.917]    + additional namespaces needed: [n=0] 
[11:00:07.917]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:07.917]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:07.917]  - seeds: <none>
[11:00:07.917]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:07.917] getGlobalsAndPackages() ...
[11:00:07.917] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:07.917] Resolving globals: FALSE
[11:00:07.917] Tweak future expression to call with '...' arguments ...
[11:00:07.917] {
[11:00:07.917]     do.call(function(...) {
[11:00:07.917]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:07.917]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:07.917]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:07.917]             on.exit(options(oopts), add = TRUE)
[11:00:07.917]         }
[11:00:07.917]         {
[11:00:07.917]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:07.917]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:07.917]                 ...future.FUN(...future.X_jj, ...)
[11:00:07.917]             })
[11:00:07.917]         }
[11:00:07.917]     }, args = future.call.arguments)
[11:00:07.917] }
[11:00:07.918] Tweak future expression to call with '...' arguments ... DONE
[11:00:07.918] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:07.918] - packages: [1] ‘future.apply’
[11:00:07.918] getGlobalsAndPackages() ... DONE
[11:00:07.919] run() for ‘Future’ ...
[11:00:07.919] - state: ‘created’
[11:00:07.919] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:07.932] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:07.932] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:07.933]   - Field: ‘node’
[11:00:07.933]   - Field: ‘label’
[11:00:07.933]   - Field: ‘local’
[11:00:07.933]   - Field: ‘owner’
[11:00:07.933]   - Field: ‘envir’
[11:00:07.933]   - Field: ‘workers’
[11:00:07.933]   - Field: ‘packages’
[11:00:07.933]   - Field: ‘gc’
[11:00:07.933]   - Field: ‘conditions’
[11:00:07.933]   - Field: ‘persistent’
[11:00:07.933]   - Field: ‘expr’
[11:00:07.933]   - Field: ‘uuid’
[11:00:07.934]   - Field: ‘seed’
[11:00:07.934]   - Field: ‘version’
[11:00:07.934]   - Field: ‘result’
[11:00:07.934]   - Field: ‘asynchronous’
[11:00:07.934]   - Field: ‘calls’
[11:00:07.934]   - Field: ‘globals’
[11:00:07.934]   - Field: ‘stdout’
[11:00:07.934]   - Field: ‘earlySignal’
[11:00:07.934]   - Field: ‘lazy’
[11:00:07.934]   - Field: ‘state’
[11:00:07.934] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:07.934] - Launch lazy future ...
[11:00:07.935] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:07.935] Packages needed by future strategies (n = 0): <none>
[11:00:07.935] {
[11:00:07.935]     {
[11:00:07.935]         {
[11:00:07.935]             ...future.startTime <- base::Sys.time()
[11:00:07.935]             {
[11:00:07.935]                 {
[11:00:07.935]                   {
[11:00:07.935]                     {
[11:00:07.935]                       {
[11:00:07.935]                         base::local({
[11:00:07.935]                           has_future <- base::requireNamespace("future", 
[11:00:07.935]                             quietly = TRUE)
[11:00:07.935]                           if (has_future) {
[11:00:07.935]                             ns <- base::getNamespace("future")
[11:00:07.935]                             version <- ns[[".package"]][["version"]]
[11:00:07.935]                             if (is.null(version)) 
[11:00:07.935]                               version <- utils::packageVersion("future")
[11:00:07.935]                           }
[11:00:07.935]                           else {
[11:00:07.935]                             version <- NULL
[11:00:07.935]                           }
[11:00:07.935]                           if (!has_future || version < "1.8.0") {
[11:00:07.935]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:07.935]                               "", base::R.version$version.string), 
[11:00:07.935]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:07.935]                                 base::R.version$platform, 8 * 
[11:00:07.935]                                   base::.Machine$sizeof.pointer), 
[11:00:07.935]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:07.935]                                 "release", "version")], collapse = " "), 
[11:00:07.935]                               hostname = base::Sys.info()[["nodename"]])
[11:00:07.935]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:07.935]                               info)
[11:00:07.935]                             info <- base::paste(info, collapse = "; ")
[11:00:07.935]                             if (!has_future) {
[11:00:07.935]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:07.935]                                 info)
[11:00:07.935]                             }
[11:00:07.935]                             else {
[11:00:07.935]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:07.935]                                 info, version)
[11:00:07.935]                             }
[11:00:07.935]                             base::stop(msg)
[11:00:07.935]                           }
[11:00:07.935]                         })
[11:00:07.935]                       }
[11:00:07.935]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:07.935]                       base::options(mc.cores = 1L)
[11:00:07.935]                     }
[11:00:07.935]                     base::local({
[11:00:07.935]                       for (pkg in "future.apply") {
[11:00:07.935]                         base::loadNamespace(pkg)
[11:00:07.935]                         base::library(pkg, character.only = TRUE)
[11:00:07.935]                       }
[11:00:07.935]                     })
[11:00:07.935]                   }
[11:00:07.935]                   ...future.strategy.old <- future::plan("list")
[11:00:07.935]                   options(future.plan = NULL)
[11:00:07.935]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:07.935]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:07.935]                 }
[11:00:07.935]                 ...future.workdir <- getwd()
[11:00:07.935]             }
[11:00:07.935]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:07.935]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:07.935]         }
[11:00:07.935]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:07.935]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:07.935]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:07.935]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:07.935]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:07.935]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:07.935]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:07.935]             base::names(...future.oldOptions))
[11:00:07.935]     }
[11:00:07.935]     if (FALSE) {
[11:00:07.935]     }
[11:00:07.935]     else {
[11:00:07.935]         if (TRUE) {
[11:00:07.935]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:07.935]                 open = "w")
[11:00:07.935]         }
[11:00:07.935]         else {
[11:00:07.935]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:07.935]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:07.935]         }
[11:00:07.935]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:07.935]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:07.935]             base::sink(type = "output", split = FALSE)
[11:00:07.935]             base::close(...future.stdout)
[11:00:07.935]         }, add = TRUE)
[11:00:07.935]     }
[11:00:07.935]     ...future.frame <- base::sys.nframe()
[11:00:07.935]     ...future.conditions <- base::list()
[11:00:07.935]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:07.935]     if (FALSE) {
[11:00:07.935]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:07.935]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:07.935]     }
[11:00:07.935]     ...future.result <- base::tryCatch({
[11:00:07.935]         base::withCallingHandlers({
[11:00:07.935]             ...future.value <- base::withVisible(base::local({
[11:00:07.935]                 ...future.makeSendCondition <- base::local({
[11:00:07.935]                   sendCondition <- NULL
[11:00:07.935]                   function(frame = 1L) {
[11:00:07.935]                     if (is.function(sendCondition)) 
[11:00:07.935]                       return(sendCondition)
[11:00:07.935]                     ns <- getNamespace("parallel")
[11:00:07.935]                     if (exists("sendData", mode = "function", 
[11:00:07.935]                       envir = ns)) {
[11:00:07.935]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:07.935]                         envir = ns)
[11:00:07.935]                       envir <- sys.frame(frame)
[11:00:07.935]                       master <- NULL
[11:00:07.935]                       while (!identical(envir, .GlobalEnv) && 
[11:00:07.935]                         !identical(envir, emptyenv())) {
[11:00:07.935]                         if (exists("master", mode = "list", envir = envir, 
[11:00:07.935]                           inherits = FALSE)) {
[11:00:07.935]                           master <- get("master", mode = "list", 
[11:00:07.935]                             envir = envir, inherits = FALSE)
[11:00:07.935]                           if (inherits(master, c("SOCKnode", 
[11:00:07.935]                             "SOCK0node"))) {
[11:00:07.935]                             sendCondition <<- function(cond) {
[11:00:07.935]                               data <- list(type = "VALUE", value = cond, 
[11:00:07.935]                                 success = TRUE)
[11:00:07.935]                               parallel_sendData(master, data)
[11:00:07.935]                             }
[11:00:07.935]                             return(sendCondition)
[11:00:07.935]                           }
[11:00:07.935]                         }
[11:00:07.935]                         frame <- frame + 1L
[11:00:07.935]                         envir <- sys.frame(frame)
[11:00:07.935]                       }
[11:00:07.935]                     }
[11:00:07.935]                     sendCondition <<- function(cond) NULL
[11:00:07.935]                   }
[11:00:07.935]                 })
[11:00:07.935]                 withCallingHandlers({
[11:00:07.935]                   {
[11:00:07.935]                     do.call(function(...) {
[11:00:07.935]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:07.935]                       if (!identical(...future.globals.maxSize.org, 
[11:00:07.935]                         ...future.globals.maxSize)) {
[11:00:07.935]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:07.935]                         on.exit(options(oopts), add = TRUE)
[11:00:07.935]                       }
[11:00:07.935]                       {
[11:00:07.935]                         lapply(seq_along(...future.elements_ii), 
[11:00:07.935]                           FUN = function(jj) {
[11:00:07.935]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:07.935]                             ...future.FUN(...future.X_jj, ...)
[11:00:07.935]                           })
[11:00:07.935]                       }
[11:00:07.935]                     }, args = future.call.arguments)
[11:00:07.935]                   }
[11:00:07.935]                 }, immediateCondition = function(cond) {
[11:00:07.935]                   sendCondition <- ...future.makeSendCondition()
[11:00:07.935]                   sendCondition(cond)
[11:00:07.935]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:07.935]                   {
[11:00:07.935]                     inherits <- base::inherits
[11:00:07.935]                     invokeRestart <- base::invokeRestart
[11:00:07.935]                     is.null <- base::is.null
[11:00:07.935]                     muffled <- FALSE
[11:00:07.935]                     if (inherits(cond, "message")) {
[11:00:07.935]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:07.935]                       if (muffled) 
[11:00:07.935]                         invokeRestart("muffleMessage")
[11:00:07.935]                     }
[11:00:07.935]                     else if (inherits(cond, "warning")) {
[11:00:07.935]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:07.935]                       if (muffled) 
[11:00:07.935]                         invokeRestart("muffleWarning")
[11:00:07.935]                     }
[11:00:07.935]                     else if (inherits(cond, "condition")) {
[11:00:07.935]                       if (!is.null(pattern)) {
[11:00:07.935]                         computeRestarts <- base::computeRestarts
[11:00:07.935]                         grepl <- base::grepl
[11:00:07.935]                         restarts <- computeRestarts(cond)
[11:00:07.935]                         for (restart in restarts) {
[11:00:07.935]                           name <- restart$name
[11:00:07.935]                           if (is.null(name)) 
[11:00:07.935]                             next
[11:00:07.935]                           if (!grepl(pattern, name)) 
[11:00:07.935]                             next
[11:00:07.935]                           invokeRestart(restart)
[11:00:07.935]                           muffled <- TRUE
[11:00:07.935]                           break
[11:00:07.935]                         }
[11:00:07.935]                       }
[11:00:07.935]                     }
[11:00:07.935]                     invisible(muffled)
[11:00:07.935]                   }
[11:00:07.935]                   muffleCondition(cond)
[11:00:07.935]                 })
[11:00:07.935]             }))
[11:00:07.935]             future::FutureResult(value = ...future.value$value, 
[11:00:07.935]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:07.935]                   ...future.rng), globalenv = if (FALSE) 
[11:00:07.935]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:07.935]                     ...future.globalenv.names))
[11:00:07.935]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:07.935]         }, condition = base::local({
[11:00:07.935]             c <- base::c
[11:00:07.935]             inherits <- base::inherits
[11:00:07.935]             invokeRestart <- base::invokeRestart
[11:00:07.935]             length <- base::length
[11:00:07.935]             list <- base::list
[11:00:07.935]             seq.int <- base::seq.int
[11:00:07.935]             signalCondition <- base::signalCondition
[11:00:07.935]             sys.calls <- base::sys.calls
[11:00:07.935]             `[[` <- base::`[[`
[11:00:07.935]             `+` <- base::`+`
[11:00:07.935]             `<<-` <- base::`<<-`
[11:00:07.935]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:07.935]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:07.935]                   3L)]
[11:00:07.935]             }
[11:00:07.935]             function(cond) {
[11:00:07.935]                 is_error <- inherits(cond, "error")
[11:00:07.935]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:07.935]                   NULL)
[11:00:07.935]                 if (is_error) {
[11:00:07.935]                   sessionInformation <- function() {
[11:00:07.935]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:07.935]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:07.935]                       search = base::search(), system = base::Sys.info())
[11:00:07.935]                   }
[11:00:07.935]                   ...future.conditions[[length(...future.conditions) + 
[11:00:07.935]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:07.935]                     cond$call), session = sessionInformation(), 
[11:00:07.935]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:07.935]                   signalCondition(cond)
[11:00:07.935]                 }
[11:00:07.935]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:07.935]                 "immediateCondition"))) {
[11:00:07.935]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:07.935]                   ...future.conditions[[length(...future.conditions) + 
[11:00:07.935]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:07.935]                   if (TRUE && !signal) {
[11:00:07.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:07.935]                     {
[11:00:07.935]                       inherits <- base::inherits
[11:00:07.935]                       invokeRestart <- base::invokeRestart
[11:00:07.935]                       is.null <- base::is.null
[11:00:07.935]                       muffled <- FALSE
[11:00:07.935]                       if (inherits(cond, "message")) {
[11:00:07.935]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:07.935]                         if (muffled) 
[11:00:07.935]                           invokeRestart("muffleMessage")
[11:00:07.935]                       }
[11:00:07.935]                       else if (inherits(cond, "warning")) {
[11:00:07.935]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:07.935]                         if (muffled) 
[11:00:07.935]                           invokeRestart("muffleWarning")
[11:00:07.935]                       }
[11:00:07.935]                       else if (inherits(cond, "condition")) {
[11:00:07.935]                         if (!is.null(pattern)) {
[11:00:07.935]                           computeRestarts <- base::computeRestarts
[11:00:07.935]                           grepl <- base::grepl
[11:00:07.935]                           restarts <- computeRestarts(cond)
[11:00:07.935]                           for (restart in restarts) {
[11:00:07.935]                             name <- restart$name
[11:00:07.935]                             if (is.null(name)) 
[11:00:07.935]                               next
[11:00:07.935]                             if (!grepl(pattern, name)) 
[11:00:07.935]                               next
[11:00:07.935]                             invokeRestart(restart)
[11:00:07.935]                             muffled <- TRUE
[11:00:07.935]                             break
[11:00:07.935]                           }
[11:00:07.935]                         }
[11:00:07.935]                       }
[11:00:07.935]                       invisible(muffled)
[11:00:07.935]                     }
[11:00:07.935]                     muffleCondition(cond, pattern = "^muffle")
[11:00:07.935]                   }
[11:00:07.935]                 }
[11:00:07.935]                 else {
[11:00:07.935]                   if (TRUE) {
[11:00:07.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:07.935]                     {
[11:00:07.935]                       inherits <- base::inherits
[11:00:07.935]                       invokeRestart <- base::invokeRestart
[11:00:07.935]                       is.null <- base::is.null
[11:00:07.935]                       muffled <- FALSE
[11:00:07.935]                       if (inherits(cond, "message")) {
[11:00:07.935]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:07.935]                         if (muffled) 
[11:00:07.935]                           invokeRestart("muffleMessage")
[11:00:07.935]                       }
[11:00:07.935]                       else if (inherits(cond, "warning")) {
[11:00:07.935]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:07.935]                         if (muffled) 
[11:00:07.935]                           invokeRestart("muffleWarning")
[11:00:07.935]                       }
[11:00:07.935]                       else if (inherits(cond, "condition")) {
[11:00:07.935]                         if (!is.null(pattern)) {
[11:00:07.935]                           computeRestarts <- base::computeRestarts
[11:00:07.935]                           grepl <- base::grepl
[11:00:07.935]                           restarts <- computeRestarts(cond)
[11:00:07.935]                           for (restart in restarts) {
[11:00:07.935]                             name <- restart$name
[11:00:07.935]                             if (is.null(name)) 
[11:00:07.935]                               next
[11:00:07.935]                             if (!grepl(pattern, name)) 
[11:00:07.935]                               next
[11:00:07.935]                             invokeRestart(restart)
[11:00:07.935]                             muffled <- TRUE
[11:00:07.935]                             break
[11:00:07.935]                           }
[11:00:07.935]                         }
[11:00:07.935]                       }
[11:00:07.935]                       invisible(muffled)
[11:00:07.935]                     }
[11:00:07.935]                     muffleCondition(cond, pattern = "^muffle")
[11:00:07.935]                   }
[11:00:07.935]                 }
[11:00:07.935]             }
[11:00:07.935]         }))
[11:00:07.935]     }, error = function(ex) {
[11:00:07.935]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:07.935]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:07.935]                 ...future.rng), started = ...future.startTime, 
[11:00:07.935]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:07.935]             version = "1.8"), class = "FutureResult")
[11:00:07.935]     }, finally = {
[11:00:07.935]         if (!identical(...future.workdir, getwd())) 
[11:00:07.935]             setwd(...future.workdir)
[11:00:07.935]         {
[11:00:07.935]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:07.935]                 ...future.oldOptions$nwarnings <- NULL
[11:00:07.935]             }
[11:00:07.935]             base::options(...future.oldOptions)
[11:00:07.935]             if (.Platform$OS.type == "windows") {
[11:00:07.935]                 old_names <- names(...future.oldEnvVars)
[11:00:07.935]                 envs <- base::Sys.getenv()
[11:00:07.935]                 names <- names(envs)
[11:00:07.935]                 common <- intersect(names, old_names)
[11:00:07.935]                 added <- setdiff(names, old_names)
[11:00:07.935]                 removed <- setdiff(old_names, names)
[11:00:07.935]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:07.935]                   envs[common]]
[11:00:07.935]                 NAMES <- toupper(changed)
[11:00:07.935]                 args <- list()
[11:00:07.935]                 for (kk in seq_along(NAMES)) {
[11:00:07.935]                   name <- changed[[kk]]
[11:00:07.935]                   NAME <- NAMES[[kk]]
[11:00:07.935]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:07.935]                     next
[11:00:07.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:07.935]                 }
[11:00:07.935]                 NAMES <- toupper(added)
[11:00:07.935]                 for (kk in seq_along(NAMES)) {
[11:00:07.935]                   name <- added[[kk]]
[11:00:07.935]                   NAME <- NAMES[[kk]]
[11:00:07.935]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:07.935]                     next
[11:00:07.935]                   args[[name]] <- ""
[11:00:07.935]                 }
[11:00:07.935]                 NAMES <- toupper(removed)
[11:00:07.935]                 for (kk in seq_along(NAMES)) {
[11:00:07.935]                   name <- removed[[kk]]
[11:00:07.935]                   NAME <- NAMES[[kk]]
[11:00:07.935]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:07.935]                     next
[11:00:07.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:07.935]                 }
[11:00:07.935]                 if (length(args) > 0) 
[11:00:07.935]                   base::do.call(base::Sys.setenv, args = args)
[11:00:07.935]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:07.935]             }
[11:00:07.935]             else {
[11:00:07.935]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:07.935]             }
[11:00:07.935]             {
[11:00:07.935]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:07.935]                   0L) {
[11:00:07.935]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:07.935]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:07.935]                   base::options(opts)
[11:00:07.935]                 }
[11:00:07.935]                 {
[11:00:07.935]                   {
[11:00:07.935]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:07.935]                     NULL
[11:00:07.935]                   }
[11:00:07.935]                   options(future.plan = NULL)
[11:00:07.935]                   if (is.na(NA_character_)) 
[11:00:07.935]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:07.935]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:07.935]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:07.935]                     .init = FALSE)
[11:00:07.935]                 }
[11:00:07.935]             }
[11:00:07.935]         }
[11:00:07.935]     })
[11:00:07.935]     if (TRUE) {
[11:00:07.935]         base::sink(type = "output", split = FALSE)
[11:00:07.935]         if (TRUE) {
[11:00:07.935]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:07.935]         }
[11:00:07.935]         else {
[11:00:07.935]             ...future.result["stdout"] <- base::list(NULL)
[11:00:07.935]         }
[11:00:07.935]         base::close(...future.stdout)
[11:00:07.935]         ...future.stdout <- NULL
[11:00:07.935]     }
[11:00:07.935]     ...future.result$conditions <- ...future.conditions
[11:00:07.935]     ...future.result$finished <- base::Sys.time()
[11:00:07.935]     ...future.result
[11:00:07.935] }
[11:00:07.938] Exporting 11 global objects (14.80 KiB) to cluster node #1 ...
[11:00:07.938] Exporting ‘...future.FUN’ (5.67 KiB) to cluster node #1 ...
[11:00:07.980] Exporting ‘...future.FUN’ (5.67 KiB) to cluster node #1 ... DONE
[11:00:07.980] Exporting ‘x_FUN’ (680 bytes) to cluster node #1 ...
[11:00:07.980] Exporting ‘x_FUN’ (680 bytes) to cluster node #1 ... DONE
[11:00:07.980] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[11:00:07.981] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[11:00:07.981] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[11:00:08.022] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[11:00:08.022] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[11:00:08.063] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[11:00:08.063] Exporting ‘dim’ (39 bytes) to cluster node #1 ...
[11:00:08.063] Exporting ‘dim’ (39 bytes) to cluster node #1 ... DONE
[11:00:08.063] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[11:00:08.064] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[11:00:08.064] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #1 ...
[11:00:08.064] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #1 ... DONE
[11:00:08.064] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #1 ...
[11:00:08.065] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #1 ... DONE
[11:00:08.065] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[11:00:08.065] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[11:00:08.065] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[11:00:08.065] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[11:00:08.066] Exporting 11 global objects (14.80 KiB) to cluster node #1 ... DONE
[11:00:08.066] MultisessionFuture started
[11:00:08.066] - Launch lazy future ... done
[11:00:08.066] run() for ‘MultisessionFuture’ ... done
[11:00:08.066] Created future:
[11:00:08.066] MultisessionFuture:
[11:00:08.066] Label: ‘future_vapply-1’
[11:00:08.066] Expression:
[11:00:08.066] {
[11:00:08.066]     do.call(function(...) {
[11:00:08.066]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:08.066]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:08.066]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:08.066]             on.exit(options(oopts), add = TRUE)
[11:00:08.066]         }
[11:00:08.066]         {
[11:00:08.066]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:08.066]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:08.066]                 ...future.FUN(...future.X_jj, ...)
[11:00:08.066]             })
[11:00:08.066]         }
[11:00:08.066]     }, args = future.call.arguments)
[11:00:08.066] }
[11:00:08.066] Lazy evaluation: FALSE
[11:00:08.066] Asynchronous evaluation: TRUE
[11:00:08.066] Local evaluation: TRUE
[11:00:08.066] Environment: R_GlobalEnv
[11:00:08.066] Capture standard output: TRUE
[11:00:08.066] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:08.066] Globals: 11 objects totaling 14.66 KiB (function ‘...future.FUN’ of 5.67 KiB, function ‘x_FUN’ of 680 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:08.066] Packages: 1 packages (‘future.apply’)
[11:00:08.066] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:08.066] Resolved: FALSE
[11:00:08.066] Value: <not collected>
[11:00:08.066] Conditions captured: <none>
[11:00:08.066] Early signaling: FALSE
[11:00:08.066] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:08.066] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:08.078] Chunk #1 of 2 ... DONE
[11:00:08.078] Chunk #2 of 2 ...
[11:00:08.078]  - Finding globals in 'X' for chunk #2 ...
[11:00:08.078] getGlobalsAndPackages() ...
[11:00:08.078] Searching for globals...
[11:00:08.079] 
[11:00:08.079] Searching for globals ... DONE
[11:00:08.079] - globals: [0] <none>
[11:00:08.079] getGlobalsAndPackages() ... DONE
[11:00:08.079]    + additional globals found: [n=0] 
[11:00:08.079]    + additional namespaces needed: [n=0] 
[11:00:08.079]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:08.079]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:08.079]  - seeds: <none>
[11:00:08.079]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:08.079] getGlobalsAndPackages() ...
[11:00:08.079] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:08.080] Resolving globals: FALSE
[11:00:08.080] Tweak future expression to call with '...' arguments ...
[11:00:08.080] {
[11:00:08.080]     do.call(function(...) {
[11:00:08.080]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:08.080]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:08.080]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:08.080]             on.exit(options(oopts), add = TRUE)
[11:00:08.080]         }
[11:00:08.080]         {
[11:00:08.080]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:08.080]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:08.080]                 ...future.FUN(...future.X_jj, ...)
[11:00:08.080]             })
[11:00:08.080]         }
[11:00:08.080]     }, args = future.call.arguments)
[11:00:08.080] }
[11:00:08.080] Tweak future expression to call with '...' arguments ... DONE
[11:00:08.080] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:08.081] - packages: [1] ‘future.apply’
[11:00:08.081] getGlobalsAndPackages() ... DONE
[11:00:08.081] run() for ‘Future’ ...
[11:00:08.081] - state: ‘created’
[11:00:08.081] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:08.094] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:08.094] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:08.095]   - Field: ‘node’
[11:00:08.095]   - Field: ‘label’
[11:00:08.095]   - Field: ‘local’
[11:00:08.095]   - Field: ‘owner’
[11:00:08.095]   - Field: ‘envir’
[11:00:08.095]   - Field: ‘workers’
[11:00:08.095]   - Field: ‘packages’
[11:00:08.095]   - Field: ‘gc’
[11:00:08.095]   - Field: ‘conditions’
[11:00:08.095]   - Field: ‘persistent’
[11:00:08.095]   - Field: ‘expr’
[11:00:08.095]   - Field: ‘uuid’
[11:00:08.095]   - Field: ‘seed’
[11:00:08.096]   - Field: ‘version’
[11:00:08.096]   - Field: ‘result’
[11:00:08.096]   - Field: ‘asynchronous’
[11:00:08.096]   - Field: ‘calls’
[11:00:08.096]   - Field: ‘globals’
[11:00:08.096]   - Field: ‘stdout’
[11:00:08.096]   - Field: ‘earlySignal’
[11:00:08.096]   - Field: ‘lazy’
[11:00:08.096]   - Field: ‘state’
[11:00:08.096] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:08.096] - Launch lazy future ...
[11:00:08.097] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:08.097] Packages needed by future strategies (n = 0): <none>
[11:00:08.097] {
[11:00:08.097]     {
[11:00:08.097]         {
[11:00:08.097]             ...future.startTime <- base::Sys.time()
[11:00:08.097]             {
[11:00:08.097]                 {
[11:00:08.097]                   {
[11:00:08.097]                     {
[11:00:08.097]                       {
[11:00:08.097]                         base::local({
[11:00:08.097]                           has_future <- base::requireNamespace("future", 
[11:00:08.097]                             quietly = TRUE)
[11:00:08.097]                           if (has_future) {
[11:00:08.097]                             ns <- base::getNamespace("future")
[11:00:08.097]                             version <- ns[[".package"]][["version"]]
[11:00:08.097]                             if (is.null(version)) 
[11:00:08.097]                               version <- utils::packageVersion("future")
[11:00:08.097]                           }
[11:00:08.097]                           else {
[11:00:08.097]                             version <- NULL
[11:00:08.097]                           }
[11:00:08.097]                           if (!has_future || version < "1.8.0") {
[11:00:08.097]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:08.097]                               "", base::R.version$version.string), 
[11:00:08.097]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:08.097]                                 base::R.version$platform, 8 * 
[11:00:08.097]                                   base::.Machine$sizeof.pointer), 
[11:00:08.097]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:08.097]                                 "release", "version")], collapse = " "), 
[11:00:08.097]                               hostname = base::Sys.info()[["nodename"]])
[11:00:08.097]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:08.097]                               info)
[11:00:08.097]                             info <- base::paste(info, collapse = "; ")
[11:00:08.097]                             if (!has_future) {
[11:00:08.097]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:08.097]                                 info)
[11:00:08.097]                             }
[11:00:08.097]                             else {
[11:00:08.097]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:08.097]                                 info, version)
[11:00:08.097]                             }
[11:00:08.097]                             base::stop(msg)
[11:00:08.097]                           }
[11:00:08.097]                         })
[11:00:08.097]                       }
[11:00:08.097]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:08.097]                       base::options(mc.cores = 1L)
[11:00:08.097]                     }
[11:00:08.097]                     base::local({
[11:00:08.097]                       for (pkg in "future.apply") {
[11:00:08.097]                         base::loadNamespace(pkg)
[11:00:08.097]                         base::library(pkg, character.only = TRUE)
[11:00:08.097]                       }
[11:00:08.097]                     })
[11:00:08.097]                   }
[11:00:08.097]                   ...future.strategy.old <- future::plan("list")
[11:00:08.097]                   options(future.plan = NULL)
[11:00:08.097]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:08.097]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:08.097]                 }
[11:00:08.097]                 ...future.workdir <- getwd()
[11:00:08.097]             }
[11:00:08.097]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:08.097]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:08.097]         }
[11:00:08.097]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:08.097]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:08.097]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:08.097]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:08.097]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:08.097]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:08.097]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:08.097]             base::names(...future.oldOptions))
[11:00:08.097]     }
[11:00:08.097]     if (FALSE) {
[11:00:08.097]     }
[11:00:08.097]     else {
[11:00:08.097]         if (TRUE) {
[11:00:08.097]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:08.097]                 open = "w")
[11:00:08.097]         }
[11:00:08.097]         else {
[11:00:08.097]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:08.097]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:08.097]         }
[11:00:08.097]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:08.097]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:08.097]             base::sink(type = "output", split = FALSE)
[11:00:08.097]             base::close(...future.stdout)
[11:00:08.097]         }, add = TRUE)
[11:00:08.097]     }
[11:00:08.097]     ...future.frame <- base::sys.nframe()
[11:00:08.097]     ...future.conditions <- base::list()
[11:00:08.097]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:08.097]     if (FALSE) {
[11:00:08.097]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:08.097]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:08.097]     }
[11:00:08.097]     ...future.result <- base::tryCatch({
[11:00:08.097]         base::withCallingHandlers({
[11:00:08.097]             ...future.value <- base::withVisible(base::local({
[11:00:08.097]                 ...future.makeSendCondition <- base::local({
[11:00:08.097]                   sendCondition <- NULL
[11:00:08.097]                   function(frame = 1L) {
[11:00:08.097]                     if (is.function(sendCondition)) 
[11:00:08.097]                       return(sendCondition)
[11:00:08.097]                     ns <- getNamespace("parallel")
[11:00:08.097]                     if (exists("sendData", mode = "function", 
[11:00:08.097]                       envir = ns)) {
[11:00:08.097]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:08.097]                         envir = ns)
[11:00:08.097]                       envir <- sys.frame(frame)
[11:00:08.097]                       master <- NULL
[11:00:08.097]                       while (!identical(envir, .GlobalEnv) && 
[11:00:08.097]                         !identical(envir, emptyenv())) {
[11:00:08.097]                         if (exists("master", mode = "list", envir = envir, 
[11:00:08.097]                           inherits = FALSE)) {
[11:00:08.097]                           master <- get("master", mode = "list", 
[11:00:08.097]                             envir = envir, inherits = FALSE)
[11:00:08.097]                           if (inherits(master, c("SOCKnode", 
[11:00:08.097]                             "SOCK0node"))) {
[11:00:08.097]                             sendCondition <<- function(cond) {
[11:00:08.097]                               data <- list(type = "VALUE", value = cond, 
[11:00:08.097]                                 success = TRUE)
[11:00:08.097]                               parallel_sendData(master, data)
[11:00:08.097]                             }
[11:00:08.097]                             return(sendCondition)
[11:00:08.097]                           }
[11:00:08.097]                         }
[11:00:08.097]                         frame <- frame + 1L
[11:00:08.097]                         envir <- sys.frame(frame)
[11:00:08.097]                       }
[11:00:08.097]                     }
[11:00:08.097]                     sendCondition <<- function(cond) NULL
[11:00:08.097]                   }
[11:00:08.097]                 })
[11:00:08.097]                 withCallingHandlers({
[11:00:08.097]                   {
[11:00:08.097]                     do.call(function(...) {
[11:00:08.097]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:08.097]                       if (!identical(...future.globals.maxSize.org, 
[11:00:08.097]                         ...future.globals.maxSize)) {
[11:00:08.097]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:08.097]                         on.exit(options(oopts), add = TRUE)
[11:00:08.097]                       }
[11:00:08.097]                       {
[11:00:08.097]                         lapply(seq_along(...future.elements_ii), 
[11:00:08.097]                           FUN = function(jj) {
[11:00:08.097]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:08.097]                             ...future.FUN(...future.X_jj, ...)
[11:00:08.097]                           })
[11:00:08.097]                       }
[11:00:08.097]                     }, args = future.call.arguments)
[11:00:08.097]                   }
[11:00:08.097]                 }, immediateCondition = function(cond) {
[11:00:08.097]                   sendCondition <- ...future.makeSendCondition()
[11:00:08.097]                   sendCondition(cond)
[11:00:08.097]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:08.097]                   {
[11:00:08.097]                     inherits <- base::inherits
[11:00:08.097]                     invokeRestart <- base::invokeRestart
[11:00:08.097]                     is.null <- base::is.null
[11:00:08.097]                     muffled <- FALSE
[11:00:08.097]                     if (inherits(cond, "message")) {
[11:00:08.097]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:08.097]                       if (muffled) 
[11:00:08.097]                         invokeRestart("muffleMessage")
[11:00:08.097]                     }
[11:00:08.097]                     else if (inherits(cond, "warning")) {
[11:00:08.097]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:08.097]                       if (muffled) 
[11:00:08.097]                         invokeRestart("muffleWarning")
[11:00:08.097]                     }
[11:00:08.097]                     else if (inherits(cond, "condition")) {
[11:00:08.097]                       if (!is.null(pattern)) {
[11:00:08.097]                         computeRestarts <- base::computeRestarts
[11:00:08.097]                         grepl <- base::grepl
[11:00:08.097]                         restarts <- computeRestarts(cond)
[11:00:08.097]                         for (restart in restarts) {
[11:00:08.097]                           name <- restart$name
[11:00:08.097]                           if (is.null(name)) 
[11:00:08.097]                             next
[11:00:08.097]                           if (!grepl(pattern, name)) 
[11:00:08.097]                             next
[11:00:08.097]                           invokeRestart(restart)
[11:00:08.097]                           muffled <- TRUE
[11:00:08.097]                           break
[11:00:08.097]                         }
[11:00:08.097]                       }
[11:00:08.097]                     }
[11:00:08.097]                     invisible(muffled)
[11:00:08.097]                   }
[11:00:08.097]                   muffleCondition(cond)
[11:00:08.097]                 })
[11:00:08.097]             }))
[11:00:08.097]             future::FutureResult(value = ...future.value$value, 
[11:00:08.097]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:08.097]                   ...future.rng), globalenv = if (FALSE) 
[11:00:08.097]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:08.097]                     ...future.globalenv.names))
[11:00:08.097]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:08.097]         }, condition = base::local({
[11:00:08.097]             c <- base::c
[11:00:08.097]             inherits <- base::inherits
[11:00:08.097]             invokeRestart <- base::invokeRestart
[11:00:08.097]             length <- base::length
[11:00:08.097]             list <- base::list
[11:00:08.097]             seq.int <- base::seq.int
[11:00:08.097]             signalCondition <- base::signalCondition
[11:00:08.097]             sys.calls <- base::sys.calls
[11:00:08.097]             `[[` <- base::`[[`
[11:00:08.097]             `+` <- base::`+`
[11:00:08.097]             `<<-` <- base::`<<-`
[11:00:08.097]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:08.097]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:08.097]                   3L)]
[11:00:08.097]             }
[11:00:08.097]             function(cond) {
[11:00:08.097]                 is_error <- inherits(cond, "error")
[11:00:08.097]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:08.097]                   NULL)
[11:00:08.097]                 if (is_error) {
[11:00:08.097]                   sessionInformation <- function() {
[11:00:08.097]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:08.097]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:08.097]                       search = base::search(), system = base::Sys.info())
[11:00:08.097]                   }
[11:00:08.097]                   ...future.conditions[[length(...future.conditions) + 
[11:00:08.097]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:08.097]                     cond$call), session = sessionInformation(), 
[11:00:08.097]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:08.097]                   signalCondition(cond)
[11:00:08.097]                 }
[11:00:08.097]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:08.097]                 "immediateCondition"))) {
[11:00:08.097]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:08.097]                   ...future.conditions[[length(...future.conditions) + 
[11:00:08.097]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:08.097]                   if (TRUE && !signal) {
[11:00:08.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:08.097]                     {
[11:00:08.097]                       inherits <- base::inherits
[11:00:08.097]                       invokeRestart <- base::invokeRestart
[11:00:08.097]                       is.null <- base::is.null
[11:00:08.097]                       muffled <- FALSE
[11:00:08.097]                       if (inherits(cond, "message")) {
[11:00:08.097]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:08.097]                         if (muffled) 
[11:00:08.097]                           invokeRestart("muffleMessage")
[11:00:08.097]                       }
[11:00:08.097]                       else if (inherits(cond, "warning")) {
[11:00:08.097]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:08.097]                         if (muffled) 
[11:00:08.097]                           invokeRestart("muffleWarning")
[11:00:08.097]                       }
[11:00:08.097]                       else if (inherits(cond, "condition")) {
[11:00:08.097]                         if (!is.null(pattern)) {
[11:00:08.097]                           computeRestarts <- base::computeRestarts
[11:00:08.097]                           grepl <- base::grepl
[11:00:08.097]                           restarts <- computeRestarts(cond)
[11:00:08.097]                           for (restart in restarts) {
[11:00:08.097]                             name <- restart$name
[11:00:08.097]                             if (is.null(name)) 
[11:00:08.097]                               next
[11:00:08.097]                             if (!grepl(pattern, name)) 
[11:00:08.097]                               next
[11:00:08.097]                             invokeRestart(restart)
[11:00:08.097]                             muffled <- TRUE
[11:00:08.097]                             break
[11:00:08.097]                           }
[11:00:08.097]                         }
[11:00:08.097]                       }
[11:00:08.097]                       invisible(muffled)
[11:00:08.097]                     }
[11:00:08.097]                     muffleCondition(cond, pattern = "^muffle")
[11:00:08.097]                   }
[11:00:08.097]                 }
[11:00:08.097]                 else {
[11:00:08.097]                   if (TRUE) {
[11:00:08.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:08.097]                     {
[11:00:08.097]                       inherits <- base::inherits
[11:00:08.097]                       invokeRestart <- base::invokeRestart
[11:00:08.097]                       is.null <- base::is.null
[11:00:08.097]                       muffled <- FALSE
[11:00:08.097]                       if (inherits(cond, "message")) {
[11:00:08.097]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:08.097]                         if (muffled) 
[11:00:08.097]                           invokeRestart("muffleMessage")
[11:00:08.097]                       }
[11:00:08.097]                       else if (inherits(cond, "warning")) {
[11:00:08.097]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:08.097]                         if (muffled) 
[11:00:08.097]                           invokeRestart("muffleWarning")
[11:00:08.097]                       }
[11:00:08.097]                       else if (inherits(cond, "condition")) {
[11:00:08.097]                         if (!is.null(pattern)) {
[11:00:08.097]                           computeRestarts <- base::computeRestarts
[11:00:08.097]                           grepl <- base::grepl
[11:00:08.097]                           restarts <- computeRestarts(cond)
[11:00:08.097]                           for (restart in restarts) {
[11:00:08.097]                             name <- restart$name
[11:00:08.097]                             if (is.null(name)) 
[11:00:08.097]                               next
[11:00:08.097]                             if (!grepl(pattern, name)) 
[11:00:08.097]                               next
[11:00:08.097]                             invokeRestart(restart)
[11:00:08.097]                             muffled <- TRUE
[11:00:08.097]                             break
[11:00:08.097]                           }
[11:00:08.097]                         }
[11:00:08.097]                       }
[11:00:08.097]                       invisible(muffled)
[11:00:08.097]                     }
[11:00:08.097]                     muffleCondition(cond, pattern = "^muffle")
[11:00:08.097]                   }
[11:00:08.097]                 }
[11:00:08.097]             }
[11:00:08.097]         }))
[11:00:08.097]     }, error = function(ex) {
[11:00:08.097]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:08.097]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:08.097]                 ...future.rng), started = ...future.startTime, 
[11:00:08.097]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:08.097]             version = "1.8"), class = "FutureResult")
[11:00:08.097]     }, finally = {
[11:00:08.097]         if (!identical(...future.workdir, getwd())) 
[11:00:08.097]             setwd(...future.workdir)
[11:00:08.097]         {
[11:00:08.097]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:08.097]                 ...future.oldOptions$nwarnings <- NULL
[11:00:08.097]             }
[11:00:08.097]             base::options(...future.oldOptions)
[11:00:08.097]             if (.Platform$OS.type == "windows") {
[11:00:08.097]                 old_names <- names(...future.oldEnvVars)
[11:00:08.097]                 envs <- base::Sys.getenv()
[11:00:08.097]                 names <- names(envs)
[11:00:08.097]                 common <- intersect(names, old_names)
[11:00:08.097]                 added <- setdiff(names, old_names)
[11:00:08.097]                 removed <- setdiff(old_names, names)
[11:00:08.097]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:08.097]                   envs[common]]
[11:00:08.097]                 NAMES <- toupper(changed)
[11:00:08.097]                 args <- list()
[11:00:08.097]                 for (kk in seq_along(NAMES)) {
[11:00:08.097]                   name <- changed[[kk]]
[11:00:08.097]                   NAME <- NAMES[[kk]]
[11:00:08.097]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:08.097]                     next
[11:00:08.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:08.097]                 }
[11:00:08.097]                 NAMES <- toupper(added)
[11:00:08.097]                 for (kk in seq_along(NAMES)) {
[11:00:08.097]                   name <- added[[kk]]
[11:00:08.097]                   NAME <- NAMES[[kk]]
[11:00:08.097]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:08.097]                     next
[11:00:08.097]                   args[[name]] <- ""
[11:00:08.097]                 }
[11:00:08.097]                 NAMES <- toupper(removed)
[11:00:08.097]                 for (kk in seq_along(NAMES)) {
[11:00:08.097]                   name <- removed[[kk]]
[11:00:08.097]                   NAME <- NAMES[[kk]]
[11:00:08.097]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:08.097]                     next
[11:00:08.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:08.097]                 }
[11:00:08.097]                 if (length(args) > 0) 
[11:00:08.097]                   base::do.call(base::Sys.setenv, args = args)
[11:00:08.097]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:08.097]             }
[11:00:08.097]             else {
[11:00:08.097]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:08.097]             }
[11:00:08.097]             {
[11:00:08.097]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:08.097]                   0L) {
[11:00:08.097]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:08.097]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:08.097]                   base::options(opts)
[11:00:08.097]                 }
[11:00:08.097]                 {
[11:00:08.097]                   {
[11:00:08.097]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:08.097]                     NULL
[11:00:08.097]                   }
[11:00:08.097]                   options(future.plan = NULL)
[11:00:08.097]                   if (is.na(NA_character_)) 
[11:00:08.097]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:08.097]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:08.097]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:08.097]                     .init = FALSE)
[11:00:08.097]                 }
[11:00:08.097]             }
[11:00:08.097]         }
[11:00:08.097]     })
[11:00:08.097]     if (TRUE) {
[11:00:08.097]         base::sink(type = "output", split = FALSE)
[11:00:08.097]         if (TRUE) {
[11:00:08.097]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:08.097]         }
[11:00:08.097]         else {
[11:00:08.097]             ...future.result["stdout"] <- base::list(NULL)
[11:00:08.097]         }
[11:00:08.097]         base::close(...future.stdout)
[11:00:08.097]         ...future.stdout <- NULL
[11:00:08.097]     }
[11:00:08.097]     ...future.result$conditions <- ...future.conditions
[11:00:08.097]     ...future.result$finished <- base::Sys.time()
[11:00:08.097]     ...future.result
[11:00:08.097] }
[11:00:08.100] Exporting 11 global objects (14.80 KiB) to cluster node #2 ...
[11:00:08.100] Exporting ‘...future.FUN’ (5.67 KiB) to cluster node #2 ...
[11:00:08.141] Exporting ‘...future.FUN’ (5.67 KiB) to cluster node #2 ... DONE
[11:00:08.141] Exporting ‘x_FUN’ (680 bytes) to cluster node #2 ...
[11:00:08.141] Exporting ‘x_FUN’ (680 bytes) to cluster node #2 ... DONE
[11:00:08.141] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[11:00:08.142] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[11:00:08.142] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[11:00:08.183] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[11:00:08.183] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[11:00:08.224] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[11:00:08.224] Exporting ‘dim’ (39 bytes) to cluster node #2 ...
[11:00:08.224] Exporting ‘dim’ (39 bytes) to cluster node #2 ... DONE
[11:00:08.224] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[11:00:08.225] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[11:00:08.225] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #2 ...
[11:00:08.225] Exporting ‘future.call.arguments’ (183 bytes) to cluster node #2 ... DONE
[11:00:08.225] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #2 ...
[11:00:08.226] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #2 ... DONE
[11:00:08.226] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[11:00:08.226] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[11:00:08.226] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[11:00:08.227] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[11:00:08.227] Exporting 11 global objects (14.80 KiB) to cluster node #2 ... DONE
[11:00:08.227] MultisessionFuture started
[11:00:08.227] - Launch lazy future ... done
[11:00:08.227] run() for ‘MultisessionFuture’ ... done
[11:00:08.227] Created future:
[11:00:08.228] MultisessionFuture:
[11:00:08.228] Label: ‘future_vapply-2’
[11:00:08.228] Expression:
[11:00:08.228] {
[11:00:08.228]     do.call(function(...) {
[11:00:08.228]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:08.228]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:08.228]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:08.228]             on.exit(options(oopts), add = TRUE)
[11:00:08.228]         }
[11:00:08.228]         {
[11:00:08.228]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:08.228]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:08.228]                 ...future.FUN(...future.X_jj, ...)
[11:00:08.228]             })
[11:00:08.228]         }
[11:00:08.228]     }, args = future.call.arguments)
[11:00:08.228] }
[11:00:08.228] Lazy evaluation: FALSE
[11:00:08.228] Asynchronous evaluation: TRUE
[11:00:08.228] Local evaluation: TRUE
[11:00:08.228] Environment: R_GlobalEnv
[11:00:08.228] Capture standard output: TRUE
[11:00:08.228] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:08.228] Globals: 11 objects totaling 14.66 KiB (function ‘...future.FUN’ of 5.67 KiB, function ‘x_FUN’ of 680 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:08.228] Packages: 1 packages (‘future.apply’)
[11:00:08.228] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:08.228] Resolved: FALSE
[11:00:08.228] Value: <not collected>
[11:00:08.228] Conditions captured: <none>
[11:00:08.228] Early signaling: FALSE
[11:00:08.228] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:08.228] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:08.239] Chunk #2 of 2 ... DONE
[11:00:08.239] Launching 2 futures (chunks) ... DONE
[11:00:08.239] Resolving 2 futures (chunks) ...
[11:00:08.239] resolve() on list ...
[11:00:08.239]  recursive: 0
[11:00:08.240]  length: 2
[11:00:08.240] 
[11:00:08.240] receiveMessageFromWorker() for ClusterFuture ...
[11:00:08.240] - Validating connection of MultisessionFuture
[11:00:08.240] - received message: FutureResult
[11:00:08.240] - Received FutureResult
[11:00:08.240] - Erased future from FutureRegistry
[11:00:08.241] result() for ClusterFuture ...
[11:00:08.241] - result already collected: FutureResult
[11:00:08.241] result() for ClusterFuture ... done
[11:00:08.241] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:08.241] Future #1
[11:00:08.241] result() for ClusterFuture ...
[11:00:08.241] - result already collected: FutureResult
[11:00:08.241] result() for ClusterFuture ... done
[11:00:08.241] result() for ClusterFuture ...
[11:00:08.241] - result already collected: FutureResult
[11:00:08.241] result() for ClusterFuture ... done
[11:00:08.241] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:00:08.242] - nx: 2
[11:00:08.242] - relay: TRUE
[11:00:08.242] - stdout: TRUE
[11:00:08.242] - signal: TRUE
[11:00:08.242] - resignal: FALSE
[11:00:08.242] - force: TRUE
[11:00:08.242] - relayed: [n=2] FALSE, FALSE
[11:00:08.242] - queued futures: [n=2] FALSE, FALSE
[11:00:08.242]  - until=1
[11:00:08.242]  - relaying element #1
[11:00:08.242] result() for ClusterFuture ...
[11:00:08.242] - result already collected: FutureResult
[11:00:08.242] result() for ClusterFuture ... done
[11:00:08.243] result() for ClusterFuture ...
[11:00:08.243] - result already collected: FutureResult
[11:00:08.243] result() for ClusterFuture ... done
[11:00:08.243] result() for ClusterFuture ...
[11:00:08.243] - result already collected: FutureResult
[11:00:08.243] result() for ClusterFuture ... done
[11:00:08.243] result() for ClusterFuture ...
[11:00:08.243] - result already collected: FutureResult
[11:00:08.243] result() for ClusterFuture ... done
[11:00:08.243] - relayed: [n=2] TRUE, FALSE
[11:00:08.243] - queued futures: [n=2] TRUE, FALSE
[11:00:08.243] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:00:08.244]  length: 1 (resolved future 1)
[11:00:08.269] receiveMessageFromWorker() for ClusterFuture ...
[11:00:08.270] - Validating connection of MultisessionFuture
[11:00:08.270] - received message: FutureResult
[11:00:08.270] - Received FutureResult
[11:00:08.270] - Erased future from FutureRegistry
[11:00:08.270] result() for ClusterFuture ...
[11:00:08.270] - result already collected: FutureResult
[11:00:08.270] result() for ClusterFuture ... done
[11:00:08.270] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:08.270] Future #2
[11:00:08.270] result() for ClusterFuture ...
[11:00:08.270] - result already collected: FutureResult
[11:00:08.271] result() for ClusterFuture ... done
[11:00:08.271] result() for ClusterFuture ...
[11:00:08.271] - result already collected: FutureResult
[11:00:08.271] result() for ClusterFuture ... done
[11:00:08.271] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:00:08.271] - nx: 2
[11:00:08.271] - relay: TRUE
[11:00:08.271] - stdout: TRUE
[11:00:08.271] - signal: TRUE
[11:00:08.271] - resignal: FALSE
[11:00:08.271] - force: TRUE
[11:00:08.271] - relayed: [n=2] TRUE, FALSE
[11:00:08.271] - queued futures: [n=2] TRUE, FALSE
[11:00:08.272]  - until=2
[11:00:08.272]  - relaying element #2
[11:00:08.272] result() for ClusterFuture ...
[11:00:08.272] - result already collected: FutureResult
[11:00:08.272] result() for ClusterFuture ... done
[11:00:08.272] result() for ClusterFuture ...
[11:00:08.272] - result already collected: FutureResult
[11:00:08.272] result() for ClusterFuture ... done
[11:00:08.272] result() for ClusterFuture ...
[11:00:08.272] - result already collected: FutureResult
[11:00:08.272] result() for ClusterFuture ... done
[11:00:08.272] result() for ClusterFuture ...
[11:00:08.273] - result already collected: FutureResult
[11:00:08.273] result() for ClusterFuture ... done
[11:00:08.273] - relayed: [n=2] TRUE, TRUE
[11:00:08.273] - queued futures: [n=2] TRUE, TRUE
[11:00:08.273] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:00:08.273]  length: 0 (resolved future 2)
[11:00:08.273] Relaying remaining futures
[11:00:08.273] signalConditionsASAP(NULL, pos=0) ...
[11:00:08.273] - nx: 2
[11:00:08.273] - relay: TRUE
[11:00:08.273] - stdout: TRUE
[11:00:08.273] - signal: TRUE
[11:00:08.273] - resignal: FALSE
[11:00:08.274] - force: TRUE
[11:00:08.274] - relayed: [n=2] TRUE, TRUE
[11:00:08.274] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:08.274] - relayed: [n=2] TRUE, TRUE
[11:00:08.274] - queued futures: [n=2] TRUE, TRUE
[11:00:08.274] signalConditionsASAP(NULL, pos=0) ... done
[11:00:08.274] resolve() on list ... DONE
[11:00:08.274] result() for ClusterFuture ...
[11:00:08.274] - result already collected: FutureResult
[11:00:08.274] result() for ClusterFuture ... done
[11:00:08.274] result() for ClusterFuture ...
[11:00:08.274] - result already collected: FutureResult
[11:00:08.275] result() for ClusterFuture ... done
[11:00:08.275] result() for ClusterFuture ...
[11:00:08.275] - result already collected: FutureResult
[11:00:08.275] result() for ClusterFuture ... done
[11:00:08.275] result() for ClusterFuture ...
[11:00:08.275] - result already collected: FutureResult
[11:00:08.275] result() for ClusterFuture ... done
[11:00:08.275]  - Number of value chunks collected: 2
[11:00:08.275] Resolving 2 futures (chunks) ... DONE
[11:00:08.275] Reducing values from 2 chunks ...
[11:00:08.275]  - Number of values collected after concatenation: 4
[11:00:08.275]  - Number of values expected: 4
[11:00:08.276] Reducing values from 2 chunks ... DONE
[11:00:08.276] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[11:00:08.277] future_lapply() ...
[11:00:08.280] Number of chunks: 2
[11:00:08.280] getGlobalsAndPackagesXApply() ...
[11:00:08.281]  - future.globals: TRUE
[11:00:08.281] getGlobalsAndPackages() ...
[11:00:08.281] Searching for globals...
[11:00:08.284] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[11:00:08.284] Searching for globals ... DONE
[11:00:08.284] Resolving globals: FALSE
[11:00:08.285] The total size of the 7 globals is 14.73 KiB (15079 bytes)
[11:00:08.285] The total size of the 7 globals exported for future expression (‘FUN()’) is 14.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (6.74 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:08.285] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:08.285] - packages: [1] ‘future.apply’
[11:00:08.285] getGlobalsAndPackages() ... DONE
[11:00:08.285]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:08.285]  - needed namespaces: [n=1] ‘future.apply’
[11:00:08.286] Finding globals ... DONE
[11:00:08.286]  - use_args: TRUE
[11:00:08.286]  - Getting '...' globals ...
[11:00:08.288] resolve() on list ...
[11:00:08.288]  recursive: 0
[11:00:08.288]  length: 1
[11:00:08.288]  elements: ‘...’
[11:00:08.288]  length: 0 (resolved future 1)
[11:00:08.288] resolve() on list ... DONE
[11:00:08.288]    - '...' content: [n=0] 
[11:00:08.288] List of 1
[11:00:08.288]  $ ...: list()
[11:00:08.288]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:08.288]  - attr(*, "where")=List of 1
[11:00:08.288]   ..$ ...:<environment: 0x55bbad604318> 
[11:00:08.288]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:08.288]  - attr(*, "resolved")= logi TRUE
[11:00:08.288]  - attr(*, "total_size")= num NA
[11:00:08.291]  - Getting '...' globals ... DONE
[11:00:08.291] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:08.291] List of 8
[11:00:08.291]  $ ...future.FUN:function (x, ...)  
[11:00:08.291]  $ x_FUN        :function (x)  
[11:00:08.291]  $ times        : int 1
[11:00:08.291]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:08.291]  $ stop_if_not  :function (...)  
[11:00:08.291]  $ dim          : NULL
[11:00:08.291]  $ valid_types  : chr "logical"
[11:00:08.291]  $ ...          : list()
[11:00:08.291]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:08.291]  - attr(*, "where")=List of 8
[11:00:08.291]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:08.291]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:08.291]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:08.291]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:08.291]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:08.291]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:08.291]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:08.291]   ..$ ...          :<environment: 0x55bbad604318> 
[11:00:08.291]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:08.291]  - attr(*, "resolved")= logi FALSE
[11:00:08.291]  - attr(*, "total_size")= num 30734
[11:00:08.296] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:08.296] getGlobalsAndPackagesXApply() ... DONE
[11:00:08.296] Number of futures (= number of chunks): 2
[11:00:08.296] Launching 2 futures (chunks) ...
[11:00:08.296] Chunk #1 of 2 ...
[11:00:08.296]  - Finding globals in 'X' for chunk #1 ...
[11:00:08.296] getGlobalsAndPackages() ...
[11:00:08.297] Searching for globals...
[11:00:08.297] 
[11:00:08.297] Searching for globals ... DONE
[11:00:08.297] - globals: [0] <none>
[11:00:08.297] getGlobalsAndPackages() ... DONE
[11:00:08.297]    + additional globals found: [n=0] 
[11:00:08.297]    + additional namespaces needed: [n=0] 
[11:00:08.297]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:08.297]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:08.297]  - seeds: <none>
[11:00:08.298]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:08.298] getGlobalsAndPackages() ...
[11:00:08.298] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:08.298] Resolving globals: FALSE
[11:00:08.298] Tweak future expression to call with '...' arguments ...
[11:00:08.298] {
[11:00:08.298]     do.call(function(...) {
[11:00:08.298]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:08.298]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:08.298]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:08.298]             on.exit(options(oopts), add = TRUE)
[11:00:08.298]         }
[11:00:08.298]         {
[11:00:08.298]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:08.298]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:08.298]                 ...future.FUN(...future.X_jj, ...)
[11:00:08.298]             })
[11:00:08.298]         }
[11:00:08.298]     }, args = future.call.arguments)
[11:00:08.298] }
[11:00:08.298] Tweak future expression to call with '...' arguments ... DONE
[11:00:08.299] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:08.299] - packages: [1] ‘future.apply’
[11:00:08.299] getGlobalsAndPackages() ... DONE
[11:00:08.299] run() for ‘Future’ ...
[11:00:08.299] - state: ‘created’
[11:00:08.299] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:08.313] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:08.313] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:08.313]   - Field: ‘node’
[11:00:08.313]   - Field: ‘label’
[11:00:08.313]   - Field: ‘local’
[11:00:08.313]   - Field: ‘owner’
[11:00:08.313]   - Field: ‘envir’
[11:00:08.313]   - Field: ‘workers’
[11:00:08.313]   - Field: ‘packages’
[11:00:08.314]   - Field: ‘gc’
[11:00:08.314]   - Field: ‘conditions’
[11:00:08.314]   - Field: ‘persistent’
[11:00:08.314]   - Field: ‘expr’
[11:00:08.314]   - Field: ‘uuid’
[11:00:08.314]   - Field: ‘seed’
[11:00:08.314]   - Field: ‘version’
[11:00:08.314]   - Field: ‘result’
[11:00:08.314]   - Field: ‘asynchronous’
[11:00:08.314]   - Field: ‘calls’
[11:00:08.314]   - Field: ‘globals’
[11:00:08.314]   - Field: ‘stdout’
[11:00:08.314]   - Field: ‘earlySignal’
[11:00:08.315]   - Field: ‘lazy’
[11:00:08.315]   - Field: ‘state’
[11:00:08.315] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:08.315] - Launch lazy future ...
[11:00:08.315] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:08.315] Packages needed by future strategies (n = 0): <none>
[11:00:08.316] {
[11:00:08.316]     {
[11:00:08.316]         {
[11:00:08.316]             ...future.startTime <- base::Sys.time()
[11:00:08.316]             {
[11:00:08.316]                 {
[11:00:08.316]                   {
[11:00:08.316]                     {
[11:00:08.316]                       {
[11:00:08.316]                         base::local({
[11:00:08.316]                           has_future <- base::requireNamespace("future", 
[11:00:08.316]                             quietly = TRUE)
[11:00:08.316]                           if (has_future) {
[11:00:08.316]                             ns <- base::getNamespace("future")
[11:00:08.316]                             version <- ns[[".package"]][["version"]]
[11:00:08.316]                             if (is.null(version)) 
[11:00:08.316]                               version <- utils::packageVersion("future")
[11:00:08.316]                           }
[11:00:08.316]                           else {
[11:00:08.316]                             version <- NULL
[11:00:08.316]                           }
[11:00:08.316]                           if (!has_future || version < "1.8.0") {
[11:00:08.316]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:08.316]                               "", base::R.version$version.string), 
[11:00:08.316]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:08.316]                                 base::R.version$platform, 8 * 
[11:00:08.316]                                   base::.Machine$sizeof.pointer), 
[11:00:08.316]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:08.316]                                 "release", "version")], collapse = " "), 
[11:00:08.316]                               hostname = base::Sys.info()[["nodename"]])
[11:00:08.316]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:08.316]                               info)
[11:00:08.316]                             info <- base::paste(info, collapse = "; ")
[11:00:08.316]                             if (!has_future) {
[11:00:08.316]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:08.316]                                 info)
[11:00:08.316]                             }
[11:00:08.316]                             else {
[11:00:08.316]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:08.316]                                 info, version)
[11:00:08.316]                             }
[11:00:08.316]                             base::stop(msg)
[11:00:08.316]                           }
[11:00:08.316]                         })
[11:00:08.316]                       }
[11:00:08.316]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:08.316]                       base::options(mc.cores = 1L)
[11:00:08.316]                     }
[11:00:08.316]                     base::local({
[11:00:08.316]                       for (pkg in "future.apply") {
[11:00:08.316]                         base::loadNamespace(pkg)
[11:00:08.316]                         base::library(pkg, character.only = TRUE)
[11:00:08.316]                       }
[11:00:08.316]                     })
[11:00:08.316]                   }
[11:00:08.316]                   ...future.strategy.old <- future::plan("list")
[11:00:08.316]                   options(future.plan = NULL)
[11:00:08.316]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:08.316]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:08.316]                 }
[11:00:08.316]                 ...future.workdir <- getwd()
[11:00:08.316]             }
[11:00:08.316]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:08.316]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:08.316]         }
[11:00:08.316]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:08.316]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:08.316]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:08.316]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:08.316]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:08.316]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:08.316]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:08.316]             base::names(...future.oldOptions))
[11:00:08.316]     }
[11:00:08.316]     if (FALSE) {
[11:00:08.316]     }
[11:00:08.316]     else {
[11:00:08.316]         if (TRUE) {
[11:00:08.316]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:08.316]                 open = "w")
[11:00:08.316]         }
[11:00:08.316]         else {
[11:00:08.316]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:08.316]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:08.316]         }
[11:00:08.316]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:08.316]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:08.316]             base::sink(type = "output", split = FALSE)
[11:00:08.316]             base::close(...future.stdout)
[11:00:08.316]         }, add = TRUE)
[11:00:08.316]     }
[11:00:08.316]     ...future.frame <- base::sys.nframe()
[11:00:08.316]     ...future.conditions <- base::list()
[11:00:08.316]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:08.316]     if (FALSE) {
[11:00:08.316]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:08.316]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:08.316]     }
[11:00:08.316]     ...future.result <- base::tryCatch({
[11:00:08.316]         base::withCallingHandlers({
[11:00:08.316]             ...future.value <- base::withVisible(base::local({
[11:00:08.316]                 ...future.makeSendCondition <- base::local({
[11:00:08.316]                   sendCondition <- NULL
[11:00:08.316]                   function(frame = 1L) {
[11:00:08.316]                     if (is.function(sendCondition)) 
[11:00:08.316]                       return(sendCondition)
[11:00:08.316]                     ns <- getNamespace("parallel")
[11:00:08.316]                     if (exists("sendData", mode = "function", 
[11:00:08.316]                       envir = ns)) {
[11:00:08.316]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:08.316]                         envir = ns)
[11:00:08.316]                       envir <- sys.frame(frame)
[11:00:08.316]                       master <- NULL
[11:00:08.316]                       while (!identical(envir, .GlobalEnv) && 
[11:00:08.316]                         !identical(envir, emptyenv())) {
[11:00:08.316]                         if (exists("master", mode = "list", envir = envir, 
[11:00:08.316]                           inherits = FALSE)) {
[11:00:08.316]                           master <- get("master", mode = "list", 
[11:00:08.316]                             envir = envir, inherits = FALSE)
[11:00:08.316]                           if (inherits(master, c("SOCKnode", 
[11:00:08.316]                             "SOCK0node"))) {
[11:00:08.316]                             sendCondition <<- function(cond) {
[11:00:08.316]                               data <- list(type = "VALUE", value = cond, 
[11:00:08.316]                                 success = TRUE)
[11:00:08.316]                               parallel_sendData(master, data)
[11:00:08.316]                             }
[11:00:08.316]                             return(sendCondition)
[11:00:08.316]                           }
[11:00:08.316]                         }
[11:00:08.316]                         frame <- frame + 1L
[11:00:08.316]                         envir <- sys.frame(frame)
[11:00:08.316]                       }
[11:00:08.316]                     }
[11:00:08.316]                     sendCondition <<- function(cond) NULL
[11:00:08.316]                   }
[11:00:08.316]                 })
[11:00:08.316]                 withCallingHandlers({
[11:00:08.316]                   {
[11:00:08.316]                     do.call(function(...) {
[11:00:08.316]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:08.316]                       if (!identical(...future.globals.maxSize.org, 
[11:00:08.316]                         ...future.globals.maxSize)) {
[11:00:08.316]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:08.316]                         on.exit(options(oopts), add = TRUE)
[11:00:08.316]                       }
[11:00:08.316]                       {
[11:00:08.316]                         lapply(seq_along(...future.elements_ii), 
[11:00:08.316]                           FUN = function(jj) {
[11:00:08.316]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:08.316]                             ...future.FUN(...future.X_jj, ...)
[11:00:08.316]                           })
[11:00:08.316]                       }
[11:00:08.316]                     }, args = future.call.arguments)
[11:00:08.316]                   }
[11:00:08.316]                 }, immediateCondition = function(cond) {
[11:00:08.316]                   sendCondition <- ...future.makeSendCondition()
[11:00:08.316]                   sendCondition(cond)
[11:00:08.316]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:08.316]                   {
[11:00:08.316]                     inherits <- base::inherits
[11:00:08.316]                     invokeRestart <- base::invokeRestart
[11:00:08.316]                     is.null <- base::is.null
[11:00:08.316]                     muffled <- FALSE
[11:00:08.316]                     if (inherits(cond, "message")) {
[11:00:08.316]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:08.316]                       if (muffled) 
[11:00:08.316]                         invokeRestart("muffleMessage")
[11:00:08.316]                     }
[11:00:08.316]                     else if (inherits(cond, "warning")) {
[11:00:08.316]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:08.316]                       if (muffled) 
[11:00:08.316]                         invokeRestart("muffleWarning")
[11:00:08.316]                     }
[11:00:08.316]                     else if (inherits(cond, "condition")) {
[11:00:08.316]                       if (!is.null(pattern)) {
[11:00:08.316]                         computeRestarts <- base::computeRestarts
[11:00:08.316]                         grepl <- base::grepl
[11:00:08.316]                         restarts <- computeRestarts(cond)
[11:00:08.316]                         for (restart in restarts) {
[11:00:08.316]                           name <- restart$name
[11:00:08.316]                           if (is.null(name)) 
[11:00:08.316]                             next
[11:00:08.316]                           if (!grepl(pattern, name)) 
[11:00:08.316]                             next
[11:00:08.316]                           invokeRestart(restart)
[11:00:08.316]                           muffled <- TRUE
[11:00:08.316]                           break
[11:00:08.316]                         }
[11:00:08.316]                       }
[11:00:08.316]                     }
[11:00:08.316]                     invisible(muffled)
[11:00:08.316]                   }
[11:00:08.316]                   muffleCondition(cond)
[11:00:08.316]                 })
[11:00:08.316]             }))
[11:00:08.316]             future::FutureResult(value = ...future.value$value, 
[11:00:08.316]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:08.316]                   ...future.rng), globalenv = if (FALSE) 
[11:00:08.316]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:08.316]                     ...future.globalenv.names))
[11:00:08.316]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:08.316]         }, condition = base::local({
[11:00:08.316]             c <- base::c
[11:00:08.316]             inherits <- base::inherits
[11:00:08.316]             invokeRestart <- base::invokeRestart
[11:00:08.316]             length <- base::length
[11:00:08.316]             list <- base::list
[11:00:08.316]             seq.int <- base::seq.int
[11:00:08.316]             signalCondition <- base::signalCondition
[11:00:08.316]             sys.calls <- base::sys.calls
[11:00:08.316]             `[[` <- base::`[[`
[11:00:08.316]             `+` <- base::`+`
[11:00:08.316]             `<<-` <- base::`<<-`
[11:00:08.316]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:08.316]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:08.316]                   3L)]
[11:00:08.316]             }
[11:00:08.316]             function(cond) {
[11:00:08.316]                 is_error <- inherits(cond, "error")
[11:00:08.316]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:08.316]                   NULL)
[11:00:08.316]                 if (is_error) {
[11:00:08.316]                   sessionInformation <- function() {
[11:00:08.316]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:08.316]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:08.316]                       search = base::search(), system = base::Sys.info())
[11:00:08.316]                   }
[11:00:08.316]                   ...future.conditions[[length(...future.conditions) + 
[11:00:08.316]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:08.316]                     cond$call), session = sessionInformation(), 
[11:00:08.316]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:08.316]                   signalCondition(cond)
[11:00:08.316]                 }
[11:00:08.316]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:08.316]                 "immediateCondition"))) {
[11:00:08.316]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:08.316]                   ...future.conditions[[length(...future.conditions) + 
[11:00:08.316]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:08.316]                   if (TRUE && !signal) {
[11:00:08.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:08.316]                     {
[11:00:08.316]                       inherits <- base::inherits
[11:00:08.316]                       invokeRestart <- base::invokeRestart
[11:00:08.316]                       is.null <- base::is.null
[11:00:08.316]                       muffled <- FALSE
[11:00:08.316]                       if (inherits(cond, "message")) {
[11:00:08.316]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:08.316]                         if (muffled) 
[11:00:08.316]                           invokeRestart("muffleMessage")
[11:00:08.316]                       }
[11:00:08.316]                       else if (inherits(cond, "warning")) {
[11:00:08.316]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:08.316]                         if (muffled) 
[11:00:08.316]                           invokeRestart("muffleWarning")
[11:00:08.316]                       }
[11:00:08.316]                       else if (inherits(cond, "condition")) {
[11:00:08.316]                         if (!is.null(pattern)) {
[11:00:08.316]                           computeRestarts <- base::computeRestarts
[11:00:08.316]                           grepl <- base::grepl
[11:00:08.316]                           restarts <- computeRestarts(cond)
[11:00:08.316]                           for (restart in restarts) {
[11:00:08.316]                             name <- restart$name
[11:00:08.316]                             if (is.null(name)) 
[11:00:08.316]                               next
[11:00:08.316]                             if (!grepl(pattern, name)) 
[11:00:08.316]                               next
[11:00:08.316]                             invokeRestart(restart)
[11:00:08.316]                             muffled <- TRUE
[11:00:08.316]                             break
[11:00:08.316]                           }
[11:00:08.316]                         }
[11:00:08.316]                       }
[11:00:08.316]                       invisible(muffled)
[11:00:08.316]                     }
[11:00:08.316]                     muffleCondition(cond, pattern = "^muffle")
[11:00:08.316]                   }
[11:00:08.316]                 }
[11:00:08.316]                 else {
[11:00:08.316]                   if (TRUE) {
[11:00:08.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:08.316]                     {
[11:00:08.316]                       inherits <- base::inherits
[11:00:08.316]                       invokeRestart <- base::invokeRestart
[11:00:08.316]                       is.null <- base::is.null
[11:00:08.316]                       muffled <- FALSE
[11:00:08.316]                       if (inherits(cond, "message")) {
[11:00:08.316]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:08.316]                         if (muffled) 
[11:00:08.316]                           invokeRestart("muffleMessage")
[11:00:08.316]                       }
[11:00:08.316]                       else if (inherits(cond, "warning")) {
[11:00:08.316]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:08.316]                         if (muffled) 
[11:00:08.316]                           invokeRestart("muffleWarning")
[11:00:08.316]                       }
[11:00:08.316]                       else if (inherits(cond, "condition")) {
[11:00:08.316]                         if (!is.null(pattern)) {
[11:00:08.316]                           computeRestarts <- base::computeRestarts
[11:00:08.316]                           grepl <- base::grepl
[11:00:08.316]                           restarts <- computeRestarts(cond)
[11:00:08.316]                           for (restart in restarts) {
[11:00:08.316]                             name <- restart$name
[11:00:08.316]                             if (is.null(name)) 
[11:00:08.316]                               next
[11:00:08.316]                             if (!grepl(pattern, name)) 
[11:00:08.316]                               next
[11:00:08.316]                             invokeRestart(restart)
[11:00:08.316]                             muffled <- TRUE
[11:00:08.316]                             break
[11:00:08.316]                           }
[11:00:08.316]                         }
[11:00:08.316]                       }
[11:00:08.316]                       invisible(muffled)
[11:00:08.316]                     }
[11:00:08.316]                     muffleCondition(cond, pattern = "^muffle")
[11:00:08.316]                   }
[11:00:08.316]                 }
[11:00:08.316]             }
[11:00:08.316]         }))
[11:00:08.316]     }, error = function(ex) {
[11:00:08.316]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:08.316]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:08.316]                 ...future.rng), started = ...future.startTime, 
[11:00:08.316]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:08.316]             version = "1.8"), class = "FutureResult")
[11:00:08.316]     }, finally = {
[11:00:08.316]         if (!identical(...future.workdir, getwd())) 
[11:00:08.316]             setwd(...future.workdir)
[11:00:08.316]         {
[11:00:08.316]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:08.316]                 ...future.oldOptions$nwarnings <- NULL
[11:00:08.316]             }
[11:00:08.316]             base::options(...future.oldOptions)
[11:00:08.316]             if (.Platform$OS.type == "windows") {
[11:00:08.316]                 old_names <- names(...future.oldEnvVars)
[11:00:08.316]                 envs <- base::Sys.getenv()
[11:00:08.316]                 names <- names(envs)
[11:00:08.316]                 common <- intersect(names, old_names)
[11:00:08.316]                 added <- setdiff(names, old_names)
[11:00:08.316]                 removed <- setdiff(old_names, names)
[11:00:08.316]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:08.316]                   envs[common]]
[11:00:08.316]                 NAMES <- toupper(changed)
[11:00:08.316]                 args <- list()
[11:00:08.316]                 for (kk in seq_along(NAMES)) {
[11:00:08.316]                   name <- changed[[kk]]
[11:00:08.316]                   NAME <- NAMES[[kk]]
[11:00:08.316]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:08.316]                     next
[11:00:08.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:08.316]                 }
[11:00:08.316]                 NAMES <- toupper(added)
[11:00:08.316]                 for (kk in seq_along(NAMES)) {
[11:00:08.316]                   name <- added[[kk]]
[11:00:08.316]                   NAME <- NAMES[[kk]]
[11:00:08.316]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:08.316]                     next
[11:00:08.316]                   args[[name]] <- ""
[11:00:08.316]                 }
[11:00:08.316]                 NAMES <- toupper(removed)
[11:00:08.316]                 for (kk in seq_along(NAMES)) {
[11:00:08.316]                   name <- removed[[kk]]
[11:00:08.316]                   NAME <- NAMES[[kk]]
[11:00:08.316]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:08.316]                     next
[11:00:08.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:08.316]                 }
[11:00:08.316]                 if (length(args) > 0) 
[11:00:08.316]                   base::do.call(base::Sys.setenv, args = args)
[11:00:08.316]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:08.316]             }
[11:00:08.316]             else {
[11:00:08.316]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:08.316]             }
[11:00:08.316]             {
[11:00:08.316]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:08.316]                   0L) {
[11:00:08.316]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:08.316]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:08.316]                   base::options(opts)
[11:00:08.316]                 }
[11:00:08.316]                 {
[11:00:08.316]                   {
[11:00:08.316]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:08.316]                     NULL
[11:00:08.316]                   }
[11:00:08.316]                   options(future.plan = NULL)
[11:00:08.316]                   if (is.na(NA_character_)) 
[11:00:08.316]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:08.316]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:08.316]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:08.316]                     .init = FALSE)
[11:00:08.316]                 }
[11:00:08.316]             }
[11:00:08.316]         }
[11:00:08.316]     })
[11:00:08.316]     if (TRUE) {
[11:00:08.316]         base::sink(type = "output", split = FALSE)
[11:00:08.316]         if (TRUE) {
[11:00:08.316]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:08.316]         }
[11:00:08.316]         else {
[11:00:08.316]             ...future.result["stdout"] <- base::list(NULL)
[11:00:08.316]         }
[11:00:08.316]         base::close(...future.stdout)
[11:00:08.316]         ...future.stdout <- NULL
[11:00:08.316]     }
[11:00:08.316]     ...future.result$conditions <- ...future.conditions
[11:00:08.316]     ...future.result$finished <- base::Sys.time()
[11:00:08.316]     ...future.result
[11:00:08.316] }
[11:00:08.318] Exporting 11 global objects (16.77 KiB) to cluster node #1 ...
[11:00:08.318] Exporting ‘...future.FUN’ (6.73 KiB) to cluster node #1 ...
[11:00:08.360] Exporting ‘...future.FUN’ (6.73 KiB) to cluster node #1 ... DONE
[11:00:08.360] Exporting ‘x_FUN’ (41 bytes) to cluster node #1 ...
[11:00:08.360] Exporting ‘x_FUN’ (41 bytes) to cluster node #1 ... DONE
[11:00:08.360] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[11:00:08.361] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[11:00:08.361] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[11:00:08.402] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[11:00:08.402] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[11:00:08.443] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[11:00:08.443] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[11:00:08.443] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[11:00:08.443] Exporting ‘valid_types’ (46 bytes) to cluster node #1 ...
[11:00:08.444] Exporting ‘valid_types’ (46 bytes) to cluster node #1 ... DONE
[11:00:08.444] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[11:00:08.444] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[11:00:08.444] Exporting ‘...future.elements_ii’ (1.67 KiB) to cluster node #1 ...
[11:00:08.445] Exporting ‘...future.elements_ii’ (1.67 KiB) to cluster node #1 ... DONE
[11:00:08.445] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[11:00:08.445] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[11:00:08.445] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[11:00:08.445] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[11:00:08.446] Exporting 11 global objects (16.77 KiB) to cluster node #1 ... DONE
[11:00:08.446] MultisessionFuture started
[11:00:08.446] - Launch lazy future ... done
[11:00:08.446] run() for ‘MultisessionFuture’ ... done
[11:00:08.446] Created future:
[11:00:08.446] MultisessionFuture:
[11:00:08.446] Label: ‘future_vapply-1’
[11:00:08.446] Expression:
[11:00:08.446] {
[11:00:08.446]     do.call(function(...) {
[11:00:08.446]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:08.446]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:08.446]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:08.446]             on.exit(options(oopts), add = TRUE)
[11:00:08.446]         }
[11:00:08.446]         {
[11:00:08.446]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:08.446]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:08.446]                 ...future.FUN(...future.X_jj, ...)
[11:00:08.446]             })
[11:00:08.446]         }
[11:00:08.446]     }, args = future.call.arguments)
[11:00:08.446] }
[11:00:08.446] Lazy evaluation: FALSE
[11:00:08.446] Asynchronous evaluation: TRUE
[11:00:08.446] Local evaluation: TRUE
[11:00:08.446] Environment: R_GlobalEnv
[11:00:08.446] Capture standard output: TRUE
[11:00:08.446] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:08.446] Globals: 11 objects totaling 16.54 KiB (function ‘...future.FUN’ of 6.73 KiB, function ‘x_FUN’ of 41 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:08.446] Packages: 1 packages (‘future.apply’)
[11:00:08.446] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:08.446] Resolved: FALSE
[11:00:08.446] Value: <not collected>
[11:00:08.446] Conditions captured: <none>
[11:00:08.446] Early signaling: FALSE
[11:00:08.446] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:08.446] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:08.458] Chunk #1 of 2 ... DONE
[11:00:08.458] Chunk #2 of 2 ...
[11:00:08.458]  - Finding globals in 'X' for chunk #2 ...
[11:00:08.458] getGlobalsAndPackages() ...
[11:00:08.458] Searching for globals...
[11:00:08.459] 
[11:00:08.459] Searching for globals ... DONE
[11:00:08.459] - globals: [0] <none>
[11:00:08.459] getGlobalsAndPackages() ... DONE
[11:00:08.459]    + additional globals found: [n=0] 
[11:00:08.459]    + additional namespaces needed: [n=0] 
[11:00:08.459]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:08.459]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:08.459]  - seeds: <none>
[11:00:08.460]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:08.460] getGlobalsAndPackages() ...
[11:00:08.460] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:08.460] Resolving globals: FALSE
[11:00:08.460] Tweak future expression to call with '...' arguments ...
[11:00:08.460] {
[11:00:08.460]     do.call(function(...) {
[11:00:08.460]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:08.460]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:08.460]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:08.460]             on.exit(options(oopts), add = TRUE)
[11:00:08.460]         }
[11:00:08.460]         {
[11:00:08.460]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:08.460]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:08.460]                 ...future.FUN(...future.X_jj, ...)
[11:00:08.460]             })
[11:00:08.460]         }
[11:00:08.460]     }, args = future.call.arguments)
[11:00:08.460] }
[11:00:08.460] Tweak future expression to call with '...' arguments ... DONE
[11:00:08.461] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:08.461] - packages: [1] ‘future.apply’
[11:00:08.461] getGlobalsAndPackages() ... DONE
[11:00:08.461] run() for ‘Future’ ...
[11:00:08.461] - state: ‘created’
[11:00:08.461] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:08.475] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:08.475] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:08.475]   - Field: ‘node’
[11:00:08.475]   - Field: ‘label’
[11:00:08.475]   - Field: ‘local’
[11:00:08.476]   - Field: ‘owner’
[11:00:08.476]   - Field: ‘envir’
[11:00:08.476]   - Field: ‘workers’
[11:00:08.476]   - Field: ‘packages’
[11:00:08.476]   - Field: ‘gc’
[11:00:08.476]   - Field: ‘conditions’
[11:00:08.476]   - Field: ‘persistent’
[11:00:08.476]   - Field: ‘expr’
[11:00:08.476]   - Field: ‘uuid’
[11:00:08.476]   - Field: ‘seed’
[11:00:08.476]   - Field: ‘version’
[11:00:08.477]   - Field: ‘result’
[11:00:08.477]   - Field: ‘asynchronous’
[11:00:08.477]   - Field: ‘calls’
[11:00:08.477]   - Field: ‘globals’
[11:00:08.477]   - Field: ‘stdout’
[11:00:08.477]   - Field: ‘earlySignal’
[11:00:08.478]   - Field: ‘lazy’
[11:00:08.478]   - Field: ‘state’
[11:00:08.478] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:08.478] - Launch lazy future ...
[11:00:08.478] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:08.478] Packages needed by future strategies (n = 0): <none>
[11:00:08.479] {
[11:00:08.479]     {
[11:00:08.479]         {
[11:00:08.479]             ...future.startTime <- base::Sys.time()
[11:00:08.479]             {
[11:00:08.479]                 {
[11:00:08.479]                   {
[11:00:08.479]                     {
[11:00:08.479]                       {
[11:00:08.479]                         base::local({
[11:00:08.479]                           has_future <- base::requireNamespace("future", 
[11:00:08.479]                             quietly = TRUE)
[11:00:08.479]                           if (has_future) {
[11:00:08.479]                             ns <- base::getNamespace("future")
[11:00:08.479]                             version <- ns[[".package"]][["version"]]
[11:00:08.479]                             if (is.null(version)) 
[11:00:08.479]                               version <- utils::packageVersion("future")
[11:00:08.479]                           }
[11:00:08.479]                           else {
[11:00:08.479]                             version <- NULL
[11:00:08.479]                           }
[11:00:08.479]                           if (!has_future || version < "1.8.0") {
[11:00:08.479]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:08.479]                               "", base::R.version$version.string), 
[11:00:08.479]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:08.479]                                 base::R.version$platform, 8 * 
[11:00:08.479]                                   base::.Machine$sizeof.pointer), 
[11:00:08.479]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:08.479]                                 "release", "version")], collapse = " "), 
[11:00:08.479]                               hostname = base::Sys.info()[["nodename"]])
[11:00:08.479]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:08.479]                               info)
[11:00:08.479]                             info <- base::paste(info, collapse = "; ")
[11:00:08.479]                             if (!has_future) {
[11:00:08.479]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:08.479]                                 info)
[11:00:08.479]                             }
[11:00:08.479]                             else {
[11:00:08.479]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:08.479]                                 info, version)
[11:00:08.479]                             }
[11:00:08.479]                             base::stop(msg)
[11:00:08.479]                           }
[11:00:08.479]                         })
[11:00:08.479]                       }
[11:00:08.479]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:08.479]                       base::options(mc.cores = 1L)
[11:00:08.479]                     }
[11:00:08.479]                     base::local({
[11:00:08.479]                       for (pkg in "future.apply") {
[11:00:08.479]                         base::loadNamespace(pkg)
[11:00:08.479]                         base::library(pkg, character.only = TRUE)
[11:00:08.479]                       }
[11:00:08.479]                     })
[11:00:08.479]                   }
[11:00:08.479]                   ...future.strategy.old <- future::plan("list")
[11:00:08.479]                   options(future.plan = NULL)
[11:00:08.479]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:08.479]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:08.479]                 }
[11:00:08.479]                 ...future.workdir <- getwd()
[11:00:08.479]             }
[11:00:08.479]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:08.479]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:08.479]         }
[11:00:08.479]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:08.479]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:08.479]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:08.479]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:08.479]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:08.479]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:08.479]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:08.479]             base::names(...future.oldOptions))
[11:00:08.479]     }
[11:00:08.479]     if (FALSE) {
[11:00:08.479]     }
[11:00:08.479]     else {
[11:00:08.479]         if (TRUE) {
[11:00:08.479]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:08.479]                 open = "w")
[11:00:08.479]         }
[11:00:08.479]         else {
[11:00:08.479]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:08.479]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:08.479]         }
[11:00:08.479]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:08.479]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:08.479]             base::sink(type = "output", split = FALSE)
[11:00:08.479]             base::close(...future.stdout)
[11:00:08.479]         }, add = TRUE)
[11:00:08.479]     }
[11:00:08.479]     ...future.frame <- base::sys.nframe()
[11:00:08.479]     ...future.conditions <- base::list()
[11:00:08.479]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:08.479]     if (FALSE) {
[11:00:08.479]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:08.479]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:08.479]     }
[11:00:08.479]     ...future.result <- base::tryCatch({
[11:00:08.479]         base::withCallingHandlers({
[11:00:08.479]             ...future.value <- base::withVisible(base::local({
[11:00:08.479]                 ...future.makeSendCondition <- base::local({
[11:00:08.479]                   sendCondition <- NULL
[11:00:08.479]                   function(frame = 1L) {
[11:00:08.479]                     if (is.function(sendCondition)) 
[11:00:08.479]                       return(sendCondition)
[11:00:08.479]                     ns <- getNamespace("parallel")
[11:00:08.479]                     if (exists("sendData", mode = "function", 
[11:00:08.479]                       envir = ns)) {
[11:00:08.479]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:08.479]                         envir = ns)
[11:00:08.479]                       envir <- sys.frame(frame)
[11:00:08.479]                       master <- NULL
[11:00:08.479]                       while (!identical(envir, .GlobalEnv) && 
[11:00:08.479]                         !identical(envir, emptyenv())) {
[11:00:08.479]                         if (exists("master", mode = "list", envir = envir, 
[11:00:08.479]                           inherits = FALSE)) {
[11:00:08.479]                           master <- get("master", mode = "list", 
[11:00:08.479]                             envir = envir, inherits = FALSE)
[11:00:08.479]                           if (inherits(master, c("SOCKnode", 
[11:00:08.479]                             "SOCK0node"))) {
[11:00:08.479]                             sendCondition <<- function(cond) {
[11:00:08.479]                               data <- list(type = "VALUE", value = cond, 
[11:00:08.479]                                 success = TRUE)
[11:00:08.479]                               parallel_sendData(master, data)
[11:00:08.479]                             }
[11:00:08.479]                             return(sendCondition)
[11:00:08.479]                           }
[11:00:08.479]                         }
[11:00:08.479]                         frame <- frame + 1L
[11:00:08.479]                         envir <- sys.frame(frame)
[11:00:08.479]                       }
[11:00:08.479]                     }
[11:00:08.479]                     sendCondition <<- function(cond) NULL
[11:00:08.479]                   }
[11:00:08.479]                 })
[11:00:08.479]                 withCallingHandlers({
[11:00:08.479]                   {
[11:00:08.479]                     do.call(function(...) {
[11:00:08.479]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:08.479]                       if (!identical(...future.globals.maxSize.org, 
[11:00:08.479]                         ...future.globals.maxSize)) {
[11:00:08.479]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:08.479]                         on.exit(options(oopts), add = TRUE)
[11:00:08.479]                       }
[11:00:08.479]                       {
[11:00:08.479]                         lapply(seq_along(...future.elements_ii), 
[11:00:08.479]                           FUN = function(jj) {
[11:00:08.479]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:08.479]                             ...future.FUN(...future.X_jj, ...)
[11:00:08.479]                           })
[11:00:08.479]                       }
[11:00:08.479]                     }, args = future.call.arguments)
[11:00:08.479]                   }
[11:00:08.479]                 }, immediateCondition = function(cond) {
[11:00:08.479]                   sendCondition <- ...future.makeSendCondition()
[11:00:08.479]                   sendCondition(cond)
[11:00:08.479]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:08.479]                   {
[11:00:08.479]                     inherits <- base::inherits
[11:00:08.479]                     invokeRestart <- base::invokeRestart
[11:00:08.479]                     is.null <- base::is.null
[11:00:08.479]                     muffled <- FALSE
[11:00:08.479]                     if (inherits(cond, "message")) {
[11:00:08.479]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:08.479]                       if (muffled) 
[11:00:08.479]                         invokeRestart("muffleMessage")
[11:00:08.479]                     }
[11:00:08.479]                     else if (inherits(cond, "warning")) {
[11:00:08.479]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:08.479]                       if (muffled) 
[11:00:08.479]                         invokeRestart("muffleWarning")
[11:00:08.479]                     }
[11:00:08.479]                     else if (inherits(cond, "condition")) {
[11:00:08.479]                       if (!is.null(pattern)) {
[11:00:08.479]                         computeRestarts <- base::computeRestarts
[11:00:08.479]                         grepl <- base::grepl
[11:00:08.479]                         restarts <- computeRestarts(cond)
[11:00:08.479]                         for (restart in restarts) {
[11:00:08.479]                           name <- restart$name
[11:00:08.479]                           if (is.null(name)) 
[11:00:08.479]                             next
[11:00:08.479]                           if (!grepl(pattern, name)) 
[11:00:08.479]                             next
[11:00:08.479]                           invokeRestart(restart)
[11:00:08.479]                           muffled <- TRUE
[11:00:08.479]                           break
[11:00:08.479]                         }
[11:00:08.479]                       }
[11:00:08.479]                     }
[11:00:08.479]                     invisible(muffled)
[11:00:08.479]                   }
[11:00:08.479]                   muffleCondition(cond)
[11:00:08.479]                 })
[11:00:08.479]             }))
[11:00:08.479]             future::FutureResult(value = ...future.value$value, 
[11:00:08.479]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:08.479]                   ...future.rng), globalenv = if (FALSE) 
[11:00:08.479]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:08.479]                     ...future.globalenv.names))
[11:00:08.479]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:08.479]         }, condition = base::local({
[11:00:08.479]             c <- base::c
[11:00:08.479]             inherits <- base::inherits
[11:00:08.479]             invokeRestart <- base::invokeRestart
[11:00:08.479]             length <- base::length
[11:00:08.479]             list <- base::list
[11:00:08.479]             seq.int <- base::seq.int
[11:00:08.479]             signalCondition <- base::signalCondition
[11:00:08.479]             sys.calls <- base::sys.calls
[11:00:08.479]             `[[` <- base::`[[`
[11:00:08.479]             `+` <- base::`+`
[11:00:08.479]             `<<-` <- base::`<<-`
[11:00:08.479]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:08.479]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:08.479]                   3L)]
[11:00:08.479]             }
[11:00:08.479]             function(cond) {
[11:00:08.479]                 is_error <- inherits(cond, "error")
[11:00:08.479]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:08.479]                   NULL)
[11:00:08.479]                 if (is_error) {
[11:00:08.479]                   sessionInformation <- function() {
[11:00:08.479]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:08.479]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:08.479]                       search = base::search(), system = base::Sys.info())
[11:00:08.479]                   }
[11:00:08.479]                   ...future.conditions[[length(...future.conditions) + 
[11:00:08.479]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:08.479]                     cond$call), session = sessionInformation(), 
[11:00:08.479]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:08.479]                   signalCondition(cond)
[11:00:08.479]                 }
[11:00:08.479]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:08.479]                 "immediateCondition"))) {
[11:00:08.479]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:08.479]                   ...future.conditions[[length(...future.conditions) + 
[11:00:08.479]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:08.479]                   if (TRUE && !signal) {
[11:00:08.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:08.479]                     {
[11:00:08.479]                       inherits <- base::inherits
[11:00:08.479]                       invokeRestart <- base::invokeRestart
[11:00:08.479]                       is.null <- base::is.null
[11:00:08.479]                       muffled <- FALSE
[11:00:08.479]                       if (inherits(cond, "message")) {
[11:00:08.479]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:08.479]                         if (muffled) 
[11:00:08.479]                           invokeRestart("muffleMessage")
[11:00:08.479]                       }
[11:00:08.479]                       else if (inherits(cond, "warning")) {
[11:00:08.479]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:08.479]                         if (muffled) 
[11:00:08.479]                           invokeRestart("muffleWarning")
[11:00:08.479]                       }
[11:00:08.479]                       else if (inherits(cond, "condition")) {
[11:00:08.479]                         if (!is.null(pattern)) {
[11:00:08.479]                           computeRestarts <- base::computeRestarts
[11:00:08.479]                           grepl <- base::grepl
[11:00:08.479]                           restarts <- computeRestarts(cond)
[11:00:08.479]                           for (restart in restarts) {
[11:00:08.479]                             name <- restart$name
[11:00:08.479]                             if (is.null(name)) 
[11:00:08.479]                               next
[11:00:08.479]                             if (!grepl(pattern, name)) 
[11:00:08.479]                               next
[11:00:08.479]                             invokeRestart(restart)
[11:00:08.479]                             muffled <- TRUE
[11:00:08.479]                             break
[11:00:08.479]                           }
[11:00:08.479]                         }
[11:00:08.479]                       }
[11:00:08.479]                       invisible(muffled)
[11:00:08.479]                     }
[11:00:08.479]                     muffleCondition(cond, pattern = "^muffle")
[11:00:08.479]                   }
[11:00:08.479]                 }
[11:00:08.479]                 else {
[11:00:08.479]                   if (TRUE) {
[11:00:08.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:08.479]                     {
[11:00:08.479]                       inherits <- base::inherits
[11:00:08.479]                       invokeRestart <- base::invokeRestart
[11:00:08.479]                       is.null <- base::is.null
[11:00:08.479]                       muffled <- FALSE
[11:00:08.479]                       if (inherits(cond, "message")) {
[11:00:08.479]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:08.479]                         if (muffled) 
[11:00:08.479]                           invokeRestart("muffleMessage")
[11:00:08.479]                       }
[11:00:08.479]                       else if (inherits(cond, "warning")) {
[11:00:08.479]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:08.479]                         if (muffled) 
[11:00:08.479]                           invokeRestart("muffleWarning")
[11:00:08.479]                       }
[11:00:08.479]                       else if (inherits(cond, "condition")) {
[11:00:08.479]                         if (!is.null(pattern)) {
[11:00:08.479]                           computeRestarts <- base::computeRestarts
[11:00:08.479]                           grepl <- base::grepl
[11:00:08.479]                           restarts <- computeRestarts(cond)
[11:00:08.479]                           for (restart in restarts) {
[11:00:08.479]                             name <- restart$name
[11:00:08.479]                             if (is.null(name)) 
[11:00:08.479]                               next
[11:00:08.479]                             if (!grepl(pattern, name)) 
[11:00:08.479]                               next
[11:00:08.479]                             invokeRestart(restart)
[11:00:08.479]                             muffled <- TRUE
[11:00:08.479]                             break
[11:00:08.479]                           }
[11:00:08.479]                         }
[11:00:08.479]                       }
[11:00:08.479]                       invisible(muffled)
[11:00:08.479]                     }
[11:00:08.479]                     muffleCondition(cond, pattern = "^muffle")
[11:00:08.479]                   }
[11:00:08.479]                 }
[11:00:08.479]             }
[11:00:08.479]         }))
[11:00:08.479]     }, error = function(ex) {
[11:00:08.479]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:08.479]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:08.479]                 ...future.rng), started = ...future.startTime, 
[11:00:08.479]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:08.479]             version = "1.8"), class = "FutureResult")
[11:00:08.479]     }, finally = {
[11:00:08.479]         if (!identical(...future.workdir, getwd())) 
[11:00:08.479]             setwd(...future.workdir)
[11:00:08.479]         {
[11:00:08.479]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:08.479]                 ...future.oldOptions$nwarnings <- NULL
[11:00:08.479]             }
[11:00:08.479]             base::options(...future.oldOptions)
[11:00:08.479]             if (.Platform$OS.type == "windows") {
[11:00:08.479]                 old_names <- names(...future.oldEnvVars)
[11:00:08.479]                 envs <- base::Sys.getenv()
[11:00:08.479]                 names <- names(envs)
[11:00:08.479]                 common <- intersect(names, old_names)
[11:00:08.479]                 added <- setdiff(names, old_names)
[11:00:08.479]                 removed <- setdiff(old_names, names)
[11:00:08.479]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:08.479]                   envs[common]]
[11:00:08.479]                 NAMES <- toupper(changed)
[11:00:08.479]                 args <- list()
[11:00:08.479]                 for (kk in seq_along(NAMES)) {
[11:00:08.479]                   name <- changed[[kk]]
[11:00:08.479]                   NAME <- NAMES[[kk]]
[11:00:08.479]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:08.479]                     next
[11:00:08.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:08.479]                 }
[11:00:08.479]                 NAMES <- toupper(added)
[11:00:08.479]                 for (kk in seq_along(NAMES)) {
[11:00:08.479]                   name <- added[[kk]]
[11:00:08.479]                   NAME <- NAMES[[kk]]
[11:00:08.479]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:08.479]                     next
[11:00:08.479]                   args[[name]] <- ""
[11:00:08.479]                 }
[11:00:08.479]                 NAMES <- toupper(removed)
[11:00:08.479]                 for (kk in seq_along(NAMES)) {
[11:00:08.479]                   name <- removed[[kk]]
[11:00:08.479]                   NAME <- NAMES[[kk]]
[11:00:08.479]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:08.479]                     next
[11:00:08.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:08.479]                 }
[11:00:08.479]                 if (length(args) > 0) 
[11:00:08.479]                   base::do.call(base::Sys.setenv, args = args)
[11:00:08.479]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:08.479]             }
[11:00:08.479]             else {
[11:00:08.479]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:08.479]             }
[11:00:08.479]             {
[11:00:08.479]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:08.479]                   0L) {
[11:00:08.479]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:08.479]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:08.479]                   base::options(opts)
[11:00:08.479]                 }
[11:00:08.479]                 {
[11:00:08.479]                   {
[11:00:08.479]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:08.479]                     NULL
[11:00:08.479]                   }
[11:00:08.479]                   options(future.plan = NULL)
[11:00:08.479]                   if (is.na(NA_character_)) 
[11:00:08.479]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:08.479]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:08.479]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:08.479]                     .init = FALSE)
[11:00:08.479]                 }
[11:00:08.479]             }
[11:00:08.479]         }
[11:00:08.479]     })
[11:00:08.479]     if (TRUE) {
[11:00:08.479]         base::sink(type = "output", split = FALSE)
[11:00:08.479]         if (TRUE) {
[11:00:08.479]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:08.479]         }
[11:00:08.479]         else {
[11:00:08.479]             ...future.result["stdout"] <- base::list(NULL)
[11:00:08.479]         }
[11:00:08.479]         base::close(...future.stdout)
[11:00:08.479]         ...future.stdout <- NULL
[11:00:08.479]     }
[11:00:08.479]     ...future.result$conditions <- ...future.conditions
[11:00:08.479]     ...future.result$finished <- base::Sys.time()
[11:00:08.479]     ...future.result
[11:00:08.479] }
[11:00:08.482] Exporting 11 global objects (16.50 KiB) to cluster node #2 ...
[11:00:08.482] Exporting ‘...future.FUN’ (6.73 KiB) to cluster node #2 ...
[11:00:08.524] Exporting ‘...future.FUN’ (6.73 KiB) to cluster node #2 ... DONE
[11:00:08.524] Exporting ‘x_FUN’ (41 bytes) to cluster node #2 ...
[11:00:08.524] Exporting ‘x_FUN’ (41 bytes) to cluster node #2 ... DONE
[11:00:08.524] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[11:00:08.525] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[11:00:08.525] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[11:00:08.566] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[11:00:08.566] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[11:00:08.607] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[11:00:08.607] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[11:00:08.607] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[11:00:08.607] Exporting ‘valid_types’ (46 bytes) to cluster node #2 ...
[11:00:08.608] Exporting ‘valid_types’ (46 bytes) to cluster node #2 ... DONE
[11:00:08.608] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[11:00:08.608] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[11:00:08.608] Exporting ‘...future.elements_ii’ (1.41 KiB) to cluster node #2 ...
[11:00:08.609] Exporting ‘...future.elements_ii’ (1.41 KiB) to cluster node #2 ... DONE
[11:00:08.609] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[11:00:08.609] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[11:00:08.609] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[11:00:08.609] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[11:00:08.610] Exporting 11 global objects (16.50 KiB) to cluster node #2 ... DONE
[11:00:08.610] MultisessionFuture started
[11:00:08.610] - Launch lazy future ... done
[11:00:08.610] run() for ‘MultisessionFuture’ ... done
[11:00:08.610] Created future:
[11:00:08.610] MultisessionFuture:
[11:00:08.610] Label: ‘future_vapply-2’
[11:00:08.610] Expression:
[11:00:08.610] {
[11:00:08.610]     do.call(function(...) {
[11:00:08.610]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:08.610]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:08.610]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:08.610]             on.exit(options(oopts), add = TRUE)
[11:00:08.610]         }
[11:00:08.610]         {
[11:00:08.610]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:08.610]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:08.610]                 ...future.FUN(...future.X_jj, ...)
[11:00:08.610]             })
[11:00:08.610]         }
[11:00:08.610]     }, args = future.call.arguments)
[11:00:08.610] }
[11:00:08.610] Lazy evaluation: FALSE
[11:00:08.610] Asynchronous evaluation: TRUE
[11:00:08.610] Local evaluation: TRUE
[11:00:08.610] Environment: R_GlobalEnv
[11:00:08.610] Capture standard output: TRUE
[11:00:08.610] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:08.610] Globals: 11 objects totaling 16.28 KiB (function ‘...future.FUN’ of 6.73 KiB, function ‘x_FUN’ of 41 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:08.610] Packages: 1 packages (‘future.apply’)
[11:00:08.610] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:08.610] Resolved: FALSE
[11:00:08.610] Value: <not collected>
[11:00:08.610] Conditions captured: <none>
[11:00:08.610] Early signaling: FALSE
[11:00:08.610] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:08.610] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:08.622] Chunk #2 of 2 ... DONE
[11:00:08.622] Launching 2 futures (chunks) ... DONE
[11:00:08.622] Resolving 2 futures (chunks) ...
[11:00:08.622] resolve() on list ...
[11:00:08.622]  recursive: 0
[11:00:08.623]  length: 2
[11:00:08.623] 
[11:00:08.623] receiveMessageFromWorker() for ClusterFuture ...
[11:00:08.623] - Validating connection of MultisessionFuture
[11:00:08.623] - received message: FutureResult
[11:00:08.623] - Received FutureResult
[11:00:08.624] - Erased future from FutureRegistry
[11:00:08.624] result() for ClusterFuture ...
[11:00:08.624] - result already collected: FutureResult
[11:00:08.624] result() for ClusterFuture ... done
[11:00:08.624] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:08.624] Future #1
[11:00:08.624] result() for ClusterFuture ...
[11:00:08.624] - result already collected: FutureResult
[11:00:08.624] result() for ClusterFuture ... done
[11:00:08.624] result() for ClusterFuture ...
[11:00:08.624] - result already collected: FutureResult
[11:00:08.624] result() for ClusterFuture ... done
[11:00:08.625] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:00:08.625] - nx: 2
[11:00:08.625] - relay: TRUE
[11:00:08.625] - stdout: TRUE
[11:00:08.625] - signal: TRUE
[11:00:08.625] - resignal: FALSE
[11:00:08.625] - force: TRUE
[11:00:08.625] - relayed: [n=2] FALSE, FALSE
[11:00:08.625] - queued futures: [n=2] FALSE, FALSE
[11:00:08.625]  - until=1
[11:00:08.625]  - relaying element #1
[11:00:08.625] result() for ClusterFuture ...
[11:00:08.625] - result already collected: FutureResult
[11:00:08.626] result() for ClusterFuture ... done
[11:00:08.626] result() for ClusterFuture ...
[11:00:08.626] - result already collected: FutureResult
[11:00:08.626] result() for ClusterFuture ... done
[11:00:08.626] result() for ClusterFuture ...
[11:00:08.626] - result already collected: FutureResult
[11:00:08.626] result() for ClusterFuture ... done
[11:00:08.626] result() for ClusterFuture ...
[11:00:08.626] - result already collected: FutureResult
[11:00:08.626] result() for ClusterFuture ... done
[11:00:08.626] - relayed: [n=2] TRUE, FALSE
[11:00:08.626] - queued futures: [n=2] TRUE, FALSE
[11:00:08.627] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:00:08.627]  length: 1 (resolved future 1)
[11:00:08.652] receiveMessageFromWorker() for ClusterFuture ...
[11:00:08.652] - Validating connection of MultisessionFuture
[11:00:08.653] - received message: FutureResult
[11:00:08.653] - Received FutureResult
[11:00:08.653] - Erased future from FutureRegistry
[11:00:08.653] result() for ClusterFuture ...
[11:00:08.653] - result already collected: FutureResult
[11:00:08.653] result() for ClusterFuture ... done
[11:00:08.653] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:08.653] Future #2
[11:00:08.653] result() for ClusterFuture ...
[11:00:08.653] - result already collected: FutureResult
[11:00:08.654] result() for ClusterFuture ... done
[11:00:08.654] result() for ClusterFuture ...
[11:00:08.654] - result already collected: FutureResult
[11:00:08.654] result() for ClusterFuture ... done
[11:00:08.654] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:00:08.654] - nx: 2
[11:00:08.654] - relay: TRUE
[11:00:08.654] - stdout: TRUE
[11:00:08.654] - signal: TRUE
[11:00:08.654] - resignal: FALSE
[11:00:08.654] - force: TRUE
[11:00:08.654] - relayed: [n=2] TRUE, FALSE
[11:00:08.654] - queued futures: [n=2] TRUE, FALSE
[11:00:08.655]  - until=2
[11:00:08.655]  - relaying element #2
[11:00:08.655] result() for ClusterFuture ...
[11:00:08.655] - result already collected: FutureResult
[11:00:08.655] result() for ClusterFuture ... done
[11:00:08.655] result() for ClusterFuture ...
[11:00:08.655] - result already collected: FutureResult
[11:00:08.655] result() for ClusterFuture ... done
[11:00:08.655] result() for ClusterFuture ...
[11:00:08.655] - result already collected: FutureResult
[11:00:08.655] result() for ClusterFuture ... done
[11:00:08.655] result() for ClusterFuture ...
[11:00:08.656] - result already collected: FutureResult
[11:00:08.656] result() for ClusterFuture ... done
[11:00:08.656] - relayed: [n=2] TRUE, TRUE
[11:00:08.656] - queued futures: [n=2] TRUE, TRUE
[11:00:08.656] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:00:08.656]  length: 0 (resolved future 2)
[11:00:08.656] Relaying remaining futures
[11:00:08.656] signalConditionsASAP(NULL, pos=0) ...
[11:00:08.656] - nx: 2
[11:00:08.656] - relay: TRUE
[11:00:08.656] - stdout: TRUE
[11:00:08.656] - signal: TRUE
[11:00:08.656] - resignal: FALSE
[11:00:08.657] - force: TRUE
[11:00:08.657] - relayed: [n=2] TRUE, TRUE
[11:00:08.657] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:08.657] - relayed: [n=2] TRUE, TRUE
[11:00:08.657] - queued futures: [n=2] TRUE, TRUE
[11:00:08.657] signalConditionsASAP(NULL, pos=0) ... done
[11:00:08.657] resolve() on list ... DONE
[11:00:08.657] result() for ClusterFuture ...
[11:00:08.657] - result already collected: FutureResult
[11:00:08.657] result() for ClusterFuture ... done
[11:00:08.657] result() for ClusterFuture ...
[11:00:08.657] - result already collected: FutureResult
[11:00:08.657] result() for ClusterFuture ... done
[11:00:08.658] result() for ClusterFuture ...
[11:00:08.658] - result already collected: FutureResult
[11:00:08.658] result() for ClusterFuture ... done
[11:00:08.658] result() for ClusterFuture ...
[11:00:08.658] - result already collected: FutureResult
[11:00:08.658] result() for ClusterFuture ... done
[11:00:08.658]  - Number of value chunks collected: 2
[11:00:08.658] Resolving 2 futures (chunks) ... DONE
[11:00:08.658] Reducing values from 2 chunks ...
[11:00:08.658]  - Number of values collected after concatenation: 11
[11:00:08.658]  - Number of values expected: 11
[11:00:08.658] Reducing values from 2 chunks ... DONE
[11:00:08.659] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[11:00:08.659] future_lapply() ...
[11:00:08.662] Number of chunks: 2
[11:00:08.663] getGlobalsAndPackagesXApply() ...
[11:00:08.663]  - future.globals: TRUE
[11:00:08.663] getGlobalsAndPackages() ...
[11:00:08.663] Searching for globals...
[11:00:08.666] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[11:00:08.666] Searching for globals ... DONE
[11:00:08.666] Resolving globals: FALSE
[11:00:08.667] The total size of the 7 globals is 11.92 KiB (12201 bytes)
[11:00:08.667] The total size of the 7 globals exported for future expression (‘FUN()’) is 11.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (4.51 KiB of class ‘function’), ‘FUN’ (3.92 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:08.667] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:08.667] - packages: [1] ‘future.apply’
[11:00:08.667] getGlobalsAndPackages() ... DONE
[11:00:08.667]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:08.668]  - needed namespaces: [n=1] ‘future.apply’
[11:00:08.668] Finding globals ... DONE
[11:00:08.668]  - use_args: TRUE
[11:00:08.668]  - Getting '...' globals ...
[11:00:08.668] resolve() on list ...
[11:00:08.668]  recursive: 0
[11:00:08.668]  length: 1
[11:00:08.668]  elements: ‘...’
[11:00:08.668]  length: 0 (resolved future 1)
[11:00:08.669] resolve() on list ... DONE
[11:00:08.669]    - '...' content: [n=0] 
[11:00:08.669] List of 1
[11:00:08.669]  $ ...: list()
[11:00:08.669]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:08.669]  - attr(*, "where")=List of 1
[11:00:08.669]   ..$ ...:<environment: 0x55bbaeb2dd38> 
[11:00:08.669]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:08.669]  - attr(*, "resolved")= logi TRUE
[11:00:08.669]  - attr(*, "total_size")= num NA
[11:00:08.671]  - Getting '...' globals ... DONE
[11:00:08.671] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:08.671] List of 8
[11:00:08.671]  $ ...future.FUN:function (x, ...)  
[11:00:08.671]  $ x_FUN        :function (x)  
[11:00:08.671]  $ times        : int 1
[11:00:08.671]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:08.671]  $ stop_if_not  :function (...)  
[11:00:08.671]  $ dim          : NULL
[11:00:08.671]  $ valid_types  : chr [1:2] "logical" "integer"
[11:00:08.671]  $ ...          : list()
[11:00:08.671]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:08.671]  - attr(*, "where")=List of 8
[11:00:08.671]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:08.671]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:08.671]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:08.671]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:08.671]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:08.671]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:08.671]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:08.671]   ..$ ...          :<environment: 0x55bbaeb2dd38> 
[11:00:08.671]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:08.671]  - attr(*, "resolved")= logi FALSE
[11:00:08.671]  - attr(*, "total_size")= num 22016
[11:00:08.676] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:08.676] getGlobalsAndPackagesXApply() ... DONE
[11:00:08.676] Number of futures (= number of chunks): 2
[11:00:08.677] Launching 2 futures (chunks) ...
[11:00:08.677] Chunk #1 of 2 ...
[11:00:08.677]  - Finding globals in 'X' for chunk #1 ...
[11:00:08.677] getGlobalsAndPackages() ...
[11:00:08.677] Searching for globals...
[11:00:08.677] 
[11:00:08.677] Searching for globals ... DONE
[11:00:08.677] - globals: [0] <none>
[11:00:08.677] getGlobalsAndPackages() ... DONE
[11:00:08.677]    + additional globals found: [n=0] 
[11:00:08.678]    + additional namespaces needed: [n=0] 
[11:00:08.678]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:08.678]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:08.678]  - seeds: <none>
[11:00:08.678]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:08.678] getGlobalsAndPackages() ...
[11:00:08.678] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:08.678] Resolving globals: FALSE
[11:00:08.678] Tweak future expression to call with '...' arguments ...
[11:00:08.678] {
[11:00:08.678]     do.call(function(...) {
[11:00:08.678]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:08.678]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:08.678]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:08.678]             on.exit(options(oopts), add = TRUE)
[11:00:08.678]         }
[11:00:08.678]         {
[11:00:08.678]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:08.678]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:08.678]                 ...future.FUN(...future.X_jj, ...)
[11:00:08.678]             })
[11:00:08.678]         }
[11:00:08.678]     }, args = future.call.arguments)
[11:00:08.678] }
[11:00:08.679] Tweak future expression to call with '...' arguments ... DONE
[11:00:08.679] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:08.679] - packages: [1] ‘future.apply’
[11:00:08.679] getGlobalsAndPackages() ... DONE
[11:00:08.680] run() for ‘Future’ ...
[11:00:08.680] - state: ‘created’
[11:00:08.680] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:08.696] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:08.696] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:08.697]   - Field: ‘node’
[11:00:08.697]   - Field: ‘label’
[11:00:08.697]   - Field: ‘local’
[11:00:08.697]   - Field: ‘owner’
[11:00:08.697]   - Field: ‘envir’
[11:00:08.697]   - Field: ‘workers’
[11:00:08.697]   - Field: ‘packages’
[11:00:08.697]   - Field: ‘gc’
[11:00:08.697]   - Field: ‘conditions’
[11:00:08.697]   - Field: ‘persistent’
[11:00:08.697]   - Field: ‘expr’
[11:00:08.698]   - Field: ‘uuid’
[11:00:08.698]   - Field: ‘seed’
[11:00:08.698]   - Field: ‘version’
[11:00:08.698]   - Field: ‘result’
[11:00:08.698]   - Field: ‘asynchronous’
[11:00:08.698]   - Field: ‘calls’
[11:00:08.698]   - Field: ‘globals’
[11:00:08.698]   - Field: ‘stdout’
[11:00:08.698]   - Field: ‘earlySignal’
[11:00:08.698]   - Field: ‘lazy’
[11:00:08.698]   - Field: ‘state’
[11:00:08.699] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:08.699] - Launch lazy future ...
[11:00:08.699] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:08.699] Packages needed by future strategies (n = 0): <none>
[11:00:08.699] {
[11:00:08.699]     {
[11:00:08.699]         {
[11:00:08.699]             ...future.startTime <- base::Sys.time()
[11:00:08.699]             {
[11:00:08.699]                 {
[11:00:08.699]                   {
[11:00:08.699]                     {
[11:00:08.699]                       {
[11:00:08.699]                         base::local({
[11:00:08.699]                           has_future <- base::requireNamespace("future", 
[11:00:08.699]                             quietly = TRUE)
[11:00:08.699]                           if (has_future) {
[11:00:08.699]                             ns <- base::getNamespace("future")
[11:00:08.699]                             version <- ns[[".package"]][["version"]]
[11:00:08.699]                             if (is.null(version)) 
[11:00:08.699]                               version <- utils::packageVersion("future")
[11:00:08.699]                           }
[11:00:08.699]                           else {
[11:00:08.699]                             version <- NULL
[11:00:08.699]                           }
[11:00:08.699]                           if (!has_future || version < "1.8.0") {
[11:00:08.699]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:08.699]                               "", base::R.version$version.string), 
[11:00:08.699]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:08.699]                                 base::R.version$platform, 8 * 
[11:00:08.699]                                   base::.Machine$sizeof.pointer), 
[11:00:08.699]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:08.699]                                 "release", "version")], collapse = " "), 
[11:00:08.699]                               hostname = base::Sys.info()[["nodename"]])
[11:00:08.699]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:08.699]                               info)
[11:00:08.699]                             info <- base::paste(info, collapse = "; ")
[11:00:08.699]                             if (!has_future) {
[11:00:08.699]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:08.699]                                 info)
[11:00:08.699]                             }
[11:00:08.699]                             else {
[11:00:08.699]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:08.699]                                 info, version)
[11:00:08.699]                             }
[11:00:08.699]                             base::stop(msg)
[11:00:08.699]                           }
[11:00:08.699]                         })
[11:00:08.699]                       }
[11:00:08.699]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:08.699]                       base::options(mc.cores = 1L)
[11:00:08.699]                     }
[11:00:08.699]                     base::local({
[11:00:08.699]                       for (pkg in "future.apply") {
[11:00:08.699]                         base::loadNamespace(pkg)
[11:00:08.699]                         base::library(pkg, character.only = TRUE)
[11:00:08.699]                       }
[11:00:08.699]                     })
[11:00:08.699]                   }
[11:00:08.699]                   ...future.strategy.old <- future::plan("list")
[11:00:08.699]                   options(future.plan = NULL)
[11:00:08.699]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:08.699]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:08.699]                 }
[11:00:08.699]                 ...future.workdir <- getwd()
[11:00:08.699]             }
[11:00:08.699]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:08.699]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:08.699]         }
[11:00:08.699]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:08.699]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:08.699]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:08.699]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:08.699]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:08.699]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:08.699]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:08.699]             base::names(...future.oldOptions))
[11:00:08.699]     }
[11:00:08.699]     if (FALSE) {
[11:00:08.699]     }
[11:00:08.699]     else {
[11:00:08.699]         if (TRUE) {
[11:00:08.699]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:08.699]                 open = "w")
[11:00:08.699]         }
[11:00:08.699]         else {
[11:00:08.699]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:08.699]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:08.699]         }
[11:00:08.699]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:08.699]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:08.699]             base::sink(type = "output", split = FALSE)
[11:00:08.699]             base::close(...future.stdout)
[11:00:08.699]         }, add = TRUE)
[11:00:08.699]     }
[11:00:08.699]     ...future.frame <- base::sys.nframe()
[11:00:08.699]     ...future.conditions <- base::list()
[11:00:08.699]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:08.699]     if (FALSE) {
[11:00:08.699]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:08.699]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:08.699]     }
[11:00:08.699]     ...future.result <- base::tryCatch({
[11:00:08.699]         base::withCallingHandlers({
[11:00:08.699]             ...future.value <- base::withVisible(base::local({
[11:00:08.699]                 ...future.makeSendCondition <- base::local({
[11:00:08.699]                   sendCondition <- NULL
[11:00:08.699]                   function(frame = 1L) {
[11:00:08.699]                     if (is.function(sendCondition)) 
[11:00:08.699]                       return(sendCondition)
[11:00:08.699]                     ns <- getNamespace("parallel")
[11:00:08.699]                     if (exists("sendData", mode = "function", 
[11:00:08.699]                       envir = ns)) {
[11:00:08.699]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:08.699]                         envir = ns)
[11:00:08.699]                       envir <- sys.frame(frame)
[11:00:08.699]                       master <- NULL
[11:00:08.699]                       while (!identical(envir, .GlobalEnv) && 
[11:00:08.699]                         !identical(envir, emptyenv())) {
[11:00:08.699]                         if (exists("master", mode = "list", envir = envir, 
[11:00:08.699]                           inherits = FALSE)) {
[11:00:08.699]                           master <- get("master", mode = "list", 
[11:00:08.699]                             envir = envir, inherits = FALSE)
[11:00:08.699]                           if (inherits(master, c("SOCKnode", 
[11:00:08.699]                             "SOCK0node"))) {
[11:00:08.699]                             sendCondition <<- function(cond) {
[11:00:08.699]                               data <- list(type = "VALUE", value = cond, 
[11:00:08.699]                                 success = TRUE)
[11:00:08.699]                               parallel_sendData(master, data)
[11:00:08.699]                             }
[11:00:08.699]                             return(sendCondition)
[11:00:08.699]                           }
[11:00:08.699]                         }
[11:00:08.699]                         frame <- frame + 1L
[11:00:08.699]                         envir <- sys.frame(frame)
[11:00:08.699]                       }
[11:00:08.699]                     }
[11:00:08.699]                     sendCondition <<- function(cond) NULL
[11:00:08.699]                   }
[11:00:08.699]                 })
[11:00:08.699]                 withCallingHandlers({
[11:00:08.699]                   {
[11:00:08.699]                     do.call(function(...) {
[11:00:08.699]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:08.699]                       if (!identical(...future.globals.maxSize.org, 
[11:00:08.699]                         ...future.globals.maxSize)) {
[11:00:08.699]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:08.699]                         on.exit(options(oopts), add = TRUE)
[11:00:08.699]                       }
[11:00:08.699]                       {
[11:00:08.699]                         lapply(seq_along(...future.elements_ii), 
[11:00:08.699]                           FUN = function(jj) {
[11:00:08.699]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:08.699]                             ...future.FUN(...future.X_jj, ...)
[11:00:08.699]                           })
[11:00:08.699]                       }
[11:00:08.699]                     }, args = future.call.arguments)
[11:00:08.699]                   }
[11:00:08.699]                 }, immediateCondition = function(cond) {
[11:00:08.699]                   sendCondition <- ...future.makeSendCondition()
[11:00:08.699]                   sendCondition(cond)
[11:00:08.699]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:08.699]                   {
[11:00:08.699]                     inherits <- base::inherits
[11:00:08.699]                     invokeRestart <- base::invokeRestart
[11:00:08.699]                     is.null <- base::is.null
[11:00:08.699]                     muffled <- FALSE
[11:00:08.699]                     if (inherits(cond, "message")) {
[11:00:08.699]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:08.699]                       if (muffled) 
[11:00:08.699]                         invokeRestart("muffleMessage")
[11:00:08.699]                     }
[11:00:08.699]                     else if (inherits(cond, "warning")) {
[11:00:08.699]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:08.699]                       if (muffled) 
[11:00:08.699]                         invokeRestart("muffleWarning")
[11:00:08.699]                     }
[11:00:08.699]                     else if (inherits(cond, "condition")) {
[11:00:08.699]                       if (!is.null(pattern)) {
[11:00:08.699]                         computeRestarts <- base::computeRestarts
[11:00:08.699]                         grepl <- base::grepl
[11:00:08.699]                         restarts <- computeRestarts(cond)
[11:00:08.699]                         for (restart in restarts) {
[11:00:08.699]                           name <- restart$name
[11:00:08.699]                           if (is.null(name)) 
[11:00:08.699]                             next
[11:00:08.699]                           if (!grepl(pattern, name)) 
[11:00:08.699]                             next
[11:00:08.699]                           invokeRestart(restart)
[11:00:08.699]                           muffled <- TRUE
[11:00:08.699]                           break
[11:00:08.699]                         }
[11:00:08.699]                       }
[11:00:08.699]                     }
[11:00:08.699]                     invisible(muffled)
[11:00:08.699]                   }
[11:00:08.699]                   muffleCondition(cond)
[11:00:08.699]                 })
[11:00:08.699]             }))
[11:00:08.699]             future::FutureResult(value = ...future.value$value, 
[11:00:08.699]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:08.699]                   ...future.rng), globalenv = if (FALSE) 
[11:00:08.699]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:08.699]                     ...future.globalenv.names))
[11:00:08.699]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:08.699]         }, condition = base::local({
[11:00:08.699]             c <- base::c
[11:00:08.699]             inherits <- base::inherits
[11:00:08.699]             invokeRestart <- base::invokeRestart
[11:00:08.699]             length <- base::length
[11:00:08.699]             list <- base::list
[11:00:08.699]             seq.int <- base::seq.int
[11:00:08.699]             signalCondition <- base::signalCondition
[11:00:08.699]             sys.calls <- base::sys.calls
[11:00:08.699]             `[[` <- base::`[[`
[11:00:08.699]             `+` <- base::`+`
[11:00:08.699]             `<<-` <- base::`<<-`
[11:00:08.699]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:08.699]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:08.699]                   3L)]
[11:00:08.699]             }
[11:00:08.699]             function(cond) {
[11:00:08.699]                 is_error <- inherits(cond, "error")
[11:00:08.699]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:08.699]                   NULL)
[11:00:08.699]                 if (is_error) {
[11:00:08.699]                   sessionInformation <- function() {
[11:00:08.699]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:08.699]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:08.699]                       search = base::search(), system = base::Sys.info())
[11:00:08.699]                   }
[11:00:08.699]                   ...future.conditions[[length(...future.conditions) + 
[11:00:08.699]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:08.699]                     cond$call), session = sessionInformation(), 
[11:00:08.699]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:08.699]                   signalCondition(cond)
[11:00:08.699]                 }
[11:00:08.699]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:08.699]                 "immediateCondition"))) {
[11:00:08.699]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:08.699]                   ...future.conditions[[length(...future.conditions) + 
[11:00:08.699]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:08.699]                   if (TRUE && !signal) {
[11:00:08.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:08.699]                     {
[11:00:08.699]                       inherits <- base::inherits
[11:00:08.699]                       invokeRestart <- base::invokeRestart
[11:00:08.699]                       is.null <- base::is.null
[11:00:08.699]                       muffled <- FALSE
[11:00:08.699]                       if (inherits(cond, "message")) {
[11:00:08.699]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:08.699]                         if (muffled) 
[11:00:08.699]                           invokeRestart("muffleMessage")
[11:00:08.699]                       }
[11:00:08.699]                       else if (inherits(cond, "warning")) {
[11:00:08.699]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:08.699]                         if (muffled) 
[11:00:08.699]                           invokeRestart("muffleWarning")
[11:00:08.699]                       }
[11:00:08.699]                       else if (inherits(cond, "condition")) {
[11:00:08.699]                         if (!is.null(pattern)) {
[11:00:08.699]                           computeRestarts <- base::computeRestarts
[11:00:08.699]                           grepl <- base::grepl
[11:00:08.699]                           restarts <- computeRestarts(cond)
[11:00:08.699]                           for (restart in restarts) {
[11:00:08.699]                             name <- restart$name
[11:00:08.699]                             if (is.null(name)) 
[11:00:08.699]                               next
[11:00:08.699]                             if (!grepl(pattern, name)) 
[11:00:08.699]                               next
[11:00:08.699]                             invokeRestart(restart)
[11:00:08.699]                             muffled <- TRUE
[11:00:08.699]                             break
[11:00:08.699]                           }
[11:00:08.699]                         }
[11:00:08.699]                       }
[11:00:08.699]                       invisible(muffled)
[11:00:08.699]                     }
[11:00:08.699]                     muffleCondition(cond, pattern = "^muffle")
[11:00:08.699]                   }
[11:00:08.699]                 }
[11:00:08.699]                 else {
[11:00:08.699]                   if (TRUE) {
[11:00:08.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:08.699]                     {
[11:00:08.699]                       inherits <- base::inherits
[11:00:08.699]                       invokeRestart <- base::invokeRestart
[11:00:08.699]                       is.null <- base::is.null
[11:00:08.699]                       muffled <- FALSE
[11:00:08.699]                       if (inherits(cond, "message")) {
[11:00:08.699]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:08.699]                         if (muffled) 
[11:00:08.699]                           invokeRestart("muffleMessage")
[11:00:08.699]                       }
[11:00:08.699]                       else if (inherits(cond, "warning")) {
[11:00:08.699]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:08.699]                         if (muffled) 
[11:00:08.699]                           invokeRestart("muffleWarning")
[11:00:08.699]                       }
[11:00:08.699]                       else if (inherits(cond, "condition")) {
[11:00:08.699]                         if (!is.null(pattern)) {
[11:00:08.699]                           computeRestarts <- base::computeRestarts
[11:00:08.699]                           grepl <- base::grepl
[11:00:08.699]                           restarts <- computeRestarts(cond)
[11:00:08.699]                           for (restart in restarts) {
[11:00:08.699]                             name <- restart$name
[11:00:08.699]                             if (is.null(name)) 
[11:00:08.699]                               next
[11:00:08.699]                             if (!grepl(pattern, name)) 
[11:00:08.699]                               next
[11:00:08.699]                             invokeRestart(restart)
[11:00:08.699]                             muffled <- TRUE
[11:00:08.699]                             break
[11:00:08.699]                           }
[11:00:08.699]                         }
[11:00:08.699]                       }
[11:00:08.699]                       invisible(muffled)
[11:00:08.699]                     }
[11:00:08.699]                     muffleCondition(cond, pattern = "^muffle")
[11:00:08.699]                   }
[11:00:08.699]                 }
[11:00:08.699]             }
[11:00:08.699]         }))
[11:00:08.699]     }, error = function(ex) {
[11:00:08.699]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:08.699]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:08.699]                 ...future.rng), started = ...future.startTime, 
[11:00:08.699]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:08.699]             version = "1.8"), class = "FutureResult")
[11:00:08.699]     }, finally = {
[11:00:08.699]         if (!identical(...future.workdir, getwd())) 
[11:00:08.699]             setwd(...future.workdir)
[11:00:08.699]         {
[11:00:08.699]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:08.699]                 ...future.oldOptions$nwarnings <- NULL
[11:00:08.699]             }
[11:00:08.699]             base::options(...future.oldOptions)
[11:00:08.699]             if (.Platform$OS.type == "windows") {
[11:00:08.699]                 old_names <- names(...future.oldEnvVars)
[11:00:08.699]                 envs <- base::Sys.getenv()
[11:00:08.699]                 names <- names(envs)
[11:00:08.699]                 common <- intersect(names, old_names)
[11:00:08.699]                 added <- setdiff(names, old_names)
[11:00:08.699]                 removed <- setdiff(old_names, names)
[11:00:08.699]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:08.699]                   envs[common]]
[11:00:08.699]                 NAMES <- toupper(changed)
[11:00:08.699]                 args <- list()
[11:00:08.699]                 for (kk in seq_along(NAMES)) {
[11:00:08.699]                   name <- changed[[kk]]
[11:00:08.699]                   NAME <- NAMES[[kk]]
[11:00:08.699]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:08.699]                     next
[11:00:08.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:08.699]                 }
[11:00:08.699]                 NAMES <- toupper(added)
[11:00:08.699]                 for (kk in seq_along(NAMES)) {
[11:00:08.699]                   name <- added[[kk]]
[11:00:08.699]                   NAME <- NAMES[[kk]]
[11:00:08.699]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:08.699]                     next
[11:00:08.699]                   args[[name]] <- ""
[11:00:08.699]                 }
[11:00:08.699]                 NAMES <- toupper(removed)
[11:00:08.699]                 for (kk in seq_along(NAMES)) {
[11:00:08.699]                   name <- removed[[kk]]
[11:00:08.699]                   NAME <- NAMES[[kk]]
[11:00:08.699]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:08.699]                     next
[11:00:08.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:08.699]                 }
[11:00:08.699]                 if (length(args) > 0) 
[11:00:08.699]                   base::do.call(base::Sys.setenv, args = args)
[11:00:08.699]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:08.699]             }
[11:00:08.699]             else {
[11:00:08.699]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:08.699]             }
[11:00:08.699]             {
[11:00:08.699]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:08.699]                   0L) {
[11:00:08.699]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:08.699]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:08.699]                   base::options(opts)
[11:00:08.699]                 }
[11:00:08.699]                 {
[11:00:08.699]                   {
[11:00:08.699]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:08.699]                     NULL
[11:00:08.699]                   }
[11:00:08.699]                   options(future.plan = NULL)
[11:00:08.699]                   if (is.na(NA_character_)) 
[11:00:08.699]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:08.699]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:08.699]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:08.699]                     .init = FALSE)
[11:00:08.699]                 }
[11:00:08.699]             }
[11:00:08.699]         }
[11:00:08.699]     })
[11:00:08.699]     if (TRUE) {
[11:00:08.699]         base::sink(type = "output", split = FALSE)
[11:00:08.699]         if (TRUE) {
[11:00:08.699]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:08.699]         }
[11:00:08.699]         else {
[11:00:08.699]             ...future.result["stdout"] <- base::list(NULL)
[11:00:08.699]         }
[11:00:08.699]         base::close(...future.stdout)
[11:00:08.699]         ...future.stdout <- NULL
[11:00:08.699]     }
[11:00:08.699]     ...future.result$conditions <- ...future.conditions
[11:00:08.699]     ...future.result$finished <- base::Sys.time()
[11:00:08.699]     ...future.result
[11:00:08.699] }
[11:00:08.702] Exporting 11 global objects (12.36 KiB) to cluster node #1 ...
[11:00:08.702] Exporting ‘...future.FUN’ (3.91 KiB) to cluster node #1 ...
[11:00:08.744] Exporting ‘...future.FUN’ (3.91 KiB) to cluster node #1 ... DONE
[11:00:08.744] Exporting ‘x_FUN’ (37 bytes) to cluster node #1 ...
[11:00:08.744] Exporting ‘x_FUN’ (37 bytes) to cluster node #1 ... DONE
[11:00:08.744] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[11:00:08.745] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[11:00:08.745] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[11:00:08.786] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[11:00:08.786] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[11:00:08.827] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[11:00:08.827] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[11:00:08.829] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[11:00:08.829] Exporting ‘valid_types’ (61 bytes) to cluster node #1 ...
[11:00:08.830] Exporting ‘valid_types’ (61 bytes) to cluster node #1 ... DONE
[11:00:08.830] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[11:00:08.830] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[11:00:08.830] Exporting ‘...future.elements_ii’ (89 bytes) to cluster node #1 ...
[11:00:08.830] Exporting ‘...future.elements_ii’ (89 bytes) to cluster node #1 ... DONE
[11:00:08.831] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[11:00:08.831] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[11:00:08.831] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[11:00:08.831] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[11:00:08.831] Exporting 11 global objects (12.36 KiB) to cluster node #1 ... DONE
[11:00:08.832] MultisessionFuture started
[11:00:08.832] - Launch lazy future ... done
[11:00:08.832] run() for ‘MultisessionFuture’ ... done
[11:00:08.832] Created future:
[11:00:08.832] MultisessionFuture:
[11:00:08.832] Label: ‘future_vapply-1’
[11:00:08.832] Expression:
[11:00:08.832] {
[11:00:08.832]     do.call(function(...) {
[11:00:08.832]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:08.832]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:08.832]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:08.832]             on.exit(options(oopts), add = TRUE)
[11:00:08.832]         }
[11:00:08.832]         {
[11:00:08.832]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:08.832]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:08.832]                 ...future.FUN(...future.X_jj, ...)
[11:00:08.832]             })
[11:00:08.832]         }
[11:00:08.832]     }, args = future.call.arguments)
[11:00:08.832] }
[11:00:08.832] Lazy evaluation: FALSE
[11:00:08.832] Asynchronous evaluation: TRUE
[11:00:08.832] Local evaluation: TRUE
[11:00:08.832] Environment: R_GlobalEnv
[11:00:08.832] Capture standard output: TRUE
[11:00:08.832] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:08.832] Globals: 11 objects totaling 12.15 KiB (function ‘...future.FUN’ of 3.91 KiB, function ‘x_FUN’ of 37 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:08.832] Packages: 1 packages (‘future.apply’)
[11:00:08.832] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:08.832] Resolved: FALSE
[11:00:08.832] Value: <not collected>
[11:00:08.832] Conditions captured: <none>
[11:00:08.832] Early signaling: FALSE
[11:00:08.832] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:08.832] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:08.844] Chunk #1 of 2 ... DONE
[11:00:08.844] Chunk #2 of 2 ...
[11:00:08.844]  - Finding globals in 'X' for chunk #2 ...
[11:00:08.844] getGlobalsAndPackages() ...
[11:00:08.844] Searching for globals...
[11:00:08.844] 
[11:00:08.844] Searching for globals ... DONE
[11:00:08.845] - globals: [0] <none>
[11:00:08.845] getGlobalsAndPackages() ... DONE
[11:00:08.845]    + additional globals found: [n=0] 
[11:00:08.845]    + additional namespaces needed: [n=0] 
[11:00:08.845]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:08.845]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:08.845]  - seeds: <none>
[11:00:08.845]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:08.845] getGlobalsAndPackages() ...
[11:00:08.845] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:08.845] Resolving globals: FALSE
[11:00:08.846] Tweak future expression to call with '...' arguments ...
[11:00:08.846] {
[11:00:08.846]     do.call(function(...) {
[11:00:08.846]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:08.846]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:08.846]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:08.846]             on.exit(options(oopts), add = TRUE)
[11:00:08.846]         }
[11:00:08.846]         {
[11:00:08.846]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:08.846]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:08.846]                 ...future.FUN(...future.X_jj, ...)
[11:00:08.846]             })
[11:00:08.846]         }
[11:00:08.846]     }, args = future.call.arguments)
[11:00:08.846] }
[11:00:08.846] Tweak future expression to call with '...' arguments ... DONE
[11:00:08.846] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:08.846] - packages: [1] ‘future.apply’
[11:00:08.847] getGlobalsAndPackages() ... DONE
[11:00:08.847] run() for ‘Future’ ...
[11:00:08.847] - state: ‘created’
[11:00:08.847] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:08.860] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:08.860] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:08.861]   - Field: ‘node’
[11:00:08.861]   - Field: ‘label’
[11:00:08.861]   - Field: ‘local’
[11:00:08.861]   - Field: ‘owner’
[11:00:08.861]   - Field: ‘envir’
[11:00:08.861]   - Field: ‘workers’
[11:00:08.861]   - Field: ‘packages’
[11:00:08.861]   - Field: ‘gc’
[11:00:08.861]   - Field: ‘conditions’
[11:00:08.861]   - Field: ‘persistent’
[11:00:08.861]   - Field: ‘expr’
[11:00:08.861]   - Field: ‘uuid’
[11:00:08.862]   - Field: ‘seed’
[11:00:08.862]   - Field: ‘version’
[11:00:08.862]   - Field: ‘result’
[11:00:08.862]   - Field: ‘asynchronous’
[11:00:08.862]   - Field: ‘calls’
[11:00:08.862]   - Field: ‘globals’
[11:00:08.862]   - Field: ‘stdout’
[11:00:08.862]   - Field: ‘earlySignal’
[11:00:08.862]   - Field: ‘lazy’
[11:00:08.862]   - Field: ‘state’
[11:00:08.862] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:08.862] - Launch lazy future ...
[11:00:08.863] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:08.863] Packages needed by future strategies (n = 0): <none>
[11:00:08.863] {
[11:00:08.863]     {
[11:00:08.863]         {
[11:00:08.863]             ...future.startTime <- base::Sys.time()
[11:00:08.863]             {
[11:00:08.863]                 {
[11:00:08.863]                   {
[11:00:08.863]                     {
[11:00:08.863]                       {
[11:00:08.863]                         base::local({
[11:00:08.863]                           has_future <- base::requireNamespace("future", 
[11:00:08.863]                             quietly = TRUE)
[11:00:08.863]                           if (has_future) {
[11:00:08.863]                             ns <- base::getNamespace("future")
[11:00:08.863]                             version <- ns[[".package"]][["version"]]
[11:00:08.863]                             if (is.null(version)) 
[11:00:08.863]                               version <- utils::packageVersion("future")
[11:00:08.863]                           }
[11:00:08.863]                           else {
[11:00:08.863]                             version <- NULL
[11:00:08.863]                           }
[11:00:08.863]                           if (!has_future || version < "1.8.0") {
[11:00:08.863]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:08.863]                               "", base::R.version$version.string), 
[11:00:08.863]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:08.863]                                 base::R.version$platform, 8 * 
[11:00:08.863]                                   base::.Machine$sizeof.pointer), 
[11:00:08.863]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:08.863]                                 "release", "version")], collapse = " "), 
[11:00:08.863]                               hostname = base::Sys.info()[["nodename"]])
[11:00:08.863]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:08.863]                               info)
[11:00:08.863]                             info <- base::paste(info, collapse = "; ")
[11:00:08.863]                             if (!has_future) {
[11:00:08.863]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:08.863]                                 info)
[11:00:08.863]                             }
[11:00:08.863]                             else {
[11:00:08.863]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:08.863]                                 info, version)
[11:00:08.863]                             }
[11:00:08.863]                             base::stop(msg)
[11:00:08.863]                           }
[11:00:08.863]                         })
[11:00:08.863]                       }
[11:00:08.863]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:08.863]                       base::options(mc.cores = 1L)
[11:00:08.863]                     }
[11:00:08.863]                     base::local({
[11:00:08.863]                       for (pkg in "future.apply") {
[11:00:08.863]                         base::loadNamespace(pkg)
[11:00:08.863]                         base::library(pkg, character.only = TRUE)
[11:00:08.863]                       }
[11:00:08.863]                     })
[11:00:08.863]                   }
[11:00:08.863]                   ...future.strategy.old <- future::plan("list")
[11:00:08.863]                   options(future.plan = NULL)
[11:00:08.863]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:08.863]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:08.863]                 }
[11:00:08.863]                 ...future.workdir <- getwd()
[11:00:08.863]             }
[11:00:08.863]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:08.863]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:08.863]         }
[11:00:08.863]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:08.863]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:08.863]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:08.863]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:08.863]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:08.863]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:08.863]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:08.863]             base::names(...future.oldOptions))
[11:00:08.863]     }
[11:00:08.863]     if (FALSE) {
[11:00:08.863]     }
[11:00:08.863]     else {
[11:00:08.863]         if (TRUE) {
[11:00:08.863]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:08.863]                 open = "w")
[11:00:08.863]         }
[11:00:08.863]         else {
[11:00:08.863]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:08.863]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:08.863]         }
[11:00:08.863]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:08.863]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:08.863]             base::sink(type = "output", split = FALSE)
[11:00:08.863]             base::close(...future.stdout)
[11:00:08.863]         }, add = TRUE)
[11:00:08.863]     }
[11:00:08.863]     ...future.frame <- base::sys.nframe()
[11:00:08.863]     ...future.conditions <- base::list()
[11:00:08.863]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:08.863]     if (FALSE) {
[11:00:08.863]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:08.863]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:08.863]     }
[11:00:08.863]     ...future.result <- base::tryCatch({
[11:00:08.863]         base::withCallingHandlers({
[11:00:08.863]             ...future.value <- base::withVisible(base::local({
[11:00:08.863]                 ...future.makeSendCondition <- base::local({
[11:00:08.863]                   sendCondition <- NULL
[11:00:08.863]                   function(frame = 1L) {
[11:00:08.863]                     if (is.function(sendCondition)) 
[11:00:08.863]                       return(sendCondition)
[11:00:08.863]                     ns <- getNamespace("parallel")
[11:00:08.863]                     if (exists("sendData", mode = "function", 
[11:00:08.863]                       envir = ns)) {
[11:00:08.863]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:08.863]                         envir = ns)
[11:00:08.863]                       envir <- sys.frame(frame)
[11:00:08.863]                       master <- NULL
[11:00:08.863]                       while (!identical(envir, .GlobalEnv) && 
[11:00:08.863]                         !identical(envir, emptyenv())) {
[11:00:08.863]                         if (exists("master", mode = "list", envir = envir, 
[11:00:08.863]                           inherits = FALSE)) {
[11:00:08.863]                           master <- get("master", mode = "list", 
[11:00:08.863]                             envir = envir, inherits = FALSE)
[11:00:08.863]                           if (inherits(master, c("SOCKnode", 
[11:00:08.863]                             "SOCK0node"))) {
[11:00:08.863]                             sendCondition <<- function(cond) {
[11:00:08.863]                               data <- list(type = "VALUE", value = cond, 
[11:00:08.863]                                 success = TRUE)
[11:00:08.863]                               parallel_sendData(master, data)
[11:00:08.863]                             }
[11:00:08.863]                             return(sendCondition)
[11:00:08.863]                           }
[11:00:08.863]                         }
[11:00:08.863]                         frame <- frame + 1L
[11:00:08.863]                         envir <- sys.frame(frame)
[11:00:08.863]                       }
[11:00:08.863]                     }
[11:00:08.863]                     sendCondition <<- function(cond) NULL
[11:00:08.863]                   }
[11:00:08.863]                 })
[11:00:08.863]                 withCallingHandlers({
[11:00:08.863]                   {
[11:00:08.863]                     do.call(function(...) {
[11:00:08.863]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:08.863]                       if (!identical(...future.globals.maxSize.org, 
[11:00:08.863]                         ...future.globals.maxSize)) {
[11:00:08.863]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:08.863]                         on.exit(options(oopts), add = TRUE)
[11:00:08.863]                       }
[11:00:08.863]                       {
[11:00:08.863]                         lapply(seq_along(...future.elements_ii), 
[11:00:08.863]                           FUN = function(jj) {
[11:00:08.863]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:08.863]                             ...future.FUN(...future.X_jj, ...)
[11:00:08.863]                           })
[11:00:08.863]                       }
[11:00:08.863]                     }, args = future.call.arguments)
[11:00:08.863]                   }
[11:00:08.863]                 }, immediateCondition = function(cond) {
[11:00:08.863]                   sendCondition <- ...future.makeSendCondition()
[11:00:08.863]                   sendCondition(cond)
[11:00:08.863]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:08.863]                   {
[11:00:08.863]                     inherits <- base::inherits
[11:00:08.863]                     invokeRestart <- base::invokeRestart
[11:00:08.863]                     is.null <- base::is.null
[11:00:08.863]                     muffled <- FALSE
[11:00:08.863]                     if (inherits(cond, "message")) {
[11:00:08.863]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:08.863]                       if (muffled) 
[11:00:08.863]                         invokeRestart("muffleMessage")
[11:00:08.863]                     }
[11:00:08.863]                     else if (inherits(cond, "warning")) {
[11:00:08.863]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:08.863]                       if (muffled) 
[11:00:08.863]                         invokeRestart("muffleWarning")
[11:00:08.863]                     }
[11:00:08.863]                     else if (inherits(cond, "condition")) {
[11:00:08.863]                       if (!is.null(pattern)) {
[11:00:08.863]                         computeRestarts <- base::computeRestarts
[11:00:08.863]                         grepl <- base::grepl
[11:00:08.863]                         restarts <- computeRestarts(cond)
[11:00:08.863]                         for (restart in restarts) {
[11:00:08.863]                           name <- restart$name
[11:00:08.863]                           if (is.null(name)) 
[11:00:08.863]                             next
[11:00:08.863]                           if (!grepl(pattern, name)) 
[11:00:08.863]                             next
[11:00:08.863]                           invokeRestart(restart)
[11:00:08.863]                           muffled <- TRUE
[11:00:08.863]                           break
[11:00:08.863]                         }
[11:00:08.863]                       }
[11:00:08.863]                     }
[11:00:08.863]                     invisible(muffled)
[11:00:08.863]                   }
[11:00:08.863]                   muffleCondition(cond)
[11:00:08.863]                 })
[11:00:08.863]             }))
[11:00:08.863]             future::FutureResult(value = ...future.value$value, 
[11:00:08.863]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:08.863]                   ...future.rng), globalenv = if (FALSE) 
[11:00:08.863]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:08.863]                     ...future.globalenv.names))
[11:00:08.863]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:08.863]         }, condition = base::local({
[11:00:08.863]             c <- base::c
[11:00:08.863]             inherits <- base::inherits
[11:00:08.863]             invokeRestart <- base::invokeRestart
[11:00:08.863]             length <- base::length
[11:00:08.863]             list <- base::list
[11:00:08.863]             seq.int <- base::seq.int
[11:00:08.863]             signalCondition <- base::signalCondition
[11:00:08.863]             sys.calls <- base::sys.calls
[11:00:08.863]             `[[` <- base::`[[`
[11:00:08.863]             `+` <- base::`+`
[11:00:08.863]             `<<-` <- base::`<<-`
[11:00:08.863]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:08.863]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:08.863]                   3L)]
[11:00:08.863]             }
[11:00:08.863]             function(cond) {
[11:00:08.863]                 is_error <- inherits(cond, "error")
[11:00:08.863]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:08.863]                   NULL)
[11:00:08.863]                 if (is_error) {
[11:00:08.863]                   sessionInformation <- function() {
[11:00:08.863]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:08.863]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:08.863]                       search = base::search(), system = base::Sys.info())
[11:00:08.863]                   }
[11:00:08.863]                   ...future.conditions[[length(...future.conditions) + 
[11:00:08.863]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:08.863]                     cond$call), session = sessionInformation(), 
[11:00:08.863]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:08.863]                   signalCondition(cond)
[11:00:08.863]                 }
[11:00:08.863]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:08.863]                 "immediateCondition"))) {
[11:00:08.863]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:08.863]                   ...future.conditions[[length(...future.conditions) + 
[11:00:08.863]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:08.863]                   if (TRUE && !signal) {
[11:00:08.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:08.863]                     {
[11:00:08.863]                       inherits <- base::inherits
[11:00:08.863]                       invokeRestart <- base::invokeRestart
[11:00:08.863]                       is.null <- base::is.null
[11:00:08.863]                       muffled <- FALSE
[11:00:08.863]                       if (inherits(cond, "message")) {
[11:00:08.863]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:08.863]                         if (muffled) 
[11:00:08.863]                           invokeRestart("muffleMessage")
[11:00:08.863]                       }
[11:00:08.863]                       else if (inherits(cond, "warning")) {
[11:00:08.863]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:08.863]                         if (muffled) 
[11:00:08.863]                           invokeRestart("muffleWarning")
[11:00:08.863]                       }
[11:00:08.863]                       else if (inherits(cond, "condition")) {
[11:00:08.863]                         if (!is.null(pattern)) {
[11:00:08.863]                           computeRestarts <- base::computeRestarts
[11:00:08.863]                           grepl <- base::grepl
[11:00:08.863]                           restarts <- computeRestarts(cond)
[11:00:08.863]                           for (restart in restarts) {
[11:00:08.863]                             name <- restart$name
[11:00:08.863]                             if (is.null(name)) 
[11:00:08.863]                               next
[11:00:08.863]                             if (!grepl(pattern, name)) 
[11:00:08.863]                               next
[11:00:08.863]                             invokeRestart(restart)
[11:00:08.863]                             muffled <- TRUE
[11:00:08.863]                             break
[11:00:08.863]                           }
[11:00:08.863]                         }
[11:00:08.863]                       }
[11:00:08.863]                       invisible(muffled)
[11:00:08.863]                     }
[11:00:08.863]                     muffleCondition(cond, pattern = "^muffle")
[11:00:08.863]                   }
[11:00:08.863]                 }
[11:00:08.863]                 else {
[11:00:08.863]                   if (TRUE) {
[11:00:08.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:08.863]                     {
[11:00:08.863]                       inherits <- base::inherits
[11:00:08.863]                       invokeRestart <- base::invokeRestart
[11:00:08.863]                       is.null <- base::is.null
[11:00:08.863]                       muffled <- FALSE
[11:00:08.863]                       if (inherits(cond, "message")) {
[11:00:08.863]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:08.863]                         if (muffled) 
[11:00:08.863]                           invokeRestart("muffleMessage")
[11:00:08.863]                       }
[11:00:08.863]                       else if (inherits(cond, "warning")) {
[11:00:08.863]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:08.863]                         if (muffled) 
[11:00:08.863]                           invokeRestart("muffleWarning")
[11:00:08.863]                       }
[11:00:08.863]                       else if (inherits(cond, "condition")) {
[11:00:08.863]                         if (!is.null(pattern)) {
[11:00:08.863]                           computeRestarts <- base::computeRestarts
[11:00:08.863]                           grepl <- base::grepl
[11:00:08.863]                           restarts <- computeRestarts(cond)
[11:00:08.863]                           for (restart in restarts) {
[11:00:08.863]                             name <- restart$name
[11:00:08.863]                             if (is.null(name)) 
[11:00:08.863]                               next
[11:00:08.863]                             if (!grepl(pattern, name)) 
[11:00:08.863]                               next
[11:00:08.863]                             invokeRestart(restart)
[11:00:08.863]                             muffled <- TRUE
[11:00:08.863]                             break
[11:00:08.863]                           }
[11:00:08.863]                         }
[11:00:08.863]                       }
[11:00:08.863]                       invisible(muffled)
[11:00:08.863]                     }
[11:00:08.863]                     muffleCondition(cond, pattern = "^muffle")
[11:00:08.863]                   }
[11:00:08.863]                 }
[11:00:08.863]             }
[11:00:08.863]         }))
[11:00:08.863]     }, error = function(ex) {
[11:00:08.863]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:08.863]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:08.863]                 ...future.rng), started = ...future.startTime, 
[11:00:08.863]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:08.863]             version = "1.8"), class = "FutureResult")
[11:00:08.863]     }, finally = {
[11:00:08.863]         if (!identical(...future.workdir, getwd())) 
[11:00:08.863]             setwd(...future.workdir)
[11:00:08.863]         {
[11:00:08.863]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:08.863]                 ...future.oldOptions$nwarnings <- NULL
[11:00:08.863]             }
[11:00:08.863]             base::options(...future.oldOptions)
[11:00:08.863]             if (.Platform$OS.type == "windows") {
[11:00:08.863]                 old_names <- names(...future.oldEnvVars)
[11:00:08.863]                 envs <- base::Sys.getenv()
[11:00:08.863]                 names <- names(envs)
[11:00:08.863]                 common <- intersect(names, old_names)
[11:00:08.863]                 added <- setdiff(names, old_names)
[11:00:08.863]                 removed <- setdiff(old_names, names)
[11:00:08.863]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:08.863]                   envs[common]]
[11:00:08.863]                 NAMES <- toupper(changed)
[11:00:08.863]                 args <- list()
[11:00:08.863]                 for (kk in seq_along(NAMES)) {
[11:00:08.863]                   name <- changed[[kk]]
[11:00:08.863]                   NAME <- NAMES[[kk]]
[11:00:08.863]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:08.863]                     next
[11:00:08.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:08.863]                 }
[11:00:08.863]                 NAMES <- toupper(added)
[11:00:08.863]                 for (kk in seq_along(NAMES)) {
[11:00:08.863]                   name <- added[[kk]]
[11:00:08.863]                   NAME <- NAMES[[kk]]
[11:00:08.863]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:08.863]                     next
[11:00:08.863]                   args[[name]] <- ""
[11:00:08.863]                 }
[11:00:08.863]                 NAMES <- toupper(removed)
[11:00:08.863]                 for (kk in seq_along(NAMES)) {
[11:00:08.863]                   name <- removed[[kk]]
[11:00:08.863]                   NAME <- NAMES[[kk]]
[11:00:08.863]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:08.863]                     next
[11:00:08.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:08.863]                 }
[11:00:08.863]                 if (length(args) > 0) 
[11:00:08.863]                   base::do.call(base::Sys.setenv, args = args)
[11:00:08.863]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:08.863]             }
[11:00:08.863]             else {
[11:00:08.863]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:08.863]             }
[11:00:08.863]             {
[11:00:08.863]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:08.863]                   0L) {
[11:00:08.863]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:08.863]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:08.863]                   base::options(opts)
[11:00:08.863]                 }
[11:00:08.863]                 {
[11:00:08.863]                   {
[11:00:08.863]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:08.863]                     NULL
[11:00:08.863]                   }
[11:00:08.863]                   options(future.plan = NULL)
[11:00:08.863]                   if (is.na(NA_character_)) 
[11:00:08.863]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:08.863]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:08.863]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:08.863]                     .init = FALSE)
[11:00:08.863]                 }
[11:00:08.863]             }
[11:00:08.863]         }
[11:00:08.863]     })
[11:00:08.863]     if (TRUE) {
[11:00:08.863]         base::sink(type = "output", split = FALSE)
[11:00:08.863]         if (TRUE) {
[11:00:08.863]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:08.863]         }
[11:00:08.863]         else {
[11:00:08.863]             ...future.result["stdout"] <- base::list(NULL)
[11:00:08.863]         }
[11:00:08.863]         base::close(...future.stdout)
[11:00:08.863]         ...future.stdout <- NULL
[11:00:08.863]     }
[11:00:08.863]     ...future.result$conditions <- ...future.conditions
[11:00:08.863]     ...future.result$finished <- base::Sys.time()
[11:00:08.863]     ...future.result
[11:00:08.863] }
[11:00:08.868] Exporting 11 global objects (12.39 KiB) to cluster node #2 ...
[11:00:08.868] Exporting ‘...future.FUN’ (3.91 KiB) to cluster node #2 ...
[11:00:08.909] Exporting ‘...future.FUN’ (3.91 KiB) to cluster node #2 ... DONE
[11:00:08.909] Exporting ‘x_FUN’ (37 bytes) to cluster node #2 ...
[11:00:08.909] Exporting ‘x_FUN’ (37 bytes) to cluster node #2 ... DONE
[11:00:08.909] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[11:00:08.910] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[11:00:08.910] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[11:00:08.951] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[11:00:08.951] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[11:00:08.992] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[11:00:08.992] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[11:00:08.992] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[11:00:08.992] Exporting ‘valid_types’ (61 bytes) to cluster node #2 ...
[11:00:08.993] Exporting ‘valid_types’ (61 bytes) to cluster node #2 ... DONE
[11:00:08.993] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[11:00:08.993] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[11:00:08.993] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #2 ...
[11:00:08.994] Exporting ‘...future.elements_ii’ (114 bytes) to cluster node #2 ... DONE
[11:00:08.994] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[11:00:08.994] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[11:00:08.994] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[11:00:08.994] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[11:00:08.995] Exporting 11 global objects (12.39 KiB) to cluster node #2 ... DONE
[11:00:08.995] MultisessionFuture started
[11:00:08.995] - Launch lazy future ... done
[11:00:08.995] run() for ‘MultisessionFuture’ ... done
[11:00:08.995] Created future:
[11:00:08.995] MultisessionFuture:
[11:00:08.995] Label: ‘future_vapply-2’
[11:00:08.995] Expression:
[11:00:08.995] {
[11:00:08.995]     do.call(function(...) {
[11:00:08.995]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:08.995]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:08.995]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:08.995]             on.exit(options(oopts), add = TRUE)
[11:00:08.995]         }
[11:00:08.995]         {
[11:00:08.995]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:08.995]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:08.995]                 ...future.FUN(...future.X_jj, ...)
[11:00:08.995]             })
[11:00:08.995]         }
[11:00:08.995]     }, args = future.call.arguments)
[11:00:08.995] }
[11:00:08.995] Lazy evaluation: FALSE
[11:00:08.995] Asynchronous evaluation: TRUE
[11:00:08.995] Local evaluation: TRUE
[11:00:08.995] Environment: R_GlobalEnv
[11:00:08.995] Capture standard output: TRUE
[11:00:08.995] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:08.995] Globals: 11 objects totaling 12.17 KiB (function ‘...future.FUN’ of 3.91 KiB, function ‘x_FUN’ of 37 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:08.995] Packages: 1 packages (‘future.apply’)
[11:00:08.995] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:08.995] Resolved: FALSE
[11:00:08.995] Value: <not collected>
[11:00:08.995] Conditions captured: <none>
[11:00:08.995] Early signaling: FALSE
[11:00:08.995] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:08.995] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:09.007] Chunk #2 of 2 ... DONE
[11:00:09.007] Launching 2 futures (chunks) ... DONE
[11:00:09.007] Resolving 2 futures (chunks) ...
[11:00:09.007] resolve() on list ...
[11:00:09.007]  recursive: 0
[11:00:09.007]  length: 2
[11:00:09.007] 
[11:00:09.008] receiveMessageFromWorker() for ClusterFuture ...
[11:00:09.008] - Validating connection of MultisessionFuture
[11:00:09.008] - received message: FutureResult
[11:00:09.008] - Received FutureResult
[11:00:09.008] - Erased future from FutureRegistry
[11:00:09.008] result() for ClusterFuture ...
[11:00:09.009] - result already collected: FutureResult
[11:00:09.009] result() for ClusterFuture ... done
[11:00:09.009] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:09.009] Future #1
[11:00:09.009] result() for ClusterFuture ...
[11:00:09.009] - result already collected: FutureResult
[11:00:09.009] result() for ClusterFuture ... done
[11:00:09.009] result() for ClusterFuture ...
[11:00:09.009] - result already collected: FutureResult
[11:00:09.009] result() for ClusterFuture ... done
[11:00:09.009] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:00:09.009] - nx: 2
[11:00:09.010] - relay: TRUE
[11:00:09.010] - stdout: TRUE
[11:00:09.010] - signal: TRUE
[11:00:09.010] - resignal: FALSE
[11:00:09.010] - force: TRUE
[11:00:09.010] - relayed: [n=2] FALSE, FALSE
[11:00:09.010] - queued futures: [n=2] FALSE, FALSE
[11:00:09.010]  - until=1
[11:00:09.010]  - relaying element #1
[11:00:09.010] result() for ClusterFuture ...
[11:00:09.010] - result already collected: FutureResult
[11:00:09.010] result() for ClusterFuture ... done
[11:00:09.011] result() for ClusterFuture ...
[11:00:09.011] - result already collected: FutureResult
[11:00:09.011] result() for ClusterFuture ... done
[11:00:09.011] result() for ClusterFuture ...
[11:00:09.011] - result already collected: FutureResult
[11:00:09.011] result() for ClusterFuture ... done
[11:00:09.011] result() for ClusterFuture ...
[11:00:09.011] - result already collected: FutureResult
[11:00:09.011] result() for ClusterFuture ... done
[11:00:09.011] - relayed: [n=2] TRUE, FALSE
[11:00:09.011] - queued futures: [n=2] TRUE, FALSE
[11:00:09.011] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:00:09.011]  length: 1 (resolved future 1)
[11:00:09.037] receiveMessageFromWorker() for ClusterFuture ...
[11:00:09.037] - Validating connection of MultisessionFuture
[11:00:09.037] - received message: FutureResult
[11:00:09.038] - Received FutureResult
[11:00:09.038] - Erased future from FutureRegistry
[11:00:09.038] result() for ClusterFuture ...
[11:00:09.038] - result already collected: FutureResult
[11:00:09.038] result() for ClusterFuture ... done
[11:00:09.038] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:09.038] Future #2
[11:00:09.038] result() for ClusterFuture ...
[11:00:09.038] - result already collected: FutureResult
[11:00:09.038] result() for ClusterFuture ... done
[11:00:09.038] result() for ClusterFuture ...
[11:00:09.039] - result already collected: FutureResult
[11:00:09.039] result() for ClusterFuture ... done
[11:00:09.039] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:00:09.039] - nx: 2
[11:00:09.039] - relay: TRUE
[11:00:09.039] - stdout: TRUE
[11:00:09.039] - signal: TRUE
[11:00:09.039] - resignal: FALSE
[11:00:09.039] - force: TRUE
[11:00:09.039] - relayed: [n=2] TRUE, FALSE
[11:00:09.039] - queued futures: [n=2] TRUE, FALSE
[11:00:09.039]  - until=2
[11:00:09.039]  - relaying element #2
[11:00:09.040] result() for ClusterFuture ...
[11:00:09.040] - result already collected: FutureResult
[11:00:09.040] result() for ClusterFuture ... done
[11:00:09.040] result() for ClusterFuture ...
[11:00:09.040] - result already collected: FutureResult
[11:00:09.040] result() for ClusterFuture ... done
[11:00:09.040] result() for ClusterFuture ...
[11:00:09.040] - result already collected: FutureResult
[11:00:09.040] result() for ClusterFuture ... done
[11:00:09.040] result() for ClusterFuture ...
[11:00:09.040] - result already collected: FutureResult
[11:00:09.040] result() for ClusterFuture ... done
[11:00:09.040] - relayed: [n=2] TRUE, TRUE
[11:00:09.041] - queued futures: [n=2] TRUE, TRUE
[11:00:09.041] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:00:09.041]  length: 0 (resolved future 2)
[11:00:09.041] Relaying remaining futures
[11:00:09.041] signalConditionsASAP(NULL, pos=0) ...
[11:00:09.041] - nx: 2
[11:00:09.041] - relay: TRUE
[11:00:09.041] - stdout: TRUE
[11:00:09.041] - signal: TRUE
[11:00:09.041] - resignal: FALSE
[11:00:09.041] - force: TRUE
[11:00:09.041] - relayed: [n=2] TRUE, TRUE
[11:00:09.041] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:09.042] - relayed: [n=2] TRUE, TRUE
[11:00:09.042] - queued futures: [n=2] TRUE, TRUE
[11:00:09.042] signalConditionsASAP(NULL, pos=0) ... done
[11:00:09.042] resolve() on list ... DONE
[11:00:09.042] result() for ClusterFuture ...
[11:00:09.042] - result already collected: FutureResult
[11:00:09.042] result() for ClusterFuture ... done
[11:00:09.042] result() for ClusterFuture ...
[11:00:09.042] - result already collected: FutureResult
[11:00:09.042] result() for ClusterFuture ... done
[11:00:09.042] result() for ClusterFuture ...
[11:00:09.043] - result already collected: FutureResult
[11:00:09.043] result() for ClusterFuture ... done
[11:00:09.043] result() for ClusterFuture ...
[11:00:09.043] - result already collected: FutureResult
[11:00:09.043] result() for ClusterFuture ... done
[11:00:09.043]  - Number of value chunks collected: 2
[11:00:09.043] Resolving 2 futures (chunks) ... DONE
[11:00:09.043] Reducing values from 2 chunks ...
[11:00:09.043]  - Number of values collected after concatenation: 3
[11:00:09.043]  - Number of values expected: 3
[11:00:09.043] Reducing values from 2 chunks ... DONE
[11:00:09.043] future_lapply() ... DONE
- exceptions ...
[11:00:09.044] future_lapply() ...
[11:00:09.047] Number of chunks: 2
[11:00:09.047] getGlobalsAndPackagesXApply() ...
[11:00:09.047]  - future.globals: TRUE
[11:00:09.047] getGlobalsAndPackages() ...
[11:00:09.047] Searching for globals...
[11:00:09.050] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[11:00:09.050] Searching for globals ... DONE
[11:00:09.050] Resolving globals: FALSE
[11:00:09.051] The total size of the 7 globals is 12.81 KiB (13119 bytes)
[11:00:09.051] The total size of the 7 globals exported for future expression (‘FUN()’) is 12.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘FUN’ (4.65 KiB of class ‘function’), ‘stop_if_not’ (4.51 KiB of class ‘function’) and ‘stopf’ (3.33 KiB of class ‘function’)
[11:00:09.052] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:09.052] - packages: [1] ‘future.apply’
[11:00:09.052] getGlobalsAndPackages() ... DONE
[11:00:09.052]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[11:00:09.052]  - needed namespaces: [n=1] ‘future.apply’
[11:00:09.052] Finding globals ... DONE
[11:00:09.052]  - use_args: TRUE
[11:00:09.052]  - Getting '...' globals ...
[11:00:09.053] resolve() on list ...
[11:00:09.053]  recursive: 0
[11:00:09.053]  length: 1
[11:00:09.053]  elements: ‘...’
[11:00:09.053]  length: 0 (resolved future 1)
[11:00:09.053] resolve() on list ... DONE
[11:00:09.053]    - '...' content: [n=0] 
[11:00:09.053] List of 1
[11:00:09.053]  $ ...: list()
[11:00:09.053]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:09.053]  - attr(*, "where")=List of 1
[11:00:09.053]   ..$ ...:<environment: 0x55bbaf714f08> 
[11:00:09.053]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:09.053]  - attr(*, "resolved")= logi TRUE
[11:00:09.053]  - attr(*, "total_size")= num NA
[11:00:09.055]  - Getting '...' globals ... DONE
[11:00:09.056] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[11:00:09.056] List of 8
[11:00:09.056]  $ ...future.FUN:function (x, ...)  
[11:00:09.056]  $ x_FUN        :function (x)  
[11:00:09.056]  $ times        : int 2
[11:00:09.056]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[11:00:09.056]  $ stop_if_not  :function (...)  
[11:00:09.056]  $ dim          : NULL
[11:00:09.056]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[11:00:09.056]  $ ...          : list()
[11:00:09.056]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:09.056]  - attr(*, "where")=List of 8
[11:00:09.056]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:09.056]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[11:00:09.056]   ..$ times        :<environment: R_EmptyEnv> 
[11:00:09.056]   ..$ stopf        :<environment: R_EmptyEnv> 
[11:00:09.056]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[11:00:09.056]   ..$ dim          :<environment: R_EmptyEnv> 
[11:00:09.056]   ..$ valid_types  :<environment: R_EmptyEnv> 
[11:00:09.056]   ..$ ...          :<environment: 0x55bbaf714f08> 
[11:00:09.056]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:09.056]  - attr(*, "resolved")= logi FALSE
[11:00:09.056]  - attr(*, "total_size")= num 23676
[11:00:09.061] Packages to be attached in all futures: [n=1] ‘future.apply’
[11:00:09.061] getGlobalsAndPackagesXApply() ... DONE
[11:00:09.061] Number of futures (= number of chunks): 2
[11:00:09.061] Launching 2 futures (chunks) ...
[11:00:09.061] Chunk #1 of 2 ...
[11:00:09.061]  - Finding globals in 'X' for chunk #1 ...
[11:00:09.061] getGlobalsAndPackages() ...
[11:00:09.062] Searching for globals...
[11:00:09.062] 
[11:00:09.062] Searching for globals ... DONE
[11:00:09.062] - globals: [0] <none>
[11:00:09.062] getGlobalsAndPackages() ... DONE
[11:00:09.062]    + additional globals found: [n=0] 
[11:00:09.062]    + additional namespaces needed: [n=0] 
[11:00:09.062]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:09.062]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:09.062]  - seeds: <none>
[11:00:09.062]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:09.063] getGlobalsAndPackages() ...
[11:00:09.063] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:09.063] Resolving globals: FALSE
[11:00:09.063] Tweak future expression to call with '...' arguments ...
[11:00:09.063] {
[11:00:09.063]     do.call(function(...) {
[11:00:09.063]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:09.063]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:09.063]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:09.063]             on.exit(options(oopts), add = TRUE)
[11:00:09.063]         }
[11:00:09.063]         {
[11:00:09.063]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:09.063]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:09.063]                 ...future.FUN(...future.X_jj, ...)
[11:00:09.063]             })
[11:00:09.063]         }
[11:00:09.063]     }, args = future.call.arguments)
[11:00:09.063] }
[11:00:09.063] Tweak future expression to call with '...' arguments ... DONE
[11:00:09.064] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:09.064] - packages: [1] ‘future.apply’
[11:00:09.064] getGlobalsAndPackages() ... DONE
[11:00:09.064] run() for ‘Future’ ...
[11:00:09.064] - state: ‘created’
[11:00:09.064] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:09.078] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:09.078] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:09.078]   - Field: ‘node’
[11:00:09.078]   - Field: ‘label’
[11:00:09.078]   - Field: ‘local’
[11:00:09.078]   - Field: ‘owner’
[11:00:09.078]   - Field: ‘envir’
[11:00:09.079]   - Field: ‘workers’
[11:00:09.079]   - Field: ‘packages’
[11:00:09.079]   - Field: ‘gc’
[11:00:09.079]   - Field: ‘conditions’
[11:00:09.079]   - Field: ‘persistent’
[11:00:09.079]   - Field: ‘expr’
[11:00:09.079]   - Field: ‘uuid’
[11:00:09.079]   - Field: ‘seed’
[11:00:09.079]   - Field: ‘version’
[11:00:09.079]   - Field: ‘result’
[11:00:09.079]   - Field: ‘asynchronous’
[11:00:09.079]   - Field: ‘calls’
[11:00:09.080]   - Field: ‘globals’
[11:00:09.080]   - Field: ‘stdout’
[11:00:09.080]   - Field: ‘earlySignal’
[11:00:09.080]   - Field: ‘lazy’
[11:00:09.080]   - Field: ‘state’
[11:00:09.080] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:09.080] - Launch lazy future ...
[11:00:09.080] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:09.080] Packages needed by future strategies (n = 0): <none>
[11:00:09.081] {
[11:00:09.081]     {
[11:00:09.081]         {
[11:00:09.081]             ...future.startTime <- base::Sys.time()
[11:00:09.081]             {
[11:00:09.081]                 {
[11:00:09.081]                   {
[11:00:09.081]                     {
[11:00:09.081]                       {
[11:00:09.081]                         base::local({
[11:00:09.081]                           has_future <- base::requireNamespace("future", 
[11:00:09.081]                             quietly = TRUE)
[11:00:09.081]                           if (has_future) {
[11:00:09.081]                             ns <- base::getNamespace("future")
[11:00:09.081]                             version <- ns[[".package"]][["version"]]
[11:00:09.081]                             if (is.null(version)) 
[11:00:09.081]                               version <- utils::packageVersion("future")
[11:00:09.081]                           }
[11:00:09.081]                           else {
[11:00:09.081]                             version <- NULL
[11:00:09.081]                           }
[11:00:09.081]                           if (!has_future || version < "1.8.0") {
[11:00:09.081]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:09.081]                               "", base::R.version$version.string), 
[11:00:09.081]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:09.081]                                 base::R.version$platform, 8 * 
[11:00:09.081]                                   base::.Machine$sizeof.pointer), 
[11:00:09.081]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:09.081]                                 "release", "version")], collapse = " "), 
[11:00:09.081]                               hostname = base::Sys.info()[["nodename"]])
[11:00:09.081]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:09.081]                               info)
[11:00:09.081]                             info <- base::paste(info, collapse = "; ")
[11:00:09.081]                             if (!has_future) {
[11:00:09.081]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:09.081]                                 info)
[11:00:09.081]                             }
[11:00:09.081]                             else {
[11:00:09.081]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:09.081]                                 info, version)
[11:00:09.081]                             }
[11:00:09.081]                             base::stop(msg)
[11:00:09.081]                           }
[11:00:09.081]                         })
[11:00:09.081]                       }
[11:00:09.081]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:09.081]                       base::options(mc.cores = 1L)
[11:00:09.081]                     }
[11:00:09.081]                     base::local({
[11:00:09.081]                       for (pkg in "future.apply") {
[11:00:09.081]                         base::loadNamespace(pkg)
[11:00:09.081]                         base::library(pkg, character.only = TRUE)
[11:00:09.081]                       }
[11:00:09.081]                     })
[11:00:09.081]                   }
[11:00:09.081]                   ...future.strategy.old <- future::plan("list")
[11:00:09.081]                   options(future.plan = NULL)
[11:00:09.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:09.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:09.081]                 }
[11:00:09.081]                 ...future.workdir <- getwd()
[11:00:09.081]             }
[11:00:09.081]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:09.081]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:09.081]         }
[11:00:09.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:09.081]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:09.081]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:09.081]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:09.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:09.081]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:09.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:09.081]             base::names(...future.oldOptions))
[11:00:09.081]     }
[11:00:09.081]     if (FALSE) {
[11:00:09.081]     }
[11:00:09.081]     else {
[11:00:09.081]         if (TRUE) {
[11:00:09.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:09.081]                 open = "w")
[11:00:09.081]         }
[11:00:09.081]         else {
[11:00:09.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:09.081]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:09.081]         }
[11:00:09.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:09.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:09.081]             base::sink(type = "output", split = FALSE)
[11:00:09.081]             base::close(...future.stdout)
[11:00:09.081]         }, add = TRUE)
[11:00:09.081]     }
[11:00:09.081]     ...future.frame <- base::sys.nframe()
[11:00:09.081]     ...future.conditions <- base::list()
[11:00:09.081]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:09.081]     if (FALSE) {
[11:00:09.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:09.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:09.081]     }
[11:00:09.081]     ...future.result <- base::tryCatch({
[11:00:09.081]         base::withCallingHandlers({
[11:00:09.081]             ...future.value <- base::withVisible(base::local({
[11:00:09.081]                 ...future.makeSendCondition <- base::local({
[11:00:09.081]                   sendCondition <- NULL
[11:00:09.081]                   function(frame = 1L) {
[11:00:09.081]                     if (is.function(sendCondition)) 
[11:00:09.081]                       return(sendCondition)
[11:00:09.081]                     ns <- getNamespace("parallel")
[11:00:09.081]                     if (exists("sendData", mode = "function", 
[11:00:09.081]                       envir = ns)) {
[11:00:09.081]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:09.081]                         envir = ns)
[11:00:09.081]                       envir <- sys.frame(frame)
[11:00:09.081]                       master <- NULL
[11:00:09.081]                       while (!identical(envir, .GlobalEnv) && 
[11:00:09.081]                         !identical(envir, emptyenv())) {
[11:00:09.081]                         if (exists("master", mode = "list", envir = envir, 
[11:00:09.081]                           inherits = FALSE)) {
[11:00:09.081]                           master <- get("master", mode = "list", 
[11:00:09.081]                             envir = envir, inherits = FALSE)
[11:00:09.081]                           if (inherits(master, c("SOCKnode", 
[11:00:09.081]                             "SOCK0node"))) {
[11:00:09.081]                             sendCondition <<- function(cond) {
[11:00:09.081]                               data <- list(type = "VALUE", value = cond, 
[11:00:09.081]                                 success = TRUE)
[11:00:09.081]                               parallel_sendData(master, data)
[11:00:09.081]                             }
[11:00:09.081]                             return(sendCondition)
[11:00:09.081]                           }
[11:00:09.081]                         }
[11:00:09.081]                         frame <- frame + 1L
[11:00:09.081]                         envir <- sys.frame(frame)
[11:00:09.081]                       }
[11:00:09.081]                     }
[11:00:09.081]                     sendCondition <<- function(cond) NULL
[11:00:09.081]                   }
[11:00:09.081]                 })
[11:00:09.081]                 withCallingHandlers({
[11:00:09.081]                   {
[11:00:09.081]                     do.call(function(...) {
[11:00:09.081]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:09.081]                       if (!identical(...future.globals.maxSize.org, 
[11:00:09.081]                         ...future.globals.maxSize)) {
[11:00:09.081]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:09.081]                         on.exit(options(oopts), add = TRUE)
[11:00:09.081]                       }
[11:00:09.081]                       {
[11:00:09.081]                         lapply(seq_along(...future.elements_ii), 
[11:00:09.081]                           FUN = function(jj) {
[11:00:09.081]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:09.081]                             ...future.FUN(...future.X_jj, ...)
[11:00:09.081]                           })
[11:00:09.081]                       }
[11:00:09.081]                     }, args = future.call.arguments)
[11:00:09.081]                   }
[11:00:09.081]                 }, immediateCondition = function(cond) {
[11:00:09.081]                   sendCondition <- ...future.makeSendCondition()
[11:00:09.081]                   sendCondition(cond)
[11:00:09.081]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:09.081]                   {
[11:00:09.081]                     inherits <- base::inherits
[11:00:09.081]                     invokeRestart <- base::invokeRestart
[11:00:09.081]                     is.null <- base::is.null
[11:00:09.081]                     muffled <- FALSE
[11:00:09.081]                     if (inherits(cond, "message")) {
[11:00:09.081]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:09.081]                       if (muffled) 
[11:00:09.081]                         invokeRestart("muffleMessage")
[11:00:09.081]                     }
[11:00:09.081]                     else if (inherits(cond, "warning")) {
[11:00:09.081]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:09.081]                       if (muffled) 
[11:00:09.081]                         invokeRestart("muffleWarning")
[11:00:09.081]                     }
[11:00:09.081]                     else if (inherits(cond, "condition")) {
[11:00:09.081]                       if (!is.null(pattern)) {
[11:00:09.081]                         computeRestarts <- base::computeRestarts
[11:00:09.081]                         grepl <- base::grepl
[11:00:09.081]                         restarts <- computeRestarts(cond)
[11:00:09.081]                         for (restart in restarts) {
[11:00:09.081]                           name <- restart$name
[11:00:09.081]                           if (is.null(name)) 
[11:00:09.081]                             next
[11:00:09.081]                           if (!grepl(pattern, name)) 
[11:00:09.081]                             next
[11:00:09.081]                           invokeRestart(restart)
[11:00:09.081]                           muffled <- TRUE
[11:00:09.081]                           break
[11:00:09.081]                         }
[11:00:09.081]                       }
[11:00:09.081]                     }
[11:00:09.081]                     invisible(muffled)
[11:00:09.081]                   }
[11:00:09.081]                   muffleCondition(cond)
[11:00:09.081]                 })
[11:00:09.081]             }))
[11:00:09.081]             future::FutureResult(value = ...future.value$value, 
[11:00:09.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:09.081]                   ...future.rng), globalenv = if (FALSE) 
[11:00:09.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:09.081]                     ...future.globalenv.names))
[11:00:09.081]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:09.081]         }, condition = base::local({
[11:00:09.081]             c <- base::c
[11:00:09.081]             inherits <- base::inherits
[11:00:09.081]             invokeRestart <- base::invokeRestart
[11:00:09.081]             length <- base::length
[11:00:09.081]             list <- base::list
[11:00:09.081]             seq.int <- base::seq.int
[11:00:09.081]             signalCondition <- base::signalCondition
[11:00:09.081]             sys.calls <- base::sys.calls
[11:00:09.081]             `[[` <- base::`[[`
[11:00:09.081]             `+` <- base::`+`
[11:00:09.081]             `<<-` <- base::`<<-`
[11:00:09.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:09.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:09.081]                   3L)]
[11:00:09.081]             }
[11:00:09.081]             function(cond) {
[11:00:09.081]                 is_error <- inherits(cond, "error")
[11:00:09.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:09.081]                   NULL)
[11:00:09.081]                 if (is_error) {
[11:00:09.081]                   sessionInformation <- function() {
[11:00:09.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:09.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:09.081]                       search = base::search(), system = base::Sys.info())
[11:00:09.081]                   }
[11:00:09.081]                   ...future.conditions[[length(...future.conditions) + 
[11:00:09.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:09.081]                     cond$call), session = sessionInformation(), 
[11:00:09.081]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:09.081]                   signalCondition(cond)
[11:00:09.081]                 }
[11:00:09.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:09.081]                 "immediateCondition"))) {
[11:00:09.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:09.081]                   ...future.conditions[[length(...future.conditions) + 
[11:00:09.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:09.081]                   if (TRUE && !signal) {
[11:00:09.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:09.081]                     {
[11:00:09.081]                       inherits <- base::inherits
[11:00:09.081]                       invokeRestart <- base::invokeRestart
[11:00:09.081]                       is.null <- base::is.null
[11:00:09.081]                       muffled <- FALSE
[11:00:09.081]                       if (inherits(cond, "message")) {
[11:00:09.081]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:09.081]                         if (muffled) 
[11:00:09.081]                           invokeRestart("muffleMessage")
[11:00:09.081]                       }
[11:00:09.081]                       else if (inherits(cond, "warning")) {
[11:00:09.081]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:09.081]                         if (muffled) 
[11:00:09.081]                           invokeRestart("muffleWarning")
[11:00:09.081]                       }
[11:00:09.081]                       else if (inherits(cond, "condition")) {
[11:00:09.081]                         if (!is.null(pattern)) {
[11:00:09.081]                           computeRestarts <- base::computeRestarts
[11:00:09.081]                           grepl <- base::grepl
[11:00:09.081]                           restarts <- computeRestarts(cond)
[11:00:09.081]                           for (restart in restarts) {
[11:00:09.081]                             name <- restart$name
[11:00:09.081]                             if (is.null(name)) 
[11:00:09.081]                               next
[11:00:09.081]                             if (!grepl(pattern, name)) 
[11:00:09.081]                               next
[11:00:09.081]                             invokeRestart(restart)
[11:00:09.081]                             muffled <- TRUE
[11:00:09.081]                             break
[11:00:09.081]                           }
[11:00:09.081]                         }
[11:00:09.081]                       }
[11:00:09.081]                       invisible(muffled)
[11:00:09.081]                     }
[11:00:09.081]                     muffleCondition(cond, pattern = "^muffle")
[11:00:09.081]                   }
[11:00:09.081]                 }
[11:00:09.081]                 else {
[11:00:09.081]                   if (TRUE) {
[11:00:09.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:09.081]                     {
[11:00:09.081]                       inherits <- base::inherits
[11:00:09.081]                       invokeRestart <- base::invokeRestart
[11:00:09.081]                       is.null <- base::is.null
[11:00:09.081]                       muffled <- FALSE
[11:00:09.081]                       if (inherits(cond, "message")) {
[11:00:09.081]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:09.081]                         if (muffled) 
[11:00:09.081]                           invokeRestart("muffleMessage")
[11:00:09.081]                       }
[11:00:09.081]                       else if (inherits(cond, "warning")) {
[11:00:09.081]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:09.081]                         if (muffled) 
[11:00:09.081]                           invokeRestart("muffleWarning")
[11:00:09.081]                       }
[11:00:09.081]                       else if (inherits(cond, "condition")) {
[11:00:09.081]                         if (!is.null(pattern)) {
[11:00:09.081]                           computeRestarts <- base::computeRestarts
[11:00:09.081]                           grepl <- base::grepl
[11:00:09.081]                           restarts <- computeRestarts(cond)
[11:00:09.081]                           for (restart in restarts) {
[11:00:09.081]                             name <- restart$name
[11:00:09.081]                             if (is.null(name)) 
[11:00:09.081]                               next
[11:00:09.081]                             if (!grepl(pattern, name)) 
[11:00:09.081]                               next
[11:00:09.081]                             invokeRestart(restart)
[11:00:09.081]                             muffled <- TRUE
[11:00:09.081]                             break
[11:00:09.081]                           }
[11:00:09.081]                         }
[11:00:09.081]                       }
[11:00:09.081]                       invisible(muffled)
[11:00:09.081]                     }
[11:00:09.081]                     muffleCondition(cond, pattern = "^muffle")
[11:00:09.081]                   }
[11:00:09.081]                 }
[11:00:09.081]             }
[11:00:09.081]         }))
[11:00:09.081]     }, error = function(ex) {
[11:00:09.081]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:09.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:09.081]                 ...future.rng), started = ...future.startTime, 
[11:00:09.081]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:09.081]             version = "1.8"), class = "FutureResult")
[11:00:09.081]     }, finally = {
[11:00:09.081]         if (!identical(...future.workdir, getwd())) 
[11:00:09.081]             setwd(...future.workdir)
[11:00:09.081]         {
[11:00:09.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:09.081]                 ...future.oldOptions$nwarnings <- NULL
[11:00:09.081]             }
[11:00:09.081]             base::options(...future.oldOptions)
[11:00:09.081]             if (.Platform$OS.type == "windows") {
[11:00:09.081]                 old_names <- names(...future.oldEnvVars)
[11:00:09.081]                 envs <- base::Sys.getenv()
[11:00:09.081]                 names <- names(envs)
[11:00:09.081]                 common <- intersect(names, old_names)
[11:00:09.081]                 added <- setdiff(names, old_names)
[11:00:09.081]                 removed <- setdiff(old_names, names)
[11:00:09.081]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:09.081]                   envs[common]]
[11:00:09.081]                 NAMES <- toupper(changed)
[11:00:09.081]                 args <- list()
[11:00:09.081]                 for (kk in seq_along(NAMES)) {
[11:00:09.081]                   name <- changed[[kk]]
[11:00:09.081]                   NAME <- NAMES[[kk]]
[11:00:09.081]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:09.081]                     next
[11:00:09.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:09.081]                 }
[11:00:09.081]                 NAMES <- toupper(added)
[11:00:09.081]                 for (kk in seq_along(NAMES)) {
[11:00:09.081]                   name <- added[[kk]]
[11:00:09.081]                   NAME <- NAMES[[kk]]
[11:00:09.081]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:09.081]                     next
[11:00:09.081]                   args[[name]] <- ""
[11:00:09.081]                 }
[11:00:09.081]                 NAMES <- toupper(removed)
[11:00:09.081]                 for (kk in seq_along(NAMES)) {
[11:00:09.081]                   name <- removed[[kk]]
[11:00:09.081]                   NAME <- NAMES[[kk]]
[11:00:09.081]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:09.081]                     next
[11:00:09.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:09.081]                 }
[11:00:09.081]                 if (length(args) > 0) 
[11:00:09.081]                   base::do.call(base::Sys.setenv, args = args)
[11:00:09.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:09.081]             }
[11:00:09.081]             else {
[11:00:09.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:09.081]             }
[11:00:09.081]             {
[11:00:09.081]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:09.081]                   0L) {
[11:00:09.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:09.081]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:09.081]                   base::options(opts)
[11:00:09.081]                 }
[11:00:09.081]                 {
[11:00:09.081]                   {
[11:00:09.081]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:09.081]                     NULL
[11:00:09.081]                   }
[11:00:09.081]                   options(future.plan = NULL)
[11:00:09.081]                   if (is.na(NA_character_)) 
[11:00:09.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:09.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:09.081]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:09.081]                     .init = FALSE)
[11:00:09.081]                 }
[11:00:09.081]             }
[11:00:09.081]         }
[11:00:09.081]     })
[11:00:09.081]     if (TRUE) {
[11:00:09.081]         base::sink(type = "output", split = FALSE)
[11:00:09.081]         if (TRUE) {
[11:00:09.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:09.081]         }
[11:00:09.081]         else {
[11:00:09.081]             ...future.result["stdout"] <- base::list(NULL)
[11:00:09.081]         }
[11:00:09.081]         base::close(...future.stdout)
[11:00:09.081]         ...future.stdout <- NULL
[11:00:09.081]     }
[11:00:09.081]     ...future.result$conditions <- ...future.conditions
[11:00:09.081]     ...future.result$finished <- base::Sys.time()
[11:00:09.081]     ...future.result
[11:00:09.081] }
[11:00:09.084] Exporting 11 global objects (13.22 KiB) to cluster node #1 ...
[11:00:09.084] Exporting ‘...future.FUN’ (4.65 KiB) to cluster node #1 ...
[11:00:09.125] Exporting ‘...future.FUN’ (4.65 KiB) to cluster node #1 ... DONE
[11:00:09.125] Exporting ‘x_FUN’ (185 bytes) to cluster node #1 ...
[11:00:09.125] Exporting ‘x_FUN’ (185 bytes) to cluster node #1 ... DONE
[11:00:09.125] Exporting ‘times’ (35 bytes) to cluster node #1 ...
[11:00:09.126] Exporting ‘times’ (35 bytes) to cluster node #1 ... DONE
[11:00:09.126] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ...
[11:00:09.167] Exporting ‘stopf’ (3.33 KiB) to cluster node #1 ... DONE
[11:00:09.167] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ...
[11:00:09.208] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #1 ... DONE
[11:00:09.208] Exporting ‘dim’ (27 bytes) to cluster node #1 ...
[11:00:09.208] Exporting ‘dim’ (27 bytes) to cluster node #1 ... DONE
[11:00:09.208] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ...
[11:00:09.209] Exporting ‘valid_types’ (75 bytes) to cluster node #1 ... DONE
[11:00:09.209] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[11:00:09.209] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[11:00:09.209] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ...
[11:00:09.210] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ... DONE
[11:00:09.210] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[11:00:09.210] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[11:00:09.210] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[11:00:09.211] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[11:00:09.211] Exporting 11 global objects (13.22 KiB) to cluster node #1 ... DONE
[11:00:09.211] MultisessionFuture started
[11:00:09.211] - Launch lazy future ... done
[11:00:09.211] run() for ‘MultisessionFuture’ ... done
[11:00:09.211] Created future:
[11:00:09.212] MultisessionFuture:
[11:00:09.212] Label: ‘future_vapply-1’
[11:00:09.212] Expression:
[11:00:09.212] {
[11:00:09.212]     do.call(function(...) {
[11:00:09.212]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:09.212]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:09.212]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:09.212]             on.exit(options(oopts), add = TRUE)
[11:00:09.212]         }
[11:00:09.212]         {
[11:00:09.212]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:09.212]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:09.212]                 ...future.FUN(...future.X_jj, ...)
[11:00:09.212]             })
[11:00:09.212]         }
[11:00:09.212]     }, args = future.call.arguments)
[11:00:09.212] }
[11:00:09.212] Lazy evaluation: FALSE
[11:00:09.212] Asynchronous evaluation: TRUE
[11:00:09.212] Local evaluation: TRUE
[11:00:09.212] Environment: R_GlobalEnv
[11:00:09.212] Capture standard output: TRUE
[11:00:09.212] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:09.212] Globals: 11 objects totaling 13.00 KiB (function ‘...future.FUN’ of 4.65 KiB, function ‘x_FUN’ of 185 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:09.212] Packages: 1 packages (‘future.apply’)
[11:00:09.212] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:09.212] Resolved: FALSE
[11:00:09.212] Value: <not collected>
[11:00:09.212] Conditions captured: <none>
[11:00:09.212] Early signaling: FALSE
[11:00:09.212] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:09.212] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:09.223] Chunk #1 of 2 ... DONE
[11:00:09.223] Chunk #2 of 2 ...
[11:00:09.223]  - Finding globals in 'X' for chunk #2 ...
[11:00:09.223] getGlobalsAndPackages() ...
[11:00:09.223] Searching for globals...
[11:00:09.224] 
[11:00:09.224] Searching for globals ... DONE
[11:00:09.224] - globals: [0] <none>
[11:00:09.224] getGlobalsAndPackages() ... DONE
[11:00:09.224]    + additional globals found: [n=0] 
[11:00:09.224]    + additional namespaces needed: [n=0] 
[11:00:09.224]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:09.224]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:09.224]  - seeds: <none>
[11:00:09.225]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:09.225] getGlobalsAndPackages() ...
[11:00:09.225] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:09.225] Resolving globals: FALSE
[11:00:09.225] Tweak future expression to call with '...' arguments ...
[11:00:09.225] {
[11:00:09.225]     do.call(function(...) {
[11:00:09.225]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:09.225]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:09.225]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:09.225]             on.exit(options(oopts), add = TRUE)
[11:00:09.225]         }
[11:00:09.225]         {
[11:00:09.225]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:09.225]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:09.225]                 ...future.FUN(...future.X_jj, ...)
[11:00:09.225]             })
[11:00:09.225]         }
[11:00:09.225]     }, args = future.call.arguments)
[11:00:09.225] }
[11:00:09.225] Tweak future expression to call with '...' arguments ... DONE
[11:00:09.226] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:09.226] - packages: [1] ‘future.apply’
[11:00:09.226] getGlobalsAndPackages() ... DONE
[11:00:09.226] run() for ‘Future’ ...
[11:00:09.226] - state: ‘created’
[11:00:09.226] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:09.240] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:09.240] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:09.240]   - Field: ‘node’
[11:00:09.240]   - Field: ‘label’
[11:00:09.240]   - Field: ‘local’
[11:00:09.240]   - Field: ‘owner’
[11:00:09.240]   - Field: ‘envir’
[11:00:09.240]   - Field: ‘workers’
[11:00:09.240]   - Field: ‘packages’
[11:00:09.240]   - Field: ‘gc’
[11:00:09.240]   - Field: ‘conditions’
[11:00:09.241]   - Field: ‘persistent’
[11:00:09.241]   - Field: ‘expr’
[11:00:09.241]   - Field: ‘uuid’
[11:00:09.241]   - Field: ‘seed’
[11:00:09.241]   - Field: ‘version’
[11:00:09.241]   - Field: ‘result’
[11:00:09.241]   - Field: ‘asynchronous’
[11:00:09.241]   - Field: ‘calls’
[11:00:09.241]   - Field: ‘globals’
[11:00:09.241]   - Field: ‘stdout’
[11:00:09.241]   - Field: ‘earlySignal’
[11:00:09.241]   - Field: ‘lazy’
[11:00:09.241]   - Field: ‘state’
[11:00:09.242] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:09.242] - Launch lazy future ...
[11:00:09.242] Packages needed by the future expression (n = 1): ‘future.apply’
[11:00:09.242] Packages needed by future strategies (n = 0): <none>
[11:00:09.242] {
[11:00:09.242]     {
[11:00:09.242]         {
[11:00:09.242]             ...future.startTime <- base::Sys.time()
[11:00:09.242]             {
[11:00:09.242]                 {
[11:00:09.242]                   {
[11:00:09.242]                     {
[11:00:09.242]                       {
[11:00:09.242]                         base::local({
[11:00:09.242]                           has_future <- base::requireNamespace("future", 
[11:00:09.242]                             quietly = TRUE)
[11:00:09.242]                           if (has_future) {
[11:00:09.242]                             ns <- base::getNamespace("future")
[11:00:09.242]                             version <- ns[[".package"]][["version"]]
[11:00:09.242]                             if (is.null(version)) 
[11:00:09.242]                               version <- utils::packageVersion("future")
[11:00:09.242]                           }
[11:00:09.242]                           else {
[11:00:09.242]                             version <- NULL
[11:00:09.242]                           }
[11:00:09.242]                           if (!has_future || version < "1.8.0") {
[11:00:09.242]                             info <- base::c(r_version = base::gsub("R version ", 
[11:00:09.242]                               "", base::R.version$version.string), 
[11:00:09.242]                               platform = base::sprintf("%s (%s-bit)", 
[11:00:09.242]                                 base::R.version$platform, 8 * 
[11:00:09.242]                                   base::.Machine$sizeof.pointer), 
[11:00:09.242]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:09.242]                                 "release", "version")], collapse = " "), 
[11:00:09.242]                               hostname = base::Sys.info()[["nodename"]])
[11:00:09.242]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:00:09.242]                               info)
[11:00:09.242]                             info <- base::paste(info, collapse = "; ")
[11:00:09.242]                             if (!has_future) {
[11:00:09.242]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:09.242]                                 info)
[11:00:09.242]                             }
[11:00:09.242]                             else {
[11:00:09.242]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:09.242]                                 info, version)
[11:00:09.242]                             }
[11:00:09.242]                             base::stop(msg)
[11:00:09.242]                           }
[11:00:09.242]                         })
[11:00:09.242]                       }
[11:00:09.242]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:09.242]                       base::options(mc.cores = 1L)
[11:00:09.242]                     }
[11:00:09.242]                     base::local({
[11:00:09.242]                       for (pkg in "future.apply") {
[11:00:09.242]                         base::loadNamespace(pkg)
[11:00:09.242]                         base::library(pkg, character.only = TRUE)
[11:00:09.242]                       }
[11:00:09.242]                     })
[11:00:09.242]                   }
[11:00:09.242]                   ...future.strategy.old <- future::plan("list")
[11:00:09.242]                   options(future.plan = NULL)
[11:00:09.242]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:09.242]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:09.242]                 }
[11:00:09.242]                 ...future.workdir <- getwd()
[11:00:09.242]             }
[11:00:09.242]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:09.242]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:09.242]         }
[11:00:09.242]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:09.242]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:09.242]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:09.242]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:09.242]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:09.242]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:09.242]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:09.242]             base::names(...future.oldOptions))
[11:00:09.242]     }
[11:00:09.242]     if (FALSE) {
[11:00:09.242]     }
[11:00:09.242]     else {
[11:00:09.242]         if (TRUE) {
[11:00:09.242]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:09.242]                 open = "w")
[11:00:09.242]         }
[11:00:09.242]         else {
[11:00:09.242]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:09.242]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:09.242]         }
[11:00:09.242]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:09.242]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:09.242]             base::sink(type = "output", split = FALSE)
[11:00:09.242]             base::close(...future.stdout)
[11:00:09.242]         }, add = TRUE)
[11:00:09.242]     }
[11:00:09.242]     ...future.frame <- base::sys.nframe()
[11:00:09.242]     ...future.conditions <- base::list()
[11:00:09.242]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:09.242]     if (FALSE) {
[11:00:09.242]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:09.242]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:09.242]     }
[11:00:09.242]     ...future.result <- base::tryCatch({
[11:00:09.242]         base::withCallingHandlers({
[11:00:09.242]             ...future.value <- base::withVisible(base::local({
[11:00:09.242]                 ...future.makeSendCondition <- base::local({
[11:00:09.242]                   sendCondition <- NULL
[11:00:09.242]                   function(frame = 1L) {
[11:00:09.242]                     if (is.function(sendCondition)) 
[11:00:09.242]                       return(sendCondition)
[11:00:09.242]                     ns <- getNamespace("parallel")
[11:00:09.242]                     if (exists("sendData", mode = "function", 
[11:00:09.242]                       envir = ns)) {
[11:00:09.242]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:09.242]                         envir = ns)
[11:00:09.242]                       envir <- sys.frame(frame)
[11:00:09.242]                       master <- NULL
[11:00:09.242]                       while (!identical(envir, .GlobalEnv) && 
[11:00:09.242]                         !identical(envir, emptyenv())) {
[11:00:09.242]                         if (exists("master", mode = "list", envir = envir, 
[11:00:09.242]                           inherits = FALSE)) {
[11:00:09.242]                           master <- get("master", mode = "list", 
[11:00:09.242]                             envir = envir, inherits = FALSE)
[11:00:09.242]                           if (inherits(master, c("SOCKnode", 
[11:00:09.242]                             "SOCK0node"))) {
[11:00:09.242]                             sendCondition <<- function(cond) {
[11:00:09.242]                               data <- list(type = "VALUE", value = cond, 
[11:00:09.242]                                 success = TRUE)
[11:00:09.242]                               parallel_sendData(master, data)
[11:00:09.242]                             }
[11:00:09.242]                             return(sendCondition)
[11:00:09.242]                           }
[11:00:09.242]                         }
[11:00:09.242]                         frame <- frame + 1L
[11:00:09.242]                         envir <- sys.frame(frame)
[11:00:09.242]                       }
[11:00:09.242]                     }
[11:00:09.242]                     sendCondition <<- function(cond) NULL
[11:00:09.242]                   }
[11:00:09.242]                 })
[11:00:09.242]                 withCallingHandlers({
[11:00:09.242]                   {
[11:00:09.242]                     do.call(function(...) {
[11:00:09.242]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:09.242]                       if (!identical(...future.globals.maxSize.org, 
[11:00:09.242]                         ...future.globals.maxSize)) {
[11:00:09.242]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:09.242]                         on.exit(options(oopts), add = TRUE)
[11:00:09.242]                       }
[11:00:09.242]                       {
[11:00:09.242]                         lapply(seq_along(...future.elements_ii), 
[11:00:09.242]                           FUN = function(jj) {
[11:00:09.242]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:09.242]                             ...future.FUN(...future.X_jj, ...)
[11:00:09.242]                           })
[11:00:09.242]                       }
[11:00:09.242]                     }, args = future.call.arguments)
[11:00:09.242]                   }
[11:00:09.242]                 }, immediateCondition = function(cond) {
[11:00:09.242]                   sendCondition <- ...future.makeSendCondition()
[11:00:09.242]                   sendCondition(cond)
[11:00:09.242]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:09.242]                   {
[11:00:09.242]                     inherits <- base::inherits
[11:00:09.242]                     invokeRestart <- base::invokeRestart
[11:00:09.242]                     is.null <- base::is.null
[11:00:09.242]                     muffled <- FALSE
[11:00:09.242]                     if (inherits(cond, "message")) {
[11:00:09.242]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:09.242]                       if (muffled) 
[11:00:09.242]                         invokeRestart("muffleMessage")
[11:00:09.242]                     }
[11:00:09.242]                     else if (inherits(cond, "warning")) {
[11:00:09.242]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:09.242]                       if (muffled) 
[11:00:09.242]                         invokeRestart("muffleWarning")
[11:00:09.242]                     }
[11:00:09.242]                     else if (inherits(cond, "condition")) {
[11:00:09.242]                       if (!is.null(pattern)) {
[11:00:09.242]                         computeRestarts <- base::computeRestarts
[11:00:09.242]                         grepl <- base::grepl
[11:00:09.242]                         restarts <- computeRestarts(cond)
[11:00:09.242]                         for (restart in restarts) {
[11:00:09.242]                           name <- restart$name
[11:00:09.242]                           if (is.null(name)) 
[11:00:09.242]                             next
[11:00:09.242]                           if (!grepl(pattern, name)) 
[11:00:09.242]                             next
[11:00:09.242]                           invokeRestart(restart)
[11:00:09.242]                           muffled <- TRUE
[11:00:09.242]                           break
[11:00:09.242]                         }
[11:00:09.242]                       }
[11:00:09.242]                     }
[11:00:09.242]                     invisible(muffled)
[11:00:09.242]                   }
[11:00:09.242]                   muffleCondition(cond)
[11:00:09.242]                 })
[11:00:09.242]             }))
[11:00:09.242]             future::FutureResult(value = ...future.value$value, 
[11:00:09.242]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:09.242]                   ...future.rng), globalenv = if (FALSE) 
[11:00:09.242]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:09.242]                     ...future.globalenv.names))
[11:00:09.242]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:09.242]         }, condition = base::local({
[11:00:09.242]             c <- base::c
[11:00:09.242]             inherits <- base::inherits
[11:00:09.242]             invokeRestart <- base::invokeRestart
[11:00:09.242]             length <- base::length
[11:00:09.242]             list <- base::list
[11:00:09.242]             seq.int <- base::seq.int
[11:00:09.242]             signalCondition <- base::signalCondition
[11:00:09.242]             sys.calls <- base::sys.calls
[11:00:09.242]             `[[` <- base::`[[`
[11:00:09.242]             `+` <- base::`+`
[11:00:09.242]             `<<-` <- base::`<<-`
[11:00:09.242]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:09.242]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:09.242]                   3L)]
[11:00:09.242]             }
[11:00:09.242]             function(cond) {
[11:00:09.242]                 is_error <- inherits(cond, "error")
[11:00:09.242]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:09.242]                   NULL)
[11:00:09.242]                 if (is_error) {
[11:00:09.242]                   sessionInformation <- function() {
[11:00:09.242]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:09.242]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:09.242]                       search = base::search(), system = base::Sys.info())
[11:00:09.242]                   }
[11:00:09.242]                   ...future.conditions[[length(...future.conditions) + 
[11:00:09.242]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:09.242]                     cond$call), session = sessionInformation(), 
[11:00:09.242]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:09.242]                   signalCondition(cond)
[11:00:09.242]                 }
[11:00:09.242]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:09.242]                 "immediateCondition"))) {
[11:00:09.242]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:09.242]                   ...future.conditions[[length(...future.conditions) + 
[11:00:09.242]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:09.242]                   if (TRUE && !signal) {
[11:00:09.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:09.242]                     {
[11:00:09.242]                       inherits <- base::inherits
[11:00:09.242]                       invokeRestart <- base::invokeRestart
[11:00:09.242]                       is.null <- base::is.null
[11:00:09.242]                       muffled <- FALSE
[11:00:09.242]                       if (inherits(cond, "message")) {
[11:00:09.242]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:09.242]                         if (muffled) 
[11:00:09.242]                           invokeRestart("muffleMessage")
[11:00:09.242]                       }
[11:00:09.242]                       else if (inherits(cond, "warning")) {
[11:00:09.242]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:09.242]                         if (muffled) 
[11:00:09.242]                           invokeRestart("muffleWarning")
[11:00:09.242]                       }
[11:00:09.242]                       else if (inherits(cond, "condition")) {
[11:00:09.242]                         if (!is.null(pattern)) {
[11:00:09.242]                           computeRestarts <- base::computeRestarts
[11:00:09.242]                           grepl <- base::grepl
[11:00:09.242]                           restarts <- computeRestarts(cond)
[11:00:09.242]                           for (restart in restarts) {
[11:00:09.242]                             name <- restart$name
[11:00:09.242]                             if (is.null(name)) 
[11:00:09.242]                               next
[11:00:09.242]                             if (!grepl(pattern, name)) 
[11:00:09.242]                               next
[11:00:09.242]                             invokeRestart(restart)
[11:00:09.242]                             muffled <- TRUE
[11:00:09.242]                             break
[11:00:09.242]                           }
[11:00:09.242]                         }
[11:00:09.242]                       }
[11:00:09.242]                       invisible(muffled)
[11:00:09.242]                     }
[11:00:09.242]                     muffleCondition(cond, pattern = "^muffle")
[11:00:09.242]                   }
[11:00:09.242]                 }
[11:00:09.242]                 else {
[11:00:09.242]                   if (TRUE) {
[11:00:09.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:09.242]                     {
[11:00:09.242]                       inherits <- base::inherits
[11:00:09.242]                       invokeRestart <- base::invokeRestart
[11:00:09.242]                       is.null <- base::is.null
[11:00:09.242]                       muffled <- FALSE
[11:00:09.242]                       if (inherits(cond, "message")) {
[11:00:09.242]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:09.242]                         if (muffled) 
[11:00:09.242]                           invokeRestart("muffleMessage")
[11:00:09.242]                       }
[11:00:09.242]                       else if (inherits(cond, "warning")) {
[11:00:09.242]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:09.242]                         if (muffled) 
[11:00:09.242]                           invokeRestart("muffleWarning")
[11:00:09.242]                       }
[11:00:09.242]                       else if (inherits(cond, "condition")) {
[11:00:09.242]                         if (!is.null(pattern)) {
[11:00:09.242]                           computeRestarts <- base::computeRestarts
[11:00:09.242]                           grepl <- base::grepl
[11:00:09.242]                           restarts <- computeRestarts(cond)
[11:00:09.242]                           for (restart in restarts) {
[11:00:09.242]                             name <- restart$name
[11:00:09.242]                             if (is.null(name)) 
[11:00:09.242]                               next
[11:00:09.242]                             if (!grepl(pattern, name)) 
[11:00:09.242]                               next
[11:00:09.242]                             invokeRestart(restart)
[11:00:09.242]                             muffled <- TRUE
[11:00:09.242]                             break
[11:00:09.242]                           }
[11:00:09.242]                         }
[11:00:09.242]                       }
[11:00:09.242]                       invisible(muffled)
[11:00:09.242]                     }
[11:00:09.242]                     muffleCondition(cond, pattern = "^muffle")
[11:00:09.242]                   }
[11:00:09.242]                 }
[11:00:09.242]             }
[11:00:09.242]         }))
[11:00:09.242]     }, error = function(ex) {
[11:00:09.242]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:09.242]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:09.242]                 ...future.rng), started = ...future.startTime, 
[11:00:09.242]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:09.242]             version = "1.8"), class = "FutureResult")
[11:00:09.242]     }, finally = {
[11:00:09.242]         if (!identical(...future.workdir, getwd())) 
[11:00:09.242]             setwd(...future.workdir)
[11:00:09.242]         {
[11:00:09.242]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:09.242]                 ...future.oldOptions$nwarnings <- NULL
[11:00:09.242]             }
[11:00:09.242]             base::options(...future.oldOptions)
[11:00:09.242]             if (.Platform$OS.type == "windows") {
[11:00:09.242]                 old_names <- names(...future.oldEnvVars)
[11:00:09.242]                 envs <- base::Sys.getenv()
[11:00:09.242]                 names <- names(envs)
[11:00:09.242]                 common <- intersect(names, old_names)
[11:00:09.242]                 added <- setdiff(names, old_names)
[11:00:09.242]                 removed <- setdiff(old_names, names)
[11:00:09.242]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:09.242]                   envs[common]]
[11:00:09.242]                 NAMES <- toupper(changed)
[11:00:09.242]                 args <- list()
[11:00:09.242]                 for (kk in seq_along(NAMES)) {
[11:00:09.242]                   name <- changed[[kk]]
[11:00:09.242]                   NAME <- NAMES[[kk]]
[11:00:09.242]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:09.242]                     next
[11:00:09.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:09.242]                 }
[11:00:09.242]                 NAMES <- toupper(added)
[11:00:09.242]                 for (kk in seq_along(NAMES)) {
[11:00:09.242]                   name <- added[[kk]]
[11:00:09.242]                   NAME <- NAMES[[kk]]
[11:00:09.242]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:09.242]                     next
[11:00:09.242]                   args[[name]] <- ""
[11:00:09.242]                 }
[11:00:09.242]                 NAMES <- toupper(removed)
[11:00:09.242]                 for (kk in seq_along(NAMES)) {
[11:00:09.242]                   name <- removed[[kk]]
[11:00:09.242]                   NAME <- NAMES[[kk]]
[11:00:09.242]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:09.242]                     next
[11:00:09.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:09.242]                 }
[11:00:09.242]                 if (length(args) > 0) 
[11:00:09.242]                   base::do.call(base::Sys.setenv, args = args)
[11:00:09.242]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:09.242]             }
[11:00:09.242]             else {
[11:00:09.242]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:09.242]             }
[11:00:09.242]             {
[11:00:09.242]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:09.242]                   0L) {
[11:00:09.242]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:09.242]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:09.242]                   base::options(opts)
[11:00:09.242]                 }
[11:00:09.242]                 {
[11:00:09.242]                   {
[11:00:09.242]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:09.242]                     NULL
[11:00:09.242]                   }
[11:00:09.242]                   options(future.plan = NULL)
[11:00:09.242]                   if (is.na(NA_character_)) 
[11:00:09.242]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:09.242]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:09.242]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:09.242]                     .init = FALSE)
[11:00:09.242]                 }
[11:00:09.242]             }
[11:00:09.242]         }
[11:00:09.242]     })
[11:00:09.242]     if (TRUE) {
[11:00:09.242]         base::sink(type = "output", split = FALSE)
[11:00:09.242]         if (TRUE) {
[11:00:09.242]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:09.242]         }
[11:00:09.242]         else {
[11:00:09.242]             ...future.result["stdout"] <- base::list(NULL)
[11:00:09.242]         }
[11:00:09.242]         base::close(...future.stdout)
[11:00:09.242]         ...future.stdout <- NULL
[11:00:09.242]     }
[11:00:09.242]     ...future.result$conditions <- ...future.conditions
[11:00:09.242]     ...future.result$finished <- base::Sys.time()
[11:00:09.242]     ...future.result
[11:00:09.242] }
[11:00:09.245] Exporting 11 global objects (13.23 KiB) to cluster node #2 ...
[11:00:09.245] Exporting ‘...future.FUN’ (4.65 KiB) to cluster node #2 ...
[11:00:09.287] Exporting ‘...future.FUN’ (4.65 KiB) to cluster node #2 ... DONE
[11:00:09.287] Exporting ‘x_FUN’ (185 bytes) to cluster node #2 ...
[11:00:09.287] Exporting ‘x_FUN’ (185 bytes) to cluster node #2 ... DONE
[11:00:09.287] Exporting ‘times’ (35 bytes) to cluster node #2 ...
[11:00:09.288] Exporting ‘times’ (35 bytes) to cluster node #2 ... DONE
[11:00:09.288] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ...
[11:00:09.329] Exporting ‘stopf’ (3.33 KiB) to cluster node #2 ... DONE
[11:00:09.329] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ...
[11:00:09.369] Exporting ‘stop_if_not’ (4.51 KiB) to cluster node #2 ... DONE
[11:00:09.370] Exporting ‘dim’ (27 bytes) to cluster node #2 ...
[11:00:09.370] Exporting ‘dim’ (27 bytes) to cluster node #2 ... DONE
[11:00:09.370] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ...
[11:00:09.370] Exporting ‘valid_types’ (75 bytes) to cluster node #2 ... DONE
[11:00:09.371] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[11:00:09.371] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[11:00:09.371] Exporting ‘...future.elements_ii’ (55 bytes) to cluster node #2 ...
[11:00:09.371] Exporting ‘...future.elements_ii’ (55 bytes) to cluster node #2 ... DONE
[11:00:09.372] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[11:00:09.372] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[11:00:09.372] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[11:00:09.372] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[11:00:09.372] Exporting 11 global objects (13.23 KiB) to cluster node #2 ... DONE
[11:00:09.373] MultisessionFuture started
[11:00:09.373] - Launch lazy future ... done
[11:00:09.373] run() for ‘MultisessionFuture’ ... done
[11:00:09.373] Created future:
[11:00:09.373] MultisessionFuture:
[11:00:09.373] Label: ‘future_vapply-2’
[11:00:09.373] Expression:
[11:00:09.373] {
[11:00:09.373]     do.call(function(...) {
[11:00:09.373]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:09.373]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:09.373]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:09.373]             on.exit(options(oopts), add = TRUE)
[11:00:09.373]         }
[11:00:09.373]         {
[11:00:09.373]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:09.373]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:09.373]                 ...future.FUN(...future.X_jj, ...)
[11:00:09.373]             })
[11:00:09.373]         }
[11:00:09.373]     }, args = future.call.arguments)
[11:00:09.373] }
[11:00:09.373] Lazy evaluation: FALSE
[11:00:09.373] Asynchronous evaluation: TRUE
[11:00:09.373] Local evaluation: TRUE
[11:00:09.373] Environment: R_GlobalEnv
[11:00:09.373] Capture standard output: TRUE
[11:00:09.373] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:09.373] Globals: 11 objects totaling 13.01 KiB (function ‘...future.FUN’ of 4.65 KiB, function ‘x_FUN’ of 185 bytes, integer ‘times’ of 35 bytes, function ‘stopf’ of 3.33 KiB, function ‘stop_if_not’ of 4.51 KiB, ...)
[11:00:09.373] Packages: 1 packages (‘future.apply’)
[11:00:09.373] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:09.373] Resolved: FALSE
[11:00:09.373] Value: <not collected>
[11:00:09.373] Conditions captured: <none>
[11:00:09.373] Early signaling: FALSE
[11:00:09.373] Owner process: 410b6d2a-0912-9077-64e6-fd0f287eb05d
[11:00:09.373] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:09.385] Chunk #2 of 2 ... DONE
[11:00:09.385] Launching 2 futures (chunks) ... DONE
[11:00:09.385] Resolving 2 futures (chunks) ...
[11:00:09.385] resolve() on list ...
[11:00:09.385]  recursive: 0
[11:00:09.385]  length: 2
[11:00:09.385] 
[11:00:09.386] receiveMessageFromWorker() for ClusterFuture ...
[11:00:09.386] - Validating connection of MultisessionFuture
[11:00:09.386] - received message: FutureResult
[11:00:09.386] - Received FutureResult
[11:00:09.387] - Erased future from FutureRegistry
[11:00:09.387] result() for ClusterFuture ...
[11:00:09.387] - result already collected: FutureResult
[11:00:09.387] result() for ClusterFuture ... done
[11:00:09.387] signalConditions() ...
[11:00:09.387]  - include = ‘immediateCondition’
[11:00:09.387]  - exclude = 
[11:00:09.387]  - resignal = FALSE
[11:00:09.387]  - Number of conditions: 1
[11:00:09.387] signalConditions() ... done
[11:00:09.387] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:09.387] Future #1
[11:00:09.388] result() for ClusterFuture ...
[11:00:09.388] - result already collected: FutureResult
[11:00:09.388] result() for ClusterFuture ... done
[11:00:09.388] result() for ClusterFuture ...
[11:00:09.388] - result already collected: FutureResult
[11:00:09.390] result() for ClusterFuture ... done
[11:00:09.390] signalConditions() ...
[11:00:09.390]  - include = ‘immediateCondition’
[11:00:09.390]  - exclude = 
[11:00:09.390]  - resignal = FALSE
[11:00:09.390]  - Number of conditions: 1
[11:00:09.390] signalConditions() ... done
[11:00:09.391] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:00:09.391] - nx: 2
[11:00:09.391] - relay: TRUE
[11:00:09.391] - stdout: TRUE
[11:00:09.391] - signal: TRUE
[11:00:09.391] - resignal: FALSE
[11:00:09.391] - force: TRUE
[11:00:09.391] - relayed: [n=2] FALSE, FALSE
[11:00:09.391] - queued futures: [n=2] FALSE, FALSE
[11:00:09.391]  - until=1
[11:00:09.391]  - relaying element #1
[11:00:09.391] result() for ClusterFuture ...
[11:00:09.391] - result already collected: FutureResult
[11:00:09.392] result() for ClusterFuture ... done
[11:00:09.392] result() for ClusterFuture ...
[11:00:09.392] - result already collected: FutureResult
[11:00:09.392] result() for ClusterFuture ... done
[11:00:09.392] signalConditions() ...
[11:00:09.392]  - include = ‘immediateCondition’
[11:00:09.392]  - exclude = 
[11:00:09.392]  - resignal = FALSE
[11:00:09.392]  - Number of conditions: 1
[11:00:09.392] signalConditions() ... done
[11:00:09.392] result() for ClusterFuture ...
[11:00:09.392] - result already collected: FutureResult
[11:00:09.392] result() for ClusterFuture ... done
[11:00:09.393] signalConditions() ...
[11:00:09.393]  - include = ‘immediateCondition’
[11:00:09.393]  - exclude = 
[11:00:09.393]  - resignal = FALSE
[11:00:09.393]  - Number of conditions: 1
[11:00:09.393] signalConditions() ... done
[11:00:09.393] result() for ClusterFuture ...
[11:00:09.393] - result already collected: FutureResult
[11:00:09.393] result() for ClusterFuture ... done
[11:00:09.393] signalConditions() ...
[11:00:09.393]  - include = ‘condition’
[11:00:09.393]  - exclude = ‘immediateCondition’
[11:00:09.393]  - resignal = TRUE
[11:00:09.394]  - Number of conditions: 1
[11:00:09.394]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:00:09.394] signalConditions() ... done
[11:00:09.394] - relayed: [n=2] FALSE, FALSE
[11:00:09.394] - queued futures: [n=2] TRUE, FALSE
[11:00:09.394] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:00:09.394] plan(): Setting new future strategy stack:
[11:00:09.394] List of future strategies:
[11:00:09.394] 1. sequential:
[11:00:09.394]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:09.394]    - tweaked: FALSE
[11:00:09.394]    - call: plan(sequential)
[11:00:09.395] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** future_vapply() ... DONE")
*** future_vapply() ... DONE
> 
> source("incl/end.R")
[11:00:09.396] plan(): Setting new future strategy stack:
[11:00:09.396] List of future strategies:
[11:00:09.396] 1. FutureStrategy:
[11:00:09.396]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:09.396]    - tweaked: FALSE
[11:00:09.396]    - call: future::plan(oplan)
[11:00:09.397] plan(): nbrOfWorkers() = 1
> 
