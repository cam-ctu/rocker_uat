
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[11:00:13.692] plan(): Setting new future strategy stack:
[11:00:13.692] List of future strategies:
[11:00:13.692] 1. sequential:
[11:00:13.692]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:13.692]    - tweaked: FALSE
[11:00:13.692]    - call: future::plan("sequential")
[11:00:13.706] plan(): nbrOfWorkers() = 1
> 
> message("*** future_*apply() and 'future.stdout' ...")
*** future_*apply() and 'future.stdout' ...
> 
> options(future.debug = TRUE)
> 
> truth <- list()
> 
> out <- utils::capture.output({
+   y <- lapply(1:0, FUN = function(x) {
+     print(x)
+   })
+ })
> truth[["lapply"]] <- list(value = y, stdout = out)
> 
> out <- utils::capture.output({
+   y <- mapply(1:0, 0:1, FUN = function(x, y) {
+     print(list(x = x, y = y))
+   })
+ })
> truth[["mapply"]] <- list(value = y, stdout = out)
> 
> for (cores in 1:availCores) {
+   message(sprintf("  - Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+   
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("* plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     for (fun in names(truth)) {
+       for (stdout in c(FALSE, TRUE, NA)) {
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ...", fun, stdout))
+   
+         out <- utils::capture.output({
+           if (fun == "lapply") {
+             y <- future_lapply(1:0, FUN = function(x) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+ 	      print(x)
+             }, future.stdout = stdout)
+ 	  } else if (fun == "mapply") {
+             y <- future_mapply(1:0, 0:1, FUN = function(x, y) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+               print(list(x = x, y = y))
+             }, future.stdout = stdout)
+ 	  }
+         })
+         stopifnot(identical(y, truth[[fun]]$value))
+   
+         if (isTRUE(stdout)) {
+           stopifnot(identical(out, truth[[fun]]$stdout))
+         } else if (is.na(stdout)) {
+         } else {
+           stopifnot(nchar(out) == 0)
+         }
+       
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ... DONE", fun, stdout))
+       } ## for (stdout ...)
+     } ## for (fun ...)
+     
+     message(sprintf("* plan('%s') ... DONE", strategy))
+   }
+   
+   message(sprintf("  - Testing with %d cores ... DONE", cores))
+ }
  - Testing with 1 cores ...
* plan('sequential') ...
[11:00:13.743] plan(): Setting new future strategy stack:
[11:00:13.743] List of future strategies:
[11:00:13.743] 1. sequential:
[11:00:13.743]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:13.743]    - tweaked: FALSE
[11:00:13.743]    - call: plan(strategy)
[11:00:13.754] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[11:00:13.754] future_lapply() ...
[11:00:13.757] Number of chunks: 1
[11:00:13.758] getGlobalsAndPackagesXApply() ...
[11:00:13.758]  - future.globals: TRUE
[11:00:13.758] getGlobalsAndPackages() ...
[11:00:13.758] Searching for globals...
[11:00:13.761] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[11:00:13.761] Searching for globals ... DONE
[11:00:13.761] Resolving globals: FALSE
[11:00:13.762] The total size of the 1 globals is 841 bytes (841 bytes)
[11:00:13.762] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[11:00:13.762] - globals: [1] ‘FUN’
[11:00:13.762] 
[11:00:13.763] getGlobalsAndPackages() ... DONE
[11:00:13.763]  - globals found/used: [n=1] ‘FUN’
[11:00:13.763]  - needed namespaces: [n=0] 
[11:00:13.763] Finding globals ... DONE
[11:00:13.763]  - use_args: TRUE
[11:00:13.763]  - Getting '...' globals ...
[11:00:13.764] resolve() on list ...
[11:00:13.764]  recursive: 0
[11:00:13.764]  length: 1
[11:00:13.764]  elements: ‘...’
[11:00:13.764]  length: 0 (resolved future 1)
[11:00:13.764] resolve() on list ... DONE
[11:00:13.764]    - '...' content: [n=0] 
[11:00:13.764] List of 1
[11:00:13.764]  $ ...: list()
[11:00:13.764]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:13.764]  - attr(*, "where")=List of 1
[11:00:13.764]   ..$ ...:<environment: 0x55ceb3c50ab8> 
[11:00:13.764]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:13.764]  - attr(*, "resolved")= logi TRUE
[11:00:13.764]  - attr(*, "total_size")= num NA
[11:00:13.770]  - Getting '...' globals ... DONE
[11:00:13.770] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[11:00:13.770] List of 2
[11:00:13.770]  $ ...future.FUN:function (x)  
[11:00:13.770]  $ ...          : list()
[11:00:13.770]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:13.770]  - attr(*, "where")=List of 2
[11:00:13.770]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:13.770]   ..$ ...          :<environment: 0x55ceb3c50ab8> 
[11:00:13.770]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:13.770]  - attr(*, "resolved")= logi FALSE
[11:00:13.770]  - attr(*, "total_size")= num 5632
[11:00:13.773] Packages to be attached in all futures: [n=0] 
[11:00:13.773] getGlobalsAndPackagesXApply() ... DONE
[11:00:13.773] Number of futures (= number of chunks): 1
[11:00:13.773] Launching 1 futures (chunks) ...
[11:00:13.773] Chunk #1 of 1 ...
[11:00:13.774]  - Finding globals in 'X' for chunk #1 ...
[11:00:13.774] getGlobalsAndPackages() ...
[11:00:13.774] Searching for globals...
[11:00:13.774] 
[11:00:13.774] Searching for globals ... DONE
[11:00:13.774] - globals: [0] <none>
[11:00:13.774] getGlobalsAndPackages() ... DONE
[11:00:13.774]    + additional globals found: [n=0] 
[11:00:13.775]    + additional namespaces needed: [n=0] 
[11:00:13.775]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:13.775]  - seeds: <none>
[11:00:13.775]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:13.775] getGlobalsAndPackages() ...
[11:00:13.775] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:13.775] Resolving globals: FALSE
[11:00:13.775] Tweak future expression to call with '...' arguments ...
[11:00:13.775] {
[11:00:13.775]     do.call(function(...) {
[11:00:13.775]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:13.775]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:13.775]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:13.775]             on.exit(options(oopts), add = TRUE)
[11:00:13.775]         }
[11:00:13.775]         {
[11:00:13.775]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:13.775]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:13.775]                 ...future.FUN(...future.X_jj, ...)
[11:00:13.775]             })
[11:00:13.775]         }
[11:00:13.775]     }, args = future.call.arguments)
[11:00:13.775] }
[11:00:13.776] Tweak future expression to call with '...' arguments ... DONE
[11:00:13.776] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:13.776] 
[11:00:13.776] getGlobalsAndPackages() ... DONE
[11:00:13.777] run() for ‘Future’ ...
[11:00:13.777] - state: ‘created’
[11:00:13.777] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:13.777] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:13.777] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:13.778]   - Field: ‘label’
[11:00:13.778]   - Field: ‘local’
[11:00:13.778]   - Field: ‘owner’
[11:00:13.778]   - Field: ‘envir’
[11:00:13.778]   - Field: ‘packages’
[11:00:13.778]   - Field: ‘gc’
[11:00:13.778]   - Field: ‘conditions’
[11:00:13.778]   - Field: ‘expr’
[11:00:13.778]   - Field: ‘uuid’
[11:00:13.778]   - Field: ‘seed’
[11:00:13.778]   - Field: ‘version’
[11:00:13.778]   - Field: ‘result’
[11:00:13.779]   - Field: ‘asynchronous’
[11:00:13.779]   - Field: ‘calls’
[11:00:13.779]   - Field: ‘globals’
[11:00:13.779]   - Field: ‘stdout’
[11:00:13.779]   - Field: ‘earlySignal’
[11:00:13.779]   - Field: ‘lazy’
[11:00:13.779]   - Field: ‘state’
[11:00:13.779] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:13.779] - Launch lazy future ...
[11:00:13.780] Packages needed by the future expression (n = 0): <none>
[11:00:13.780] Packages needed by future strategies (n = 0): <none>
[11:00:13.781] {
[11:00:13.781]     {
[11:00:13.781]         {
[11:00:13.781]             ...future.startTime <- base::Sys.time()
[11:00:13.781]             {
[11:00:13.781]                 {
[11:00:13.781]                   {
[11:00:13.781]                     base::local({
[11:00:13.781]                       has_future <- base::requireNamespace("future", 
[11:00:13.781]                         quietly = TRUE)
[11:00:13.781]                       if (has_future) {
[11:00:13.781]                         ns <- base::getNamespace("future")
[11:00:13.781]                         version <- ns[[".package"]][["version"]]
[11:00:13.781]                         if (is.null(version)) 
[11:00:13.781]                           version <- utils::packageVersion("future")
[11:00:13.781]                       }
[11:00:13.781]                       else {
[11:00:13.781]                         version <- NULL
[11:00:13.781]                       }
[11:00:13.781]                       if (!has_future || version < "1.8.0") {
[11:00:13.781]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:13.781]                           "", base::R.version$version.string), 
[11:00:13.781]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:13.781]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:13.781]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:13.781]                             "release", "version")], collapse = " "), 
[11:00:13.781]                           hostname = base::Sys.info()[["nodename"]])
[11:00:13.781]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:13.781]                           info)
[11:00:13.781]                         info <- base::paste(info, collapse = "; ")
[11:00:13.781]                         if (!has_future) {
[11:00:13.781]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:13.781]                             info)
[11:00:13.781]                         }
[11:00:13.781]                         else {
[11:00:13.781]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:13.781]                             info, version)
[11:00:13.781]                         }
[11:00:13.781]                         base::stop(msg)
[11:00:13.781]                       }
[11:00:13.781]                     })
[11:00:13.781]                   }
[11:00:13.781]                   ...future.strategy.old <- future::plan("list")
[11:00:13.781]                   options(future.plan = NULL)
[11:00:13.781]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:13.781]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:13.781]                 }
[11:00:13.781]                 ...future.workdir <- getwd()
[11:00:13.781]             }
[11:00:13.781]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:13.781]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:13.781]         }
[11:00:13.781]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:13.781]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:13.781]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:13.781]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:13.781]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:13.781]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:13.781]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:13.781]             base::names(...future.oldOptions))
[11:00:13.781]     }
[11:00:13.781]     if (FALSE) {
[11:00:13.781]     }
[11:00:13.781]     else {
[11:00:13.781]         if (FALSE) {
[11:00:13.781]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:13.781]                 open = "w")
[11:00:13.781]         }
[11:00:13.781]         else {
[11:00:13.781]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:13.781]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:13.781]         }
[11:00:13.781]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:13.781]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:13.781]             base::sink(type = "output", split = FALSE)
[11:00:13.781]             base::close(...future.stdout)
[11:00:13.781]         }, add = TRUE)
[11:00:13.781]     }
[11:00:13.781]     ...future.frame <- base::sys.nframe()
[11:00:13.781]     ...future.conditions <- base::list()
[11:00:13.781]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:13.781]     if (FALSE) {
[11:00:13.781]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:13.781]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:13.781]     }
[11:00:13.781]     ...future.result <- base::tryCatch({
[11:00:13.781]         base::withCallingHandlers({
[11:00:13.781]             ...future.value <- base::withVisible(base::local({
[11:00:13.781]                 do.call(function(...) {
[11:00:13.781]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:13.781]                   if (!identical(...future.globals.maxSize.org, 
[11:00:13.781]                     ...future.globals.maxSize)) {
[11:00:13.781]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:13.781]                     on.exit(options(oopts), add = TRUE)
[11:00:13.781]                   }
[11:00:13.781]                   {
[11:00:13.781]                     lapply(seq_along(...future.elements_ii), 
[11:00:13.781]                       FUN = function(jj) {
[11:00:13.781]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:13.781]                         ...future.FUN(...future.X_jj, ...)
[11:00:13.781]                       })
[11:00:13.781]                   }
[11:00:13.781]                 }, args = future.call.arguments)
[11:00:13.781]             }))
[11:00:13.781]             future::FutureResult(value = ...future.value$value, 
[11:00:13.781]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:13.781]                   ...future.rng), globalenv = if (FALSE) 
[11:00:13.781]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:13.781]                     ...future.globalenv.names))
[11:00:13.781]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:13.781]         }, condition = base::local({
[11:00:13.781]             c <- base::c
[11:00:13.781]             inherits <- base::inherits
[11:00:13.781]             invokeRestart <- base::invokeRestart
[11:00:13.781]             length <- base::length
[11:00:13.781]             list <- base::list
[11:00:13.781]             seq.int <- base::seq.int
[11:00:13.781]             signalCondition <- base::signalCondition
[11:00:13.781]             sys.calls <- base::sys.calls
[11:00:13.781]             `[[` <- base::`[[`
[11:00:13.781]             `+` <- base::`+`
[11:00:13.781]             `<<-` <- base::`<<-`
[11:00:13.781]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:13.781]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:13.781]                   3L)]
[11:00:13.781]             }
[11:00:13.781]             function(cond) {
[11:00:13.781]                 is_error <- inherits(cond, "error")
[11:00:13.781]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:13.781]                   NULL)
[11:00:13.781]                 if (is_error) {
[11:00:13.781]                   sessionInformation <- function() {
[11:00:13.781]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:13.781]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:13.781]                       search = base::search(), system = base::Sys.info())
[11:00:13.781]                   }
[11:00:13.781]                   ...future.conditions[[length(...future.conditions) + 
[11:00:13.781]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:13.781]                     cond$call), session = sessionInformation(), 
[11:00:13.781]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:13.781]                   signalCondition(cond)
[11:00:13.781]                 }
[11:00:13.781]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:13.781]                 "immediateCondition"))) {
[11:00:13.781]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:13.781]                   ...future.conditions[[length(...future.conditions) + 
[11:00:13.781]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:13.781]                   if (TRUE && !signal) {
[11:00:13.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:13.781]                     {
[11:00:13.781]                       inherits <- base::inherits
[11:00:13.781]                       invokeRestart <- base::invokeRestart
[11:00:13.781]                       is.null <- base::is.null
[11:00:13.781]                       muffled <- FALSE
[11:00:13.781]                       if (inherits(cond, "message")) {
[11:00:13.781]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:13.781]                         if (muffled) 
[11:00:13.781]                           invokeRestart("muffleMessage")
[11:00:13.781]                       }
[11:00:13.781]                       else if (inherits(cond, "warning")) {
[11:00:13.781]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:13.781]                         if (muffled) 
[11:00:13.781]                           invokeRestart("muffleWarning")
[11:00:13.781]                       }
[11:00:13.781]                       else if (inherits(cond, "condition")) {
[11:00:13.781]                         if (!is.null(pattern)) {
[11:00:13.781]                           computeRestarts <- base::computeRestarts
[11:00:13.781]                           grepl <- base::grepl
[11:00:13.781]                           restarts <- computeRestarts(cond)
[11:00:13.781]                           for (restart in restarts) {
[11:00:13.781]                             name <- restart$name
[11:00:13.781]                             if (is.null(name)) 
[11:00:13.781]                               next
[11:00:13.781]                             if (!grepl(pattern, name)) 
[11:00:13.781]                               next
[11:00:13.781]                             invokeRestart(restart)
[11:00:13.781]                             muffled <- TRUE
[11:00:13.781]                             break
[11:00:13.781]                           }
[11:00:13.781]                         }
[11:00:13.781]                       }
[11:00:13.781]                       invisible(muffled)
[11:00:13.781]                     }
[11:00:13.781]                     muffleCondition(cond, pattern = "^muffle")
[11:00:13.781]                   }
[11:00:13.781]                 }
[11:00:13.781]                 else {
[11:00:13.781]                   if (TRUE) {
[11:00:13.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:13.781]                     {
[11:00:13.781]                       inherits <- base::inherits
[11:00:13.781]                       invokeRestart <- base::invokeRestart
[11:00:13.781]                       is.null <- base::is.null
[11:00:13.781]                       muffled <- FALSE
[11:00:13.781]                       if (inherits(cond, "message")) {
[11:00:13.781]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:13.781]                         if (muffled) 
[11:00:13.781]                           invokeRestart("muffleMessage")
[11:00:13.781]                       }
[11:00:13.781]                       else if (inherits(cond, "warning")) {
[11:00:13.781]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:13.781]                         if (muffled) 
[11:00:13.781]                           invokeRestart("muffleWarning")
[11:00:13.781]                       }
[11:00:13.781]                       else if (inherits(cond, "condition")) {
[11:00:13.781]                         if (!is.null(pattern)) {
[11:00:13.781]                           computeRestarts <- base::computeRestarts
[11:00:13.781]                           grepl <- base::grepl
[11:00:13.781]                           restarts <- computeRestarts(cond)
[11:00:13.781]                           for (restart in restarts) {
[11:00:13.781]                             name <- restart$name
[11:00:13.781]                             if (is.null(name)) 
[11:00:13.781]                               next
[11:00:13.781]                             if (!grepl(pattern, name)) 
[11:00:13.781]                               next
[11:00:13.781]                             invokeRestart(restart)
[11:00:13.781]                             muffled <- TRUE
[11:00:13.781]                             break
[11:00:13.781]                           }
[11:00:13.781]                         }
[11:00:13.781]                       }
[11:00:13.781]                       invisible(muffled)
[11:00:13.781]                     }
[11:00:13.781]                     muffleCondition(cond, pattern = "^muffle")
[11:00:13.781]                   }
[11:00:13.781]                 }
[11:00:13.781]             }
[11:00:13.781]         }))
[11:00:13.781]     }, error = function(ex) {
[11:00:13.781]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:13.781]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:13.781]                 ...future.rng), started = ...future.startTime, 
[11:00:13.781]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:13.781]             version = "1.8"), class = "FutureResult")
[11:00:13.781]     }, finally = {
[11:00:13.781]         if (!identical(...future.workdir, getwd())) 
[11:00:13.781]             setwd(...future.workdir)
[11:00:13.781]         {
[11:00:13.781]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:13.781]                 ...future.oldOptions$nwarnings <- NULL
[11:00:13.781]             }
[11:00:13.781]             base::options(...future.oldOptions)
[11:00:13.781]             if (.Platform$OS.type == "windows") {
[11:00:13.781]                 old_names <- names(...future.oldEnvVars)
[11:00:13.781]                 envs <- base::Sys.getenv()
[11:00:13.781]                 names <- names(envs)
[11:00:13.781]                 common <- intersect(names, old_names)
[11:00:13.781]                 added <- setdiff(names, old_names)
[11:00:13.781]                 removed <- setdiff(old_names, names)
[11:00:13.781]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:13.781]                   envs[common]]
[11:00:13.781]                 NAMES <- toupper(changed)
[11:00:13.781]                 args <- list()
[11:00:13.781]                 for (kk in seq_along(NAMES)) {
[11:00:13.781]                   name <- changed[[kk]]
[11:00:13.781]                   NAME <- NAMES[[kk]]
[11:00:13.781]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:13.781]                     next
[11:00:13.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:13.781]                 }
[11:00:13.781]                 NAMES <- toupper(added)
[11:00:13.781]                 for (kk in seq_along(NAMES)) {
[11:00:13.781]                   name <- added[[kk]]
[11:00:13.781]                   NAME <- NAMES[[kk]]
[11:00:13.781]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:13.781]                     next
[11:00:13.781]                   args[[name]] <- ""
[11:00:13.781]                 }
[11:00:13.781]                 NAMES <- toupper(removed)
[11:00:13.781]                 for (kk in seq_along(NAMES)) {
[11:00:13.781]                   name <- removed[[kk]]
[11:00:13.781]                   NAME <- NAMES[[kk]]
[11:00:13.781]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:13.781]                     next
[11:00:13.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:13.781]                 }
[11:00:13.781]                 if (length(args) > 0) 
[11:00:13.781]                   base::do.call(base::Sys.setenv, args = args)
[11:00:13.781]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:13.781]             }
[11:00:13.781]             else {
[11:00:13.781]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:13.781]             }
[11:00:13.781]             {
[11:00:13.781]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:13.781]                   0L) {
[11:00:13.781]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:13.781]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:13.781]                   base::options(opts)
[11:00:13.781]                 }
[11:00:13.781]                 {
[11:00:13.781]                   {
[11:00:13.781]                     NULL
[11:00:13.781]                     RNGkind("Mersenne-Twister")
[11:00:13.781]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:13.781]                       inherits = FALSE)
[11:00:13.781]                   }
[11:00:13.781]                   options(future.plan = NULL)
[11:00:13.781]                   if (is.na(NA_character_)) 
[11:00:13.781]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:13.781]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:13.781]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:13.781]                     .init = FALSE)
[11:00:13.781]                 }
[11:00:13.781]             }
[11:00:13.781]         }
[11:00:13.781]     })
[11:00:13.781]     if (TRUE) {
[11:00:13.781]         base::sink(type = "output", split = FALSE)
[11:00:13.781]         if (FALSE) {
[11:00:13.781]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:13.781]         }
[11:00:13.781]         else {
[11:00:13.781]             ...future.result["stdout"] <- base::list(NULL)
[11:00:13.781]         }
[11:00:13.781]         base::close(...future.stdout)
[11:00:13.781]         ...future.stdout <- NULL
[11:00:13.781]     }
[11:00:13.781]     ...future.result$conditions <- ...future.conditions
[11:00:13.781]     ...future.result$finished <- base::Sys.time()
[11:00:13.781]     ...future.result
[11:00:13.781] }
[11:00:13.782] assign_globals() ...
[11:00:13.783] List of 5
[11:00:13.783]  $ ...future.FUN            :function (x)  
[11:00:13.783]  $ future.call.arguments    : list()
[11:00:13.783]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:13.783]  $ ...future.elements_ii    :List of 2
[11:00:13.783]   ..$ : int 1
[11:00:13.783]   ..$ : int 0
[11:00:13.783]  $ ...future.seeds_ii       : NULL
[11:00:13.783]  $ ...future.globals.maxSize: NULL
[11:00:13.783]  - attr(*, "where")=List of 5
[11:00:13.783]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:13.783]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:13.783]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:13.783]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:13.783]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:13.783]  - attr(*, "resolved")= logi FALSE
[11:00:13.783]  - attr(*, "total_size")= num 5632
[11:00:13.783]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:13.783]  - attr(*, "already-done")= logi TRUE
[11:00:13.787] - reassign environment for ‘...future.FUN’
[11:00:13.787] - copied ‘...future.FUN’ to environment
[11:00:13.787] - copied ‘future.call.arguments’ to environment
[11:00:13.787] - copied ‘...future.elements_ii’ to environment
[11:00:13.788] - copied ‘...future.seeds_ii’ to environment
[11:00:13.788] - copied ‘...future.globals.maxSize’ to environment
[11:00:13.788] assign_globals() ... done
[11:00:13.788] plan(): Setting new future strategy stack:
[11:00:13.788] List of future strategies:
[11:00:13.788] 1. sequential:
[11:00:13.788]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:13.788]    - tweaked: FALSE
[11:00:13.788]    - call: NULL
[11:00:13.788] plan(): nbrOfWorkers() = 1
[11:00:14.291] plan(): Setting new future strategy stack:
[11:00:14.291] List of future strategies:
[11:00:14.291] 1. sequential:
[11:00:14.291]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:14.291]    - tweaked: FALSE
[11:00:14.291]    - call: plan(strategy)
[11:00:14.291] plan(): nbrOfWorkers() = 1
[11:00:14.292] SequentialFuture started (and completed)
[11:00:14.292] - Launch lazy future ... done
[11:00:14.292] run() for ‘SequentialFuture’ ... done
[11:00:14.292] Created future:
[11:00:14.292] SequentialFuture:
[11:00:14.292] Label: ‘future_lapply-1’
[11:00:14.292] Expression:
[11:00:14.292] {
[11:00:14.292]     do.call(function(...) {
[11:00:14.292]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:14.292]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:14.292]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:14.292]             on.exit(options(oopts), add = TRUE)
[11:00:14.292]         }
[11:00:14.292]         {
[11:00:14.292]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:14.292]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:14.292]                 ...future.FUN(...future.X_jj, ...)
[11:00:14.292]             })
[11:00:14.292]         }
[11:00:14.292]     }, args = future.call.arguments)
[11:00:14.292] }
[11:00:14.292] Lazy evaluation: FALSE
[11:00:14.292] Asynchronous evaluation: FALSE
[11:00:14.292] Local evaluation: TRUE
[11:00:14.292] Environment: R_GlobalEnv
[11:00:14.292] Capture standard output: FALSE
[11:00:14.292] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:14.292] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:14.292] Packages: <none>
[11:00:14.292] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:14.292] Resolved: TRUE
[11:00:14.292] Value: 55 bytes of class ‘list’
[11:00:14.292] Early signaling: FALSE
[11:00:14.292] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:14.292] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:14.293] Chunk #1 of 1 ... DONE
[11:00:14.294] Launching 1 futures (chunks) ... DONE
[11:00:14.294] Resolving 1 futures (chunks) ...
[11:00:14.294] resolve() on list ...
[11:00:14.294]  recursive: 0
[11:00:14.294]  length: 1
[11:00:14.294] 
[11:00:14.294] resolved() for ‘SequentialFuture’ ...
[11:00:14.294] - state: ‘finished’
[11:00:14.294] - run: TRUE
[11:00:14.294] - result: ‘FutureResult’
[11:00:14.295] resolved() for ‘SequentialFuture’ ... done
[11:00:14.295] Future #1
[11:00:14.295] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:14.295] - nx: 1
[11:00:14.295] - relay: TRUE
[11:00:14.295] - stdout: TRUE
[11:00:14.295] - signal: TRUE
[11:00:14.295] - resignal: FALSE
[11:00:14.295] - force: TRUE
[11:00:14.296] - relayed: [n=1] FALSE
[11:00:14.296] - queued futures: [n=1] FALSE
[11:00:14.296]  - until=1
[11:00:14.296]  - relaying element #1
[11:00:14.296] - relayed: [n=1] TRUE
[11:00:14.296] - queued futures: [n=1] TRUE
[11:00:14.296] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:14.298]  length: 0 (resolved future 1)
[11:00:14.298] Relaying remaining futures
[11:00:14.298] signalConditionsASAP(NULL, pos=0) ...
[11:00:14.298] - nx: 1
[11:00:14.298] - relay: TRUE
[11:00:14.299] - stdout: TRUE
[11:00:14.299] - signal: TRUE
[11:00:14.299] - resignal: FALSE
[11:00:14.299] - force: TRUE
[11:00:14.299] - relayed: [n=1] TRUE
[11:00:14.299] - queued futures: [n=1] TRUE
 - flush all
[11:00:14.299] - relayed: [n=1] TRUE
[11:00:14.299] - queued futures: [n=1] TRUE
[11:00:14.299] signalConditionsASAP(NULL, pos=0) ... done
[11:00:14.299] resolve() on list ... DONE
[11:00:14.299]  - Number of value chunks collected: 1
[11:00:14.300] Resolving 1 futures (chunks) ... DONE
[11:00:14.300] Reducing values from 1 chunks ...
[11:00:14.300]  - Number of values collected after concatenation: 2
[11:00:14.300]  - Number of values expected: 2
[11:00:14.300] Reducing values from 1 chunks ... DONE
[11:00:14.300] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[11:00:14.300] future_lapply() ...
[11:00:14.301] Number of chunks: 1
[11:00:14.301] getGlobalsAndPackagesXApply() ...
[11:00:14.301]  - future.globals: TRUE
[11:00:14.301] getGlobalsAndPackages() ...
[11:00:14.301] Searching for globals...
[11:00:14.303] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[11:00:14.303] Searching for globals ... DONE
[11:00:14.303] Resolving globals: FALSE
[11:00:14.303] The total size of the 1 globals is 841 bytes (841 bytes)
[11:00:14.304] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[11:00:14.304] - globals: [1] ‘FUN’
[11:00:14.304] 
[11:00:14.304] getGlobalsAndPackages() ... DONE
[11:00:14.304]  - globals found/used: [n=1] ‘FUN’
[11:00:14.304]  - needed namespaces: [n=0] 
[11:00:14.304] Finding globals ... DONE
[11:00:14.304]  - use_args: TRUE
[11:00:14.304]  - Getting '...' globals ...
[11:00:14.305] resolve() on list ...
[11:00:14.305]  recursive: 0
[11:00:14.305]  length: 1
[11:00:14.305]  elements: ‘...’
[11:00:14.305]  length: 0 (resolved future 1)
[11:00:14.305] resolve() on list ... DONE
[11:00:14.305]    - '...' content: [n=0] 
[11:00:14.305] List of 1
[11:00:14.305]  $ ...: list()
[11:00:14.305]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:14.305]  - attr(*, "where")=List of 1
[11:00:14.305]   ..$ ...:<environment: 0x55ceb243b980> 
[11:00:14.305]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:14.305]  - attr(*, "resolved")= logi TRUE
[11:00:14.305]  - attr(*, "total_size")= num NA
[11:00:14.307]  - Getting '...' globals ... DONE
[11:00:14.308] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[11:00:14.308] List of 2
[11:00:14.308]  $ ...future.FUN:function (x)  
[11:00:14.308]  $ ...          : list()
[11:00:14.308]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:14.308]  - attr(*, "where")=List of 2
[11:00:14.308]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:14.308]   ..$ ...          :<environment: 0x55ceb243b980> 
[11:00:14.308]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:14.308]  - attr(*, "resolved")= logi FALSE
[11:00:14.308]  - attr(*, "total_size")= num 5632
[11:00:14.310] Packages to be attached in all futures: [n=0] 
[11:00:14.310] getGlobalsAndPackagesXApply() ... DONE
[11:00:14.311] Number of futures (= number of chunks): 1
[11:00:14.311] Launching 1 futures (chunks) ...
[11:00:14.311] Chunk #1 of 1 ...
[11:00:14.311]  - Finding globals in 'X' for chunk #1 ...
[11:00:14.311] getGlobalsAndPackages() ...
[11:00:14.311] Searching for globals...
[11:00:14.311] 
[11:00:14.311] Searching for globals ... DONE
[11:00:14.311] - globals: [0] <none>
[11:00:14.312] getGlobalsAndPackages() ... DONE
[11:00:14.312]    + additional globals found: [n=0] 
[11:00:14.312]    + additional namespaces needed: [n=0] 
[11:00:14.312]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:14.312]  - seeds: <none>
[11:00:14.312]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:14.312] getGlobalsAndPackages() ...
[11:00:14.312] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:14.312] Resolving globals: FALSE
[11:00:14.312] Tweak future expression to call with '...' arguments ...
[11:00:14.312] {
[11:00:14.312]     do.call(function(...) {
[11:00:14.312]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:14.312]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:14.312]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:14.312]             on.exit(options(oopts), add = TRUE)
[11:00:14.312]         }
[11:00:14.312]         {
[11:00:14.312]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:14.312]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:14.312]                 ...future.FUN(...future.X_jj, ...)
[11:00:14.312]             })
[11:00:14.312]         }
[11:00:14.312]     }, args = future.call.arguments)
[11:00:14.312] }
[11:00:14.313] Tweak future expression to call with '...' arguments ... DONE
[11:00:14.313] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:14.313] 
[11:00:14.313] getGlobalsAndPackages() ... DONE
[11:00:14.313] run() for ‘Future’ ...
[11:00:14.314] - state: ‘created’
[11:00:14.314] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:14.314] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:14.314] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:14.314]   - Field: ‘label’
[11:00:14.314]   - Field: ‘local’
[11:00:14.314]   - Field: ‘owner’
[11:00:14.314]   - Field: ‘envir’
[11:00:14.314]   - Field: ‘packages’
[11:00:14.315]   - Field: ‘gc’
[11:00:14.315]   - Field: ‘conditions’
[11:00:14.315]   - Field: ‘expr’
[11:00:14.315]   - Field: ‘uuid’
[11:00:14.315]   - Field: ‘seed’
[11:00:14.315]   - Field: ‘version’
[11:00:14.315]   - Field: ‘result’
[11:00:14.315]   - Field: ‘asynchronous’
[11:00:14.315]   - Field: ‘calls’
[11:00:14.315]   - Field: ‘globals’
[11:00:14.315]   - Field: ‘stdout’
[11:00:14.315]   - Field: ‘earlySignal’
[11:00:14.316]   - Field: ‘lazy’
[11:00:14.316]   - Field: ‘state’
[11:00:14.316] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:14.316] - Launch lazy future ...
[11:00:14.316] Packages needed by the future expression (n = 0): <none>
[11:00:14.316] Packages needed by future strategies (n = 0): <none>
[11:00:14.316] {
[11:00:14.316]     {
[11:00:14.316]         {
[11:00:14.316]             ...future.startTime <- base::Sys.time()
[11:00:14.316]             {
[11:00:14.316]                 {
[11:00:14.316]                   {
[11:00:14.316]                     base::local({
[11:00:14.316]                       has_future <- base::requireNamespace("future", 
[11:00:14.316]                         quietly = TRUE)
[11:00:14.316]                       if (has_future) {
[11:00:14.316]                         ns <- base::getNamespace("future")
[11:00:14.316]                         version <- ns[[".package"]][["version"]]
[11:00:14.316]                         if (is.null(version)) 
[11:00:14.316]                           version <- utils::packageVersion("future")
[11:00:14.316]                       }
[11:00:14.316]                       else {
[11:00:14.316]                         version <- NULL
[11:00:14.316]                       }
[11:00:14.316]                       if (!has_future || version < "1.8.0") {
[11:00:14.316]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:14.316]                           "", base::R.version$version.string), 
[11:00:14.316]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:14.316]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:14.316]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:14.316]                             "release", "version")], collapse = " "), 
[11:00:14.316]                           hostname = base::Sys.info()[["nodename"]])
[11:00:14.316]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:14.316]                           info)
[11:00:14.316]                         info <- base::paste(info, collapse = "; ")
[11:00:14.316]                         if (!has_future) {
[11:00:14.316]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:14.316]                             info)
[11:00:14.316]                         }
[11:00:14.316]                         else {
[11:00:14.316]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:14.316]                             info, version)
[11:00:14.316]                         }
[11:00:14.316]                         base::stop(msg)
[11:00:14.316]                       }
[11:00:14.316]                     })
[11:00:14.316]                   }
[11:00:14.316]                   ...future.strategy.old <- future::plan("list")
[11:00:14.316]                   options(future.plan = NULL)
[11:00:14.316]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:14.316]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:14.316]                 }
[11:00:14.316]                 ...future.workdir <- getwd()
[11:00:14.316]             }
[11:00:14.316]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:14.316]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:14.316]         }
[11:00:14.316]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:14.316]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:14.316]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:14.316]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:14.316]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:14.316]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:14.316]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:14.316]             base::names(...future.oldOptions))
[11:00:14.316]     }
[11:00:14.316]     if (FALSE) {
[11:00:14.316]     }
[11:00:14.316]     else {
[11:00:14.316]         if (TRUE) {
[11:00:14.316]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:14.316]                 open = "w")
[11:00:14.316]         }
[11:00:14.316]         else {
[11:00:14.316]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:14.316]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:14.316]         }
[11:00:14.316]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:14.316]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:14.316]             base::sink(type = "output", split = FALSE)
[11:00:14.316]             base::close(...future.stdout)
[11:00:14.316]         }, add = TRUE)
[11:00:14.316]     }
[11:00:14.316]     ...future.frame <- base::sys.nframe()
[11:00:14.316]     ...future.conditions <- base::list()
[11:00:14.316]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:14.316]     if (FALSE) {
[11:00:14.316]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:14.316]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:14.316]     }
[11:00:14.316]     ...future.result <- base::tryCatch({
[11:00:14.316]         base::withCallingHandlers({
[11:00:14.316]             ...future.value <- base::withVisible(base::local({
[11:00:14.316]                 do.call(function(...) {
[11:00:14.316]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:14.316]                   if (!identical(...future.globals.maxSize.org, 
[11:00:14.316]                     ...future.globals.maxSize)) {
[11:00:14.316]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:14.316]                     on.exit(options(oopts), add = TRUE)
[11:00:14.316]                   }
[11:00:14.316]                   {
[11:00:14.316]                     lapply(seq_along(...future.elements_ii), 
[11:00:14.316]                       FUN = function(jj) {
[11:00:14.316]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:14.316]                         ...future.FUN(...future.X_jj, ...)
[11:00:14.316]                       })
[11:00:14.316]                   }
[11:00:14.316]                 }, args = future.call.arguments)
[11:00:14.316]             }))
[11:00:14.316]             future::FutureResult(value = ...future.value$value, 
[11:00:14.316]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:14.316]                   ...future.rng), globalenv = if (FALSE) 
[11:00:14.316]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:14.316]                     ...future.globalenv.names))
[11:00:14.316]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:14.316]         }, condition = base::local({
[11:00:14.316]             c <- base::c
[11:00:14.316]             inherits <- base::inherits
[11:00:14.316]             invokeRestart <- base::invokeRestart
[11:00:14.316]             length <- base::length
[11:00:14.316]             list <- base::list
[11:00:14.316]             seq.int <- base::seq.int
[11:00:14.316]             signalCondition <- base::signalCondition
[11:00:14.316]             sys.calls <- base::sys.calls
[11:00:14.316]             `[[` <- base::`[[`
[11:00:14.316]             `+` <- base::`+`
[11:00:14.316]             `<<-` <- base::`<<-`
[11:00:14.316]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:14.316]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:14.316]                   3L)]
[11:00:14.316]             }
[11:00:14.316]             function(cond) {
[11:00:14.316]                 is_error <- inherits(cond, "error")
[11:00:14.316]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:14.316]                   NULL)
[11:00:14.316]                 if (is_error) {
[11:00:14.316]                   sessionInformation <- function() {
[11:00:14.316]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:14.316]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:14.316]                       search = base::search(), system = base::Sys.info())
[11:00:14.316]                   }
[11:00:14.316]                   ...future.conditions[[length(...future.conditions) + 
[11:00:14.316]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:14.316]                     cond$call), session = sessionInformation(), 
[11:00:14.316]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:14.316]                   signalCondition(cond)
[11:00:14.316]                 }
[11:00:14.316]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:14.316]                 "immediateCondition"))) {
[11:00:14.316]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:14.316]                   ...future.conditions[[length(...future.conditions) + 
[11:00:14.316]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:14.316]                   if (TRUE && !signal) {
[11:00:14.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:14.316]                     {
[11:00:14.316]                       inherits <- base::inherits
[11:00:14.316]                       invokeRestart <- base::invokeRestart
[11:00:14.316]                       is.null <- base::is.null
[11:00:14.316]                       muffled <- FALSE
[11:00:14.316]                       if (inherits(cond, "message")) {
[11:00:14.316]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:14.316]                         if (muffled) 
[11:00:14.316]                           invokeRestart("muffleMessage")
[11:00:14.316]                       }
[11:00:14.316]                       else if (inherits(cond, "warning")) {
[11:00:14.316]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:14.316]                         if (muffled) 
[11:00:14.316]                           invokeRestart("muffleWarning")
[11:00:14.316]                       }
[11:00:14.316]                       else if (inherits(cond, "condition")) {
[11:00:14.316]                         if (!is.null(pattern)) {
[11:00:14.316]                           computeRestarts <- base::computeRestarts
[11:00:14.316]                           grepl <- base::grepl
[11:00:14.316]                           restarts <- computeRestarts(cond)
[11:00:14.316]                           for (restart in restarts) {
[11:00:14.316]                             name <- restart$name
[11:00:14.316]                             if (is.null(name)) 
[11:00:14.316]                               next
[11:00:14.316]                             if (!grepl(pattern, name)) 
[11:00:14.316]                               next
[11:00:14.316]                             invokeRestart(restart)
[11:00:14.316]                             muffled <- TRUE
[11:00:14.316]                             break
[11:00:14.316]                           }
[11:00:14.316]                         }
[11:00:14.316]                       }
[11:00:14.316]                       invisible(muffled)
[11:00:14.316]                     }
[11:00:14.316]                     muffleCondition(cond, pattern = "^muffle")
[11:00:14.316]                   }
[11:00:14.316]                 }
[11:00:14.316]                 else {
[11:00:14.316]                   if (TRUE) {
[11:00:14.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:14.316]                     {
[11:00:14.316]                       inherits <- base::inherits
[11:00:14.316]                       invokeRestart <- base::invokeRestart
[11:00:14.316]                       is.null <- base::is.null
[11:00:14.316]                       muffled <- FALSE
[11:00:14.316]                       if (inherits(cond, "message")) {
[11:00:14.316]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:14.316]                         if (muffled) 
[11:00:14.316]                           invokeRestart("muffleMessage")
[11:00:14.316]                       }
[11:00:14.316]                       else if (inherits(cond, "warning")) {
[11:00:14.316]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:14.316]                         if (muffled) 
[11:00:14.316]                           invokeRestart("muffleWarning")
[11:00:14.316]                       }
[11:00:14.316]                       else if (inherits(cond, "condition")) {
[11:00:14.316]                         if (!is.null(pattern)) {
[11:00:14.316]                           computeRestarts <- base::computeRestarts
[11:00:14.316]                           grepl <- base::grepl
[11:00:14.316]                           restarts <- computeRestarts(cond)
[11:00:14.316]                           for (restart in restarts) {
[11:00:14.316]                             name <- restart$name
[11:00:14.316]                             if (is.null(name)) 
[11:00:14.316]                               next
[11:00:14.316]                             if (!grepl(pattern, name)) 
[11:00:14.316]                               next
[11:00:14.316]                             invokeRestart(restart)
[11:00:14.316]                             muffled <- TRUE
[11:00:14.316]                             break
[11:00:14.316]                           }
[11:00:14.316]                         }
[11:00:14.316]                       }
[11:00:14.316]                       invisible(muffled)
[11:00:14.316]                     }
[11:00:14.316]                     muffleCondition(cond, pattern = "^muffle")
[11:00:14.316]                   }
[11:00:14.316]                 }
[11:00:14.316]             }
[11:00:14.316]         }))
[11:00:14.316]     }, error = function(ex) {
[11:00:14.316]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:14.316]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:14.316]                 ...future.rng), started = ...future.startTime, 
[11:00:14.316]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:14.316]             version = "1.8"), class = "FutureResult")
[11:00:14.316]     }, finally = {
[11:00:14.316]         if (!identical(...future.workdir, getwd())) 
[11:00:14.316]             setwd(...future.workdir)
[11:00:14.316]         {
[11:00:14.316]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:14.316]                 ...future.oldOptions$nwarnings <- NULL
[11:00:14.316]             }
[11:00:14.316]             base::options(...future.oldOptions)
[11:00:14.316]             if (.Platform$OS.type == "windows") {
[11:00:14.316]                 old_names <- names(...future.oldEnvVars)
[11:00:14.316]                 envs <- base::Sys.getenv()
[11:00:14.316]                 names <- names(envs)
[11:00:14.316]                 common <- intersect(names, old_names)
[11:00:14.316]                 added <- setdiff(names, old_names)
[11:00:14.316]                 removed <- setdiff(old_names, names)
[11:00:14.316]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:14.316]                   envs[common]]
[11:00:14.316]                 NAMES <- toupper(changed)
[11:00:14.316]                 args <- list()
[11:00:14.316]                 for (kk in seq_along(NAMES)) {
[11:00:14.316]                   name <- changed[[kk]]
[11:00:14.316]                   NAME <- NAMES[[kk]]
[11:00:14.316]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:14.316]                     next
[11:00:14.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:14.316]                 }
[11:00:14.316]                 NAMES <- toupper(added)
[11:00:14.316]                 for (kk in seq_along(NAMES)) {
[11:00:14.316]                   name <- added[[kk]]
[11:00:14.316]                   NAME <- NAMES[[kk]]
[11:00:14.316]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:14.316]                     next
[11:00:14.316]                   args[[name]] <- ""
[11:00:14.316]                 }
[11:00:14.316]                 NAMES <- toupper(removed)
[11:00:14.316]                 for (kk in seq_along(NAMES)) {
[11:00:14.316]                   name <- removed[[kk]]
[11:00:14.316]                   NAME <- NAMES[[kk]]
[11:00:14.316]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:14.316]                     next
[11:00:14.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:14.316]                 }
[11:00:14.316]                 if (length(args) > 0) 
[11:00:14.316]                   base::do.call(base::Sys.setenv, args = args)
[11:00:14.316]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:14.316]             }
[11:00:14.316]             else {
[11:00:14.316]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:14.316]             }
[11:00:14.316]             {
[11:00:14.316]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:14.316]                   0L) {
[11:00:14.316]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:14.316]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:14.316]                   base::options(opts)
[11:00:14.316]                 }
[11:00:14.316]                 {
[11:00:14.316]                   {
[11:00:14.316]                     NULL
[11:00:14.316]                     RNGkind("Mersenne-Twister")
[11:00:14.316]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:14.316]                       inherits = FALSE)
[11:00:14.316]                   }
[11:00:14.316]                   options(future.plan = NULL)
[11:00:14.316]                   if (is.na(NA_character_)) 
[11:00:14.316]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:14.316]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:14.316]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:14.316]                     .init = FALSE)
[11:00:14.316]                 }
[11:00:14.316]             }
[11:00:14.316]         }
[11:00:14.316]     })
[11:00:14.316]     if (TRUE) {
[11:00:14.316]         base::sink(type = "output", split = FALSE)
[11:00:14.316]         if (TRUE) {
[11:00:14.316]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:14.316]         }
[11:00:14.316]         else {
[11:00:14.316]             ...future.result["stdout"] <- base::list(NULL)
[11:00:14.316]         }
[11:00:14.316]         base::close(...future.stdout)
[11:00:14.316]         ...future.stdout <- NULL
[11:00:14.316]     }
[11:00:14.316]     ...future.result$conditions <- ...future.conditions
[11:00:14.316]     ...future.result$finished <- base::Sys.time()
[11:00:14.316]     ...future.result
[11:00:14.316] }
[11:00:14.318] assign_globals() ...
[11:00:14.318] List of 5
[11:00:14.318]  $ ...future.FUN            :function (x)  
[11:00:14.318]  $ future.call.arguments    : list()
[11:00:14.318]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:14.318]  $ ...future.elements_ii    :List of 2
[11:00:14.318]   ..$ : int 1
[11:00:14.318]   ..$ : int 0
[11:00:14.318]  $ ...future.seeds_ii       : NULL
[11:00:14.318]  $ ...future.globals.maxSize: NULL
[11:00:14.318]  - attr(*, "where")=List of 5
[11:00:14.318]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:14.318]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:14.318]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:14.318]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:14.318]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:14.318]  - attr(*, "resolved")= logi FALSE
[11:00:14.318]  - attr(*, "total_size")= num 5632
[11:00:14.318]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:14.318]  - attr(*, "already-done")= logi TRUE
[11:00:14.324] - reassign environment for ‘...future.FUN’
[11:00:14.324] - copied ‘...future.FUN’ to environment
[11:00:14.324] - copied ‘future.call.arguments’ to environment
[11:00:14.324] - copied ‘...future.elements_ii’ to environment
[11:00:14.324] - copied ‘...future.seeds_ii’ to environment
[11:00:14.324] - copied ‘...future.globals.maxSize’ to environment
[11:00:14.324] assign_globals() ... done
[11:00:14.325] plan(): Setting new future strategy stack:
[11:00:14.325] List of future strategies:
[11:00:14.325] 1. sequential:
[11:00:14.325]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:14.325]    - tweaked: FALSE
[11:00:14.325]    - call: NULL
[11:00:14.325] plan(): nbrOfWorkers() = 1
[11:00:14.827] plan(): Setting new future strategy stack:
[11:00:14.827] List of future strategies:
[11:00:14.827] 1. sequential:
[11:00:14.827]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:14.827]    - tweaked: FALSE
[11:00:14.827]    - call: plan(strategy)
[11:00:14.828] plan(): nbrOfWorkers() = 1
[11:00:14.828] SequentialFuture started (and completed)
[11:00:14.828] - Launch lazy future ... done
[11:00:14.828] run() for ‘SequentialFuture’ ... done
[11:00:14.828] Created future:
[11:00:14.828] SequentialFuture:
[11:00:14.828] Label: ‘future_lapply-1’
[11:00:14.828] Expression:
[11:00:14.828] {
[11:00:14.828]     do.call(function(...) {
[11:00:14.828]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:14.828]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:14.828]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:14.828]             on.exit(options(oopts), add = TRUE)
[11:00:14.828]         }
[11:00:14.828]         {
[11:00:14.828]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:14.828]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:14.828]                 ...future.FUN(...future.X_jj, ...)
[11:00:14.828]             })
[11:00:14.828]         }
[11:00:14.828]     }, args = future.call.arguments)
[11:00:14.828] }
[11:00:14.828] Lazy evaluation: FALSE
[11:00:14.828] Asynchronous evaluation: FALSE
[11:00:14.828] Local evaluation: TRUE
[11:00:14.828] Environment: R_GlobalEnv
[11:00:14.828] Capture standard output: TRUE
[11:00:14.828] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:14.828] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:14.828] Packages: <none>
[11:00:14.828] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:14.828] Resolved: TRUE
[11:00:14.828] Value: 55 bytes of class ‘list’
[11:00:14.828] Early signaling: FALSE
[11:00:14.828] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:14.828] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:14.829] Chunk #1 of 1 ... DONE
[11:00:14.829] Launching 1 futures (chunks) ... DONE
[11:00:14.829] Resolving 1 futures (chunks) ...
[11:00:14.829] resolve() on list ...
[11:00:14.829]  recursive: 0
[11:00:14.830]  length: 1
[11:00:14.830] 
[11:00:14.830] resolved() for ‘SequentialFuture’ ...
[11:00:14.830] - state: ‘finished’
[11:00:14.830] - run: TRUE
[11:00:14.830] - result: ‘FutureResult’
[11:00:14.830] resolved() for ‘SequentialFuture’ ... done
[11:00:14.830] Future #1
[11:00:14.830] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:14.830] - nx: 1
[11:00:14.831] - relay: TRUE
[11:00:14.831] - stdout: TRUE
[11:00:14.831] - signal: TRUE
[11:00:14.831] - resignal: FALSE
[11:00:14.831] - force: TRUE
[11:00:14.831] - relayed: [n=1] FALSE
[11:00:14.831] - queued futures: [n=1] FALSE
[11:00:14.831]  - until=1
[11:00:14.831]  - relaying element #1
[11:00:14.831] - relayed: [n=1] TRUE
[11:00:14.831] - queued futures: [n=1] TRUE
[11:00:14.832] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:14.832]  length: 0 (resolved future 1)
[11:00:14.832] Relaying remaining futures
[11:00:14.832] signalConditionsASAP(NULL, pos=0) ...
[11:00:14.832] - nx: 1
[11:00:14.832] - relay: TRUE
[11:00:14.832] - stdout: TRUE
[11:00:14.832] - signal: TRUE
[11:00:14.832] - resignal: FALSE
[11:00:14.832] - force: TRUE
[11:00:14.832] - relayed: [n=1] TRUE
[11:00:14.832] - queued futures: [n=1] TRUE
 - flush all
[11:00:14.833] - relayed: [n=1] TRUE
[11:00:14.833] - queued futures: [n=1] TRUE
[11:00:14.833] signalConditionsASAP(NULL, pos=0) ... done
[11:00:14.833] resolve() on list ... DONE
[11:00:14.833]  - Number of value chunks collected: 1
[11:00:14.833] Resolving 1 futures (chunks) ... DONE
[11:00:14.833] Reducing values from 1 chunks ...
[11:00:14.833]  - Number of values collected after concatenation: 2
[11:00:14.833]  - Number of values expected: 2
[11:00:14.833] Reducing values from 1 chunks ... DONE
[11:00:14.833] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[11:00:14.834] future_lapply() ...
[11:00:14.834] Number of chunks: 1
[11:00:14.835] getGlobalsAndPackagesXApply() ...
[11:00:14.835]  - future.globals: TRUE
[11:00:14.835] getGlobalsAndPackages() ...
[11:00:14.835] Searching for globals...
[11:00:14.836] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[11:00:14.836] Searching for globals ... DONE
[11:00:14.836] Resolving globals: FALSE
[11:00:14.837] The total size of the 1 globals is 841 bytes (841 bytes)
[11:00:14.837] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[11:00:14.837] - globals: [1] ‘FUN’
[11:00:14.837] 
[11:00:14.837] getGlobalsAndPackages() ... DONE
[11:00:14.838]  - globals found/used: [n=1] ‘FUN’
[11:00:14.838]  - needed namespaces: [n=0] 
[11:00:14.838] Finding globals ... DONE
[11:00:14.838]  - use_args: TRUE
[11:00:14.838]  - Getting '...' globals ...
[11:00:14.838] resolve() on list ...
[11:00:14.838]  recursive: 0
[11:00:14.838]  length: 1
[11:00:14.838]  elements: ‘...’
[11:00:14.839]  length: 0 (resolved future 1)
[11:00:14.839] resolve() on list ... DONE
[11:00:14.839]    - '...' content: [n=0] 
[11:00:14.839] List of 1
[11:00:14.839]  $ ...: list()
[11:00:14.839]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:14.839]  - attr(*, "where")=List of 1
[11:00:14.839]   ..$ ...:<environment: 0x55ceb329e3d8> 
[11:00:14.839]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:14.839]  - attr(*, "resolved")= logi TRUE
[11:00:14.839]  - attr(*, "total_size")= num NA
[11:00:14.841]  - Getting '...' globals ... DONE
[11:00:14.841] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[11:00:14.842] List of 2
[11:00:14.842]  $ ...future.FUN:function (x)  
[11:00:14.842]  $ ...          : list()
[11:00:14.842]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:14.842]  - attr(*, "where")=List of 2
[11:00:14.842]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:14.842]   ..$ ...          :<environment: 0x55ceb329e3d8> 
[11:00:14.842]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:14.842]  - attr(*, "resolved")= logi FALSE
[11:00:14.842]  - attr(*, "total_size")= num 5632
[11:00:14.844] Packages to be attached in all futures: [n=0] 
[11:00:14.844] getGlobalsAndPackagesXApply() ... DONE
[11:00:14.844] Number of futures (= number of chunks): 1
[11:00:14.845] Launching 1 futures (chunks) ...
[11:00:14.845] Chunk #1 of 1 ...
[11:00:14.845]  - Finding globals in 'X' for chunk #1 ...
[11:00:14.845] getGlobalsAndPackages() ...
[11:00:14.845] Searching for globals...
[11:00:14.845] 
[11:00:14.846] Searching for globals ... DONE
[11:00:14.846] - globals: [0] <none>
[11:00:14.846] getGlobalsAndPackages() ... DONE
[11:00:14.846]    + additional globals found: [n=0] 
[11:00:14.846]    + additional namespaces needed: [n=0] 
[11:00:14.846]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:14.846]  - seeds: <none>
[11:00:14.846]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:14.846] getGlobalsAndPackages() ...
[11:00:14.847] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:14.847] Resolving globals: FALSE
[11:00:14.847] Tweak future expression to call with '...' arguments ...
[11:00:14.847] {
[11:00:14.847]     do.call(function(...) {
[11:00:14.847]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:14.847]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:14.847]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:14.847]             on.exit(options(oopts), add = TRUE)
[11:00:14.847]         }
[11:00:14.847]         {
[11:00:14.847]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:14.847]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:14.847]                 ...future.FUN(...future.X_jj, ...)
[11:00:14.847]             })
[11:00:14.847]         }
[11:00:14.847]     }, args = future.call.arguments)
[11:00:14.847] }
[11:00:14.849] Tweak future expression to call with '...' arguments ... DONE
[11:00:14.849] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:14.850] 
[11:00:14.850] getGlobalsAndPackages() ... DONE
[11:00:14.850] run() for ‘Future’ ...
[11:00:14.850] - state: ‘created’
[11:00:14.850] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:14.851] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:14.851] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:14.851]   - Field: ‘label’
[11:00:14.851]   - Field: ‘local’
[11:00:14.851]   - Field: ‘owner’
[11:00:14.851]   - Field: ‘envir’
[11:00:14.851]   - Field: ‘packages’
[11:00:14.851]   - Field: ‘gc’
[11:00:14.851]   - Field: ‘conditions’
[11:00:14.851]   - Field: ‘expr’
[11:00:14.851]   - Field: ‘uuid’
[11:00:14.852]   - Field: ‘seed’
[11:00:14.852]   - Field: ‘version’
[11:00:14.852]   - Field: ‘result’
[11:00:14.852]   - Field: ‘asynchronous’
[11:00:14.852]   - Field: ‘calls’
[11:00:14.852]   - Field: ‘globals’
[11:00:14.852]   - Field: ‘stdout’
[11:00:14.852]   - Field: ‘earlySignal’
[11:00:14.852]   - Field: ‘lazy’
[11:00:14.852]   - Field: ‘state’
[11:00:14.852] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:14.852] - Launch lazy future ...
[11:00:14.853] Packages needed by the future expression (n = 0): <none>
[11:00:14.853] Packages needed by future strategies (n = 0): <none>
[11:00:14.853] {
[11:00:14.853]     {
[11:00:14.853]         {
[11:00:14.853]             ...future.startTime <- base::Sys.time()
[11:00:14.853]             {
[11:00:14.853]                 {
[11:00:14.853]                   {
[11:00:14.853]                     base::local({
[11:00:14.853]                       has_future <- base::requireNamespace("future", 
[11:00:14.853]                         quietly = TRUE)
[11:00:14.853]                       if (has_future) {
[11:00:14.853]                         ns <- base::getNamespace("future")
[11:00:14.853]                         version <- ns[[".package"]][["version"]]
[11:00:14.853]                         if (is.null(version)) 
[11:00:14.853]                           version <- utils::packageVersion("future")
[11:00:14.853]                       }
[11:00:14.853]                       else {
[11:00:14.853]                         version <- NULL
[11:00:14.853]                       }
[11:00:14.853]                       if (!has_future || version < "1.8.0") {
[11:00:14.853]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:14.853]                           "", base::R.version$version.string), 
[11:00:14.853]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:14.853]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:14.853]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:14.853]                             "release", "version")], collapse = " "), 
[11:00:14.853]                           hostname = base::Sys.info()[["nodename"]])
[11:00:14.853]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:14.853]                           info)
[11:00:14.853]                         info <- base::paste(info, collapse = "; ")
[11:00:14.853]                         if (!has_future) {
[11:00:14.853]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:14.853]                             info)
[11:00:14.853]                         }
[11:00:14.853]                         else {
[11:00:14.853]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:14.853]                             info, version)
[11:00:14.853]                         }
[11:00:14.853]                         base::stop(msg)
[11:00:14.853]                       }
[11:00:14.853]                     })
[11:00:14.853]                   }
[11:00:14.853]                   ...future.strategy.old <- future::plan("list")
[11:00:14.853]                   options(future.plan = NULL)
[11:00:14.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:14.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:14.853]                 }
[11:00:14.853]                 ...future.workdir <- getwd()
[11:00:14.853]             }
[11:00:14.853]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:14.853]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:14.853]         }
[11:00:14.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:14.853]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:14.853]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:14.853]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:14.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:14.853]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:14.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:14.853]             base::names(...future.oldOptions))
[11:00:14.853]     }
[11:00:14.853]     if (TRUE) {
[11:00:14.853]     }
[11:00:14.853]     else {
[11:00:14.853]         if (NA) {
[11:00:14.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:14.853]                 open = "w")
[11:00:14.853]         }
[11:00:14.853]         else {
[11:00:14.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:14.853]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:14.853]         }
[11:00:14.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:14.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:14.853]             base::sink(type = "output", split = FALSE)
[11:00:14.853]             base::close(...future.stdout)
[11:00:14.853]         }, add = TRUE)
[11:00:14.853]     }
[11:00:14.853]     ...future.frame <- base::sys.nframe()
[11:00:14.853]     ...future.conditions <- base::list()
[11:00:14.853]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:14.853]     if (FALSE) {
[11:00:14.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:14.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:14.853]     }
[11:00:14.853]     ...future.result <- base::tryCatch({
[11:00:14.853]         base::withCallingHandlers({
[11:00:14.853]             ...future.value <- base::withVisible(base::local({
[11:00:14.853]                 do.call(function(...) {
[11:00:14.853]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:14.853]                   if (!identical(...future.globals.maxSize.org, 
[11:00:14.853]                     ...future.globals.maxSize)) {
[11:00:14.853]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:14.853]                     on.exit(options(oopts), add = TRUE)
[11:00:14.853]                   }
[11:00:14.853]                   {
[11:00:14.853]                     lapply(seq_along(...future.elements_ii), 
[11:00:14.853]                       FUN = function(jj) {
[11:00:14.853]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:14.853]                         ...future.FUN(...future.X_jj, ...)
[11:00:14.853]                       })
[11:00:14.853]                   }
[11:00:14.853]                 }, args = future.call.arguments)
[11:00:14.853]             }))
[11:00:14.853]             future::FutureResult(value = ...future.value$value, 
[11:00:14.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:14.853]                   ...future.rng), globalenv = if (FALSE) 
[11:00:14.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:14.853]                     ...future.globalenv.names))
[11:00:14.853]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:14.853]         }, condition = base::local({
[11:00:14.853]             c <- base::c
[11:00:14.853]             inherits <- base::inherits
[11:00:14.853]             invokeRestart <- base::invokeRestart
[11:00:14.853]             length <- base::length
[11:00:14.853]             list <- base::list
[11:00:14.853]             seq.int <- base::seq.int
[11:00:14.853]             signalCondition <- base::signalCondition
[11:00:14.853]             sys.calls <- base::sys.calls
[11:00:14.853]             `[[` <- base::`[[`
[11:00:14.853]             `+` <- base::`+`
[11:00:14.853]             `<<-` <- base::`<<-`
[11:00:14.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:14.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:14.853]                   3L)]
[11:00:14.853]             }
[11:00:14.853]             function(cond) {
[11:00:14.853]                 is_error <- inherits(cond, "error")
[11:00:14.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:14.853]                   NULL)
[11:00:14.853]                 if (is_error) {
[11:00:14.853]                   sessionInformation <- function() {
[11:00:14.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:14.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:14.853]                       search = base::search(), system = base::Sys.info())
[11:00:14.853]                   }
[11:00:14.853]                   ...future.conditions[[length(...future.conditions) + 
[11:00:14.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:14.853]                     cond$call), session = sessionInformation(), 
[11:00:14.853]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:14.853]                   signalCondition(cond)
[11:00:14.853]                 }
[11:00:14.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:14.853]                 "immediateCondition"))) {
[11:00:14.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:14.853]                   ...future.conditions[[length(...future.conditions) + 
[11:00:14.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:14.853]                   if (TRUE && !signal) {
[11:00:14.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:14.853]                     {
[11:00:14.853]                       inherits <- base::inherits
[11:00:14.853]                       invokeRestart <- base::invokeRestart
[11:00:14.853]                       is.null <- base::is.null
[11:00:14.853]                       muffled <- FALSE
[11:00:14.853]                       if (inherits(cond, "message")) {
[11:00:14.853]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:14.853]                         if (muffled) 
[11:00:14.853]                           invokeRestart("muffleMessage")
[11:00:14.853]                       }
[11:00:14.853]                       else if (inherits(cond, "warning")) {
[11:00:14.853]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:14.853]                         if (muffled) 
[11:00:14.853]                           invokeRestart("muffleWarning")
[11:00:14.853]                       }
[11:00:14.853]                       else if (inherits(cond, "condition")) {
[11:00:14.853]                         if (!is.null(pattern)) {
[11:00:14.853]                           computeRestarts <- base::computeRestarts
[11:00:14.853]                           grepl <- base::grepl
[11:00:14.853]                           restarts <- computeRestarts(cond)
[11:00:14.853]                           for (restart in restarts) {
[11:00:14.853]                             name <- restart$name
[11:00:14.853]                             if (is.null(name)) 
[11:00:14.853]                               next
[11:00:14.853]                             if (!grepl(pattern, name)) 
[11:00:14.853]                               next
[11:00:14.853]                             invokeRestart(restart)
[11:00:14.853]                             muffled <- TRUE
[11:00:14.853]                             break
[11:00:14.853]                           }
[11:00:14.853]                         }
[11:00:14.853]                       }
[11:00:14.853]                       invisible(muffled)
[11:00:14.853]                     }
[11:00:14.853]                     muffleCondition(cond, pattern = "^muffle")
[11:00:14.853]                   }
[11:00:14.853]                 }
[11:00:14.853]                 else {
[11:00:14.853]                   if (TRUE) {
[11:00:14.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:14.853]                     {
[11:00:14.853]                       inherits <- base::inherits
[11:00:14.853]                       invokeRestart <- base::invokeRestart
[11:00:14.853]                       is.null <- base::is.null
[11:00:14.853]                       muffled <- FALSE
[11:00:14.853]                       if (inherits(cond, "message")) {
[11:00:14.853]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:14.853]                         if (muffled) 
[11:00:14.853]                           invokeRestart("muffleMessage")
[11:00:14.853]                       }
[11:00:14.853]                       else if (inherits(cond, "warning")) {
[11:00:14.853]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:14.853]                         if (muffled) 
[11:00:14.853]                           invokeRestart("muffleWarning")
[11:00:14.853]                       }
[11:00:14.853]                       else if (inherits(cond, "condition")) {
[11:00:14.853]                         if (!is.null(pattern)) {
[11:00:14.853]                           computeRestarts <- base::computeRestarts
[11:00:14.853]                           grepl <- base::grepl
[11:00:14.853]                           restarts <- computeRestarts(cond)
[11:00:14.853]                           for (restart in restarts) {
[11:00:14.853]                             name <- restart$name
[11:00:14.853]                             if (is.null(name)) 
[11:00:14.853]                               next
[11:00:14.853]                             if (!grepl(pattern, name)) 
[11:00:14.853]                               next
[11:00:14.853]                             invokeRestart(restart)
[11:00:14.853]                             muffled <- TRUE
[11:00:14.853]                             break
[11:00:14.853]                           }
[11:00:14.853]                         }
[11:00:14.853]                       }
[11:00:14.853]                       invisible(muffled)
[11:00:14.853]                     }
[11:00:14.853]                     muffleCondition(cond, pattern = "^muffle")
[11:00:14.853]                   }
[11:00:14.853]                 }
[11:00:14.853]             }
[11:00:14.853]         }))
[11:00:14.853]     }, error = function(ex) {
[11:00:14.853]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:14.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:14.853]                 ...future.rng), started = ...future.startTime, 
[11:00:14.853]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:14.853]             version = "1.8"), class = "FutureResult")
[11:00:14.853]     }, finally = {
[11:00:14.853]         if (!identical(...future.workdir, getwd())) 
[11:00:14.853]             setwd(...future.workdir)
[11:00:14.853]         {
[11:00:14.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:14.853]                 ...future.oldOptions$nwarnings <- NULL
[11:00:14.853]             }
[11:00:14.853]             base::options(...future.oldOptions)
[11:00:14.853]             if (.Platform$OS.type == "windows") {
[11:00:14.853]                 old_names <- names(...future.oldEnvVars)
[11:00:14.853]                 envs <- base::Sys.getenv()
[11:00:14.853]                 names <- names(envs)
[11:00:14.853]                 common <- intersect(names, old_names)
[11:00:14.853]                 added <- setdiff(names, old_names)
[11:00:14.853]                 removed <- setdiff(old_names, names)
[11:00:14.853]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:14.853]                   envs[common]]
[11:00:14.853]                 NAMES <- toupper(changed)
[11:00:14.853]                 args <- list()
[11:00:14.853]                 for (kk in seq_along(NAMES)) {
[11:00:14.853]                   name <- changed[[kk]]
[11:00:14.853]                   NAME <- NAMES[[kk]]
[11:00:14.853]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:14.853]                     next
[11:00:14.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:14.853]                 }
[11:00:14.853]                 NAMES <- toupper(added)
[11:00:14.853]                 for (kk in seq_along(NAMES)) {
[11:00:14.853]                   name <- added[[kk]]
[11:00:14.853]                   NAME <- NAMES[[kk]]
[11:00:14.853]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:14.853]                     next
[11:00:14.853]                   args[[name]] <- ""
[11:00:14.853]                 }
[11:00:14.853]                 NAMES <- toupper(removed)
[11:00:14.853]                 for (kk in seq_along(NAMES)) {
[11:00:14.853]                   name <- removed[[kk]]
[11:00:14.853]                   NAME <- NAMES[[kk]]
[11:00:14.853]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:14.853]                     next
[11:00:14.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:14.853]                 }
[11:00:14.853]                 if (length(args) > 0) 
[11:00:14.853]                   base::do.call(base::Sys.setenv, args = args)
[11:00:14.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:14.853]             }
[11:00:14.853]             else {
[11:00:14.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:14.853]             }
[11:00:14.853]             {
[11:00:14.853]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:14.853]                   0L) {
[11:00:14.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:14.853]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:14.853]                   base::options(opts)
[11:00:14.853]                 }
[11:00:14.853]                 {
[11:00:14.853]                   {
[11:00:14.853]                     NULL
[11:00:14.853]                     RNGkind("Mersenne-Twister")
[11:00:14.853]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:14.853]                       inherits = FALSE)
[11:00:14.853]                   }
[11:00:14.853]                   options(future.plan = NULL)
[11:00:14.853]                   if (is.na(NA_character_)) 
[11:00:14.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:14.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:14.853]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:14.853]                     .init = FALSE)
[11:00:14.853]                 }
[11:00:14.853]             }
[11:00:14.853]         }
[11:00:14.853]     })
[11:00:14.853]     if (FALSE) {
[11:00:14.853]         base::sink(type = "output", split = FALSE)
[11:00:14.853]         if (NA) {
[11:00:14.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:14.853]         }
[11:00:14.853]         else {
[11:00:14.853]             ...future.result["stdout"] <- base::list(NULL)
[11:00:14.853]         }
[11:00:14.853]         base::close(...future.stdout)
[11:00:14.853]         ...future.stdout <- NULL
[11:00:14.853]     }
[11:00:14.853]     ...future.result$conditions <- ...future.conditions
[11:00:14.853]     ...future.result$finished <- base::Sys.time()
[11:00:14.853]     ...future.result
[11:00:14.853] }
[11:00:14.855] assign_globals() ...
[11:00:14.855] List of 5
[11:00:14.855]  $ ...future.FUN            :function (x)  
[11:00:14.855]  $ future.call.arguments    : list()
[11:00:14.855]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:14.855]  $ ...future.elements_ii    :List of 2
[11:00:14.855]   ..$ : int 1
[11:00:14.855]   ..$ : int 0
[11:00:14.855]  $ ...future.seeds_ii       : NULL
[11:00:14.855]  $ ...future.globals.maxSize: NULL
[11:00:14.855]  - attr(*, "where")=List of 5
[11:00:14.855]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:14.855]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:14.855]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:14.855]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:14.855]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:14.855]  - attr(*, "resolved")= logi FALSE
[11:00:14.855]  - attr(*, "total_size")= num 5632
[11:00:14.855]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:14.855]  - attr(*, "already-done")= logi TRUE
[11:00:14.860] - reassign environment for ‘...future.FUN’
[11:00:14.860] - copied ‘...future.FUN’ to environment
[11:00:14.860] - copied ‘future.call.arguments’ to environment
[11:00:14.860] - copied ‘...future.elements_ii’ to environment
[11:00:14.860] - copied ‘...future.seeds_ii’ to environment
[11:00:14.860] - copied ‘...future.globals.maxSize’ to environment
[11:00:14.860] assign_globals() ... done
[11:00:14.861] plan(): Setting new future strategy stack:
[11:00:14.861] List of future strategies:
[11:00:14.861] 1. sequential:
[11:00:14.861]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:14.861]    - tweaked: FALSE
[11:00:14.861]    - call: NULL
[11:00:14.861] plan(): nbrOfWorkers() = 1
[11:00:15.363] plan(): Setting new future strategy stack:
[11:00:15.363] List of future strategies:
[11:00:15.363] 1. sequential:
[11:00:15.363]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:15.363]    - tweaked: FALSE
[11:00:15.363]    - call: plan(strategy)
[11:00:15.364] plan(): nbrOfWorkers() = 1
[11:00:15.364] SequentialFuture started (and completed)
[11:00:15.364] - Launch lazy future ... done
[11:00:15.364] run() for ‘SequentialFuture’ ... done
[11:00:15.364] Created future:
[11:00:15.364] SequentialFuture:
[11:00:15.364] Label: ‘future_lapply-1’
[11:00:15.364] Expression:
[11:00:15.364] {
[11:00:15.364]     do.call(function(...) {
[11:00:15.364]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:15.364]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:15.364]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:15.364]             on.exit(options(oopts), add = TRUE)
[11:00:15.364]         }
[11:00:15.364]         {
[11:00:15.364]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:15.364]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:15.364]                 ...future.FUN(...future.X_jj, ...)
[11:00:15.364]             })
[11:00:15.364]         }
[11:00:15.364]     }, args = future.call.arguments)
[11:00:15.364] }
[11:00:15.364] Lazy evaluation: FALSE
[11:00:15.364] Asynchronous evaluation: FALSE
[11:00:15.364] Local evaluation: TRUE
[11:00:15.364] Environment: R_GlobalEnv
[11:00:15.364] Capture standard output: NA
[11:00:15.364] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:15.364] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:15.364] Packages: <none>
[11:00:15.364] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:15.364] Resolved: TRUE
[11:00:15.364] Value: 55 bytes of class ‘list’
[11:00:15.364] Early signaling: FALSE
[11:00:15.364] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:15.364] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:15.365] Chunk #1 of 1 ... DONE
[11:00:15.365] Launching 1 futures (chunks) ... DONE
[11:00:15.365] Resolving 1 futures (chunks) ...
[11:00:15.365] resolve() on list ...
[11:00:15.365]  recursive: 0
[11:00:15.365]  length: 1
[11:00:15.366] 
[11:00:15.366] resolved() for ‘SequentialFuture’ ...
[11:00:15.366] - state: ‘finished’
[11:00:15.366] - run: TRUE
[11:00:15.366] - result: ‘FutureResult’
[11:00:15.366] resolved() for ‘SequentialFuture’ ... done
[11:00:15.366] Future #1
[11:00:15.366] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:15.366] - nx: 1
[11:00:15.366] - relay: TRUE
[11:00:15.367] - stdout: TRUE
[11:00:15.367] - signal: TRUE
[11:00:15.367] - resignal: FALSE
[11:00:15.367] - force: TRUE
[11:00:15.367] - relayed: [n=1] FALSE
[11:00:15.367] - queued futures: [n=1] FALSE
[11:00:15.367]  - until=1
[11:00:15.367]  - relaying element #1
[11:00:15.367] - relayed: [n=1] TRUE
[11:00:15.367] - queued futures: [n=1] TRUE
[11:00:15.367] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:15.368]  length: 0 (resolved future 1)
[11:00:15.368] Relaying remaining futures
[11:00:15.368] signalConditionsASAP(NULL, pos=0) ...
[11:00:15.368] - nx: 1
[11:00:15.368] - relay: TRUE
[11:00:15.368] - stdout: TRUE
[11:00:15.368] - signal: TRUE
[11:00:15.368] - resignal: FALSE
[11:00:15.368] - force: TRUE
[11:00:15.368] - relayed: [n=1] TRUE
[11:00:15.368] - queued futures: [n=1] TRUE
 - flush all
[11:00:15.368] - relayed: [n=1] TRUE
[11:00:15.369] - queued futures: [n=1] TRUE
[11:00:15.369] signalConditionsASAP(NULL, pos=0) ... done
[11:00:15.369] resolve() on list ... DONE
[11:00:15.369]  - Number of value chunks collected: 1
[11:00:15.369] Resolving 1 futures (chunks) ... DONE
[11:00:15.369] Reducing values from 1 chunks ...
[11:00:15.369]  - Number of values collected after concatenation: 2
[11:00:15.369]  - Number of values expected: 2
[11:00:15.369] Reducing values from 1 chunks ... DONE
[11:00:15.369] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[11:00:15.370] future_mapply() ...
[11:00:15.370] Number of chunks: 1
[11:00:15.370] getGlobalsAndPackagesXApply() ...
[11:00:15.370]  - future.globals: TRUE
[11:00:15.370] getGlobalsAndPackages() ...
[11:00:15.370] Searching for globals...
[11:00:15.372] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[11:00:15.372] Searching for globals ... DONE
[11:00:15.372] Resolving globals: FALSE
[11:00:15.372] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[11:00:15.373] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[11:00:15.373] - globals: [1] ‘FUN’
[11:00:15.373] 
[11:00:15.373] getGlobalsAndPackages() ... DONE
[11:00:15.373]  - globals found/used: [n=1] ‘FUN’
[11:00:15.373]  - needed namespaces: [n=0] 
[11:00:15.373] Finding globals ... DONE
[11:00:15.373] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[11:00:15.373] List of 2
[11:00:15.373]  $ ...future.FUN:function (x, y)  
[11:00:15.373]  $ MoreArgs     : NULL
[11:00:15.373]  - attr(*, "where")=List of 2
[11:00:15.373]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:15.373]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[11:00:15.373]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:15.373]  - attr(*, "resolved")= logi FALSE
[11:00:15.373]  - attr(*, "total_size")= num NA
[11:00:15.377] Packages to be attached in all futures: [n=0] 
[11:00:15.378] getGlobalsAndPackagesXApply() ... DONE
[11:00:15.378] Number of futures (= number of chunks): 1
[11:00:15.378] Launching 1 futures (chunks) ...
[11:00:15.378] Chunk #1 of 1 ...
[11:00:15.378]  - Finding globals in '...' for chunk #1 ...
[11:00:15.378] getGlobalsAndPackages() ...
[11:00:15.378] Searching for globals...
[11:00:15.378] 
[11:00:15.379] Searching for globals ... DONE
[11:00:15.379] - globals: [0] <none>
[11:00:15.379] getGlobalsAndPackages() ... DONE
[11:00:15.379]    + additional globals found: [n=0] 
[11:00:15.379]    + additional namespaces needed: [n=0] 
[11:00:15.379]  - Finding globals in '...' for chunk #1 ... DONE
[11:00:15.379]  - seeds: <none>
[11:00:15.379]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:15.379] getGlobalsAndPackages() ...
[11:00:15.379] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:15.379] Resolving globals: FALSE
[11:00:15.380] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[11:00:15.380] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[11:00:15.380] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:15.381] 
[11:00:15.381] getGlobalsAndPackages() ... DONE
[11:00:15.381] run() for ‘Future’ ...
[11:00:15.381] - state: ‘created’
[11:00:15.381] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:15.381] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:15.382] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:15.382]   - Field: ‘label’
[11:00:15.382]   - Field: ‘local’
[11:00:15.382]   - Field: ‘owner’
[11:00:15.382]   - Field: ‘envir’
[11:00:15.382]   - Field: ‘packages’
[11:00:15.382]   - Field: ‘gc’
[11:00:15.382]   - Field: ‘conditions’
[11:00:15.382]   - Field: ‘expr’
[11:00:15.382]   - Field: ‘uuid’
[11:00:15.382]   - Field: ‘seed’
[11:00:15.382]   - Field: ‘version’
[11:00:15.383]   - Field: ‘result’
[11:00:15.383]   - Field: ‘asynchronous’
[11:00:15.383]   - Field: ‘calls’
[11:00:15.383]   - Field: ‘globals’
[11:00:15.383]   - Field: ‘stdout’
[11:00:15.383]   - Field: ‘earlySignal’
[11:00:15.383]   - Field: ‘lazy’
[11:00:15.383]   - Field: ‘state’
[11:00:15.383] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:15.383] - Launch lazy future ...
[11:00:15.384] Packages needed by the future expression (n = 0): <none>
[11:00:15.384] Packages needed by future strategies (n = 0): <none>
[11:00:15.384] {
[11:00:15.384]     {
[11:00:15.384]         {
[11:00:15.384]             ...future.startTime <- base::Sys.time()
[11:00:15.384]             {
[11:00:15.384]                 {
[11:00:15.384]                   {
[11:00:15.384]                     base::local({
[11:00:15.384]                       has_future <- base::requireNamespace("future", 
[11:00:15.384]                         quietly = TRUE)
[11:00:15.384]                       if (has_future) {
[11:00:15.384]                         ns <- base::getNamespace("future")
[11:00:15.384]                         version <- ns[[".package"]][["version"]]
[11:00:15.384]                         if (is.null(version)) 
[11:00:15.384]                           version <- utils::packageVersion("future")
[11:00:15.384]                       }
[11:00:15.384]                       else {
[11:00:15.384]                         version <- NULL
[11:00:15.384]                       }
[11:00:15.384]                       if (!has_future || version < "1.8.0") {
[11:00:15.384]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:15.384]                           "", base::R.version$version.string), 
[11:00:15.384]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:15.384]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:15.384]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:15.384]                             "release", "version")], collapse = " "), 
[11:00:15.384]                           hostname = base::Sys.info()[["nodename"]])
[11:00:15.384]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:15.384]                           info)
[11:00:15.384]                         info <- base::paste(info, collapse = "; ")
[11:00:15.384]                         if (!has_future) {
[11:00:15.384]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:15.384]                             info)
[11:00:15.384]                         }
[11:00:15.384]                         else {
[11:00:15.384]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:15.384]                             info, version)
[11:00:15.384]                         }
[11:00:15.384]                         base::stop(msg)
[11:00:15.384]                       }
[11:00:15.384]                     })
[11:00:15.384]                   }
[11:00:15.384]                   ...future.strategy.old <- future::plan("list")
[11:00:15.384]                   options(future.plan = NULL)
[11:00:15.384]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:15.384]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:15.384]                 }
[11:00:15.384]                 ...future.workdir <- getwd()
[11:00:15.384]             }
[11:00:15.384]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:15.384]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:15.384]         }
[11:00:15.384]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:15.384]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:15.384]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:15.384]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:15.384]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:15.384]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:15.384]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:15.384]             base::names(...future.oldOptions))
[11:00:15.384]     }
[11:00:15.384]     if (FALSE) {
[11:00:15.384]     }
[11:00:15.384]     else {
[11:00:15.384]         if (FALSE) {
[11:00:15.384]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:15.384]                 open = "w")
[11:00:15.384]         }
[11:00:15.384]         else {
[11:00:15.384]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:15.384]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:15.384]         }
[11:00:15.384]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:15.384]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:15.384]             base::sink(type = "output", split = FALSE)
[11:00:15.384]             base::close(...future.stdout)
[11:00:15.384]         }, add = TRUE)
[11:00:15.384]     }
[11:00:15.384]     ...future.frame <- base::sys.nframe()
[11:00:15.384]     ...future.conditions <- base::list()
[11:00:15.384]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:15.384]     if (FALSE) {
[11:00:15.384]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:15.384]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:15.384]     }
[11:00:15.384]     ...future.result <- base::tryCatch({
[11:00:15.384]         base::withCallingHandlers({
[11:00:15.384]             ...future.value <- base::withVisible(base::local({
[11:00:15.384]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:15.384]                 if (!identical(...future.globals.maxSize.org, 
[11:00:15.384]                   ...future.globals.maxSize)) {
[11:00:15.384]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:15.384]                   on.exit(options(oopts), add = TRUE)
[11:00:15.384]                 }
[11:00:15.384]                 {
[11:00:15.384]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:15.384]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:00:15.384]                     USE.NAMES = FALSE)
[11:00:15.384]                   do.call(mapply, args = args)
[11:00:15.384]                 }
[11:00:15.384]             }))
[11:00:15.384]             future::FutureResult(value = ...future.value$value, 
[11:00:15.384]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:15.384]                   ...future.rng), globalenv = if (FALSE) 
[11:00:15.384]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:15.384]                     ...future.globalenv.names))
[11:00:15.384]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:15.384]         }, condition = base::local({
[11:00:15.384]             c <- base::c
[11:00:15.384]             inherits <- base::inherits
[11:00:15.384]             invokeRestart <- base::invokeRestart
[11:00:15.384]             length <- base::length
[11:00:15.384]             list <- base::list
[11:00:15.384]             seq.int <- base::seq.int
[11:00:15.384]             signalCondition <- base::signalCondition
[11:00:15.384]             sys.calls <- base::sys.calls
[11:00:15.384]             `[[` <- base::`[[`
[11:00:15.384]             `+` <- base::`+`
[11:00:15.384]             `<<-` <- base::`<<-`
[11:00:15.384]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:15.384]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:15.384]                   3L)]
[11:00:15.384]             }
[11:00:15.384]             function(cond) {
[11:00:15.384]                 is_error <- inherits(cond, "error")
[11:00:15.384]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:15.384]                   NULL)
[11:00:15.384]                 if (is_error) {
[11:00:15.384]                   sessionInformation <- function() {
[11:00:15.384]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:15.384]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:15.384]                       search = base::search(), system = base::Sys.info())
[11:00:15.384]                   }
[11:00:15.384]                   ...future.conditions[[length(...future.conditions) + 
[11:00:15.384]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:15.384]                     cond$call), session = sessionInformation(), 
[11:00:15.384]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:15.384]                   signalCondition(cond)
[11:00:15.384]                 }
[11:00:15.384]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:15.384]                 "immediateCondition"))) {
[11:00:15.384]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:15.384]                   ...future.conditions[[length(...future.conditions) + 
[11:00:15.384]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:15.384]                   if (TRUE && !signal) {
[11:00:15.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:15.384]                     {
[11:00:15.384]                       inherits <- base::inherits
[11:00:15.384]                       invokeRestart <- base::invokeRestart
[11:00:15.384]                       is.null <- base::is.null
[11:00:15.384]                       muffled <- FALSE
[11:00:15.384]                       if (inherits(cond, "message")) {
[11:00:15.384]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:15.384]                         if (muffled) 
[11:00:15.384]                           invokeRestart("muffleMessage")
[11:00:15.384]                       }
[11:00:15.384]                       else if (inherits(cond, "warning")) {
[11:00:15.384]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:15.384]                         if (muffled) 
[11:00:15.384]                           invokeRestart("muffleWarning")
[11:00:15.384]                       }
[11:00:15.384]                       else if (inherits(cond, "condition")) {
[11:00:15.384]                         if (!is.null(pattern)) {
[11:00:15.384]                           computeRestarts <- base::computeRestarts
[11:00:15.384]                           grepl <- base::grepl
[11:00:15.384]                           restarts <- computeRestarts(cond)
[11:00:15.384]                           for (restart in restarts) {
[11:00:15.384]                             name <- restart$name
[11:00:15.384]                             if (is.null(name)) 
[11:00:15.384]                               next
[11:00:15.384]                             if (!grepl(pattern, name)) 
[11:00:15.384]                               next
[11:00:15.384]                             invokeRestart(restart)
[11:00:15.384]                             muffled <- TRUE
[11:00:15.384]                             break
[11:00:15.384]                           }
[11:00:15.384]                         }
[11:00:15.384]                       }
[11:00:15.384]                       invisible(muffled)
[11:00:15.384]                     }
[11:00:15.384]                     muffleCondition(cond, pattern = "^muffle")
[11:00:15.384]                   }
[11:00:15.384]                 }
[11:00:15.384]                 else {
[11:00:15.384]                   if (TRUE) {
[11:00:15.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:15.384]                     {
[11:00:15.384]                       inherits <- base::inherits
[11:00:15.384]                       invokeRestart <- base::invokeRestart
[11:00:15.384]                       is.null <- base::is.null
[11:00:15.384]                       muffled <- FALSE
[11:00:15.384]                       if (inherits(cond, "message")) {
[11:00:15.384]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:15.384]                         if (muffled) 
[11:00:15.384]                           invokeRestart("muffleMessage")
[11:00:15.384]                       }
[11:00:15.384]                       else if (inherits(cond, "warning")) {
[11:00:15.384]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:15.384]                         if (muffled) 
[11:00:15.384]                           invokeRestart("muffleWarning")
[11:00:15.384]                       }
[11:00:15.384]                       else if (inherits(cond, "condition")) {
[11:00:15.384]                         if (!is.null(pattern)) {
[11:00:15.384]                           computeRestarts <- base::computeRestarts
[11:00:15.384]                           grepl <- base::grepl
[11:00:15.384]                           restarts <- computeRestarts(cond)
[11:00:15.384]                           for (restart in restarts) {
[11:00:15.384]                             name <- restart$name
[11:00:15.384]                             if (is.null(name)) 
[11:00:15.384]                               next
[11:00:15.384]                             if (!grepl(pattern, name)) 
[11:00:15.384]                               next
[11:00:15.384]                             invokeRestart(restart)
[11:00:15.384]                             muffled <- TRUE
[11:00:15.384]                             break
[11:00:15.384]                           }
[11:00:15.384]                         }
[11:00:15.384]                       }
[11:00:15.384]                       invisible(muffled)
[11:00:15.384]                     }
[11:00:15.384]                     muffleCondition(cond, pattern = "^muffle")
[11:00:15.384]                   }
[11:00:15.384]                 }
[11:00:15.384]             }
[11:00:15.384]         }))
[11:00:15.384]     }, error = function(ex) {
[11:00:15.384]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:15.384]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:15.384]                 ...future.rng), started = ...future.startTime, 
[11:00:15.384]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:15.384]             version = "1.8"), class = "FutureResult")
[11:00:15.384]     }, finally = {
[11:00:15.384]         if (!identical(...future.workdir, getwd())) 
[11:00:15.384]             setwd(...future.workdir)
[11:00:15.384]         {
[11:00:15.384]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:15.384]                 ...future.oldOptions$nwarnings <- NULL
[11:00:15.384]             }
[11:00:15.384]             base::options(...future.oldOptions)
[11:00:15.384]             if (.Platform$OS.type == "windows") {
[11:00:15.384]                 old_names <- names(...future.oldEnvVars)
[11:00:15.384]                 envs <- base::Sys.getenv()
[11:00:15.384]                 names <- names(envs)
[11:00:15.384]                 common <- intersect(names, old_names)
[11:00:15.384]                 added <- setdiff(names, old_names)
[11:00:15.384]                 removed <- setdiff(old_names, names)
[11:00:15.384]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:15.384]                   envs[common]]
[11:00:15.384]                 NAMES <- toupper(changed)
[11:00:15.384]                 args <- list()
[11:00:15.384]                 for (kk in seq_along(NAMES)) {
[11:00:15.384]                   name <- changed[[kk]]
[11:00:15.384]                   NAME <- NAMES[[kk]]
[11:00:15.384]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:15.384]                     next
[11:00:15.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:15.384]                 }
[11:00:15.384]                 NAMES <- toupper(added)
[11:00:15.384]                 for (kk in seq_along(NAMES)) {
[11:00:15.384]                   name <- added[[kk]]
[11:00:15.384]                   NAME <- NAMES[[kk]]
[11:00:15.384]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:15.384]                     next
[11:00:15.384]                   args[[name]] <- ""
[11:00:15.384]                 }
[11:00:15.384]                 NAMES <- toupper(removed)
[11:00:15.384]                 for (kk in seq_along(NAMES)) {
[11:00:15.384]                   name <- removed[[kk]]
[11:00:15.384]                   NAME <- NAMES[[kk]]
[11:00:15.384]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:15.384]                     next
[11:00:15.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:15.384]                 }
[11:00:15.384]                 if (length(args) > 0) 
[11:00:15.384]                   base::do.call(base::Sys.setenv, args = args)
[11:00:15.384]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:15.384]             }
[11:00:15.384]             else {
[11:00:15.384]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:15.384]             }
[11:00:15.384]             {
[11:00:15.384]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:15.384]                   0L) {
[11:00:15.384]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:15.384]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:15.384]                   base::options(opts)
[11:00:15.384]                 }
[11:00:15.384]                 {
[11:00:15.384]                   {
[11:00:15.384]                     NULL
[11:00:15.384]                     RNGkind("Mersenne-Twister")
[11:00:15.384]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:15.384]                       inherits = FALSE)
[11:00:15.384]                   }
[11:00:15.384]                   options(future.plan = NULL)
[11:00:15.384]                   if (is.na(NA_character_)) 
[11:00:15.384]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:15.384]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:15.384]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:15.384]                     .init = FALSE)
[11:00:15.384]                 }
[11:00:15.384]             }
[11:00:15.384]         }
[11:00:15.384]     })
[11:00:15.384]     if (TRUE) {
[11:00:15.384]         base::sink(type = "output", split = FALSE)
[11:00:15.384]         if (FALSE) {
[11:00:15.384]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:15.384]         }
[11:00:15.384]         else {
[11:00:15.384]             ...future.result["stdout"] <- base::list(NULL)
[11:00:15.384]         }
[11:00:15.384]         base::close(...future.stdout)
[11:00:15.384]         ...future.stdout <- NULL
[11:00:15.384]     }
[11:00:15.384]     ...future.result$conditions <- ...future.conditions
[11:00:15.384]     ...future.result$finished <- base::Sys.time()
[11:00:15.384]     ...future.result
[11:00:15.384] }
[11:00:15.386] assign_globals() ...
[11:00:15.386] List of 5
[11:00:15.386]  $ ...future.FUN            :function (x, y)  
[11:00:15.386]  $ MoreArgs                 : NULL
[11:00:15.386]  $ ...future.elements_ii    :List of 2
[11:00:15.386]   ..$ :List of 2
[11:00:15.386]   .. ..$ : int 1
[11:00:15.386]   .. ..$ : int 0
[11:00:15.386]   ..$ :List of 2
[11:00:15.386]   .. ..$ : int 0
[11:00:15.386]   .. ..$ : int 1
[11:00:15.386]  $ ...future.seeds_ii       : NULL
[11:00:15.386]  $ ...future.globals.maxSize: NULL
[11:00:15.386]  - attr(*, "where")=List of 5
[11:00:15.386]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:15.386]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[11:00:15.386]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:15.386]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:15.386]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:15.386]  - attr(*, "resolved")= logi FALSE
[11:00:15.386]  - attr(*, "total_size")= num 1242
[11:00:15.386]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:15.386]  - attr(*, "already-done")= logi TRUE
[11:00:15.391] - reassign environment for ‘...future.FUN’
[11:00:15.391] - copied ‘...future.FUN’ to environment
[11:00:15.391] - copied ‘MoreArgs’ to environment
[11:00:15.391] - copied ‘...future.elements_ii’ to environment
[11:00:15.391] - copied ‘...future.seeds_ii’ to environment
[11:00:15.392] - copied ‘...future.globals.maxSize’ to environment
[11:00:15.392] assign_globals() ... done
[11:00:15.392] plan(): Setting new future strategy stack:
[11:00:15.392] List of future strategies:
[11:00:15.392] 1. sequential:
[11:00:15.392]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:15.392]    - tweaked: FALSE
[11:00:15.392]    - call: NULL
[11:00:15.392] plan(): nbrOfWorkers() = 1
[11:00:15.894] plan(): Setting new future strategy stack:
[11:00:15.894] List of future strategies:
[11:00:15.894] 1. sequential:
[11:00:15.894]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:15.894]    - tweaked: FALSE
[11:00:15.894]    - call: plan(strategy)
[11:00:15.895] plan(): nbrOfWorkers() = 1
[11:00:15.895] SequentialFuture started (and completed)
[11:00:15.895] - Launch lazy future ... done
[11:00:15.895] run() for ‘SequentialFuture’ ... done
[11:00:15.895] Created future:
[11:00:15.896] SequentialFuture:
[11:00:15.896] Label: ‘future_mapply-1’
[11:00:15.896] Expression:
[11:00:15.896] {
[11:00:15.896]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:15.896]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:15.896]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:15.896]         on.exit(options(oopts), add = TRUE)
[11:00:15.896]     }
[11:00:15.896]     {
[11:00:15.896]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:15.896]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:00:15.896]         do.call(mapply, args = args)
[11:00:15.896]     }
[11:00:15.896] }
[11:00:15.896] Lazy evaluation: FALSE
[11:00:15.896] Asynchronous evaluation: FALSE
[11:00:15.896] Local evaluation: TRUE
[11:00:15.896] Environment: R_GlobalEnv
[11:00:15.896] Capture standard output: FALSE
[11:00:15.896] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:15.896] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:15.896] Packages: <none>
[11:00:15.896] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:15.896] Resolved: TRUE
[11:00:15.896] Value: 184 bytes of class ‘list’
[11:00:15.896] Early signaling: FALSE
[11:00:15.896] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:15.896] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:15.896] Chunk #1 of 1 ... DONE
[11:00:15.896] Launching 1 futures (chunks) ... DONE
[11:00:15.897] Resolving 1 futures (chunks) ...
[11:00:15.897] resolve() on list ...
[11:00:15.897]  recursive: 0
[11:00:15.897]  length: 1
[11:00:15.897] 
[11:00:15.897] resolved() for ‘SequentialFuture’ ...
[11:00:15.897] - state: ‘finished’
[11:00:15.897] - run: TRUE
[11:00:15.897] - result: ‘FutureResult’
[11:00:15.897] resolved() for ‘SequentialFuture’ ... done
[11:00:15.897] Future #1
[11:00:15.898] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:15.898] - nx: 1
[11:00:15.898] - relay: TRUE
[11:00:15.898] - stdout: TRUE
[11:00:15.898] - signal: TRUE
[11:00:15.898] - resignal: FALSE
[11:00:15.898] - force: TRUE
[11:00:15.898] - relayed: [n=1] FALSE
[11:00:15.898] - queued futures: [n=1] FALSE
[11:00:15.898]  - until=1
[11:00:15.898]  - relaying element #1
[11:00:15.899] - relayed: [n=1] TRUE
[11:00:15.899] - queued futures: [n=1] TRUE
[11:00:15.899] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:15.899]  length: 0 (resolved future 1)
[11:00:15.899] Relaying remaining futures
[11:00:15.899] signalConditionsASAP(NULL, pos=0) ...
[11:00:15.899] - nx: 1
[11:00:15.899] - relay: TRUE
[11:00:15.899] - stdout: TRUE
[11:00:15.899] - signal: TRUE
[11:00:15.899] - resignal: FALSE
[11:00:15.899] - force: TRUE
[11:00:15.900] - relayed: [n=1] TRUE
[11:00:15.900] - queued futures: [n=1] TRUE
 - flush all
[11:00:15.900] - relayed: [n=1] TRUE
[11:00:15.900] - queued futures: [n=1] TRUE
[11:00:15.900] signalConditionsASAP(NULL, pos=0) ... done
[11:00:15.900] resolve() on list ... DONE
[11:00:15.900]  - Number of value chunks collected: 1
[11:00:15.900] Resolving 1 futures (chunks) ... DONE
[11:00:15.900] Reducing values from 1 chunks ...
[11:00:15.900]  - Number of values collected after concatenation: 2
[11:00:15.900]  - Number of values expected: 2
[11:00:15.901] Reducing values from 1 chunks ... DONE
[11:00:15.901] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[11:00:15.903] future_mapply() ...
[11:00:15.903] Number of chunks: 1
[11:00:15.903] getGlobalsAndPackagesXApply() ...
[11:00:15.903]  - future.globals: TRUE
[11:00:15.903] getGlobalsAndPackages() ...
[11:00:15.903] Searching for globals...
[11:00:15.905] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[11:00:15.905] Searching for globals ... DONE
[11:00:15.905] Resolving globals: FALSE
[11:00:15.905] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[11:00:15.906] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[11:00:15.906] - globals: [1] ‘FUN’
[11:00:15.906] 
[11:00:15.906] getGlobalsAndPackages() ... DONE
[11:00:15.906]  - globals found/used: [n=1] ‘FUN’
[11:00:15.906]  - needed namespaces: [n=0] 
[11:00:15.906] Finding globals ... DONE
[11:00:15.906] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[11:00:15.906] List of 2
[11:00:15.906]  $ ...future.FUN:function (x, y)  
[11:00:15.906]  $ MoreArgs     : NULL
[11:00:15.906]  - attr(*, "where")=List of 2
[11:00:15.906]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:15.906]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[11:00:15.906]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:15.906]  - attr(*, "resolved")= logi FALSE
[11:00:15.906]  - attr(*, "total_size")= num NA
[11:00:15.909] Packages to be attached in all futures: [n=0] 
[11:00:15.909] getGlobalsAndPackagesXApply() ... DONE
[11:00:15.909] Number of futures (= number of chunks): 1
[11:00:15.909] Launching 1 futures (chunks) ...
[11:00:15.909] Chunk #1 of 1 ...
[11:00:15.909]  - Finding globals in '...' for chunk #1 ...
[11:00:15.909] getGlobalsAndPackages() ...
[11:00:15.910] Searching for globals...
[11:00:15.910] 
[11:00:15.910] Searching for globals ... DONE
[11:00:15.910] - globals: [0] <none>
[11:00:15.910] getGlobalsAndPackages() ... DONE
[11:00:15.910]    + additional globals found: [n=0] 
[11:00:15.910]    + additional namespaces needed: [n=0] 
[11:00:15.910]  - Finding globals in '...' for chunk #1 ... DONE
[11:00:15.910]  - seeds: <none>
[11:00:15.911]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:15.911] getGlobalsAndPackages() ...
[11:00:15.911] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:15.911] Resolving globals: FALSE
[11:00:15.911] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[11:00:15.912] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[11:00:15.912] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:15.912] 
[11:00:15.912] getGlobalsAndPackages() ... DONE
[11:00:15.912] run() for ‘Future’ ...
[11:00:15.912] - state: ‘created’
[11:00:15.912] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:15.913] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:15.913] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:15.913]   - Field: ‘label’
[11:00:15.913]   - Field: ‘local’
[11:00:15.913]   - Field: ‘owner’
[11:00:15.913]   - Field: ‘envir’
[11:00:15.913]   - Field: ‘packages’
[11:00:15.913]   - Field: ‘gc’
[11:00:15.913]   - Field: ‘conditions’
[11:00:15.914]   - Field: ‘expr’
[11:00:15.914]   - Field: ‘uuid’
[11:00:15.914]   - Field: ‘seed’
[11:00:15.914]   - Field: ‘version’
[11:00:15.914]   - Field: ‘result’
[11:00:15.914]   - Field: ‘asynchronous’
[11:00:15.914]   - Field: ‘calls’
[11:00:15.914]   - Field: ‘globals’
[11:00:15.914]   - Field: ‘stdout’
[11:00:15.914]   - Field: ‘earlySignal’
[11:00:15.914]   - Field: ‘lazy’
[11:00:15.914]   - Field: ‘state’
[11:00:15.915] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:15.915] - Launch lazy future ...
[11:00:15.915] Packages needed by the future expression (n = 0): <none>
[11:00:15.915] Packages needed by future strategies (n = 0): <none>
[11:00:15.915] {
[11:00:15.915]     {
[11:00:15.915]         {
[11:00:15.915]             ...future.startTime <- base::Sys.time()
[11:00:15.915]             {
[11:00:15.915]                 {
[11:00:15.915]                   {
[11:00:15.915]                     base::local({
[11:00:15.915]                       has_future <- base::requireNamespace("future", 
[11:00:15.915]                         quietly = TRUE)
[11:00:15.915]                       if (has_future) {
[11:00:15.915]                         ns <- base::getNamespace("future")
[11:00:15.915]                         version <- ns[[".package"]][["version"]]
[11:00:15.915]                         if (is.null(version)) 
[11:00:15.915]                           version <- utils::packageVersion("future")
[11:00:15.915]                       }
[11:00:15.915]                       else {
[11:00:15.915]                         version <- NULL
[11:00:15.915]                       }
[11:00:15.915]                       if (!has_future || version < "1.8.0") {
[11:00:15.915]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:15.915]                           "", base::R.version$version.string), 
[11:00:15.915]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:15.915]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:15.915]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:15.915]                             "release", "version")], collapse = " "), 
[11:00:15.915]                           hostname = base::Sys.info()[["nodename"]])
[11:00:15.915]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:15.915]                           info)
[11:00:15.915]                         info <- base::paste(info, collapse = "; ")
[11:00:15.915]                         if (!has_future) {
[11:00:15.915]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:15.915]                             info)
[11:00:15.915]                         }
[11:00:15.915]                         else {
[11:00:15.915]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:15.915]                             info, version)
[11:00:15.915]                         }
[11:00:15.915]                         base::stop(msg)
[11:00:15.915]                       }
[11:00:15.915]                     })
[11:00:15.915]                   }
[11:00:15.915]                   ...future.strategy.old <- future::plan("list")
[11:00:15.915]                   options(future.plan = NULL)
[11:00:15.915]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:15.915]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:15.915]                 }
[11:00:15.915]                 ...future.workdir <- getwd()
[11:00:15.915]             }
[11:00:15.915]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:15.915]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:15.915]         }
[11:00:15.915]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:15.915]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:15.915]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:15.915]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:15.915]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:15.915]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:15.915]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:15.915]             base::names(...future.oldOptions))
[11:00:15.915]     }
[11:00:15.915]     if (FALSE) {
[11:00:15.915]     }
[11:00:15.915]     else {
[11:00:15.915]         if (TRUE) {
[11:00:15.915]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:15.915]                 open = "w")
[11:00:15.915]         }
[11:00:15.915]         else {
[11:00:15.915]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:15.915]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:15.915]         }
[11:00:15.915]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:15.915]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:15.915]             base::sink(type = "output", split = FALSE)
[11:00:15.915]             base::close(...future.stdout)
[11:00:15.915]         }, add = TRUE)
[11:00:15.915]     }
[11:00:15.915]     ...future.frame <- base::sys.nframe()
[11:00:15.915]     ...future.conditions <- base::list()
[11:00:15.915]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:15.915]     if (FALSE) {
[11:00:15.915]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:15.915]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:15.915]     }
[11:00:15.915]     ...future.result <- base::tryCatch({
[11:00:15.915]         base::withCallingHandlers({
[11:00:15.915]             ...future.value <- base::withVisible(base::local({
[11:00:15.915]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:15.915]                 if (!identical(...future.globals.maxSize.org, 
[11:00:15.915]                   ...future.globals.maxSize)) {
[11:00:15.915]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:15.915]                   on.exit(options(oopts), add = TRUE)
[11:00:15.915]                 }
[11:00:15.915]                 {
[11:00:15.915]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:15.915]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:00:15.915]                     USE.NAMES = FALSE)
[11:00:15.915]                   do.call(mapply, args = args)
[11:00:15.915]                 }
[11:00:15.915]             }))
[11:00:15.915]             future::FutureResult(value = ...future.value$value, 
[11:00:15.915]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:15.915]                   ...future.rng), globalenv = if (FALSE) 
[11:00:15.915]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:15.915]                     ...future.globalenv.names))
[11:00:15.915]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:15.915]         }, condition = base::local({
[11:00:15.915]             c <- base::c
[11:00:15.915]             inherits <- base::inherits
[11:00:15.915]             invokeRestart <- base::invokeRestart
[11:00:15.915]             length <- base::length
[11:00:15.915]             list <- base::list
[11:00:15.915]             seq.int <- base::seq.int
[11:00:15.915]             signalCondition <- base::signalCondition
[11:00:15.915]             sys.calls <- base::sys.calls
[11:00:15.915]             `[[` <- base::`[[`
[11:00:15.915]             `+` <- base::`+`
[11:00:15.915]             `<<-` <- base::`<<-`
[11:00:15.915]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:15.915]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:15.915]                   3L)]
[11:00:15.915]             }
[11:00:15.915]             function(cond) {
[11:00:15.915]                 is_error <- inherits(cond, "error")
[11:00:15.915]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:15.915]                   NULL)
[11:00:15.915]                 if (is_error) {
[11:00:15.915]                   sessionInformation <- function() {
[11:00:15.915]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:15.915]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:15.915]                       search = base::search(), system = base::Sys.info())
[11:00:15.915]                   }
[11:00:15.915]                   ...future.conditions[[length(...future.conditions) + 
[11:00:15.915]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:15.915]                     cond$call), session = sessionInformation(), 
[11:00:15.915]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:15.915]                   signalCondition(cond)
[11:00:15.915]                 }
[11:00:15.915]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:15.915]                 "immediateCondition"))) {
[11:00:15.915]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:15.915]                   ...future.conditions[[length(...future.conditions) + 
[11:00:15.915]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:15.915]                   if (TRUE && !signal) {
[11:00:15.915]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:15.915]                     {
[11:00:15.915]                       inherits <- base::inherits
[11:00:15.915]                       invokeRestart <- base::invokeRestart
[11:00:15.915]                       is.null <- base::is.null
[11:00:15.915]                       muffled <- FALSE
[11:00:15.915]                       if (inherits(cond, "message")) {
[11:00:15.915]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:15.915]                         if (muffled) 
[11:00:15.915]                           invokeRestart("muffleMessage")
[11:00:15.915]                       }
[11:00:15.915]                       else if (inherits(cond, "warning")) {
[11:00:15.915]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:15.915]                         if (muffled) 
[11:00:15.915]                           invokeRestart("muffleWarning")
[11:00:15.915]                       }
[11:00:15.915]                       else if (inherits(cond, "condition")) {
[11:00:15.915]                         if (!is.null(pattern)) {
[11:00:15.915]                           computeRestarts <- base::computeRestarts
[11:00:15.915]                           grepl <- base::grepl
[11:00:15.915]                           restarts <- computeRestarts(cond)
[11:00:15.915]                           for (restart in restarts) {
[11:00:15.915]                             name <- restart$name
[11:00:15.915]                             if (is.null(name)) 
[11:00:15.915]                               next
[11:00:15.915]                             if (!grepl(pattern, name)) 
[11:00:15.915]                               next
[11:00:15.915]                             invokeRestart(restart)
[11:00:15.915]                             muffled <- TRUE
[11:00:15.915]                             break
[11:00:15.915]                           }
[11:00:15.915]                         }
[11:00:15.915]                       }
[11:00:15.915]                       invisible(muffled)
[11:00:15.915]                     }
[11:00:15.915]                     muffleCondition(cond, pattern = "^muffle")
[11:00:15.915]                   }
[11:00:15.915]                 }
[11:00:15.915]                 else {
[11:00:15.915]                   if (TRUE) {
[11:00:15.915]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:15.915]                     {
[11:00:15.915]                       inherits <- base::inherits
[11:00:15.915]                       invokeRestart <- base::invokeRestart
[11:00:15.915]                       is.null <- base::is.null
[11:00:15.915]                       muffled <- FALSE
[11:00:15.915]                       if (inherits(cond, "message")) {
[11:00:15.915]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:15.915]                         if (muffled) 
[11:00:15.915]                           invokeRestart("muffleMessage")
[11:00:15.915]                       }
[11:00:15.915]                       else if (inherits(cond, "warning")) {
[11:00:15.915]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:15.915]                         if (muffled) 
[11:00:15.915]                           invokeRestart("muffleWarning")
[11:00:15.915]                       }
[11:00:15.915]                       else if (inherits(cond, "condition")) {
[11:00:15.915]                         if (!is.null(pattern)) {
[11:00:15.915]                           computeRestarts <- base::computeRestarts
[11:00:15.915]                           grepl <- base::grepl
[11:00:15.915]                           restarts <- computeRestarts(cond)
[11:00:15.915]                           for (restart in restarts) {
[11:00:15.915]                             name <- restart$name
[11:00:15.915]                             if (is.null(name)) 
[11:00:15.915]                               next
[11:00:15.915]                             if (!grepl(pattern, name)) 
[11:00:15.915]                               next
[11:00:15.915]                             invokeRestart(restart)
[11:00:15.915]                             muffled <- TRUE
[11:00:15.915]                             break
[11:00:15.915]                           }
[11:00:15.915]                         }
[11:00:15.915]                       }
[11:00:15.915]                       invisible(muffled)
[11:00:15.915]                     }
[11:00:15.915]                     muffleCondition(cond, pattern = "^muffle")
[11:00:15.915]                   }
[11:00:15.915]                 }
[11:00:15.915]             }
[11:00:15.915]         }))
[11:00:15.915]     }, error = function(ex) {
[11:00:15.915]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:15.915]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:15.915]                 ...future.rng), started = ...future.startTime, 
[11:00:15.915]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:15.915]             version = "1.8"), class = "FutureResult")
[11:00:15.915]     }, finally = {
[11:00:15.915]         if (!identical(...future.workdir, getwd())) 
[11:00:15.915]             setwd(...future.workdir)
[11:00:15.915]         {
[11:00:15.915]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:15.915]                 ...future.oldOptions$nwarnings <- NULL
[11:00:15.915]             }
[11:00:15.915]             base::options(...future.oldOptions)
[11:00:15.915]             if (.Platform$OS.type == "windows") {
[11:00:15.915]                 old_names <- names(...future.oldEnvVars)
[11:00:15.915]                 envs <- base::Sys.getenv()
[11:00:15.915]                 names <- names(envs)
[11:00:15.915]                 common <- intersect(names, old_names)
[11:00:15.915]                 added <- setdiff(names, old_names)
[11:00:15.915]                 removed <- setdiff(old_names, names)
[11:00:15.915]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:15.915]                   envs[common]]
[11:00:15.915]                 NAMES <- toupper(changed)
[11:00:15.915]                 args <- list()
[11:00:15.915]                 for (kk in seq_along(NAMES)) {
[11:00:15.915]                   name <- changed[[kk]]
[11:00:15.915]                   NAME <- NAMES[[kk]]
[11:00:15.915]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:15.915]                     next
[11:00:15.915]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:15.915]                 }
[11:00:15.915]                 NAMES <- toupper(added)
[11:00:15.915]                 for (kk in seq_along(NAMES)) {
[11:00:15.915]                   name <- added[[kk]]
[11:00:15.915]                   NAME <- NAMES[[kk]]
[11:00:15.915]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:15.915]                     next
[11:00:15.915]                   args[[name]] <- ""
[11:00:15.915]                 }
[11:00:15.915]                 NAMES <- toupper(removed)
[11:00:15.915]                 for (kk in seq_along(NAMES)) {
[11:00:15.915]                   name <- removed[[kk]]
[11:00:15.915]                   NAME <- NAMES[[kk]]
[11:00:15.915]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:15.915]                     next
[11:00:15.915]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:15.915]                 }
[11:00:15.915]                 if (length(args) > 0) 
[11:00:15.915]                   base::do.call(base::Sys.setenv, args = args)
[11:00:15.915]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:15.915]             }
[11:00:15.915]             else {
[11:00:15.915]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:15.915]             }
[11:00:15.915]             {
[11:00:15.915]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:15.915]                   0L) {
[11:00:15.915]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:15.915]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:15.915]                   base::options(opts)
[11:00:15.915]                 }
[11:00:15.915]                 {
[11:00:15.915]                   {
[11:00:15.915]                     NULL
[11:00:15.915]                     RNGkind("Mersenne-Twister")
[11:00:15.915]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:15.915]                       inherits = FALSE)
[11:00:15.915]                   }
[11:00:15.915]                   options(future.plan = NULL)
[11:00:15.915]                   if (is.na(NA_character_)) 
[11:00:15.915]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:15.915]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:15.915]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:15.915]                     .init = FALSE)
[11:00:15.915]                 }
[11:00:15.915]             }
[11:00:15.915]         }
[11:00:15.915]     })
[11:00:15.915]     if (TRUE) {
[11:00:15.915]         base::sink(type = "output", split = FALSE)
[11:00:15.915]         if (TRUE) {
[11:00:15.915]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:15.915]         }
[11:00:15.915]         else {
[11:00:15.915]             ...future.result["stdout"] <- base::list(NULL)
[11:00:15.915]         }
[11:00:15.915]         base::close(...future.stdout)
[11:00:15.915]         ...future.stdout <- NULL
[11:00:15.915]     }
[11:00:15.915]     ...future.result$conditions <- ...future.conditions
[11:00:15.915]     ...future.result$finished <- base::Sys.time()
[11:00:15.915]     ...future.result
[11:00:15.915] }
[11:00:15.917] assign_globals() ...
[11:00:15.917] List of 5
[11:00:15.917]  $ ...future.FUN            :function (x, y)  
[11:00:15.917]  $ MoreArgs                 : NULL
[11:00:15.917]  $ ...future.elements_ii    :List of 2
[11:00:15.917]   ..$ :List of 2
[11:00:15.917]   .. ..$ : int 1
[11:00:15.917]   .. ..$ : int 0
[11:00:15.917]   ..$ :List of 2
[11:00:15.917]   .. ..$ : int 0
[11:00:15.917]   .. ..$ : int 1
[11:00:15.917]  $ ...future.seeds_ii       : NULL
[11:00:15.917]  $ ...future.globals.maxSize: NULL
[11:00:15.917]  - attr(*, "where")=List of 5
[11:00:15.917]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:15.917]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[11:00:15.917]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:15.917]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:15.917]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:15.917]  - attr(*, "resolved")= logi FALSE
[11:00:15.917]  - attr(*, "total_size")= num 1242
[11:00:15.917]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:15.917]  - attr(*, "already-done")= logi TRUE
[11:00:15.922] - reassign environment for ‘...future.FUN’
[11:00:15.922] - copied ‘...future.FUN’ to environment
[11:00:15.923] - copied ‘MoreArgs’ to environment
[11:00:15.923] - copied ‘...future.elements_ii’ to environment
[11:00:15.923] - copied ‘...future.seeds_ii’ to environment
[11:00:15.923] - copied ‘...future.globals.maxSize’ to environment
[11:00:15.923] assign_globals() ... done
[11:00:15.923] plan(): Setting new future strategy stack:
[11:00:15.923] List of future strategies:
[11:00:15.923] 1. sequential:
[11:00:15.923]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:15.923]    - tweaked: FALSE
[11:00:15.923]    - call: NULL
[11:00:15.924] plan(): nbrOfWorkers() = 1
[11:00:16.425] plan(): Setting new future strategy stack:
[11:00:16.425] List of future strategies:
[11:00:16.425] 1. sequential:
[11:00:16.425]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:16.425]    - tweaked: FALSE
[11:00:16.425]    - call: plan(strategy)
[11:00:16.426] plan(): nbrOfWorkers() = 1
[11:00:16.426] SequentialFuture started (and completed)
[11:00:16.426] - Launch lazy future ... done
[11:00:16.426] run() for ‘SequentialFuture’ ... done
[11:00:16.427] Created future:
[11:00:16.428] SequentialFuture:
[11:00:16.428] Label: ‘future_mapply-1’
[11:00:16.428] Expression:
[11:00:16.428] {
[11:00:16.428]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:16.428]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:16.428]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:16.428]         on.exit(options(oopts), add = TRUE)
[11:00:16.428]     }
[11:00:16.428]     {
[11:00:16.428]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:16.428]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:00:16.428]         do.call(mapply, args = args)
[11:00:16.428]     }
[11:00:16.428] }
[11:00:16.428] Lazy evaluation: FALSE
[11:00:16.428] Asynchronous evaluation: FALSE
[11:00:16.428] Local evaluation: TRUE
[11:00:16.428] Environment: R_GlobalEnv
[11:00:16.428] Capture standard output: TRUE
[11:00:16.428] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:16.428] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:16.428] Packages: <none>
[11:00:16.428] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:16.428] Resolved: TRUE
[11:00:16.428] Value: 184 bytes of class ‘list’
[11:00:16.428] Early signaling: FALSE
[11:00:16.428] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:16.428] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:16.429] Chunk #1 of 1 ... DONE
[11:00:16.429] Launching 1 futures (chunks) ... DONE
[11:00:16.429] Resolving 1 futures (chunks) ...
[11:00:16.429] resolve() on list ...
[11:00:16.429]  recursive: 0
[11:00:16.430]  length: 1
[11:00:16.430] 
[11:00:16.430] resolved() for ‘SequentialFuture’ ...
[11:00:16.430] - state: ‘finished’
[11:00:16.430] - run: TRUE
[11:00:16.430] - result: ‘FutureResult’
[11:00:16.430] resolved() for ‘SequentialFuture’ ... done
[11:00:16.430] Future #1
[11:00:16.430] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:16.430] - nx: 1
[11:00:16.431] - relay: TRUE
[11:00:16.431] - stdout: TRUE
[11:00:16.431] - signal: TRUE
[11:00:16.431] - resignal: FALSE
[11:00:16.431] - force: TRUE
[11:00:16.431] - relayed: [n=1] FALSE
[11:00:16.431] - queued futures: [n=1] FALSE
[11:00:16.431]  - until=1
[11:00:16.431]  - relaying element #1
[11:00:16.431] - relayed: [n=1] TRUE
[11:00:16.431] - queued futures: [n=1] TRUE
[11:00:16.432] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:16.432]  length: 0 (resolved future 1)
[11:00:16.432] Relaying remaining futures
[11:00:16.432] signalConditionsASAP(NULL, pos=0) ...
[11:00:16.432] - nx: 1
[11:00:16.432] - relay: TRUE
[11:00:16.432] - stdout: TRUE
[11:00:16.432] - signal: TRUE
[11:00:16.432] - resignal: FALSE
[11:00:16.432] - force: TRUE
[11:00:16.432] - relayed: [n=1] TRUE
[11:00:16.432] - queued futures: [n=1] TRUE
 - flush all
[11:00:16.433] - relayed: [n=1] TRUE
[11:00:16.433] - queued futures: [n=1] TRUE
[11:00:16.433] signalConditionsASAP(NULL, pos=0) ... done
[11:00:16.433] resolve() on list ... DONE
[11:00:16.433]  - Number of value chunks collected: 1
[11:00:16.433] Resolving 1 futures (chunks) ... DONE
[11:00:16.433] Reducing values from 1 chunks ...
[11:00:16.433]  - Number of values collected after concatenation: 2
[11:00:16.433]  - Number of values expected: 2
[11:00:16.433] Reducing values from 1 chunks ... DONE
[11:00:16.433] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[11:00:16.434] future_mapply() ...
[11:00:16.434] Number of chunks: 1
[11:00:16.434] getGlobalsAndPackagesXApply() ...
[11:00:16.434]  - future.globals: TRUE
[11:00:16.434] getGlobalsAndPackages() ...
[11:00:16.434] Searching for globals...
[11:00:16.436] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[11:00:16.436] Searching for globals ... DONE
[11:00:16.436] Resolving globals: FALSE
[11:00:16.436] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[11:00:16.437] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[11:00:16.437] - globals: [1] ‘FUN’
[11:00:16.437] 
[11:00:16.437] getGlobalsAndPackages() ... DONE
[11:00:16.437]  - globals found/used: [n=1] ‘FUN’
[11:00:16.437]  - needed namespaces: [n=0] 
[11:00:16.437] Finding globals ... DONE
[11:00:16.438] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[11:00:16.438] List of 2
[11:00:16.438]  $ ...future.FUN:function (x, y)  
[11:00:16.438]  $ MoreArgs     : NULL
[11:00:16.438]  - attr(*, "where")=List of 2
[11:00:16.438]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:16.438]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[11:00:16.438]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:16.438]  - attr(*, "resolved")= logi FALSE
[11:00:16.438]  - attr(*, "total_size")= num NA
[11:00:16.440] Packages to be attached in all futures: [n=0] 
[11:00:16.440] getGlobalsAndPackagesXApply() ... DONE
[11:00:16.440] Number of futures (= number of chunks): 1
[11:00:16.440] Launching 1 futures (chunks) ...
[11:00:16.441] Chunk #1 of 1 ...
[11:00:16.441]  - Finding globals in '...' for chunk #1 ...
[11:00:16.441] getGlobalsAndPackages() ...
[11:00:16.441] Searching for globals...
[11:00:16.441] 
[11:00:16.441] Searching for globals ... DONE
[11:00:16.441] - globals: [0] <none>
[11:00:16.441] getGlobalsAndPackages() ... DONE
[11:00:16.441]    + additional globals found: [n=0] 
[11:00:16.442]    + additional namespaces needed: [n=0] 
[11:00:16.442]  - Finding globals in '...' for chunk #1 ... DONE
[11:00:16.442]  - seeds: <none>
[11:00:16.442]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:16.442] getGlobalsAndPackages() ...
[11:00:16.442] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:16.442] Resolving globals: FALSE
[11:00:16.442] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[11:00:16.443] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[11:00:16.443] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:16.443] 
[11:00:16.443] getGlobalsAndPackages() ... DONE
[11:00:16.443] run() for ‘Future’ ...
[11:00:16.444] - state: ‘created’
[11:00:16.444] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:00:16.444] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:16.444] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:16.444]   - Field: ‘label’
[11:00:16.444]   - Field: ‘local’
[11:00:16.444]   - Field: ‘owner’
[11:00:16.444]   - Field: ‘envir’
[11:00:16.445]   - Field: ‘packages’
[11:00:16.445]   - Field: ‘gc’
[11:00:16.445]   - Field: ‘conditions’
[11:00:16.445]   - Field: ‘expr’
[11:00:16.445]   - Field: ‘uuid’
[11:00:16.445]   - Field: ‘seed’
[11:00:16.445]   - Field: ‘version’
[11:00:16.445]   - Field: ‘result’
[11:00:16.445]   - Field: ‘asynchronous’
[11:00:16.445]   - Field: ‘calls’
[11:00:16.445]   - Field: ‘globals’
[11:00:16.445]   - Field: ‘stdout’
[11:00:16.446]   - Field: ‘earlySignal’
[11:00:16.446]   - Field: ‘lazy’
[11:00:16.446]   - Field: ‘state’
[11:00:16.446] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:16.446] - Launch lazy future ...
[11:00:16.446] Packages needed by the future expression (n = 0): <none>
[11:00:16.446] Packages needed by future strategies (n = 0): <none>
[11:00:16.447] {
[11:00:16.447]     {
[11:00:16.447]         {
[11:00:16.447]             ...future.startTime <- base::Sys.time()
[11:00:16.447]             {
[11:00:16.447]                 {
[11:00:16.447]                   {
[11:00:16.447]                     base::local({
[11:00:16.447]                       has_future <- base::requireNamespace("future", 
[11:00:16.447]                         quietly = TRUE)
[11:00:16.447]                       if (has_future) {
[11:00:16.447]                         ns <- base::getNamespace("future")
[11:00:16.447]                         version <- ns[[".package"]][["version"]]
[11:00:16.447]                         if (is.null(version)) 
[11:00:16.447]                           version <- utils::packageVersion("future")
[11:00:16.447]                       }
[11:00:16.447]                       else {
[11:00:16.447]                         version <- NULL
[11:00:16.447]                       }
[11:00:16.447]                       if (!has_future || version < "1.8.0") {
[11:00:16.447]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:16.447]                           "", base::R.version$version.string), 
[11:00:16.447]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:16.447]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:16.447]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:16.447]                             "release", "version")], collapse = " "), 
[11:00:16.447]                           hostname = base::Sys.info()[["nodename"]])
[11:00:16.447]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:16.447]                           info)
[11:00:16.447]                         info <- base::paste(info, collapse = "; ")
[11:00:16.447]                         if (!has_future) {
[11:00:16.447]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:16.447]                             info)
[11:00:16.447]                         }
[11:00:16.447]                         else {
[11:00:16.447]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:16.447]                             info, version)
[11:00:16.447]                         }
[11:00:16.447]                         base::stop(msg)
[11:00:16.447]                       }
[11:00:16.447]                     })
[11:00:16.447]                   }
[11:00:16.447]                   ...future.strategy.old <- future::plan("list")
[11:00:16.447]                   options(future.plan = NULL)
[11:00:16.447]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:16.447]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:16.447]                 }
[11:00:16.447]                 ...future.workdir <- getwd()
[11:00:16.447]             }
[11:00:16.447]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:16.447]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:16.447]         }
[11:00:16.447]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:16.447]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:16.447]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:16.447]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:16.447]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:16.447]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:16.447]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:16.447]             base::names(...future.oldOptions))
[11:00:16.447]     }
[11:00:16.447]     if (TRUE) {
[11:00:16.447]     }
[11:00:16.447]     else {
[11:00:16.447]         if (NA) {
[11:00:16.447]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:16.447]                 open = "w")
[11:00:16.447]         }
[11:00:16.447]         else {
[11:00:16.447]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:16.447]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:16.447]         }
[11:00:16.447]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:16.447]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:16.447]             base::sink(type = "output", split = FALSE)
[11:00:16.447]             base::close(...future.stdout)
[11:00:16.447]         }, add = TRUE)
[11:00:16.447]     }
[11:00:16.447]     ...future.frame <- base::sys.nframe()
[11:00:16.447]     ...future.conditions <- base::list()
[11:00:16.447]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:16.447]     if (FALSE) {
[11:00:16.447]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:16.447]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:16.447]     }
[11:00:16.447]     ...future.result <- base::tryCatch({
[11:00:16.447]         base::withCallingHandlers({
[11:00:16.447]             ...future.value <- base::withVisible(base::local({
[11:00:16.447]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:16.447]                 if (!identical(...future.globals.maxSize.org, 
[11:00:16.447]                   ...future.globals.maxSize)) {
[11:00:16.447]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:16.447]                   on.exit(options(oopts), add = TRUE)
[11:00:16.447]                 }
[11:00:16.447]                 {
[11:00:16.447]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:16.447]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:00:16.447]                     USE.NAMES = FALSE)
[11:00:16.447]                   do.call(mapply, args = args)
[11:00:16.447]                 }
[11:00:16.447]             }))
[11:00:16.447]             future::FutureResult(value = ...future.value$value, 
[11:00:16.447]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:16.447]                   ...future.rng), globalenv = if (FALSE) 
[11:00:16.447]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:16.447]                     ...future.globalenv.names))
[11:00:16.447]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:16.447]         }, condition = base::local({
[11:00:16.447]             c <- base::c
[11:00:16.447]             inherits <- base::inherits
[11:00:16.447]             invokeRestart <- base::invokeRestart
[11:00:16.447]             length <- base::length
[11:00:16.447]             list <- base::list
[11:00:16.447]             seq.int <- base::seq.int
[11:00:16.447]             signalCondition <- base::signalCondition
[11:00:16.447]             sys.calls <- base::sys.calls
[11:00:16.447]             `[[` <- base::`[[`
[11:00:16.447]             `+` <- base::`+`
[11:00:16.447]             `<<-` <- base::`<<-`
[11:00:16.447]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:16.447]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:16.447]                   3L)]
[11:00:16.447]             }
[11:00:16.447]             function(cond) {
[11:00:16.447]                 is_error <- inherits(cond, "error")
[11:00:16.447]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:16.447]                   NULL)
[11:00:16.447]                 if (is_error) {
[11:00:16.447]                   sessionInformation <- function() {
[11:00:16.447]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:16.447]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:16.447]                       search = base::search(), system = base::Sys.info())
[11:00:16.447]                   }
[11:00:16.447]                   ...future.conditions[[length(...future.conditions) + 
[11:00:16.447]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:16.447]                     cond$call), session = sessionInformation(), 
[11:00:16.447]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:16.447]                   signalCondition(cond)
[11:00:16.447]                 }
[11:00:16.447]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:16.447]                 "immediateCondition"))) {
[11:00:16.447]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:16.447]                   ...future.conditions[[length(...future.conditions) + 
[11:00:16.447]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:16.447]                   if (TRUE && !signal) {
[11:00:16.447]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:16.447]                     {
[11:00:16.447]                       inherits <- base::inherits
[11:00:16.447]                       invokeRestart <- base::invokeRestart
[11:00:16.447]                       is.null <- base::is.null
[11:00:16.447]                       muffled <- FALSE
[11:00:16.447]                       if (inherits(cond, "message")) {
[11:00:16.447]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:16.447]                         if (muffled) 
[11:00:16.447]                           invokeRestart("muffleMessage")
[11:00:16.447]                       }
[11:00:16.447]                       else if (inherits(cond, "warning")) {
[11:00:16.447]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:16.447]                         if (muffled) 
[11:00:16.447]                           invokeRestart("muffleWarning")
[11:00:16.447]                       }
[11:00:16.447]                       else if (inherits(cond, "condition")) {
[11:00:16.447]                         if (!is.null(pattern)) {
[11:00:16.447]                           computeRestarts <- base::computeRestarts
[11:00:16.447]                           grepl <- base::grepl
[11:00:16.447]                           restarts <- computeRestarts(cond)
[11:00:16.447]                           for (restart in restarts) {
[11:00:16.447]                             name <- restart$name
[11:00:16.447]                             if (is.null(name)) 
[11:00:16.447]                               next
[11:00:16.447]                             if (!grepl(pattern, name)) 
[11:00:16.447]                               next
[11:00:16.447]                             invokeRestart(restart)
[11:00:16.447]                             muffled <- TRUE
[11:00:16.447]                             break
[11:00:16.447]                           }
[11:00:16.447]                         }
[11:00:16.447]                       }
[11:00:16.447]                       invisible(muffled)
[11:00:16.447]                     }
[11:00:16.447]                     muffleCondition(cond, pattern = "^muffle")
[11:00:16.447]                   }
[11:00:16.447]                 }
[11:00:16.447]                 else {
[11:00:16.447]                   if (TRUE) {
[11:00:16.447]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:16.447]                     {
[11:00:16.447]                       inherits <- base::inherits
[11:00:16.447]                       invokeRestart <- base::invokeRestart
[11:00:16.447]                       is.null <- base::is.null
[11:00:16.447]                       muffled <- FALSE
[11:00:16.447]                       if (inherits(cond, "message")) {
[11:00:16.447]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:16.447]                         if (muffled) 
[11:00:16.447]                           invokeRestart("muffleMessage")
[11:00:16.447]                       }
[11:00:16.447]                       else if (inherits(cond, "warning")) {
[11:00:16.447]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:16.447]                         if (muffled) 
[11:00:16.447]                           invokeRestart("muffleWarning")
[11:00:16.447]                       }
[11:00:16.447]                       else if (inherits(cond, "condition")) {
[11:00:16.447]                         if (!is.null(pattern)) {
[11:00:16.447]                           computeRestarts <- base::computeRestarts
[11:00:16.447]                           grepl <- base::grepl
[11:00:16.447]                           restarts <- computeRestarts(cond)
[11:00:16.447]                           for (restart in restarts) {
[11:00:16.447]                             name <- restart$name
[11:00:16.447]                             if (is.null(name)) 
[11:00:16.447]                               next
[11:00:16.447]                             if (!grepl(pattern, name)) 
[11:00:16.447]                               next
[11:00:16.447]                             invokeRestart(restart)
[11:00:16.447]                             muffled <- TRUE
[11:00:16.447]                             break
[11:00:16.447]                           }
[11:00:16.447]                         }
[11:00:16.447]                       }
[11:00:16.447]                       invisible(muffled)
[11:00:16.447]                     }
[11:00:16.447]                     muffleCondition(cond, pattern = "^muffle")
[11:00:16.447]                   }
[11:00:16.447]                 }
[11:00:16.447]             }
[11:00:16.447]         }))
[11:00:16.447]     }, error = function(ex) {
[11:00:16.447]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:16.447]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:16.447]                 ...future.rng), started = ...future.startTime, 
[11:00:16.447]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:16.447]             version = "1.8"), class = "FutureResult")
[11:00:16.447]     }, finally = {
[11:00:16.447]         if (!identical(...future.workdir, getwd())) 
[11:00:16.447]             setwd(...future.workdir)
[11:00:16.447]         {
[11:00:16.447]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:16.447]                 ...future.oldOptions$nwarnings <- NULL
[11:00:16.447]             }
[11:00:16.447]             base::options(...future.oldOptions)
[11:00:16.447]             if (.Platform$OS.type == "windows") {
[11:00:16.447]                 old_names <- names(...future.oldEnvVars)
[11:00:16.447]                 envs <- base::Sys.getenv()
[11:00:16.447]                 names <- names(envs)
[11:00:16.447]                 common <- intersect(names, old_names)
[11:00:16.447]                 added <- setdiff(names, old_names)
[11:00:16.447]                 removed <- setdiff(old_names, names)
[11:00:16.447]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:16.447]                   envs[common]]
[11:00:16.447]                 NAMES <- toupper(changed)
[11:00:16.447]                 args <- list()
[11:00:16.447]                 for (kk in seq_along(NAMES)) {
[11:00:16.447]                   name <- changed[[kk]]
[11:00:16.447]                   NAME <- NAMES[[kk]]
[11:00:16.447]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:16.447]                     next
[11:00:16.447]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:16.447]                 }
[11:00:16.447]                 NAMES <- toupper(added)
[11:00:16.447]                 for (kk in seq_along(NAMES)) {
[11:00:16.447]                   name <- added[[kk]]
[11:00:16.447]                   NAME <- NAMES[[kk]]
[11:00:16.447]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:16.447]                     next
[11:00:16.447]                   args[[name]] <- ""
[11:00:16.447]                 }
[11:00:16.447]                 NAMES <- toupper(removed)
[11:00:16.447]                 for (kk in seq_along(NAMES)) {
[11:00:16.447]                   name <- removed[[kk]]
[11:00:16.447]                   NAME <- NAMES[[kk]]
[11:00:16.447]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:16.447]                     next
[11:00:16.447]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:16.447]                 }
[11:00:16.447]                 if (length(args) > 0) 
[11:00:16.447]                   base::do.call(base::Sys.setenv, args = args)
[11:00:16.447]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:16.447]             }
[11:00:16.447]             else {
[11:00:16.447]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:16.447]             }
[11:00:16.447]             {
[11:00:16.447]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:16.447]                   0L) {
[11:00:16.447]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:16.447]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:16.447]                   base::options(opts)
[11:00:16.447]                 }
[11:00:16.447]                 {
[11:00:16.447]                   {
[11:00:16.447]                     NULL
[11:00:16.447]                     RNGkind("Mersenne-Twister")
[11:00:16.447]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:16.447]                       inherits = FALSE)
[11:00:16.447]                   }
[11:00:16.447]                   options(future.plan = NULL)
[11:00:16.447]                   if (is.na(NA_character_)) 
[11:00:16.447]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:16.447]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:16.447]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:16.447]                     .init = FALSE)
[11:00:16.447]                 }
[11:00:16.447]             }
[11:00:16.447]         }
[11:00:16.447]     })
[11:00:16.447]     if (FALSE) {
[11:00:16.447]         base::sink(type = "output", split = FALSE)
[11:00:16.447]         if (NA) {
[11:00:16.447]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:16.447]         }
[11:00:16.447]         else {
[11:00:16.447]             ...future.result["stdout"] <- base::list(NULL)
[11:00:16.447]         }
[11:00:16.447]         base::close(...future.stdout)
[11:00:16.447]         ...future.stdout <- NULL
[11:00:16.447]     }
[11:00:16.447]     ...future.result$conditions <- ...future.conditions
[11:00:16.447]     ...future.result$finished <- base::Sys.time()
[11:00:16.447]     ...future.result
[11:00:16.447] }
[11:00:16.448] assign_globals() ...
[11:00:16.448] List of 5
[11:00:16.448]  $ ...future.FUN            :function (x, y)  
[11:00:16.448]  $ MoreArgs                 : NULL
[11:00:16.448]  $ ...future.elements_ii    :List of 2
[11:00:16.448]   ..$ :List of 2
[11:00:16.448]   .. ..$ : int 1
[11:00:16.448]   .. ..$ : int 0
[11:00:16.448]   ..$ :List of 2
[11:00:16.448]   .. ..$ : int 0
[11:00:16.448]   .. ..$ : int 1
[11:00:16.448]  $ ...future.seeds_ii       : NULL
[11:00:16.448]  $ ...future.globals.maxSize: NULL
[11:00:16.448]  - attr(*, "where")=List of 5
[11:00:16.448]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:16.448]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[11:00:16.448]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:16.448]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:16.448]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:16.448]  - attr(*, "resolved")= logi FALSE
[11:00:16.448]  - attr(*, "total_size")= num 1242
[11:00:16.448]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:16.448]  - attr(*, "already-done")= logi TRUE
[11:00:16.455] - reassign environment for ‘...future.FUN’
[11:00:16.455] - copied ‘...future.FUN’ to environment
[11:00:16.455] - copied ‘MoreArgs’ to environment
[11:00:16.455] - copied ‘...future.elements_ii’ to environment
[11:00:16.455] - copied ‘...future.seeds_ii’ to environment
[11:00:16.455] - copied ‘...future.globals.maxSize’ to environment
[11:00:16.455] assign_globals() ... done
[11:00:16.456] plan(): Setting new future strategy stack:
[11:00:16.456] List of future strategies:
[11:00:16.456] 1. sequential:
[11:00:16.456]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:16.456]    - tweaked: FALSE
[11:00:16.456]    - call: NULL
[11:00:16.456] plan(): nbrOfWorkers() = 1
[11:00:16.958] plan(): Setting new future strategy stack:
[11:00:16.958] List of future strategies:
[11:00:16.958] 1. sequential:
[11:00:16.958]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:16.958]    - tweaked: FALSE
[11:00:16.958]    - call: plan(strategy)
[11:00:16.958] plan(): nbrOfWorkers() = 1
[11:00:16.959] SequentialFuture started (and completed)
[11:00:16.959] - Launch lazy future ... done
[11:00:16.959] run() for ‘SequentialFuture’ ... done
[11:00:16.959] Created future:
[11:00:16.959] SequentialFuture:
[11:00:16.959] Label: ‘future_mapply-1’
[11:00:16.959] Expression:
[11:00:16.959] {
[11:00:16.959]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:16.959]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:16.959]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:16.959]         on.exit(options(oopts), add = TRUE)
[11:00:16.959]     }
[11:00:16.959]     {
[11:00:16.959]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:16.959]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:00:16.959]         do.call(mapply, args = args)
[11:00:16.959]     }
[11:00:16.959] }
[11:00:16.959] Lazy evaluation: FALSE
[11:00:16.959] Asynchronous evaluation: FALSE
[11:00:16.959] Local evaluation: TRUE
[11:00:16.959] Environment: R_GlobalEnv
[11:00:16.959] Capture standard output: NA
[11:00:16.959] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:16.959] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:16.959] Packages: <none>
[11:00:16.959] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:16.959] Resolved: TRUE
[11:00:16.959] Value: 184 bytes of class ‘list’
[11:00:16.959] Early signaling: FALSE
[11:00:16.959] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:16.959] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:16.960] Chunk #1 of 1 ... DONE
[11:00:16.960] Launching 1 futures (chunks) ... DONE
[11:00:16.960] Resolving 1 futures (chunks) ...
[11:00:16.960] resolve() on list ...
[11:00:16.960]  recursive: 0
[11:00:16.960]  length: 1
[11:00:16.960] 
[11:00:16.960] resolved() for ‘SequentialFuture’ ...
[11:00:16.961] - state: ‘finished’
[11:00:16.961] - run: TRUE
[11:00:16.961] - result: ‘FutureResult’
[11:00:16.961] resolved() for ‘SequentialFuture’ ... done
[11:00:16.961] Future #1
[11:00:16.961] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:16.961] - nx: 1
[11:00:16.961] - relay: TRUE
[11:00:16.961] - stdout: TRUE
[11:00:16.961] - signal: TRUE
[11:00:16.961] - resignal: FALSE
[11:00:16.962] - force: TRUE
[11:00:16.962] - relayed: [n=1] FALSE
[11:00:16.962] - queued futures: [n=1] FALSE
[11:00:16.962]  - until=1
[11:00:16.962]  - relaying element #1
[11:00:16.962] - relayed: [n=1] TRUE
[11:00:16.962] - queued futures: [n=1] TRUE
[11:00:16.962] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:16.962]  length: 0 (resolved future 1)
[11:00:16.962] Relaying remaining futures
[11:00:16.962] signalConditionsASAP(NULL, pos=0) ...
[11:00:16.963] - nx: 1
[11:00:16.963] - relay: TRUE
[11:00:16.963] - stdout: TRUE
[11:00:16.963] - signal: TRUE
[11:00:16.963] - resignal: FALSE
[11:00:16.963] - force: TRUE
[11:00:16.963] - relayed: [n=1] TRUE
[11:00:16.963] - queued futures: [n=1] TRUE
 - flush all
[11:00:16.963] - relayed: [n=1] TRUE
[11:00:16.963] - queued futures: [n=1] TRUE
[11:00:16.963] signalConditionsASAP(NULL, pos=0) ... done
[11:00:16.963] resolve() on list ... DONE
[11:00:16.964]  - Number of value chunks collected: 1
[11:00:16.964] Resolving 1 futures (chunks) ... DONE
[11:00:16.964] Reducing values from 1 chunks ...
[11:00:16.964]  - Number of values collected after concatenation: 2
[11:00:16.964]  - Number of values expected: 2
[11:00:16.964] Reducing values from 1 chunks ... DONE
[11:00:16.964] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('sequential') ... DONE
* plan('multicore') ...
[11:00:16.965] plan(): Setting new future strategy stack:
[11:00:16.965] List of future strategies:
[11:00:16.965] 1. multicore:
[11:00:16.965]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:16.965]    - tweaked: FALSE
[11:00:16.965]    - call: plan(strategy)
[11:00:16.966] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[11:00:16.967] future_lapply() ...
[11:00:16.968] Number of chunks: 1
[11:00:16.969] getGlobalsAndPackagesXApply() ...
[11:00:16.969]  - future.globals: TRUE
[11:00:16.969] getGlobalsAndPackages() ...
[11:00:16.969] Searching for globals...
[11:00:16.970] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[11:00:16.970] Searching for globals ... DONE
[11:00:16.970] Resolving globals: FALSE
[11:00:16.971] The total size of the 1 globals is 841 bytes (841 bytes)
[11:00:16.971] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[11:00:16.971] - globals: [1] ‘FUN’
[11:00:16.971] 
[11:00:16.971] getGlobalsAndPackages() ... DONE
[11:00:16.972]  - globals found/used: [n=1] ‘FUN’
[11:00:16.972]  - needed namespaces: [n=0] 
[11:00:16.972] Finding globals ... DONE
[11:00:16.972]  - use_args: TRUE
[11:00:16.972]  - Getting '...' globals ...
[11:00:16.972] resolve() on list ...
[11:00:16.972]  recursive: 0
[11:00:16.972]  length: 1
[11:00:16.972]  elements: ‘...’
[11:00:16.973]  length: 0 (resolved future 1)
[11:00:16.973] resolve() on list ... DONE
[11:00:16.973]    - '...' content: [n=0] 
[11:00:16.973] List of 1
[11:00:16.973]  $ ...: list()
[11:00:16.973]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:16.973]  - attr(*, "where")=List of 1
[11:00:16.973]   ..$ ...:<environment: 0x55ceb34969e0> 
[11:00:16.973]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:16.973]  - attr(*, "resolved")= logi TRUE
[11:00:16.973]  - attr(*, "total_size")= num NA
[11:00:16.975]  - Getting '...' globals ... DONE
[11:00:16.975] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[11:00:16.975] List of 2
[11:00:16.975]  $ ...future.FUN:function (x)  
[11:00:16.975]  $ ...          : list()
[11:00:16.975]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:16.975]  - attr(*, "where")=List of 2
[11:00:16.975]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:16.975]   ..$ ...          :<environment: 0x55ceb34969e0> 
[11:00:16.975]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:16.975]  - attr(*, "resolved")= logi FALSE
[11:00:16.975]  - attr(*, "total_size")= num 5632
[11:00:16.979] Packages to be attached in all futures: [n=0] 
[11:00:16.980] getGlobalsAndPackagesXApply() ... DONE
[11:00:16.980] Number of futures (= number of chunks): 1
[11:00:16.980] Launching 1 futures (chunks) ...
[11:00:16.980] Chunk #1 of 1 ...
[11:00:16.980]  - Finding globals in 'X' for chunk #1 ...
[11:00:16.980] getGlobalsAndPackages() ...
[11:00:16.980] Searching for globals...
[11:00:16.980] 
[11:00:16.981] Searching for globals ... DONE
[11:00:16.981] - globals: [0] <none>
[11:00:16.981] getGlobalsAndPackages() ... DONE
[11:00:16.981]    + additional globals found: [n=0] 
[11:00:16.981]    + additional namespaces needed: [n=0] 
[11:00:16.981]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:16.981]  - seeds: <none>
[11:00:16.981]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:16.981] getGlobalsAndPackages() ...
[11:00:16.981] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:16.981] Resolving globals: FALSE
[11:00:16.982] Tweak future expression to call with '...' arguments ...
[11:00:16.982] {
[11:00:16.982]     do.call(function(...) {
[11:00:16.982]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:16.982]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:16.982]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:16.982]             on.exit(options(oopts), add = TRUE)
[11:00:16.982]         }
[11:00:16.982]         {
[11:00:16.982]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:16.982]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:16.982]                 ...future.FUN(...future.X_jj, ...)
[11:00:16.982]             })
[11:00:16.982]         }
[11:00:16.982]     }, args = future.call.arguments)
[11:00:16.982] }
[11:00:16.982] Tweak future expression to call with '...' arguments ... DONE
[11:00:16.982] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:16.982] 
[11:00:16.982] getGlobalsAndPackages() ... DONE
[11:00:16.983] run() for ‘Future’ ...
[11:00:16.983] - state: ‘created’
[11:00:16.983] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:16.984] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:16.985] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:16.985]   - Field: ‘label’
[11:00:16.985]   - Field: ‘local’
[11:00:16.985]   - Field: ‘owner’
[11:00:16.985]   - Field: ‘envir’
[11:00:16.985]   - Field: ‘packages’
[11:00:16.985]   - Field: ‘gc’
[11:00:16.985]   - Field: ‘conditions’
[11:00:16.985]   - Field: ‘expr’
[11:00:16.985]   - Field: ‘uuid’
[11:00:16.985]   - Field: ‘seed’
[11:00:16.986]   - Field: ‘version’
[11:00:16.986]   - Field: ‘result’
[11:00:16.986]   - Field: ‘asynchronous’
[11:00:16.986]   - Field: ‘calls’
[11:00:16.986]   - Field: ‘globals’
[11:00:16.986]   - Field: ‘stdout’
[11:00:16.986]   - Field: ‘earlySignal’
[11:00:16.986]   - Field: ‘lazy’
[11:00:16.986]   - Field: ‘state’
[11:00:16.986] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:16.986] - Launch lazy future ...
[11:00:16.987] Packages needed by the future expression (n = 0): <none>
[11:00:16.987] Packages needed by future strategies (n = 0): <none>
[11:00:16.987] {
[11:00:16.987]     {
[11:00:16.987]         {
[11:00:16.987]             ...future.startTime <- base::Sys.time()
[11:00:16.987]             {
[11:00:16.987]                 {
[11:00:16.987]                   {
[11:00:16.987]                     base::local({
[11:00:16.987]                       has_future <- base::requireNamespace("future", 
[11:00:16.987]                         quietly = TRUE)
[11:00:16.987]                       if (has_future) {
[11:00:16.987]                         ns <- base::getNamespace("future")
[11:00:16.987]                         version <- ns[[".package"]][["version"]]
[11:00:16.987]                         if (is.null(version)) 
[11:00:16.987]                           version <- utils::packageVersion("future")
[11:00:16.987]                       }
[11:00:16.987]                       else {
[11:00:16.987]                         version <- NULL
[11:00:16.987]                       }
[11:00:16.987]                       if (!has_future || version < "1.8.0") {
[11:00:16.987]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:16.987]                           "", base::R.version$version.string), 
[11:00:16.987]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:16.987]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:16.987]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:16.987]                             "release", "version")], collapse = " "), 
[11:00:16.987]                           hostname = base::Sys.info()[["nodename"]])
[11:00:16.987]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:16.987]                           info)
[11:00:16.987]                         info <- base::paste(info, collapse = "; ")
[11:00:16.987]                         if (!has_future) {
[11:00:16.987]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:16.987]                             info)
[11:00:16.987]                         }
[11:00:16.987]                         else {
[11:00:16.987]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:16.987]                             info, version)
[11:00:16.987]                         }
[11:00:16.987]                         base::stop(msg)
[11:00:16.987]                       }
[11:00:16.987]                     })
[11:00:16.987]                   }
[11:00:16.987]                   ...future.strategy.old <- future::plan("list")
[11:00:16.987]                   options(future.plan = NULL)
[11:00:16.987]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:16.987]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:16.987]                 }
[11:00:16.987]                 ...future.workdir <- getwd()
[11:00:16.987]             }
[11:00:16.987]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:16.987]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:16.987]         }
[11:00:16.987]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:16.987]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:16.987]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:16.987]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:16.987]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:16.987]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:16.987]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:16.987]             base::names(...future.oldOptions))
[11:00:16.987]     }
[11:00:16.987]     if (FALSE) {
[11:00:16.987]     }
[11:00:16.987]     else {
[11:00:16.987]         if (FALSE) {
[11:00:16.987]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:16.987]                 open = "w")
[11:00:16.987]         }
[11:00:16.987]         else {
[11:00:16.987]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:16.987]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:16.987]         }
[11:00:16.987]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:16.987]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:16.987]             base::sink(type = "output", split = FALSE)
[11:00:16.987]             base::close(...future.stdout)
[11:00:16.987]         }, add = TRUE)
[11:00:16.987]     }
[11:00:16.987]     ...future.frame <- base::sys.nframe()
[11:00:16.987]     ...future.conditions <- base::list()
[11:00:16.987]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:16.987]     if (FALSE) {
[11:00:16.987]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:16.987]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:16.987]     }
[11:00:16.987]     ...future.result <- base::tryCatch({
[11:00:16.987]         base::withCallingHandlers({
[11:00:16.987]             ...future.value <- base::withVisible(base::local({
[11:00:16.987]                 do.call(function(...) {
[11:00:16.987]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:16.987]                   if (!identical(...future.globals.maxSize.org, 
[11:00:16.987]                     ...future.globals.maxSize)) {
[11:00:16.987]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:16.987]                     on.exit(options(oopts), add = TRUE)
[11:00:16.987]                   }
[11:00:16.987]                   {
[11:00:16.987]                     lapply(seq_along(...future.elements_ii), 
[11:00:16.987]                       FUN = function(jj) {
[11:00:16.987]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:16.987]                         ...future.FUN(...future.X_jj, ...)
[11:00:16.987]                       })
[11:00:16.987]                   }
[11:00:16.987]                 }, args = future.call.arguments)
[11:00:16.987]             }))
[11:00:16.987]             future::FutureResult(value = ...future.value$value, 
[11:00:16.987]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:16.987]                   ...future.rng), globalenv = if (FALSE) 
[11:00:16.987]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:16.987]                     ...future.globalenv.names))
[11:00:16.987]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:16.987]         }, condition = base::local({
[11:00:16.987]             c <- base::c
[11:00:16.987]             inherits <- base::inherits
[11:00:16.987]             invokeRestart <- base::invokeRestart
[11:00:16.987]             length <- base::length
[11:00:16.987]             list <- base::list
[11:00:16.987]             seq.int <- base::seq.int
[11:00:16.987]             signalCondition <- base::signalCondition
[11:00:16.987]             sys.calls <- base::sys.calls
[11:00:16.987]             `[[` <- base::`[[`
[11:00:16.987]             `+` <- base::`+`
[11:00:16.987]             `<<-` <- base::`<<-`
[11:00:16.987]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:16.987]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:16.987]                   3L)]
[11:00:16.987]             }
[11:00:16.987]             function(cond) {
[11:00:16.987]                 is_error <- inherits(cond, "error")
[11:00:16.987]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:16.987]                   NULL)
[11:00:16.987]                 if (is_error) {
[11:00:16.987]                   sessionInformation <- function() {
[11:00:16.987]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:16.987]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:16.987]                       search = base::search(), system = base::Sys.info())
[11:00:16.987]                   }
[11:00:16.987]                   ...future.conditions[[length(...future.conditions) + 
[11:00:16.987]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:16.987]                     cond$call), session = sessionInformation(), 
[11:00:16.987]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:16.987]                   signalCondition(cond)
[11:00:16.987]                 }
[11:00:16.987]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:16.987]                 "immediateCondition"))) {
[11:00:16.987]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:16.987]                   ...future.conditions[[length(...future.conditions) + 
[11:00:16.987]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:16.987]                   if (TRUE && !signal) {
[11:00:16.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:16.987]                     {
[11:00:16.987]                       inherits <- base::inherits
[11:00:16.987]                       invokeRestart <- base::invokeRestart
[11:00:16.987]                       is.null <- base::is.null
[11:00:16.987]                       muffled <- FALSE
[11:00:16.987]                       if (inherits(cond, "message")) {
[11:00:16.987]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:16.987]                         if (muffled) 
[11:00:16.987]                           invokeRestart("muffleMessage")
[11:00:16.987]                       }
[11:00:16.987]                       else if (inherits(cond, "warning")) {
[11:00:16.987]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:16.987]                         if (muffled) 
[11:00:16.987]                           invokeRestart("muffleWarning")
[11:00:16.987]                       }
[11:00:16.987]                       else if (inherits(cond, "condition")) {
[11:00:16.987]                         if (!is.null(pattern)) {
[11:00:16.987]                           computeRestarts <- base::computeRestarts
[11:00:16.987]                           grepl <- base::grepl
[11:00:16.987]                           restarts <- computeRestarts(cond)
[11:00:16.987]                           for (restart in restarts) {
[11:00:16.987]                             name <- restart$name
[11:00:16.987]                             if (is.null(name)) 
[11:00:16.987]                               next
[11:00:16.987]                             if (!grepl(pattern, name)) 
[11:00:16.987]                               next
[11:00:16.987]                             invokeRestart(restart)
[11:00:16.987]                             muffled <- TRUE
[11:00:16.987]                             break
[11:00:16.987]                           }
[11:00:16.987]                         }
[11:00:16.987]                       }
[11:00:16.987]                       invisible(muffled)
[11:00:16.987]                     }
[11:00:16.987]                     muffleCondition(cond, pattern = "^muffle")
[11:00:16.987]                   }
[11:00:16.987]                 }
[11:00:16.987]                 else {
[11:00:16.987]                   if (TRUE) {
[11:00:16.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:16.987]                     {
[11:00:16.987]                       inherits <- base::inherits
[11:00:16.987]                       invokeRestart <- base::invokeRestart
[11:00:16.987]                       is.null <- base::is.null
[11:00:16.987]                       muffled <- FALSE
[11:00:16.987]                       if (inherits(cond, "message")) {
[11:00:16.987]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:16.987]                         if (muffled) 
[11:00:16.987]                           invokeRestart("muffleMessage")
[11:00:16.987]                       }
[11:00:16.987]                       else if (inherits(cond, "warning")) {
[11:00:16.987]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:16.987]                         if (muffled) 
[11:00:16.987]                           invokeRestart("muffleWarning")
[11:00:16.987]                       }
[11:00:16.987]                       else if (inherits(cond, "condition")) {
[11:00:16.987]                         if (!is.null(pattern)) {
[11:00:16.987]                           computeRestarts <- base::computeRestarts
[11:00:16.987]                           grepl <- base::grepl
[11:00:16.987]                           restarts <- computeRestarts(cond)
[11:00:16.987]                           for (restart in restarts) {
[11:00:16.987]                             name <- restart$name
[11:00:16.987]                             if (is.null(name)) 
[11:00:16.987]                               next
[11:00:16.987]                             if (!grepl(pattern, name)) 
[11:00:16.987]                               next
[11:00:16.987]                             invokeRestart(restart)
[11:00:16.987]                             muffled <- TRUE
[11:00:16.987]                             break
[11:00:16.987]                           }
[11:00:16.987]                         }
[11:00:16.987]                       }
[11:00:16.987]                       invisible(muffled)
[11:00:16.987]                     }
[11:00:16.987]                     muffleCondition(cond, pattern = "^muffle")
[11:00:16.987]                   }
[11:00:16.987]                 }
[11:00:16.987]             }
[11:00:16.987]         }))
[11:00:16.987]     }, error = function(ex) {
[11:00:16.987]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:16.987]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:16.987]                 ...future.rng), started = ...future.startTime, 
[11:00:16.987]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:16.987]             version = "1.8"), class = "FutureResult")
[11:00:16.987]     }, finally = {
[11:00:16.987]         if (!identical(...future.workdir, getwd())) 
[11:00:16.987]             setwd(...future.workdir)
[11:00:16.987]         {
[11:00:16.987]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:16.987]                 ...future.oldOptions$nwarnings <- NULL
[11:00:16.987]             }
[11:00:16.987]             base::options(...future.oldOptions)
[11:00:16.987]             if (.Platform$OS.type == "windows") {
[11:00:16.987]                 old_names <- names(...future.oldEnvVars)
[11:00:16.987]                 envs <- base::Sys.getenv()
[11:00:16.987]                 names <- names(envs)
[11:00:16.987]                 common <- intersect(names, old_names)
[11:00:16.987]                 added <- setdiff(names, old_names)
[11:00:16.987]                 removed <- setdiff(old_names, names)
[11:00:16.987]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:16.987]                   envs[common]]
[11:00:16.987]                 NAMES <- toupper(changed)
[11:00:16.987]                 args <- list()
[11:00:16.987]                 for (kk in seq_along(NAMES)) {
[11:00:16.987]                   name <- changed[[kk]]
[11:00:16.987]                   NAME <- NAMES[[kk]]
[11:00:16.987]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:16.987]                     next
[11:00:16.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:16.987]                 }
[11:00:16.987]                 NAMES <- toupper(added)
[11:00:16.987]                 for (kk in seq_along(NAMES)) {
[11:00:16.987]                   name <- added[[kk]]
[11:00:16.987]                   NAME <- NAMES[[kk]]
[11:00:16.987]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:16.987]                     next
[11:00:16.987]                   args[[name]] <- ""
[11:00:16.987]                 }
[11:00:16.987]                 NAMES <- toupper(removed)
[11:00:16.987]                 for (kk in seq_along(NAMES)) {
[11:00:16.987]                   name <- removed[[kk]]
[11:00:16.987]                   NAME <- NAMES[[kk]]
[11:00:16.987]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:16.987]                     next
[11:00:16.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:16.987]                 }
[11:00:16.987]                 if (length(args) > 0) 
[11:00:16.987]                   base::do.call(base::Sys.setenv, args = args)
[11:00:16.987]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:16.987]             }
[11:00:16.987]             else {
[11:00:16.987]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:16.987]             }
[11:00:16.987]             {
[11:00:16.987]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:16.987]                   0L) {
[11:00:16.987]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:16.987]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:16.987]                   base::options(opts)
[11:00:16.987]                 }
[11:00:16.987]                 {
[11:00:16.987]                   {
[11:00:16.987]                     NULL
[11:00:16.987]                     RNGkind("Mersenne-Twister")
[11:00:16.987]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:16.987]                       inherits = FALSE)
[11:00:16.987]                   }
[11:00:16.987]                   options(future.plan = NULL)
[11:00:16.987]                   if (is.na(NA_character_)) 
[11:00:16.987]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:16.987]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:16.987]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:16.987]                     .init = FALSE)
[11:00:16.987]                 }
[11:00:16.987]             }
[11:00:16.987]         }
[11:00:16.987]     })
[11:00:16.987]     if (TRUE) {
[11:00:16.987]         base::sink(type = "output", split = FALSE)
[11:00:16.987]         if (FALSE) {
[11:00:16.987]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:16.987]         }
[11:00:16.987]         else {
[11:00:16.987]             ...future.result["stdout"] <- base::list(NULL)
[11:00:16.987]         }
[11:00:16.987]         base::close(...future.stdout)
[11:00:16.987]         ...future.stdout <- NULL
[11:00:16.987]     }
[11:00:16.987]     ...future.result$conditions <- ...future.conditions
[11:00:16.987]     ...future.result$finished <- base::Sys.time()
[11:00:16.987]     ...future.result
[11:00:16.987] }
[11:00:16.989] assign_globals() ...
[11:00:16.989] List of 5
[11:00:16.989]  $ ...future.FUN            :function (x)  
[11:00:16.989]  $ future.call.arguments    : list()
[11:00:16.989]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:16.989]  $ ...future.elements_ii    :List of 2
[11:00:16.989]   ..$ : int 1
[11:00:16.989]   ..$ : int 0
[11:00:16.989]  $ ...future.seeds_ii       : NULL
[11:00:16.989]  $ ...future.globals.maxSize: NULL
[11:00:16.989]  - attr(*, "where")=List of 5
[11:00:16.989]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:16.989]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:16.989]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:16.989]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:16.989]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:16.989]  - attr(*, "resolved")= logi FALSE
[11:00:16.989]  - attr(*, "total_size")= num 5632
[11:00:16.989]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:16.989]  - attr(*, "already-done")= logi TRUE
[11:00:16.993] - reassign environment for ‘...future.FUN’
[11:00:16.994] - copied ‘...future.FUN’ to environment
[11:00:16.994] - copied ‘future.call.arguments’ to environment
[11:00:16.994] - copied ‘...future.elements_ii’ to environment
[11:00:16.994] - copied ‘...future.seeds_ii’ to environment
[11:00:16.994] - copied ‘...future.globals.maxSize’ to environment
[11:00:16.994] assign_globals() ... done
[11:00:16.994] plan(): Setting new future strategy stack:
[11:00:16.994] List of future strategies:
[11:00:16.994] 1. sequential:
[11:00:16.994]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:16.994]    - tweaked: FALSE
[11:00:16.994]    - call: NULL
[11:00:16.995] plan(): nbrOfWorkers() = 1
[11:00:17.496] plan(): Setting new future strategy stack:
[11:00:17.496] List of future strategies:
[11:00:17.496] 1. multicore:
[11:00:17.496]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:17.496]    - tweaked: FALSE
[11:00:17.496]    - call: plan(strategy)
[11:00:17.498] plan(): nbrOfWorkers() = 1
[11:00:17.498] SequentialFuture started (and completed)
[11:00:17.499] - Launch lazy future ... done
[11:00:17.499] run() for ‘SequentialFuture’ ... done
[11:00:17.499] Created future:
[11:00:17.499] SequentialFuture:
[11:00:17.499] Label: ‘future_lapply-1’
[11:00:17.499] Expression:
[11:00:17.499] {
[11:00:17.499]     do.call(function(...) {
[11:00:17.499]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:17.499]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:17.499]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:17.499]             on.exit(options(oopts), add = TRUE)
[11:00:17.499]         }
[11:00:17.499]         {
[11:00:17.499]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:17.499]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:17.499]                 ...future.FUN(...future.X_jj, ...)
[11:00:17.499]             })
[11:00:17.499]         }
[11:00:17.499]     }, args = future.call.arguments)
[11:00:17.499] }
[11:00:17.499] Lazy evaluation: FALSE
[11:00:17.499] Asynchronous evaluation: FALSE
[11:00:17.499] Local evaluation: TRUE
[11:00:17.499] Environment: R_GlobalEnv
[11:00:17.499] Capture standard output: FALSE
[11:00:17.499] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:17.499] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:17.499] Packages: <none>
[11:00:17.499] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:17.499] Resolved: TRUE
[11:00:17.499] Value: 55 bytes of class ‘list’
[11:00:17.499] Early signaling: FALSE
[11:00:17.499] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:17.499] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:17.500] Chunk #1 of 1 ... DONE
[11:00:17.500] Launching 1 futures (chunks) ... DONE
[11:00:17.500] Resolving 1 futures (chunks) ...
[11:00:17.500] resolve() on list ...
[11:00:17.500]  recursive: 0
[11:00:17.500]  length: 1
[11:00:17.500] 
[11:00:17.500] resolved() for ‘SequentialFuture’ ...
[11:00:17.500] - state: ‘finished’
[11:00:17.501] - run: TRUE
[11:00:17.501] - result: ‘FutureResult’
[11:00:17.501] resolved() for ‘SequentialFuture’ ... done
[11:00:17.501] Future #1
[11:00:17.501] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:17.501] - nx: 1
[11:00:17.501] - relay: TRUE
[11:00:17.501] - stdout: TRUE
[11:00:17.501] - signal: TRUE
[11:00:17.501] - resignal: FALSE
[11:00:17.501] - force: TRUE
[11:00:17.502] - relayed: [n=1] FALSE
[11:00:17.502] - queued futures: [n=1] FALSE
[11:00:17.502]  - until=1
[11:00:17.502]  - relaying element #1
[11:00:17.502] - relayed: [n=1] TRUE
[11:00:17.502] - queued futures: [n=1] TRUE
[11:00:17.502] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:17.502]  length: 0 (resolved future 1)
[11:00:17.502] Relaying remaining futures
[11:00:17.502] signalConditionsASAP(NULL, pos=0) ...
[11:00:17.502] - nx: 1
[11:00:17.503] - relay: TRUE
[11:00:17.503] - stdout: TRUE
[11:00:17.503] - signal: TRUE
[11:00:17.503] - resignal: FALSE
[11:00:17.503] - force: TRUE
[11:00:17.503] - relayed: [n=1] TRUE
[11:00:17.503] - queued futures: [n=1] TRUE
 - flush all
[11:00:17.505] - relayed: [n=1] TRUE
[11:00:17.505] - queued futures: [n=1] TRUE
[11:00:17.505] signalConditionsASAP(NULL, pos=0) ... done
[11:00:17.505] resolve() on list ... DONE
[11:00:17.505]  - Number of value chunks collected: 1
[11:00:17.505] Resolving 1 futures (chunks) ... DONE
[11:00:17.505] Reducing values from 1 chunks ...
[11:00:17.505]  - Number of values collected after concatenation: 2
[11:00:17.505]  - Number of values expected: 2
[11:00:17.506] Reducing values from 1 chunks ... DONE
[11:00:17.506] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[11:00:17.506] future_lapply() ...
[11:00:17.508] Number of chunks: 1
[11:00:17.508] getGlobalsAndPackagesXApply() ...
[11:00:17.508]  - future.globals: TRUE
[11:00:17.508] getGlobalsAndPackages() ...
[11:00:17.508] Searching for globals...
[11:00:17.510] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[11:00:17.510] Searching for globals ... DONE
[11:00:17.510] Resolving globals: FALSE
[11:00:17.510] The total size of the 1 globals is 841 bytes (841 bytes)
[11:00:17.511] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[11:00:17.511] - globals: [1] ‘FUN’
[11:00:17.511] 
[11:00:17.511] getGlobalsAndPackages() ... DONE
[11:00:17.511]  - globals found/used: [n=1] ‘FUN’
[11:00:17.511]  - needed namespaces: [n=0] 
[11:00:17.511] Finding globals ... DONE
[11:00:17.511]  - use_args: TRUE
[11:00:17.511]  - Getting '...' globals ...
[11:00:17.512] resolve() on list ...
[11:00:17.512]  recursive: 0
[11:00:17.512]  length: 1
[11:00:17.512]  elements: ‘...’
[11:00:17.512]  length: 0 (resolved future 1)
[11:00:17.512] resolve() on list ... DONE
[11:00:17.512]    - '...' content: [n=0] 
[11:00:17.512] List of 1
[11:00:17.512]  $ ...: list()
[11:00:17.512]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:17.512]  - attr(*, "where")=List of 1
[11:00:17.512]   ..$ ...:<environment: 0x55ceb2db7520> 
[11:00:17.512]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:17.512]  - attr(*, "resolved")= logi TRUE
[11:00:17.512]  - attr(*, "total_size")= num NA
[11:00:17.515]  - Getting '...' globals ... DONE
[11:00:17.515] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[11:00:17.515] List of 2
[11:00:17.515]  $ ...future.FUN:function (x)  
[11:00:17.515]  $ ...          : list()
[11:00:17.515]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:17.515]  - attr(*, "where")=List of 2
[11:00:17.515]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:17.515]   ..$ ...          :<environment: 0x55ceb2db7520> 
[11:00:17.515]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:17.515]  - attr(*, "resolved")= logi FALSE
[11:00:17.515]  - attr(*, "total_size")= num 5632
[11:00:17.517] Packages to be attached in all futures: [n=0] 
[11:00:17.517] getGlobalsAndPackagesXApply() ... DONE
[11:00:17.518] Number of futures (= number of chunks): 1
[11:00:17.518] Launching 1 futures (chunks) ...
[11:00:17.518] Chunk #1 of 1 ...
[11:00:17.518]  - Finding globals in 'X' for chunk #1 ...
[11:00:17.518] getGlobalsAndPackages() ...
[11:00:17.518] Searching for globals...
[11:00:17.518] 
[11:00:17.518] Searching for globals ... DONE
[11:00:17.519] - globals: [0] <none>
[11:00:17.519] getGlobalsAndPackages() ... DONE
[11:00:17.519]    + additional globals found: [n=0] 
[11:00:17.519]    + additional namespaces needed: [n=0] 
[11:00:17.519]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:17.519]  - seeds: <none>
[11:00:17.519]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:17.519] getGlobalsAndPackages() ...
[11:00:17.519] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:17.519] Resolving globals: FALSE
[11:00:17.519] Tweak future expression to call with '...' arguments ...
[11:00:17.520] {
[11:00:17.520]     do.call(function(...) {
[11:00:17.520]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:17.520]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:17.520]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:17.520]             on.exit(options(oopts), add = TRUE)
[11:00:17.520]         }
[11:00:17.520]         {
[11:00:17.520]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:17.520]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:17.520]                 ...future.FUN(...future.X_jj, ...)
[11:00:17.520]             })
[11:00:17.520]         }
[11:00:17.520]     }, args = future.call.arguments)
[11:00:17.520] }
[11:00:17.520] Tweak future expression to call with '...' arguments ... DONE
[11:00:17.520] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:17.520] 
[11:00:17.520] getGlobalsAndPackages() ... DONE
[11:00:17.521] run() for ‘Future’ ...
[11:00:17.521] - state: ‘created’
[11:00:17.521] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:17.522] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:17.522] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:17.523]   - Field: ‘label’
[11:00:17.523]   - Field: ‘local’
[11:00:17.523]   - Field: ‘owner’
[11:00:17.523]   - Field: ‘envir’
[11:00:17.523]   - Field: ‘packages’
[11:00:17.523]   - Field: ‘gc’
[11:00:17.523]   - Field: ‘conditions’
[11:00:17.523]   - Field: ‘expr’
[11:00:17.523]   - Field: ‘uuid’
[11:00:17.523]   - Field: ‘seed’
[11:00:17.523]   - Field: ‘version’
[11:00:17.524]   - Field: ‘result’
[11:00:17.524]   - Field: ‘asynchronous’
[11:00:17.524]   - Field: ‘calls’
[11:00:17.524]   - Field: ‘globals’
[11:00:17.524]   - Field: ‘stdout’
[11:00:17.524]   - Field: ‘earlySignal’
[11:00:17.524]   - Field: ‘lazy’
[11:00:17.524]   - Field: ‘state’
[11:00:17.524] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:17.524] - Launch lazy future ...
[11:00:17.524] Packages needed by the future expression (n = 0): <none>
[11:00:17.525] Packages needed by future strategies (n = 0): <none>
[11:00:17.525] {
[11:00:17.525]     {
[11:00:17.525]         {
[11:00:17.525]             ...future.startTime <- base::Sys.time()
[11:00:17.525]             {
[11:00:17.525]                 {
[11:00:17.525]                   {
[11:00:17.525]                     base::local({
[11:00:17.525]                       has_future <- base::requireNamespace("future", 
[11:00:17.525]                         quietly = TRUE)
[11:00:17.525]                       if (has_future) {
[11:00:17.525]                         ns <- base::getNamespace("future")
[11:00:17.525]                         version <- ns[[".package"]][["version"]]
[11:00:17.525]                         if (is.null(version)) 
[11:00:17.525]                           version <- utils::packageVersion("future")
[11:00:17.525]                       }
[11:00:17.525]                       else {
[11:00:17.525]                         version <- NULL
[11:00:17.525]                       }
[11:00:17.525]                       if (!has_future || version < "1.8.0") {
[11:00:17.525]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:17.525]                           "", base::R.version$version.string), 
[11:00:17.525]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:17.525]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:17.525]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:17.525]                             "release", "version")], collapse = " "), 
[11:00:17.525]                           hostname = base::Sys.info()[["nodename"]])
[11:00:17.525]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:17.525]                           info)
[11:00:17.525]                         info <- base::paste(info, collapse = "; ")
[11:00:17.525]                         if (!has_future) {
[11:00:17.525]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:17.525]                             info)
[11:00:17.525]                         }
[11:00:17.525]                         else {
[11:00:17.525]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:17.525]                             info, version)
[11:00:17.525]                         }
[11:00:17.525]                         base::stop(msg)
[11:00:17.525]                       }
[11:00:17.525]                     })
[11:00:17.525]                   }
[11:00:17.525]                   ...future.strategy.old <- future::plan("list")
[11:00:17.525]                   options(future.plan = NULL)
[11:00:17.525]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:17.525]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:17.525]                 }
[11:00:17.525]                 ...future.workdir <- getwd()
[11:00:17.525]             }
[11:00:17.525]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:17.525]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:17.525]         }
[11:00:17.525]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:17.525]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:17.525]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:17.525]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:17.525]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:17.525]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:17.525]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:17.525]             base::names(...future.oldOptions))
[11:00:17.525]     }
[11:00:17.525]     if (FALSE) {
[11:00:17.525]     }
[11:00:17.525]     else {
[11:00:17.525]         if (TRUE) {
[11:00:17.525]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:17.525]                 open = "w")
[11:00:17.525]         }
[11:00:17.525]         else {
[11:00:17.525]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:17.525]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:17.525]         }
[11:00:17.525]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:17.525]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:17.525]             base::sink(type = "output", split = FALSE)
[11:00:17.525]             base::close(...future.stdout)
[11:00:17.525]         }, add = TRUE)
[11:00:17.525]     }
[11:00:17.525]     ...future.frame <- base::sys.nframe()
[11:00:17.525]     ...future.conditions <- base::list()
[11:00:17.525]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:17.525]     if (FALSE) {
[11:00:17.525]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:17.525]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:17.525]     }
[11:00:17.525]     ...future.result <- base::tryCatch({
[11:00:17.525]         base::withCallingHandlers({
[11:00:17.525]             ...future.value <- base::withVisible(base::local({
[11:00:17.525]                 do.call(function(...) {
[11:00:17.525]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:17.525]                   if (!identical(...future.globals.maxSize.org, 
[11:00:17.525]                     ...future.globals.maxSize)) {
[11:00:17.525]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:17.525]                     on.exit(options(oopts), add = TRUE)
[11:00:17.525]                   }
[11:00:17.525]                   {
[11:00:17.525]                     lapply(seq_along(...future.elements_ii), 
[11:00:17.525]                       FUN = function(jj) {
[11:00:17.525]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:17.525]                         ...future.FUN(...future.X_jj, ...)
[11:00:17.525]                       })
[11:00:17.525]                   }
[11:00:17.525]                 }, args = future.call.arguments)
[11:00:17.525]             }))
[11:00:17.525]             future::FutureResult(value = ...future.value$value, 
[11:00:17.525]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:17.525]                   ...future.rng), globalenv = if (FALSE) 
[11:00:17.525]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:17.525]                     ...future.globalenv.names))
[11:00:17.525]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:17.525]         }, condition = base::local({
[11:00:17.525]             c <- base::c
[11:00:17.525]             inherits <- base::inherits
[11:00:17.525]             invokeRestart <- base::invokeRestart
[11:00:17.525]             length <- base::length
[11:00:17.525]             list <- base::list
[11:00:17.525]             seq.int <- base::seq.int
[11:00:17.525]             signalCondition <- base::signalCondition
[11:00:17.525]             sys.calls <- base::sys.calls
[11:00:17.525]             `[[` <- base::`[[`
[11:00:17.525]             `+` <- base::`+`
[11:00:17.525]             `<<-` <- base::`<<-`
[11:00:17.525]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:17.525]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:17.525]                   3L)]
[11:00:17.525]             }
[11:00:17.525]             function(cond) {
[11:00:17.525]                 is_error <- inherits(cond, "error")
[11:00:17.525]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:17.525]                   NULL)
[11:00:17.525]                 if (is_error) {
[11:00:17.525]                   sessionInformation <- function() {
[11:00:17.525]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:17.525]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:17.525]                       search = base::search(), system = base::Sys.info())
[11:00:17.525]                   }
[11:00:17.525]                   ...future.conditions[[length(...future.conditions) + 
[11:00:17.525]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:17.525]                     cond$call), session = sessionInformation(), 
[11:00:17.525]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:17.525]                   signalCondition(cond)
[11:00:17.525]                 }
[11:00:17.525]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:17.525]                 "immediateCondition"))) {
[11:00:17.525]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:17.525]                   ...future.conditions[[length(...future.conditions) + 
[11:00:17.525]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:17.525]                   if (TRUE && !signal) {
[11:00:17.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:17.525]                     {
[11:00:17.525]                       inherits <- base::inherits
[11:00:17.525]                       invokeRestart <- base::invokeRestart
[11:00:17.525]                       is.null <- base::is.null
[11:00:17.525]                       muffled <- FALSE
[11:00:17.525]                       if (inherits(cond, "message")) {
[11:00:17.525]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:17.525]                         if (muffled) 
[11:00:17.525]                           invokeRestart("muffleMessage")
[11:00:17.525]                       }
[11:00:17.525]                       else if (inherits(cond, "warning")) {
[11:00:17.525]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:17.525]                         if (muffled) 
[11:00:17.525]                           invokeRestart("muffleWarning")
[11:00:17.525]                       }
[11:00:17.525]                       else if (inherits(cond, "condition")) {
[11:00:17.525]                         if (!is.null(pattern)) {
[11:00:17.525]                           computeRestarts <- base::computeRestarts
[11:00:17.525]                           grepl <- base::grepl
[11:00:17.525]                           restarts <- computeRestarts(cond)
[11:00:17.525]                           for (restart in restarts) {
[11:00:17.525]                             name <- restart$name
[11:00:17.525]                             if (is.null(name)) 
[11:00:17.525]                               next
[11:00:17.525]                             if (!grepl(pattern, name)) 
[11:00:17.525]                               next
[11:00:17.525]                             invokeRestart(restart)
[11:00:17.525]                             muffled <- TRUE
[11:00:17.525]                             break
[11:00:17.525]                           }
[11:00:17.525]                         }
[11:00:17.525]                       }
[11:00:17.525]                       invisible(muffled)
[11:00:17.525]                     }
[11:00:17.525]                     muffleCondition(cond, pattern = "^muffle")
[11:00:17.525]                   }
[11:00:17.525]                 }
[11:00:17.525]                 else {
[11:00:17.525]                   if (TRUE) {
[11:00:17.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:17.525]                     {
[11:00:17.525]                       inherits <- base::inherits
[11:00:17.525]                       invokeRestart <- base::invokeRestart
[11:00:17.525]                       is.null <- base::is.null
[11:00:17.525]                       muffled <- FALSE
[11:00:17.525]                       if (inherits(cond, "message")) {
[11:00:17.525]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:17.525]                         if (muffled) 
[11:00:17.525]                           invokeRestart("muffleMessage")
[11:00:17.525]                       }
[11:00:17.525]                       else if (inherits(cond, "warning")) {
[11:00:17.525]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:17.525]                         if (muffled) 
[11:00:17.525]                           invokeRestart("muffleWarning")
[11:00:17.525]                       }
[11:00:17.525]                       else if (inherits(cond, "condition")) {
[11:00:17.525]                         if (!is.null(pattern)) {
[11:00:17.525]                           computeRestarts <- base::computeRestarts
[11:00:17.525]                           grepl <- base::grepl
[11:00:17.525]                           restarts <- computeRestarts(cond)
[11:00:17.525]                           for (restart in restarts) {
[11:00:17.525]                             name <- restart$name
[11:00:17.525]                             if (is.null(name)) 
[11:00:17.525]                               next
[11:00:17.525]                             if (!grepl(pattern, name)) 
[11:00:17.525]                               next
[11:00:17.525]                             invokeRestart(restart)
[11:00:17.525]                             muffled <- TRUE
[11:00:17.525]                             break
[11:00:17.525]                           }
[11:00:17.525]                         }
[11:00:17.525]                       }
[11:00:17.525]                       invisible(muffled)
[11:00:17.525]                     }
[11:00:17.525]                     muffleCondition(cond, pattern = "^muffle")
[11:00:17.525]                   }
[11:00:17.525]                 }
[11:00:17.525]             }
[11:00:17.525]         }))
[11:00:17.525]     }, error = function(ex) {
[11:00:17.525]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:17.525]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:17.525]                 ...future.rng), started = ...future.startTime, 
[11:00:17.525]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:17.525]             version = "1.8"), class = "FutureResult")
[11:00:17.525]     }, finally = {
[11:00:17.525]         if (!identical(...future.workdir, getwd())) 
[11:00:17.525]             setwd(...future.workdir)
[11:00:17.525]         {
[11:00:17.525]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:17.525]                 ...future.oldOptions$nwarnings <- NULL
[11:00:17.525]             }
[11:00:17.525]             base::options(...future.oldOptions)
[11:00:17.525]             if (.Platform$OS.type == "windows") {
[11:00:17.525]                 old_names <- names(...future.oldEnvVars)
[11:00:17.525]                 envs <- base::Sys.getenv()
[11:00:17.525]                 names <- names(envs)
[11:00:17.525]                 common <- intersect(names, old_names)
[11:00:17.525]                 added <- setdiff(names, old_names)
[11:00:17.525]                 removed <- setdiff(old_names, names)
[11:00:17.525]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:17.525]                   envs[common]]
[11:00:17.525]                 NAMES <- toupper(changed)
[11:00:17.525]                 args <- list()
[11:00:17.525]                 for (kk in seq_along(NAMES)) {
[11:00:17.525]                   name <- changed[[kk]]
[11:00:17.525]                   NAME <- NAMES[[kk]]
[11:00:17.525]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:17.525]                     next
[11:00:17.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:17.525]                 }
[11:00:17.525]                 NAMES <- toupper(added)
[11:00:17.525]                 for (kk in seq_along(NAMES)) {
[11:00:17.525]                   name <- added[[kk]]
[11:00:17.525]                   NAME <- NAMES[[kk]]
[11:00:17.525]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:17.525]                     next
[11:00:17.525]                   args[[name]] <- ""
[11:00:17.525]                 }
[11:00:17.525]                 NAMES <- toupper(removed)
[11:00:17.525]                 for (kk in seq_along(NAMES)) {
[11:00:17.525]                   name <- removed[[kk]]
[11:00:17.525]                   NAME <- NAMES[[kk]]
[11:00:17.525]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:17.525]                     next
[11:00:17.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:17.525]                 }
[11:00:17.525]                 if (length(args) > 0) 
[11:00:17.525]                   base::do.call(base::Sys.setenv, args = args)
[11:00:17.525]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:17.525]             }
[11:00:17.525]             else {
[11:00:17.525]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:17.525]             }
[11:00:17.525]             {
[11:00:17.525]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:17.525]                   0L) {
[11:00:17.525]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:17.525]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:17.525]                   base::options(opts)
[11:00:17.525]                 }
[11:00:17.525]                 {
[11:00:17.525]                   {
[11:00:17.525]                     NULL
[11:00:17.525]                     RNGkind("Mersenne-Twister")
[11:00:17.525]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:17.525]                       inherits = FALSE)
[11:00:17.525]                   }
[11:00:17.525]                   options(future.plan = NULL)
[11:00:17.525]                   if (is.na(NA_character_)) 
[11:00:17.525]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:17.525]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:17.525]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:17.525]                     .init = FALSE)
[11:00:17.525]                 }
[11:00:17.525]             }
[11:00:17.525]         }
[11:00:17.525]     })
[11:00:17.525]     if (TRUE) {
[11:00:17.525]         base::sink(type = "output", split = FALSE)
[11:00:17.525]         if (TRUE) {
[11:00:17.525]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:17.525]         }
[11:00:17.525]         else {
[11:00:17.525]             ...future.result["stdout"] <- base::list(NULL)
[11:00:17.525]         }
[11:00:17.525]         base::close(...future.stdout)
[11:00:17.525]         ...future.stdout <- NULL
[11:00:17.525]     }
[11:00:17.525]     ...future.result$conditions <- ...future.conditions
[11:00:17.525]     ...future.result$finished <- base::Sys.time()
[11:00:17.525]     ...future.result
[11:00:17.525] }
[11:00:17.527] assign_globals() ...
[11:00:17.527] List of 5
[11:00:17.527]  $ ...future.FUN            :function (x)  
[11:00:17.527]  $ future.call.arguments    : list()
[11:00:17.527]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:17.527]  $ ...future.elements_ii    :List of 2
[11:00:17.527]   ..$ : int 1
[11:00:17.527]   ..$ : int 0
[11:00:17.527]  $ ...future.seeds_ii       : NULL
[11:00:17.527]  $ ...future.globals.maxSize: NULL
[11:00:17.527]  - attr(*, "where")=List of 5
[11:00:17.527]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:17.527]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:17.527]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:17.527]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:17.527]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:17.527]  - attr(*, "resolved")= logi FALSE
[11:00:17.527]  - attr(*, "total_size")= num 5632
[11:00:17.527]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:17.527]  - attr(*, "already-done")= logi TRUE
[11:00:17.533] - reassign environment for ‘...future.FUN’
[11:00:17.533] - copied ‘...future.FUN’ to environment
[11:00:17.533] - copied ‘future.call.arguments’ to environment
[11:00:17.534] - copied ‘...future.elements_ii’ to environment
[11:00:17.534] - copied ‘...future.seeds_ii’ to environment
[11:00:17.534] - copied ‘...future.globals.maxSize’ to environment
[11:00:17.534] assign_globals() ... done
[11:00:17.534] plan(): Setting new future strategy stack:
[11:00:17.534] List of future strategies:
[11:00:17.534] 1. sequential:
[11:00:17.534]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:17.534]    - tweaked: FALSE
[11:00:17.534]    - call: NULL
[11:00:17.535] plan(): nbrOfWorkers() = 1
[11:00:18.036] plan(): Setting new future strategy stack:
[11:00:18.036] List of future strategies:
[11:00:18.036] 1. multicore:
[11:00:18.036]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:18.036]    - tweaked: FALSE
[11:00:18.036]    - call: plan(strategy)
[11:00:18.038] plan(): nbrOfWorkers() = 1
[11:00:18.038] SequentialFuture started (and completed)
[11:00:18.039] - Launch lazy future ... done
[11:00:18.039] run() for ‘SequentialFuture’ ... done
[11:00:18.039] Created future:
[11:00:18.039] SequentialFuture:
[11:00:18.039] Label: ‘future_lapply-1’
[11:00:18.039] Expression:
[11:00:18.039] {
[11:00:18.039]     do.call(function(...) {
[11:00:18.039]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:18.039]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:18.039]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:18.039]             on.exit(options(oopts), add = TRUE)
[11:00:18.039]         }
[11:00:18.039]         {
[11:00:18.039]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:18.039]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:18.039]                 ...future.FUN(...future.X_jj, ...)
[11:00:18.039]             })
[11:00:18.039]         }
[11:00:18.039]     }, args = future.call.arguments)
[11:00:18.039] }
[11:00:18.039] Lazy evaluation: FALSE
[11:00:18.039] Asynchronous evaluation: FALSE
[11:00:18.039] Local evaluation: TRUE
[11:00:18.039] Environment: R_GlobalEnv
[11:00:18.039] Capture standard output: TRUE
[11:00:18.039] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:18.039] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:18.039] Packages: <none>
[11:00:18.039] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:18.039] Resolved: TRUE
[11:00:18.039] Value: 55 bytes of class ‘list’
[11:00:18.039] Early signaling: FALSE
[11:00:18.039] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:18.039] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:18.040] Chunk #1 of 1 ... DONE
[11:00:18.040] Launching 1 futures (chunks) ... DONE
[11:00:18.040] Resolving 1 futures (chunks) ...
[11:00:18.040] resolve() on list ...
[11:00:18.040]  recursive: 0
[11:00:18.040]  length: 1
[11:00:18.040] 
[11:00:18.040] resolved() for ‘SequentialFuture’ ...
[11:00:18.040] - state: ‘finished’
[11:00:18.041] - run: TRUE
[11:00:18.041] - result: ‘FutureResult’
[11:00:18.041] resolved() for ‘SequentialFuture’ ... done
[11:00:18.041] Future #1
[11:00:18.041] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:18.041] - nx: 1
[11:00:18.041] - relay: TRUE
[11:00:18.041] - stdout: TRUE
[11:00:18.041] - signal: TRUE
[11:00:18.041] - resignal: FALSE
[11:00:18.041] - force: TRUE
[11:00:18.042] - relayed: [n=1] FALSE
[11:00:18.042] - queued futures: [n=1] FALSE
[11:00:18.042]  - until=1
[11:00:18.042]  - relaying element #1
[11:00:18.042] - relayed: [n=1] TRUE
[11:00:18.042] - queued futures: [n=1] TRUE
[11:00:18.042] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:18.042]  length: 0 (resolved future 1)
[11:00:18.042] Relaying remaining futures
[11:00:18.042] signalConditionsASAP(NULL, pos=0) ...
[11:00:18.043] - nx: 1
[11:00:18.043] - relay: TRUE
[11:00:18.043] - stdout: TRUE
[11:00:18.043] - signal: TRUE
[11:00:18.043] - resignal: FALSE
[11:00:18.043] - force: TRUE
[11:00:18.043] - relayed: [n=1] TRUE
[11:00:18.043] - queued futures: [n=1] TRUE
 - flush all
[11:00:18.043] - relayed: [n=1] TRUE
[11:00:18.043] - queued futures: [n=1] TRUE
[11:00:18.043] signalConditionsASAP(NULL, pos=0) ... done
[11:00:18.043] resolve() on list ... DONE
[11:00:18.044]  - Number of value chunks collected: 1
[11:00:18.044] Resolving 1 futures (chunks) ... DONE
[11:00:18.044] Reducing values from 1 chunks ...
[11:00:18.044]  - Number of values collected after concatenation: 2
[11:00:18.044]  - Number of values expected: 2
[11:00:18.044] Reducing values from 1 chunks ... DONE
[11:00:18.044] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[11:00:18.044] future_lapply() ...
[11:00:18.046] Number of chunks: 1
[11:00:18.046] getGlobalsAndPackagesXApply() ...
[11:00:18.047]  - future.globals: TRUE
[11:00:18.047] getGlobalsAndPackages() ...
[11:00:18.047] Searching for globals...
[11:00:18.048] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[11:00:18.048] Searching for globals ... DONE
[11:00:18.048] Resolving globals: FALSE
[11:00:18.049] The total size of the 1 globals is 841 bytes (841 bytes)
[11:00:18.049] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[11:00:18.049] - globals: [1] ‘FUN’
[11:00:18.049] 
[11:00:18.049] getGlobalsAndPackages() ... DONE
[11:00:18.049]  - globals found/used: [n=1] ‘FUN’
[11:00:18.049]  - needed namespaces: [n=0] 
[11:00:18.050] Finding globals ... DONE
[11:00:18.050]  - use_args: TRUE
[11:00:18.050]  - Getting '...' globals ...
[11:00:18.050] resolve() on list ...
[11:00:18.050]  recursive: 0
[11:00:18.050]  length: 1
[11:00:18.050]  elements: ‘...’
[11:00:18.050]  length: 0 (resolved future 1)
[11:00:18.051] resolve() on list ... DONE
[11:00:18.051]    - '...' content: [n=0] 
[11:00:18.051] List of 1
[11:00:18.051]  $ ...: list()
[11:00:18.051]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:18.051]  - attr(*, "where")=List of 1
[11:00:18.051]   ..$ ...:<environment: 0x55ceb3893b50> 
[11:00:18.051]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:18.051]  - attr(*, "resolved")= logi TRUE
[11:00:18.051]  - attr(*, "total_size")= num NA
[11:00:18.053]  - Getting '...' globals ... DONE
[11:00:18.053] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[11:00:18.053] List of 2
[11:00:18.053]  $ ...future.FUN:function (x)  
[11:00:18.053]  $ ...          : list()
[11:00:18.053]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:18.053]  - attr(*, "where")=List of 2
[11:00:18.053]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:18.053]   ..$ ...          :<environment: 0x55ceb3893b50> 
[11:00:18.053]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:18.053]  - attr(*, "resolved")= logi FALSE
[11:00:18.053]  - attr(*, "total_size")= num 5632
[11:00:18.058] Packages to be attached in all futures: [n=0] 
[11:00:18.058] getGlobalsAndPackagesXApply() ... DONE
[11:00:18.058] Number of futures (= number of chunks): 1
[11:00:18.058] Launching 1 futures (chunks) ...
[11:00:18.058] Chunk #1 of 1 ...
[11:00:18.058]  - Finding globals in 'X' for chunk #1 ...
[11:00:18.058] getGlobalsAndPackages() ...
[11:00:18.058] Searching for globals...
[11:00:18.059] 
[11:00:18.059] Searching for globals ... DONE
[11:00:18.059] - globals: [0] <none>
[11:00:18.059] getGlobalsAndPackages() ... DONE
[11:00:18.059]    + additional globals found: [n=0] 
[11:00:18.059]    + additional namespaces needed: [n=0] 
[11:00:18.059]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:18.059]  - seeds: <none>
[11:00:18.059]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:18.059] getGlobalsAndPackages() ...
[11:00:18.059] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:18.060] Resolving globals: FALSE
[11:00:18.060] Tweak future expression to call with '...' arguments ...
[11:00:18.060] {
[11:00:18.060]     do.call(function(...) {
[11:00:18.060]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:18.060]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:18.060]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:18.060]             on.exit(options(oopts), add = TRUE)
[11:00:18.060]         }
[11:00:18.060]         {
[11:00:18.060]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:18.060]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:18.060]                 ...future.FUN(...future.X_jj, ...)
[11:00:18.060]             })
[11:00:18.060]         }
[11:00:18.060]     }, args = future.call.arguments)
[11:00:18.060] }
[11:00:18.060] Tweak future expression to call with '...' arguments ... DONE
[11:00:18.060] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:18.060] 
[11:00:18.061] getGlobalsAndPackages() ... DONE
[11:00:18.061] run() for ‘Future’ ...
[11:00:18.061] - state: ‘created’
[11:00:18.061] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:18.063] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:18.063] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:18.063]   - Field: ‘label’
[11:00:18.063]   - Field: ‘local’
[11:00:18.063]   - Field: ‘owner’
[11:00:18.063]   - Field: ‘envir’
[11:00:18.063]   - Field: ‘packages’
[11:00:18.063]   - Field: ‘gc’
[11:00:18.063]   - Field: ‘conditions’
[11:00:18.063]   - Field: ‘expr’
[11:00:18.064]   - Field: ‘uuid’
[11:00:18.064]   - Field: ‘seed’
[11:00:18.064]   - Field: ‘version’
[11:00:18.064]   - Field: ‘result’
[11:00:18.064]   - Field: ‘asynchronous’
[11:00:18.064]   - Field: ‘calls’
[11:00:18.064]   - Field: ‘globals’
[11:00:18.064]   - Field: ‘stdout’
[11:00:18.064]   - Field: ‘earlySignal’
[11:00:18.064]   - Field: ‘lazy’
[11:00:18.064]   - Field: ‘state’
[11:00:18.064] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:18.065] - Launch lazy future ...
[11:00:18.065] Packages needed by the future expression (n = 0): <none>
[11:00:18.065] Packages needed by future strategies (n = 0): <none>
[11:00:18.065] {
[11:00:18.065]     {
[11:00:18.065]         {
[11:00:18.065]             ...future.startTime <- base::Sys.time()
[11:00:18.065]             {
[11:00:18.065]                 {
[11:00:18.065]                   {
[11:00:18.065]                     base::local({
[11:00:18.065]                       has_future <- base::requireNamespace("future", 
[11:00:18.065]                         quietly = TRUE)
[11:00:18.065]                       if (has_future) {
[11:00:18.065]                         ns <- base::getNamespace("future")
[11:00:18.065]                         version <- ns[[".package"]][["version"]]
[11:00:18.065]                         if (is.null(version)) 
[11:00:18.065]                           version <- utils::packageVersion("future")
[11:00:18.065]                       }
[11:00:18.065]                       else {
[11:00:18.065]                         version <- NULL
[11:00:18.065]                       }
[11:00:18.065]                       if (!has_future || version < "1.8.0") {
[11:00:18.065]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:18.065]                           "", base::R.version$version.string), 
[11:00:18.065]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:18.065]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:18.065]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:18.065]                             "release", "version")], collapse = " "), 
[11:00:18.065]                           hostname = base::Sys.info()[["nodename"]])
[11:00:18.065]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:18.065]                           info)
[11:00:18.065]                         info <- base::paste(info, collapse = "; ")
[11:00:18.065]                         if (!has_future) {
[11:00:18.065]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:18.065]                             info)
[11:00:18.065]                         }
[11:00:18.065]                         else {
[11:00:18.065]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:18.065]                             info, version)
[11:00:18.065]                         }
[11:00:18.065]                         base::stop(msg)
[11:00:18.065]                       }
[11:00:18.065]                     })
[11:00:18.065]                   }
[11:00:18.065]                   ...future.strategy.old <- future::plan("list")
[11:00:18.065]                   options(future.plan = NULL)
[11:00:18.065]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:18.065]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:18.065]                 }
[11:00:18.065]                 ...future.workdir <- getwd()
[11:00:18.065]             }
[11:00:18.065]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:18.065]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:18.065]         }
[11:00:18.065]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:18.065]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:18.065]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:18.065]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:18.065]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:18.065]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:18.065]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:18.065]             base::names(...future.oldOptions))
[11:00:18.065]     }
[11:00:18.065]     if (TRUE) {
[11:00:18.065]     }
[11:00:18.065]     else {
[11:00:18.065]         if (NA) {
[11:00:18.065]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:18.065]                 open = "w")
[11:00:18.065]         }
[11:00:18.065]         else {
[11:00:18.065]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:18.065]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:18.065]         }
[11:00:18.065]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:18.065]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:18.065]             base::sink(type = "output", split = FALSE)
[11:00:18.065]             base::close(...future.stdout)
[11:00:18.065]         }, add = TRUE)
[11:00:18.065]     }
[11:00:18.065]     ...future.frame <- base::sys.nframe()
[11:00:18.065]     ...future.conditions <- base::list()
[11:00:18.065]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:18.065]     if (FALSE) {
[11:00:18.065]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:18.065]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:18.065]     }
[11:00:18.065]     ...future.result <- base::tryCatch({
[11:00:18.065]         base::withCallingHandlers({
[11:00:18.065]             ...future.value <- base::withVisible(base::local({
[11:00:18.065]                 do.call(function(...) {
[11:00:18.065]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:18.065]                   if (!identical(...future.globals.maxSize.org, 
[11:00:18.065]                     ...future.globals.maxSize)) {
[11:00:18.065]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:18.065]                     on.exit(options(oopts), add = TRUE)
[11:00:18.065]                   }
[11:00:18.065]                   {
[11:00:18.065]                     lapply(seq_along(...future.elements_ii), 
[11:00:18.065]                       FUN = function(jj) {
[11:00:18.065]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:18.065]                         ...future.FUN(...future.X_jj, ...)
[11:00:18.065]                       })
[11:00:18.065]                   }
[11:00:18.065]                 }, args = future.call.arguments)
[11:00:18.065]             }))
[11:00:18.065]             future::FutureResult(value = ...future.value$value, 
[11:00:18.065]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:18.065]                   ...future.rng), globalenv = if (FALSE) 
[11:00:18.065]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:18.065]                     ...future.globalenv.names))
[11:00:18.065]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:18.065]         }, condition = base::local({
[11:00:18.065]             c <- base::c
[11:00:18.065]             inherits <- base::inherits
[11:00:18.065]             invokeRestart <- base::invokeRestart
[11:00:18.065]             length <- base::length
[11:00:18.065]             list <- base::list
[11:00:18.065]             seq.int <- base::seq.int
[11:00:18.065]             signalCondition <- base::signalCondition
[11:00:18.065]             sys.calls <- base::sys.calls
[11:00:18.065]             `[[` <- base::`[[`
[11:00:18.065]             `+` <- base::`+`
[11:00:18.065]             `<<-` <- base::`<<-`
[11:00:18.065]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:18.065]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:18.065]                   3L)]
[11:00:18.065]             }
[11:00:18.065]             function(cond) {
[11:00:18.065]                 is_error <- inherits(cond, "error")
[11:00:18.065]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:18.065]                   NULL)
[11:00:18.065]                 if (is_error) {
[11:00:18.065]                   sessionInformation <- function() {
[11:00:18.065]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:18.065]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:18.065]                       search = base::search(), system = base::Sys.info())
[11:00:18.065]                   }
[11:00:18.065]                   ...future.conditions[[length(...future.conditions) + 
[11:00:18.065]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:18.065]                     cond$call), session = sessionInformation(), 
[11:00:18.065]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:18.065]                   signalCondition(cond)
[11:00:18.065]                 }
[11:00:18.065]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:18.065]                 "immediateCondition"))) {
[11:00:18.065]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:18.065]                   ...future.conditions[[length(...future.conditions) + 
[11:00:18.065]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:18.065]                   if (TRUE && !signal) {
[11:00:18.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:18.065]                     {
[11:00:18.065]                       inherits <- base::inherits
[11:00:18.065]                       invokeRestart <- base::invokeRestart
[11:00:18.065]                       is.null <- base::is.null
[11:00:18.065]                       muffled <- FALSE
[11:00:18.065]                       if (inherits(cond, "message")) {
[11:00:18.065]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:18.065]                         if (muffled) 
[11:00:18.065]                           invokeRestart("muffleMessage")
[11:00:18.065]                       }
[11:00:18.065]                       else if (inherits(cond, "warning")) {
[11:00:18.065]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:18.065]                         if (muffled) 
[11:00:18.065]                           invokeRestart("muffleWarning")
[11:00:18.065]                       }
[11:00:18.065]                       else if (inherits(cond, "condition")) {
[11:00:18.065]                         if (!is.null(pattern)) {
[11:00:18.065]                           computeRestarts <- base::computeRestarts
[11:00:18.065]                           grepl <- base::grepl
[11:00:18.065]                           restarts <- computeRestarts(cond)
[11:00:18.065]                           for (restart in restarts) {
[11:00:18.065]                             name <- restart$name
[11:00:18.065]                             if (is.null(name)) 
[11:00:18.065]                               next
[11:00:18.065]                             if (!grepl(pattern, name)) 
[11:00:18.065]                               next
[11:00:18.065]                             invokeRestart(restart)
[11:00:18.065]                             muffled <- TRUE
[11:00:18.065]                             break
[11:00:18.065]                           }
[11:00:18.065]                         }
[11:00:18.065]                       }
[11:00:18.065]                       invisible(muffled)
[11:00:18.065]                     }
[11:00:18.065]                     muffleCondition(cond, pattern = "^muffle")
[11:00:18.065]                   }
[11:00:18.065]                 }
[11:00:18.065]                 else {
[11:00:18.065]                   if (TRUE) {
[11:00:18.065]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:18.065]                     {
[11:00:18.065]                       inherits <- base::inherits
[11:00:18.065]                       invokeRestart <- base::invokeRestart
[11:00:18.065]                       is.null <- base::is.null
[11:00:18.065]                       muffled <- FALSE
[11:00:18.065]                       if (inherits(cond, "message")) {
[11:00:18.065]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:18.065]                         if (muffled) 
[11:00:18.065]                           invokeRestart("muffleMessage")
[11:00:18.065]                       }
[11:00:18.065]                       else if (inherits(cond, "warning")) {
[11:00:18.065]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:18.065]                         if (muffled) 
[11:00:18.065]                           invokeRestart("muffleWarning")
[11:00:18.065]                       }
[11:00:18.065]                       else if (inherits(cond, "condition")) {
[11:00:18.065]                         if (!is.null(pattern)) {
[11:00:18.065]                           computeRestarts <- base::computeRestarts
[11:00:18.065]                           grepl <- base::grepl
[11:00:18.065]                           restarts <- computeRestarts(cond)
[11:00:18.065]                           for (restart in restarts) {
[11:00:18.065]                             name <- restart$name
[11:00:18.065]                             if (is.null(name)) 
[11:00:18.065]                               next
[11:00:18.065]                             if (!grepl(pattern, name)) 
[11:00:18.065]                               next
[11:00:18.065]                             invokeRestart(restart)
[11:00:18.065]                             muffled <- TRUE
[11:00:18.065]                             break
[11:00:18.065]                           }
[11:00:18.065]                         }
[11:00:18.065]                       }
[11:00:18.065]                       invisible(muffled)
[11:00:18.065]                     }
[11:00:18.065]                     muffleCondition(cond, pattern = "^muffle")
[11:00:18.065]                   }
[11:00:18.065]                 }
[11:00:18.065]             }
[11:00:18.065]         }))
[11:00:18.065]     }, error = function(ex) {
[11:00:18.065]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:18.065]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:18.065]                 ...future.rng), started = ...future.startTime, 
[11:00:18.065]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:18.065]             version = "1.8"), class = "FutureResult")
[11:00:18.065]     }, finally = {
[11:00:18.065]         if (!identical(...future.workdir, getwd())) 
[11:00:18.065]             setwd(...future.workdir)
[11:00:18.065]         {
[11:00:18.065]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:18.065]                 ...future.oldOptions$nwarnings <- NULL
[11:00:18.065]             }
[11:00:18.065]             base::options(...future.oldOptions)
[11:00:18.065]             if (.Platform$OS.type == "windows") {
[11:00:18.065]                 old_names <- names(...future.oldEnvVars)
[11:00:18.065]                 envs <- base::Sys.getenv()
[11:00:18.065]                 names <- names(envs)
[11:00:18.065]                 common <- intersect(names, old_names)
[11:00:18.065]                 added <- setdiff(names, old_names)
[11:00:18.065]                 removed <- setdiff(old_names, names)
[11:00:18.065]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:18.065]                   envs[common]]
[11:00:18.065]                 NAMES <- toupper(changed)
[11:00:18.065]                 args <- list()
[11:00:18.065]                 for (kk in seq_along(NAMES)) {
[11:00:18.065]                   name <- changed[[kk]]
[11:00:18.065]                   NAME <- NAMES[[kk]]
[11:00:18.065]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:18.065]                     next
[11:00:18.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:18.065]                 }
[11:00:18.065]                 NAMES <- toupper(added)
[11:00:18.065]                 for (kk in seq_along(NAMES)) {
[11:00:18.065]                   name <- added[[kk]]
[11:00:18.065]                   NAME <- NAMES[[kk]]
[11:00:18.065]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:18.065]                     next
[11:00:18.065]                   args[[name]] <- ""
[11:00:18.065]                 }
[11:00:18.065]                 NAMES <- toupper(removed)
[11:00:18.065]                 for (kk in seq_along(NAMES)) {
[11:00:18.065]                   name <- removed[[kk]]
[11:00:18.065]                   NAME <- NAMES[[kk]]
[11:00:18.065]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:18.065]                     next
[11:00:18.065]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:18.065]                 }
[11:00:18.065]                 if (length(args) > 0) 
[11:00:18.065]                   base::do.call(base::Sys.setenv, args = args)
[11:00:18.065]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:18.065]             }
[11:00:18.065]             else {
[11:00:18.065]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:18.065]             }
[11:00:18.065]             {
[11:00:18.065]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:18.065]                   0L) {
[11:00:18.065]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:18.065]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:18.065]                   base::options(opts)
[11:00:18.065]                 }
[11:00:18.065]                 {
[11:00:18.065]                   {
[11:00:18.065]                     NULL
[11:00:18.065]                     RNGkind("Mersenne-Twister")
[11:00:18.065]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:18.065]                       inherits = FALSE)
[11:00:18.065]                   }
[11:00:18.065]                   options(future.plan = NULL)
[11:00:18.065]                   if (is.na(NA_character_)) 
[11:00:18.065]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:18.065]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:18.065]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:18.065]                     .init = FALSE)
[11:00:18.065]                 }
[11:00:18.065]             }
[11:00:18.065]         }
[11:00:18.065]     })
[11:00:18.065]     if (FALSE) {
[11:00:18.065]         base::sink(type = "output", split = FALSE)
[11:00:18.065]         if (NA) {
[11:00:18.065]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:18.065]         }
[11:00:18.065]         else {
[11:00:18.065]             ...future.result["stdout"] <- base::list(NULL)
[11:00:18.065]         }
[11:00:18.065]         base::close(...future.stdout)
[11:00:18.065]         ...future.stdout <- NULL
[11:00:18.065]     }
[11:00:18.065]     ...future.result$conditions <- ...future.conditions
[11:00:18.065]     ...future.result$finished <- base::Sys.time()
[11:00:18.065]     ...future.result
[11:00:18.065] }
[11:00:18.067] assign_globals() ...
[11:00:18.067] List of 5
[11:00:18.067]  $ ...future.FUN            :function (x)  
[11:00:18.067]  $ future.call.arguments    : list()
[11:00:18.067]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:18.067]  $ ...future.elements_ii    :List of 2
[11:00:18.067]   ..$ : int 1
[11:00:18.067]   ..$ : int 0
[11:00:18.067]  $ ...future.seeds_ii       : NULL
[11:00:18.067]  $ ...future.globals.maxSize: NULL
[11:00:18.067]  - attr(*, "where")=List of 5
[11:00:18.067]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:18.067]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:18.067]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:18.067]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:18.067]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:18.067]  - attr(*, "resolved")= logi FALSE
[11:00:18.067]  - attr(*, "total_size")= num 5632
[11:00:18.067]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:18.067]  - attr(*, "already-done")= logi TRUE
[11:00:18.072] - reassign environment for ‘...future.FUN’
[11:00:18.072] - copied ‘...future.FUN’ to environment
[11:00:18.072] - copied ‘future.call.arguments’ to environment
[11:00:18.072] - copied ‘...future.elements_ii’ to environment
[11:00:18.072] - copied ‘...future.seeds_ii’ to environment
[11:00:18.072] - copied ‘...future.globals.maxSize’ to environment
[11:00:18.072] assign_globals() ... done
[11:00:18.073] plan(): Setting new future strategy stack:
[11:00:18.073] List of future strategies:
[11:00:18.073] 1. sequential:
[11:00:18.073]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:18.073]    - tweaked: FALSE
[11:00:18.073]    - call: NULL
[11:00:18.073] plan(): nbrOfWorkers() = 1
[11:00:18.575] plan(): Setting new future strategy stack:
[11:00:18.575] List of future strategies:
[11:00:18.575] 1. multicore:
[11:00:18.575]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:18.575]    - tweaked: FALSE
[11:00:18.575]    - call: plan(strategy)
[11:00:18.577] plan(): nbrOfWorkers() = 1
[11:00:18.577] SequentialFuture started (and completed)
[11:00:18.577] - Launch lazy future ... done
[11:00:18.577] run() for ‘SequentialFuture’ ... done
[11:00:18.577] Created future:
[11:00:18.577] SequentialFuture:
[11:00:18.577] Label: ‘future_lapply-1’
[11:00:18.577] Expression:
[11:00:18.577] {
[11:00:18.577]     do.call(function(...) {
[11:00:18.577]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:18.577]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:18.577]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:18.577]             on.exit(options(oopts), add = TRUE)
[11:00:18.577]         }
[11:00:18.577]         {
[11:00:18.577]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:18.577]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:18.577]                 ...future.FUN(...future.X_jj, ...)
[11:00:18.577]             })
[11:00:18.577]         }
[11:00:18.577]     }, args = future.call.arguments)
[11:00:18.577] }
[11:00:18.577] Lazy evaluation: FALSE
[11:00:18.577] Asynchronous evaluation: FALSE
[11:00:18.577] Local evaluation: TRUE
[11:00:18.577] Environment: R_GlobalEnv
[11:00:18.577] Capture standard output: NA
[11:00:18.577] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:18.577] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:18.577] Packages: <none>
[11:00:18.577] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:18.577] Resolved: TRUE
[11:00:18.577] Value: 55 bytes of class ‘list’
[11:00:18.577] Early signaling: FALSE
[11:00:18.577] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:18.577] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:18.578] Chunk #1 of 1 ... DONE
[11:00:18.578] Launching 1 futures (chunks) ... DONE
[11:00:18.578] Resolving 1 futures (chunks) ...
[11:00:18.579] resolve() on list ...
[11:00:18.579]  recursive: 0
[11:00:18.579]  length: 1
[11:00:18.579] 
[11:00:18.579] resolved() for ‘SequentialFuture’ ...
[11:00:18.579] - state: ‘finished’
[11:00:18.579] - run: TRUE
[11:00:18.579] - result: ‘FutureResult’
[11:00:18.579] resolved() for ‘SequentialFuture’ ... done
[11:00:18.579] Future #1
[11:00:18.579] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:18.580] - nx: 1
[11:00:18.580] - relay: TRUE
[11:00:18.580] - stdout: TRUE
[11:00:18.580] - signal: TRUE
[11:00:18.580] - resignal: FALSE
[11:00:18.580] - force: TRUE
[11:00:18.580] - relayed: [n=1] FALSE
[11:00:18.580] - queued futures: [n=1] FALSE
[11:00:18.580]  - until=1
[11:00:18.580]  - relaying element #1
[11:00:18.582] - relayed: [n=1] TRUE
[11:00:18.582] - queued futures: [n=1] TRUE
[11:00:18.582] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:18.582]  length: 0 (resolved future 1)
[11:00:18.582] Relaying remaining futures
[11:00:18.583] signalConditionsASAP(NULL, pos=0) ...
[11:00:18.583] - nx: 1
[11:00:18.583] - relay: TRUE
[11:00:18.583] - stdout: TRUE
[11:00:18.583] - signal: TRUE
[11:00:18.583] - resignal: FALSE
[11:00:18.583] - force: TRUE
[11:00:18.583] - relayed: [n=1] TRUE
[11:00:18.583] - queued futures: [n=1] TRUE
 - flush all
[11:00:18.583] - relayed: [n=1] TRUE
[11:00:18.583] - queued futures: [n=1] TRUE
[11:00:18.583] signalConditionsASAP(NULL, pos=0) ... done
[11:00:18.583] resolve() on list ... DONE
[11:00:18.584]  - Number of value chunks collected: 1
[11:00:18.584] Resolving 1 futures (chunks) ... DONE
[11:00:18.584] Reducing values from 1 chunks ...
[11:00:18.584]  - Number of values collected after concatenation: 2
[11:00:18.584]  - Number of values expected: 2
[11:00:18.584] Reducing values from 1 chunks ... DONE
[11:00:18.584] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[11:00:18.584] future_mapply() ...
[11:00:18.586] Number of chunks: 1
[11:00:18.586] getGlobalsAndPackagesXApply() ...
[11:00:18.586]  - future.globals: TRUE
[11:00:18.586] getGlobalsAndPackages() ...
[11:00:18.586] Searching for globals...
[11:00:18.588] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[11:00:18.588] Searching for globals ... DONE
[11:00:18.588] Resolving globals: FALSE
[11:00:18.588] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[11:00:18.589] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[11:00:18.589] - globals: [1] ‘FUN’
[11:00:18.589] 
[11:00:18.589] getGlobalsAndPackages() ... DONE
[11:00:18.589]  - globals found/used: [n=1] ‘FUN’
[11:00:18.589]  - needed namespaces: [n=0] 
[11:00:18.589] Finding globals ... DONE
[11:00:18.589] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[11:00:18.589] List of 2
[11:00:18.589]  $ ...future.FUN:function (x, y)  
[11:00:18.589]  $ MoreArgs     : NULL
[11:00:18.589]  - attr(*, "where")=List of 2
[11:00:18.589]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:18.589]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[11:00:18.589]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:18.589]  - attr(*, "resolved")= logi FALSE
[11:00:18.589]  - attr(*, "total_size")= num NA
[11:00:18.592] Packages to be attached in all futures: [n=0] 
[11:00:18.592] getGlobalsAndPackagesXApply() ... DONE
[11:00:18.592] Number of futures (= number of chunks): 1
[11:00:18.592] Launching 1 futures (chunks) ...
[11:00:18.592] Chunk #1 of 1 ...
[11:00:18.592]  - Finding globals in '...' for chunk #1 ...
[11:00:18.593] getGlobalsAndPackages() ...
[11:00:18.593] Searching for globals...
[11:00:18.593] 
[11:00:18.593] Searching for globals ... DONE
[11:00:18.593] - globals: [0] <none>
[11:00:18.593] getGlobalsAndPackages() ... DONE
[11:00:18.593]    + additional globals found: [n=0] 
[11:00:18.593]    + additional namespaces needed: [n=0] 
[11:00:18.593]  - Finding globals in '...' for chunk #1 ... DONE
[11:00:18.594]  - seeds: <none>
[11:00:18.594]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:18.594] getGlobalsAndPackages() ...
[11:00:18.594] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:18.594] Resolving globals: FALSE
[11:00:18.594] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[11:00:18.595] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[11:00:18.595] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:18.595] 
[11:00:18.595] getGlobalsAndPackages() ... DONE
[11:00:18.595] run() for ‘Future’ ...
[11:00:18.595] - state: ‘created’
[11:00:18.596] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:18.597] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:18.597] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:18.597]   - Field: ‘label’
[11:00:18.597]   - Field: ‘local’
[11:00:18.597]   - Field: ‘owner’
[11:00:18.598]   - Field: ‘envir’
[11:00:18.598]   - Field: ‘packages’
[11:00:18.598]   - Field: ‘gc’
[11:00:18.598]   - Field: ‘conditions’
[11:00:18.598]   - Field: ‘expr’
[11:00:18.598]   - Field: ‘uuid’
[11:00:18.598]   - Field: ‘seed’
[11:00:18.598]   - Field: ‘version’
[11:00:18.598]   - Field: ‘result’
[11:00:18.598]   - Field: ‘asynchronous’
[11:00:18.598]   - Field: ‘calls’
[11:00:18.598]   - Field: ‘globals’
[11:00:18.599]   - Field: ‘stdout’
[11:00:18.599]   - Field: ‘earlySignal’
[11:00:18.599]   - Field: ‘lazy’
[11:00:18.599]   - Field: ‘state’
[11:00:18.599] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:18.599] - Launch lazy future ...
[11:00:18.599] Packages needed by the future expression (n = 0): <none>
[11:00:18.599] Packages needed by future strategies (n = 0): <none>
[11:00:18.600] {
[11:00:18.600]     {
[11:00:18.600]         {
[11:00:18.600]             ...future.startTime <- base::Sys.time()
[11:00:18.600]             {
[11:00:18.600]                 {
[11:00:18.600]                   {
[11:00:18.600]                     base::local({
[11:00:18.600]                       has_future <- base::requireNamespace("future", 
[11:00:18.600]                         quietly = TRUE)
[11:00:18.600]                       if (has_future) {
[11:00:18.600]                         ns <- base::getNamespace("future")
[11:00:18.600]                         version <- ns[[".package"]][["version"]]
[11:00:18.600]                         if (is.null(version)) 
[11:00:18.600]                           version <- utils::packageVersion("future")
[11:00:18.600]                       }
[11:00:18.600]                       else {
[11:00:18.600]                         version <- NULL
[11:00:18.600]                       }
[11:00:18.600]                       if (!has_future || version < "1.8.0") {
[11:00:18.600]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:18.600]                           "", base::R.version$version.string), 
[11:00:18.600]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:18.600]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:18.600]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:18.600]                             "release", "version")], collapse = " "), 
[11:00:18.600]                           hostname = base::Sys.info()[["nodename"]])
[11:00:18.600]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:18.600]                           info)
[11:00:18.600]                         info <- base::paste(info, collapse = "; ")
[11:00:18.600]                         if (!has_future) {
[11:00:18.600]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:18.600]                             info)
[11:00:18.600]                         }
[11:00:18.600]                         else {
[11:00:18.600]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:18.600]                             info, version)
[11:00:18.600]                         }
[11:00:18.600]                         base::stop(msg)
[11:00:18.600]                       }
[11:00:18.600]                     })
[11:00:18.600]                   }
[11:00:18.600]                   ...future.strategy.old <- future::plan("list")
[11:00:18.600]                   options(future.plan = NULL)
[11:00:18.600]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:18.600]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:18.600]                 }
[11:00:18.600]                 ...future.workdir <- getwd()
[11:00:18.600]             }
[11:00:18.600]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:18.600]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:18.600]         }
[11:00:18.600]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:18.600]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:18.600]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:18.600]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:18.600]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:18.600]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:18.600]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:18.600]             base::names(...future.oldOptions))
[11:00:18.600]     }
[11:00:18.600]     if (FALSE) {
[11:00:18.600]     }
[11:00:18.600]     else {
[11:00:18.600]         if (FALSE) {
[11:00:18.600]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:18.600]                 open = "w")
[11:00:18.600]         }
[11:00:18.600]         else {
[11:00:18.600]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:18.600]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:18.600]         }
[11:00:18.600]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:18.600]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:18.600]             base::sink(type = "output", split = FALSE)
[11:00:18.600]             base::close(...future.stdout)
[11:00:18.600]         }, add = TRUE)
[11:00:18.600]     }
[11:00:18.600]     ...future.frame <- base::sys.nframe()
[11:00:18.600]     ...future.conditions <- base::list()
[11:00:18.600]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:18.600]     if (FALSE) {
[11:00:18.600]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:18.600]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:18.600]     }
[11:00:18.600]     ...future.result <- base::tryCatch({
[11:00:18.600]         base::withCallingHandlers({
[11:00:18.600]             ...future.value <- base::withVisible(base::local({
[11:00:18.600]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:18.600]                 if (!identical(...future.globals.maxSize.org, 
[11:00:18.600]                   ...future.globals.maxSize)) {
[11:00:18.600]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:18.600]                   on.exit(options(oopts), add = TRUE)
[11:00:18.600]                 }
[11:00:18.600]                 {
[11:00:18.600]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:18.600]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:00:18.600]                     USE.NAMES = FALSE)
[11:00:18.600]                   do.call(mapply, args = args)
[11:00:18.600]                 }
[11:00:18.600]             }))
[11:00:18.600]             future::FutureResult(value = ...future.value$value, 
[11:00:18.600]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:18.600]                   ...future.rng), globalenv = if (FALSE) 
[11:00:18.600]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:18.600]                     ...future.globalenv.names))
[11:00:18.600]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:18.600]         }, condition = base::local({
[11:00:18.600]             c <- base::c
[11:00:18.600]             inherits <- base::inherits
[11:00:18.600]             invokeRestart <- base::invokeRestart
[11:00:18.600]             length <- base::length
[11:00:18.600]             list <- base::list
[11:00:18.600]             seq.int <- base::seq.int
[11:00:18.600]             signalCondition <- base::signalCondition
[11:00:18.600]             sys.calls <- base::sys.calls
[11:00:18.600]             `[[` <- base::`[[`
[11:00:18.600]             `+` <- base::`+`
[11:00:18.600]             `<<-` <- base::`<<-`
[11:00:18.600]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:18.600]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:18.600]                   3L)]
[11:00:18.600]             }
[11:00:18.600]             function(cond) {
[11:00:18.600]                 is_error <- inherits(cond, "error")
[11:00:18.600]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:18.600]                   NULL)
[11:00:18.600]                 if (is_error) {
[11:00:18.600]                   sessionInformation <- function() {
[11:00:18.600]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:18.600]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:18.600]                       search = base::search(), system = base::Sys.info())
[11:00:18.600]                   }
[11:00:18.600]                   ...future.conditions[[length(...future.conditions) + 
[11:00:18.600]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:18.600]                     cond$call), session = sessionInformation(), 
[11:00:18.600]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:18.600]                   signalCondition(cond)
[11:00:18.600]                 }
[11:00:18.600]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:18.600]                 "immediateCondition"))) {
[11:00:18.600]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:18.600]                   ...future.conditions[[length(...future.conditions) + 
[11:00:18.600]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:18.600]                   if (TRUE && !signal) {
[11:00:18.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:18.600]                     {
[11:00:18.600]                       inherits <- base::inherits
[11:00:18.600]                       invokeRestart <- base::invokeRestart
[11:00:18.600]                       is.null <- base::is.null
[11:00:18.600]                       muffled <- FALSE
[11:00:18.600]                       if (inherits(cond, "message")) {
[11:00:18.600]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:18.600]                         if (muffled) 
[11:00:18.600]                           invokeRestart("muffleMessage")
[11:00:18.600]                       }
[11:00:18.600]                       else if (inherits(cond, "warning")) {
[11:00:18.600]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:18.600]                         if (muffled) 
[11:00:18.600]                           invokeRestart("muffleWarning")
[11:00:18.600]                       }
[11:00:18.600]                       else if (inherits(cond, "condition")) {
[11:00:18.600]                         if (!is.null(pattern)) {
[11:00:18.600]                           computeRestarts <- base::computeRestarts
[11:00:18.600]                           grepl <- base::grepl
[11:00:18.600]                           restarts <- computeRestarts(cond)
[11:00:18.600]                           for (restart in restarts) {
[11:00:18.600]                             name <- restart$name
[11:00:18.600]                             if (is.null(name)) 
[11:00:18.600]                               next
[11:00:18.600]                             if (!grepl(pattern, name)) 
[11:00:18.600]                               next
[11:00:18.600]                             invokeRestart(restart)
[11:00:18.600]                             muffled <- TRUE
[11:00:18.600]                             break
[11:00:18.600]                           }
[11:00:18.600]                         }
[11:00:18.600]                       }
[11:00:18.600]                       invisible(muffled)
[11:00:18.600]                     }
[11:00:18.600]                     muffleCondition(cond, pattern = "^muffle")
[11:00:18.600]                   }
[11:00:18.600]                 }
[11:00:18.600]                 else {
[11:00:18.600]                   if (TRUE) {
[11:00:18.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:18.600]                     {
[11:00:18.600]                       inherits <- base::inherits
[11:00:18.600]                       invokeRestart <- base::invokeRestart
[11:00:18.600]                       is.null <- base::is.null
[11:00:18.600]                       muffled <- FALSE
[11:00:18.600]                       if (inherits(cond, "message")) {
[11:00:18.600]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:18.600]                         if (muffled) 
[11:00:18.600]                           invokeRestart("muffleMessage")
[11:00:18.600]                       }
[11:00:18.600]                       else if (inherits(cond, "warning")) {
[11:00:18.600]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:18.600]                         if (muffled) 
[11:00:18.600]                           invokeRestart("muffleWarning")
[11:00:18.600]                       }
[11:00:18.600]                       else if (inherits(cond, "condition")) {
[11:00:18.600]                         if (!is.null(pattern)) {
[11:00:18.600]                           computeRestarts <- base::computeRestarts
[11:00:18.600]                           grepl <- base::grepl
[11:00:18.600]                           restarts <- computeRestarts(cond)
[11:00:18.600]                           for (restart in restarts) {
[11:00:18.600]                             name <- restart$name
[11:00:18.600]                             if (is.null(name)) 
[11:00:18.600]                               next
[11:00:18.600]                             if (!grepl(pattern, name)) 
[11:00:18.600]                               next
[11:00:18.600]                             invokeRestart(restart)
[11:00:18.600]                             muffled <- TRUE
[11:00:18.600]                             break
[11:00:18.600]                           }
[11:00:18.600]                         }
[11:00:18.600]                       }
[11:00:18.600]                       invisible(muffled)
[11:00:18.600]                     }
[11:00:18.600]                     muffleCondition(cond, pattern = "^muffle")
[11:00:18.600]                   }
[11:00:18.600]                 }
[11:00:18.600]             }
[11:00:18.600]         }))
[11:00:18.600]     }, error = function(ex) {
[11:00:18.600]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:18.600]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:18.600]                 ...future.rng), started = ...future.startTime, 
[11:00:18.600]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:18.600]             version = "1.8"), class = "FutureResult")
[11:00:18.600]     }, finally = {
[11:00:18.600]         if (!identical(...future.workdir, getwd())) 
[11:00:18.600]             setwd(...future.workdir)
[11:00:18.600]         {
[11:00:18.600]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:18.600]                 ...future.oldOptions$nwarnings <- NULL
[11:00:18.600]             }
[11:00:18.600]             base::options(...future.oldOptions)
[11:00:18.600]             if (.Platform$OS.type == "windows") {
[11:00:18.600]                 old_names <- names(...future.oldEnvVars)
[11:00:18.600]                 envs <- base::Sys.getenv()
[11:00:18.600]                 names <- names(envs)
[11:00:18.600]                 common <- intersect(names, old_names)
[11:00:18.600]                 added <- setdiff(names, old_names)
[11:00:18.600]                 removed <- setdiff(old_names, names)
[11:00:18.600]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:18.600]                   envs[common]]
[11:00:18.600]                 NAMES <- toupper(changed)
[11:00:18.600]                 args <- list()
[11:00:18.600]                 for (kk in seq_along(NAMES)) {
[11:00:18.600]                   name <- changed[[kk]]
[11:00:18.600]                   NAME <- NAMES[[kk]]
[11:00:18.600]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:18.600]                     next
[11:00:18.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:18.600]                 }
[11:00:18.600]                 NAMES <- toupper(added)
[11:00:18.600]                 for (kk in seq_along(NAMES)) {
[11:00:18.600]                   name <- added[[kk]]
[11:00:18.600]                   NAME <- NAMES[[kk]]
[11:00:18.600]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:18.600]                     next
[11:00:18.600]                   args[[name]] <- ""
[11:00:18.600]                 }
[11:00:18.600]                 NAMES <- toupper(removed)
[11:00:18.600]                 for (kk in seq_along(NAMES)) {
[11:00:18.600]                   name <- removed[[kk]]
[11:00:18.600]                   NAME <- NAMES[[kk]]
[11:00:18.600]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:18.600]                     next
[11:00:18.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:18.600]                 }
[11:00:18.600]                 if (length(args) > 0) 
[11:00:18.600]                   base::do.call(base::Sys.setenv, args = args)
[11:00:18.600]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:18.600]             }
[11:00:18.600]             else {
[11:00:18.600]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:18.600]             }
[11:00:18.600]             {
[11:00:18.600]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:18.600]                   0L) {
[11:00:18.600]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:18.600]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:18.600]                   base::options(opts)
[11:00:18.600]                 }
[11:00:18.600]                 {
[11:00:18.600]                   {
[11:00:18.600]                     NULL
[11:00:18.600]                     RNGkind("Mersenne-Twister")
[11:00:18.600]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:18.600]                       inherits = FALSE)
[11:00:18.600]                   }
[11:00:18.600]                   options(future.plan = NULL)
[11:00:18.600]                   if (is.na(NA_character_)) 
[11:00:18.600]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:18.600]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:18.600]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:18.600]                     .init = FALSE)
[11:00:18.600]                 }
[11:00:18.600]             }
[11:00:18.600]         }
[11:00:18.600]     })
[11:00:18.600]     if (TRUE) {
[11:00:18.600]         base::sink(type = "output", split = FALSE)
[11:00:18.600]         if (FALSE) {
[11:00:18.600]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:18.600]         }
[11:00:18.600]         else {
[11:00:18.600]             ...future.result["stdout"] <- base::list(NULL)
[11:00:18.600]         }
[11:00:18.600]         base::close(...future.stdout)
[11:00:18.600]         ...future.stdout <- NULL
[11:00:18.600]     }
[11:00:18.600]     ...future.result$conditions <- ...future.conditions
[11:00:18.600]     ...future.result$finished <- base::Sys.time()
[11:00:18.600]     ...future.result
[11:00:18.600] }
[11:00:18.601] assign_globals() ...
[11:00:18.601] List of 5
[11:00:18.601]  $ ...future.FUN            :function (x, y)  
[11:00:18.601]  $ MoreArgs                 : NULL
[11:00:18.601]  $ ...future.elements_ii    :List of 2
[11:00:18.601]   ..$ :List of 2
[11:00:18.601]   .. ..$ : int 1
[11:00:18.601]   .. ..$ : int 0
[11:00:18.601]   ..$ :List of 2
[11:00:18.601]   .. ..$ : int 0
[11:00:18.601]   .. ..$ : int 1
[11:00:18.601]  $ ...future.seeds_ii       : NULL
[11:00:18.601]  $ ...future.globals.maxSize: NULL
[11:00:18.601]  - attr(*, "where")=List of 5
[11:00:18.601]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:18.601]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[11:00:18.601]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:18.601]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:18.601]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:18.601]  - attr(*, "resolved")= logi FALSE
[11:00:18.601]  - attr(*, "total_size")= num 1242
[11:00:18.601]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:18.601]  - attr(*, "already-done")= logi TRUE
[11:00:18.608] - reassign environment for ‘...future.FUN’
[11:00:18.608] - copied ‘...future.FUN’ to environment
[11:00:18.608] - copied ‘MoreArgs’ to environment
[11:00:18.608] - copied ‘...future.elements_ii’ to environment
[11:00:18.608] - copied ‘...future.seeds_ii’ to environment
[11:00:18.608] - copied ‘...future.globals.maxSize’ to environment
[11:00:18.608] assign_globals() ... done
[11:00:18.609] plan(): Setting new future strategy stack:
[11:00:18.609] List of future strategies:
[11:00:18.609] 1. sequential:
[11:00:18.609]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:18.609]    - tweaked: FALSE
[11:00:18.609]    - call: NULL
[11:00:18.609] plan(): nbrOfWorkers() = 1
[11:00:19.111] plan(): Setting new future strategy stack:
[11:00:19.111] List of future strategies:
[11:00:19.111] 1. multicore:
[11:00:19.111]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:19.111]    - tweaked: FALSE
[11:00:19.111]    - call: plan(strategy)
[11:00:19.113] plan(): nbrOfWorkers() = 1
[11:00:19.113] SequentialFuture started (and completed)
[11:00:19.113] - Launch lazy future ... done
[11:00:19.113] run() for ‘SequentialFuture’ ... done
[11:00:19.113] Created future:
[11:00:19.113] SequentialFuture:
[11:00:19.113] Label: ‘future_mapply-1’
[11:00:19.113] Expression:
[11:00:19.113] {
[11:00:19.113]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:19.113]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:19.113]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:19.113]         on.exit(options(oopts), add = TRUE)
[11:00:19.113]     }
[11:00:19.113]     {
[11:00:19.113]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:19.113]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:00:19.113]         do.call(mapply, args = args)
[11:00:19.113]     }
[11:00:19.113] }
[11:00:19.113] Lazy evaluation: FALSE
[11:00:19.113] Asynchronous evaluation: FALSE
[11:00:19.113] Local evaluation: TRUE
[11:00:19.113] Environment: R_GlobalEnv
[11:00:19.113] Capture standard output: FALSE
[11:00:19.113] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:19.113] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:19.113] Packages: <none>
[11:00:19.113] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:19.113] Resolved: TRUE
[11:00:19.113] Value: 184 bytes of class ‘list’
[11:00:19.113] Early signaling: FALSE
[11:00:19.113] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:19.113] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:19.114] Chunk #1 of 1 ... DONE
[11:00:19.114] Launching 1 futures (chunks) ... DONE
[11:00:19.114] Resolving 1 futures (chunks) ...
[11:00:19.114] resolve() on list ...
[11:00:19.114]  recursive: 0
[11:00:19.114]  length: 1
[11:00:19.115] 
[11:00:19.115] resolved() for ‘SequentialFuture’ ...
[11:00:19.115] - state: ‘finished’
[11:00:19.115] - run: TRUE
[11:00:19.115] - result: ‘FutureResult’
[11:00:19.115] resolved() for ‘SequentialFuture’ ... done
[11:00:19.115] Future #1
[11:00:19.115] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:19.115] - nx: 1
[11:00:19.115] - relay: TRUE
[11:00:19.115] - stdout: TRUE
[11:00:19.116] - signal: TRUE
[11:00:19.116] - resignal: FALSE
[11:00:19.116] - force: TRUE
[11:00:19.116] - relayed: [n=1] FALSE
[11:00:19.116] - queued futures: [n=1] FALSE
[11:00:19.116]  - until=1
[11:00:19.116]  - relaying element #1
[11:00:19.116] - relayed: [n=1] TRUE
[11:00:19.116] - queued futures: [n=1] TRUE
[11:00:19.116] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:19.116]  length: 0 (resolved future 1)
[11:00:19.117] Relaying remaining futures
[11:00:19.117] signalConditionsASAP(NULL, pos=0) ...
[11:00:19.117] - nx: 1
[11:00:19.117] - relay: TRUE
[11:00:19.117] - stdout: TRUE
[11:00:19.117] - signal: TRUE
[11:00:19.117] - resignal: FALSE
[11:00:19.117] - force: TRUE
[11:00:19.117] - relayed: [n=1] TRUE
[11:00:19.117] - queued futures: [n=1] TRUE
 - flush all
[11:00:19.117] - relayed: [n=1] TRUE
[11:00:19.117] - queued futures: [n=1] TRUE
[11:00:19.118] signalConditionsASAP(NULL, pos=0) ... done
[11:00:19.118] resolve() on list ... DONE
[11:00:19.118]  - Number of value chunks collected: 1
[11:00:19.118] Resolving 1 futures (chunks) ... DONE
[11:00:19.118] Reducing values from 1 chunks ...
[11:00:19.118]  - Number of values collected after concatenation: 2
[11:00:19.118]  - Number of values expected: 2
[11:00:19.118] Reducing values from 1 chunks ... DONE
[11:00:19.118] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[11:00:19.119] future_mapply() ...
[11:00:19.120] Number of chunks: 1
[11:00:19.120] getGlobalsAndPackagesXApply() ...
[11:00:19.120]  - future.globals: TRUE
[11:00:19.120] getGlobalsAndPackages() ...
[11:00:19.120] Searching for globals...
[11:00:19.122] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[11:00:19.122] Searching for globals ... DONE
[11:00:19.122] Resolving globals: FALSE
[11:00:19.122] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[11:00:19.123] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[11:00:19.123] - globals: [1] ‘FUN’
[11:00:19.123] 
[11:00:19.123] getGlobalsAndPackages() ... DONE
[11:00:19.123]  - globals found/used: [n=1] ‘FUN’
[11:00:19.123]  - needed namespaces: [n=0] 
[11:00:19.123] Finding globals ... DONE
[11:00:19.124] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[11:00:19.124] List of 2
[11:00:19.124]  $ ...future.FUN:function (x, y)  
[11:00:19.124]  $ MoreArgs     : NULL
[11:00:19.124]  - attr(*, "where")=List of 2
[11:00:19.124]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:19.124]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[11:00:19.124]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:19.124]  - attr(*, "resolved")= logi FALSE
[11:00:19.124]  - attr(*, "total_size")= num NA
[11:00:19.126] Packages to be attached in all futures: [n=0] 
[11:00:19.126] getGlobalsAndPackagesXApply() ... DONE
[11:00:19.126] Number of futures (= number of chunks): 1
[11:00:19.126] Launching 1 futures (chunks) ...
[11:00:19.127] Chunk #1 of 1 ...
[11:00:19.127]  - Finding globals in '...' for chunk #1 ...
[11:00:19.127] getGlobalsAndPackages() ...
[11:00:19.127] Searching for globals...
[11:00:19.127] 
[11:00:19.127] Searching for globals ... DONE
[11:00:19.127] - globals: [0] <none>
[11:00:19.127] getGlobalsAndPackages() ... DONE
[11:00:19.128]    + additional globals found: [n=0] 
[11:00:19.128]    + additional namespaces needed: [n=0] 
[11:00:19.128]  - Finding globals in '...' for chunk #1 ... DONE
[11:00:19.128]  - seeds: <none>
[11:00:19.128]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:19.128] getGlobalsAndPackages() ...
[11:00:19.128] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:19.128] Resolving globals: FALSE
[11:00:19.130] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[11:00:19.131] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[11:00:19.131] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:19.131] 
[11:00:19.131] getGlobalsAndPackages() ... DONE
[11:00:19.131] run() for ‘Future’ ...
[11:00:19.131] - state: ‘created’
[11:00:19.131] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:19.133] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:19.133] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:19.133]   - Field: ‘label’
[11:00:19.133]   - Field: ‘local’
[11:00:19.133]   - Field: ‘owner’
[11:00:19.133]   - Field: ‘envir’
[11:00:19.134]   - Field: ‘packages’
[11:00:19.134]   - Field: ‘gc’
[11:00:19.134]   - Field: ‘conditions’
[11:00:19.134]   - Field: ‘expr’
[11:00:19.134]   - Field: ‘uuid’
[11:00:19.134]   - Field: ‘seed’
[11:00:19.134]   - Field: ‘version’
[11:00:19.134]   - Field: ‘result’
[11:00:19.134]   - Field: ‘asynchronous’
[11:00:19.134]   - Field: ‘calls’
[11:00:19.134]   - Field: ‘globals’
[11:00:19.134]   - Field: ‘stdout’
[11:00:19.135]   - Field: ‘earlySignal’
[11:00:19.135]   - Field: ‘lazy’
[11:00:19.135]   - Field: ‘state’
[11:00:19.135] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:19.135] - Launch lazy future ...
[11:00:19.135] Packages needed by the future expression (n = 0): <none>
[11:00:19.135] Packages needed by future strategies (n = 0): <none>
[11:00:19.136] {
[11:00:19.136]     {
[11:00:19.136]         {
[11:00:19.136]             ...future.startTime <- base::Sys.time()
[11:00:19.136]             {
[11:00:19.136]                 {
[11:00:19.136]                   {
[11:00:19.136]                     base::local({
[11:00:19.136]                       has_future <- base::requireNamespace("future", 
[11:00:19.136]                         quietly = TRUE)
[11:00:19.136]                       if (has_future) {
[11:00:19.136]                         ns <- base::getNamespace("future")
[11:00:19.136]                         version <- ns[[".package"]][["version"]]
[11:00:19.136]                         if (is.null(version)) 
[11:00:19.136]                           version <- utils::packageVersion("future")
[11:00:19.136]                       }
[11:00:19.136]                       else {
[11:00:19.136]                         version <- NULL
[11:00:19.136]                       }
[11:00:19.136]                       if (!has_future || version < "1.8.0") {
[11:00:19.136]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:19.136]                           "", base::R.version$version.string), 
[11:00:19.136]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:19.136]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:19.136]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:19.136]                             "release", "version")], collapse = " "), 
[11:00:19.136]                           hostname = base::Sys.info()[["nodename"]])
[11:00:19.136]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:19.136]                           info)
[11:00:19.136]                         info <- base::paste(info, collapse = "; ")
[11:00:19.136]                         if (!has_future) {
[11:00:19.136]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:19.136]                             info)
[11:00:19.136]                         }
[11:00:19.136]                         else {
[11:00:19.136]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:19.136]                             info, version)
[11:00:19.136]                         }
[11:00:19.136]                         base::stop(msg)
[11:00:19.136]                       }
[11:00:19.136]                     })
[11:00:19.136]                   }
[11:00:19.136]                   ...future.strategy.old <- future::plan("list")
[11:00:19.136]                   options(future.plan = NULL)
[11:00:19.136]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:19.136]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:19.136]                 }
[11:00:19.136]                 ...future.workdir <- getwd()
[11:00:19.136]             }
[11:00:19.136]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:19.136]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:19.136]         }
[11:00:19.136]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:19.136]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:19.136]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:19.136]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:19.136]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:19.136]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:19.136]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:19.136]             base::names(...future.oldOptions))
[11:00:19.136]     }
[11:00:19.136]     if (FALSE) {
[11:00:19.136]     }
[11:00:19.136]     else {
[11:00:19.136]         if (TRUE) {
[11:00:19.136]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:19.136]                 open = "w")
[11:00:19.136]         }
[11:00:19.136]         else {
[11:00:19.136]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:19.136]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:19.136]         }
[11:00:19.136]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:19.136]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:19.136]             base::sink(type = "output", split = FALSE)
[11:00:19.136]             base::close(...future.stdout)
[11:00:19.136]         }, add = TRUE)
[11:00:19.136]     }
[11:00:19.136]     ...future.frame <- base::sys.nframe()
[11:00:19.136]     ...future.conditions <- base::list()
[11:00:19.136]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:19.136]     if (FALSE) {
[11:00:19.136]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:19.136]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:19.136]     }
[11:00:19.136]     ...future.result <- base::tryCatch({
[11:00:19.136]         base::withCallingHandlers({
[11:00:19.136]             ...future.value <- base::withVisible(base::local({
[11:00:19.136]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:19.136]                 if (!identical(...future.globals.maxSize.org, 
[11:00:19.136]                   ...future.globals.maxSize)) {
[11:00:19.136]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:19.136]                   on.exit(options(oopts), add = TRUE)
[11:00:19.136]                 }
[11:00:19.136]                 {
[11:00:19.136]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:19.136]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:00:19.136]                     USE.NAMES = FALSE)
[11:00:19.136]                   do.call(mapply, args = args)
[11:00:19.136]                 }
[11:00:19.136]             }))
[11:00:19.136]             future::FutureResult(value = ...future.value$value, 
[11:00:19.136]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:19.136]                   ...future.rng), globalenv = if (FALSE) 
[11:00:19.136]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:19.136]                     ...future.globalenv.names))
[11:00:19.136]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:19.136]         }, condition = base::local({
[11:00:19.136]             c <- base::c
[11:00:19.136]             inherits <- base::inherits
[11:00:19.136]             invokeRestart <- base::invokeRestart
[11:00:19.136]             length <- base::length
[11:00:19.136]             list <- base::list
[11:00:19.136]             seq.int <- base::seq.int
[11:00:19.136]             signalCondition <- base::signalCondition
[11:00:19.136]             sys.calls <- base::sys.calls
[11:00:19.136]             `[[` <- base::`[[`
[11:00:19.136]             `+` <- base::`+`
[11:00:19.136]             `<<-` <- base::`<<-`
[11:00:19.136]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:19.136]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:19.136]                   3L)]
[11:00:19.136]             }
[11:00:19.136]             function(cond) {
[11:00:19.136]                 is_error <- inherits(cond, "error")
[11:00:19.136]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:19.136]                   NULL)
[11:00:19.136]                 if (is_error) {
[11:00:19.136]                   sessionInformation <- function() {
[11:00:19.136]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:19.136]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:19.136]                       search = base::search(), system = base::Sys.info())
[11:00:19.136]                   }
[11:00:19.136]                   ...future.conditions[[length(...future.conditions) + 
[11:00:19.136]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:19.136]                     cond$call), session = sessionInformation(), 
[11:00:19.136]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:19.136]                   signalCondition(cond)
[11:00:19.136]                 }
[11:00:19.136]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:19.136]                 "immediateCondition"))) {
[11:00:19.136]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:19.136]                   ...future.conditions[[length(...future.conditions) + 
[11:00:19.136]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:19.136]                   if (TRUE && !signal) {
[11:00:19.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:19.136]                     {
[11:00:19.136]                       inherits <- base::inherits
[11:00:19.136]                       invokeRestart <- base::invokeRestart
[11:00:19.136]                       is.null <- base::is.null
[11:00:19.136]                       muffled <- FALSE
[11:00:19.136]                       if (inherits(cond, "message")) {
[11:00:19.136]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:19.136]                         if (muffled) 
[11:00:19.136]                           invokeRestart("muffleMessage")
[11:00:19.136]                       }
[11:00:19.136]                       else if (inherits(cond, "warning")) {
[11:00:19.136]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:19.136]                         if (muffled) 
[11:00:19.136]                           invokeRestart("muffleWarning")
[11:00:19.136]                       }
[11:00:19.136]                       else if (inherits(cond, "condition")) {
[11:00:19.136]                         if (!is.null(pattern)) {
[11:00:19.136]                           computeRestarts <- base::computeRestarts
[11:00:19.136]                           grepl <- base::grepl
[11:00:19.136]                           restarts <- computeRestarts(cond)
[11:00:19.136]                           for (restart in restarts) {
[11:00:19.136]                             name <- restart$name
[11:00:19.136]                             if (is.null(name)) 
[11:00:19.136]                               next
[11:00:19.136]                             if (!grepl(pattern, name)) 
[11:00:19.136]                               next
[11:00:19.136]                             invokeRestart(restart)
[11:00:19.136]                             muffled <- TRUE
[11:00:19.136]                             break
[11:00:19.136]                           }
[11:00:19.136]                         }
[11:00:19.136]                       }
[11:00:19.136]                       invisible(muffled)
[11:00:19.136]                     }
[11:00:19.136]                     muffleCondition(cond, pattern = "^muffle")
[11:00:19.136]                   }
[11:00:19.136]                 }
[11:00:19.136]                 else {
[11:00:19.136]                   if (TRUE) {
[11:00:19.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:19.136]                     {
[11:00:19.136]                       inherits <- base::inherits
[11:00:19.136]                       invokeRestart <- base::invokeRestart
[11:00:19.136]                       is.null <- base::is.null
[11:00:19.136]                       muffled <- FALSE
[11:00:19.136]                       if (inherits(cond, "message")) {
[11:00:19.136]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:19.136]                         if (muffled) 
[11:00:19.136]                           invokeRestart("muffleMessage")
[11:00:19.136]                       }
[11:00:19.136]                       else if (inherits(cond, "warning")) {
[11:00:19.136]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:19.136]                         if (muffled) 
[11:00:19.136]                           invokeRestart("muffleWarning")
[11:00:19.136]                       }
[11:00:19.136]                       else if (inherits(cond, "condition")) {
[11:00:19.136]                         if (!is.null(pattern)) {
[11:00:19.136]                           computeRestarts <- base::computeRestarts
[11:00:19.136]                           grepl <- base::grepl
[11:00:19.136]                           restarts <- computeRestarts(cond)
[11:00:19.136]                           for (restart in restarts) {
[11:00:19.136]                             name <- restart$name
[11:00:19.136]                             if (is.null(name)) 
[11:00:19.136]                               next
[11:00:19.136]                             if (!grepl(pattern, name)) 
[11:00:19.136]                               next
[11:00:19.136]                             invokeRestart(restart)
[11:00:19.136]                             muffled <- TRUE
[11:00:19.136]                             break
[11:00:19.136]                           }
[11:00:19.136]                         }
[11:00:19.136]                       }
[11:00:19.136]                       invisible(muffled)
[11:00:19.136]                     }
[11:00:19.136]                     muffleCondition(cond, pattern = "^muffle")
[11:00:19.136]                   }
[11:00:19.136]                 }
[11:00:19.136]             }
[11:00:19.136]         }))
[11:00:19.136]     }, error = function(ex) {
[11:00:19.136]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:19.136]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:19.136]                 ...future.rng), started = ...future.startTime, 
[11:00:19.136]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:19.136]             version = "1.8"), class = "FutureResult")
[11:00:19.136]     }, finally = {
[11:00:19.136]         if (!identical(...future.workdir, getwd())) 
[11:00:19.136]             setwd(...future.workdir)
[11:00:19.136]         {
[11:00:19.136]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:19.136]                 ...future.oldOptions$nwarnings <- NULL
[11:00:19.136]             }
[11:00:19.136]             base::options(...future.oldOptions)
[11:00:19.136]             if (.Platform$OS.type == "windows") {
[11:00:19.136]                 old_names <- names(...future.oldEnvVars)
[11:00:19.136]                 envs <- base::Sys.getenv()
[11:00:19.136]                 names <- names(envs)
[11:00:19.136]                 common <- intersect(names, old_names)
[11:00:19.136]                 added <- setdiff(names, old_names)
[11:00:19.136]                 removed <- setdiff(old_names, names)
[11:00:19.136]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:19.136]                   envs[common]]
[11:00:19.136]                 NAMES <- toupper(changed)
[11:00:19.136]                 args <- list()
[11:00:19.136]                 for (kk in seq_along(NAMES)) {
[11:00:19.136]                   name <- changed[[kk]]
[11:00:19.136]                   NAME <- NAMES[[kk]]
[11:00:19.136]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:19.136]                     next
[11:00:19.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:19.136]                 }
[11:00:19.136]                 NAMES <- toupper(added)
[11:00:19.136]                 for (kk in seq_along(NAMES)) {
[11:00:19.136]                   name <- added[[kk]]
[11:00:19.136]                   NAME <- NAMES[[kk]]
[11:00:19.136]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:19.136]                     next
[11:00:19.136]                   args[[name]] <- ""
[11:00:19.136]                 }
[11:00:19.136]                 NAMES <- toupper(removed)
[11:00:19.136]                 for (kk in seq_along(NAMES)) {
[11:00:19.136]                   name <- removed[[kk]]
[11:00:19.136]                   NAME <- NAMES[[kk]]
[11:00:19.136]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:19.136]                     next
[11:00:19.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:19.136]                 }
[11:00:19.136]                 if (length(args) > 0) 
[11:00:19.136]                   base::do.call(base::Sys.setenv, args = args)
[11:00:19.136]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:19.136]             }
[11:00:19.136]             else {
[11:00:19.136]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:19.136]             }
[11:00:19.136]             {
[11:00:19.136]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:19.136]                   0L) {
[11:00:19.136]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:19.136]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:19.136]                   base::options(opts)
[11:00:19.136]                 }
[11:00:19.136]                 {
[11:00:19.136]                   {
[11:00:19.136]                     NULL
[11:00:19.136]                     RNGkind("Mersenne-Twister")
[11:00:19.136]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:19.136]                       inherits = FALSE)
[11:00:19.136]                   }
[11:00:19.136]                   options(future.plan = NULL)
[11:00:19.136]                   if (is.na(NA_character_)) 
[11:00:19.136]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:19.136]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:19.136]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:19.136]                     .init = FALSE)
[11:00:19.136]                 }
[11:00:19.136]             }
[11:00:19.136]         }
[11:00:19.136]     })
[11:00:19.136]     if (TRUE) {
[11:00:19.136]         base::sink(type = "output", split = FALSE)
[11:00:19.136]         if (TRUE) {
[11:00:19.136]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:19.136]         }
[11:00:19.136]         else {
[11:00:19.136]             ...future.result["stdout"] <- base::list(NULL)
[11:00:19.136]         }
[11:00:19.136]         base::close(...future.stdout)
[11:00:19.136]         ...future.stdout <- NULL
[11:00:19.136]     }
[11:00:19.136]     ...future.result$conditions <- ...future.conditions
[11:00:19.136]     ...future.result$finished <- base::Sys.time()
[11:00:19.136]     ...future.result
[11:00:19.136] }
[11:00:19.137] assign_globals() ...
[11:00:19.137] List of 5
[11:00:19.137]  $ ...future.FUN            :function (x, y)  
[11:00:19.137]  $ MoreArgs                 : NULL
[11:00:19.137]  $ ...future.elements_ii    :List of 2
[11:00:19.137]   ..$ :List of 2
[11:00:19.137]   .. ..$ : int 1
[11:00:19.137]   .. ..$ : int 0
[11:00:19.137]   ..$ :List of 2
[11:00:19.137]   .. ..$ : int 0
[11:00:19.137]   .. ..$ : int 1
[11:00:19.137]  $ ...future.seeds_ii       : NULL
[11:00:19.137]  $ ...future.globals.maxSize: NULL
[11:00:19.137]  - attr(*, "where")=List of 5
[11:00:19.137]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:19.137]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[11:00:19.137]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:19.137]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:19.137]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:19.137]  - attr(*, "resolved")= logi FALSE
[11:00:19.137]  - attr(*, "total_size")= num 1242
[11:00:19.137]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:19.137]  - attr(*, "already-done")= logi TRUE
[11:00:19.143] - reassign environment for ‘...future.FUN’
[11:00:19.143] - copied ‘...future.FUN’ to environment
[11:00:19.143] - copied ‘MoreArgs’ to environment
[11:00:19.143] - copied ‘...future.elements_ii’ to environment
[11:00:19.143] - copied ‘...future.seeds_ii’ to environment
[11:00:19.143] - copied ‘...future.globals.maxSize’ to environment
[11:00:19.143] assign_globals() ... done
[11:00:19.143] plan(): Setting new future strategy stack:
[11:00:19.144] List of future strategies:
[11:00:19.144] 1. sequential:
[11:00:19.144]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:19.144]    - tweaked: FALSE
[11:00:19.144]    - call: NULL
[11:00:19.144] plan(): nbrOfWorkers() = 1
[11:00:19.646] plan(): Setting new future strategy stack:
[11:00:19.646] List of future strategies:
[11:00:19.646] 1. multicore:
[11:00:19.646]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:19.646]    - tweaked: FALSE
[11:00:19.646]    - call: plan(strategy)
[11:00:19.647] plan(): nbrOfWorkers() = 1
[11:00:19.648] SequentialFuture started (and completed)
[11:00:19.648] - Launch lazy future ... done
[11:00:19.648] run() for ‘SequentialFuture’ ... done
[11:00:19.648] Created future:
[11:00:19.648] SequentialFuture:
[11:00:19.648] Label: ‘future_mapply-1’
[11:00:19.648] Expression:
[11:00:19.648] {
[11:00:19.648]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:19.648]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:19.648]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:19.648]         on.exit(options(oopts), add = TRUE)
[11:00:19.648]     }
[11:00:19.648]     {
[11:00:19.648]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:19.648]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:00:19.648]         do.call(mapply, args = args)
[11:00:19.648]     }
[11:00:19.648] }
[11:00:19.648] Lazy evaluation: FALSE
[11:00:19.648] Asynchronous evaluation: FALSE
[11:00:19.648] Local evaluation: TRUE
[11:00:19.648] Environment: R_GlobalEnv
[11:00:19.648] Capture standard output: TRUE
[11:00:19.648] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:19.648] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:19.648] Packages: <none>
[11:00:19.648] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:19.648] Resolved: TRUE
[11:00:19.648] Value: 184 bytes of class ‘list’
[11:00:19.648] Early signaling: FALSE
[11:00:19.648] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:19.648] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:19.649] Chunk #1 of 1 ... DONE
[11:00:19.649] Launching 1 futures (chunks) ... DONE
[11:00:19.649] Resolving 1 futures (chunks) ...
[11:00:19.649] resolve() on list ...
[11:00:19.649]  recursive: 0
[11:00:19.649]  length: 1
[11:00:19.649] 
[11:00:19.650] resolved() for ‘SequentialFuture’ ...
[11:00:19.650] - state: ‘finished’
[11:00:19.650] - run: TRUE
[11:00:19.650] - result: ‘FutureResult’
[11:00:19.650] resolved() for ‘SequentialFuture’ ... done
[11:00:19.650] Future #1
[11:00:19.650] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:19.650] - nx: 1
[11:00:19.650] - relay: TRUE
[11:00:19.650] - stdout: TRUE
[11:00:19.650] - signal: TRUE
[11:00:19.650] - resignal: FALSE
[11:00:19.651] - force: TRUE
[11:00:19.651] - relayed: [n=1] FALSE
[11:00:19.651] - queued futures: [n=1] FALSE
[11:00:19.651]  - until=1
[11:00:19.651]  - relaying element #1
[11:00:19.651] - relayed: [n=1] TRUE
[11:00:19.651] - queued futures: [n=1] TRUE
[11:00:19.651] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:19.651]  length: 0 (resolved future 1)
[11:00:19.651] Relaying remaining futures
[11:00:19.652] signalConditionsASAP(NULL, pos=0) ...
[11:00:19.652] - nx: 1
[11:00:19.652] - relay: TRUE
[11:00:19.652] - stdout: TRUE
[11:00:19.652] - signal: TRUE
[11:00:19.652] - resignal: FALSE
[11:00:19.652] - force: TRUE
[11:00:19.652] - relayed: [n=1] TRUE
[11:00:19.652] - queued futures: [n=1] TRUE
 - flush all
[11:00:19.652] - relayed: [n=1] TRUE
[11:00:19.652] - queued futures: [n=1] TRUE
[11:00:19.652] signalConditionsASAP(NULL, pos=0) ... done
[11:00:19.653] resolve() on list ... DONE
[11:00:19.653]  - Number of value chunks collected: 1
[11:00:19.653] Resolving 1 futures (chunks) ... DONE
[11:00:19.653] Reducing values from 1 chunks ...
[11:00:19.653]  - Number of values collected after concatenation: 2
[11:00:19.653]  - Number of values expected: 2
[11:00:19.653] Reducing values from 1 chunks ... DONE
[11:00:19.653] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[11:00:19.654] future_mapply() ...
[11:00:19.657] Number of chunks: 1
[11:00:19.657] getGlobalsAndPackagesXApply() ...
[11:00:19.657]  - future.globals: TRUE
[11:00:19.657] getGlobalsAndPackages() ...
[11:00:19.657] Searching for globals...
[11:00:19.658] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[11:00:19.659] Searching for globals ... DONE
[11:00:19.659] Resolving globals: FALSE
[11:00:19.659] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[11:00:19.659] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[11:00:19.660] - globals: [1] ‘FUN’
[11:00:19.660] 
[11:00:19.660] getGlobalsAndPackages() ... DONE
[11:00:19.660]  - globals found/used: [n=1] ‘FUN’
[11:00:19.660]  - needed namespaces: [n=0] 
[11:00:19.660] Finding globals ... DONE
[11:00:19.660] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[11:00:19.660] List of 2
[11:00:19.660]  $ ...future.FUN:function (x, y)  
[11:00:19.660]  $ MoreArgs     : NULL
[11:00:19.660]  - attr(*, "where")=List of 2
[11:00:19.660]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:19.660]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[11:00:19.660]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:19.660]  - attr(*, "resolved")= logi FALSE
[11:00:19.660]  - attr(*, "total_size")= num NA
[11:00:19.663] Packages to be attached in all futures: [n=0] 
[11:00:19.663] getGlobalsAndPackagesXApply() ... DONE
[11:00:19.663] Number of futures (= number of chunks): 1
[11:00:19.663] Launching 1 futures (chunks) ...
[11:00:19.663] Chunk #1 of 1 ...
[11:00:19.663]  - Finding globals in '...' for chunk #1 ...
[11:00:19.663] getGlobalsAndPackages() ...
[11:00:19.664] Searching for globals...
[11:00:19.664] 
[11:00:19.664] Searching for globals ... DONE
[11:00:19.664] - globals: [0] <none>
[11:00:19.664] getGlobalsAndPackages() ... DONE
[11:00:19.664]    + additional globals found: [n=0] 
[11:00:19.664]    + additional namespaces needed: [n=0] 
[11:00:19.664]  - Finding globals in '...' for chunk #1 ... DONE
[11:00:19.664]  - seeds: <none>
[11:00:19.665]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:19.665] getGlobalsAndPackages() ...
[11:00:19.665] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:19.665] Resolving globals: FALSE
[11:00:19.665] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[11:00:19.666] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[11:00:19.666] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:19.666] 
[11:00:19.666] getGlobalsAndPackages() ... DONE
[11:00:19.666] run() for ‘Future’ ...
[11:00:19.666] - state: ‘created’
[11:00:19.666] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:19.668] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:19.668] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:19.668]   - Field: ‘label’
[11:00:19.668]   - Field: ‘local’
[11:00:19.668]   - Field: ‘owner’
[11:00:19.669]   - Field: ‘envir’
[11:00:19.669]   - Field: ‘packages’
[11:00:19.669]   - Field: ‘gc’
[11:00:19.669]   - Field: ‘conditions’
[11:00:19.669]   - Field: ‘expr’
[11:00:19.669]   - Field: ‘uuid’
[11:00:19.669]   - Field: ‘seed’
[11:00:19.669]   - Field: ‘version’
[11:00:19.669]   - Field: ‘result’
[11:00:19.669]   - Field: ‘asynchronous’
[11:00:19.669]   - Field: ‘calls’
[11:00:19.670]   - Field: ‘globals’
[11:00:19.670]   - Field: ‘stdout’
[11:00:19.670]   - Field: ‘earlySignal’
[11:00:19.670]   - Field: ‘lazy’
[11:00:19.670]   - Field: ‘state’
[11:00:19.670] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:19.670] - Launch lazy future ...
[11:00:19.670] Packages needed by the future expression (n = 0): <none>
[11:00:19.670] Packages needed by future strategies (n = 0): <none>
[11:00:19.671] {
[11:00:19.671]     {
[11:00:19.671]         {
[11:00:19.671]             ...future.startTime <- base::Sys.time()
[11:00:19.671]             {
[11:00:19.671]                 {
[11:00:19.671]                   {
[11:00:19.671]                     base::local({
[11:00:19.671]                       has_future <- base::requireNamespace("future", 
[11:00:19.671]                         quietly = TRUE)
[11:00:19.671]                       if (has_future) {
[11:00:19.671]                         ns <- base::getNamespace("future")
[11:00:19.671]                         version <- ns[[".package"]][["version"]]
[11:00:19.671]                         if (is.null(version)) 
[11:00:19.671]                           version <- utils::packageVersion("future")
[11:00:19.671]                       }
[11:00:19.671]                       else {
[11:00:19.671]                         version <- NULL
[11:00:19.671]                       }
[11:00:19.671]                       if (!has_future || version < "1.8.0") {
[11:00:19.671]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:19.671]                           "", base::R.version$version.string), 
[11:00:19.671]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:19.671]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:19.671]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:19.671]                             "release", "version")], collapse = " "), 
[11:00:19.671]                           hostname = base::Sys.info()[["nodename"]])
[11:00:19.671]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:19.671]                           info)
[11:00:19.671]                         info <- base::paste(info, collapse = "; ")
[11:00:19.671]                         if (!has_future) {
[11:00:19.671]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:19.671]                             info)
[11:00:19.671]                         }
[11:00:19.671]                         else {
[11:00:19.671]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:19.671]                             info, version)
[11:00:19.671]                         }
[11:00:19.671]                         base::stop(msg)
[11:00:19.671]                       }
[11:00:19.671]                     })
[11:00:19.671]                   }
[11:00:19.671]                   ...future.strategy.old <- future::plan("list")
[11:00:19.671]                   options(future.plan = NULL)
[11:00:19.671]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:19.671]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:19.671]                 }
[11:00:19.671]                 ...future.workdir <- getwd()
[11:00:19.671]             }
[11:00:19.671]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:19.671]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:19.671]         }
[11:00:19.671]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:19.671]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:19.671]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:19.671]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:19.671]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:19.671]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:19.671]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:19.671]             base::names(...future.oldOptions))
[11:00:19.671]     }
[11:00:19.671]     if (TRUE) {
[11:00:19.671]     }
[11:00:19.671]     else {
[11:00:19.671]         if (NA) {
[11:00:19.671]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:19.671]                 open = "w")
[11:00:19.671]         }
[11:00:19.671]         else {
[11:00:19.671]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:19.671]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:19.671]         }
[11:00:19.671]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:19.671]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:19.671]             base::sink(type = "output", split = FALSE)
[11:00:19.671]             base::close(...future.stdout)
[11:00:19.671]         }, add = TRUE)
[11:00:19.671]     }
[11:00:19.671]     ...future.frame <- base::sys.nframe()
[11:00:19.671]     ...future.conditions <- base::list()
[11:00:19.671]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:19.671]     if (FALSE) {
[11:00:19.671]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:19.671]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:19.671]     }
[11:00:19.671]     ...future.result <- base::tryCatch({
[11:00:19.671]         base::withCallingHandlers({
[11:00:19.671]             ...future.value <- base::withVisible(base::local({
[11:00:19.671]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:19.671]                 if (!identical(...future.globals.maxSize.org, 
[11:00:19.671]                   ...future.globals.maxSize)) {
[11:00:19.671]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:19.671]                   on.exit(options(oopts), add = TRUE)
[11:00:19.671]                 }
[11:00:19.671]                 {
[11:00:19.671]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:19.671]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:00:19.671]                     USE.NAMES = FALSE)
[11:00:19.671]                   do.call(mapply, args = args)
[11:00:19.671]                 }
[11:00:19.671]             }))
[11:00:19.671]             future::FutureResult(value = ...future.value$value, 
[11:00:19.671]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:19.671]                   ...future.rng), globalenv = if (FALSE) 
[11:00:19.671]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:19.671]                     ...future.globalenv.names))
[11:00:19.671]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:19.671]         }, condition = base::local({
[11:00:19.671]             c <- base::c
[11:00:19.671]             inherits <- base::inherits
[11:00:19.671]             invokeRestart <- base::invokeRestart
[11:00:19.671]             length <- base::length
[11:00:19.671]             list <- base::list
[11:00:19.671]             seq.int <- base::seq.int
[11:00:19.671]             signalCondition <- base::signalCondition
[11:00:19.671]             sys.calls <- base::sys.calls
[11:00:19.671]             `[[` <- base::`[[`
[11:00:19.671]             `+` <- base::`+`
[11:00:19.671]             `<<-` <- base::`<<-`
[11:00:19.671]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:19.671]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:19.671]                   3L)]
[11:00:19.671]             }
[11:00:19.671]             function(cond) {
[11:00:19.671]                 is_error <- inherits(cond, "error")
[11:00:19.671]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:19.671]                   NULL)
[11:00:19.671]                 if (is_error) {
[11:00:19.671]                   sessionInformation <- function() {
[11:00:19.671]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:19.671]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:19.671]                       search = base::search(), system = base::Sys.info())
[11:00:19.671]                   }
[11:00:19.671]                   ...future.conditions[[length(...future.conditions) + 
[11:00:19.671]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:19.671]                     cond$call), session = sessionInformation(), 
[11:00:19.671]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:19.671]                   signalCondition(cond)
[11:00:19.671]                 }
[11:00:19.671]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:19.671]                 "immediateCondition"))) {
[11:00:19.671]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:19.671]                   ...future.conditions[[length(...future.conditions) + 
[11:00:19.671]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:19.671]                   if (TRUE && !signal) {
[11:00:19.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:19.671]                     {
[11:00:19.671]                       inherits <- base::inherits
[11:00:19.671]                       invokeRestart <- base::invokeRestart
[11:00:19.671]                       is.null <- base::is.null
[11:00:19.671]                       muffled <- FALSE
[11:00:19.671]                       if (inherits(cond, "message")) {
[11:00:19.671]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:19.671]                         if (muffled) 
[11:00:19.671]                           invokeRestart("muffleMessage")
[11:00:19.671]                       }
[11:00:19.671]                       else if (inherits(cond, "warning")) {
[11:00:19.671]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:19.671]                         if (muffled) 
[11:00:19.671]                           invokeRestart("muffleWarning")
[11:00:19.671]                       }
[11:00:19.671]                       else if (inherits(cond, "condition")) {
[11:00:19.671]                         if (!is.null(pattern)) {
[11:00:19.671]                           computeRestarts <- base::computeRestarts
[11:00:19.671]                           grepl <- base::grepl
[11:00:19.671]                           restarts <- computeRestarts(cond)
[11:00:19.671]                           for (restart in restarts) {
[11:00:19.671]                             name <- restart$name
[11:00:19.671]                             if (is.null(name)) 
[11:00:19.671]                               next
[11:00:19.671]                             if (!grepl(pattern, name)) 
[11:00:19.671]                               next
[11:00:19.671]                             invokeRestart(restart)
[11:00:19.671]                             muffled <- TRUE
[11:00:19.671]                             break
[11:00:19.671]                           }
[11:00:19.671]                         }
[11:00:19.671]                       }
[11:00:19.671]                       invisible(muffled)
[11:00:19.671]                     }
[11:00:19.671]                     muffleCondition(cond, pattern = "^muffle")
[11:00:19.671]                   }
[11:00:19.671]                 }
[11:00:19.671]                 else {
[11:00:19.671]                   if (TRUE) {
[11:00:19.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:19.671]                     {
[11:00:19.671]                       inherits <- base::inherits
[11:00:19.671]                       invokeRestart <- base::invokeRestart
[11:00:19.671]                       is.null <- base::is.null
[11:00:19.671]                       muffled <- FALSE
[11:00:19.671]                       if (inherits(cond, "message")) {
[11:00:19.671]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:19.671]                         if (muffled) 
[11:00:19.671]                           invokeRestart("muffleMessage")
[11:00:19.671]                       }
[11:00:19.671]                       else if (inherits(cond, "warning")) {
[11:00:19.671]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:19.671]                         if (muffled) 
[11:00:19.671]                           invokeRestart("muffleWarning")
[11:00:19.671]                       }
[11:00:19.671]                       else if (inherits(cond, "condition")) {
[11:00:19.671]                         if (!is.null(pattern)) {
[11:00:19.671]                           computeRestarts <- base::computeRestarts
[11:00:19.671]                           grepl <- base::grepl
[11:00:19.671]                           restarts <- computeRestarts(cond)
[11:00:19.671]                           for (restart in restarts) {
[11:00:19.671]                             name <- restart$name
[11:00:19.671]                             if (is.null(name)) 
[11:00:19.671]                               next
[11:00:19.671]                             if (!grepl(pattern, name)) 
[11:00:19.671]                               next
[11:00:19.671]                             invokeRestart(restart)
[11:00:19.671]                             muffled <- TRUE
[11:00:19.671]                             break
[11:00:19.671]                           }
[11:00:19.671]                         }
[11:00:19.671]                       }
[11:00:19.671]                       invisible(muffled)
[11:00:19.671]                     }
[11:00:19.671]                     muffleCondition(cond, pattern = "^muffle")
[11:00:19.671]                   }
[11:00:19.671]                 }
[11:00:19.671]             }
[11:00:19.671]         }))
[11:00:19.671]     }, error = function(ex) {
[11:00:19.671]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:19.671]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:19.671]                 ...future.rng), started = ...future.startTime, 
[11:00:19.671]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:19.671]             version = "1.8"), class = "FutureResult")
[11:00:19.671]     }, finally = {
[11:00:19.671]         if (!identical(...future.workdir, getwd())) 
[11:00:19.671]             setwd(...future.workdir)
[11:00:19.671]         {
[11:00:19.671]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:19.671]                 ...future.oldOptions$nwarnings <- NULL
[11:00:19.671]             }
[11:00:19.671]             base::options(...future.oldOptions)
[11:00:19.671]             if (.Platform$OS.type == "windows") {
[11:00:19.671]                 old_names <- names(...future.oldEnvVars)
[11:00:19.671]                 envs <- base::Sys.getenv()
[11:00:19.671]                 names <- names(envs)
[11:00:19.671]                 common <- intersect(names, old_names)
[11:00:19.671]                 added <- setdiff(names, old_names)
[11:00:19.671]                 removed <- setdiff(old_names, names)
[11:00:19.671]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:19.671]                   envs[common]]
[11:00:19.671]                 NAMES <- toupper(changed)
[11:00:19.671]                 args <- list()
[11:00:19.671]                 for (kk in seq_along(NAMES)) {
[11:00:19.671]                   name <- changed[[kk]]
[11:00:19.671]                   NAME <- NAMES[[kk]]
[11:00:19.671]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:19.671]                     next
[11:00:19.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:19.671]                 }
[11:00:19.671]                 NAMES <- toupper(added)
[11:00:19.671]                 for (kk in seq_along(NAMES)) {
[11:00:19.671]                   name <- added[[kk]]
[11:00:19.671]                   NAME <- NAMES[[kk]]
[11:00:19.671]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:19.671]                     next
[11:00:19.671]                   args[[name]] <- ""
[11:00:19.671]                 }
[11:00:19.671]                 NAMES <- toupper(removed)
[11:00:19.671]                 for (kk in seq_along(NAMES)) {
[11:00:19.671]                   name <- removed[[kk]]
[11:00:19.671]                   NAME <- NAMES[[kk]]
[11:00:19.671]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:19.671]                     next
[11:00:19.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:19.671]                 }
[11:00:19.671]                 if (length(args) > 0) 
[11:00:19.671]                   base::do.call(base::Sys.setenv, args = args)
[11:00:19.671]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:19.671]             }
[11:00:19.671]             else {
[11:00:19.671]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:19.671]             }
[11:00:19.671]             {
[11:00:19.671]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:19.671]                   0L) {
[11:00:19.671]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:19.671]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:19.671]                   base::options(opts)
[11:00:19.671]                 }
[11:00:19.671]                 {
[11:00:19.671]                   {
[11:00:19.671]                     NULL
[11:00:19.671]                     RNGkind("Mersenne-Twister")
[11:00:19.671]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:19.671]                       inherits = FALSE)
[11:00:19.671]                   }
[11:00:19.671]                   options(future.plan = NULL)
[11:00:19.671]                   if (is.na(NA_character_)) 
[11:00:19.671]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:19.671]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:19.671]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:19.671]                     .init = FALSE)
[11:00:19.671]                 }
[11:00:19.671]             }
[11:00:19.671]         }
[11:00:19.671]     })
[11:00:19.671]     if (FALSE) {
[11:00:19.671]         base::sink(type = "output", split = FALSE)
[11:00:19.671]         if (NA) {
[11:00:19.671]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:19.671]         }
[11:00:19.671]         else {
[11:00:19.671]             ...future.result["stdout"] <- base::list(NULL)
[11:00:19.671]         }
[11:00:19.671]         base::close(...future.stdout)
[11:00:19.671]         ...future.stdout <- NULL
[11:00:19.671]     }
[11:00:19.671]     ...future.result$conditions <- ...future.conditions
[11:00:19.671]     ...future.result$finished <- base::Sys.time()
[11:00:19.671]     ...future.result
[11:00:19.671] }
[11:00:19.672] assign_globals() ...
[11:00:19.673] List of 5
[11:00:19.673]  $ ...future.FUN            :function (x, y)  
[11:00:19.673]  $ MoreArgs                 : NULL
[11:00:19.673]  $ ...future.elements_ii    :List of 2
[11:00:19.673]   ..$ :List of 2
[11:00:19.673]   .. ..$ : int 1
[11:00:19.673]   .. ..$ : int 0
[11:00:19.673]   ..$ :List of 2
[11:00:19.673]   .. ..$ : int 0
[11:00:19.673]   .. ..$ : int 1
[11:00:19.673]  $ ...future.seeds_ii       : NULL
[11:00:19.673]  $ ...future.globals.maxSize: NULL
[11:00:19.673]  - attr(*, "where")=List of 5
[11:00:19.673]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:19.673]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[11:00:19.673]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:19.673]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:19.673]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:19.673]  - attr(*, "resolved")= logi FALSE
[11:00:19.673]  - attr(*, "total_size")= num 1242
[11:00:19.673]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:19.673]  - attr(*, "already-done")= logi TRUE
[11:00:19.678] - reassign environment for ‘...future.FUN’
[11:00:19.678] - copied ‘...future.FUN’ to environment
[11:00:19.678] - copied ‘MoreArgs’ to environment
[11:00:19.678] - copied ‘...future.elements_ii’ to environment
[11:00:19.680] - copied ‘...future.seeds_ii’ to environment
[11:00:19.680] - copied ‘...future.globals.maxSize’ to environment
[11:00:19.680] assign_globals() ... done
[11:00:19.681] plan(): Setting new future strategy stack:
[11:00:19.681] List of future strategies:
[11:00:19.681] 1. sequential:
[11:00:19.681]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:19.681]    - tweaked: FALSE
[11:00:19.681]    - call: NULL
[11:00:19.681] plan(): nbrOfWorkers() = 1
[11:00:20.183] plan(): Setting new future strategy stack:
[11:00:20.183] List of future strategies:
[11:00:20.183] 1. multicore:
[11:00:20.183]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:20.183]    - tweaked: FALSE
[11:00:20.183]    - call: plan(strategy)
[11:00:20.185] plan(): nbrOfWorkers() = 1
[11:00:20.185] SequentialFuture started (and completed)
[11:00:20.185] - Launch lazy future ... done
[11:00:20.185] run() for ‘SequentialFuture’ ... done
[11:00:20.185] Created future:
[11:00:20.185] SequentialFuture:
[11:00:20.185] Label: ‘future_mapply-1’
[11:00:20.185] Expression:
[11:00:20.185] {
[11:00:20.185]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:20.185]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:20.185]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:20.185]         on.exit(options(oopts), add = TRUE)
[11:00:20.185]     }
[11:00:20.185]     {
[11:00:20.185]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:20.185]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:00:20.185]         do.call(mapply, args = args)
[11:00:20.185]     }
[11:00:20.185] }
[11:00:20.185] Lazy evaluation: FALSE
[11:00:20.185] Asynchronous evaluation: FALSE
[11:00:20.185] Local evaluation: TRUE
[11:00:20.185] Environment: R_GlobalEnv
[11:00:20.185] Capture standard output: NA
[11:00:20.185] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:20.185] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:20.185] Packages: <none>
[11:00:20.185] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:20.185] Resolved: TRUE
[11:00:20.185] Value: 184 bytes of class ‘list’
[11:00:20.185] Early signaling: FALSE
[11:00:20.185] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:20.185] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:20.186] Chunk #1 of 1 ... DONE
[11:00:20.186] Launching 1 futures (chunks) ... DONE
[11:00:20.186] Resolving 1 futures (chunks) ...
[11:00:20.186] resolve() on list ...
[11:00:20.187]  recursive: 0
[11:00:20.187]  length: 1
[11:00:20.187] 
[11:00:20.187] resolved() for ‘SequentialFuture’ ...
[11:00:20.187] - state: ‘finished’
[11:00:20.187] - run: TRUE
[11:00:20.187] - result: ‘FutureResult’
[11:00:20.187] resolved() for ‘SequentialFuture’ ... done
[11:00:20.187] Future #1
[11:00:20.187] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:20.187] - nx: 1
[11:00:20.188] - relay: TRUE
[11:00:20.188] - stdout: TRUE
[11:00:20.188] - signal: TRUE
[11:00:20.188] - resignal: FALSE
[11:00:20.188] - force: TRUE
[11:00:20.188] - relayed: [n=1] FALSE
[11:00:20.188] - queued futures: [n=1] FALSE
[11:00:20.188]  - until=1
[11:00:20.188]  - relaying element #1
[11:00:20.188] - relayed: [n=1] TRUE
[11:00:20.188] - queued futures: [n=1] TRUE
[11:00:20.189] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:20.189]  length: 0 (resolved future 1)
[11:00:20.189] Relaying remaining futures
[11:00:20.189] signalConditionsASAP(NULL, pos=0) ...
[11:00:20.189] - nx: 1
[11:00:20.189] - relay: TRUE
[11:00:20.189] - stdout: TRUE
[11:00:20.189] - signal: TRUE
[11:00:20.189] - resignal: FALSE
[11:00:20.189] - force: TRUE
[11:00:20.189] - relayed: [n=1] TRUE
[11:00:20.190] - queued futures: [n=1] TRUE
 - flush all
[11:00:20.190] - relayed: [n=1] TRUE
[11:00:20.190] - queued futures: [n=1] TRUE
[11:00:20.190] signalConditionsASAP(NULL, pos=0) ... done
[11:00:20.190] resolve() on list ... DONE
[11:00:20.190]  - Number of value chunks collected: 1
[11:00:20.190] Resolving 1 futures (chunks) ... DONE
[11:00:20.190] Reducing values from 1 chunks ...
[11:00:20.190]  - Number of values collected after concatenation: 2
[11:00:20.190]  - Number of values expected: 2
[11:00:20.190] Reducing values from 1 chunks ... DONE
[11:00:20.191] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[11:00:20.191] plan(): Setting new future strategy stack:
[11:00:20.191] List of future strategies:
[11:00:20.191] 1. multisession:
[11:00:20.191]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:00:20.191]    - tweaked: FALSE
[11:00:20.191]    - call: plan(strategy)
[11:00:20.191] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[11:00:20.192] multisession:
[11:00:20.192] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:00:20.192] - tweaked: FALSE
[11:00:20.192] - call: plan(strategy)
[11:00:20.193] getGlobalsAndPackages() ...
[11:00:20.193] Not searching for globals
[11:00:20.193] - globals: [0] <none>
[11:00:20.194] getGlobalsAndPackages() ... DONE
[11:00:20.194] Packages needed by the future expression (n = 0): <none>
[11:00:20.194] Packages needed by future strategies (n = 0): <none>
[11:00:20.194] {
[11:00:20.194]     {
[11:00:20.194]         {
[11:00:20.194]             ...future.startTime <- base::Sys.time()
[11:00:20.194]             {
[11:00:20.194]                 {
[11:00:20.194]                   {
[11:00:20.194]                     base::local({
[11:00:20.194]                       has_future <- base::requireNamespace("future", 
[11:00:20.194]                         quietly = TRUE)
[11:00:20.194]                       if (has_future) {
[11:00:20.194]                         ns <- base::getNamespace("future")
[11:00:20.194]                         version <- ns[[".package"]][["version"]]
[11:00:20.194]                         if (is.null(version)) 
[11:00:20.194]                           version <- utils::packageVersion("future")
[11:00:20.194]                       }
[11:00:20.194]                       else {
[11:00:20.194]                         version <- NULL
[11:00:20.194]                       }
[11:00:20.194]                       if (!has_future || version < "1.8.0") {
[11:00:20.194]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:20.194]                           "", base::R.version$version.string), 
[11:00:20.194]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:20.194]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:20.194]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:20.194]                             "release", "version")], collapse = " "), 
[11:00:20.194]                           hostname = base::Sys.info()[["nodename"]])
[11:00:20.194]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:20.194]                           info)
[11:00:20.194]                         info <- base::paste(info, collapse = "; ")
[11:00:20.194]                         if (!has_future) {
[11:00:20.194]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:20.194]                             info)
[11:00:20.194]                         }
[11:00:20.194]                         else {
[11:00:20.194]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:20.194]                             info, version)
[11:00:20.194]                         }
[11:00:20.194]                         base::stop(msg)
[11:00:20.194]                       }
[11:00:20.194]                     })
[11:00:20.194]                   }
[11:00:20.194]                   ...future.strategy.old <- future::plan("list")
[11:00:20.194]                   options(future.plan = NULL)
[11:00:20.194]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:20.194]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:20.194]                 }
[11:00:20.194]                 ...future.workdir <- getwd()
[11:00:20.194]             }
[11:00:20.194]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:20.194]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:20.194]         }
[11:00:20.194]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:20.194]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:20.194]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:20.194]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:20.194]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:20.194]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:20.194]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:20.194]             base::names(...future.oldOptions))
[11:00:20.194]     }
[11:00:20.194]     if (FALSE) {
[11:00:20.194]     }
[11:00:20.194]     else {
[11:00:20.194]         if (TRUE) {
[11:00:20.194]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:20.194]                 open = "w")
[11:00:20.194]         }
[11:00:20.194]         else {
[11:00:20.194]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:20.194]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:20.194]         }
[11:00:20.194]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:20.194]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:20.194]             base::sink(type = "output", split = FALSE)
[11:00:20.194]             base::close(...future.stdout)
[11:00:20.194]         }, add = TRUE)
[11:00:20.194]     }
[11:00:20.194]     ...future.frame <- base::sys.nframe()
[11:00:20.194]     ...future.conditions <- base::list()
[11:00:20.194]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:20.194]     if (FALSE) {
[11:00:20.194]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:20.194]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:20.194]     }
[11:00:20.194]     ...future.result <- base::tryCatch({
[11:00:20.194]         base::withCallingHandlers({
[11:00:20.194]             ...future.value <- base::withVisible(base::local(NA))
[11:00:20.194]             future::FutureResult(value = ...future.value$value, 
[11:00:20.194]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:20.194]                   ...future.rng), globalenv = if (FALSE) 
[11:00:20.194]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:20.194]                     ...future.globalenv.names))
[11:00:20.194]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:20.194]         }, condition = base::local({
[11:00:20.194]             c <- base::c
[11:00:20.194]             inherits <- base::inherits
[11:00:20.194]             invokeRestart <- base::invokeRestart
[11:00:20.194]             length <- base::length
[11:00:20.194]             list <- base::list
[11:00:20.194]             seq.int <- base::seq.int
[11:00:20.194]             signalCondition <- base::signalCondition
[11:00:20.194]             sys.calls <- base::sys.calls
[11:00:20.194]             `[[` <- base::`[[`
[11:00:20.194]             `+` <- base::`+`
[11:00:20.194]             `<<-` <- base::`<<-`
[11:00:20.194]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:20.194]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:20.194]                   3L)]
[11:00:20.194]             }
[11:00:20.194]             function(cond) {
[11:00:20.194]                 is_error <- inherits(cond, "error")
[11:00:20.194]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:20.194]                   NULL)
[11:00:20.194]                 if (is_error) {
[11:00:20.194]                   sessionInformation <- function() {
[11:00:20.194]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:20.194]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:20.194]                       search = base::search(), system = base::Sys.info())
[11:00:20.194]                   }
[11:00:20.194]                   ...future.conditions[[length(...future.conditions) + 
[11:00:20.194]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:20.194]                     cond$call), session = sessionInformation(), 
[11:00:20.194]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:20.194]                   signalCondition(cond)
[11:00:20.194]                 }
[11:00:20.194]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:20.194]                 "immediateCondition"))) {
[11:00:20.194]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:20.194]                   ...future.conditions[[length(...future.conditions) + 
[11:00:20.194]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:20.194]                   if (TRUE && !signal) {
[11:00:20.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:20.194]                     {
[11:00:20.194]                       inherits <- base::inherits
[11:00:20.194]                       invokeRestart <- base::invokeRestart
[11:00:20.194]                       is.null <- base::is.null
[11:00:20.194]                       muffled <- FALSE
[11:00:20.194]                       if (inherits(cond, "message")) {
[11:00:20.194]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:20.194]                         if (muffled) 
[11:00:20.194]                           invokeRestart("muffleMessage")
[11:00:20.194]                       }
[11:00:20.194]                       else if (inherits(cond, "warning")) {
[11:00:20.194]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:20.194]                         if (muffled) 
[11:00:20.194]                           invokeRestart("muffleWarning")
[11:00:20.194]                       }
[11:00:20.194]                       else if (inherits(cond, "condition")) {
[11:00:20.194]                         if (!is.null(pattern)) {
[11:00:20.194]                           computeRestarts <- base::computeRestarts
[11:00:20.194]                           grepl <- base::grepl
[11:00:20.194]                           restarts <- computeRestarts(cond)
[11:00:20.194]                           for (restart in restarts) {
[11:00:20.194]                             name <- restart$name
[11:00:20.194]                             if (is.null(name)) 
[11:00:20.194]                               next
[11:00:20.194]                             if (!grepl(pattern, name)) 
[11:00:20.194]                               next
[11:00:20.194]                             invokeRestart(restart)
[11:00:20.194]                             muffled <- TRUE
[11:00:20.194]                             break
[11:00:20.194]                           }
[11:00:20.194]                         }
[11:00:20.194]                       }
[11:00:20.194]                       invisible(muffled)
[11:00:20.194]                     }
[11:00:20.194]                     muffleCondition(cond, pattern = "^muffle")
[11:00:20.194]                   }
[11:00:20.194]                 }
[11:00:20.194]                 else {
[11:00:20.194]                   if (TRUE) {
[11:00:20.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:20.194]                     {
[11:00:20.194]                       inherits <- base::inherits
[11:00:20.194]                       invokeRestart <- base::invokeRestart
[11:00:20.194]                       is.null <- base::is.null
[11:00:20.194]                       muffled <- FALSE
[11:00:20.194]                       if (inherits(cond, "message")) {
[11:00:20.194]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:20.194]                         if (muffled) 
[11:00:20.194]                           invokeRestart("muffleMessage")
[11:00:20.194]                       }
[11:00:20.194]                       else if (inherits(cond, "warning")) {
[11:00:20.194]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:20.194]                         if (muffled) 
[11:00:20.194]                           invokeRestart("muffleWarning")
[11:00:20.194]                       }
[11:00:20.194]                       else if (inherits(cond, "condition")) {
[11:00:20.194]                         if (!is.null(pattern)) {
[11:00:20.194]                           computeRestarts <- base::computeRestarts
[11:00:20.194]                           grepl <- base::grepl
[11:00:20.194]                           restarts <- computeRestarts(cond)
[11:00:20.194]                           for (restart in restarts) {
[11:00:20.194]                             name <- restart$name
[11:00:20.194]                             if (is.null(name)) 
[11:00:20.194]                               next
[11:00:20.194]                             if (!grepl(pattern, name)) 
[11:00:20.194]                               next
[11:00:20.194]                             invokeRestart(restart)
[11:00:20.194]                             muffled <- TRUE
[11:00:20.194]                             break
[11:00:20.194]                           }
[11:00:20.194]                         }
[11:00:20.194]                       }
[11:00:20.194]                       invisible(muffled)
[11:00:20.194]                     }
[11:00:20.194]                     muffleCondition(cond, pattern = "^muffle")
[11:00:20.194]                   }
[11:00:20.194]                 }
[11:00:20.194]             }
[11:00:20.194]         }))
[11:00:20.194]     }, error = function(ex) {
[11:00:20.194]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:20.194]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:20.194]                 ...future.rng), started = ...future.startTime, 
[11:00:20.194]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:20.194]             version = "1.8"), class = "FutureResult")
[11:00:20.194]     }, finally = {
[11:00:20.194]         if (!identical(...future.workdir, getwd())) 
[11:00:20.194]             setwd(...future.workdir)
[11:00:20.194]         {
[11:00:20.194]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:20.194]                 ...future.oldOptions$nwarnings <- NULL
[11:00:20.194]             }
[11:00:20.194]             base::options(...future.oldOptions)
[11:00:20.194]             if (.Platform$OS.type == "windows") {
[11:00:20.194]                 old_names <- names(...future.oldEnvVars)
[11:00:20.194]                 envs <- base::Sys.getenv()
[11:00:20.194]                 names <- names(envs)
[11:00:20.194]                 common <- intersect(names, old_names)
[11:00:20.194]                 added <- setdiff(names, old_names)
[11:00:20.194]                 removed <- setdiff(old_names, names)
[11:00:20.194]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:20.194]                   envs[common]]
[11:00:20.194]                 NAMES <- toupper(changed)
[11:00:20.194]                 args <- list()
[11:00:20.194]                 for (kk in seq_along(NAMES)) {
[11:00:20.194]                   name <- changed[[kk]]
[11:00:20.194]                   NAME <- NAMES[[kk]]
[11:00:20.194]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:20.194]                     next
[11:00:20.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:20.194]                 }
[11:00:20.194]                 NAMES <- toupper(added)
[11:00:20.194]                 for (kk in seq_along(NAMES)) {
[11:00:20.194]                   name <- added[[kk]]
[11:00:20.194]                   NAME <- NAMES[[kk]]
[11:00:20.194]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:20.194]                     next
[11:00:20.194]                   args[[name]] <- ""
[11:00:20.194]                 }
[11:00:20.194]                 NAMES <- toupper(removed)
[11:00:20.194]                 for (kk in seq_along(NAMES)) {
[11:00:20.194]                   name <- removed[[kk]]
[11:00:20.194]                   NAME <- NAMES[[kk]]
[11:00:20.194]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:20.194]                     next
[11:00:20.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:20.194]                 }
[11:00:20.194]                 if (length(args) > 0) 
[11:00:20.194]                   base::do.call(base::Sys.setenv, args = args)
[11:00:20.194]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:20.194]             }
[11:00:20.194]             else {
[11:00:20.194]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:20.194]             }
[11:00:20.194]             {
[11:00:20.194]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:20.194]                   0L) {
[11:00:20.194]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:20.194]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:20.194]                   base::options(opts)
[11:00:20.194]                 }
[11:00:20.194]                 {
[11:00:20.194]                   {
[11:00:20.194]                     NULL
[11:00:20.194]                     RNGkind("Mersenne-Twister")
[11:00:20.194]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:20.194]                       inherits = FALSE)
[11:00:20.194]                   }
[11:00:20.194]                   options(future.plan = NULL)
[11:00:20.194]                   if (is.na(NA_character_)) 
[11:00:20.194]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:20.194]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:20.194]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:20.194]                     .init = FALSE)
[11:00:20.194]                 }
[11:00:20.194]             }
[11:00:20.194]         }
[11:00:20.194]     })
[11:00:20.194]     if (TRUE) {
[11:00:20.194]         base::sink(type = "output", split = FALSE)
[11:00:20.194]         if (TRUE) {
[11:00:20.194]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:20.194]         }
[11:00:20.194]         else {
[11:00:20.194]             ...future.result["stdout"] <- base::list(NULL)
[11:00:20.194]         }
[11:00:20.194]         base::close(...future.stdout)
[11:00:20.194]         ...future.stdout <- NULL
[11:00:20.194]     }
[11:00:20.194]     ...future.result$conditions <- ...future.conditions
[11:00:20.194]     ...future.result$finished <- base::Sys.time()
[11:00:20.194]     ...future.result
[11:00:20.194] }
[11:00:20.196] plan(): Setting new future strategy stack:
[11:00:20.196] List of future strategies:
[11:00:20.196] 1. sequential:
[11:00:20.196]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:20.196]    - tweaked: FALSE
[11:00:20.196]    - call: NULL
[11:00:20.197] plan(): nbrOfWorkers() = 1
[11:00:20.198] plan(): Setting new future strategy stack:
[11:00:20.198] List of future strategies:
[11:00:20.198] 1. multisession:
[11:00:20.198]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:00:20.198]    - tweaked: FALSE
[11:00:20.198]    - call: plan(strategy)
[11:00:20.199] plan(): nbrOfWorkers() = 1
[11:00:20.199] SequentialFuture started (and completed)
[11:00:20.200] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[11:00:20.201] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[11:00:20.201] future_lapply() ...
[11:00:20.203] Number of chunks: 1
[11:00:20.203] getGlobalsAndPackagesXApply() ...
[11:00:20.203]  - future.globals: TRUE
[11:00:20.203] getGlobalsAndPackages() ...
[11:00:20.203] Searching for globals...
[11:00:20.204] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[11:00:20.205] Searching for globals ... DONE
[11:00:20.205] Resolving globals: FALSE
[11:00:20.205] The total size of the 1 globals is 841 bytes (841 bytes)
[11:00:20.205] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[11:00:20.206] - globals: [1] ‘FUN’
[11:00:20.206] 
[11:00:20.206] getGlobalsAndPackages() ... DONE
[11:00:20.206]  - globals found/used: [n=1] ‘FUN’
[11:00:20.206]  - needed namespaces: [n=0] 
[11:00:20.206] Finding globals ... DONE
[11:00:20.206]  - use_args: TRUE
[11:00:20.206]  - Getting '...' globals ...
[11:00:20.206] resolve() on list ...
[11:00:20.207]  recursive: 0
[11:00:20.232]  length: 1
[11:00:20.233]  elements: ‘...’
[11:00:20.233]  length: 0 (resolved future 1)
[11:00:20.233] resolve() on list ... DONE
[11:00:20.233]    - '...' content: [n=0] 
[11:00:20.233] List of 1
[11:00:20.233]  $ ...: list()
[11:00:20.233]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:20.233]  - attr(*, "where")=List of 1
[11:00:20.233]   ..$ ...:<environment: 0x55ceb3a83b18> 
[11:00:20.233]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:20.233]  - attr(*, "resolved")= logi TRUE
[11:00:20.233]  - attr(*, "total_size")= num NA
[11:00:20.236]  - Getting '...' globals ... DONE
[11:00:20.236] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[11:00:20.236] List of 2
[11:00:20.236]  $ ...future.FUN:function (x)  
[11:00:20.236]  $ ...          : list()
[11:00:20.236]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:20.236]  - attr(*, "where")=List of 2
[11:00:20.236]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:20.236]   ..$ ...          :<environment: 0x55ceb3a83b18> 
[11:00:20.236]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:20.236]  - attr(*, "resolved")= logi FALSE
[11:00:20.236]  - attr(*, "total_size")= num 5632
[11:00:20.239] Packages to be attached in all futures: [n=0] 
[11:00:20.239] getGlobalsAndPackagesXApply() ... DONE
[11:00:20.239] Number of futures (= number of chunks): 1
[11:00:20.239] Launching 1 futures (chunks) ...
[11:00:20.239] Chunk #1 of 1 ...
[11:00:20.239]  - Finding globals in 'X' for chunk #1 ...
[11:00:20.239] getGlobalsAndPackages() ...
[11:00:20.239] Searching for globals...
[11:00:20.240] 
[11:00:20.240] Searching for globals ... DONE
[11:00:20.240] - globals: [0] <none>
[11:00:20.240] getGlobalsAndPackages() ... DONE
[11:00:20.240]    + additional globals found: [n=0] 
[11:00:20.240]    + additional namespaces needed: [n=0] 
[11:00:20.240]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:20.240]  - seeds: <none>
[11:00:20.240]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:20.240] getGlobalsAndPackages() ...
[11:00:20.240] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:20.240] Resolving globals: FALSE
[11:00:20.241] Tweak future expression to call with '...' arguments ...
[11:00:20.241] {
[11:00:20.241]     do.call(function(...) {
[11:00:20.241]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:20.241]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:20.241]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:20.241]             on.exit(options(oopts), add = TRUE)
[11:00:20.241]         }
[11:00:20.241]         {
[11:00:20.241]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:20.241]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:20.241]                 ...future.FUN(...future.X_jj, ...)
[11:00:20.241]             })
[11:00:20.241]         }
[11:00:20.241]     }, args = future.call.arguments)
[11:00:20.241] }
[11:00:20.241] Tweak future expression to call with '...' arguments ... DONE
[11:00:20.241] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:20.241] 
[11:00:20.241] getGlobalsAndPackages() ... DONE
[11:00:20.242] run() for ‘Future’ ...
[11:00:20.242] - state: ‘created’
[11:00:20.242] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:20.243] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:20.243] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:20.244]   - Field: ‘label’
[11:00:20.244]   - Field: ‘local’
[11:00:20.244]   - Field: ‘owner’
[11:00:20.244]   - Field: ‘envir’
[11:00:20.244]   - Field: ‘packages’
[11:00:20.244]   - Field: ‘gc’
[11:00:20.244]   - Field: ‘conditions’
[11:00:20.244]   - Field: ‘expr’
[11:00:20.244]   - Field: ‘uuid’
[11:00:20.244]   - Field: ‘seed’
[11:00:20.244]   - Field: ‘version’
[11:00:20.244]   - Field: ‘result’
[11:00:20.245]   - Field: ‘asynchronous’
[11:00:20.245]   - Field: ‘calls’
[11:00:20.245]   - Field: ‘globals’
[11:00:20.245]   - Field: ‘stdout’
[11:00:20.245]   - Field: ‘earlySignal’
[11:00:20.245]   - Field: ‘lazy’
[11:00:20.245]   - Field: ‘state’
[11:00:20.245] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:20.245] - Launch lazy future ...
[11:00:20.245] Packages needed by the future expression (n = 0): <none>
[11:00:20.245] Packages needed by future strategies (n = 0): <none>
[11:00:20.246] {
[11:00:20.246]     {
[11:00:20.246]         {
[11:00:20.246]             ...future.startTime <- base::Sys.time()
[11:00:20.246]             {
[11:00:20.246]                 {
[11:00:20.246]                   {
[11:00:20.246]                     base::local({
[11:00:20.246]                       has_future <- base::requireNamespace("future", 
[11:00:20.246]                         quietly = TRUE)
[11:00:20.246]                       if (has_future) {
[11:00:20.246]                         ns <- base::getNamespace("future")
[11:00:20.246]                         version <- ns[[".package"]][["version"]]
[11:00:20.246]                         if (is.null(version)) 
[11:00:20.246]                           version <- utils::packageVersion("future")
[11:00:20.246]                       }
[11:00:20.246]                       else {
[11:00:20.246]                         version <- NULL
[11:00:20.246]                       }
[11:00:20.246]                       if (!has_future || version < "1.8.0") {
[11:00:20.246]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:20.246]                           "", base::R.version$version.string), 
[11:00:20.246]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:20.246]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:20.246]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:20.246]                             "release", "version")], collapse = " "), 
[11:00:20.246]                           hostname = base::Sys.info()[["nodename"]])
[11:00:20.246]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:20.246]                           info)
[11:00:20.246]                         info <- base::paste(info, collapse = "; ")
[11:00:20.246]                         if (!has_future) {
[11:00:20.246]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:20.246]                             info)
[11:00:20.246]                         }
[11:00:20.246]                         else {
[11:00:20.246]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:20.246]                             info, version)
[11:00:20.246]                         }
[11:00:20.246]                         base::stop(msg)
[11:00:20.246]                       }
[11:00:20.246]                     })
[11:00:20.246]                   }
[11:00:20.246]                   ...future.strategy.old <- future::plan("list")
[11:00:20.246]                   options(future.plan = NULL)
[11:00:20.246]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:20.246]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:20.246]                 }
[11:00:20.246]                 ...future.workdir <- getwd()
[11:00:20.246]             }
[11:00:20.246]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:20.246]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:20.246]         }
[11:00:20.246]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:20.246]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:20.246]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:20.246]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:20.246]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:20.246]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:20.246]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:20.246]             base::names(...future.oldOptions))
[11:00:20.246]     }
[11:00:20.246]     if (FALSE) {
[11:00:20.246]     }
[11:00:20.246]     else {
[11:00:20.246]         if (FALSE) {
[11:00:20.246]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:20.246]                 open = "w")
[11:00:20.246]         }
[11:00:20.246]         else {
[11:00:20.246]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:20.246]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:20.246]         }
[11:00:20.246]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:20.246]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:20.246]             base::sink(type = "output", split = FALSE)
[11:00:20.246]             base::close(...future.stdout)
[11:00:20.246]         }, add = TRUE)
[11:00:20.246]     }
[11:00:20.246]     ...future.frame <- base::sys.nframe()
[11:00:20.246]     ...future.conditions <- base::list()
[11:00:20.246]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:20.246]     if (FALSE) {
[11:00:20.246]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:20.246]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:20.246]     }
[11:00:20.246]     ...future.result <- base::tryCatch({
[11:00:20.246]         base::withCallingHandlers({
[11:00:20.246]             ...future.value <- base::withVisible(base::local({
[11:00:20.246]                 do.call(function(...) {
[11:00:20.246]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:20.246]                   if (!identical(...future.globals.maxSize.org, 
[11:00:20.246]                     ...future.globals.maxSize)) {
[11:00:20.246]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:20.246]                     on.exit(options(oopts), add = TRUE)
[11:00:20.246]                   }
[11:00:20.246]                   {
[11:00:20.246]                     lapply(seq_along(...future.elements_ii), 
[11:00:20.246]                       FUN = function(jj) {
[11:00:20.246]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:20.246]                         ...future.FUN(...future.X_jj, ...)
[11:00:20.246]                       })
[11:00:20.246]                   }
[11:00:20.246]                 }, args = future.call.arguments)
[11:00:20.246]             }))
[11:00:20.246]             future::FutureResult(value = ...future.value$value, 
[11:00:20.246]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:20.246]                   ...future.rng), globalenv = if (FALSE) 
[11:00:20.246]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:20.246]                     ...future.globalenv.names))
[11:00:20.246]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:20.246]         }, condition = base::local({
[11:00:20.246]             c <- base::c
[11:00:20.246]             inherits <- base::inherits
[11:00:20.246]             invokeRestart <- base::invokeRestart
[11:00:20.246]             length <- base::length
[11:00:20.246]             list <- base::list
[11:00:20.246]             seq.int <- base::seq.int
[11:00:20.246]             signalCondition <- base::signalCondition
[11:00:20.246]             sys.calls <- base::sys.calls
[11:00:20.246]             `[[` <- base::`[[`
[11:00:20.246]             `+` <- base::`+`
[11:00:20.246]             `<<-` <- base::`<<-`
[11:00:20.246]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:20.246]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:20.246]                   3L)]
[11:00:20.246]             }
[11:00:20.246]             function(cond) {
[11:00:20.246]                 is_error <- inherits(cond, "error")
[11:00:20.246]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:20.246]                   NULL)
[11:00:20.246]                 if (is_error) {
[11:00:20.246]                   sessionInformation <- function() {
[11:00:20.246]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:20.246]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:20.246]                       search = base::search(), system = base::Sys.info())
[11:00:20.246]                   }
[11:00:20.246]                   ...future.conditions[[length(...future.conditions) + 
[11:00:20.246]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:20.246]                     cond$call), session = sessionInformation(), 
[11:00:20.246]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:20.246]                   signalCondition(cond)
[11:00:20.246]                 }
[11:00:20.246]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:20.246]                 "immediateCondition"))) {
[11:00:20.246]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:20.246]                   ...future.conditions[[length(...future.conditions) + 
[11:00:20.246]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:20.246]                   if (TRUE && !signal) {
[11:00:20.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:20.246]                     {
[11:00:20.246]                       inherits <- base::inherits
[11:00:20.246]                       invokeRestart <- base::invokeRestart
[11:00:20.246]                       is.null <- base::is.null
[11:00:20.246]                       muffled <- FALSE
[11:00:20.246]                       if (inherits(cond, "message")) {
[11:00:20.246]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:20.246]                         if (muffled) 
[11:00:20.246]                           invokeRestart("muffleMessage")
[11:00:20.246]                       }
[11:00:20.246]                       else if (inherits(cond, "warning")) {
[11:00:20.246]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:20.246]                         if (muffled) 
[11:00:20.246]                           invokeRestart("muffleWarning")
[11:00:20.246]                       }
[11:00:20.246]                       else if (inherits(cond, "condition")) {
[11:00:20.246]                         if (!is.null(pattern)) {
[11:00:20.246]                           computeRestarts <- base::computeRestarts
[11:00:20.246]                           grepl <- base::grepl
[11:00:20.246]                           restarts <- computeRestarts(cond)
[11:00:20.246]                           for (restart in restarts) {
[11:00:20.246]                             name <- restart$name
[11:00:20.246]                             if (is.null(name)) 
[11:00:20.246]                               next
[11:00:20.246]                             if (!grepl(pattern, name)) 
[11:00:20.246]                               next
[11:00:20.246]                             invokeRestart(restart)
[11:00:20.246]                             muffled <- TRUE
[11:00:20.246]                             break
[11:00:20.246]                           }
[11:00:20.246]                         }
[11:00:20.246]                       }
[11:00:20.246]                       invisible(muffled)
[11:00:20.246]                     }
[11:00:20.246]                     muffleCondition(cond, pattern = "^muffle")
[11:00:20.246]                   }
[11:00:20.246]                 }
[11:00:20.246]                 else {
[11:00:20.246]                   if (TRUE) {
[11:00:20.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:20.246]                     {
[11:00:20.246]                       inherits <- base::inherits
[11:00:20.246]                       invokeRestart <- base::invokeRestart
[11:00:20.246]                       is.null <- base::is.null
[11:00:20.246]                       muffled <- FALSE
[11:00:20.246]                       if (inherits(cond, "message")) {
[11:00:20.246]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:20.246]                         if (muffled) 
[11:00:20.246]                           invokeRestart("muffleMessage")
[11:00:20.246]                       }
[11:00:20.246]                       else if (inherits(cond, "warning")) {
[11:00:20.246]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:20.246]                         if (muffled) 
[11:00:20.246]                           invokeRestart("muffleWarning")
[11:00:20.246]                       }
[11:00:20.246]                       else if (inherits(cond, "condition")) {
[11:00:20.246]                         if (!is.null(pattern)) {
[11:00:20.246]                           computeRestarts <- base::computeRestarts
[11:00:20.246]                           grepl <- base::grepl
[11:00:20.246]                           restarts <- computeRestarts(cond)
[11:00:20.246]                           for (restart in restarts) {
[11:00:20.246]                             name <- restart$name
[11:00:20.246]                             if (is.null(name)) 
[11:00:20.246]                               next
[11:00:20.246]                             if (!grepl(pattern, name)) 
[11:00:20.246]                               next
[11:00:20.246]                             invokeRestart(restart)
[11:00:20.246]                             muffled <- TRUE
[11:00:20.246]                             break
[11:00:20.246]                           }
[11:00:20.246]                         }
[11:00:20.246]                       }
[11:00:20.246]                       invisible(muffled)
[11:00:20.246]                     }
[11:00:20.246]                     muffleCondition(cond, pattern = "^muffle")
[11:00:20.246]                   }
[11:00:20.246]                 }
[11:00:20.246]             }
[11:00:20.246]         }))
[11:00:20.246]     }, error = function(ex) {
[11:00:20.246]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:20.246]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:20.246]                 ...future.rng), started = ...future.startTime, 
[11:00:20.246]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:20.246]             version = "1.8"), class = "FutureResult")
[11:00:20.246]     }, finally = {
[11:00:20.246]         if (!identical(...future.workdir, getwd())) 
[11:00:20.246]             setwd(...future.workdir)
[11:00:20.246]         {
[11:00:20.246]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:20.246]                 ...future.oldOptions$nwarnings <- NULL
[11:00:20.246]             }
[11:00:20.246]             base::options(...future.oldOptions)
[11:00:20.246]             if (.Platform$OS.type == "windows") {
[11:00:20.246]                 old_names <- names(...future.oldEnvVars)
[11:00:20.246]                 envs <- base::Sys.getenv()
[11:00:20.246]                 names <- names(envs)
[11:00:20.246]                 common <- intersect(names, old_names)
[11:00:20.246]                 added <- setdiff(names, old_names)
[11:00:20.246]                 removed <- setdiff(old_names, names)
[11:00:20.246]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:20.246]                   envs[common]]
[11:00:20.246]                 NAMES <- toupper(changed)
[11:00:20.246]                 args <- list()
[11:00:20.246]                 for (kk in seq_along(NAMES)) {
[11:00:20.246]                   name <- changed[[kk]]
[11:00:20.246]                   NAME <- NAMES[[kk]]
[11:00:20.246]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:20.246]                     next
[11:00:20.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:20.246]                 }
[11:00:20.246]                 NAMES <- toupper(added)
[11:00:20.246]                 for (kk in seq_along(NAMES)) {
[11:00:20.246]                   name <- added[[kk]]
[11:00:20.246]                   NAME <- NAMES[[kk]]
[11:00:20.246]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:20.246]                     next
[11:00:20.246]                   args[[name]] <- ""
[11:00:20.246]                 }
[11:00:20.246]                 NAMES <- toupper(removed)
[11:00:20.246]                 for (kk in seq_along(NAMES)) {
[11:00:20.246]                   name <- removed[[kk]]
[11:00:20.246]                   NAME <- NAMES[[kk]]
[11:00:20.246]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:20.246]                     next
[11:00:20.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:20.246]                 }
[11:00:20.246]                 if (length(args) > 0) 
[11:00:20.246]                   base::do.call(base::Sys.setenv, args = args)
[11:00:20.246]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:20.246]             }
[11:00:20.246]             else {
[11:00:20.246]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:20.246]             }
[11:00:20.246]             {
[11:00:20.246]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:20.246]                   0L) {
[11:00:20.246]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:20.246]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:20.246]                   base::options(opts)
[11:00:20.246]                 }
[11:00:20.246]                 {
[11:00:20.246]                   {
[11:00:20.246]                     NULL
[11:00:20.246]                     RNGkind("Mersenne-Twister")
[11:00:20.246]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:20.246]                       inherits = FALSE)
[11:00:20.246]                   }
[11:00:20.246]                   options(future.plan = NULL)
[11:00:20.246]                   if (is.na(NA_character_)) 
[11:00:20.246]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:20.246]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:20.246]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:20.246]                     .init = FALSE)
[11:00:20.246]                 }
[11:00:20.246]             }
[11:00:20.246]         }
[11:00:20.246]     })
[11:00:20.246]     if (TRUE) {
[11:00:20.246]         base::sink(type = "output", split = FALSE)
[11:00:20.246]         if (FALSE) {
[11:00:20.246]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:20.246]         }
[11:00:20.246]         else {
[11:00:20.246]             ...future.result["stdout"] <- base::list(NULL)
[11:00:20.246]         }
[11:00:20.246]         base::close(...future.stdout)
[11:00:20.246]         ...future.stdout <- NULL
[11:00:20.246]     }
[11:00:20.246]     ...future.result$conditions <- ...future.conditions
[11:00:20.246]     ...future.result$finished <- base::Sys.time()
[11:00:20.246]     ...future.result
[11:00:20.246] }
[11:00:20.248] assign_globals() ...
[11:00:20.248] List of 5
[11:00:20.248]  $ ...future.FUN            :function (x)  
[11:00:20.248]  $ future.call.arguments    : list()
[11:00:20.248]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:20.248]  $ ...future.elements_ii    :List of 2
[11:00:20.248]   ..$ : int 1
[11:00:20.248]   ..$ : int 0
[11:00:20.248]  $ ...future.seeds_ii       : NULL
[11:00:20.248]  $ ...future.globals.maxSize: NULL
[11:00:20.248]  - attr(*, "where")=List of 5
[11:00:20.248]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:20.248]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:20.248]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:20.248]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:20.248]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:20.248]  - attr(*, "resolved")= logi FALSE
[11:00:20.248]  - attr(*, "total_size")= num 5632
[11:00:20.248]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:20.248]  - attr(*, "already-done")= logi TRUE
[11:00:20.252] - reassign environment for ‘...future.FUN’
[11:00:20.252] - copied ‘...future.FUN’ to environment
[11:00:20.253] - copied ‘future.call.arguments’ to environment
[11:00:20.253] - copied ‘...future.elements_ii’ to environment
[11:00:20.253] - copied ‘...future.seeds_ii’ to environment
[11:00:20.253] - copied ‘...future.globals.maxSize’ to environment
[11:00:20.253] assign_globals() ... done
[11:00:20.253] plan(): Setting new future strategy stack:
[11:00:20.253] List of future strategies:
[11:00:20.253] 1. sequential:
[11:00:20.253]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:20.253]    - tweaked: FALSE
[11:00:20.253]    - call: NULL
[11:00:20.254] plan(): nbrOfWorkers() = 1
[11:00:20.755] plan(): Setting new future strategy stack:
[11:00:20.756] List of future strategies:
[11:00:20.756] 1. multisession:
[11:00:20.756]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:00:20.756]    - tweaked: FALSE
[11:00:20.756]    - call: plan(strategy)
[11:00:20.757] plan(): nbrOfWorkers() = 1
[11:00:20.758] SequentialFuture started (and completed)
[11:00:20.758] - Launch lazy future ... done
[11:00:20.758] run() for ‘SequentialFuture’ ... done
[11:00:20.758] Created future:
[11:00:20.758] SequentialFuture:
[11:00:20.758] Label: ‘future_lapply-1’
[11:00:20.758] Expression:
[11:00:20.758] {
[11:00:20.758]     do.call(function(...) {
[11:00:20.758]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:20.758]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:20.758]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:20.758]             on.exit(options(oopts), add = TRUE)
[11:00:20.758]         }
[11:00:20.758]         {
[11:00:20.758]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:20.758]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:20.758]                 ...future.FUN(...future.X_jj, ...)
[11:00:20.758]             })
[11:00:20.758]         }
[11:00:20.758]     }, args = future.call.arguments)
[11:00:20.758] }
[11:00:20.758] Lazy evaluation: FALSE
[11:00:20.758] Asynchronous evaluation: FALSE
[11:00:20.758] Local evaluation: TRUE
[11:00:20.758] Environment: R_GlobalEnv
[11:00:20.758] Capture standard output: FALSE
[11:00:20.758] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:20.758] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:20.758] Packages: <none>
[11:00:20.758] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:20.758] Resolved: TRUE
[11:00:20.758] Value: 55 bytes of class ‘list’
[11:00:20.758] Early signaling: FALSE
[11:00:20.758] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:20.758] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:20.759] Chunk #1 of 1 ... DONE
[11:00:20.759] Launching 1 futures (chunks) ... DONE
[11:00:20.759] Resolving 1 futures (chunks) ...
[11:00:20.759] resolve() on list ...
[11:00:20.759]  recursive: 0
[11:00:20.759]  length: 1
[11:00:20.759] 
[11:00:20.760] resolved() for ‘SequentialFuture’ ...
[11:00:20.760] - state: ‘finished’
[11:00:20.760] - run: TRUE
[11:00:20.760] - result: ‘FutureResult’
[11:00:20.760] resolved() for ‘SequentialFuture’ ... done
[11:00:20.760] Future #1
[11:00:20.760] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:20.762] - nx: 1
[11:00:20.762] - relay: TRUE
[11:00:20.762] - stdout: TRUE
[11:00:20.762] - signal: TRUE
[11:00:20.762] - resignal: FALSE
[11:00:20.762] - force: TRUE
[11:00:20.762] - relayed: [n=1] FALSE
[11:00:20.762] - queued futures: [n=1] FALSE
[11:00:20.762]  - until=1
[11:00:20.763]  - relaying element #1
[11:00:20.763] - relayed: [n=1] TRUE
[11:00:20.763] - queued futures: [n=1] TRUE
[11:00:20.763] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:20.763]  length: 0 (resolved future 1)
[11:00:20.763] Relaying remaining futures
[11:00:20.763] signalConditionsASAP(NULL, pos=0) ...
[11:00:20.763] - nx: 1
[11:00:20.763] - relay: TRUE
[11:00:20.764] - stdout: TRUE
[11:00:20.764] - signal: TRUE
[11:00:20.764] - resignal: FALSE
[11:00:20.764] - force: TRUE
[11:00:20.764] - relayed: [n=1] TRUE
[11:00:20.764] - queued futures: [n=1] TRUE
 - flush all
[11:00:20.764] - relayed: [n=1] TRUE
[11:00:20.764] - queued futures: [n=1] TRUE
[11:00:20.764] signalConditionsASAP(NULL, pos=0) ... done
[11:00:20.764] resolve() on list ... DONE
[11:00:20.765]  - Number of value chunks collected: 1
[11:00:20.765] Resolving 1 futures (chunks) ... DONE
[11:00:20.765] Reducing values from 1 chunks ...
[11:00:20.765]  - Number of values collected after concatenation: 2
[11:00:20.765]  - Number of values expected: 2
[11:00:20.765] Reducing values from 1 chunks ... DONE
[11:00:20.765] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[11:00:20.765] future_lapply() ...
[11:00:20.767] Number of chunks: 1
[11:00:20.767] getGlobalsAndPackagesXApply() ...
[11:00:20.767]  - future.globals: TRUE
[11:00:20.767] getGlobalsAndPackages() ...
[11:00:20.768] Searching for globals...
[11:00:20.769] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[11:00:20.769] Searching for globals ... DONE
[11:00:20.769] Resolving globals: FALSE
[11:00:20.769] The total size of the 1 globals is 841 bytes (841 bytes)
[11:00:20.770] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[11:00:20.770] - globals: [1] ‘FUN’
[11:00:20.770] 
[11:00:20.770] getGlobalsAndPackages() ... DONE
[11:00:20.770]  - globals found/used: [n=1] ‘FUN’
[11:00:20.770]  - needed namespaces: [n=0] 
[11:00:20.770] Finding globals ... DONE
[11:00:20.770]  - use_args: TRUE
[11:00:20.771]  - Getting '...' globals ...
[11:00:20.771] resolve() on list ...
[11:00:20.771]  recursive: 0
[11:00:20.771]  length: 1
[11:00:20.771]  elements: ‘...’
[11:00:20.771]  length: 0 (resolved future 1)
[11:00:20.771] resolve() on list ... DONE
[11:00:20.771]    - '...' content: [n=0] 
[11:00:20.771] List of 1
[11:00:20.771]  $ ...: list()
[11:00:20.771]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:20.771]  - attr(*, "where")=List of 1
[11:00:20.771]   ..$ ...:<environment: 0x55ceb2e3c2d0> 
[11:00:20.771]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:20.771]  - attr(*, "resolved")= logi TRUE
[11:00:20.771]  - attr(*, "total_size")= num NA
[11:00:20.774]  - Getting '...' globals ... DONE
[11:00:20.774] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[11:00:20.774] List of 2
[11:00:20.774]  $ ...future.FUN:function (x)  
[11:00:20.774]  $ ...          : list()
[11:00:20.774]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:20.774]  - attr(*, "where")=List of 2
[11:00:20.774]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:20.774]   ..$ ...          :<environment: 0x55ceb2e3c2d0> 
[11:00:20.774]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:20.774]  - attr(*, "resolved")= logi FALSE
[11:00:20.774]  - attr(*, "total_size")= num 5632
[11:00:20.777] Packages to be attached in all futures: [n=0] 
[11:00:20.777] getGlobalsAndPackagesXApply() ... DONE
[11:00:20.777] Number of futures (= number of chunks): 1
[11:00:20.777] Launching 1 futures (chunks) ...
[11:00:20.777] Chunk #1 of 1 ...
[11:00:20.777]  - Finding globals in 'X' for chunk #1 ...
[11:00:20.777] getGlobalsAndPackages() ...
[11:00:20.777] Searching for globals...
[11:00:20.778] 
[11:00:20.778] Searching for globals ... DONE
[11:00:20.778] - globals: [0] <none>
[11:00:20.778] getGlobalsAndPackages() ... DONE
[11:00:20.778]    + additional globals found: [n=0] 
[11:00:20.778]    + additional namespaces needed: [n=0] 
[11:00:20.778]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:20.778]  - seeds: <none>
[11:00:20.778]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:20.778] getGlobalsAndPackages() ...
[11:00:20.778] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:20.779] Resolving globals: FALSE
[11:00:20.779] Tweak future expression to call with '...' arguments ...
[11:00:20.779] {
[11:00:20.779]     do.call(function(...) {
[11:00:20.779]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:20.779]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:20.779]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:20.779]             on.exit(options(oopts), add = TRUE)
[11:00:20.779]         }
[11:00:20.779]         {
[11:00:20.779]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:20.779]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:20.779]                 ...future.FUN(...future.X_jj, ...)
[11:00:20.779]             })
[11:00:20.779]         }
[11:00:20.779]     }, args = future.call.arguments)
[11:00:20.779] }
[11:00:20.779] Tweak future expression to call with '...' arguments ... DONE
[11:00:20.779] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:20.779] 
[11:00:20.779] getGlobalsAndPackages() ... DONE
[11:00:20.780] run() for ‘Future’ ...
[11:00:20.780] - state: ‘created’
[11:00:20.780] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:20.781] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:20.781] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:20.782]   - Field: ‘label’
[11:00:20.782]   - Field: ‘local’
[11:00:20.782]   - Field: ‘owner’
[11:00:20.782]   - Field: ‘envir’
[11:00:20.782]   - Field: ‘packages’
[11:00:20.782]   - Field: ‘gc’
[11:00:20.782]   - Field: ‘conditions’
[11:00:20.782]   - Field: ‘expr’
[11:00:20.782]   - Field: ‘uuid’
[11:00:20.782]   - Field: ‘seed’
[11:00:20.782]   - Field: ‘version’
[11:00:20.782]   - Field: ‘result’
[11:00:20.783]   - Field: ‘asynchronous’
[11:00:20.783]   - Field: ‘calls’
[11:00:20.783]   - Field: ‘globals’
[11:00:20.783]   - Field: ‘stdout’
[11:00:20.783]   - Field: ‘earlySignal’
[11:00:20.783]   - Field: ‘lazy’
[11:00:20.783]   - Field: ‘state’
[11:00:20.783] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:20.783] - Launch lazy future ...
[11:00:20.783] Packages needed by the future expression (n = 0): <none>
[11:00:20.783] Packages needed by future strategies (n = 0): <none>
[11:00:20.784] {
[11:00:20.784]     {
[11:00:20.784]         {
[11:00:20.784]             ...future.startTime <- base::Sys.time()
[11:00:20.784]             {
[11:00:20.784]                 {
[11:00:20.784]                   {
[11:00:20.784]                     base::local({
[11:00:20.784]                       has_future <- base::requireNamespace("future", 
[11:00:20.784]                         quietly = TRUE)
[11:00:20.784]                       if (has_future) {
[11:00:20.784]                         ns <- base::getNamespace("future")
[11:00:20.784]                         version <- ns[[".package"]][["version"]]
[11:00:20.784]                         if (is.null(version)) 
[11:00:20.784]                           version <- utils::packageVersion("future")
[11:00:20.784]                       }
[11:00:20.784]                       else {
[11:00:20.784]                         version <- NULL
[11:00:20.784]                       }
[11:00:20.784]                       if (!has_future || version < "1.8.0") {
[11:00:20.784]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:20.784]                           "", base::R.version$version.string), 
[11:00:20.784]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:20.784]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:20.784]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:20.784]                             "release", "version")], collapse = " "), 
[11:00:20.784]                           hostname = base::Sys.info()[["nodename"]])
[11:00:20.784]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:20.784]                           info)
[11:00:20.784]                         info <- base::paste(info, collapse = "; ")
[11:00:20.784]                         if (!has_future) {
[11:00:20.784]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:20.784]                             info)
[11:00:20.784]                         }
[11:00:20.784]                         else {
[11:00:20.784]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:20.784]                             info, version)
[11:00:20.784]                         }
[11:00:20.784]                         base::stop(msg)
[11:00:20.784]                       }
[11:00:20.784]                     })
[11:00:20.784]                   }
[11:00:20.784]                   ...future.strategy.old <- future::plan("list")
[11:00:20.784]                   options(future.plan = NULL)
[11:00:20.784]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:20.784]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:20.784]                 }
[11:00:20.784]                 ...future.workdir <- getwd()
[11:00:20.784]             }
[11:00:20.784]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:20.784]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:20.784]         }
[11:00:20.784]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:20.784]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:20.784]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:20.784]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:20.784]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:20.784]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:20.784]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:20.784]             base::names(...future.oldOptions))
[11:00:20.784]     }
[11:00:20.784]     if (FALSE) {
[11:00:20.784]     }
[11:00:20.784]     else {
[11:00:20.784]         if (TRUE) {
[11:00:20.784]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:20.784]                 open = "w")
[11:00:20.784]         }
[11:00:20.784]         else {
[11:00:20.784]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:20.784]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:20.784]         }
[11:00:20.784]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:20.784]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:20.784]             base::sink(type = "output", split = FALSE)
[11:00:20.784]             base::close(...future.stdout)
[11:00:20.784]         }, add = TRUE)
[11:00:20.784]     }
[11:00:20.784]     ...future.frame <- base::sys.nframe()
[11:00:20.784]     ...future.conditions <- base::list()
[11:00:20.784]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:20.784]     if (FALSE) {
[11:00:20.784]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:20.784]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:20.784]     }
[11:00:20.784]     ...future.result <- base::tryCatch({
[11:00:20.784]         base::withCallingHandlers({
[11:00:20.784]             ...future.value <- base::withVisible(base::local({
[11:00:20.784]                 do.call(function(...) {
[11:00:20.784]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:20.784]                   if (!identical(...future.globals.maxSize.org, 
[11:00:20.784]                     ...future.globals.maxSize)) {
[11:00:20.784]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:20.784]                     on.exit(options(oopts), add = TRUE)
[11:00:20.784]                   }
[11:00:20.784]                   {
[11:00:20.784]                     lapply(seq_along(...future.elements_ii), 
[11:00:20.784]                       FUN = function(jj) {
[11:00:20.784]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:20.784]                         ...future.FUN(...future.X_jj, ...)
[11:00:20.784]                       })
[11:00:20.784]                   }
[11:00:20.784]                 }, args = future.call.arguments)
[11:00:20.784]             }))
[11:00:20.784]             future::FutureResult(value = ...future.value$value, 
[11:00:20.784]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:20.784]                   ...future.rng), globalenv = if (FALSE) 
[11:00:20.784]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:20.784]                     ...future.globalenv.names))
[11:00:20.784]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:20.784]         }, condition = base::local({
[11:00:20.784]             c <- base::c
[11:00:20.784]             inherits <- base::inherits
[11:00:20.784]             invokeRestart <- base::invokeRestart
[11:00:20.784]             length <- base::length
[11:00:20.784]             list <- base::list
[11:00:20.784]             seq.int <- base::seq.int
[11:00:20.784]             signalCondition <- base::signalCondition
[11:00:20.784]             sys.calls <- base::sys.calls
[11:00:20.784]             `[[` <- base::`[[`
[11:00:20.784]             `+` <- base::`+`
[11:00:20.784]             `<<-` <- base::`<<-`
[11:00:20.784]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:20.784]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:20.784]                   3L)]
[11:00:20.784]             }
[11:00:20.784]             function(cond) {
[11:00:20.784]                 is_error <- inherits(cond, "error")
[11:00:20.784]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:20.784]                   NULL)
[11:00:20.784]                 if (is_error) {
[11:00:20.784]                   sessionInformation <- function() {
[11:00:20.784]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:20.784]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:20.784]                       search = base::search(), system = base::Sys.info())
[11:00:20.784]                   }
[11:00:20.784]                   ...future.conditions[[length(...future.conditions) + 
[11:00:20.784]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:20.784]                     cond$call), session = sessionInformation(), 
[11:00:20.784]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:20.784]                   signalCondition(cond)
[11:00:20.784]                 }
[11:00:20.784]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:20.784]                 "immediateCondition"))) {
[11:00:20.784]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:20.784]                   ...future.conditions[[length(...future.conditions) + 
[11:00:20.784]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:20.784]                   if (TRUE && !signal) {
[11:00:20.784]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:20.784]                     {
[11:00:20.784]                       inherits <- base::inherits
[11:00:20.784]                       invokeRestart <- base::invokeRestart
[11:00:20.784]                       is.null <- base::is.null
[11:00:20.784]                       muffled <- FALSE
[11:00:20.784]                       if (inherits(cond, "message")) {
[11:00:20.784]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:20.784]                         if (muffled) 
[11:00:20.784]                           invokeRestart("muffleMessage")
[11:00:20.784]                       }
[11:00:20.784]                       else if (inherits(cond, "warning")) {
[11:00:20.784]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:20.784]                         if (muffled) 
[11:00:20.784]                           invokeRestart("muffleWarning")
[11:00:20.784]                       }
[11:00:20.784]                       else if (inherits(cond, "condition")) {
[11:00:20.784]                         if (!is.null(pattern)) {
[11:00:20.784]                           computeRestarts <- base::computeRestarts
[11:00:20.784]                           grepl <- base::grepl
[11:00:20.784]                           restarts <- computeRestarts(cond)
[11:00:20.784]                           for (restart in restarts) {
[11:00:20.784]                             name <- restart$name
[11:00:20.784]                             if (is.null(name)) 
[11:00:20.784]                               next
[11:00:20.784]                             if (!grepl(pattern, name)) 
[11:00:20.784]                               next
[11:00:20.784]                             invokeRestart(restart)
[11:00:20.784]                             muffled <- TRUE
[11:00:20.784]                             break
[11:00:20.784]                           }
[11:00:20.784]                         }
[11:00:20.784]                       }
[11:00:20.784]                       invisible(muffled)
[11:00:20.784]                     }
[11:00:20.784]                     muffleCondition(cond, pattern = "^muffle")
[11:00:20.784]                   }
[11:00:20.784]                 }
[11:00:20.784]                 else {
[11:00:20.784]                   if (TRUE) {
[11:00:20.784]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:20.784]                     {
[11:00:20.784]                       inherits <- base::inherits
[11:00:20.784]                       invokeRestart <- base::invokeRestart
[11:00:20.784]                       is.null <- base::is.null
[11:00:20.784]                       muffled <- FALSE
[11:00:20.784]                       if (inherits(cond, "message")) {
[11:00:20.784]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:20.784]                         if (muffled) 
[11:00:20.784]                           invokeRestart("muffleMessage")
[11:00:20.784]                       }
[11:00:20.784]                       else if (inherits(cond, "warning")) {
[11:00:20.784]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:20.784]                         if (muffled) 
[11:00:20.784]                           invokeRestart("muffleWarning")
[11:00:20.784]                       }
[11:00:20.784]                       else if (inherits(cond, "condition")) {
[11:00:20.784]                         if (!is.null(pattern)) {
[11:00:20.784]                           computeRestarts <- base::computeRestarts
[11:00:20.784]                           grepl <- base::grepl
[11:00:20.784]                           restarts <- computeRestarts(cond)
[11:00:20.784]                           for (restart in restarts) {
[11:00:20.784]                             name <- restart$name
[11:00:20.784]                             if (is.null(name)) 
[11:00:20.784]                               next
[11:00:20.784]                             if (!grepl(pattern, name)) 
[11:00:20.784]                               next
[11:00:20.784]                             invokeRestart(restart)
[11:00:20.784]                             muffled <- TRUE
[11:00:20.784]                             break
[11:00:20.784]                           }
[11:00:20.784]                         }
[11:00:20.784]                       }
[11:00:20.784]                       invisible(muffled)
[11:00:20.784]                     }
[11:00:20.784]                     muffleCondition(cond, pattern = "^muffle")
[11:00:20.784]                   }
[11:00:20.784]                 }
[11:00:20.784]             }
[11:00:20.784]         }))
[11:00:20.784]     }, error = function(ex) {
[11:00:20.784]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:20.784]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:20.784]                 ...future.rng), started = ...future.startTime, 
[11:00:20.784]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:20.784]             version = "1.8"), class = "FutureResult")
[11:00:20.784]     }, finally = {
[11:00:20.784]         if (!identical(...future.workdir, getwd())) 
[11:00:20.784]             setwd(...future.workdir)
[11:00:20.784]         {
[11:00:20.784]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:20.784]                 ...future.oldOptions$nwarnings <- NULL
[11:00:20.784]             }
[11:00:20.784]             base::options(...future.oldOptions)
[11:00:20.784]             if (.Platform$OS.type == "windows") {
[11:00:20.784]                 old_names <- names(...future.oldEnvVars)
[11:00:20.784]                 envs <- base::Sys.getenv()
[11:00:20.784]                 names <- names(envs)
[11:00:20.784]                 common <- intersect(names, old_names)
[11:00:20.784]                 added <- setdiff(names, old_names)
[11:00:20.784]                 removed <- setdiff(old_names, names)
[11:00:20.784]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:20.784]                   envs[common]]
[11:00:20.784]                 NAMES <- toupper(changed)
[11:00:20.784]                 args <- list()
[11:00:20.784]                 for (kk in seq_along(NAMES)) {
[11:00:20.784]                   name <- changed[[kk]]
[11:00:20.784]                   NAME <- NAMES[[kk]]
[11:00:20.784]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:20.784]                     next
[11:00:20.784]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:20.784]                 }
[11:00:20.784]                 NAMES <- toupper(added)
[11:00:20.784]                 for (kk in seq_along(NAMES)) {
[11:00:20.784]                   name <- added[[kk]]
[11:00:20.784]                   NAME <- NAMES[[kk]]
[11:00:20.784]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:20.784]                     next
[11:00:20.784]                   args[[name]] <- ""
[11:00:20.784]                 }
[11:00:20.784]                 NAMES <- toupper(removed)
[11:00:20.784]                 for (kk in seq_along(NAMES)) {
[11:00:20.784]                   name <- removed[[kk]]
[11:00:20.784]                   NAME <- NAMES[[kk]]
[11:00:20.784]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:20.784]                     next
[11:00:20.784]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:20.784]                 }
[11:00:20.784]                 if (length(args) > 0) 
[11:00:20.784]                   base::do.call(base::Sys.setenv, args = args)
[11:00:20.784]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:20.784]             }
[11:00:20.784]             else {
[11:00:20.784]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:20.784]             }
[11:00:20.784]             {
[11:00:20.784]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:20.784]                   0L) {
[11:00:20.784]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:20.784]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:20.784]                   base::options(opts)
[11:00:20.784]                 }
[11:00:20.784]                 {
[11:00:20.784]                   {
[11:00:20.784]                     NULL
[11:00:20.784]                     RNGkind("Mersenne-Twister")
[11:00:20.784]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:20.784]                       inherits = FALSE)
[11:00:20.784]                   }
[11:00:20.784]                   options(future.plan = NULL)
[11:00:20.784]                   if (is.na(NA_character_)) 
[11:00:20.784]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:20.784]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:20.784]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:20.784]                     .init = FALSE)
[11:00:20.784]                 }
[11:00:20.784]             }
[11:00:20.784]         }
[11:00:20.784]     })
[11:00:20.784]     if (TRUE) {
[11:00:20.784]         base::sink(type = "output", split = FALSE)
[11:00:20.784]         if (TRUE) {
[11:00:20.784]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:20.784]         }
[11:00:20.784]         else {
[11:00:20.784]             ...future.result["stdout"] <- base::list(NULL)
[11:00:20.784]         }
[11:00:20.784]         base::close(...future.stdout)
[11:00:20.784]         ...future.stdout <- NULL
[11:00:20.784]     }
[11:00:20.784]     ...future.result$conditions <- ...future.conditions
[11:00:20.784]     ...future.result$finished <- base::Sys.time()
[11:00:20.784]     ...future.result
[11:00:20.784] }
[11:00:20.786] assign_globals() ...
[11:00:20.786] List of 5
[11:00:20.786]  $ ...future.FUN            :function (x)  
[11:00:20.786]  $ future.call.arguments    : list()
[11:00:20.786]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:20.786]  $ ...future.elements_ii    :List of 2
[11:00:20.786]   ..$ : int 1
[11:00:20.786]   ..$ : int 0
[11:00:20.786]  $ ...future.seeds_ii       : NULL
[11:00:20.786]  $ ...future.globals.maxSize: NULL
[11:00:20.786]  - attr(*, "where")=List of 5
[11:00:20.786]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:20.786]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:20.786]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:20.786]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:20.786]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:20.786]  - attr(*, "resolved")= logi FALSE
[11:00:20.786]  - attr(*, "total_size")= num 5632
[11:00:20.786]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:20.786]  - attr(*, "already-done")= logi TRUE
[11:00:20.791] - reassign environment for ‘...future.FUN’
[11:00:20.791] - copied ‘...future.FUN’ to environment
[11:00:20.792] - copied ‘future.call.arguments’ to environment
[11:00:20.792] - copied ‘...future.elements_ii’ to environment
[11:00:20.792] - copied ‘...future.seeds_ii’ to environment
[11:00:20.792] - copied ‘...future.globals.maxSize’ to environment
[11:00:20.792] assign_globals() ... done
[11:00:20.792] plan(): Setting new future strategy stack:
[11:00:20.792] List of future strategies:
[11:00:20.792] 1. sequential:
[11:00:20.792]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:20.792]    - tweaked: FALSE
[11:00:20.792]    - call: NULL
[11:00:20.793] plan(): nbrOfWorkers() = 1
[11:00:21.294] plan(): Setting new future strategy stack:
[11:00:21.294] List of future strategies:
[11:00:21.294] 1. multisession:
[11:00:21.294]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:00:21.294]    - tweaked: FALSE
[11:00:21.294]    - call: plan(strategy)
[11:00:21.296] plan(): nbrOfWorkers() = 1
[11:00:21.296] SequentialFuture started (and completed)
[11:00:21.297] - Launch lazy future ... done
[11:00:21.297] run() for ‘SequentialFuture’ ... done
[11:00:21.297] Created future:
[11:00:21.297] SequentialFuture:
[11:00:21.297] Label: ‘future_lapply-1’
[11:00:21.297] Expression:
[11:00:21.297] {
[11:00:21.297]     do.call(function(...) {
[11:00:21.297]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:21.297]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:21.297]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:21.297]             on.exit(options(oopts), add = TRUE)
[11:00:21.297]         }
[11:00:21.297]         {
[11:00:21.297]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:21.297]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:21.297]                 ...future.FUN(...future.X_jj, ...)
[11:00:21.297]             })
[11:00:21.297]         }
[11:00:21.297]     }, args = future.call.arguments)
[11:00:21.297] }
[11:00:21.297] Lazy evaluation: FALSE
[11:00:21.297] Asynchronous evaluation: FALSE
[11:00:21.297] Local evaluation: TRUE
[11:00:21.297] Environment: R_GlobalEnv
[11:00:21.297] Capture standard output: TRUE
[11:00:21.297] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:21.297] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:21.297] Packages: <none>
[11:00:21.297] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:21.297] Resolved: TRUE
[11:00:21.297] Value: 55 bytes of class ‘list’
[11:00:21.297] Early signaling: FALSE
[11:00:21.297] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:21.297] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:21.298] Chunk #1 of 1 ... DONE
[11:00:21.298] Launching 1 futures (chunks) ... DONE
[11:00:21.298] Resolving 1 futures (chunks) ...
[11:00:21.298] resolve() on list ...
[11:00:21.298]  recursive: 0
[11:00:21.298]  length: 1
[11:00:21.298] 
[11:00:21.298] resolved() for ‘SequentialFuture’ ...
[11:00:21.298] - state: ‘finished’
[11:00:21.299] - run: TRUE
[11:00:21.299] - result: ‘FutureResult’
[11:00:21.299] resolved() for ‘SequentialFuture’ ... done
[11:00:21.299] Future #1
[11:00:21.299] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:21.299] - nx: 1
[11:00:21.299] - relay: TRUE
[11:00:21.299] - stdout: TRUE
[11:00:21.299] - signal: TRUE
[11:00:21.299] - resignal: FALSE
[11:00:21.299] - force: TRUE
[11:00:21.300] - relayed: [n=1] FALSE
[11:00:21.300] - queued futures: [n=1] FALSE
[11:00:21.300]  - until=1
[11:00:21.300]  - relaying element #1
[11:00:21.300] - relayed: [n=1] TRUE
[11:00:21.300] - queued futures: [n=1] TRUE
[11:00:21.300] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:21.300]  length: 0 (resolved future 1)
[11:00:21.300] Relaying remaining futures
[11:00:21.300] signalConditionsASAP(NULL, pos=0) ...
[11:00:21.301] - nx: 1
[11:00:21.301] - relay: TRUE
[11:00:21.301] - stdout: TRUE
[11:00:21.301] - signal: TRUE
[11:00:21.301] - resignal: FALSE
[11:00:21.301] - force: TRUE
[11:00:21.301] - relayed: [n=1] TRUE
[11:00:21.301] - queued futures: [n=1] TRUE
 - flush all
[11:00:21.301] - relayed: [n=1] TRUE
[11:00:21.301] - queued futures: [n=1] TRUE
[11:00:21.301] signalConditionsASAP(NULL, pos=0) ... done
[11:00:21.301] resolve() on list ... DONE
[11:00:21.302]  - Number of value chunks collected: 1
[11:00:21.302] Resolving 1 futures (chunks) ... DONE
[11:00:21.302] Reducing values from 1 chunks ...
[11:00:21.302]  - Number of values collected after concatenation: 2
[11:00:21.302]  - Number of values expected: 2
[11:00:21.302] Reducing values from 1 chunks ... DONE
[11:00:21.302] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[11:00:21.302] future_lapply() ...
[11:00:21.304] Number of chunks: 1
[11:00:21.304] getGlobalsAndPackagesXApply() ...
[11:00:21.304]  - future.globals: TRUE
[11:00:21.305] getGlobalsAndPackages() ...
[11:00:21.305] Searching for globals...
[11:00:21.306] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[11:00:21.306] Searching for globals ... DONE
[11:00:21.306] Resolving globals: FALSE
[11:00:21.307] The total size of the 1 globals is 841 bytes (841 bytes)
[11:00:21.307] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[11:00:21.307] - globals: [1] ‘FUN’
[11:00:21.307] 
[11:00:21.307] getGlobalsAndPackages() ... DONE
[11:00:21.307]  - globals found/used: [n=1] ‘FUN’
[11:00:21.307]  - needed namespaces: [n=0] 
[11:00:21.307] Finding globals ... DONE
[11:00:21.308]  - use_args: TRUE
[11:00:21.308]  - Getting '...' globals ...
[11:00:21.308] resolve() on list ...
[11:00:21.308]  recursive: 0
[11:00:21.308]  length: 1
[11:00:21.308]  elements: ‘...’
[11:00:21.308]  length: 0 (resolved future 1)
[11:00:21.308] resolve() on list ... DONE
[11:00:21.308]    - '...' content: [n=0] 
[11:00:21.309] List of 1
[11:00:21.309]  $ ...: list()
[11:00:21.309]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:21.309]  - attr(*, "where")=List of 1
[11:00:21.309]   ..$ ...:<environment: 0x55ceb3399d60> 
[11:00:21.309]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:21.309]  - attr(*, "resolved")= logi TRUE
[11:00:21.309]  - attr(*, "total_size")= num NA
[11:00:21.311]  - Getting '...' globals ... DONE
[11:00:21.311] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[11:00:21.311] List of 2
[11:00:21.311]  $ ...future.FUN:function (x)  
[11:00:21.311]  $ ...          : list()
[11:00:21.311]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:21.311]  - attr(*, "where")=List of 2
[11:00:21.311]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:21.311]   ..$ ...          :<environment: 0x55ceb3399d60> 
[11:00:21.311]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:21.311]  - attr(*, "resolved")= logi FALSE
[11:00:21.311]  - attr(*, "total_size")= num 5632
[11:00:21.315] Packages to be attached in all futures: [n=0] 
[11:00:21.315] getGlobalsAndPackagesXApply() ... DONE
[11:00:21.315] Number of futures (= number of chunks): 1
[11:00:21.316] Launching 1 futures (chunks) ...
[11:00:21.316] Chunk #1 of 1 ...
[11:00:21.316]  - Finding globals in 'X' for chunk #1 ...
[11:00:21.316] getGlobalsAndPackages() ...
[11:00:21.316] Searching for globals...
[11:00:21.316] 
[11:00:21.316] Searching for globals ... DONE
[11:00:21.316] - globals: [0] <none>
[11:00:21.317] getGlobalsAndPackages() ... DONE
[11:00:21.317]    + additional globals found: [n=0] 
[11:00:21.317]    + additional namespaces needed: [n=0] 
[11:00:21.317]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:21.317]  - seeds: <none>
[11:00:21.317]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:21.317] getGlobalsAndPackages() ...
[11:00:21.317] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:21.317] Resolving globals: FALSE
[11:00:21.317] Tweak future expression to call with '...' arguments ...
[11:00:21.318] {
[11:00:21.318]     do.call(function(...) {
[11:00:21.318]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:21.318]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:21.318]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:21.318]             on.exit(options(oopts), add = TRUE)
[11:00:21.318]         }
[11:00:21.318]         {
[11:00:21.318]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:21.318]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:21.318]                 ...future.FUN(...future.X_jj, ...)
[11:00:21.318]             })
[11:00:21.318]         }
[11:00:21.318]     }, args = future.call.arguments)
[11:00:21.318] }
[11:00:21.318] Tweak future expression to call with '...' arguments ... DONE
[11:00:21.318] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:21.318] 
[11:00:21.318] getGlobalsAndPackages() ... DONE
[11:00:21.319] run() for ‘Future’ ...
[11:00:21.319] - state: ‘created’
[11:00:21.319] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:21.320] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:21.320] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:21.320]   - Field: ‘label’
[11:00:21.321]   - Field: ‘local’
[11:00:21.321]   - Field: ‘owner’
[11:00:21.321]   - Field: ‘envir’
[11:00:21.321]   - Field: ‘packages’
[11:00:21.321]   - Field: ‘gc’
[11:00:21.321]   - Field: ‘conditions’
[11:00:21.321]   - Field: ‘expr’
[11:00:21.321]   - Field: ‘uuid’
[11:00:21.321]   - Field: ‘seed’
[11:00:21.321]   - Field: ‘version’
[11:00:21.321]   - Field: ‘result’
[11:00:21.321]   - Field: ‘asynchronous’
[11:00:21.322]   - Field: ‘calls’
[11:00:21.322]   - Field: ‘globals’
[11:00:21.322]   - Field: ‘stdout’
[11:00:21.322]   - Field: ‘earlySignal’
[11:00:21.322]   - Field: ‘lazy’
[11:00:21.322]   - Field: ‘state’
[11:00:21.322] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:21.322] - Launch lazy future ...
[11:00:21.322] Packages needed by the future expression (n = 0): <none>
[11:00:21.322] Packages needed by future strategies (n = 0): <none>
[11:00:21.323] {
[11:00:21.323]     {
[11:00:21.323]         {
[11:00:21.323]             ...future.startTime <- base::Sys.time()
[11:00:21.323]             {
[11:00:21.323]                 {
[11:00:21.323]                   {
[11:00:21.323]                     base::local({
[11:00:21.323]                       has_future <- base::requireNamespace("future", 
[11:00:21.323]                         quietly = TRUE)
[11:00:21.323]                       if (has_future) {
[11:00:21.323]                         ns <- base::getNamespace("future")
[11:00:21.323]                         version <- ns[[".package"]][["version"]]
[11:00:21.323]                         if (is.null(version)) 
[11:00:21.323]                           version <- utils::packageVersion("future")
[11:00:21.323]                       }
[11:00:21.323]                       else {
[11:00:21.323]                         version <- NULL
[11:00:21.323]                       }
[11:00:21.323]                       if (!has_future || version < "1.8.0") {
[11:00:21.323]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:21.323]                           "", base::R.version$version.string), 
[11:00:21.323]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:21.323]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:21.323]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:21.323]                             "release", "version")], collapse = " "), 
[11:00:21.323]                           hostname = base::Sys.info()[["nodename"]])
[11:00:21.323]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:21.323]                           info)
[11:00:21.323]                         info <- base::paste(info, collapse = "; ")
[11:00:21.323]                         if (!has_future) {
[11:00:21.323]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:21.323]                             info)
[11:00:21.323]                         }
[11:00:21.323]                         else {
[11:00:21.323]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:21.323]                             info, version)
[11:00:21.323]                         }
[11:00:21.323]                         base::stop(msg)
[11:00:21.323]                       }
[11:00:21.323]                     })
[11:00:21.323]                   }
[11:00:21.323]                   ...future.strategy.old <- future::plan("list")
[11:00:21.323]                   options(future.plan = NULL)
[11:00:21.323]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:21.323]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:21.323]                 }
[11:00:21.323]                 ...future.workdir <- getwd()
[11:00:21.323]             }
[11:00:21.323]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:21.323]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:21.323]         }
[11:00:21.323]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:21.323]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:21.323]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:21.323]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:21.323]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:21.323]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:21.323]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:21.323]             base::names(...future.oldOptions))
[11:00:21.323]     }
[11:00:21.323]     if (TRUE) {
[11:00:21.323]     }
[11:00:21.323]     else {
[11:00:21.323]         if (NA) {
[11:00:21.323]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:21.323]                 open = "w")
[11:00:21.323]         }
[11:00:21.323]         else {
[11:00:21.323]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:21.323]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:21.323]         }
[11:00:21.323]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:21.323]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:21.323]             base::sink(type = "output", split = FALSE)
[11:00:21.323]             base::close(...future.stdout)
[11:00:21.323]         }, add = TRUE)
[11:00:21.323]     }
[11:00:21.323]     ...future.frame <- base::sys.nframe()
[11:00:21.323]     ...future.conditions <- base::list()
[11:00:21.323]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:21.323]     if (FALSE) {
[11:00:21.323]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:21.323]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:21.323]     }
[11:00:21.323]     ...future.result <- base::tryCatch({
[11:00:21.323]         base::withCallingHandlers({
[11:00:21.323]             ...future.value <- base::withVisible(base::local({
[11:00:21.323]                 do.call(function(...) {
[11:00:21.323]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:21.323]                   if (!identical(...future.globals.maxSize.org, 
[11:00:21.323]                     ...future.globals.maxSize)) {
[11:00:21.323]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:21.323]                     on.exit(options(oopts), add = TRUE)
[11:00:21.323]                   }
[11:00:21.323]                   {
[11:00:21.323]                     lapply(seq_along(...future.elements_ii), 
[11:00:21.323]                       FUN = function(jj) {
[11:00:21.323]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:21.323]                         ...future.FUN(...future.X_jj, ...)
[11:00:21.323]                       })
[11:00:21.323]                   }
[11:00:21.323]                 }, args = future.call.arguments)
[11:00:21.323]             }))
[11:00:21.323]             future::FutureResult(value = ...future.value$value, 
[11:00:21.323]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:21.323]                   ...future.rng), globalenv = if (FALSE) 
[11:00:21.323]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:21.323]                     ...future.globalenv.names))
[11:00:21.323]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:21.323]         }, condition = base::local({
[11:00:21.323]             c <- base::c
[11:00:21.323]             inherits <- base::inherits
[11:00:21.323]             invokeRestart <- base::invokeRestart
[11:00:21.323]             length <- base::length
[11:00:21.323]             list <- base::list
[11:00:21.323]             seq.int <- base::seq.int
[11:00:21.323]             signalCondition <- base::signalCondition
[11:00:21.323]             sys.calls <- base::sys.calls
[11:00:21.323]             `[[` <- base::`[[`
[11:00:21.323]             `+` <- base::`+`
[11:00:21.323]             `<<-` <- base::`<<-`
[11:00:21.323]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:21.323]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:21.323]                   3L)]
[11:00:21.323]             }
[11:00:21.323]             function(cond) {
[11:00:21.323]                 is_error <- inherits(cond, "error")
[11:00:21.323]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:21.323]                   NULL)
[11:00:21.323]                 if (is_error) {
[11:00:21.323]                   sessionInformation <- function() {
[11:00:21.323]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:21.323]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:21.323]                       search = base::search(), system = base::Sys.info())
[11:00:21.323]                   }
[11:00:21.323]                   ...future.conditions[[length(...future.conditions) + 
[11:00:21.323]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:21.323]                     cond$call), session = sessionInformation(), 
[11:00:21.323]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:21.323]                   signalCondition(cond)
[11:00:21.323]                 }
[11:00:21.323]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:21.323]                 "immediateCondition"))) {
[11:00:21.323]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:21.323]                   ...future.conditions[[length(...future.conditions) + 
[11:00:21.323]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:21.323]                   if (TRUE && !signal) {
[11:00:21.323]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:21.323]                     {
[11:00:21.323]                       inherits <- base::inherits
[11:00:21.323]                       invokeRestart <- base::invokeRestart
[11:00:21.323]                       is.null <- base::is.null
[11:00:21.323]                       muffled <- FALSE
[11:00:21.323]                       if (inherits(cond, "message")) {
[11:00:21.323]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:21.323]                         if (muffled) 
[11:00:21.323]                           invokeRestart("muffleMessage")
[11:00:21.323]                       }
[11:00:21.323]                       else if (inherits(cond, "warning")) {
[11:00:21.323]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:21.323]                         if (muffled) 
[11:00:21.323]                           invokeRestart("muffleWarning")
[11:00:21.323]                       }
[11:00:21.323]                       else if (inherits(cond, "condition")) {
[11:00:21.323]                         if (!is.null(pattern)) {
[11:00:21.323]                           computeRestarts <- base::computeRestarts
[11:00:21.323]                           grepl <- base::grepl
[11:00:21.323]                           restarts <- computeRestarts(cond)
[11:00:21.323]                           for (restart in restarts) {
[11:00:21.323]                             name <- restart$name
[11:00:21.323]                             if (is.null(name)) 
[11:00:21.323]                               next
[11:00:21.323]                             if (!grepl(pattern, name)) 
[11:00:21.323]                               next
[11:00:21.323]                             invokeRestart(restart)
[11:00:21.323]                             muffled <- TRUE
[11:00:21.323]                             break
[11:00:21.323]                           }
[11:00:21.323]                         }
[11:00:21.323]                       }
[11:00:21.323]                       invisible(muffled)
[11:00:21.323]                     }
[11:00:21.323]                     muffleCondition(cond, pattern = "^muffle")
[11:00:21.323]                   }
[11:00:21.323]                 }
[11:00:21.323]                 else {
[11:00:21.323]                   if (TRUE) {
[11:00:21.323]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:21.323]                     {
[11:00:21.323]                       inherits <- base::inherits
[11:00:21.323]                       invokeRestart <- base::invokeRestart
[11:00:21.323]                       is.null <- base::is.null
[11:00:21.323]                       muffled <- FALSE
[11:00:21.323]                       if (inherits(cond, "message")) {
[11:00:21.323]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:21.323]                         if (muffled) 
[11:00:21.323]                           invokeRestart("muffleMessage")
[11:00:21.323]                       }
[11:00:21.323]                       else if (inherits(cond, "warning")) {
[11:00:21.323]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:21.323]                         if (muffled) 
[11:00:21.323]                           invokeRestart("muffleWarning")
[11:00:21.323]                       }
[11:00:21.323]                       else if (inherits(cond, "condition")) {
[11:00:21.323]                         if (!is.null(pattern)) {
[11:00:21.323]                           computeRestarts <- base::computeRestarts
[11:00:21.323]                           grepl <- base::grepl
[11:00:21.323]                           restarts <- computeRestarts(cond)
[11:00:21.323]                           for (restart in restarts) {
[11:00:21.323]                             name <- restart$name
[11:00:21.323]                             if (is.null(name)) 
[11:00:21.323]                               next
[11:00:21.323]                             if (!grepl(pattern, name)) 
[11:00:21.323]                               next
[11:00:21.323]                             invokeRestart(restart)
[11:00:21.323]                             muffled <- TRUE
[11:00:21.323]                             break
[11:00:21.323]                           }
[11:00:21.323]                         }
[11:00:21.323]                       }
[11:00:21.323]                       invisible(muffled)
[11:00:21.323]                     }
[11:00:21.323]                     muffleCondition(cond, pattern = "^muffle")
[11:00:21.323]                   }
[11:00:21.323]                 }
[11:00:21.323]             }
[11:00:21.323]         }))
[11:00:21.323]     }, error = function(ex) {
[11:00:21.323]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:21.323]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:21.323]                 ...future.rng), started = ...future.startTime, 
[11:00:21.323]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:21.323]             version = "1.8"), class = "FutureResult")
[11:00:21.323]     }, finally = {
[11:00:21.323]         if (!identical(...future.workdir, getwd())) 
[11:00:21.323]             setwd(...future.workdir)
[11:00:21.323]         {
[11:00:21.323]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:21.323]                 ...future.oldOptions$nwarnings <- NULL
[11:00:21.323]             }
[11:00:21.323]             base::options(...future.oldOptions)
[11:00:21.323]             if (.Platform$OS.type == "windows") {
[11:00:21.323]                 old_names <- names(...future.oldEnvVars)
[11:00:21.323]                 envs <- base::Sys.getenv()
[11:00:21.323]                 names <- names(envs)
[11:00:21.323]                 common <- intersect(names, old_names)
[11:00:21.323]                 added <- setdiff(names, old_names)
[11:00:21.323]                 removed <- setdiff(old_names, names)
[11:00:21.323]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:21.323]                   envs[common]]
[11:00:21.323]                 NAMES <- toupper(changed)
[11:00:21.323]                 args <- list()
[11:00:21.323]                 for (kk in seq_along(NAMES)) {
[11:00:21.323]                   name <- changed[[kk]]
[11:00:21.323]                   NAME <- NAMES[[kk]]
[11:00:21.323]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:21.323]                     next
[11:00:21.323]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:21.323]                 }
[11:00:21.323]                 NAMES <- toupper(added)
[11:00:21.323]                 for (kk in seq_along(NAMES)) {
[11:00:21.323]                   name <- added[[kk]]
[11:00:21.323]                   NAME <- NAMES[[kk]]
[11:00:21.323]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:21.323]                     next
[11:00:21.323]                   args[[name]] <- ""
[11:00:21.323]                 }
[11:00:21.323]                 NAMES <- toupper(removed)
[11:00:21.323]                 for (kk in seq_along(NAMES)) {
[11:00:21.323]                   name <- removed[[kk]]
[11:00:21.323]                   NAME <- NAMES[[kk]]
[11:00:21.323]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:21.323]                     next
[11:00:21.323]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:21.323]                 }
[11:00:21.323]                 if (length(args) > 0) 
[11:00:21.323]                   base::do.call(base::Sys.setenv, args = args)
[11:00:21.323]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:21.323]             }
[11:00:21.323]             else {
[11:00:21.323]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:21.323]             }
[11:00:21.323]             {
[11:00:21.323]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:21.323]                   0L) {
[11:00:21.323]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:21.323]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:21.323]                   base::options(opts)
[11:00:21.323]                 }
[11:00:21.323]                 {
[11:00:21.323]                   {
[11:00:21.323]                     NULL
[11:00:21.323]                     RNGkind("Mersenne-Twister")
[11:00:21.323]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:21.323]                       inherits = FALSE)
[11:00:21.323]                   }
[11:00:21.323]                   options(future.plan = NULL)
[11:00:21.323]                   if (is.na(NA_character_)) 
[11:00:21.323]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:21.323]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:21.323]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:21.323]                     .init = FALSE)
[11:00:21.323]                 }
[11:00:21.323]             }
[11:00:21.323]         }
[11:00:21.323]     })
[11:00:21.323]     if (FALSE) {
[11:00:21.323]         base::sink(type = "output", split = FALSE)
[11:00:21.323]         if (NA) {
[11:00:21.323]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:21.323]         }
[11:00:21.323]         else {
[11:00:21.323]             ...future.result["stdout"] <- base::list(NULL)
[11:00:21.323]         }
[11:00:21.323]         base::close(...future.stdout)
[11:00:21.323]         ...future.stdout <- NULL
[11:00:21.323]     }
[11:00:21.323]     ...future.result$conditions <- ...future.conditions
[11:00:21.323]     ...future.result$finished <- base::Sys.time()
[11:00:21.323]     ...future.result
[11:00:21.323] }
[11:00:21.325] assign_globals() ...
[11:00:21.325] List of 5
[11:00:21.325]  $ ...future.FUN            :function (x)  
[11:00:21.325]  $ future.call.arguments    : list()
[11:00:21.325]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:21.325]  $ ...future.elements_ii    :List of 2
[11:00:21.325]   ..$ : int 1
[11:00:21.325]   ..$ : int 0
[11:00:21.325]  $ ...future.seeds_ii       : NULL
[11:00:21.325]  $ ...future.globals.maxSize: NULL
[11:00:21.325]  - attr(*, "where")=List of 5
[11:00:21.325]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:21.325]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:21.325]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:21.325]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:21.325]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:21.325]  - attr(*, "resolved")= logi FALSE
[11:00:21.325]  - attr(*, "total_size")= num 5632
[11:00:21.325]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:21.325]  - attr(*, "already-done")= logi TRUE
[11:00:21.329] - reassign environment for ‘...future.FUN’
[11:00:21.329] - copied ‘...future.FUN’ to environment
[11:00:21.329] - copied ‘future.call.arguments’ to environment
[11:00:21.330] - copied ‘...future.elements_ii’ to environment
[11:00:21.330] - copied ‘...future.seeds_ii’ to environment
[11:00:21.330] - copied ‘...future.globals.maxSize’ to environment
[11:00:21.330] assign_globals() ... done
[11:00:21.330] plan(): Setting new future strategy stack:
[11:00:21.330] List of future strategies:
[11:00:21.330] 1. sequential:
[11:00:21.330]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:21.330]    - tweaked: FALSE
[11:00:21.330]    - call: NULL
[11:00:21.330] plan(): nbrOfWorkers() = 1
[11:00:21.832] plan(): Setting new future strategy stack:
[11:00:21.832] List of future strategies:
[11:00:21.832] 1. multisession:
[11:00:21.832]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:00:21.832]    - tweaked: FALSE
[11:00:21.832]    - call: plan(strategy)
[11:00:21.834] plan(): nbrOfWorkers() = 1
[11:00:21.834] SequentialFuture started (and completed)
[11:00:21.834] - Launch lazy future ... done
[11:00:21.834] run() for ‘SequentialFuture’ ... done
[11:00:21.834] Created future:
[11:00:21.835] SequentialFuture:
[11:00:21.835] Label: ‘future_lapply-1’
[11:00:21.835] Expression:
[11:00:21.835] {
[11:00:21.835]     do.call(function(...) {
[11:00:21.835]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:21.835]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:21.835]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:21.835]             on.exit(options(oopts), add = TRUE)
[11:00:21.835]         }
[11:00:21.835]         {
[11:00:21.835]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:21.835]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:21.835]                 ...future.FUN(...future.X_jj, ...)
[11:00:21.835]             })
[11:00:21.835]         }
[11:00:21.835]     }, args = future.call.arguments)
[11:00:21.835] }
[11:00:21.835] Lazy evaluation: FALSE
[11:00:21.835] Asynchronous evaluation: FALSE
[11:00:21.835] Local evaluation: TRUE
[11:00:21.835] Environment: R_GlobalEnv
[11:00:21.835] Capture standard output: NA
[11:00:21.835] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:21.835] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:21.835] Packages: <none>
[11:00:21.835] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:21.835] Resolved: TRUE
[11:00:21.835] Value: 55 bytes of class ‘list’
[11:00:21.835] Early signaling: FALSE
[11:00:21.835] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:21.835] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:21.835] Chunk #1 of 1 ... DONE
[11:00:21.836] Launching 1 futures (chunks) ... DONE
[11:00:21.836] Resolving 1 futures (chunks) ...
[11:00:21.836] resolve() on list ...
[11:00:21.836]  recursive: 0
[11:00:21.836]  length: 1
[11:00:21.836] 
[11:00:21.836] resolved() for ‘SequentialFuture’ ...
[11:00:21.836] - state: ‘finished’
[11:00:21.836] - run: TRUE
[11:00:21.836] - result: ‘FutureResult’
[11:00:21.836] resolved() for ‘SequentialFuture’ ... done
[11:00:21.837] Future #1
[11:00:21.837] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:21.837] - nx: 1
[11:00:21.837] - relay: TRUE
[11:00:21.837] - stdout: TRUE
[11:00:21.837] - signal: TRUE
[11:00:21.837] - resignal: FALSE
[11:00:21.837] - force: TRUE
[11:00:21.837] - relayed: [n=1] FALSE
[11:00:21.837] - queued futures: [n=1] FALSE
[11:00:21.837]  - until=1
[11:00:21.838]  - relaying element #1
[11:00:21.838] - relayed: [n=1] TRUE
[11:00:21.838] - queued futures: [n=1] TRUE
[11:00:21.838] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:21.838]  length: 0 (resolved future 1)
[11:00:21.838] Relaying remaining futures
[11:00:21.838] signalConditionsASAP(NULL, pos=0) ...
[11:00:21.838] - nx: 1
[11:00:21.838] - relay: TRUE
[11:00:21.838] - stdout: TRUE
[11:00:21.838] - signal: TRUE
[11:00:21.839] - resignal: FALSE
[11:00:21.839] - force: TRUE
[11:00:21.839] - relayed: [n=1] TRUE
[11:00:21.839] - queued futures: [n=1] TRUE
 - flush all
[11:00:21.839] - relayed: [n=1] TRUE
[11:00:21.839] - queued futures: [n=1] TRUE
[11:00:21.839] signalConditionsASAP(NULL, pos=0) ... done
[11:00:21.839] resolve() on list ... DONE
[11:00:21.839]  - Number of value chunks collected: 1
[11:00:21.839] Resolving 1 futures (chunks) ... DONE
[11:00:21.839] Reducing values from 1 chunks ...
[11:00:21.840]  - Number of values collected after concatenation: 2
[11:00:21.840]  - Number of values expected: 2
[11:00:21.840] Reducing values from 1 chunks ... DONE
[11:00:21.840] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[11:00:21.840] future_mapply() ...
[11:00:21.841] Number of chunks: 1
[11:00:21.842] getGlobalsAndPackagesXApply() ...
[11:00:21.842]  - future.globals: TRUE
[11:00:21.842] getGlobalsAndPackages() ...
[11:00:21.843] Searching for globals...
[11:00:21.845] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[11:00:21.845] Searching for globals ... DONE
[11:00:21.845] Resolving globals: FALSE
[11:00:21.846] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[11:00:21.846] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[11:00:21.846] - globals: [1] ‘FUN’
[11:00:21.846] 
[11:00:21.846] getGlobalsAndPackages() ... DONE
[11:00:21.846]  - globals found/used: [n=1] ‘FUN’
[11:00:21.846]  - needed namespaces: [n=0] 
[11:00:21.847] Finding globals ... DONE
[11:00:21.847] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[11:00:21.847] List of 2
[11:00:21.847]  $ ...future.FUN:function (x, y)  
[11:00:21.847]  $ MoreArgs     : NULL
[11:00:21.847]  - attr(*, "where")=List of 2
[11:00:21.847]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:21.847]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[11:00:21.847]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:21.847]  - attr(*, "resolved")= logi FALSE
[11:00:21.847]  - attr(*, "total_size")= num NA
[11:00:21.849] Packages to be attached in all futures: [n=0] 
[11:00:21.849] getGlobalsAndPackagesXApply() ... DONE
[11:00:21.850] Number of futures (= number of chunks): 1
[11:00:21.850] Launching 1 futures (chunks) ...
[11:00:21.850] Chunk #1 of 1 ...
[11:00:21.850]  - Finding globals in '...' for chunk #1 ...
[11:00:21.850] getGlobalsAndPackages() ...
[11:00:21.850] Searching for globals...
[11:00:21.850] 
[11:00:21.850] Searching for globals ... DONE
[11:00:21.850] - globals: [0] <none>
[11:00:21.851] getGlobalsAndPackages() ... DONE
[11:00:21.851]    + additional globals found: [n=0] 
[11:00:21.851]    + additional namespaces needed: [n=0] 
[11:00:21.851]  - Finding globals in '...' for chunk #1 ... DONE
[11:00:21.851]  - seeds: <none>
[11:00:21.851]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:21.851] getGlobalsAndPackages() ...
[11:00:21.851] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:21.851] Resolving globals: FALSE
[11:00:21.852] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[11:00:21.852] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[11:00:21.852] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:21.852] 
[11:00:21.852] getGlobalsAndPackages() ... DONE
[11:00:21.853] run() for ‘Future’ ...
[11:00:21.853] - state: ‘created’
[11:00:21.853] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:21.854] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:21.854] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:21.854]   - Field: ‘label’
[11:00:21.855]   - Field: ‘local’
[11:00:21.855]   - Field: ‘owner’
[11:00:21.855]   - Field: ‘envir’
[11:00:21.855]   - Field: ‘packages’
[11:00:21.855]   - Field: ‘gc’
[11:00:21.855]   - Field: ‘conditions’
[11:00:21.855]   - Field: ‘expr’
[11:00:21.855]   - Field: ‘uuid’
[11:00:21.855]   - Field: ‘seed’
[11:00:21.855]   - Field: ‘version’
[11:00:21.855]   - Field: ‘result’
[11:00:21.855]   - Field: ‘asynchronous’
[11:00:21.856]   - Field: ‘calls’
[11:00:21.856]   - Field: ‘globals’
[11:00:21.856]   - Field: ‘stdout’
[11:00:21.856]   - Field: ‘earlySignal’
[11:00:21.856]   - Field: ‘lazy’
[11:00:21.856]   - Field: ‘state’
[11:00:21.856] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:21.856] - Launch lazy future ...
[11:00:21.856] Packages needed by the future expression (n = 0): <none>
[11:00:21.856] Packages needed by future strategies (n = 0): <none>
[11:00:21.857] {
[11:00:21.857]     {
[11:00:21.857]         {
[11:00:21.857]             ...future.startTime <- base::Sys.time()
[11:00:21.857]             {
[11:00:21.857]                 {
[11:00:21.857]                   {
[11:00:21.857]                     base::local({
[11:00:21.857]                       has_future <- base::requireNamespace("future", 
[11:00:21.857]                         quietly = TRUE)
[11:00:21.857]                       if (has_future) {
[11:00:21.857]                         ns <- base::getNamespace("future")
[11:00:21.857]                         version <- ns[[".package"]][["version"]]
[11:00:21.857]                         if (is.null(version)) 
[11:00:21.857]                           version <- utils::packageVersion("future")
[11:00:21.857]                       }
[11:00:21.857]                       else {
[11:00:21.857]                         version <- NULL
[11:00:21.857]                       }
[11:00:21.857]                       if (!has_future || version < "1.8.0") {
[11:00:21.857]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:21.857]                           "", base::R.version$version.string), 
[11:00:21.857]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:21.857]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:21.857]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:21.857]                             "release", "version")], collapse = " "), 
[11:00:21.857]                           hostname = base::Sys.info()[["nodename"]])
[11:00:21.857]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:21.857]                           info)
[11:00:21.857]                         info <- base::paste(info, collapse = "; ")
[11:00:21.857]                         if (!has_future) {
[11:00:21.857]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:21.857]                             info)
[11:00:21.857]                         }
[11:00:21.857]                         else {
[11:00:21.857]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:21.857]                             info, version)
[11:00:21.857]                         }
[11:00:21.857]                         base::stop(msg)
[11:00:21.857]                       }
[11:00:21.857]                     })
[11:00:21.857]                   }
[11:00:21.857]                   ...future.strategy.old <- future::plan("list")
[11:00:21.857]                   options(future.plan = NULL)
[11:00:21.857]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:21.857]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:21.857]                 }
[11:00:21.857]                 ...future.workdir <- getwd()
[11:00:21.857]             }
[11:00:21.857]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:21.857]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:21.857]         }
[11:00:21.857]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:21.857]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:21.857]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:21.857]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:21.857]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:21.857]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:21.857]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:21.857]             base::names(...future.oldOptions))
[11:00:21.857]     }
[11:00:21.857]     if (FALSE) {
[11:00:21.857]     }
[11:00:21.857]     else {
[11:00:21.857]         if (FALSE) {
[11:00:21.857]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:21.857]                 open = "w")
[11:00:21.857]         }
[11:00:21.857]         else {
[11:00:21.857]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:21.857]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:21.857]         }
[11:00:21.857]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:21.857]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:21.857]             base::sink(type = "output", split = FALSE)
[11:00:21.857]             base::close(...future.stdout)
[11:00:21.857]         }, add = TRUE)
[11:00:21.857]     }
[11:00:21.857]     ...future.frame <- base::sys.nframe()
[11:00:21.857]     ...future.conditions <- base::list()
[11:00:21.857]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:21.857]     if (FALSE) {
[11:00:21.857]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:21.857]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:21.857]     }
[11:00:21.857]     ...future.result <- base::tryCatch({
[11:00:21.857]         base::withCallingHandlers({
[11:00:21.857]             ...future.value <- base::withVisible(base::local({
[11:00:21.857]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:21.857]                 if (!identical(...future.globals.maxSize.org, 
[11:00:21.857]                   ...future.globals.maxSize)) {
[11:00:21.857]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:21.857]                   on.exit(options(oopts), add = TRUE)
[11:00:21.857]                 }
[11:00:21.857]                 {
[11:00:21.857]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:21.857]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:00:21.857]                     USE.NAMES = FALSE)
[11:00:21.857]                   do.call(mapply, args = args)
[11:00:21.857]                 }
[11:00:21.857]             }))
[11:00:21.857]             future::FutureResult(value = ...future.value$value, 
[11:00:21.857]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:21.857]                   ...future.rng), globalenv = if (FALSE) 
[11:00:21.857]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:21.857]                     ...future.globalenv.names))
[11:00:21.857]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:21.857]         }, condition = base::local({
[11:00:21.857]             c <- base::c
[11:00:21.857]             inherits <- base::inherits
[11:00:21.857]             invokeRestart <- base::invokeRestart
[11:00:21.857]             length <- base::length
[11:00:21.857]             list <- base::list
[11:00:21.857]             seq.int <- base::seq.int
[11:00:21.857]             signalCondition <- base::signalCondition
[11:00:21.857]             sys.calls <- base::sys.calls
[11:00:21.857]             `[[` <- base::`[[`
[11:00:21.857]             `+` <- base::`+`
[11:00:21.857]             `<<-` <- base::`<<-`
[11:00:21.857]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:21.857]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:21.857]                   3L)]
[11:00:21.857]             }
[11:00:21.857]             function(cond) {
[11:00:21.857]                 is_error <- inherits(cond, "error")
[11:00:21.857]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:21.857]                   NULL)
[11:00:21.857]                 if (is_error) {
[11:00:21.857]                   sessionInformation <- function() {
[11:00:21.857]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:21.857]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:21.857]                       search = base::search(), system = base::Sys.info())
[11:00:21.857]                   }
[11:00:21.857]                   ...future.conditions[[length(...future.conditions) + 
[11:00:21.857]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:21.857]                     cond$call), session = sessionInformation(), 
[11:00:21.857]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:21.857]                   signalCondition(cond)
[11:00:21.857]                 }
[11:00:21.857]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:21.857]                 "immediateCondition"))) {
[11:00:21.857]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:21.857]                   ...future.conditions[[length(...future.conditions) + 
[11:00:21.857]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:21.857]                   if (TRUE && !signal) {
[11:00:21.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:21.857]                     {
[11:00:21.857]                       inherits <- base::inherits
[11:00:21.857]                       invokeRestart <- base::invokeRestart
[11:00:21.857]                       is.null <- base::is.null
[11:00:21.857]                       muffled <- FALSE
[11:00:21.857]                       if (inherits(cond, "message")) {
[11:00:21.857]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:21.857]                         if (muffled) 
[11:00:21.857]                           invokeRestart("muffleMessage")
[11:00:21.857]                       }
[11:00:21.857]                       else if (inherits(cond, "warning")) {
[11:00:21.857]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:21.857]                         if (muffled) 
[11:00:21.857]                           invokeRestart("muffleWarning")
[11:00:21.857]                       }
[11:00:21.857]                       else if (inherits(cond, "condition")) {
[11:00:21.857]                         if (!is.null(pattern)) {
[11:00:21.857]                           computeRestarts <- base::computeRestarts
[11:00:21.857]                           grepl <- base::grepl
[11:00:21.857]                           restarts <- computeRestarts(cond)
[11:00:21.857]                           for (restart in restarts) {
[11:00:21.857]                             name <- restart$name
[11:00:21.857]                             if (is.null(name)) 
[11:00:21.857]                               next
[11:00:21.857]                             if (!grepl(pattern, name)) 
[11:00:21.857]                               next
[11:00:21.857]                             invokeRestart(restart)
[11:00:21.857]                             muffled <- TRUE
[11:00:21.857]                             break
[11:00:21.857]                           }
[11:00:21.857]                         }
[11:00:21.857]                       }
[11:00:21.857]                       invisible(muffled)
[11:00:21.857]                     }
[11:00:21.857]                     muffleCondition(cond, pattern = "^muffle")
[11:00:21.857]                   }
[11:00:21.857]                 }
[11:00:21.857]                 else {
[11:00:21.857]                   if (TRUE) {
[11:00:21.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:21.857]                     {
[11:00:21.857]                       inherits <- base::inherits
[11:00:21.857]                       invokeRestart <- base::invokeRestart
[11:00:21.857]                       is.null <- base::is.null
[11:00:21.857]                       muffled <- FALSE
[11:00:21.857]                       if (inherits(cond, "message")) {
[11:00:21.857]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:21.857]                         if (muffled) 
[11:00:21.857]                           invokeRestart("muffleMessage")
[11:00:21.857]                       }
[11:00:21.857]                       else if (inherits(cond, "warning")) {
[11:00:21.857]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:21.857]                         if (muffled) 
[11:00:21.857]                           invokeRestart("muffleWarning")
[11:00:21.857]                       }
[11:00:21.857]                       else if (inherits(cond, "condition")) {
[11:00:21.857]                         if (!is.null(pattern)) {
[11:00:21.857]                           computeRestarts <- base::computeRestarts
[11:00:21.857]                           grepl <- base::grepl
[11:00:21.857]                           restarts <- computeRestarts(cond)
[11:00:21.857]                           for (restart in restarts) {
[11:00:21.857]                             name <- restart$name
[11:00:21.857]                             if (is.null(name)) 
[11:00:21.857]                               next
[11:00:21.857]                             if (!grepl(pattern, name)) 
[11:00:21.857]                               next
[11:00:21.857]                             invokeRestart(restart)
[11:00:21.857]                             muffled <- TRUE
[11:00:21.857]                             break
[11:00:21.857]                           }
[11:00:21.857]                         }
[11:00:21.857]                       }
[11:00:21.857]                       invisible(muffled)
[11:00:21.857]                     }
[11:00:21.857]                     muffleCondition(cond, pattern = "^muffle")
[11:00:21.857]                   }
[11:00:21.857]                 }
[11:00:21.857]             }
[11:00:21.857]         }))
[11:00:21.857]     }, error = function(ex) {
[11:00:21.857]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:21.857]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:21.857]                 ...future.rng), started = ...future.startTime, 
[11:00:21.857]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:21.857]             version = "1.8"), class = "FutureResult")
[11:00:21.857]     }, finally = {
[11:00:21.857]         if (!identical(...future.workdir, getwd())) 
[11:00:21.857]             setwd(...future.workdir)
[11:00:21.857]         {
[11:00:21.857]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:21.857]                 ...future.oldOptions$nwarnings <- NULL
[11:00:21.857]             }
[11:00:21.857]             base::options(...future.oldOptions)
[11:00:21.857]             if (.Platform$OS.type == "windows") {
[11:00:21.857]                 old_names <- names(...future.oldEnvVars)
[11:00:21.857]                 envs <- base::Sys.getenv()
[11:00:21.857]                 names <- names(envs)
[11:00:21.857]                 common <- intersect(names, old_names)
[11:00:21.857]                 added <- setdiff(names, old_names)
[11:00:21.857]                 removed <- setdiff(old_names, names)
[11:00:21.857]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:21.857]                   envs[common]]
[11:00:21.857]                 NAMES <- toupper(changed)
[11:00:21.857]                 args <- list()
[11:00:21.857]                 for (kk in seq_along(NAMES)) {
[11:00:21.857]                   name <- changed[[kk]]
[11:00:21.857]                   NAME <- NAMES[[kk]]
[11:00:21.857]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:21.857]                     next
[11:00:21.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:21.857]                 }
[11:00:21.857]                 NAMES <- toupper(added)
[11:00:21.857]                 for (kk in seq_along(NAMES)) {
[11:00:21.857]                   name <- added[[kk]]
[11:00:21.857]                   NAME <- NAMES[[kk]]
[11:00:21.857]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:21.857]                     next
[11:00:21.857]                   args[[name]] <- ""
[11:00:21.857]                 }
[11:00:21.857]                 NAMES <- toupper(removed)
[11:00:21.857]                 for (kk in seq_along(NAMES)) {
[11:00:21.857]                   name <- removed[[kk]]
[11:00:21.857]                   NAME <- NAMES[[kk]]
[11:00:21.857]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:21.857]                     next
[11:00:21.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:21.857]                 }
[11:00:21.857]                 if (length(args) > 0) 
[11:00:21.857]                   base::do.call(base::Sys.setenv, args = args)
[11:00:21.857]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:21.857]             }
[11:00:21.857]             else {
[11:00:21.857]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:21.857]             }
[11:00:21.857]             {
[11:00:21.857]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:21.857]                   0L) {
[11:00:21.857]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:21.857]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:21.857]                   base::options(opts)
[11:00:21.857]                 }
[11:00:21.857]                 {
[11:00:21.857]                   {
[11:00:21.857]                     NULL
[11:00:21.857]                     RNGkind("Mersenne-Twister")
[11:00:21.857]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:21.857]                       inherits = FALSE)
[11:00:21.857]                   }
[11:00:21.857]                   options(future.plan = NULL)
[11:00:21.857]                   if (is.na(NA_character_)) 
[11:00:21.857]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:21.857]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:21.857]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:21.857]                     .init = FALSE)
[11:00:21.857]                 }
[11:00:21.857]             }
[11:00:21.857]         }
[11:00:21.857]     })
[11:00:21.857]     if (TRUE) {
[11:00:21.857]         base::sink(type = "output", split = FALSE)
[11:00:21.857]         if (FALSE) {
[11:00:21.857]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:21.857]         }
[11:00:21.857]         else {
[11:00:21.857]             ...future.result["stdout"] <- base::list(NULL)
[11:00:21.857]         }
[11:00:21.857]         base::close(...future.stdout)
[11:00:21.857]         ...future.stdout <- NULL
[11:00:21.857]     }
[11:00:21.857]     ...future.result$conditions <- ...future.conditions
[11:00:21.857]     ...future.result$finished <- base::Sys.time()
[11:00:21.857]     ...future.result
[11:00:21.857] }
[11:00:21.859] assign_globals() ...
[11:00:21.859] List of 5
[11:00:21.859]  $ ...future.FUN            :function (x, y)  
[11:00:21.859]  $ MoreArgs                 : NULL
[11:00:21.859]  $ ...future.elements_ii    :List of 2
[11:00:21.859]   ..$ :List of 2
[11:00:21.859]   .. ..$ : int 1
[11:00:21.859]   .. ..$ : int 0
[11:00:21.859]   ..$ :List of 2
[11:00:21.859]   .. ..$ : int 0
[11:00:21.859]   .. ..$ : int 1
[11:00:21.859]  $ ...future.seeds_ii       : NULL
[11:00:21.859]  $ ...future.globals.maxSize: NULL
[11:00:21.859]  - attr(*, "where")=List of 5
[11:00:21.859]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:21.859]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[11:00:21.859]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:21.859]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:21.859]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:21.859]  - attr(*, "resolved")= logi FALSE
[11:00:21.859]  - attr(*, "total_size")= num 1242
[11:00:21.859]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:21.859]  - attr(*, "already-done")= logi TRUE
[11:00:21.864] - reassign environment for ‘...future.FUN’
[11:00:21.864] - copied ‘...future.FUN’ to environment
[11:00:21.864] - copied ‘MoreArgs’ to environment
[11:00:21.864] - copied ‘...future.elements_ii’ to environment
[11:00:21.864] - copied ‘...future.seeds_ii’ to environment
[11:00:21.864] - copied ‘...future.globals.maxSize’ to environment
[11:00:21.864] assign_globals() ... done
[11:00:21.865] plan(): Setting new future strategy stack:
[11:00:21.865] List of future strategies:
[11:00:21.865] 1. sequential:
[11:00:21.865]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:21.865]    - tweaked: FALSE
[11:00:21.865]    - call: NULL
[11:00:21.865] plan(): nbrOfWorkers() = 1
[11:00:22.367] plan(): Setting new future strategy stack:
[11:00:22.367] List of future strategies:
[11:00:22.367] 1. multisession:
[11:00:22.367]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:00:22.367]    - tweaked: FALSE
[11:00:22.367]    - call: plan(strategy)
[11:00:22.369] plan(): nbrOfWorkers() = 1
[11:00:22.369] SequentialFuture started (and completed)
[11:00:22.369] - Launch lazy future ... done
[11:00:22.369] run() for ‘SequentialFuture’ ... done
[11:00:22.369] Created future:
[11:00:22.369] SequentialFuture:
[11:00:22.369] Label: ‘future_mapply-1’
[11:00:22.369] Expression:
[11:00:22.369] {
[11:00:22.369]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:22.369]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:22.369]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:22.369]         on.exit(options(oopts), add = TRUE)
[11:00:22.369]     }
[11:00:22.369]     {
[11:00:22.369]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:22.369]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:00:22.369]         do.call(mapply, args = args)
[11:00:22.369]     }
[11:00:22.369] }
[11:00:22.369] Lazy evaluation: FALSE
[11:00:22.369] Asynchronous evaluation: FALSE
[11:00:22.369] Local evaluation: TRUE
[11:00:22.369] Environment: R_GlobalEnv
[11:00:22.369] Capture standard output: FALSE
[11:00:22.369] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:22.369] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:22.369] Packages: <none>
[11:00:22.369] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:22.369] Resolved: TRUE
[11:00:22.369] Value: 184 bytes of class ‘list’
[11:00:22.369] Early signaling: FALSE
[11:00:22.369] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:22.369] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:22.372] Chunk #1 of 1 ... DONE
[11:00:22.372] Launching 1 futures (chunks) ... DONE
[11:00:22.372] Resolving 1 futures (chunks) ...
[11:00:22.372] resolve() on list ...
[11:00:22.372]  recursive: 0
[11:00:22.372]  length: 1
[11:00:22.372] 
[11:00:22.373] resolved() for ‘SequentialFuture’ ...
[11:00:22.373] - state: ‘finished’
[11:00:22.373] - run: TRUE
[11:00:22.373] - result: ‘FutureResult’
[11:00:22.373] resolved() for ‘SequentialFuture’ ... done
[11:00:22.373] Future #1
[11:00:22.373] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:22.373] - nx: 1
[11:00:22.373] - relay: TRUE
[11:00:22.374] - stdout: TRUE
[11:00:22.374] - signal: TRUE
[11:00:22.374] - resignal: FALSE
[11:00:22.374] - force: TRUE
[11:00:22.374] - relayed: [n=1] FALSE
[11:00:22.374] - queued futures: [n=1] FALSE
[11:00:22.374]  - until=1
[11:00:22.374]  - relaying element #1
[11:00:22.374] - relayed: [n=1] TRUE
[11:00:22.374] - queued futures: [n=1] TRUE
[11:00:22.375] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:22.375]  length: 0 (resolved future 1)
[11:00:22.375] Relaying remaining futures
[11:00:22.375] signalConditionsASAP(NULL, pos=0) ...
[11:00:22.375] - nx: 1
[11:00:22.375] - relay: TRUE
[11:00:22.375] - stdout: TRUE
[11:00:22.375] - signal: TRUE
[11:00:22.375] - resignal: FALSE
[11:00:22.375] - force: TRUE
[11:00:22.375] - relayed: [n=1] TRUE
[11:00:22.375] - queued futures: [n=1] TRUE
 - flush all
[11:00:22.376] - relayed: [n=1] TRUE
[11:00:22.376] - queued futures: [n=1] TRUE
[11:00:22.376] signalConditionsASAP(NULL, pos=0) ... done
[11:00:22.376] resolve() on list ... DONE
[11:00:22.376]  - Number of value chunks collected: 1
[11:00:22.376] Resolving 1 futures (chunks) ... DONE
[11:00:22.376] Reducing values from 1 chunks ...
[11:00:22.376]  - Number of values collected after concatenation: 2
[11:00:22.376]  - Number of values expected: 2
[11:00:22.376] Reducing values from 1 chunks ... DONE
[11:00:22.376] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[11:00:22.377] future_mapply() ...
[11:00:22.378] Number of chunks: 1
[11:00:22.378] getGlobalsAndPackagesXApply() ...
[11:00:22.378]  - future.globals: TRUE
[11:00:22.378] getGlobalsAndPackages() ...
[11:00:22.378] Searching for globals...
[11:00:22.380] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[11:00:22.380] Searching for globals ... DONE
[11:00:22.380] Resolving globals: FALSE
[11:00:22.381] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[11:00:22.381] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[11:00:22.381] - globals: [1] ‘FUN’
[11:00:22.381] 
[11:00:22.381] getGlobalsAndPackages() ... DONE
[11:00:22.381]  - globals found/used: [n=1] ‘FUN’
[11:00:22.381]  - needed namespaces: [n=0] 
[11:00:22.381] Finding globals ... DONE
[11:00:22.382] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[11:00:22.382] List of 2
[11:00:22.382]  $ ...future.FUN:function (x, y)  
[11:00:22.382]  $ MoreArgs     : NULL
[11:00:22.382]  - attr(*, "where")=List of 2
[11:00:22.382]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:22.382]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[11:00:22.382]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:22.382]  - attr(*, "resolved")= logi FALSE
[11:00:22.382]  - attr(*, "total_size")= num NA
[11:00:22.384] Packages to be attached in all futures: [n=0] 
[11:00:22.384] getGlobalsAndPackagesXApply() ... DONE
[11:00:22.384] Number of futures (= number of chunks): 1
[11:00:22.385] Launching 1 futures (chunks) ...
[11:00:22.385] Chunk #1 of 1 ...
[11:00:22.385]  - Finding globals in '...' for chunk #1 ...
[11:00:22.385] getGlobalsAndPackages() ...
[11:00:22.385] Searching for globals...
[11:00:22.385] 
[11:00:22.385] Searching for globals ... DONE
[11:00:22.385] - globals: [0] <none>
[11:00:22.385] getGlobalsAndPackages() ... DONE
[11:00:22.386]    + additional globals found: [n=0] 
[11:00:22.386]    + additional namespaces needed: [n=0] 
[11:00:22.386]  - Finding globals in '...' for chunk #1 ... DONE
[11:00:22.386]  - seeds: <none>
[11:00:22.386]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:22.386] getGlobalsAndPackages() ...
[11:00:22.386] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:22.386] Resolving globals: FALSE
[11:00:22.387] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[11:00:22.387] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[11:00:22.387] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:22.387] 
[11:00:22.387] getGlobalsAndPackages() ... DONE
[11:00:22.388] run() for ‘Future’ ...
[11:00:22.388] - state: ‘created’
[11:00:22.388] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:22.389] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:22.389] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:22.389]   - Field: ‘label’
[11:00:22.389]   - Field: ‘local’
[11:00:22.390]   - Field: ‘owner’
[11:00:22.390]   - Field: ‘envir’
[11:00:22.390]   - Field: ‘packages’
[11:00:22.390]   - Field: ‘gc’
[11:00:22.390]   - Field: ‘conditions’
[11:00:22.390]   - Field: ‘expr’
[11:00:22.390]   - Field: ‘uuid’
[11:00:22.390]   - Field: ‘seed’
[11:00:22.390]   - Field: ‘version’
[11:00:22.390]   - Field: ‘result’
[11:00:22.390]   - Field: ‘asynchronous’
[11:00:22.390]   - Field: ‘calls’
[11:00:22.391]   - Field: ‘globals’
[11:00:22.391]   - Field: ‘stdout’
[11:00:22.391]   - Field: ‘earlySignal’
[11:00:22.391]   - Field: ‘lazy’
[11:00:22.391]   - Field: ‘state’
[11:00:22.391] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:22.391] - Launch lazy future ...
[11:00:22.391] Packages needed by the future expression (n = 0): <none>
[11:00:22.391] Packages needed by future strategies (n = 0): <none>
[11:00:22.392] {
[11:00:22.392]     {
[11:00:22.392]         {
[11:00:22.392]             ...future.startTime <- base::Sys.time()
[11:00:22.392]             {
[11:00:22.392]                 {
[11:00:22.392]                   {
[11:00:22.392]                     base::local({
[11:00:22.392]                       has_future <- base::requireNamespace("future", 
[11:00:22.392]                         quietly = TRUE)
[11:00:22.392]                       if (has_future) {
[11:00:22.392]                         ns <- base::getNamespace("future")
[11:00:22.392]                         version <- ns[[".package"]][["version"]]
[11:00:22.392]                         if (is.null(version)) 
[11:00:22.392]                           version <- utils::packageVersion("future")
[11:00:22.392]                       }
[11:00:22.392]                       else {
[11:00:22.392]                         version <- NULL
[11:00:22.392]                       }
[11:00:22.392]                       if (!has_future || version < "1.8.0") {
[11:00:22.392]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:22.392]                           "", base::R.version$version.string), 
[11:00:22.392]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:22.392]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:22.392]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:22.392]                             "release", "version")], collapse = " "), 
[11:00:22.392]                           hostname = base::Sys.info()[["nodename"]])
[11:00:22.392]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:22.392]                           info)
[11:00:22.392]                         info <- base::paste(info, collapse = "; ")
[11:00:22.392]                         if (!has_future) {
[11:00:22.392]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:22.392]                             info)
[11:00:22.392]                         }
[11:00:22.392]                         else {
[11:00:22.392]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:22.392]                             info, version)
[11:00:22.392]                         }
[11:00:22.392]                         base::stop(msg)
[11:00:22.392]                       }
[11:00:22.392]                     })
[11:00:22.392]                   }
[11:00:22.392]                   ...future.strategy.old <- future::plan("list")
[11:00:22.392]                   options(future.plan = NULL)
[11:00:22.392]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:22.392]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:22.392]                 }
[11:00:22.392]                 ...future.workdir <- getwd()
[11:00:22.392]             }
[11:00:22.392]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:22.392]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:22.392]         }
[11:00:22.392]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:22.392]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:22.392]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:22.392]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:22.392]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:22.392]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:22.392]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:22.392]             base::names(...future.oldOptions))
[11:00:22.392]     }
[11:00:22.392]     if (FALSE) {
[11:00:22.392]     }
[11:00:22.392]     else {
[11:00:22.392]         if (TRUE) {
[11:00:22.392]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:22.392]                 open = "w")
[11:00:22.392]         }
[11:00:22.392]         else {
[11:00:22.392]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:22.392]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:22.392]         }
[11:00:22.392]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:22.392]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:22.392]             base::sink(type = "output", split = FALSE)
[11:00:22.392]             base::close(...future.stdout)
[11:00:22.392]         }, add = TRUE)
[11:00:22.392]     }
[11:00:22.392]     ...future.frame <- base::sys.nframe()
[11:00:22.392]     ...future.conditions <- base::list()
[11:00:22.392]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:22.392]     if (FALSE) {
[11:00:22.392]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:22.392]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:22.392]     }
[11:00:22.392]     ...future.result <- base::tryCatch({
[11:00:22.392]         base::withCallingHandlers({
[11:00:22.392]             ...future.value <- base::withVisible(base::local({
[11:00:22.392]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:22.392]                 if (!identical(...future.globals.maxSize.org, 
[11:00:22.392]                   ...future.globals.maxSize)) {
[11:00:22.392]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:22.392]                   on.exit(options(oopts), add = TRUE)
[11:00:22.392]                 }
[11:00:22.392]                 {
[11:00:22.392]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:22.392]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:00:22.392]                     USE.NAMES = FALSE)
[11:00:22.392]                   do.call(mapply, args = args)
[11:00:22.392]                 }
[11:00:22.392]             }))
[11:00:22.392]             future::FutureResult(value = ...future.value$value, 
[11:00:22.392]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:22.392]                   ...future.rng), globalenv = if (FALSE) 
[11:00:22.392]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:22.392]                     ...future.globalenv.names))
[11:00:22.392]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:22.392]         }, condition = base::local({
[11:00:22.392]             c <- base::c
[11:00:22.392]             inherits <- base::inherits
[11:00:22.392]             invokeRestart <- base::invokeRestart
[11:00:22.392]             length <- base::length
[11:00:22.392]             list <- base::list
[11:00:22.392]             seq.int <- base::seq.int
[11:00:22.392]             signalCondition <- base::signalCondition
[11:00:22.392]             sys.calls <- base::sys.calls
[11:00:22.392]             `[[` <- base::`[[`
[11:00:22.392]             `+` <- base::`+`
[11:00:22.392]             `<<-` <- base::`<<-`
[11:00:22.392]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:22.392]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:22.392]                   3L)]
[11:00:22.392]             }
[11:00:22.392]             function(cond) {
[11:00:22.392]                 is_error <- inherits(cond, "error")
[11:00:22.392]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:22.392]                   NULL)
[11:00:22.392]                 if (is_error) {
[11:00:22.392]                   sessionInformation <- function() {
[11:00:22.392]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:22.392]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:22.392]                       search = base::search(), system = base::Sys.info())
[11:00:22.392]                   }
[11:00:22.392]                   ...future.conditions[[length(...future.conditions) + 
[11:00:22.392]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:22.392]                     cond$call), session = sessionInformation(), 
[11:00:22.392]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:22.392]                   signalCondition(cond)
[11:00:22.392]                 }
[11:00:22.392]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:22.392]                 "immediateCondition"))) {
[11:00:22.392]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:22.392]                   ...future.conditions[[length(...future.conditions) + 
[11:00:22.392]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:22.392]                   if (TRUE && !signal) {
[11:00:22.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:22.392]                     {
[11:00:22.392]                       inherits <- base::inherits
[11:00:22.392]                       invokeRestart <- base::invokeRestart
[11:00:22.392]                       is.null <- base::is.null
[11:00:22.392]                       muffled <- FALSE
[11:00:22.392]                       if (inherits(cond, "message")) {
[11:00:22.392]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:22.392]                         if (muffled) 
[11:00:22.392]                           invokeRestart("muffleMessage")
[11:00:22.392]                       }
[11:00:22.392]                       else if (inherits(cond, "warning")) {
[11:00:22.392]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:22.392]                         if (muffled) 
[11:00:22.392]                           invokeRestart("muffleWarning")
[11:00:22.392]                       }
[11:00:22.392]                       else if (inherits(cond, "condition")) {
[11:00:22.392]                         if (!is.null(pattern)) {
[11:00:22.392]                           computeRestarts <- base::computeRestarts
[11:00:22.392]                           grepl <- base::grepl
[11:00:22.392]                           restarts <- computeRestarts(cond)
[11:00:22.392]                           for (restart in restarts) {
[11:00:22.392]                             name <- restart$name
[11:00:22.392]                             if (is.null(name)) 
[11:00:22.392]                               next
[11:00:22.392]                             if (!grepl(pattern, name)) 
[11:00:22.392]                               next
[11:00:22.392]                             invokeRestart(restart)
[11:00:22.392]                             muffled <- TRUE
[11:00:22.392]                             break
[11:00:22.392]                           }
[11:00:22.392]                         }
[11:00:22.392]                       }
[11:00:22.392]                       invisible(muffled)
[11:00:22.392]                     }
[11:00:22.392]                     muffleCondition(cond, pattern = "^muffle")
[11:00:22.392]                   }
[11:00:22.392]                 }
[11:00:22.392]                 else {
[11:00:22.392]                   if (TRUE) {
[11:00:22.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:22.392]                     {
[11:00:22.392]                       inherits <- base::inherits
[11:00:22.392]                       invokeRestart <- base::invokeRestart
[11:00:22.392]                       is.null <- base::is.null
[11:00:22.392]                       muffled <- FALSE
[11:00:22.392]                       if (inherits(cond, "message")) {
[11:00:22.392]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:22.392]                         if (muffled) 
[11:00:22.392]                           invokeRestart("muffleMessage")
[11:00:22.392]                       }
[11:00:22.392]                       else if (inherits(cond, "warning")) {
[11:00:22.392]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:22.392]                         if (muffled) 
[11:00:22.392]                           invokeRestart("muffleWarning")
[11:00:22.392]                       }
[11:00:22.392]                       else if (inherits(cond, "condition")) {
[11:00:22.392]                         if (!is.null(pattern)) {
[11:00:22.392]                           computeRestarts <- base::computeRestarts
[11:00:22.392]                           grepl <- base::grepl
[11:00:22.392]                           restarts <- computeRestarts(cond)
[11:00:22.392]                           for (restart in restarts) {
[11:00:22.392]                             name <- restart$name
[11:00:22.392]                             if (is.null(name)) 
[11:00:22.392]                               next
[11:00:22.392]                             if (!grepl(pattern, name)) 
[11:00:22.392]                               next
[11:00:22.392]                             invokeRestart(restart)
[11:00:22.392]                             muffled <- TRUE
[11:00:22.392]                             break
[11:00:22.392]                           }
[11:00:22.392]                         }
[11:00:22.392]                       }
[11:00:22.392]                       invisible(muffled)
[11:00:22.392]                     }
[11:00:22.392]                     muffleCondition(cond, pattern = "^muffle")
[11:00:22.392]                   }
[11:00:22.392]                 }
[11:00:22.392]             }
[11:00:22.392]         }))
[11:00:22.392]     }, error = function(ex) {
[11:00:22.392]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:22.392]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:22.392]                 ...future.rng), started = ...future.startTime, 
[11:00:22.392]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:22.392]             version = "1.8"), class = "FutureResult")
[11:00:22.392]     }, finally = {
[11:00:22.392]         if (!identical(...future.workdir, getwd())) 
[11:00:22.392]             setwd(...future.workdir)
[11:00:22.392]         {
[11:00:22.392]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:22.392]                 ...future.oldOptions$nwarnings <- NULL
[11:00:22.392]             }
[11:00:22.392]             base::options(...future.oldOptions)
[11:00:22.392]             if (.Platform$OS.type == "windows") {
[11:00:22.392]                 old_names <- names(...future.oldEnvVars)
[11:00:22.392]                 envs <- base::Sys.getenv()
[11:00:22.392]                 names <- names(envs)
[11:00:22.392]                 common <- intersect(names, old_names)
[11:00:22.392]                 added <- setdiff(names, old_names)
[11:00:22.392]                 removed <- setdiff(old_names, names)
[11:00:22.392]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:22.392]                   envs[common]]
[11:00:22.392]                 NAMES <- toupper(changed)
[11:00:22.392]                 args <- list()
[11:00:22.392]                 for (kk in seq_along(NAMES)) {
[11:00:22.392]                   name <- changed[[kk]]
[11:00:22.392]                   NAME <- NAMES[[kk]]
[11:00:22.392]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:22.392]                     next
[11:00:22.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:22.392]                 }
[11:00:22.392]                 NAMES <- toupper(added)
[11:00:22.392]                 for (kk in seq_along(NAMES)) {
[11:00:22.392]                   name <- added[[kk]]
[11:00:22.392]                   NAME <- NAMES[[kk]]
[11:00:22.392]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:22.392]                     next
[11:00:22.392]                   args[[name]] <- ""
[11:00:22.392]                 }
[11:00:22.392]                 NAMES <- toupper(removed)
[11:00:22.392]                 for (kk in seq_along(NAMES)) {
[11:00:22.392]                   name <- removed[[kk]]
[11:00:22.392]                   NAME <- NAMES[[kk]]
[11:00:22.392]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:22.392]                     next
[11:00:22.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:22.392]                 }
[11:00:22.392]                 if (length(args) > 0) 
[11:00:22.392]                   base::do.call(base::Sys.setenv, args = args)
[11:00:22.392]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:22.392]             }
[11:00:22.392]             else {
[11:00:22.392]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:22.392]             }
[11:00:22.392]             {
[11:00:22.392]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:22.392]                   0L) {
[11:00:22.392]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:22.392]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:22.392]                   base::options(opts)
[11:00:22.392]                 }
[11:00:22.392]                 {
[11:00:22.392]                   {
[11:00:22.392]                     NULL
[11:00:22.392]                     RNGkind("Mersenne-Twister")
[11:00:22.392]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:22.392]                       inherits = FALSE)
[11:00:22.392]                   }
[11:00:22.392]                   options(future.plan = NULL)
[11:00:22.392]                   if (is.na(NA_character_)) 
[11:00:22.392]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:22.392]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:22.392]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:22.392]                     .init = FALSE)
[11:00:22.392]                 }
[11:00:22.392]             }
[11:00:22.392]         }
[11:00:22.392]     })
[11:00:22.392]     if (TRUE) {
[11:00:22.392]         base::sink(type = "output", split = FALSE)
[11:00:22.392]         if (TRUE) {
[11:00:22.392]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:22.392]         }
[11:00:22.392]         else {
[11:00:22.392]             ...future.result["stdout"] <- base::list(NULL)
[11:00:22.392]         }
[11:00:22.392]         base::close(...future.stdout)
[11:00:22.392]         ...future.stdout <- NULL
[11:00:22.392]     }
[11:00:22.392]     ...future.result$conditions <- ...future.conditions
[11:00:22.392]     ...future.result$finished <- base::Sys.time()
[11:00:22.392]     ...future.result
[11:00:22.392] }
[11:00:22.393] assign_globals() ...
[11:00:22.394] List of 5
[11:00:22.394]  $ ...future.FUN            :function (x, y)  
[11:00:22.394]  $ MoreArgs                 : NULL
[11:00:22.394]  $ ...future.elements_ii    :List of 2
[11:00:22.394]   ..$ :List of 2
[11:00:22.394]   .. ..$ : int 1
[11:00:22.394]   .. ..$ : int 0
[11:00:22.394]   ..$ :List of 2
[11:00:22.394]   .. ..$ : int 0
[11:00:22.394]   .. ..$ : int 1
[11:00:22.394]  $ ...future.seeds_ii       : NULL
[11:00:22.394]  $ ...future.globals.maxSize: NULL
[11:00:22.394]  - attr(*, "where")=List of 5
[11:00:22.394]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:22.394]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[11:00:22.394]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:22.394]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:22.394]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:22.394]  - attr(*, "resolved")= logi FALSE
[11:00:22.394]  - attr(*, "total_size")= num 1242
[11:00:22.394]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:22.394]  - attr(*, "already-done")= logi TRUE
[11:00:22.400] - reassign environment for ‘...future.FUN’
[11:00:22.400] - copied ‘...future.FUN’ to environment
[11:00:22.400] - copied ‘MoreArgs’ to environment
[11:00:22.400] - copied ‘...future.elements_ii’ to environment
[11:00:22.400] - copied ‘...future.seeds_ii’ to environment
[11:00:22.400] - copied ‘...future.globals.maxSize’ to environment
[11:00:22.401] assign_globals() ... done
[11:00:22.401] plan(): Setting new future strategy stack:
[11:00:22.401] List of future strategies:
[11:00:22.401] 1. sequential:
[11:00:22.401]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:22.401]    - tweaked: FALSE
[11:00:22.401]    - call: NULL
[11:00:22.401] plan(): nbrOfWorkers() = 1
[11:00:22.903] plan(): Setting new future strategy stack:
[11:00:22.903] List of future strategies:
[11:00:22.903] 1. multisession:
[11:00:22.903]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:00:22.903]    - tweaked: FALSE
[11:00:22.903]    - call: plan(strategy)
[11:00:22.905] plan(): nbrOfWorkers() = 1
[11:00:22.905] SequentialFuture started (and completed)
[11:00:22.905] - Launch lazy future ... done
[11:00:22.905] run() for ‘SequentialFuture’ ... done
[11:00:22.905] Created future:
[11:00:22.906] SequentialFuture:
[11:00:22.906] Label: ‘future_mapply-1’
[11:00:22.906] Expression:
[11:00:22.906] {
[11:00:22.906]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:22.906]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:22.906]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:22.906]         on.exit(options(oopts), add = TRUE)
[11:00:22.906]     }
[11:00:22.906]     {
[11:00:22.906]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:22.906]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:00:22.906]         do.call(mapply, args = args)
[11:00:22.906]     }
[11:00:22.906] }
[11:00:22.906] Lazy evaluation: FALSE
[11:00:22.906] Asynchronous evaluation: FALSE
[11:00:22.906] Local evaluation: TRUE
[11:00:22.906] Environment: R_GlobalEnv
[11:00:22.906] Capture standard output: TRUE
[11:00:22.906] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:22.906] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:22.906] Packages: <none>
[11:00:22.906] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:22.906] Resolved: TRUE
[11:00:22.906] Value: 184 bytes of class ‘list’
[11:00:22.906] Early signaling: FALSE
[11:00:22.906] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:22.906] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:22.906] Chunk #1 of 1 ... DONE
[11:00:22.907] Launching 1 futures (chunks) ... DONE
[11:00:22.907] Resolving 1 futures (chunks) ...
[11:00:22.907] resolve() on list ...
[11:00:22.907]  recursive: 0
[11:00:22.907]  length: 1
[11:00:22.907] 
[11:00:22.907] resolved() for ‘SequentialFuture’ ...
[11:00:22.907] - state: ‘finished’
[11:00:22.907] - run: TRUE
[11:00:22.907] - result: ‘FutureResult’
[11:00:22.907] resolved() for ‘SequentialFuture’ ... done
[11:00:22.908] Future #1
[11:00:22.908] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:22.908] - nx: 1
[11:00:22.908] - relay: TRUE
[11:00:22.908] - stdout: TRUE
[11:00:22.908] - signal: TRUE
[11:00:22.908] - resignal: FALSE
[11:00:22.908] - force: TRUE
[11:00:22.908] - relayed: [n=1] FALSE
[11:00:22.908] - queued futures: [n=1] FALSE
[11:00:22.908]  - until=1
[11:00:22.909]  - relaying element #1
[11:00:22.909] - relayed: [n=1] TRUE
[11:00:22.909] - queued futures: [n=1] TRUE
[11:00:22.909] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:22.909]  length: 0 (resolved future 1)
[11:00:22.909] Relaying remaining futures
[11:00:22.909] signalConditionsASAP(NULL, pos=0) ...
[11:00:22.909] - nx: 1
[11:00:22.909] - relay: TRUE
[11:00:22.909] - stdout: TRUE
[11:00:22.909] - signal: TRUE
[11:00:22.910] - resignal: FALSE
[11:00:22.910] - force: TRUE
[11:00:22.910] - relayed: [n=1] TRUE
[11:00:22.910] - queued futures: [n=1] TRUE
 - flush all
[11:00:22.910] - relayed: [n=1] TRUE
[11:00:22.910] - queued futures: [n=1] TRUE
[11:00:22.910] signalConditionsASAP(NULL, pos=0) ... done
[11:00:22.910] resolve() on list ... DONE
[11:00:22.910]  - Number of value chunks collected: 1
[11:00:22.910] Resolving 1 futures (chunks) ... DONE
[11:00:22.910] Reducing values from 1 chunks ...
[11:00:22.911]  - Number of values collected after concatenation: 2
[11:00:22.911]  - Number of values expected: 2
[11:00:22.911] Reducing values from 1 chunks ... DONE
[11:00:22.911] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[11:00:22.911] future_mapply() ...
[11:00:22.912] Number of chunks: 1
[11:00:22.913] getGlobalsAndPackagesXApply() ...
[11:00:22.913]  - future.globals: TRUE
[11:00:22.913] getGlobalsAndPackages() ...
[11:00:22.913] Searching for globals...
[11:00:22.914] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[11:00:22.914] Searching for globals ... DONE
[11:00:22.915] Resolving globals: FALSE
[11:00:22.915] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[11:00:22.915] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[11:00:22.915] - globals: [1] ‘FUN’
[11:00:22.915] 
[11:00:22.916] getGlobalsAndPackages() ... DONE
[11:00:22.916]  - globals found/used: [n=1] ‘FUN’
[11:00:22.916]  - needed namespaces: [n=0] 
[11:00:22.916] Finding globals ... DONE
[11:00:22.916] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[11:00:22.916] List of 2
[11:00:22.916]  $ ...future.FUN:function (x, y)  
[11:00:22.916]  $ MoreArgs     : NULL
[11:00:22.916]  - attr(*, "where")=List of 2
[11:00:22.916]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:22.916]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[11:00:22.916]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:22.916]  - attr(*, "resolved")= logi FALSE
[11:00:22.916]  - attr(*, "total_size")= num NA
[11:00:22.919] Packages to be attached in all futures: [n=0] 
[11:00:22.919] getGlobalsAndPackagesXApply() ... DONE
[11:00:22.919] Number of futures (= number of chunks): 1
[11:00:22.919] Launching 1 futures (chunks) ...
[11:00:22.919] Chunk #1 of 1 ...
[11:00:22.919]  - Finding globals in '...' for chunk #1 ...
[11:00:22.919] getGlobalsAndPackages() ...
[11:00:22.919] Searching for globals...
[11:00:22.920] 
[11:00:22.920] Searching for globals ... DONE
[11:00:22.920] - globals: [0] <none>
[11:00:22.920] getGlobalsAndPackages() ... DONE
[11:00:22.920]    + additional globals found: [n=0] 
[11:00:22.920]    + additional namespaces needed: [n=0] 
[11:00:22.920]  - Finding globals in '...' for chunk #1 ... DONE
[11:00:22.920]  - seeds: <none>
[11:00:22.920]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:22.920] getGlobalsAndPackages() ...
[11:00:22.920] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:22.921] Resolving globals: FALSE
[11:00:22.921] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[11:00:22.921] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[11:00:22.921] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:22.922] 
[11:00:22.922] getGlobalsAndPackages() ... DONE
[11:00:22.922] run() for ‘Future’ ...
[11:00:22.922] - state: ‘created’
[11:00:22.922] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:22.925] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:22.925] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:00:22.925]   - Field: ‘label’
[11:00:22.925]   - Field: ‘local’
[11:00:22.925]   - Field: ‘owner’
[11:00:22.926]   - Field: ‘envir’
[11:00:22.926]   - Field: ‘packages’
[11:00:22.926]   - Field: ‘gc’
[11:00:22.926]   - Field: ‘conditions’
[11:00:22.926]   - Field: ‘expr’
[11:00:22.926]   - Field: ‘uuid’
[11:00:22.926]   - Field: ‘seed’
[11:00:22.926]   - Field: ‘version’
[11:00:22.926]   - Field: ‘result’
[11:00:22.926]   - Field: ‘asynchronous’
[11:00:22.927]   - Field: ‘calls’
[11:00:22.927]   - Field: ‘globals’
[11:00:22.927]   - Field: ‘stdout’
[11:00:22.927]   - Field: ‘earlySignal’
[11:00:22.927]   - Field: ‘lazy’
[11:00:22.927]   - Field: ‘state’
[11:00:22.927] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:00:22.927] - Launch lazy future ...
[11:00:22.927] Packages needed by the future expression (n = 0): <none>
[11:00:22.927] Packages needed by future strategies (n = 0): <none>
[11:00:22.928] {
[11:00:22.928]     {
[11:00:22.928]         {
[11:00:22.928]             ...future.startTime <- base::Sys.time()
[11:00:22.928]             {
[11:00:22.928]                 {
[11:00:22.928]                   {
[11:00:22.928]                     base::local({
[11:00:22.928]                       has_future <- base::requireNamespace("future", 
[11:00:22.928]                         quietly = TRUE)
[11:00:22.928]                       if (has_future) {
[11:00:22.928]                         ns <- base::getNamespace("future")
[11:00:22.928]                         version <- ns[[".package"]][["version"]]
[11:00:22.928]                         if (is.null(version)) 
[11:00:22.928]                           version <- utils::packageVersion("future")
[11:00:22.928]                       }
[11:00:22.928]                       else {
[11:00:22.928]                         version <- NULL
[11:00:22.928]                       }
[11:00:22.928]                       if (!has_future || version < "1.8.0") {
[11:00:22.928]                         info <- base::c(r_version = base::gsub("R version ", 
[11:00:22.928]                           "", base::R.version$version.string), 
[11:00:22.928]                           platform = base::sprintf("%s (%s-bit)", 
[11:00:22.928]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:22.928]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:22.928]                             "release", "version")], collapse = " "), 
[11:00:22.928]                           hostname = base::Sys.info()[["nodename"]])
[11:00:22.928]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:00:22.928]                           info)
[11:00:22.928]                         info <- base::paste(info, collapse = "; ")
[11:00:22.928]                         if (!has_future) {
[11:00:22.928]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:22.928]                             info)
[11:00:22.928]                         }
[11:00:22.928]                         else {
[11:00:22.928]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:22.928]                             info, version)
[11:00:22.928]                         }
[11:00:22.928]                         base::stop(msg)
[11:00:22.928]                       }
[11:00:22.928]                     })
[11:00:22.928]                   }
[11:00:22.928]                   ...future.strategy.old <- future::plan("list")
[11:00:22.928]                   options(future.plan = NULL)
[11:00:22.928]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:22.928]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:22.928]                 }
[11:00:22.928]                 ...future.workdir <- getwd()
[11:00:22.928]             }
[11:00:22.928]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:22.928]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:22.928]         }
[11:00:22.928]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:22.928]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:22.928]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:22.928]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:22.928]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:22.928]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:22.928]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:22.928]             base::names(...future.oldOptions))
[11:00:22.928]     }
[11:00:22.928]     if (TRUE) {
[11:00:22.928]     }
[11:00:22.928]     else {
[11:00:22.928]         if (NA) {
[11:00:22.928]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:22.928]                 open = "w")
[11:00:22.928]         }
[11:00:22.928]         else {
[11:00:22.928]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:22.928]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:22.928]         }
[11:00:22.928]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:22.928]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:22.928]             base::sink(type = "output", split = FALSE)
[11:00:22.928]             base::close(...future.stdout)
[11:00:22.928]         }, add = TRUE)
[11:00:22.928]     }
[11:00:22.928]     ...future.frame <- base::sys.nframe()
[11:00:22.928]     ...future.conditions <- base::list()
[11:00:22.928]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:22.928]     if (FALSE) {
[11:00:22.928]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:22.928]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:22.928]     }
[11:00:22.928]     ...future.result <- base::tryCatch({
[11:00:22.928]         base::withCallingHandlers({
[11:00:22.928]             ...future.value <- base::withVisible(base::local({
[11:00:22.928]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:22.928]                 if (!identical(...future.globals.maxSize.org, 
[11:00:22.928]                   ...future.globals.maxSize)) {
[11:00:22.928]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:22.928]                   on.exit(options(oopts), add = TRUE)
[11:00:22.928]                 }
[11:00:22.928]                 {
[11:00:22.928]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:22.928]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:00:22.928]                     USE.NAMES = FALSE)
[11:00:22.928]                   do.call(mapply, args = args)
[11:00:22.928]                 }
[11:00:22.928]             }))
[11:00:22.928]             future::FutureResult(value = ...future.value$value, 
[11:00:22.928]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:22.928]                   ...future.rng), globalenv = if (FALSE) 
[11:00:22.928]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:22.928]                     ...future.globalenv.names))
[11:00:22.928]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:22.928]         }, condition = base::local({
[11:00:22.928]             c <- base::c
[11:00:22.928]             inherits <- base::inherits
[11:00:22.928]             invokeRestart <- base::invokeRestart
[11:00:22.928]             length <- base::length
[11:00:22.928]             list <- base::list
[11:00:22.928]             seq.int <- base::seq.int
[11:00:22.928]             signalCondition <- base::signalCondition
[11:00:22.928]             sys.calls <- base::sys.calls
[11:00:22.928]             `[[` <- base::`[[`
[11:00:22.928]             `+` <- base::`+`
[11:00:22.928]             `<<-` <- base::`<<-`
[11:00:22.928]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:22.928]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:22.928]                   3L)]
[11:00:22.928]             }
[11:00:22.928]             function(cond) {
[11:00:22.928]                 is_error <- inherits(cond, "error")
[11:00:22.928]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:22.928]                   NULL)
[11:00:22.928]                 if (is_error) {
[11:00:22.928]                   sessionInformation <- function() {
[11:00:22.928]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:22.928]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:22.928]                       search = base::search(), system = base::Sys.info())
[11:00:22.928]                   }
[11:00:22.928]                   ...future.conditions[[length(...future.conditions) + 
[11:00:22.928]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:22.928]                     cond$call), session = sessionInformation(), 
[11:00:22.928]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:22.928]                   signalCondition(cond)
[11:00:22.928]                 }
[11:00:22.928]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:22.928]                 "immediateCondition"))) {
[11:00:22.928]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:22.928]                   ...future.conditions[[length(...future.conditions) + 
[11:00:22.928]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:22.928]                   if (TRUE && !signal) {
[11:00:22.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:22.928]                     {
[11:00:22.928]                       inherits <- base::inherits
[11:00:22.928]                       invokeRestart <- base::invokeRestart
[11:00:22.928]                       is.null <- base::is.null
[11:00:22.928]                       muffled <- FALSE
[11:00:22.928]                       if (inherits(cond, "message")) {
[11:00:22.928]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:22.928]                         if (muffled) 
[11:00:22.928]                           invokeRestart("muffleMessage")
[11:00:22.928]                       }
[11:00:22.928]                       else if (inherits(cond, "warning")) {
[11:00:22.928]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:22.928]                         if (muffled) 
[11:00:22.928]                           invokeRestart("muffleWarning")
[11:00:22.928]                       }
[11:00:22.928]                       else if (inherits(cond, "condition")) {
[11:00:22.928]                         if (!is.null(pattern)) {
[11:00:22.928]                           computeRestarts <- base::computeRestarts
[11:00:22.928]                           grepl <- base::grepl
[11:00:22.928]                           restarts <- computeRestarts(cond)
[11:00:22.928]                           for (restart in restarts) {
[11:00:22.928]                             name <- restart$name
[11:00:22.928]                             if (is.null(name)) 
[11:00:22.928]                               next
[11:00:22.928]                             if (!grepl(pattern, name)) 
[11:00:22.928]                               next
[11:00:22.928]                             invokeRestart(restart)
[11:00:22.928]                             muffled <- TRUE
[11:00:22.928]                             break
[11:00:22.928]                           }
[11:00:22.928]                         }
[11:00:22.928]                       }
[11:00:22.928]                       invisible(muffled)
[11:00:22.928]                     }
[11:00:22.928]                     muffleCondition(cond, pattern = "^muffle")
[11:00:22.928]                   }
[11:00:22.928]                 }
[11:00:22.928]                 else {
[11:00:22.928]                   if (TRUE) {
[11:00:22.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:22.928]                     {
[11:00:22.928]                       inherits <- base::inherits
[11:00:22.928]                       invokeRestart <- base::invokeRestart
[11:00:22.928]                       is.null <- base::is.null
[11:00:22.928]                       muffled <- FALSE
[11:00:22.928]                       if (inherits(cond, "message")) {
[11:00:22.928]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:22.928]                         if (muffled) 
[11:00:22.928]                           invokeRestart("muffleMessage")
[11:00:22.928]                       }
[11:00:22.928]                       else if (inherits(cond, "warning")) {
[11:00:22.928]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:22.928]                         if (muffled) 
[11:00:22.928]                           invokeRestart("muffleWarning")
[11:00:22.928]                       }
[11:00:22.928]                       else if (inherits(cond, "condition")) {
[11:00:22.928]                         if (!is.null(pattern)) {
[11:00:22.928]                           computeRestarts <- base::computeRestarts
[11:00:22.928]                           grepl <- base::grepl
[11:00:22.928]                           restarts <- computeRestarts(cond)
[11:00:22.928]                           for (restart in restarts) {
[11:00:22.928]                             name <- restart$name
[11:00:22.928]                             if (is.null(name)) 
[11:00:22.928]                               next
[11:00:22.928]                             if (!grepl(pattern, name)) 
[11:00:22.928]                               next
[11:00:22.928]                             invokeRestart(restart)
[11:00:22.928]                             muffled <- TRUE
[11:00:22.928]                             break
[11:00:22.928]                           }
[11:00:22.928]                         }
[11:00:22.928]                       }
[11:00:22.928]                       invisible(muffled)
[11:00:22.928]                     }
[11:00:22.928]                     muffleCondition(cond, pattern = "^muffle")
[11:00:22.928]                   }
[11:00:22.928]                 }
[11:00:22.928]             }
[11:00:22.928]         }))
[11:00:22.928]     }, error = function(ex) {
[11:00:22.928]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:22.928]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:22.928]                 ...future.rng), started = ...future.startTime, 
[11:00:22.928]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:22.928]             version = "1.8"), class = "FutureResult")
[11:00:22.928]     }, finally = {
[11:00:22.928]         if (!identical(...future.workdir, getwd())) 
[11:00:22.928]             setwd(...future.workdir)
[11:00:22.928]         {
[11:00:22.928]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:22.928]                 ...future.oldOptions$nwarnings <- NULL
[11:00:22.928]             }
[11:00:22.928]             base::options(...future.oldOptions)
[11:00:22.928]             if (.Platform$OS.type == "windows") {
[11:00:22.928]                 old_names <- names(...future.oldEnvVars)
[11:00:22.928]                 envs <- base::Sys.getenv()
[11:00:22.928]                 names <- names(envs)
[11:00:22.928]                 common <- intersect(names, old_names)
[11:00:22.928]                 added <- setdiff(names, old_names)
[11:00:22.928]                 removed <- setdiff(old_names, names)
[11:00:22.928]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:22.928]                   envs[common]]
[11:00:22.928]                 NAMES <- toupper(changed)
[11:00:22.928]                 args <- list()
[11:00:22.928]                 for (kk in seq_along(NAMES)) {
[11:00:22.928]                   name <- changed[[kk]]
[11:00:22.928]                   NAME <- NAMES[[kk]]
[11:00:22.928]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:22.928]                     next
[11:00:22.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:22.928]                 }
[11:00:22.928]                 NAMES <- toupper(added)
[11:00:22.928]                 for (kk in seq_along(NAMES)) {
[11:00:22.928]                   name <- added[[kk]]
[11:00:22.928]                   NAME <- NAMES[[kk]]
[11:00:22.928]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:22.928]                     next
[11:00:22.928]                   args[[name]] <- ""
[11:00:22.928]                 }
[11:00:22.928]                 NAMES <- toupper(removed)
[11:00:22.928]                 for (kk in seq_along(NAMES)) {
[11:00:22.928]                   name <- removed[[kk]]
[11:00:22.928]                   NAME <- NAMES[[kk]]
[11:00:22.928]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:22.928]                     next
[11:00:22.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:22.928]                 }
[11:00:22.928]                 if (length(args) > 0) 
[11:00:22.928]                   base::do.call(base::Sys.setenv, args = args)
[11:00:22.928]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:22.928]             }
[11:00:22.928]             else {
[11:00:22.928]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:22.928]             }
[11:00:22.928]             {
[11:00:22.928]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:22.928]                   0L) {
[11:00:22.928]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:22.928]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:22.928]                   base::options(opts)
[11:00:22.928]                 }
[11:00:22.928]                 {
[11:00:22.928]                   {
[11:00:22.928]                     NULL
[11:00:22.928]                     RNGkind("Mersenne-Twister")
[11:00:22.928]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:00:22.928]                       inherits = FALSE)
[11:00:22.928]                   }
[11:00:22.928]                   options(future.plan = NULL)
[11:00:22.928]                   if (is.na(NA_character_)) 
[11:00:22.928]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:22.928]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:22.928]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:22.928]                     .init = FALSE)
[11:00:22.928]                 }
[11:00:22.928]             }
[11:00:22.928]         }
[11:00:22.928]     })
[11:00:22.928]     if (FALSE) {
[11:00:22.928]         base::sink(type = "output", split = FALSE)
[11:00:22.928]         if (NA) {
[11:00:22.928]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:22.928]         }
[11:00:22.928]         else {
[11:00:22.928]             ...future.result["stdout"] <- base::list(NULL)
[11:00:22.928]         }
[11:00:22.928]         base::close(...future.stdout)
[11:00:22.928]         ...future.stdout <- NULL
[11:00:22.928]     }
[11:00:22.928]     ...future.result$conditions <- ...future.conditions
[11:00:22.928]     ...future.result$finished <- base::Sys.time()
[11:00:22.928]     ...future.result
[11:00:22.928] }
[11:00:22.930] assign_globals() ...
[11:00:22.930] List of 5
[11:00:22.930]  $ ...future.FUN            :function (x, y)  
[11:00:22.930]  $ MoreArgs                 : NULL
[11:00:22.930]  $ ...future.elements_ii    :List of 2
[11:00:22.930]   ..$ :List of 2
[11:00:22.930]   .. ..$ : int 1
[11:00:22.930]   .. ..$ : int 0
[11:00:22.930]   ..$ :List of 2
[11:00:22.930]   .. ..$ : int 0
[11:00:22.930]   .. ..$ : int 1
[11:00:22.930]  $ ...future.seeds_ii       : NULL
[11:00:22.930]  $ ...future.globals.maxSize: NULL
[11:00:22.930]  - attr(*, "where")=List of 5
[11:00:22.930]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:22.930]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[11:00:22.930]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:22.930]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:22.930]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:22.930]  - attr(*, "resolved")= logi FALSE
[11:00:22.930]  - attr(*, "total_size")= num 1242
[11:00:22.930]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:22.930]  - attr(*, "already-done")= logi TRUE
[11:00:22.935] - reassign environment for ‘...future.FUN’
[11:00:22.935] - copied ‘...future.FUN’ to environment
[11:00:22.935] - copied ‘MoreArgs’ to environment
[11:00:22.935] - copied ‘...future.elements_ii’ to environment
[11:00:22.935] - copied ‘...future.seeds_ii’ to environment
[11:00:22.935] - copied ‘...future.globals.maxSize’ to environment
[11:00:22.935] assign_globals() ... done
[11:00:22.936] plan(): Setting new future strategy stack:
[11:00:22.936] List of future strategies:
[11:00:22.936] 1. sequential:
[11:00:22.936]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:22.936]    - tweaked: FALSE
[11:00:22.936]    - call: NULL
[11:00:22.936] plan(): nbrOfWorkers() = 1
[11:00:23.438] plan(): Setting new future strategy stack:
[11:00:23.438] List of future strategies:
[11:00:23.438] 1. multisession:
[11:00:23.438]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:00:23.438]    - tweaked: FALSE
[11:00:23.438]    - call: plan(strategy)
[11:00:23.440] plan(): nbrOfWorkers() = 1
[11:00:23.440] SequentialFuture started (and completed)
[11:00:23.440] - Launch lazy future ... done
[11:00:23.440] run() for ‘SequentialFuture’ ... done
[11:00:23.440] Created future:
[11:00:23.440] SequentialFuture:
[11:00:23.440] Label: ‘future_mapply-1’
[11:00:23.440] Expression:
[11:00:23.440] {
[11:00:23.440]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:23.440]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:23.440]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:23.440]         on.exit(options(oopts), add = TRUE)
[11:00:23.440]     }
[11:00:23.440]     {
[11:00:23.440]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:23.440]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:00:23.440]         do.call(mapply, args = args)
[11:00:23.440]     }
[11:00:23.440] }
[11:00:23.440] Lazy evaluation: FALSE
[11:00:23.440] Asynchronous evaluation: FALSE
[11:00:23.440] Local evaluation: TRUE
[11:00:23.440] Environment: R_GlobalEnv
[11:00:23.440] Capture standard output: NA
[11:00:23.440] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:23.440] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:23.440] Packages: <none>
[11:00:23.440] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:23.440] Resolved: TRUE
[11:00:23.440] Value: 184 bytes of class ‘list’
[11:00:23.440] Early signaling: FALSE
[11:00:23.440] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:23.440] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:00:23.441] Chunk #1 of 1 ... DONE
[11:00:23.441] Launching 1 futures (chunks) ... DONE
[11:00:23.441] Resolving 1 futures (chunks) ...
[11:00:23.441] resolve() on list ...
[11:00:23.442]  recursive: 0
[11:00:23.442]  length: 1
[11:00:23.442] 
[11:00:23.442] resolved() for ‘SequentialFuture’ ...
[11:00:23.442] - state: ‘finished’
[11:00:23.442] - run: TRUE
[11:00:23.442] - result: ‘FutureResult’
[11:00:23.442] resolved() for ‘SequentialFuture’ ... done
[11:00:23.442] Future #1
[11:00:23.442] signalConditionsASAP(SequentialFuture, pos=1) ...
[11:00:23.442] - nx: 1
[11:00:23.443] - relay: TRUE
[11:00:23.443] - stdout: TRUE
[11:00:23.443] - signal: TRUE
[11:00:23.443] - resignal: FALSE
[11:00:23.443] - force: TRUE
[11:00:23.443] - relayed: [n=1] FALSE
[11:00:23.443] - queued futures: [n=1] FALSE
[11:00:23.443]  - until=1
[11:00:23.443]  - relaying element #1
[11:00:23.443] - relayed: [n=1] TRUE
[11:00:23.443] - queued futures: [n=1] TRUE
[11:00:23.444] signalConditionsASAP(SequentialFuture, pos=1) ... done
[11:00:23.444]  length: 0 (resolved future 1)
[11:00:23.444] Relaying remaining futures
[11:00:23.444] signalConditionsASAP(NULL, pos=0) ...
[11:00:23.444] - nx: 1
[11:00:23.444] - relay: TRUE
[11:00:23.444] - stdout: TRUE
[11:00:23.444] - signal: TRUE
[11:00:23.444] - resignal: FALSE
[11:00:23.444] - force: TRUE
[11:00:23.444] - relayed: [n=1] TRUE
[11:00:23.444] - queued futures: [n=1] TRUE
 - flush all
[11:00:23.445] - relayed: [n=1] TRUE
[11:00:23.445] - queued futures: [n=1] TRUE
[11:00:23.445] signalConditionsASAP(NULL, pos=0) ... done
[11:00:23.445] resolve() on list ... DONE
[11:00:23.445]  - Number of value chunks collected: 1
[11:00:23.445] Resolving 1 futures (chunks) ... DONE
[11:00:23.445] Reducing values from 1 chunks ...
[11:00:23.445]  - Number of values collected after concatenation: 2
[11:00:23.445]  - Number of values expected: 2
[11:00:23.445] Reducing values from 1 chunks ... DONE
[11:00:23.445] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 1 cores ... DONE
  - Testing with 2 cores ...
* plan('multicore') ...
[11:00:23.451] plan(): Setting new future strategy stack:
[11:00:23.451] List of future strategies:
[11:00:23.451] 1. multicore:
[11:00:23.451]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:23.451]    - tweaked: FALSE
[11:00:23.451]    - call: plan(strategy)
[11:00:23.453] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[11:00:23.453] future_lapply() ...
[11:00:23.456] Number of chunks: 2
[11:00:23.456] getGlobalsAndPackagesXApply() ...
[11:00:23.456]  - future.globals: TRUE
[11:00:23.456] getGlobalsAndPackages() ...
[11:00:23.456] Searching for globals...
[11:00:23.458] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[11:00:23.458] Searching for globals ... DONE
[11:00:23.458] Resolving globals: FALSE
[11:00:23.458] The total size of the 1 globals is 841 bytes (841 bytes)
[11:00:23.459] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[11:00:23.459] - globals: [1] ‘FUN’
[11:00:23.459] 
[11:00:23.459] getGlobalsAndPackages() ... DONE
[11:00:23.459]  - globals found/used: [n=1] ‘FUN’
[11:00:23.459]  - needed namespaces: [n=0] 
[11:00:23.459] Finding globals ... DONE
[11:00:23.459]  - use_args: TRUE
[11:00:23.459]  - Getting '...' globals ...
[11:00:23.460] resolve() on list ...
[11:00:23.460]  recursive: 0
[11:00:23.460]  length: 1
[11:00:23.460]  elements: ‘...’
[11:00:23.460]  length: 0 (resolved future 1)
[11:00:23.460] resolve() on list ... DONE
[11:00:23.460]    - '...' content: [n=0] 
[11:00:23.460] List of 1
[11:00:23.460]  $ ...: list()
[11:00:23.460]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:23.460]  - attr(*, "where")=List of 1
[11:00:23.460]   ..$ ...:<environment: 0x55ceb3ff5df8> 
[11:00:23.460]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:23.460]  - attr(*, "resolved")= logi TRUE
[11:00:23.460]  - attr(*, "total_size")= num NA
[11:00:23.463]  - Getting '...' globals ... DONE
[11:00:23.463] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[11:00:23.463] List of 2
[11:00:23.463]  $ ...future.FUN:function (x)  
[11:00:23.463]  $ ...          : list()
[11:00:23.463]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:23.463]  - attr(*, "where")=List of 2
[11:00:23.463]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:23.463]   ..$ ...          :<environment: 0x55ceb3ff5df8> 
[11:00:23.463]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:23.463]  - attr(*, "resolved")= logi FALSE
[11:00:23.463]  - attr(*, "total_size")= num 5632
[11:00:23.465] Packages to be attached in all futures: [n=0] 
[11:00:23.465] getGlobalsAndPackagesXApply() ... DONE
[11:00:23.466] Number of futures (= number of chunks): 2
[11:00:23.466] Launching 2 futures (chunks) ...
[11:00:23.466] Chunk #1 of 2 ...
[11:00:23.466]  - Finding globals in 'X' for chunk #1 ...
[11:00:23.466] getGlobalsAndPackages() ...
[11:00:23.466] Searching for globals...
[11:00:23.466] 
[11:00:23.466] Searching for globals ... DONE
[11:00:23.467] - globals: [0] <none>
[11:00:23.467] getGlobalsAndPackages() ... DONE
[11:00:23.467]    + additional globals found: [n=0] 
[11:00:23.467]    + additional namespaces needed: [n=0] 
[11:00:23.467]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:23.467]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:23.467]  - seeds: <none>
[11:00:23.467]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:23.467] getGlobalsAndPackages() ...
[11:00:23.467] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:23.467] Resolving globals: FALSE
[11:00:23.467] Tweak future expression to call with '...' arguments ...
[11:00:23.468] {
[11:00:23.468]     do.call(function(...) {
[11:00:23.468]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:23.468]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:23.468]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:23.468]             on.exit(options(oopts), add = TRUE)
[11:00:23.468]         }
[11:00:23.468]         {
[11:00:23.468]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:23.468]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:23.468]                 ...future.FUN(...future.X_jj, ...)
[11:00:23.468]             })
[11:00:23.468]         }
[11:00:23.468]     }, args = future.call.arguments)
[11:00:23.468] }
[11:00:23.468] Tweak future expression to call with '...' arguments ... DONE
[11:00:23.468] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:23.468] 
[11:00:23.468] getGlobalsAndPackages() ... DONE
[11:00:23.469] run() for ‘Future’ ...
[11:00:23.469] - state: ‘created’
[11:00:23.469] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:23.470] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:23.470] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:23.471]   - Field: ‘label’
[11:00:23.471]   - Field: ‘local’
[11:00:23.471]   - Field: ‘owner’
[11:00:23.471]   - Field: ‘envir’
[11:00:23.471]   - Field: ‘workers’
[11:00:23.471]   - Field: ‘packages’
[11:00:23.471]   - Field: ‘gc’
[11:00:23.471]   - Field: ‘job’
[11:00:23.471]   - Field: ‘conditions’
[11:00:23.471]   - Field: ‘expr’
[11:00:23.471]   - Field: ‘uuid’
[11:00:23.471]   - Field: ‘seed’
[11:00:23.472]   - Field: ‘version’
[11:00:23.472]   - Field: ‘result’
[11:00:23.472]   - Field: ‘asynchronous’
[11:00:23.472]   - Field: ‘calls’
[11:00:23.472]   - Field: ‘globals’
[11:00:23.472]   - Field: ‘stdout’
[11:00:23.472]   - Field: ‘earlySignal’
[11:00:23.472]   - Field: ‘lazy’
[11:00:23.472]   - Field: ‘state’
[11:00:23.472] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:23.472] - Launch lazy future ...
[11:00:23.473] Packages needed by the future expression (n = 0): <none>
[11:00:23.473] Packages needed by future strategies (n = 0): <none>
[11:00:23.474] {
[11:00:23.474]     {
[11:00:23.474]         {
[11:00:23.474]             ...future.startTime <- base::Sys.time()
[11:00:23.474]             {
[11:00:23.474]                 {
[11:00:23.474]                   {
[11:00:23.474]                     {
[11:00:23.474]                       base::local({
[11:00:23.474]                         has_future <- base::requireNamespace("future", 
[11:00:23.474]                           quietly = TRUE)
[11:00:23.474]                         if (has_future) {
[11:00:23.474]                           ns <- base::getNamespace("future")
[11:00:23.474]                           version <- ns[[".package"]][["version"]]
[11:00:23.474]                           if (is.null(version)) 
[11:00:23.474]                             version <- utils::packageVersion("future")
[11:00:23.474]                         }
[11:00:23.474]                         else {
[11:00:23.474]                           version <- NULL
[11:00:23.474]                         }
[11:00:23.474]                         if (!has_future || version < "1.8.0") {
[11:00:23.474]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:23.474]                             "", base::R.version$version.string), 
[11:00:23.474]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:23.474]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:23.474]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:23.474]                               "release", "version")], collapse = " "), 
[11:00:23.474]                             hostname = base::Sys.info()[["nodename"]])
[11:00:23.474]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:23.474]                             info)
[11:00:23.474]                           info <- base::paste(info, collapse = "; ")
[11:00:23.474]                           if (!has_future) {
[11:00:23.474]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:23.474]                               info)
[11:00:23.474]                           }
[11:00:23.474]                           else {
[11:00:23.474]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:23.474]                               info, version)
[11:00:23.474]                           }
[11:00:23.474]                           base::stop(msg)
[11:00:23.474]                         }
[11:00:23.474]                       })
[11:00:23.474]                     }
[11:00:23.474]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:23.474]                     base::options(mc.cores = 1L)
[11:00:23.474]                   }
[11:00:23.474]                   ...future.strategy.old <- future::plan("list")
[11:00:23.474]                   options(future.plan = NULL)
[11:00:23.474]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:23.474]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:23.474]                 }
[11:00:23.474]                 ...future.workdir <- getwd()
[11:00:23.474]             }
[11:00:23.474]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:23.474]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:23.474]         }
[11:00:23.474]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:23.474]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:23.474]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:23.474]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:23.474]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:23.474]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:23.474]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:23.474]             base::names(...future.oldOptions))
[11:00:23.474]     }
[11:00:23.474]     if (FALSE) {
[11:00:23.474]     }
[11:00:23.474]     else {
[11:00:23.474]         if (FALSE) {
[11:00:23.474]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:23.474]                 open = "w")
[11:00:23.474]         }
[11:00:23.474]         else {
[11:00:23.474]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:23.474]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:23.474]         }
[11:00:23.474]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:23.474]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:23.474]             base::sink(type = "output", split = FALSE)
[11:00:23.474]             base::close(...future.stdout)
[11:00:23.474]         }, add = TRUE)
[11:00:23.474]     }
[11:00:23.474]     ...future.frame <- base::sys.nframe()
[11:00:23.474]     ...future.conditions <- base::list()
[11:00:23.474]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:23.474]     if (FALSE) {
[11:00:23.474]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:23.474]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:23.474]     }
[11:00:23.474]     ...future.result <- base::tryCatch({
[11:00:23.474]         base::withCallingHandlers({
[11:00:23.474]             ...future.value <- base::withVisible(base::local({
[11:00:23.474]                 withCallingHandlers({
[11:00:23.474]                   {
[11:00:23.474]                     do.call(function(...) {
[11:00:23.474]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:23.474]                       if (!identical(...future.globals.maxSize.org, 
[11:00:23.474]                         ...future.globals.maxSize)) {
[11:00:23.474]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:23.474]                         on.exit(options(oopts), add = TRUE)
[11:00:23.474]                       }
[11:00:23.474]                       {
[11:00:23.474]                         lapply(seq_along(...future.elements_ii), 
[11:00:23.474]                           FUN = function(jj) {
[11:00:23.474]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:23.474]                             ...future.FUN(...future.X_jj, ...)
[11:00:23.474]                           })
[11:00:23.474]                       }
[11:00:23.474]                     }, args = future.call.arguments)
[11:00:23.474]                   }
[11:00:23.474]                 }, immediateCondition = function(cond) {
[11:00:23.474]                   save_rds <- function (object, pathname, ...) 
[11:00:23.474]                   {
[11:00:23.474]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:23.474]                     if (file_test("-f", pathname_tmp)) {
[11:00:23.474]                       fi_tmp <- file.info(pathname_tmp)
[11:00:23.474]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:23.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:23.474]                         fi_tmp[["mtime"]])
[11:00:23.474]                     }
[11:00:23.474]                     tryCatch({
[11:00:23.474]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:23.474]                     }, error = function(ex) {
[11:00:23.474]                       msg <- conditionMessage(ex)
[11:00:23.474]                       fi_tmp <- file.info(pathname_tmp)
[11:00:23.474]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:23.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:23.474]                         fi_tmp[["mtime"]], msg)
[11:00:23.474]                       ex$message <- msg
[11:00:23.474]                       stop(ex)
[11:00:23.474]                     })
[11:00:23.474]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:23.474]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:23.474]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:23.474]                       fi_tmp <- file.info(pathname_tmp)
[11:00:23.474]                       fi <- file.info(pathname)
[11:00:23.474]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:23.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:23.474]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:23.474]                         fi[["size"]], fi[["mtime"]])
[11:00:23.474]                       stop(msg)
[11:00:23.474]                     }
[11:00:23.474]                     invisible(pathname)
[11:00:23.474]                   }
[11:00:23.474]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:23.474]                     rootPath = tempdir()) 
[11:00:23.474]                   {
[11:00:23.474]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:23.474]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:23.474]                       tmpdir = path, fileext = ".rds")
[11:00:23.474]                     save_rds(obj, file)
[11:00:23.474]                   }
[11:00:23.474]                   saveImmediateCondition(cond, path = "/tmp/RtmpuTAfww/.future/immediateConditions")
[11:00:23.474]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:23.474]                   {
[11:00:23.474]                     inherits <- base::inherits
[11:00:23.474]                     invokeRestart <- base::invokeRestart
[11:00:23.474]                     is.null <- base::is.null
[11:00:23.474]                     muffled <- FALSE
[11:00:23.474]                     if (inherits(cond, "message")) {
[11:00:23.474]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:23.474]                       if (muffled) 
[11:00:23.474]                         invokeRestart("muffleMessage")
[11:00:23.474]                     }
[11:00:23.474]                     else if (inherits(cond, "warning")) {
[11:00:23.474]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:23.474]                       if (muffled) 
[11:00:23.474]                         invokeRestart("muffleWarning")
[11:00:23.474]                     }
[11:00:23.474]                     else if (inherits(cond, "condition")) {
[11:00:23.474]                       if (!is.null(pattern)) {
[11:00:23.474]                         computeRestarts <- base::computeRestarts
[11:00:23.474]                         grepl <- base::grepl
[11:00:23.474]                         restarts <- computeRestarts(cond)
[11:00:23.474]                         for (restart in restarts) {
[11:00:23.474]                           name <- restart$name
[11:00:23.474]                           if (is.null(name)) 
[11:00:23.474]                             next
[11:00:23.474]                           if (!grepl(pattern, name)) 
[11:00:23.474]                             next
[11:00:23.474]                           invokeRestart(restart)
[11:00:23.474]                           muffled <- TRUE
[11:00:23.474]                           break
[11:00:23.474]                         }
[11:00:23.474]                       }
[11:00:23.474]                     }
[11:00:23.474]                     invisible(muffled)
[11:00:23.474]                   }
[11:00:23.474]                   muffleCondition(cond)
[11:00:23.474]                 })
[11:00:23.474]             }))
[11:00:23.474]             future::FutureResult(value = ...future.value$value, 
[11:00:23.474]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:23.474]                   ...future.rng), globalenv = if (FALSE) 
[11:00:23.474]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:23.474]                     ...future.globalenv.names))
[11:00:23.474]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:23.474]         }, condition = base::local({
[11:00:23.474]             c <- base::c
[11:00:23.474]             inherits <- base::inherits
[11:00:23.474]             invokeRestart <- base::invokeRestart
[11:00:23.474]             length <- base::length
[11:00:23.474]             list <- base::list
[11:00:23.474]             seq.int <- base::seq.int
[11:00:23.474]             signalCondition <- base::signalCondition
[11:00:23.474]             sys.calls <- base::sys.calls
[11:00:23.474]             `[[` <- base::`[[`
[11:00:23.474]             `+` <- base::`+`
[11:00:23.474]             `<<-` <- base::`<<-`
[11:00:23.474]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:23.474]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:23.474]                   3L)]
[11:00:23.474]             }
[11:00:23.474]             function(cond) {
[11:00:23.474]                 is_error <- inherits(cond, "error")
[11:00:23.474]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:23.474]                   NULL)
[11:00:23.474]                 if (is_error) {
[11:00:23.474]                   sessionInformation <- function() {
[11:00:23.474]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:23.474]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:23.474]                       search = base::search(), system = base::Sys.info())
[11:00:23.474]                   }
[11:00:23.474]                   ...future.conditions[[length(...future.conditions) + 
[11:00:23.474]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:23.474]                     cond$call), session = sessionInformation(), 
[11:00:23.474]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:23.474]                   signalCondition(cond)
[11:00:23.474]                 }
[11:00:23.474]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:23.474]                 "immediateCondition"))) {
[11:00:23.474]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:23.474]                   ...future.conditions[[length(...future.conditions) + 
[11:00:23.474]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:23.474]                   if (TRUE && !signal) {
[11:00:23.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:23.474]                     {
[11:00:23.474]                       inherits <- base::inherits
[11:00:23.474]                       invokeRestart <- base::invokeRestart
[11:00:23.474]                       is.null <- base::is.null
[11:00:23.474]                       muffled <- FALSE
[11:00:23.474]                       if (inherits(cond, "message")) {
[11:00:23.474]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:23.474]                         if (muffled) 
[11:00:23.474]                           invokeRestart("muffleMessage")
[11:00:23.474]                       }
[11:00:23.474]                       else if (inherits(cond, "warning")) {
[11:00:23.474]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:23.474]                         if (muffled) 
[11:00:23.474]                           invokeRestart("muffleWarning")
[11:00:23.474]                       }
[11:00:23.474]                       else if (inherits(cond, "condition")) {
[11:00:23.474]                         if (!is.null(pattern)) {
[11:00:23.474]                           computeRestarts <- base::computeRestarts
[11:00:23.474]                           grepl <- base::grepl
[11:00:23.474]                           restarts <- computeRestarts(cond)
[11:00:23.474]                           for (restart in restarts) {
[11:00:23.474]                             name <- restart$name
[11:00:23.474]                             if (is.null(name)) 
[11:00:23.474]                               next
[11:00:23.474]                             if (!grepl(pattern, name)) 
[11:00:23.474]                               next
[11:00:23.474]                             invokeRestart(restart)
[11:00:23.474]                             muffled <- TRUE
[11:00:23.474]                             break
[11:00:23.474]                           }
[11:00:23.474]                         }
[11:00:23.474]                       }
[11:00:23.474]                       invisible(muffled)
[11:00:23.474]                     }
[11:00:23.474]                     muffleCondition(cond, pattern = "^muffle")
[11:00:23.474]                   }
[11:00:23.474]                 }
[11:00:23.474]                 else {
[11:00:23.474]                   if (TRUE) {
[11:00:23.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:23.474]                     {
[11:00:23.474]                       inherits <- base::inherits
[11:00:23.474]                       invokeRestart <- base::invokeRestart
[11:00:23.474]                       is.null <- base::is.null
[11:00:23.474]                       muffled <- FALSE
[11:00:23.474]                       if (inherits(cond, "message")) {
[11:00:23.474]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:23.474]                         if (muffled) 
[11:00:23.474]                           invokeRestart("muffleMessage")
[11:00:23.474]                       }
[11:00:23.474]                       else if (inherits(cond, "warning")) {
[11:00:23.474]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:23.474]                         if (muffled) 
[11:00:23.474]                           invokeRestart("muffleWarning")
[11:00:23.474]                       }
[11:00:23.474]                       else if (inherits(cond, "condition")) {
[11:00:23.474]                         if (!is.null(pattern)) {
[11:00:23.474]                           computeRestarts <- base::computeRestarts
[11:00:23.474]                           grepl <- base::grepl
[11:00:23.474]                           restarts <- computeRestarts(cond)
[11:00:23.474]                           for (restart in restarts) {
[11:00:23.474]                             name <- restart$name
[11:00:23.474]                             if (is.null(name)) 
[11:00:23.474]                               next
[11:00:23.474]                             if (!grepl(pattern, name)) 
[11:00:23.474]                               next
[11:00:23.474]                             invokeRestart(restart)
[11:00:23.474]                             muffled <- TRUE
[11:00:23.474]                             break
[11:00:23.474]                           }
[11:00:23.474]                         }
[11:00:23.474]                       }
[11:00:23.474]                       invisible(muffled)
[11:00:23.474]                     }
[11:00:23.474]                     muffleCondition(cond, pattern = "^muffle")
[11:00:23.474]                   }
[11:00:23.474]                 }
[11:00:23.474]             }
[11:00:23.474]         }))
[11:00:23.474]     }, error = function(ex) {
[11:00:23.474]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:23.474]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:23.474]                 ...future.rng), started = ...future.startTime, 
[11:00:23.474]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:23.474]             version = "1.8"), class = "FutureResult")
[11:00:23.474]     }, finally = {
[11:00:23.474]         if (!identical(...future.workdir, getwd())) 
[11:00:23.474]             setwd(...future.workdir)
[11:00:23.474]         {
[11:00:23.474]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:23.474]                 ...future.oldOptions$nwarnings <- NULL
[11:00:23.474]             }
[11:00:23.474]             base::options(...future.oldOptions)
[11:00:23.474]             if (.Platform$OS.type == "windows") {
[11:00:23.474]                 old_names <- names(...future.oldEnvVars)
[11:00:23.474]                 envs <- base::Sys.getenv()
[11:00:23.474]                 names <- names(envs)
[11:00:23.474]                 common <- intersect(names, old_names)
[11:00:23.474]                 added <- setdiff(names, old_names)
[11:00:23.474]                 removed <- setdiff(old_names, names)
[11:00:23.474]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:23.474]                   envs[common]]
[11:00:23.474]                 NAMES <- toupper(changed)
[11:00:23.474]                 args <- list()
[11:00:23.474]                 for (kk in seq_along(NAMES)) {
[11:00:23.474]                   name <- changed[[kk]]
[11:00:23.474]                   NAME <- NAMES[[kk]]
[11:00:23.474]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:23.474]                     next
[11:00:23.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:23.474]                 }
[11:00:23.474]                 NAMES <- toupper(added)
[11:00:23.474]                 for (kk in seq_along(NAMES)) {
[11:00:23.474]                   name <- added[[kk]]
[11:00:23.474]                   NAME <- NAMES[[kk]]
[11:00:23.474]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:23.474]                     next
[11:00:23.474]                   args[[name]] <- ""
[11:00:23.474]                 }
[11:00:23.474]                 NAMES <- toupper(removed)
[11:00:23.474]                 for (kk in seq_along(NAMES)) {
[11:00:23.474]                   name <- removed[[kk]]
[11:00:23.474]                   NAME <- NAMES[[kk]]
[11:00:23.474]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:23.474]                     next
[11:00:23.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:23.474]                 }
[11:00:23.474]                 if (length(args) > 0) 
[11:00:23.474]                   base::do.call(base::Sys.setenv, args = args)
[11:00:23.474]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:23.474]             }
[11:00:23.474]             else {
[11:00:23.474]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:23.474]             }
[11:00:23.474]             {
[11:00:23.474]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:23.474]                   0L) {
[11:00:23.474]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:23.474]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:23.474]                   base::options(opts)
[11:00:23.474]                 }
[11:00:23.474]                 {
[11:00:23.474]                   {
[11:00:23.474]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:23.474]                     NULL
[11:00:23.474]                   }
[11:00:23.474]                   options(future.plan = NULL)
[11:00:23.474]                   if (is.na(NA_character_)) 
[11:00:23.474]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:23.474]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:23.474]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:23.474]                     .init = FALSE)
[11:00:23.474]                 }
[11:00:23.474]             }
[11:00:23.474]         }
[11:00:23.474]     })
[11:00:23.474]     if (TRUE) {
[11:00:23.474]         base::sink(type = "output", split = FALSE)
[11:00:23.474]         if (FALSE) {
[11:00:23.474]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:23.474]         }
[11:00:23.474]         else {
[11:00:23.474]             ...future.result["stdout"] <- base::list(NULL)
[11:00:23.474]         }
[11:00:23.474]         base::close(...future.stdout)
[11:00:23.474]         ...future.stdout <- NULL
[11:00:23.474]     }
[11:00:23.474]     ...future.result$conditions <- ...future.conditions
[11:00:23.474]     ...future.result$finished <- base::Sys.time()
[11:00:23.474]     ...future.result
[11:00:23.474] }
[11:00:23.476] assign_globals() ...
[11:00:23.476] List of 5
[11:00:23.476]  $ ...future.FUN            :function (x)  
[11:00:23.476]  $ future.call.arguments    : list()
[11:00:23.476]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:23.476]  $ ...future.elements_ii    :List of 1
[11:00:23.476]   ..$ : int 1
[11:00:23.476]  $ ...future.seeds_ii       : NULL
[11:00:23.476]  $ ...future.globals.maxSize: NULL
[11:00:23.476]  - attr(*, "where")=List of 5
[11:00:23.476]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:23.476]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:23.476]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:23.476]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:23.476]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:23.476]  - attr(*, "resolved")= logi FALSE
[11:00:23.476]  - attr(*, "total_size")= num 5632
[11:00:23.476]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:23.476]  - attr(*, "already-done")= logi TRUE
[11:00:23.482] - reassign environment for ‘...future.FUN’
[11:00:23.482] - copied ‘...future.FUN’ to environment
[11:00:23.482] - copied ‘future.call.arguments’ to environment
[11:00:23.482] - copied ‘...future.elements_ii’ to environment
[11:00:23.482] - copied ‘...future.seeds_ii’ to environment
[11:00:23.482] - copied ‘...future.globals.maxSize’ to environment
[11:00:23.482] assign_globals() ... done
[11:00:23.483] requestCore(): workers = 2
[11:00:23.486] MulticoreFuture started
[11:00:23.486] - Launch lazy future ... done
[11:00:23.486] plan(): Setting new future strategy stack:
[11:00:23.486] run() for ‘MulticoreFuture’ ... done
[11:00:23.487] Created future:
[11:00:23.487] List of future strategies:
[11:00:23.487] 1. sequential:
[11:00:23.487]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:23.487]    - tweaked: FALSE
[11:00:23.487]    - call: NULL
[11:00:23.488] plan(): nbrOfWorkers() = 1
[11:00:23.487] MulticoreFuture:
[11:00:23.487] Label: ‘future_lapply-1’
[11:00:23.487] Expression:
[11:00:23.487] {
[11:00:23.487]     do.call(function(...) {
[11:00:23.487]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:23.487]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:23.487]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:23.487]             on.exit(options(oopts), add = TRUE)
[11:00:23.487]         }
[11:00:23.487]         {
[11:00:23.487]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:23.487]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:23.487]                 ...future.FUN(...future.X_jj, ...)
[11:00:23.487]             })
[11:00:23.487]         }
[11:00:23.487]     }, args = future.call.arguments)
[11:00:23.487] }
[11:00:23.487] Lazy evaluation: FALSE
[11:00:23.487] Asynchronous evaluation: TRUE
[11:00:23.487] Local evaluation: TRUE
[11:00:23.487] Environment: R_GlobalEnv
[11:00:23.487] Capture standard output: FALSE
[11:00:23.487] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:23.487] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:23.487] Packages: <none>
[11:00:23.487] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:23.487] Resolved: FALSE
[11:00:23.487] Value: <not collected>
[11:00:23.487] Conditions captured: <none>
[11:00:23.487] Early signaling: FALSE
[11:00:23.487] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:23.487] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:23.502] Chunk #1 of 2 ... DONE
[11:00:23.502] Chunk #2 of 2 ...
[11:00:23.502]  - Finding globals in 'X' for chunk #2 ...
[11:00:23.502] getGlobalsAndPackages() ...
[11:00:23.503] Searching for globals...
[11:00:23.503] 
[11:00:23.503] Searching for globals ... DONE
[11:00:23.504] - globals: [0] <none>
[11:00:23.504] getGlobalsAndPackages() ... DONE
[11:00:23.504]    + additional globals found: [n=0] 
[11:00:23.504]    + additional namespaces needed: [n=0] 
[11:00:23.504]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:23.505]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:23.505]  - seeds: <none>
[11:00:23.505]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:23.505] getGlobalsAndPackages() ...
[11:00:23.505] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:23.506] Resolving globals: FALSE
[11:00:23.506] Tweak future expression to call with '...' arguments ...
[11:00:23.506] {
[11:00:23.506]     do.call(function(...) {
[11:00:23.506]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:23.506]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:23.506]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:23.506]             on.exit(options(oopts), add = TRUE)
[11:00:23.506]         }
[11:00:23.506]         {
[11:00:23.506]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:23.506]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:23.506]                 ...future.FUN(...future.X_jj, ...)
[11:00:23.506]             })
[11:00:23.506]         }
[11:00:23.506]     }, args = future.call.arguments)
[11:00:23.506] }
[11:00:23.506] Tweak future expression to call with '...' arguments ... DONE
[11:00:23.507] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:23.507] 
[11:00:23.508] getGlobalsAndPackages() ... DONE
[11:00:23.508] run() for ‘Future’ ...
[11:00:23.508] - state: ‘created’
[11:00:23.509] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:23.512] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:23.513] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:23.513]   - Field: ‘label’
[11:00:23.513]   - Field: ‘local’
[11:00:23.513]   - Field: ‘owner’
[11:00:23.513]   - Field: ‘envir’
[11:00:23.513]   - Field: ‘workers’
[11:00:23.514]   - Field: ‘packages’
[11:00:23.514]   - Field: ‘gc’
[11:00:23.514]   - Field: ‘job’
[11:00:23.514]   - Field: ‘conditions’
[11:00:23.514]   - Field: ‘expr’
[11:00:23.515]   - Field: ‘uuid’
[11:00:23.515]   - Field: ‘seed’
[11:00:23.515]   - Field: ‘version’
[11:00:23.515]   - Field: ‘result’
[11:00:23.515]   - Field: ‘asynchronous’
[11:00:23.515]   - Field: ‘calls’
[11:00:23.516]   - Field: ‘globals’
[11:00:23.516]   - Field: ‘stdout’
[11:00:23.516]   - Field: ‘earlySignal’
[11:00:23.516]   - Field: ‘lazy’
[11:00:23.516]   - Field: ‘state’
[11:00:23.517] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:23.517] - Launch lazy future ...
[11:00:23.517] Packages needed by the future expression (n = 0): <none>
[11:00:23.517] Packages needed by future strategies (n = 0): <none>
[11:00:23.518] {
[11:00:23.518]     {
[11:00:23.518]         {
[11:00:23.518]             ...future.startTime <- base::Sys.time()
[11:00:23.518]             {
[11:00:23.518]                 {
[11:00:23.518]                   {
[11:00:23.518]                     {
[11:00:23.518]                       base::local({
[11:00:23.518]                         has_future <- base::requireNamespace("future", 
[11:00:23.518]                           quietly = TRUE)
[11:00:23.518]                         if (has_future) {
[11:00:23.518]                           ns <- base::getNamespace("future")
[11:00:23.518]                           version <- ns[[".package"]][["version"]]
[11:00:23.518]                           if (is.null(version)) 
[11:00:23.518]                             version <- utils::packageVersion("future")
[11:00:23.518]                         }
[11:00:23.518]                         else {
[11:00:23.518]                           version <- NULL
[11:00:23.518]                         }
[11:00:23.518]                         if (!has_future || version < "1.8.0") {
[11:00:23.518]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:23.518]                             "", base::R.version$version.string), 
[11:00:23.518]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:23.518]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:23.518]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:23.518]                               "release", "version")], collapse = " "), 
[11:00:23.518]                             hostname = base::Sys.info()[["nodename"]])
[11:00:23.518]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:23.518]                             info)
[11:00:23.518]                           info <- base::paste(info, collapse = "; ")
[11:00:23.518]                           if (!has_future) {
[11:00:23.518]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:23.518]                               info)
[11:00:23.518]                           }
[11:00:23.518]                           else {
[11:00:23.518]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:23.518]                               info, version)
[11:00:23.518]                           }
[11:00:23.518]                           base::stop(msg)
[11:00:23.518]                         }
[11:00:23.518]                       })
[11:00:23.518]                     }
[11:00:23.518]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:23.518]                     base::options(mc.cores = 1L)
[11:00:23.518]                   }
[11:00:23.518]                   ...future.strategy.old <- future::plan("list")
[11:00:23.518]                   options(future.plan = NULL)
[11:00:23.518]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:23.518]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:23.518]                 }
[11:00:23.518]                 ...future.workdir <- getwd()
[11:00:23.518]             }
[11:00:23.518]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:23.518]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:23.518]         }
[11:00:23.518]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:23.518]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:23.518]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:23.518]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:23.518]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:23.518]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:23.518]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:23.518]             base::names(...future.oldOptions))
[11:00:23.518]     }
[11:00:23.518]     if (FALSE) {
[11:00:23.518]     }
[11:00:23.518]     else {
[11:00:23.518]         if (FALSE) {
[11:00:23.518]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:23.518]                 open = "w")
[11:00:23.518]         }
[11:00:23.518]         else {
[11:00:23.518]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:23.518]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:23.518]         }
[11:00:23.518]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:23.518]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:23.518]             base::sink(type = "output", split = FALSE)
[11:00:23.518]             base::close(...future.stdout)
[11:00:23.518]         }, add = TRUE)
[11:00:23.518]     }
[11:00:23.518]     ...future.frame <- base::sys.nframe()
[11:00:23.518]     ...future.conditions <- base::list()
[11:00:23.518]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:23.518]     if (FALSE) {
[11:00:23.518]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:23.518]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:23.518]     }
[11:00:23.518]     ...future.result <- base::tryCatch({
[11:00:23.518]         base::withCallingHandlers({
[11:00:23.518]             ...future.value <- base::withVisible(base::local({
[11:00:23.518]                 withCallingHandlers({
[11:00:23.518]                   {
[11:00:23.518]                     do.call(function(...) {
[11:00:23.518]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:23.518]                       if (!identical(...future.globals.maxSize.org, 
[11:00:23.518]                         ...future.globals.maxSize)) {
[11:00:23.518]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:23.518]                         on.exit(options(oopts), add = TRUE)
[11:00:23.518]                       }
[11:00:23.518]                       {
[11:00:23.518]                         lapply(seq_along(...future.elements_ii), 
[11:00:23.518]                           FUN = function(jj) {
[11:00:23.518]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:23.518]                             ...future.FUN(...future.X_jj, ...)
[11:00:23.518]                           })
[11:00:23.518]                       }
[11:00:23.518]                     }, args = future.call.arguments)
[11:00:23.518]                   }
[11:00:23.518]                 }, immediateCondition = function(cond) {
[11:00:23.518]                   save_rds <- function (object, pathname, ...) 
[11:00:23.518]                   {
[11:00:23.518]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:23.518]                     if (file_test("-f", pathname_tmp)) {
[11:00:23.518]                       fi_tmp <- file.info(pathname_tmp)
[11:00:23.518]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:23.518]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:23.518]                         fi_tmp[["mtime"]])
[11:00:23.518]                     }
[11:00:23.518]                     tryCatch({
[11:00:23.518]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:23.518]                     }, error = function(ex) {
[11:00:23.518]                       msg <- conditionMessage(ex)
[11:00:23.518]                       fi_tmp <- file.info(pathname_tmp)
[11:00:23.518]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:23.518]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:23.518]                         fi_tmp[["mtime"]], msg)
[11:00:23.518]                       ex$message <- msg
[11:00:23.518]                       stop(ex)
[11:00:23.518]                     })
[11:00:23.518]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:23.518]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:23.518]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:23.518]                       fi_tmp <- file.info(pathname_tmp)
[11:00:23.518]                       fi <- file.info(pathname)
[11:00:23.518]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:23.518]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:23.518]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:23.518]                         fi[["size"]], fi[["mtime"]])
[11:00:23.518]                       stop(msg)
[11:00:23.518]                     }
[11:00:23.518]                     invisible(pathname)
[11:00:23.518]                   }
[11:00:23.518]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:23.518]                     rootPath = tempdir()) 
[11:00:23.518]                   {
[11:00:23.518]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:23.518]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:23.518]                       tmpdir = path, fileext = ".rds")
[11:00:23.518]                     save_rds(obj, file)
[11:00:23.518]                   }
[11:00:23.518]                   saveImmediateCondition(cond, path = "/tmp/RtmpuTAfww/.future/immediateConditions")
[11:00:23.518]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:23.518]                   {
[11:00:23.518]                     inherits <- base::inherits
[11:00:23.518]                     invokeRestart <- base::invokeRestart
[11:00:23.518]                     is.null <- base::is.null
[11:00:23.518]                     muffled <- FALSE
[11:00:23.518]                     if (inherits(cond, "message")) {
[11:00:23.518]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:23.518]                       if (muffled) 
[11:00:23.518]                         invokeRestart("muffleMessage")
[11:00:23.518]                     }
[11:00:23.518]                     else if (inherits(cond, "warning")) {
[11:00:23.518]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:23.518]                       if (muffled) 
[11:00:23.518]                         invokeRestart("muffleWarning")
[11:00:23.518]                     }
[11:00:23.518]                     else if (inherits(cond, "condition")) {
[11:00:23.518]                       if (!is.null(pattern)) {
[11:00:23.518]                         computeRestarts <- base::computeRestarts
[11:00:23.518]                         grepl <- base::grepl
[11:00:23.518]                         restarts <- computeRestarts(cond)
[11:00:23.518]                         for (restart in restarts) {
[11:00:23.518]                           name <- restart$name
[11:00:23.518]                           if (is.null(name)) 
[11:00:23.518]                             next
[11:00:23.518]                           if (!grepl(pattern, name)) 
[11:00:23.518]                             next
[11:00:23.518]                           invokeRestart(restart)
[11:00:23.518]                           muffled <- TRUE
[11:00:23.518]                           break
[11:00:23.518]                         }
[11:00:23.518]                       }
[11:00:23.518]                     }
[11:00:23.518]                     invisible(muffled)
[11:00:23.518]                   }
[11:00:23.518]                   muffleCondition(cond)
[11:00:23.518]                 })
[11:00:23.518]             }))
[11:00:23.518]             future::FutureResult(value = ...future.value$value, 
[11:00:23.518]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:23.518]                   ...future.rng), globalenv = if (FALSE) 
[11:00:23.518]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:23.518]                     ...future.globalenv.names))
[11:00:23.518]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:23.518]         }, condition = base::local({
[11:00:23.518]             c <- base::c
[11:00:23.518]             inherits <- base::inherits
[11:00:23.518]             invokeRestart <- base::invokeRestart
[11:00:23.518]             length <- base::length
[11:00:23.518]             list <- base::list
[11:00:23.518]             seq.int <- base::seq.int
[11:00:23.518]             signalCondition <- base::signalCondition
[11:00:23.518]             sys.calls <- base::sys.calls
[11:00:23.518]             `[[` <- base::`[[`
[11:00:23.518]             `+` <- base::`+`
[11:00:23.518]             `<<-` <- base::`<<-`
[11:00:23.518]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:23.518]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:23.518]                   3L)]
[11:00:23.518]             }
[11:00:23.518]             function(cond) {
[11:00:23.518]                 is_error <- inherits(cond, "error")
[11:00:23.518]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:23.518]                   NULL)
[11:00:23.518]                 if (is_error) {
[11:00:23.518]                   sessionInformation <- function() {
[11:00:23.518]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:23.518]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:23.518]                       search = base::search(), system = base::Sys.info())
[11:00:23.518]                   }
[11:00:23.518]                   ...future.conditions[[length(...future.conditions) + 
[11:00:23.518]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:23.518]                     cond$call), session = sessionInformation(), 
[11:00:23.518]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:23.518]                   signalCondition(cond)
[11:00:23.518]                 }
[11:00:23.518]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:23.518]                 "immediateCondition"))) {
[11:00:23.518]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:23.518]                   ...future.conditions[[length(...future.conditions) + 
[11:00:23.518]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:23.518]                   if (TRUE && !signal) {
[11:00:23.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:23.518]                     {
[11:00:23.518]                       inherits <- base::inherits
[11:00:23.518]                       invokeRestart <- base::invokeRestart
[11:00:23.518]                       is.null <- base::is.null
[11:00:23.518]                       muffled <- FALSE
[11:00:23.518]                       if (inherits(cond, "message")) {
[11:00:23.518]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:23.518]                         if (muffled) 
[11:00:23.518]                           invokeRestart("muffleMessage")
[11:00:23.518]                       }
[11:00:23.518]                       else if (inherits(cond, "warning")) {
[11:00:23.518]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:23.518]                         if (muffled) 
[11:00:23.518]                           invokeRestart("muffleWarning")
[11:00:23.518]                       }
[11:00:23.518]                       else if (inherits(cond, "condition")) {
[11:00:23.518]                         if (!is.null(pattern)) {
[11:00:23.518]                           computeRestarts <- base::computeRestarts
[11:00:23.518]                           grepl <- base::grepl
[11:00:23.518]                           restarts <- computeRestarts(cond)
[11:00:23.518]                           for (restart in restarts) {
[11:00:23.518]                             name <- restart$name
[11:00:23.518]                             if (is.null(name)) 
[11:00:23.518]                               next
[11:00:23.518]                             if (!grepl(pattern, name)) 
[11:00:23.518]                               next
[11:00:23.518]                             invokeRestart(restart)
[11:00:23.518]                             muffled <- TRUE
[11:00:23.518]                             break
[11:00:23.518]                           }
[11:00:23.518]                         }
[11:00:23.518]                       }
[11:00:23.518]                       invisible(muffled)
[11:00:23.518]                     }
[11:00:23.518]                     muffleCondition(cond, pattern = "^muffle")
[11:00:23.518]                   }
[11:00:23.518]                 }
[11:00:23.518]                 else {
[11:00:23.518]                   if (TRUE) {
[11:00:23.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:23.518]                     {
[11:00:23.518]                       inherits <- base::inherits
[11:00:23.518]                       invokeRestart <- base::invokeRestart
[11:00:23.518]                       is.null <- base::is.null
[11:00:23.518]                       muffled <- FALSE
[11:00:23.518]                       if (inherits(cond, "message")) {
[11:00:23.518]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:23.518]                         if (muffled) 
[11:00:23.518]                           invokeRestart("muffleMessage")
[11:00:23.518]                       }
[11:00:23.518]                       else if (inherits(cond, "warning")) {
[11:00:23.518]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:23.518]                         if (muffled) 
[11:00:23.518]                           invokeRestart("muffleWarning")
[11:00:23.518]                       }
[11:00:23.518]                       else if (inherits(cond, "condition")) {
[11:00:23.518]                         if (!is.null(pattern)) {
[11:00:23.518]                           computeRestarts <- base::computeRestarts
[11:00:23.518]                           grepl <- base::grepl
[11:00:23.518]                           restarts <- computeRestarts(cond)
[11:00:23.518]                           for (restart in restarts) {
[11:00:23.518]                             name <- restart$name
[11:00:23.518]                             if (is.null(name)) 
[11:00:23.518]                               next
[11:00:23.518]                             if (!grepl(pattern, name)) 
[11:00:23.518]                               next
[11:00:23.518]                             invokeRestart(restart)
[11:00:23.518]                             muffled <- TRUE
[11:00:23.518]                             break
[11:00:23.518]                           }
[11:00:23.518]                         }
[11:00:23.518]                       }
[11:00:23.518]                       invisible(muffled)
[11:00:23.518]                     }
[11:00:23.518]                     muffleCondition(cond, pattern = "^muffle")
[11:00:23.518]                   }
[11:00:23.518]                 }
[11:00:23.518]             }
[11:00:23.518]         }))
[11:00:23.518]     }, error = function(ex) {
[11:00:23.518]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:23.518]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:23.518]                 ...future.rng), started = ...future.startTime, 
[11:00:23.518]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:23.518]             version = "1.8"), class = "FutureResult")
[11:00:23.518]     }, finally = {
[11:00:23.518]         if (!identical(...future.workdir, getwd())) 
[11:00:23.518]             setwd(...future.workdir)
[11:00:23.518]         {
[11:00:23.518]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:23.518]                 ...future.oldOptions$nwarnings <- NULL
[11:00:23.518]             }
[11:00:23.518]             base::options(...future.oldOptions)
[11:00:23.518]             if (.Platform$OS.type == "windows") {
[11:00:23.518]                 old_names <- names(...future.oldEnvVars)
[11:00:23.518]                 envs <- base::Sys.getenv()
[11:00:23.518]                 names <- names(envs)
[11:00:23.518]                 common <- intersect(names, old_names)
[11:00:23.518]                 added <- setdiff(names, old_names)
[11:00:23.518]                 removed <- setdiff(old_names, names)
[11:00:23.518]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:23.518]                   envs[common]]
[11:00:23.518]                 NAMES <- toupper(changed)
[11:00:23.518]                 args <- list()
[11:00:23.518]                 for (kk in seq_along(NAMES)) {
[11:00:23.518]                   name <- changed[[kk]]
[11:00:23.518]                   NAME <- NAMES[[kk]]
[11:00:23.518]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:23.518]                     next
[11:00:23.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:23.518]                 }
[11:00:23.518]                 NAMES <- toupper(added)
[11:00:23.518]                 for (kk in seq_along(NAMES)) {
[11:00:23.518]                   name <- added[[kk]]
[11:00:23.518]                   NAME <- NAMES[[kk]]
[11:00:23.518]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:23.518]                     next
[11:00:23.518]                   args[[name]] <- ""
[11:00:23.518]                 }
[11:00:23.518]                 NAMES <- toupper(removed)
[11:00:23.518]                 for (kk in seq_along(NAMES)) {
[11:00:23.518]                   name <- removed[[kk]]
[11:00:23.518]                   NAME <- NAMES[[kk]]
[11:00:23.518]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:23.518]                     next
[11:00:23.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:23.518]                 }
[11:00:23.518]                 if (length(args) > 0) 
[11:00:23.518]                   base::do.call(base::Sys.setenv, args = args)
[11:00:23.518]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:23.518]             }
[11:00:23.518]             else {
[11:00:23.518]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:23.518]             }
[11:00:23.518]             {
[11:00:23.518]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:23.518]                   0L) {
[11:00:23.518]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:23.518]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:23.518]                   base::options(opts)
[11:00:23.518]                 }
[11:00:23.518]                 {
[11:00:23.518]                   {
[11:00:23.518]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:23.518]                     NULL
[11:00:23.518]                   }
[11:00:23.518]                   options(future.plan = NULL)
[11:00:23.518]                   if (is.na(NA_character_)) 
[11:00:23.518]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:23.518]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:23.518]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:23.518]                     .init = FALSE)
[11:00:23.518]                 }
[11:00:23.518]             }
[11:00:23.518]         }
[11:00:23.518]     })
[11:00:23.518]     if (TRUE) {
[11:00:23.518]         base::sink(type = "output", split = FALSE)
[11:00:23.518]         if (FALSE) {
[11:00:23.518]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:23.518]         }
[11:00:23.518]         else {
[11:00:23.518]             ...future.result["stdout"] <- base::list(NULL)
[11:00:23.518]         }
[11:00:23.518]         base::close(...future.stdout)
[11:00:23.518]         ...future.stdout <- NULL
[11:00:23.518]     }
[11:00:23.518]     ...future.result$conditions <- ...future.conditions
[11:00:23.518]     ...future.result$finished <- base::Sys.time()
[11:00:23.518]     ...future.result
[11:00:23.518] }
[11:00:23.522] assign_globals() ...
[11:00:23.522] List of 5
[11:00:23.522]  $ ...future.FUN            :function (x)  
[11:00:23.522]  $ future.call.arguments    : list()
[11:00:23.522]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:23.522]  $ ...future.elements_ii    :List of 1
[11:00:23.522]   ..$ : int 0
[11:00:23.522]  $ ...future.seeds_ii       : NULL
[11:00:23.522]  $ ...future.globals.maxSize: NULL
[11:00:23.522]  - attr(*, "where")=List of 5
[11:00:23.522]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:23.522]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:23.522]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:23.522]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:23.522]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:23.522]  - attr(*, "resolved")= logi FALSE
[11:00:23.522]  - attr(*, "total_size")= num 5632
[11:00:23.522]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:23.522]  - attr(*, "already-done")= logi TRUE
[11:00:23.531] - reassign environment for ‘...future.FUN’
[11:00:23.532] - copied ‘...future.FUN’ to environment
[11:00:23.532] - copied ‘future.call.arguments’ to environment
[11:00:23.532] - copied ‘...future.elements_ii’ to environment
[11:00:23.532] - copied ‘...future.seeds_ii’ to environment
[11:00:23.532] - copied ‘...future.globals.maxSize’ to environment
[11:00:23.532] assign_globals() ... done
[11:00:23.533] requestCore(): workers = 2
[11:00:23.544] MulticoreFuture started
[11:00:23.545] - Launch lazy future ... done
[11:00:23.546] plan(): Setting new future strategy stack:
[11:00:23.546] run() for ‘MulticoreFuture’ ... done
[11:00:23.547] Created future:
[11:00:23.546] List of future strategies:
[11:00:23.546] 1. sequential:
[11:00:23.546]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:23.546]    - tweaked: FALSE
[11:00:23.546]    - call: NULL
[11:00:23.548] plan(): nbrOfWorkers() = 1
[11:00:23.551] plan(): Setting new future strategy stack:
[11:00:23.551] List of future strategies:
[11:00:23.551] 1. multicore:
[11:00:23.551]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:23.551]    - tweaked: FALSE
[11:00:23.551]    - call: plan(strategy)
[11:00:23.556] plan(): nbrOfWorkers() = 2
[11:00:23.547] MulticoreFuture:
[11:00:23.547] Label: ‘future_lapply-2’
[11:00:23.547] Expression:
[11:00:23.547] {
[11:00:23.547]     do.call(function(...) {
[11:00:23.547]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:23.547]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:23.547]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:23.547]             on.exit(options(oopts), add = TRUE)
[11:00:23.547]         }
[11:00:23.547]         {
[11:00:23.547]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:23.547]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:23.547]                 ...future.FUN(...future.X_jj, ...)
[11:00:23.547]             })
[11:00:23.547]         }
[11:00:23.547]     }, args = future.call.arguments)
[11:00:23.547] }
[11:00:23.547] Lazy evaluation: FALSE
[11:00:23.547] Asynchronous evaluation: TRUE
[11:00:23.547] Local evaluation: TRUE
[11:00:23.547] Environment: R_GlobalEnv
[11:00:23.547] Capture standard output: FALSE
[11:00:23.547] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:23.547] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:23.547] Packages: <none>
[11:00:23.547] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:23.547] Resolved: TRUE
[11:00:23.547] Value: <not collected>
[11:00:23.547] Conditions captured: <none>
[11:00:23.547] Early signaling: FALSE
[11:00:23.547] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:23.547] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:23.557] Chunk #2 of 2 ... DONE
[11:00:23.557] Launching 2 futures (chunks) ... DONE
[11:00:23.557] Resolving 2 futures (chunks) ...
[11:00:23.558] resolve() on list ...
[11:00:23.558]  recursive: 0
[11:00:23.558]  length: 2
[11:00:23.558] 
[11:00:23.569] Future #2
[11:00:23.570] result() for MulticoreFuture ...
[11:00:23.572] result() for MulticoreFuture ...
[11:00:23.572] result() for MulticoreFuture ... done
[11:00:23.572] result() for MulticoreFuture ... done
[11:00:23.572] result() for MulticoreFuture ...
[11:00:23.572] result() for MulticoreFuture ... done
[11:00:23.572] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:00:23.573] - nx: 2
[11:00:23.573] - relay: TRUE
[11:00:23.573] - stdout: TRUE
[11:00:23.573] - signal: TRUE
[11:00:23.573] - resignal: FALSE
[11:00:23.573] - force: TRUE
[11:00:23.573] - relayed: [n=2] FALSE, FALSE
[11:00:23.573] - queued futures: [n=2] FALSE, FALSE
[11:00:23.574]  - until=1
[11:00:23.574]  - relaying element #1
[11:00:23.574] - relayed: [n=2] FALSE, FALSE
[11:00:23.574] - queued futures: [n=2] FALSE, TRUE
[11:00:23.574] signalConditionsASAP(NULL, pos=2) ... done
[11:00:23.574]  length: 1 (resolved future 2)
[11:00:23.990] plan(): Setting new future strategy stack:
[11:00:23.991] List of future strategies:
[11:00:23.991] 1. multicore:
[11:00:23.991]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:23.991]    - tweaked: FALSE
[11:00:23.991]    - call: plan(strategy)
[11:00:23.993] plan(): nbrOfWorkers() = 2
[11:00:23.994] Future #1
[11:00:23.994] result() for MulticoreFuture ...
[11:00:23.994] result() for MulticoreFuture ...
[11:00:23.995] result() for MulticoreFuture ... done
[11:00:23.995] result() for MulticoreFuture ... done
[11:00:23.995] result() for MulticoreFuture ...
[11:00:23.995] result() for MulticoreFuture ... done
[11:00:23.995] signalConditionsASAP(MulticoreFuture, pos=1) ...
[11:00:23.995] - nx: 2
[11:00:23.995] - relay: TRUE
[11:00:23.995] - stdout: TRUE
[11:00:23.995] - signal: TRUE
[11:00:23.995] - resignal: FALSE
[11:00:23.996] - force: TRUE
[11:00:23.996] - relayed: [n=2] FALSE, FALSE
[11:00:23.996] - queued futures: [n=2] FALSE, TRUE
[11:00:23.996]  - until=1
[11:00:23.996]  - relaying element #1
[11:00:23.996] result() for MulticoreFuture ...
[11:00:23.996] result() for MulticoreFuture ... done
[11:00:23.996] result() for MulticoreFuture ...
[11:00:23.997] result() for MulticoreFuture ... done
[11:00:23.997] result() for MulticoreFuture ...
[11:00:23.997] result() for MulticoreFuture ... done
[11:00:23.997] result() for MulticoreFuture ...
[11:00:23.997] result() for MulticoreFuture ... done
[11:00:23.997] - relayed: [n=2] TRUE, FALSE
[11:00:23.997] - queued futures: [n=2] TRUE, TRUE
[11:00:23.997] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[11:00:23.997]  length: 0 (resolved future 1)
[11:00:23.998] Relaying remaining futures
[11:00:23.998] signalConditionsASAP(NULL, pos=0) ...
[11:00:23.998] - nx: 2
[11:00:23.998] - relay: TRUE
[11:00:23.998] - stdout: TRUE
[11:00:23.998] - signal: TRUE
[11:00:23.998] - resignal: FALSE
[11:00:23.998] - force: TRUE
[11:00:23.998] - relayed: [n=2] TRUE, FALSE
[11:00:23.998] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:23.999]  - relaying element #2
[11:00:23.999] result() for MulticoreFuture ...
[11:00:23.999] result() for MulticoreFuture ... done
[11:00:23.999] result() for MulticoreFuture ...
[11:00:23.999] result() for MulticoreFuture ... done
[11:00:23.999] result() for MulticoreFuture ...
[11:00:23.999] result() for MulticoreFuture ... done
[11:00:23.999] result() for MulticoreFuture ...
[11:00:24.000] result() for MulticoreFuture ... done
[11:00:24.000] - relayed: [n=2] TRUE, TRUE
[11:00:24.000] - queued futures: [n=2] TRUE, TRUE
[11:00:24.000] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[11:00:24.000] resolve() on list ... DONE
[11:00:24.000] result() for MulticoreFuture ...
[11:00:24.000] result() for MulticoreFuture ... done
[11:00:24.000] result() for MulticoreFuture ...
[11:00:24.000] result() for MulticoreFuture ... done
[11:00:24.000] result() for MulticoreFuture ...
[11:00:24.001] result() for MulticoreFuture ... done
[11:00:24.001] result() for MulticoreFuture ...
[11:00:24.001] result() for MulticoreFuture ... done
[11:00:24.001]  - Number of value chunks collected: 2
[11:00:24.001] Resolving 2 futures (chunks) ... DONE
[11:00:24.001] Reducing values from 2 chunks ...
[11:00:24.001]  - Number of values collected after concatenation: 2
[11:00:24.001]  - Number of values expected: 2
[11:00:24.001] Reducing values from 2 chunks ... DONE
[11:00:24.002] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[11:00:24.002] future_lapply() ...
[11:00:24.005] Number of chunks: 2
[11:00:24.005] getGlobalsAndPackagesXApply() ...
[11:00:24.005]  - future.globals: TRUE
[11:00:24.005] getGlobalsAndPackages() ...
[11:00:24.005] Searching for globals...
[11:00:24.007] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[11:00:24.007] Searching for globals ... DONE
[11:00:24.007] Resolving globals: FALSE
[11:00:24.008] The total size of the 1 globals is 841 bytes (841 bytes)
[11:00:24.008] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[11:00:24.008] - globals: [1] ‘FUN’
[11:00:24.008] 
[11:00:24.008] getGlobalsAndPackages() ... DONE
[11:00:24.009]  - globals found/used: [n=1] ‘FUN’
[11:00:24.009]  - needed namespaces: [n=0] 
[11:00:24.009] Finding globals ... DONE
[11:00:24.009]  - use_args: TRUE
[11:00:24.009]  - Getting '...' globals ...
[11:00:24.009] resolve() on list ...
[11:00:24.009]  recursive: 0
[11:00:24.010]  length: 1
[11:00:24.010]  elements: ‘...’
[11:00:24.010]  length: 0 (resolved future 1)
[11:00:24.010] resolve() on list ... DONE
[11:00:24.010]    - '...' content: [n=0] 
[11:00:24.010] List of 1
[11:00:24.010]  $ ...: list()
[11:00:24.010]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:24.010]  - attr(*, "where")=List of 1
[11:00:24.010]   ..$ ...:<environment: 0x55ceb39a47b8> 
[11:00:24.010]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:24.010]  - attr(*, "resolved")= logi TRUE
[11:00:24.010]  - attr(*, "total_size")= num NA
[11:00:24.015]  - Getting '...' globals ... DONE
[11:00:24.015] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[11:00:24.015] List of 2
[11:00:24.015]  $ ...future.FUN:function (x)  
[11:00:24.015]  $ ...          : list()
[11:00:24.015]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:24.015]  - attr(*, "where")=List of 2
[11:00:24.015]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:24.015]   ..$ ...          :<environment: 0x55ceb39a47b8> 
[11:00:24.015]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:24.015]  - attr(*, "resolved")= logi FALSE
[11:00:24.015]  - attr(*, "total_size")= num 5632
[11:00:24.018] Packages to be attached in all futures: [n=0] 
[11:00:24.018] getGlobalsAndPackagesXApply() ... DONE
[11:00:24.018] Number of futures (= number of chunks): 2
[11:00:24.018] Launching 2 futures (chunks) ...
[11:00:24.018] Chunk #1 of 2 ...
[11:00:24.018]  - Finding globals in 'X' for chunk #1 ...
[11:00:24.019] getGlobalsAndPackages() ...
[11:00:24.019] Searching for globals...
[11:00:24.019] 
[11:00:24.019] Searching for globals ... DONE
[11:00:24.019] - globals: [0] <none>
[11:00:24.019] getGlobalsAndPackages() ... DONE
[11:00:24.019]    + additional globals found: [n=0] 
[11:00:24.019]    + additional namespaces needed: [n=0] 
[11:00:24.019]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:24.020]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:24.020]  - seeds: <none>
[11:00:24.020]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:24.020] getGlobalsAndPackages() ...
[11:00:24.020] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:24.020] Resolving globals: FALSE
[11:00:24.020] Tweak future expression to call with '...' arguments ...
[11:00:24.020] {
[11:00:24.020]     do.call(function(...) {
[11:00:24.020]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:24.020]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:24.020]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:24.020]             on.exit(options(oopts), add = TRUE)
[11:00:24.020]         }
[11:00:24.020]         {
[11:00:24.020]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:24.020]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:24.020]                 ...future.FUN(...future.X_jj, ...)
[11:00:24.020]             })
[11:00:24.020]         }
[11:00:24.020]     }, args = future.call.arguments)
[11:00:24.020] }
[11:00:24.020] Tweak future expression to call with '...' arguments ... DONE
[11:00:24.021] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:24.021] 
[11:00:24.021] getGlobalsAndPackages() ... DONE
[11:00:24.021] run() for ‘Future’ ...
[11:00:24.021] - state: ‘created’
[11:00:24.022] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:24.023] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:24.023] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:24.023]   - Field: ‘label’
[11:00:24.023]   - Field: ‘local’
[11:00:24.024]   - Field: ‘owner’
[11:00:24.024]   - Field: ‘envir’
[11:00:24.024]   - Field: ‘workers’
[11:00:24.024]   - Field: ‘packages’
[11:00:24.024]   - Field: ‘gc’
[11:00:24.024]   - Field: ‘job’
[11:00:24.024]   - Field: ‘conditions’
[11:00:24.024]   - Field: ‘expr’
[11:00:24.024]   - Field: ‘uuid’
[11:00:24.024]   - Field: ‘seed’
[11:00:24.024]   - Field: ‘version’
[11:00:24.024]   - Field: ‘result’
[11:00:24.025]   - Field: ‘asynchronous’
[11:00:24.025]   - Field: ‘calls’
[11:00:24.025]   - Field: ‘globals’
[11:00:24.025]   - Field: ‘stdout’
[11:00:24.025]   - Field: ‘earlySignal’
[11:00:24.025]   - Field: ‘lazy’
[11:00:24.025]   - Field: ‘state’
[11:00:24.025] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:24.025] - Launch lazy future ...
[11:00:24.025] Packages needed by the future expression (n = 0): <none>
[11:00:24.026] Packages needed by future strategies (n = 0): <none>
[11:00:24.026] {
[11:00:24.026]     {
[11:00:24.026]         {
[11:00:24.026]             ...future.startTime <- base::Sys.time()
[11:00:24.026]             {
[11:00:24.026]                 {
[11:00:24.026]                   {
[11:00:24.026]                     {
[11:00:24.026]                       base::local({
[11:00:24.026]                         has_future <- base::requireNamespace("future", 
[11:00:24.026]                           quietly = TRUE)
[11:00:24.026]                         if (has_future) {
[11:00:24.026]                           ns <- base::getNamespace("future")
[11:00:24.026]                           version <- ns[[".package"]][["version"]]
[11:00:24.026]                           if (is.null(version)) 
[11:00:24.026]                             version <- utils::packageVersion("future")
[11:00:24.026]                         }
[11:00:24.026]                         else {
[11:00:24.026]                           version <- NULL
[11:00:24.026]                         }
[11:00:24.026]                         if (!has_future || version < "1.8.0") {
[11:00:24.026]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:24.026]                             "", base::R.version$version.string), 
[11:00:24.026]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:24.026]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:24.026]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:24.026]                               "release", "version")], collapse = " "), 
[11:00:24.026]                             hostname = base::Sys.info()[["nodename"]])
[11:00:24.026]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:24.026]                             info)
[11:00:24.026]                           info <- base::paste(info, collapse = "; ")
[11:00:24.026]                           if (!has_future) {
[11:00:24.026]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:24.026]                               info)
[11:00:24.026]                           }
[11:00:24.026]                           else {
[11:00:24.026]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:24.026]                               info, version)
[11:00:24.026]                           }
[11:00:24.026]                           base::stop(msg)
[11:00:24.026]                         }
[11:00:24.026]                       })
[11:00:24.026]                     }
[11:00:24.026]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:24.026]                     base::options(mc.cores = 1L)
[11:00:24.026]                   }
[11:00:24.026]                   ...future.strategy.old <- future::plan("list")
[11:00:24.026]                   options(future.plan = NULL)
[11:00:24.026]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:24.026]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:24.026]                 }
[11:00:24.026]                 ...future.workdir <- getwd()
[11:00:24.026]             }
[11:00:24.026]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:24.026]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:24.026]         }
[11:00:24.026]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:24.026]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:24.026]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:24.026]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:24.026]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:24.026]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:24.026]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:24.026]             base::names(...future.oldOptions))
[11:00:24.026]     }
[11:00:24.026]     if (FALSE) {
[11:00:24.026]     }
[11:00:24.026]     else {
[11:00:24.026]         if (TRUE) {
[11:00:24.026]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:24.026]                 open = "w")
[11:00:24.026]         }
[11:00:24.026]         else {
[11:00:24.026]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:24.026]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:24.026]         }
[11:00:24.026]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:24.026]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:24.026]             base::sink(type = "output", split = FALSE)
[11:00:24.026]             base::close(...future.stdout)
[11:00:24.026]         }, add = TRUE)
[11:00:24.026]     }
[11:00:24.026]     ...future.frame <- base::sys.nframe()
[11:00:24.026]     ...future.conditions <- base::list()
[11:00:24.026]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:24.026]     if (FALSE) {
[11:00:24.026]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:24.026]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:24.026]     }
[11:00:24.026]     ...future.result <- base::tryCatch({
[11:00:24.026]         base::withCallingHandlers({
[11:00:24.026]             ...future.value <- base::withVisible(base::local({
[11:00:24.026]                 withCallingHandlers({
[11:00:24.026]                   {
[11:00:24.026]                     do.call(function(...) {
[11:00:24.026]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:24.026]                       if (!identical(...future.globals.maxSize.org, 
[11:00:24.026]                         ...future.globals.maxSize)) {
[11:00:24.026]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:24.026]                         on.exit(options(oopts), add = TRUE)
[11:00:24.026]                       }
[11:00:24.026]                       {
[11:00:24.026]                         lapply(seq_along(...future.elements_ii), 
[11:00:24.026]                           FUN = function(jj) {
[11:00:24.026]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:24.026]                             ...future.FUN(...future.X_jj, ...)
[11:00:24.026]                           })
[11:00:24.026]                       }
[11:00:24.026]                     }, args = future.call.arguments)
[11:00:24.026]                   }
[11:00:24.026]                 }, immediateCondition = function(cond) {
[11:00:24.026]                   save_rds <- function (object, pathname, ...) 
[11:00:24.026]                   {
[11:00:24.026]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:24.026]                     if (file_test("-f", pathname_tmp)) {
[11:00:24.026]                       fi_tmp <- file.info(pathname_tmp)
[11:00:24.026]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:24.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:24.026]                         fi_tmp[["mtime"]])
[11:00:24.026]                     }
[11:00:24.026]                     tryCatch({
[11:00:24.026]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:24.026]                     }, error = function(ex) {
[11:00:24.026]                       msg <- conditionMessage(ex)
[11:00:24.026]                       fi_tmp <- file.info(pathname_tmp)
[11:00:24.026]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:24.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:24.026]                         fi_tmp[["mtime"]], msg)
[11:00:24.026]                       ex$message <- msg
[11:00:24.026]                       stop(ex)
[11:00:24.026]                     })
[11:00:24.026]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:24.026]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:24.026]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:24.026]                       fi_tmp <- file.info(pathname_tmp)
[11:00:24.026]                       fi <- file.info(pathname)
[11:00:24.026]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:24.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:24.026]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:24.026]                         fi[["size"]], fi[["mtime"]])
[11:00:24.026]                       stop(msg)
[11:00:24.026]                     }
[11:00:24.026]                     invisible(pathname)
[11:00:24.026]                   }
[11:00:24.026]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:24.026]                     rootPath = tempdir()) 
[11:00:24.026]                   {
[11:00:24.026]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:24.026]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:24.026]                       tmpdir = path, fileext = ".rds")
[11:00:24.026]                     save_rds(obj, file)
[11:00:24.026]                   }
[11:00:24.026]                   saveImmediateCondition(cond, path = "/tmp/RtmpuTAfww/.future/immediateConditions")
[11:00:24.026]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:24.026]                   {
[11:00:24.026]                     inherits <- base::inherits
[11:00:24.026]                     invokeRestart <- base::invokeRestart
[11:00:24.026]                     is.null <- base::is.null
[11:00:24.026]                     muffled <- FALSE
[11:00:24.026]                     if (inherits(cond, "message")) {
[11:00:24.026]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:24.026]                       if (muffled) 
[11:00:24.026]                         invokeRestart("muffleMessage")
[11:00:24.026]                     }
[11:00:24.026]                     else if (inherits(cond, "warning")) {
[11:00:24.026]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:24.026]                       if (muffled) 
[11:00:24.026]                         invokeRestart("muffleWarning")
[11:00:24.026]                     }
[11:00:24.026]                     else if (inherits(cond, "condition")) {
[11:00:24.026]                       if (!is.null(pattern)) {
[11:00:24.026]                         computeRestarts <- base::computeRestarts
[11:00:24.026]                         grepl <- base::grepl
[11:00:24.026]                         restarts <- computeRestarts(cond)
[11:00:24.026]                         for (restart in restarts) {
[11:00:24.026]                           name <- restart$name
[11:00:24.026]                           if (is.null(name)) 
[11:00:24.026]                             next
[11:00:24.026]                           if (!grepl(pattern, name)) 
[11:00:24.026]                             next
[11:00:24.026]                           invokeRestart(restart)
[11:00:24.026]                           muffled <- TRUE
[11:00:24.026]                           break
[11:00:24.026]                         }
[11:00:24.026]                       }
[11:00:24.026]                     }
[11:00:24.026]                     invisible(muffled)
[11:00:24.026]                   }
[11:00:24.026]                   muffleCondition(cond)
[11:00:24.026]                 })
[11:00:24.026]             }))
[11:00:24.026]             future::FutureResult(value = ...future.value$value, 
[11:00:24.026]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:24.026]                   ...future.rng), globalenv = if (FALSE) 
[11:00:24.026]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:24.026]                     ...future.globalenv.names))
[11:00:24.026]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:24.026]         }, condition = base::local({
[11:00:24.026]             c <- base::c
[11:00:24.026]             inherits <- base::inherits
[11:00:24.026]             invokeRestart <- base::invokeRestart
[11:00:24.026]             length <- base::length
[11:00:24.026]             list <- base::list
[11:00:24.026]             seq.int <- base::seq.int
[11:00:24.026]             signalCondition <- base::signalCondition
[11:00:24.026]             sys.calls <- base::sys.calls
[11:00:24.026]             `[[` <- base::`[[`
[11:00:24.026]             `+` <- base::`+`
[11:00:24.026]             `<<-` <- base::`<<-`
[11:00:24.026]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:24.026]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:24.026]                   3L)]
[11:00:24.026]             }
[11:00:24.026]             function(cond) {
[11:00:24.026]                 is_error <- inherits(cond, "error")
[11:00:24.026]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:24.026]                   NULL)
[11:00:24.026]                 if (is_error) {
[11:00:24.026]                   sessionInformation <- function() {
[11:00:24.026]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:24.026]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:24.026]                       search = base::search(), system = base::Sys.info())
[11:00:24.026]                   }
[11:00:24.026]                   ...future.conditions[[length(...future.conditions) + 
[11:00:24.026]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:24.026]                     cond$call), session = sessionInformation(), 
[11:00:24.026]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:24.026]                   signalCondition(cond)
[11:00:24.026]                 }
[11:00:24.026]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:24.026]                 "immediateCondition"))) {
[11:00:24.026]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:24.026]                   ...future.conditions[[length(...future.conditions) + 
[11:00:24.026]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:24.026]                   if (TRUE && !signal) {
[11:00:24.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:24.026]                     {
[11:00:24.026]                       inherits <- base::inherits
[11:00:24.026]                       invokeRestart <- base::invokeRestart
[11:00:24.026]                       is.null <- base::is.null
[11:00:24.026]                       muffled <- FALSE
[11:00:24.026]                       if (inherits(cond, "message")) {
[11:00:24.026]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:24.026]                         if (muffled) 
[11:00:24.026]                           invokeRestart("muffleMessage")
[11:00:24.026]                       }
[11:00:24.026]                       else if (inherits(cond, "warning")) {
[11:00:24.026]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:24.026]                         if (muffled) 
[11:00:24.026]                           invokeRestart("muffleWarning")
[11:00:24.026]                       }
[11:00:24.026]                       else if (inherits(cond, "condition")) {
[11:00:24.026]                         if (!is.null(pattern)) {
[11:00:24.026]                           computeRestarts <- base::computeRestarts
[11:00:24.026]                           grepl <- base::grepl
[11:00:24.026]                           restarts <- computeRestarts(cond)
[11:00:24.026]                           for (restart in restarts) {
[11:00:24.026]                             name <- restart$name
[11:00:24.026]                             if (is.null(name)) 
[11:00:24.026]                               next
[11:00:24.026]                             if (!grepl(pattern, name)) 
[11:00:24.026]                               next
[11:00:24.026]                             invokeRestart(restart)
[11:00:24.026]                             muffled <- TRUE
[11:00:24.026]                             break
[11:00:24.026]                           }
[11:00:24.026]                         }
[11:00:24.026]                       }
[11:00:24.026]                       invisible(muffled)
[11:00:24.026]                     }
[11:00:24.026]                     muffleCondition(cond, pattern = "^muffle")
[11:00:24.026]                   }
[11:00:24.026]                 }
[11:00:24.026]                 else {
[11:00:24.026]                   if (TRUE) {
[11:00:24.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:24.026]                     {
[11:00:24.026]                       inherits <- base::inherits
[11:00:24.026]                       invokeRestart <- base::invokeRestart
[11:00:24.026]                       is.null <- base::is.null
[11:00:24.026]                       muffled <- FALSE
[11:00:24.026]                       if (inherits(cond, "message")) {
[11:00:24.026]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:24.026]                         if (muffled) 
[11:00:24.026]                           invokeRestart("muffleMessage")
[11:00:24.026]                       }
[11:00:24.026]                       else if (inherits(cond, "warning")) {
[11:00:24.026]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:24.026]                         if (muffled) 
[11:00:24.026]                           invokeRestart("muffleWarning")
[11:00:24.026]                       }
[11:00:24.026]                       else if (inherits(cond, "condition")) {
[11:00:24.026]                         if (!is.null(pattern)) {
[11:00:24.026]                           computeRestarts <- base::computeRestarts
[11:00:24.026]                           grepl <- base::grepl
[11:00:24.026]                           restarts <- computeRestarts(cond)
[11:00:24.026]                           for (restart in restarts) {
[11:00:24.026]                             name <- restart$name
[11:00:24.026]                             if (is.null(name)) 
[11:00:24.026]                               next
[11:00:24.026]                             if (!grepl(pattern, name)) 
[11:00:24.026]                               next
[11:00:24.026]                             invokeRestart(restart)
[11:00:24.026]                             muffled <- TRUE
[11:00:24.026]                             break
[11:00:24.026]                           }
[11:00:24.026]                         }
[11:00:24.026]                       }
[11:00:24.026]                       invisible(muffled)
[11:00:24.026]                     }
[11:00:24.026]                     muffleCondition(cond, pattern = "^muffle")
[11:00:24.026]                   }
[11:00:24.026]                 }
[11:00:24.026]             }
[11:00:24.026]         }))
[11:00:24.026]     }, error = function(ex) {
[11:00:24.026]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:24.026]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:24.026]                 ...future.rng), started = ...future.startTime, 
[11:00:24.026]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:24.026]             version = "1.8"), class = "FutureResult")
[11:00:24.026]     }, finally = {
[11:00:24.026]         if (!identical(...future.workdir, getwd())) 
[11:00:24.026]             setwd(...future.workdir)
[11:00:24.026]         {
[11:00:24.026]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:24.026]                 ...future.oldOptions$nwarnings <- NULL
[11:00:24.026]             }
[11:00:24.026]             base::options(...future.oldOptions)
[11:00:24.026]             if (.Platform$OS.type == "windows") {
[11:00:24.026]                 old_names <- names(...future.oldEnvVars)
[11:00:24.026]                 envs <- base::Sys.getenv()
[11:00:24.026]                 names <- names(envs)
[11:00:24.026]                 common <- intersect(names, old_names)
[11:00:24.026]                 added <- setdiff(names, old_names)
[11:00:24.026]                 removed <- setdiff(old_names, names)
[11:00:24.026]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:24.026]                   envs[common]]
[11:00:24.026]                 NAMES <- toupper(changed)
[11:00:24.026]                 args <- list()
[11:00:24.026]                 for (kk in seq_along(NAMES)) {
[11:00:24.026]                   name <- changed[[kk]]
[11:00:24.026]                   NAME <- NAMES[[kk]]
[11:00:24.026]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:24.026]                     next
[11:00:24.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:24.026]                 }
[11:00:24.026]                 NAMES <- toupper(added)
[11:00:24.026]                 for (kk in seq_along(NAMES)) {
[11:00:24.026]                   name <- added[[kk]]
[11:00:24.026]                   NAME <- NAMES[[kk]]
[11:00:24.026]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:24.026]                     next
[11:00:24.026]                   args[[name]] <- ""
[11:00:24.026]                 }
[11:00:24.026]                 NAMES <- toupper(removed)
[11:00:24.026]                 for (kk in seq_along(NAMES)) {
[11:00:24.026]                   name <- removed[[kk]]
[11:00:24.026]                   NAME <- NAMES[[kk]]
[11:00:24.026]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:24.026]                     next
[11:00:24.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:24.026]                 }
[11:00:24.026]                 if (length(args) > 0) 
[11:00:24.026]                   base::do.call(base::Sys.setenv, args = args)
[11:00:24.026]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:24.026]             }
[11:00:24.026]             else {
[11:00:24.026]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:24.026]             }
[11:00:24.026]             {
[11:00:24.026]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:24.026]                   0L) {
[11:00:24.026]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:24.026]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:24.026]                   base::options(opts)
[11:00:24.026]                 }
[11:00:24.026]                 {
[11:00:24.026]                   {
[11:00:24.026]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:24.026]                     NULL
[11:00:24.026]                   }
[11:00:24.026]                   options(future.plan = NULL)
[11:00:24.026]                   if (is.na(NA_character_)) 
[11:00:24.026]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:24.026]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:24.026]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:24.026]                     .init = FALSE)
[11:00:24.026]                 }
[11:00:24.026]             }
[11:00:24.026]         }
[11:00:24.026]     })
[11:00:24.026]     if (TRUE) {
[11:00:24.026]         base::sink(type = "output", split = FALSE)
[11:00:24.026]         if (TRUE) {
[11:00:24.026]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:24.026]         }
[11:00:24.026]         else {
[11:00:24.026]             ...future.result["stdout"] <- base::list(NULL)
[11:00:24.026]         }
[11:00:24.026]         base::close(...future.stdout)
[11:00:24.026]         ...future.stdout <- NULL
[11:00:24.026]     }
[11:00:24.026]     ...future.result$conditions <- ...future.conditions
[11:00:24.026]     ...future.result$finished <- base::Sys.time()
[11:00:24.026]     ...future.result
[11:00:24.026] }
[11:00:24.029] assign_globals() ...
[11:00:24.029] List of 5
[11:00:24.029]  $ ...future.FUN            :function (x)  
[11:00:24.029]  $ future.call.arguments    : list()
[11:00:24.029]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:24.029]  $ ...future.elements_ii    :List of 1
[11:00:24.029]   ..$ : int 1
[11:00:24.029]  $ ...future.seeds_ii       : NULL
[11:00:24.029]  $ ...future.globals.maxSize: NULL
[11:00:24.029]  - attr(*, "where")=List of 5
[11:00:24.029]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:24.029]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:24.029]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:24.029]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:24.029]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:24.029]  - attr(*, "resolved")= logi FALSE
[11:00:24.029]  - attr(*, "total_size")= num 5632
[11:00:24.029]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:24.029]  - attr(*, "already-done")= logi TRUE
[11:00:24.033] - reassign environment for ‘...future.FUN’
[11:00:24.033] - copied ‘...future.FUN’ to environment
[11:00:24.033] - copied ‘future.call.arguments’ to environment
[11:00:24.033] - copied ‘...future.elements_ii’ to environment
[11:00:24.033] - copied ‘...future.seeds_ii’ to environment
[11:00:24.034] - copied ‘...future.globals.maxSize’ to environment
[11:00:24.034] assign_globals() ... done
[11:00:24.034] requestCore(): workers = 2
[11:00:24.036] MulticoreFuture started
[11:00:24.036] - Launch lazy future ... done
[11:00:24.036] run() for ‘MulticoreFuture’ ... done
[11:00:24.037] Created future:
[11:00:24.037] plan(): Setting new future strategy stack:
[11:00:24.037] List of future strategies:
[11:00:24.037] 1. sequential:
[11:00:24.037]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:24.037]    - tweaked: FALSE
[11:00:24.037]    - call: NULL
[11:00:24.038] plan(): nbrOfWorkers() = 1
[11:00:24.037] MulticoreFuture:
[11:00:24.037] Label: ‘future_lapply-1’
[11:00:24.037] Expression:
[11:00:24.037] {
[11:00:24.037]     do.call(function(...) {
[11:00:24.037]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:24.037]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:24.037]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:24.037]             on.exit(options(oopts), add = TRUE)
[11:00:24.037]         }
[11:00:24.037]         {
[11:00:24.037]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:24.037]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:24.037]                 ...future.FUN(...future.X_jj, ...)
[11:00:24.037]             })
[11:00:24.037]         }
[11:00:24.037]     }, args = future.call.arguments)
[11:00:24.037] }
[11:00:24.037] Lazy evaluation: FALSE
[11:00:24.037] Asynchronous evaluation: TRUE
[11:00:24.037] Local evaluation: TRUE
[11:00:24.037] Environment: R_GlobalEnv
[11:00:24.037] Capture standard output: TRUE
[11:00:24.037] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:24.037] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:24.037] Packages: <none>
[11:00:24.037] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:24.037] Resolved: FALSE
[11:00:24.037] Value: <not collected>
[11:00:24.037] Conditions captured: <none>
[11:00:24.037] Early signaling: FALSE
[11:00:24.037] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:24.037] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:24.049] Chunk #1 of 2 ... DONE
[11:00:24.049] Chunk #2 of 2 ...
[11:00:24.050]  - Finding globals in 'X' for chunk #2 ...
[11:00:24.053] getGlobalsAndPackages() ...
[11:00:24.054] Searching for globals...
[11:00:24.055] 
[11:00:24.055] Searching for globals ... DONE
[11:00:24.055] - globals: [0] <none>
[11:00:24.056] getGlobalsAndPackages() ... DONE
[11:00:24.056]    + additional globals found: [n=0] 
[11:00:24.056]    + additional namespaces needed: [n=0] 
[11:00:24.057]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:24.057]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:24.057]  - seeds: <none>
[11:00:24.058]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:24.058] getGlobalsAndPackages() ...
[11:00:24.058] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:24.059] Resolving globals: FALSE
[11:00:24.059] Tweak future expression to call with '...' arguments ...
[11:00:24.059] {
[11:00:24.059]     do.call(function(...) {
[11:00:24.059]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:24.059]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:24.059]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:24.059]             on.exit(options(oopts), add = TRUE)
[11:00:24.059]         }
[11:00:24.059]         {
[11:00:24.059]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:24.059]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:24.059]                 ...future.FUN(...future.X_jj, ...)
[11:00:24.059]             })
[11:00:24.059]         }
[11:00:24.059]     }, args = future.call.arguments)
[11:00:24.059] }
[11:00:24.060] Tweak future expression to call with '...' arguments ... DONE
[11:00:24.061] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:24.061] 
[11:00:24.061] getGlobalsAndPackages() ... DONE
[11:00:24.062] run() for ‘Future’ ...
[11:00:24.062] - state: ‘created’
[11:00:24.062] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:24.065] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:24.065] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:24.065]   - Field: ‘label’
[11:00:24.065]   - Field: ‘local’
[11:00:24.065]   - Field: ‘owner’
[11:00:24.065]   - Field: ‘envir’
[11:00:24.066]   - Field: ‘workers’
[11:00:24.066]   - Field: ‘packages’
[11:00:24.066]   - Field: ‘gc’
[11:00:24.066]   - Field: ‘job’
[11:00:24.066]   - Field: ‘conditions’
[11:00:24.066]   - Field: ‘expr’
[11:00:24.066]   - Field: ‘uuid’
[11:00:24.066]   - Field: ‘seed’
[11:00:24.067]   - Field: ‘version’
[11:00:24.067]   - Field: ‘result’
[11:00:24.067]   - Field: ‘asynchronous’
[11:00:24.067]   - Field: ‘calls’
[11:00:24.067]   - Field: ‘globals’
[11:00:24.067]   - Field: ‘stdout’
[11:00:24.067]   - Field: ‘earlySignal’
[11:00:24.068]   - Field: ‘lazy’
[11:00:24.068]   - Field: ‘state’
[11:00:24.068] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:24.068] - Launch lazy future ...
[11:00:24.068] Packages needed by the future expression (n = 0): <none>
[11:00:24.068] Packages needed by future strategies (n = 0): <none>
[11:00:24.069] {
[11:00:24.069]     {
[11:00:24.069]         {
[11:00:24.069]             ...future.startTime <- base::Sys.time()
[11:00:24.069]             {
[11:00:24.069]                 {
[11:00:24.069]                   {
[11:00:24.069]                     {
[11:00:24.069]                       base::local({
[11:00:24.069]                         has_future <- base::requireNamespace("future", 
[11:00:24.069]                           quietly = TRUE)
[11:00:24.069]                         if (has_future) {
[11:00:24.069]                           ns <- base::getNamespace("future")
[11:00:24.069]                           version <- ns[[".package"]][["version"]]
[11:00:24.069]                           if (is.null(version)) 
[11:00:24.069]                             version <- utils::packageVersion("future")
[11:00:24.069]                         }
[11:00:24.069]                         else {
[11:00:24.069]                           version <- NULL
[11:00:24.069]                         }
[11:00:24.069]                         if (!has_future || version < "1.8.0") {
[11:00:24.069]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:24.069]                             "", base::R.version$version.string), 
[11:00:24.069]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:24.069]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:24.069]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:24.069]                               "release", "version")], collapse = " "), 
[11:00:24.069]                             hostname = base::Sys.info()[["nodename"]])
[11:00:24.069]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:24.069]                             info)
[11:00:24.069]                           info <- base::paste(info, collapse = "; ")
[11:00:24.069]                           if (!has_future) {
[11:00:24.069]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:24.069]                               info)
[11:00:24.069]                           }
[11:00:24.069]                           else {
[11:00:24.069]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:24.069]                               info, version)
[11:00:24.069]                           }
[11:00:24.069]                           base::stop(msg)
[11:00:24.069]                         }
[11:00:24.069]                       })
[11:00:24.069]                     }
[11:00:24.069]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:24.069]                     base::options(mc.cores = 1L)
[11:00:24.069]                   }
[11:00:24.069]                   ...future.strategy.old <- future::plan("list")
[11:00:24.069]                   options(future.plan = NULL)
[11:00:24.069]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:24.069]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:24.069]                 }
[11:00:24.069]                 ...future.workdir <- getwd()
[11:00:24.069]             }
[11:00:24.069]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:24.069]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:24.069]         }
[11:00:24.069]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:24.069]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:24.069]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:24.069]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:24.069]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:24.069]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:24.069]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:24.069]             base::names(...future.oldOptions))
[11:00:24.069]     }
[11:00:24.069]     if (FALSE) {
[11:00:24.069]     }
[11:00:24.069]     else {
[11:00:24.069]         if (TRUE) {
[11:00:24.069]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:24.069]                 open = "w")
[11:00:24.069]         }
[11:00:24.069]         else {
[11:00:24.069]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:24.069]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:24.069]         }
[11:00:24.069]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:24.069]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:24.069]             base::sink(type = "output", split = FALSE)
[11:00:24.069]             base::close(...future.stdout)
[11:00:24.069]         }, add = TRUE)
[11:00:24.069]     }
[11:00:24.069]     ...future.frame <- base::sys.nframe()
[11:00:24.069]     ...future.conditions <- base::list()
[11:00:24.069]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:24.069]     if (FALSE) {
[11:00:24.069]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:24.069]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:24.069]     }
[11:00:24.069]     ...future.result <- base::tryCatch({
[11:00:24.069]         base::withCallingHandlers({
[11:00:24.069]             ...future.value <- base::withVisible(base::local({
[11:00:24.069]                 withCallingHandlers({
[11:00:24.069]                   {
[11:00:24.069]                     do.call(function(...) {
[11:00:24.069]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:24.069]                       if (!identical(...future.globals.maxSize.org, 
[11:00:24.069]                         ...future.globals.maxSize)) {
[11:00:24.069]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:24.069]                         on.exit(options(oopts), add = TRUE)
[11:00:24.069]                       }
[11:00:24.069]                       {
[11:00:24.069]                         lapply(seq_along(...future.elements_ii), 
[11:00:24.069]                           FUN = function(jj) {
[11:00:24.069]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:24.069]                             ...future.FUN(...future.X_jj, ...)
[11:00:24.069]                           })
[11:00:24.069]                       }
[11:00:24.069]                     }, args = future.call.arguments)
[11:00:24.069]                   }
[11:00:24.069]                 }, immediateCondition = function(cond) {
[11:00:24.069]                   save_rds <- function (object, pathname, ...) 
[11:00:24.069]                   {
[11:00:24.069]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:24.069]                     if (file_test("-f", pathname_tmp)) {
[11:00:24.069]                       fi_tmp <- file.info(pathname_tmp)
[11:00:24.069]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:24.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:24.069]                         fi_tmp[["mtime"]])
[11:00:24.069]                     }
[11:00:24.069]                     tryCatch({
[11:00:24.069]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:24.069]                     }, error = function(ex) {
[11:00:24.069]                       msg <- conditionMessage(ex)
[11:00:24.069]                       fi_tmp <- file.info(pathname_tmp)
[11:00:24.069]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:24.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:24.069]                         fi_tmp[["mtime"]], msg)
[11:00:24.069]                       ex$message <- msg
[11:00:24.069]                       stop(ex)
[11:00:24.069]                     })
[11:00:24.069]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:24.069]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:24.069]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:24.069]                       fi_tmp <- file.info(pathname_tmp)
[11:00:24.069]                       fi <- file.info(pathname)
[11:00:24.069]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:24.069]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:24.069]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:24.069]                         fi[["size"]], fi[["mtime"]])
[11:00:24.069]                       stop(msg)
[11:00:24.069]                     }
[11:00:24.069]                     invisible(pathname)
[11:00:24.069]                   }
[11:00:24.069]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:24.069]                     rootPath = tempdir()) 
[11:00:24.069]                   {
[11:00:24.069]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:24.069]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:24.069]                       tmpdir = path, fileext = ".rds")
[11:00:24.069]                     save_rds(obj, file)
[11:00:24.069]                   }
[11:00:24.069]                   saveImmediateCondition(cond, path = "/tmp/RtmpuTAfww/.future/immediateConditions")
[11:00:24.069]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:24.069]                   {
[11:00:24.069]                     inherits <- base::inherits
[11:00:24.069]                     invokeRestart <- base::invokeRestart
[11:00:24.069]                     is.null <- base::is.null
[11:00:24.069]                     muffled <- FALSE
[11:00:24.069]                     if (inherits(cond, "message")) {
[11:00:24.069]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:24.069]                       if (muffled) 
[11:00:24.069]                         invokeRestart("muffleMessage")
[11:00:24.069]                     }
[11:00:24.069]                     else if (inherits(cond, "warning")) {
[11:00:24.069]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:24.069]                       if (muffled) 
[11:00:24.069]                         invokeRestart("muffleWarning")
[11:00:24.069]                     }
[11:00:24.069]                     else if (inherits(cond, "condition")) {
[11:00:24.069]                       if (!is.null(pattern)) {
[11:00:24.069]                         computeRestarts <- base::computeRestarts
[11:00:24.069]                         grepl <- base::grepl
[11:00:24.069]                         restarts <- computeRestarts(cond)
[11:00:24.069]                         for (restart in restarts) {
[11:00:24.069]                           name <- restart$name
[11:00:24.069]                           if (is.null(name)) 
[11:00:24.069]                             next
[11:00:24.069]                           if (!grepl(pattern, name)) 
[11:00:24.069]                             next
[11:00:24.069]                           invokeRestart(restart)
[11:00:24.069]                           muffled <- TRUE
[11:00:24.069]                           break
[11:00:24.069]                         }
[11:00:24.069]                       }
[11:00:24.069]                     }
[11:00:24.069]                     invisible(muffled)
[11:00:24.069]                   }
[11:00:24.069]                   muffleCondition(cond)
[11:00:24.069]                 })
[11:00:24.069]             }))
[11:00:24.069]             future::FutureResult(value = ...future.value$value, 
[11:00:24.069]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:24.069]                   ...future.rng), globalenv = if (FALSE) 
[11:00:24.069]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:24.069]                     ...future.globalenv.names))
[11:00:24.069]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:24.069]         }, condition = base::local({
[11:00:24.069]             c <- base::c
[11:00:24.069]             inherits <- base::inherits
[11:00:24.069]             invokeRestart <- base::invokeRestart
[11:00:24.069]             length <- base::length
[11:00:24.069]             list <- base::list
[11:00:24.069]             seq.int <- base::seq.int
[11:00:24.069]             signalCondition <- base::signalCondition
[11:00:24.069]             sys.calls <- base::sys.calls
[11:00:24.069]             `[[` <- base::`[[`
[11:00:24.069]             `+` <- base::`+`
[11:00:24.069]             `<<-` <- base::`<<-`
[11:00:24.069]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:24.069]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:24.069]                   3L)]
[11:00:24.069]             }
[11:00:24.069]             function(cond) {
[11:00:24.069]                 is_error <- inherits(cond, "error")
[11:00:24.069]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:24.069]                   NULL)
[11:00:24.069]                 if (is_error) {
[11:00:24.069]                   sessionInformation <- function() {
[11:00:24.069]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:24.069]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:24.069]                       search = base::search(), system = base::Sys.info())
[11:00:24.069]                   }
[11:00:24.069]                   ...future.conditions[[length(...future.conditions) + 
[11:00:24.069]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:24.069]                     cond$call), session = sessionInformation(), 
[11:00:24.069]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:24.069]                   signalCondition(cond)
[11:00:24.069]                 }
[11:00:24.069]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:24.069]                 "immediateCondition"))) {
[11:00:24.069]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:24.069]                   ...future.conditions[[length(...future.conditions) + 
[11:00:24.069]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:24.069]                   if (TRUE && !signal) {
[11:00:24.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:24.069]                     {
[11:00:24.069]                       inherits <- base::inherits
[11:00:24.069]                       invokeRestart <- base::invokeRestart
[11:00:24.069]                       is.null <- base::is.null
[11:00:24.069]                       muffled <- FALSE
[11:00:24.069]                       if (inherits(cond, "message")) {
[11:00:24.069]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:24.069]                         if (muffled) 
[11:00:24.069]                           invokeRestart("muffleMessage")
[11:00:24.069]                       }
[11:00:24.069]                       else if (inherits(cond, "warning")) {
[11:00:24.069]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:24.069]                         if (muffled) 
[11:00:24.069]                           invokeRestart("muffleWarning")
[11:00:24.069]                       }
[11:00:24.069]                       else if (inherits(cond, "condition")) {
[11:00:24.069]                         if (!is.null(pattern)) {
[11:00:24.069]                           computeRestarts <- base::computeRestarts
[11:00:24.069]                           grepl <- base::grepl
[11:00:24.069]                           restarts <- computeRestarts(cond)
[11:00:24.069]                           for (restart in restarts) {
[11:00:24.069]                             name <- restart$name
[11:00:24.069]                             if (is.null(name)) 
[11:00:24.069]                               next
[11:00:24.069]                             if (!grepl(pattern, name)) 
[11:00:24.069]                               next
[11:00:24.069]                             invokeRestart(restart)
[11:00:24.069]                             muffled <- TRUE
[11:00:24.069]                             break
[11:00:24.069]                           }
[11:00:24.069]                         }
[11:00:24.069]                       }
[11:00:24.069]                       invisible(muffled)
[11:00:24.069]                     }
[11:00:24.069]                     muffleCondition(cond, pattern = "^muffle")
[11:00:24.069]                   }
[11:00:24.069]                 }
[11:00:24.069]                 else {
[11:00:24.069]                   if (TRUE) {
[11:00:24.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:24.069]                     {
[11:00:24.069]                       inherits <- base::inherits
[11:00:24.069]                       invokeRestart <- base::invokeRestart
[11:00:24.069]                       is.null <- base::is.null
[11:00:24.069]                       muffled <- FALSE
[11:00:24.069]                       if (inherits(cond, "message")) {
[11:00:24.069]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:24.069]                         if (muffled) 
[11:00:24.069]                           invokeRestart("muffleMessage")
[11:00:24.069]                       }
[11:00:24.069]                       else if (inherits(cond, "warning")) {
[11:00:24.069]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:24.069]                         if (muffled) 
[11:00:24.069]                           invokeRestart("muffleWarning")
[11:00:24.069]                       }
[11:00:24.069]                       else if (inherits(cond, "condition")) {
[11:00:24.069]                         if (!is.null(pattern)) {
[11:00:24.069]                           computeRestarts <- base::computeRestarts
[11:00:24.069]                           grepl <- base::grepl
[11:00:24.069]                           restarts <- computeRestarts(cond)
[11:00:24.069]                           for (restart in restarts) {
[11:00:24.069]                             name <- restart$name
[11:00:24.069]                             if (is.null(name)) 
[11:00:24.069]                               next
[11:00:24.069]                             if (!grepl(pattern, name)) 
[11:00:24.069]                               next
[11:00:24.069]                             invokeRestart(restart)
[11:00:24.069]                             muffled <- TRUE
[11:00:24.069]                             break
[11:00:24.069]                           }
[11:00:24.069]                         }
[11:00:24.069]                       }
[11:00:24.069]                       invisible(muffled)
[11:00:24.069]                     }
[11:00:24.069]                     muffleCondition(cond, pattern = "^muffle")
[11:00:24.069]                   }
[11:00:24.069]                 }
[11:00:24.069]             }
[11:00:24.069]         }))
[11:00:24.069]     }, error = function(ex) {
[11:00:24.069]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:24.069]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:24.069]                 ...future.rng), started = ...future.startTime, 
[11:00:24.069]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:24.069]             version = "1.8"), class = "FutureResult")
[11:00:24.069]     }, finally = {
[11:00:24.069]         if (!identical(...future.workdir, getwd())) 
[11:00:24.069]             setwd(...future.workdir)
[11:00:24.069]         {
[11:00:24.069]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:24.069]                 ...future.oldOptions$nwarnings <- NULL
[11:00:24.069]             }
[11:00:24.069]             base::options(...future.oldOptions)
[11:00:24.069]             if (.Platform$OS.type == "windows") {
[11:00:24.069]                 old_names <- names(...future.oldEnvVars)
[11:00:24.069]                 envs <- base::Sys.getenv()
[11:00:24.069]                 names <- names(envs)
[11:00:24.069]                 common <- intersect(names, old_names)
[11:00:24.069]                 added <- setdiff(names, old_names)
[11:00:24.069]                 removed <- setdiff(old_names, names)
[11:00:24.069]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:24.069]                   envs[common]]
[11:00:24.069]                 NAMES <- toupper(changed)
[11:00:24.069]                 args <- list()
[11:00:24.069]                 for (kk in seq_along(NAMES)) {
[11:00:24.069]                   name <- changed[[kk]]
[11:00:24.069]                   NAME <- NAMES[[kk]]
[11:00:24.069]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:24.069]                     next
[11:00:24.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:24.069]                 }
[11:00:24.069]                 NAMES <- toupper(added)
[11:00:24.069]                 for (kk in seq_along(NAMES)) {
[11:00:24.069]                   name <- added[[kk]]
[11:00:24.069]                   NAME <- NAMES[[kk]]
[11:00:24.069]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:24.069]                     next
[11:00:24.069]                   args[[name]] <- ""
[11:00:24.069]                 }
[11:00:24.069]                 NAMES <- toupper(removed)
[11:00:24.069]                 for (kk in seq_along(NAMES)) {
[11:00:24.069]                   name <- removed[[kk]]
[11:00:24.069]                   NAME <- NAMES[[kk]]
[11:00:24.069]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:24.069]                     next
[11:00:24.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:24.069]                 }
[11:00:24.069]                 if (length(args) > 0) 
[11:00:24.069]                   base::do.call(base::Sys.setenv, args = args)
[11:00:24.069]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:24.069]             }
[11:00:24.069]             else {
[11:00:24.069]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:24.069]             }
[11:00:24.069]             {
[11:00:24.069]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:24.069]                   0L) {
[11:00:24.069]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:24.069]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:24.069]                   base::options(opts)
[11:00:24.069]                 }
[11:00:24.069]                 {
[11:00:24.069]                   {
[11:00:24.069]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:24.069]                     NULL
[11:00:24.069]                   }
[11:00:24.069]                   options(future.plan = NULL)
[11:00:24.069]                   if (is.na(NA_character_)) 
[11:00:24.069]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:24.069]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:24.069]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:24.069]                     .init = FALSE)
[11:00:24.069]                 }
[11:00:24.069]             }
[11:00:24.069]         }
[11:00:24.069]     })
[11:00:24.069]     if (TRUE) {
[11:00:24.069]         base::sink(type = "output", split = FALSE)
[11:00:24.069]         if (TRUE) {
[11:00:24.069]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:24.069]         }
[11:00:24.069]         else {
[11:00:24.069]             ...future.result["stdout"] <- base::list(NULL)
[11:00:24.069]         }
[11:00:24.069]         base::close(...future.stdout)
[11:00:24.069]         ...future.stdout <- NULL
[11:00:24.069]     }
[11:00:24.069]     ...future.result$conditions <- ...future.conditions
[11:00:24.069]     ...future.result$finished <- base::Sys.time()
[11:00:24.069]     ...future.result
[11:00:24.069] }
[11:00:24.072] assign_globals() ...
[11:00:24.072] List of 5
[11:00:24.072]  $ ...future.FUN            :function (x)  
[11:00:24.072]  $ future.call.arguments    : list()
[11:00:24.072]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:24.072]  $ ...future.elements_ii    :List of 1
[11:00:24.072]   ..$ : int 0
[11:00:24.072]  $ ...future.seeds_ii       : NULL
[11:00:24.072]  $ ...future.globals.maxSize: NULL
[11:00:24.072]  - attr(*, "where")=List of 5
[11:00:24.072]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:24.072]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:24.072]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:24.072]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:24.072]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:24.072]  - attr(*, "resolved")= logi FALSE
[11:00:24.072]  - attr(*, "total_size")= num 5632
[11:00:24.072]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:24.072]  - attr(*, "already-done")= logi TRUE
[11:00:24.078] - reassign environment for ‘...future.FUN’
[11:00:24.078] - copied ‘...future.FUN’ to environment
[11:00:24.078] - copied ‘future.call.arguments’ to environment
[11:00:24.078] - copied ‘...future.elements_ii’ to environment
[11:00:24.079] - copied ‘...future.seeds_ii’ to environment
[11:00:24.079] - copied ‘...future.globals.maxSize’ to environment
[11:00:24.079] assign_globals() ... done
[11:00:24.079] requestCore(): workers = 2
[11:00:24.081] MulticoreFuture started
[11:00:24.082] - Launch lazy future ... done
[11:00:24.082] run() for ‘MulticoreFuture’ ... done
[11:00:24.082] Created future:
[11:00:24.082] plan(): Setting new future strategy stack:
[11:00:24.082] List of future strategies:
[11:00:24.082] 1. sequential:
[11:00:24.082]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:24.082]    - tweaked: FALSE
[11:00:24.082]    - call: NULL
[11:00:24.083] plan(): nbrOfWorkers() = 1
[11:00:24.085] plan(): Setting new future strategy stack:
[11:00:24.085] List of future strategies:
[11:00:24.085] 1. multicore:
[11:00:24.085]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:24.085]    - tweaked: FALSE
[11:00:24.085]    - call: plan(strategy)
[11:00:24.089] plan(): nbrOfWorkers() = 2
[11:00:24.082] MulticoreFuture:
[11:00:24.082] Label: ‘future_lapply-2’
[11:00:24.082] Expression:
[11:00:24.082] {
[11:00:24.082]     do.call(function(...) {
[11:00:24.082]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:24.082]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:24.082]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:24.082]             on.exit(options(oopts), add = TRUE)
[11:00:24.082]         }
[11:00:24.082]         {
[11:00:24.082]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:24.082]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:24.082]                 ...future.FUN(...future.X_jj, ...)
[11:00:24.082]             })
[11:00:24.082]         }
[11:00:24.082]     }, args = future.call.arguments)
[11:00:24.082] }
[11:00:24.082] Lazy evaluation: FALSE
[11:00:24.082] Asynchronous evaluation: TRUE
[11:00:24.082] Local evaluation: TRUE
[11:00:24.082] Environment: R_GlobalEnv
[11:00:24.082] Capture standard output: TRUE
[11:00:24.082] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:24.082] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:24.082] Packages: <none>
[11:00:24.082] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:24.082] Resolved: TRUE
[11:00:24.082] Value: <not collected>
[11:00:24.082] Conditions captured: <none>
[11:00:24.082] Early signaling: FALSE
[11:00:24.082] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:24.082] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:24.090] Chunk #2 of 2 ... DONE
[11:00:24.090] Launching 2 futures (chunks) ... DONE
[11:00:24.090] Resolving 2 futures (chunks) ...
[11:00:24.090] resolve() on list ...
[11:00:24.090]  recursive: 0
[11:00:24.090]  length: 2
[11:00:24.091] 
[11:00:24.101] Future #2
[11:00:24.101] result() for MulticoreFuture ...
[11:00:24.102] result() for MulticoreFuture ...
[11:00:24.103] result() for MulticoreFuture ... done
[11:00:24.103] result() for MulticoreFuture ... done
[11:00:24.103] result() for MulticoreFuture ...
[11:00:24.103] result() for MulticoreFuture ... done
[11:00:24.103] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:00:24.103] - nx: 2
[11:00:24.103] - relay: TRUE
[11:00:24.104] - stdout: TRUE
[11:00:24.104] - signal: TRUE
[11:00:24.104] - resignal: FALSE
[11:00:24.104] - force: TRUE
[11:00:24.104] - relayed: [n=2] FALSE, FALSE
[11:00:24.104] - queued futures: [n=2] FALSE, FALSE
[11:00:24.104]  - until=1
[11:00:24.104]  - relaying element #1
[11:00:24.105] - relayed: [n=2] FALSE, FALSE
[11:00:24.105] - queued futures: [n=2] FALSE, TRUE
[11:00:24.105] signalConditionsASAP(NULL, pos=2) ... done
[11:00:24.105]  length: 1 (resolved future 2)
[11:00:24.541] plan(): Setting new future strategy stack:
[11:00:24.541] List of future strategies:
[11:00:24.541] 1. multicore:
[11:00:24.541]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:24.541]    - tweaked: FALSE
[11:00:24.541]    - call: plan(strategy)
[11:00:24.547] plan(): nbrOfWorkers() = 2
[11:00:24.547] Future #1
[11:00:24.548] result() for MulticoreFuture ...
[11:00:24.549] result() for MulticoreFuture ...
[11:00:24.549] result() for MulticoreFuture ... done
[11:00:24.549] result() for MulticoreFuture ... done
[11:00:24.549] result() for MulticoreFuture ...
[11:00:24.549] result() for MulticoreFuture ... done
[11:00:24.549] signalConditionsASAP(MulticoreFuture, pos=1) ...
[11:00:24.549] - nx: 2
[11:00:24.549] - relay: TRUE
[11:00:24.549] - stdout: TRUE
[11:00:24.550] - signal: TRUE
[11:00:24.550] - resignal: FALSE
[11:00:24.550] - force: TRUE
[11:00:24.550] - relayed: [n=2] FALSE, FALSE
[11:00:24.550] - queued futures: [n=2] FALSE, TRUE
[11:00:24.550]  - until=1
[11:00:24.552]  - relaying element #1
[11:00:24.553] result() for MulticoreFuture ...
[11:00:24.553] result() for MulticoreFuture ... done
[11:00:24.553] result() for MulticoreFuture ...
[11:00:24.553] result() for MulticoreFuture ... done
[11:00:24.553] result() for MulticoreFuture ...
[11:00:24.554] result() for MulticoreFuture ... done
[11:00:24.554] result() for MulticoreFuture ...
[11:00:24.554] result() for MulticoreFuture ... done
[11:00:24.554] - relayed: [n=2] TRUE, FALSE
[11:00:24.554] - queued futures: [n=2] TRUE, TRUE
[11:00:24.554] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[11:00:24.555]  length: 0 (resolved future 1)
[11:00:24.555] Relaying remaining futures
[11:00:24.555] signalConditionsASAP(NULL, pos=0) ...
[11:00:24.555] - nx: 2
[11:00:24.555] - relay: TRUE
[11:00:24.555] - stdout: TRUE
[11:00:24.555] - signal: TRUE
[11:00:24.556] - resignal: FALSE
[11:00:24.556] - force: TRUE
[11:00:24.556] - relayed: [n=2] TRUE, FALSE
[11:00:24.556] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:24.556]  - relaying element #2
[11:00:24.556] result() for MulticoreFuture ...
[11:00:24.556] result() for MulticoreFuture ... done
[11:00:24.556] result() for MulticoreFuture ...
[11:00:24.557] result() for MulticoreFuture ... done
[11:00:24.557] result() for MulticoreFuture ...
[11:00:24.557] result() for MulticoreFuture ... done
[11:00:24.557] result() for MulticoreFuture ...
[11:00:24.557] result() for MulticoreFuture ... done
[11:00:24.557] - relayed: [n=2] TRUE, TRUE
[11:00:24.557] - queued futures: [n=2] TRUE, TRUE
[11:00:24.557] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[11:00:24.557] resolve() on list ... DONE
[11:00:24.558] result() for MulticoreFuture ...
[11:00:24.558] result() for MulticoreFuture ... done
[11:00:24.558] result() for MulticoreFuture ...
[11:00:24.558] result() for MulticoreFuture ... done
[11:00:24.558] result() for MulticoreFuture ...
[11:00:24.558] result() for MulticoreFuture ... done
[11:00:24.558] result() for MulticoreFuture ...
[11:00:24.558] result() for MulticoreFuture ... done
[11:00:24.559]  - Number of value chunks collected: 2
[11:00:24.559] Resolving 2 futures (chunks) ... DONE
[11:00:24.559] Reducing values from 2 chunks ...
[11:00:24.559]  - Number of values collected after concatenation: 2
[11:00:24.559]  - Number of values expected: 2
[11:00:24.559] Reducing values from 2 chunks ... DONE
[11:00:24.559] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[11:00:24.560] future_lapply() ...
[11:00:24.562] Number of chunks: 2
[11:00:24.562] getGlobalsAndPackagesXApply() ...
[11:00:24.562]  - future.globals: TRUE
[11:00:24.563] getGlobalsAndPackages() ...
[11:00:24.563] Searching for globals...
[11:00:24.564] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[11:00:24.564] Searching for globals ... DONE
[11:00:24.565] Resolving globals: FALSE
[11:00:24.565] The total size of the 1 globals is 841 bytes (841 bytes)
[11:00:24.565] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[11:00:24.565] - globals: [1] ‘FUN’
[11:00:24.566] 
[11:00:24.566] getGlobalsAndPackages() ... DONE
[11:00:24.566]  - globals found/used: [n=1] ‘FUN’
[11:00:24.566]  - needed namespaces: [n=0] 
[11:00:24.566] Finding globals ... DONE
[11:00:24.566]  - use_args: TRUE
[11:00:24.566]  - Getting '...' globals ...
[11:00:24.567] resolve() on list ...
[11:00:24.567]  recursive: 0
[11:00:24.567]  length: 1
[11:00:24.567]  elements: ‘...’
[11:00:24.567]  length: 0 (resolved future 1)
[11:00:24.567] resolve() on list ... DONE
[11:00:24.567]    - '...' content: [n=0] 
[11:00:24.567] List of 1
[11:00:24.567]  $ ...: list()
[11:00:24.567]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:24.567]  - attr(*, "where")=List of 1
[11:00:24.567]   ..$ ...:<environment: 0x55ceb2012e70> 
[11:00:24.567]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:24.567]  - attr(*, "resolved")= logi TRUE
[11:00:24.567]  - attr(*, "total_size")= num NA
[11:00:24.570]  - Getting '...' globals ... DONE
[11:00:24.570] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[11:00:24.570] List of 2
[11:00:24.570]  $ ...future.FUN:function (x)  
[11:00:24.570]  $ ...          : list()
[11:00:24.570]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:24.570]  - attr(*, "where")=List of 2
[11:00:24.570]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:24.570]   ..$ ...          :<environment: 0x55ceb2012e70> 
[11:00:24.570]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:24.570]  - attr(*, "resolved")= logi FALSE
[11:00:24.570]  - attr(*, "total_size")= num 5632
[11:00:24.573] Packages to be attached in all futures: [n=0] 
[11:00:24.573] getGlobalsAndPackagesXApply() ... DONE
[11:00:24.573] Number of futures (= number of chunks): 2
[11:00:24.574] Launching 2 futures (chunks) ...
[11:00:24.574] Chunk #1 of 2 ...
[11:00:24.574]  - Finding globals in 'X' for chunk #1 ...
[11:00:24.574] getGlobalsAndPackages() ...
[11:00:24.574] Searching for globals...
[11:00:24.574] 
[11:00:24.574] Searching for globals ... DONE
[11:00:24.574] - globals: [0] <none>
[11:00:24.574] getGlobalsAndPackages() ... DONE
[11:00:24.575]    + additional globals found: [n=0] 
[11:00:24.575]    + additional namespaces needed: [n=0] 
[11:00:24.575]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:24.575]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:24.575]  - seeds: <none>
[11:00:24.575]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:24.575] getGlobalsAndPackages() ...
[11:00:24.575] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:24.575] Resolving globals: FALSE
[11:00:24.575] Tweak future expression to call with '...' arguments ...
[11:00:24.576] {
[11:00:24.576]     do.call(function(...) {
[11:00:24.576]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:24.576]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:24.576]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:24.576]             on.exit(options(oopts), add = TRUE)
[11:00:24.576]         }
[11:00:24.576]         {
[11:00:24.576]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:24.576]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:24.576]                 ...future.FUN(...future.X_jj, ...)
[11:00:24.576]             })
[11:00:24.576]         }
[11:00:24.576]     }, args = future.call.arguments)
[11:00:24.576] }
[11:00:24.576] Tweak future expression to call with '...' arguments ... DONE
[11:00:24.576] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:24.576] 
[11:00:24.576] getGlobalsAndPackages() ... DONE
[11:00:24.577] run() for ‘Future’ ...
[11:00:24.577] - state: ‘created’
[11:00:24.577] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:24.579] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:24.580] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:24.580]   - Field: ‘label’
[11:00:24.580]   - Field: ‘local’
[11:00:24.580]   - Field: ‘owner’
[11:00:24.580]   - Field: ‘envir’
[11:00:24.580]   - Field: ‘workers’
[11:00:24.580]   - Field: ‘packages’
[11:00:24.580]   - Field: ‘gc’
[11:00:24.580]   - Field: ‘job’
[11:00:24.580]   - Field: ‘conditions’
[11:00:24.581]   - Field: ‘expr’
[11:00:24.581]   - Field: ‘uuid’
[11:00:24.581]   - Field: ‘seed’
[11:00:24.581]   - Field: ‘version’
[11:00:24.581]   - Field: ‘result’
[11:00:24.581]   - Field: ‘asynchronous’
[11:00:24.581]   - Field: ‘calls’
[11:00:24.581]   - Field: ‘globals’
[11:00:24.581]   - Field: ‘stdout’
[11:00:24.581]   - Field: ‘earlySignal’
[11:00:24.581]   - Field: ‘lazy’
[11:00:24.581]   - Field: ‘state’
[11:00:24.581] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:24.582] - Launch lazy future ...
[11:00:24.582] Packages needed by the future expression (n = 0): <none>
[11:00:24.582] Packages needed by future strategies (n = 0): <none>
[11:00:24.582] {
[11:00:24.582]     {
[11:00:24.582]         {
[11:00:24.582]             ...future.startTime <- base::Sys.time()
[11:00:24.582]             {
[11:00:24.582]                 {
[11:00:24.582]                   {
[11:00:24.582]                     {
[11:00:24.582]                       base::local({
[11:00:24.582]                         has_future <- base::requireNamespace("future", 
[11:00:24.582]                           quietly = TRUE)
[11:00:24.582]                         if (has_future) {
[11:00:24.582]                           ns <- base::getNamespace("future")
[11:00:24.582]                           version <- ns[[".package"]][["version"]]
[11:00:24.582]                           if (is.null(version)) 
[11:00:24.582]                             version <- utils::packageVersion("future")
[11:00:24.582]                         }
[11:00:24.582]                         else {
[11:00:24.582]                           version <- NULL
[11:00:24.582]                         }
[11:00:24.582]                         if (!has_future || version < "1.8.0") {
[11:00:24.582]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:24.582]                             "", base::R.version$version.string), 
[11:00:24.582]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:24.582]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:24.582]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:24.582]                               "release", "version")], collapse = " "), 
[11:00:24.582]                             hostname = base::Sys.info()[["nodename"]])
[11:00:24.582]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:24.582]                             info)
[11:00:24.582]                           info <- base::paste(info, collapse = "; ")
[11:00:24.582]                           if (!has_future) {
[11:00:24.582]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:24.582]                               info)
[11:00:24.582]                           }
[11:00:24.582]                           else {
[11:00:24.582]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:24.582]                               info, version)
[11:00:24.582]                           }
[11:00:24.582]                           base::stop(msg)
[11:00:24.582]                         }
[11:00:24.582]                       })
[11:00:24.582]                     }
[11:00:24.582]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:24.582]                     base::options(mc.cores = 1L)
[11:00:24.582]                   }
[11:00:24.582]                   ...future.strategy.old <- future::plan("list")
[11:00:24.582]                   options(future.plan = NULL)
[11:00:24.582]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:24.582]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:24.582]                 }
[11:00:24.582]                 ...future.workdir <- getwd()
[11:00:24.582]             }
[11:00:24.582]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:24.582]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:24.582]         }
[11:00:24.582]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:24.582]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:24.582]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:24.582]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:24.582]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:24.582]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:24.582]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:24.582]             base::names(...future.oldOptions))
[11:00:24.582]     }
[11:00:24.582]     if (TRUE) {
[11:00:24.582]     }
[11:00:24.582]     else {
[11:00:24.582]         if (NA) {
[11:00:24.582]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:24.582]                 open = "w")
[11:00:24.582]         }
[11:00:24.582]         else {
[11:00:24.582]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:24.582]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:24.582]         }
[11:00:24.582]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:24.582]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:24.582]             base::sink(type = "output", split = FALSE)
[11:00:24.582]             base::close(...future.stdout)
[11:00:24.582]         }, add = TRUE)
[11:00:24.582]     }
[11:00:24.582]     ...future.frame <- base::sys.nframe()
[11:00:24.582]     ...future.conditions <- base::list()
[11:00:24.582]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:24.582]     if (FALSE) {
[11:00:24.582]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:24.582]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:24.582]     }
[11:00:24.582]     ...future.result <- base::tryCatch({
[11:00:24.582]         base::withCallingHandlers({
[11:00:24.582]             ...future.value <- base::withVisible(base::local({
[11:00:24.582]                 withCallingHandlers({
[11:00:24.582]                   {
[11:00:24.582]                     do.call(function(...) {
[11:00:24.582]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:24.582]                       if (!identical(...future.globals.maxSize.org, 
[11:00:24.582]                         ...future.globals.maxSize)) {
[11:00:24.582]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:24.582]                         on.exit(options(oopts), add = TRUE)
[11:00:24.582]                       }
[11:00:24.582]                       {
[11:00:24.582]                         lapply(seq_along(...future.elements_ii), 
[11:00:24.582]                           FUN = function(jj) {
[11:00:24.582]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:24.582]                             ...future.FUN(...future.X_jj, ...)
[11:00:24.582]                           })
[11:00:24.582]                       }
[11:00:24.582]                     }, args = future.call.arguments)
[11:00:24.582]                   }
[11:00:24.582]                 }, immediateCondition = function(cond) {
[11:00:24.582]                   save_rds <- function (object, pathname, ...) 
[11:00:24.582]                   {
[11:00:24.582]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:24.582]                     if (file_test("-f", pathname_tmp)) {
[11:00:24.582]                       fi_tmp <- file.info(pathname_tmp)
[11:00:24.582]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:24.582]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:24.582]                         fi_tmp[["mtime"]])
[11:00:24.582]                     }
[11:00:24.582]                     tryCatch({
[11:00:24.582]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:24.582]                     }, error = function(ex) {
[11:00:24.582]                       msg <- conditionMessage(ex)
[11:00:24.582]                       fi_tmp <- file.info(pathname_tmp)
[11:00:24.582]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:24.582]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:24.582]                         fi_tmp[["mtime"]], msg)
[11:00:24.582]                       ex$message <- msg
[11:00:24.582]                       stop(ex)
[11:00:24.582]                     })
[11:00:24.582]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:24.582]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:24.582]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:24.582]                       fi_tmp <- file.info(pathname_tmp)
[11:00:24.582]                       fi <- file.info(pathname)
[11:00:24.582]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:24.582]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:24.582]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:24.582]                         fi[["size"]], fi[["mtime"]])
[11:00:24.582]                       stop(msg)
[11:00:24.582]                     }
[11:00:24.582]                     invisible(pathname)
[11:00:24.582]                   }
[11:00:24.582]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:24.582]                     rootPath = tempdir()) 
[11:00:24.582]                   {
[11:00:24.582]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:24.582]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:24.582]                       tmpdir = path, fileext = ".rds")
[11:00:24.582]                     save_rds(obj, file)
[11:00:24.582]                   }
[11:00:24.582]                   saveImmediateCondition(cond, path = "/tmp/RtmpuTAfww/.future/immediateConditions")
[11:00:24.582]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:24.582]                   {
[11:00:24.582]                     inherits <- base::inherits
[11:00:24.582]                     invokeRestart <- base::invokeRestart
[11:00:24.582]                     is.null <- base::is.null
[11:00:24.582]                     muffled <- FALSE
[11:00:24.582]                     if (inherits(cond, "message")) {
[11:00:24.582]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:24.582]                       if (muffled) 
[11:00:24.582]                         invokeRestart("muffleMessage")
[11:00:24.582]                     }
[11:00:24.582]                     else if (inherits(cond, "warning")) {
[11:00:24.582]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:24.582]                       if (muffled) 
[11:00:24.582]                         invokeRestart("muffleWarning")
[11:00:24.582]                     }
[11:00:24.582]                     else if (inherits(cond, "condition")) {
[11:00:24.582]                       if (!is.null(pattern)) {
[11:00:24.582]                         computeRestarts <- base::computeRestarts
[11:00:24.582]                         grepl <- base::grepl
[11:00:24.582]                         restarts <- computeRestarts(cond)
[11:00:24.582]                         for (restart in restarts) {
[11:00:24.582]                           name <- restart$name
[11:00:24.582]                           if (is.null(name)) 
[11:00:24.582]                             next
[11:00:24.582]                           if (!grepl(pattern, name)) 
[11:00:24.582]                             next
[11:00:24.582]                           invokeRestart(restart)
[11:00:24.582]                           muffled <- TRUE
[11:00:24.582]                           break
[11:00:24.582]                         }
[11:00:24.582]                       }
[11:00:24.582]                     }
[11:00:24.582]                     invisible(muffled)
[11:00:24.582]                   }
[11:00:24.582]                   muffleCondition(cond)
[11:00:24.582]                 })
[11:00:24.582]             }))
[11:00:24.582]             future::FutureResult(value = ...future.value$value, 
[11:00:24.582]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:24.582]                   ...future.rng), globalenv = if (FALSE) 
[11:00:24.582]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:24.582]                     ...future.globalenv.names))
[11:00:24.582]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:24.582]         }, condition = base::local({
[11:00:24.582]             c <- base::c
[11:00:24.582]             inherits <- base::inherits
[11:00:24.582]             invokeRestart <- base::invokeRestart
[11:00:24.582]             length <- base::length
[11:00:24.582]             list <- base::list
[11:00:24.582]             seq.int <- base::seq.int
[11:00:24.582]             signalCondition <- base::signalCondition
[11:00:24.582]             sys.calls <- base::sys.calls
[11:00:24.582]             `[[` <- base::`[[`
[11:00:24.582]             `+` <- base::`+`
[11:00:24.582]             `<<-` <- base::`<<-`
[11:00:24.582]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:24.582]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:24.582]                   3L)]
[11:00:24.582]             }
[11:00:24.582]             function(cond) {
[11:00:24.582]                 is_error <- inherits(cond, "error")
[11:00:24.582]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:24.582]                   NULL)
[11:00:24.582]                 if (is_error) {
[11:00:24.582]                   sessionInformation <- function() {
[11:00:24.582]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:24.582]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:24.582]                       search = base::search(), system = base::Sys.info())
[11:00:24.582]                   }
[11:00:24.582]                   ...future.conditions[[length(...future.conditions) + 
[11:00:24.582]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:24.582]                     cond$call), session = sessionInformation(), 
[11:00:24.582]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:24.582]                   signalCondition(cond)
[11:00:24.582]                 }
[11:00:24.582]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:24.582]                 "immediateCondition"))) {
[11:00:24.582]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:24.582]                   ...future.conditions[[length(...future.conditions) + 
[11:00:24.582]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:24.582]                   if (TRUE && !signal) {
[11:00:24.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:24.582]                     {
[11:00:24.582]                       inherits <- base::inherits
[11:00:24.582]                       invokeRestart <- base::invokeRestart
[11:00:24.582]                       is.null <- base::is.null
[11:00:24.582]                       muffled <- FALSE
[11:00:24.582]                       if (inherits(cond, "message")) {
[11:00:24.582]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:24.582]                         if (muffled) 
[11:00:24.582]                           invokeRestart("muffleMessage")
[11:00:24.582]                       }
[11:00:24.582]                       else if (inherits(cond, "warning")) {
[11:00:24.582]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:24.582]                         if (muffled) 
[11:00:24.582]                           invokeRestart("muffleWarning")
[11:00:24.582]                       }
[11:00:24.582]                       else if (inherits(cond, "condition")) {
[11:00:24.582]                         if (!is.null(pattern)) {
[11:00:24.582]                           computeRestarts <- base::computeRestarts
[11:00:24.582]                           grepl <- base::grepl
[11:00:24.582]                           restarts <- computeRestarts(cond)
[11:00:24.582]                           for (restart in restarts) {
[11:00:24.582]                             name <- restart$name
[11:00:24.582]                             if (is.null(name)) 
[11:00:24.582]                               next
[11:00:24.582]                             if (!grepl(pattern, name)) 
[11:00:24.582]                               next
[11:00:24.582]                             invokeRestart(restart)
[11:00:24.582]                             muffled <- TRUE
[11:00:24.582]                             break
[11:00:24.582]                           }
[11:00:24.582]                         }
[11:00:24.582]                       }
[11:00:24.582]                       invisible(muffled)
[11:00:24.582]                     }
[11:00:24.582]                     muffleCondition(cond, pattern = "^muffle")
[11:00:24.582]                   }
[11:00:24.582]                 }
[11:00:24.582]                 else {
[11:00:24.582]                   if (TRUE) {
[11:00:24.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:24.582]                     {
[11:00:24.582]                       inherits <- base::inherits
[11:00:24.582]                       invokeRestart <- base::invokeRestart
[11:00:24.582]                       is.null <- base::is.null
[11:00:24.582]                       muffled <- FALSE
[11:00:24.582]                       if (inherits(cond, "message")) {
[11:00:24.582]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:24.582]                         if (muffled) 
[11:00:24.582]                           invokeRestart("muffleMessage")
[11:00:24.582]                       }
[11:00:24.582]                       else if (inherits(cond, "warning")) {
[11:00:24.582]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:24.582]                         if (muffled) 
[11:00:24.582]                           invokeRestart("muffleWarning")
[11:00:24.582]                       }
[11:00:24.582]                       else if (inherits(cond, "condition")) {
[11:00:24.582]                         if (!is.null(pattern)) {
[11:00:24.582]                           computeRestarts <- base::computeRestarts
[11:00:24.582]                           grepl <- base::grepl
[11:00:24.582]                           restarts <- computeRestarts(cond)
[11:00:24.582]                           for (restart in restarts) {
[11:00:24.582]                             name <- restart$name
[11:00:24.582]                             if (is.null(name)) 
[11:00:24.582]                               next
[11:00:24.582]                             if (!grepl(pattern, name)) 
[11:00:24.582]                               next
[11:00:24.582]                             invokeRestart(restart)
[11:00:24.582]                             muffled <- TRUE
[11:00:24.582]                             break
[11:00:24.582]                           }
[11:00:24.582]                         }
[11:00:24.582]                       }
[11:00:24.582]                       invisible(muffled)
[11:00:24.582]                     }
[11:00:24.582]                     muffleCondition(cond, pattern = "^muffle")
[11:00:24.582]                   }
[11:00:24.582]                 }
[11:00:24.582]             }
[11:00:24.582]         }))
[11:00:24.582]     }, error = function(ex) {
[11:00:24.582]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:24.582]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:24.582]                 ...future.rng), started = ...future.startTime, 
[11:00:24.582]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:24.582]             version = "1.8"), class = "FutureResult")
[11:00:24.582]     }, finally = {
[11:00:24.582]         if (!identical(...future.workdir, getwd())) 
[11:00:24.582]             setwd(...future.workdir)
[11:00:24.582]         {
[11:00:24.582]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:24.582]                 ...future.oldOptions$nwarnings <- NULL
[11:00:24.582]             }
[11:00:24.582]             base::options(...future.oldOptions)
[11:00:24.582]             if (.Platform$OS.type == "windows") {
[11:00:24.582]                 old_names <- names(...future.oldEnvVars)
[11:00:24.582]                 envs <- base::Sys.getenv()
[11:00:24.582]                 names <- names(envs)
[11:00:24.582]                 common <- intersect(names, old_names)
[11:00:24.582]                 added <- setdiff(names, old_names)
[11:00:24.582]                 removed <- setdiff(old_names, names)
[11:00:24.582]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:24.582]                   envs[common]]
[11:00:24.582]                 NAMES <- toupper(changed)
[11:00:24.582]                 args <- list()
[11:00:24.582]                 for (kk in seq_along(NAMES)) {
[11:00:24.582]                   name <- changed[[kk]]
[11:00:24.582]                   NAME <- NAMES[[kk]]
[11:00:24.582]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:24.582]                     next
[11:00:24.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:24.582]                 }
[11:00:24.582]                 NAMES <- toupper(added)
[11:00:24.582]                 for (kk in seq_along(NAMES)) {
[11:00:24.582]                   name <- added[[kk]]
[11:00:24.582]                   NAME <- NAMES[[kk]]
[11:00:24.582]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:24.582]                     next
[11:00:24.582]                   args[[name]] <- ""
[11:00:24.582]                 }
[11:00:24.582]                 NAMES <- toupper(removed)
[11:00:24.582]                 for (kk in seq_along(NAMES)) {
[11:00:24.582]                   name <- removed[[kk]]
[11:00:24.582]                   NAME <- NAMES[[kk]]
[11:00:24.582]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:24.582]                     next
[11:00:24.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:24.582]                 }
[11:00:24.582]                 if (length(args) > 0) 
[11:00:24.582]                   base::do.call(base::Sys.setenv, args = args)
[11:00:24.582]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:24.582]             }
[11:00:24.582]             else {
[11:00:24.582]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:24.582]             }
[11:00:24.582]             {
[11:00:24.582]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:24.582]                   0L) {
[11:00:24.582]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:24.582]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:24.582]                   base::options(opts)
[11:00:24.582]                 }
[11:00:24.582]                 {
[11:00:24.582]                   {
[11:00:24.582]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:24.582]                     NULL
[11:00:24.582]                   }
[11:00:24.582]                   options(future.plan = NULL)
[11:00:24.582]                   if (is.na(NA_character_)) 
[11:00:24.582]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:24.582]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:24.582]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:24.582]                     .init = FALSE)
[11:00:24.582]                 }
[11:00:24.582]             }
[11:00:24.582]         }
[11:00:24.582]     })
[11:00:24.582]     if (FALSE) {
[11:00:24.582]         base::sink(type = "output", split = FALSE)
[11:00:24.582]         if (NA) {
[11:00:24.582]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:24.582]         }
[11:00:24.582]         else {
[11:00:24.582]             ...future.result["stdout"] <- base::list(NULL)
[11:00:24.582]         }
[11:00:24.582]         base::close(...future.stdout)
[11:00:24.582]         ...future.stdout <- NULL
[11:00:24.582]     }
[11:00:24.582]     ...future.result$conditions <- ...future.conditions
[11:00:24.582]     ...future.result$finished <- base::Sys.time()
[11:00:24.582]     ...future.result
[11:00:24.582] }
[11:00:24.585] assign_globals() ...
[11:00:24.585] List of 5
[11:00:24.585]  $ ...future.FUN            :function (x)  
[11:00:24.585]  $ future.call.arguments    : list()
[11:00:24.585]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:24.585]  $ ...future.elements_ii    :List of 1
[11:00:24.585]   ..$ : int 1
[11:00:24.585]  $ ...future.seeds_ii       : NULL
[11:00:24.585]  $ ...future.globals.maxSize: NULL
[11:00:24.585]  - attr(*, "where")=List of 5
[11:00:24.585]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:24.585]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:24.585]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:24.585]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:24.585]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:24.585]  - attr(*, "resolved")= logi FALSE
[11:00:24.585]  - attr(*, "total_size")= num 5632
[11:00:24.585]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:24.585]  - attr(*, "already-done")= logi TRUE
[11:00:24.589] - reassign environment for ‘...future.FUN’
[11:00:24.589] - copied ‘...future.FUN’ to environment
[11:00:24.589] - copied ‘future.call.arguments’ to environment
[11:00:24.590] - copied ‘...future.elements_ii’ to environment
[11:00:24.590] - copied ‘...future.seeds_ii’ to environment
[11:00:24.590] - copied ‘...future.globals.maxSize’ to environment
[11:00:24.590] assign_globals() ... done
[11:00:24.590] requestCore(): workers = 2
[11:00:24.592] MulticoreFuture started
[11:00:24.592] - Launch lazy future ... done
[11:00:24.592] run() for ‘MulticoreFuture’ ... done
[11:00:24.593] Created future:
[11:00:24.593] plan(): Setting new future strategy stack:
[11:00:24.593] List of future strategies:
[11:00:24.593] 1. sequential:
[11:00:24.593]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:24.593]    - tweaked: FALSE
[11:00:24.593]    - call: NULL
[11:00:24.594] plan(): nbrOfWorkers() = 1
[11:00:24.593] MulticoreFuture:
[11:00:24.593] Label: ‘future_lapply-1’
[11:00:24.593] Expression:
[11:00:24.593] {
[11:00:24.593]     do.call(function(...) {
[11:00:24.593]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:24.593]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:24.593]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:24.593]             on.exit(options(oopts), add = TRUE)
[11:00:24.593]         }
[11:00:24.593]         {
[11:00:24.593]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:24.593]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:24.593]                 ...future.FUN(...future.X_jj, ...)
[11:00:24.593]             })
[11:00:24.593]         }
[11:00:24.593]     }, args = future.call.arguments)
[11:00:24.593] }
[11:00:24.593] Lazy evaluation: FALSE
[11:00:24.593] Asynchronous evaluation: TRUE
[11:00:24.593] Local evaluation: TRUE
[11:00:24.593] Environment: R_GlobalEnv
[11:00:24.593] Capture standard output: NA
[11:00:24.593] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:24.593] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:24.593] Packages: <none>
[11:00:24.593] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:24.593] Resolved: FALSE
[11:00:24.593] Value: <not collected>
[11:00:24.593] Conditions captured: <none>
[11:00:24.593] Early signaling: FALSE
[11:00:24.593] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:24.593] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:24.605] Chunk #1 of 2 ... DONE
[11:00:24.605] Chunk #2 of 2 ...
[11:00:24.606]  - Finding globals in 'X' for chunk #2 ...
[11:00:24.606] getGlobalsAndPackages() ...
[11:00:24.606] Searching for globals...
[11:00:24.607] 
[11:00:24.607] Searching for globals ... DONE
[11:00:24.607] - globals: [0] <none>
[11:00:24.607] getGlobalsAndPackages() ... DONE
[11:00:24.607]    + additional globals found: [n=0] 
[11:00:24.607]    + additional namespaces needed: [n=0] 
[11:00:24.607]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:24.608]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:24.608]  - seeds: <none>
[11:00:24.608]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:24.608] getGlobalsAndPackages() ...
[11:00:24.608] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:24.608] Resolving globals: FALSE
[11:00:24.609] Tweak future expression to call with '...' arguments ...
[11:00:24.609] {
[11:00:24.609]     do.call(function(...) {
[11:00:24.609]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:24.609]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:24.609]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:24.609]             on.exit(options(oopts), add = TRUE)
[11:00:24.609]         }
[11:00:24.609]         {
[11:00:24.609]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:24.609]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:24.609]                 ...future.FUN(...future.X_jj, ...)
[11:00:24.609]             })
[11:00:24.609]         }
[11:00:24.609]     }, args = future.call.arguments)
[11:00:24.609] }
[11:00:24.609] Tweak future expression to call with '...' arguments ... DONE
[11:00:24.610] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:24.610] 
[11:00:24.610] getGlobalsAndPackages() ... DONE
[11:00:24.611] run() for ‘Future’ ...
[11:00:24.611] - state: ‘created’
[11:00:24.611] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:24.614] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:24.614] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:24.614]   - Field: ‘label’
[11:00:24.614]   - Field: ‘local’
[11:00:24.615]   - Field: ‘owner’
[11:00:24.615]   - Field: ‘envir’
[11:00:24.615]   - Field: ‘workers’
[11:00:24.615]   - Field: ‘packages’
[11:00:24.615]   - Field: ‘gc’
[11:00:24.615]   - Field: ‘job’
[11:00:24.615]   - Field: ‘conditions’
[11:00:24.616]   - Field: ‘expr’
[11:00:24.616]   - Field: ‘uuid’
[11:00:24.616]   - Field: ‘seed’
[11:00:24.616]   - Field: ‘version’
[11:00:24.616]   - Field: ‘result’
[11:00:24.616]   - Field: ‘asynchronous’
[11:00:24.617]   - Field: ‘calls’
[11:00:24.617]   - Field: ‘globals’
[11:00:24.617]   - Field: ‘stdout’
[11:00:24.617]   - Field: ‘earlySignal’
[11:00:24.617]   - Field: ‘lazy’
[11:00:24.617]   - Field: ‘state’
[11:00:24.617] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:24.617] - Launch lazy future ...
[11:00:24.618] Packages needed by the future expression (n = 0): <none>
[11:00:24.618] Packages needed by future strategies (n = 0): <none>
[11:00:24.619] {
[11:00:24.619]     {
[11:00:24.619]         {
[11:00:24.619]             ...future.startTime <- base::Sys.time()
[11:00:24.619]             {
[11:00:24.619]                 {
[11:00:24.619]                   {
[11:00:24.619]                     {
[11:00:24.619]                       base::local({
[11:00:24.619]                         has_future <- base::requireNamespace("future", 
[11:00:24.619]                           quietly = TRUE)
[11:00:24.619]                         if (has_future) {
[11:00:24.619]                           ns <- base::getNamespace("future")
[11:00:24.619]                           version <- ns[[".package"]][["version"]]
[11:00:24.619]                           if (is.null(version)) 
[11:00:24.619]                             version <- utils::packageVersion("future")
[11:00:24.619]                         }
[11:00:24.619]                         else {
[11:00:24.619]                           version <- NULL
[11:00:24.619]                         }
[11:00:24.619]                         if (!has_future || version < "1.8.0") {
[11:00:24.619]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:24.619]                             "", base::R.version$version.string), 
[11:00:24.619]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:24.619]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:24.619]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:24.619]                               "release", "version")], collapse = " "), 
[11:00:24.619]                             hostname = base::Sys.info()[["nodename"]])
[11:00:24.619]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:24.619]                             info)
[11:00:24.619]                           info <- base::paste(info, collapse = "; ")
[11:00:24.619]                           if (!has_future) {
[11:00:24.619]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:24.619]                               info)
[11:00:24.619]                           }
[11:00:24.619]                           else {
[11:00:24.619]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:24.619]                               info, version)
[11:00:24.619]                           }
[11:00:24.619]                           base::stop(msg)
[11:00:24.619]                         }
[11:00:24.619]                       })
[11:00:24.619]                     }
[11:00:24.619]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:24.619]                     base::options(mc.cores = 1L)
[11:00:24.619]                   }
[11:00:24.619]                   ...future.strategy.old <- future::plan("list")
[11:00:24.619]                   options(future.plan = NULL)
[11:00:24.619]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:24.619]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:24.619]                 }
[11:00:24.619]                 ...future.workdir <- getwd()
[11:00:24.619]             }
[11:00:24.619]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:24.619]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:24.619]         }
[11:00:24.619]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:24.619]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:24.619]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:24.619]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:24.619]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:24.619]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:24.619]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:24.619]             base::names(...future.oldOptions))
[11:00:24.619]     }
[11:00:24.619]     if (TRUE) {
[11:00:24.619]     }
[11:00:24.619]     else {
[11:00:24.619]         if (NA) {
[11:00:24.619]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:24.619]                 open = "w")
[11:00:24.619]         }
[11:00:24.619]         else {
[11:00:24.619]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:24.619]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:24.619]         }
[11:00:24.619]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:24.619]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:24.619]             base::sink(type = "output", split = FALSE)
[11:00:24.619]             base::close(...future.stdout)
[11:00:24.619]         }, add = TRUE)
[11:00:24.619]     }
[11:00:24.619]     ...future.frame <- base::sys.nframe()
[11:00:24.619]     ...future.conditions <- base::list()
[11:00:24.619]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:24.619]     if (FALSE) {
[11:00:24.619]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:24.619]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:24.619]     }
[11:00:24.619]     ...future.result <- base::tryCatch({
[11:00:24.619]         base::withCallingHandlers({
[11:00:24.619]             ...future.value <- base::withVisible(base::local({
[11:00:24.619]                 withCallingHandlers({
[11:00:24.619]                   {
[11:00:24.619]                     do.call(function(...) {
[11:00:24.619]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:24.619]                       if (!identical(...future.globals.maxSize.org, 
[11:00:24.619]                         ...future.globals.maxSize)) {
[11:00:24.619]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:24.619]                         on.exit(options(oopts), add = TRUE)
[11:00:24.619]                       }
[11:00:24.619]                       {
[11:00:24.619]                         lapply(seq_along(...future.elements_ii), 
[11:00:24.619]                           FUN = function(jj) {
[11:00:24.619]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:24.619]                             ...future.FUN(...future.X_jj, ...)
[11:00:24.619]                           })
[11:00:24.619]                       }
[11:00:24.619]                     }, args = future.call.arguments)
[11:00:24.619]                   }
[11:00:24.619]                 }, immediateCondition = function(cond) {
[11:00:24.619]                   save_rds <- function (object, pathname, ...) 
[11:00:24.619]                   {
[11:00:24.619]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:24.619]                     if (file_test("-f", pathname_tmp)) {
[11:00:24.619]                       fi_tmp <- file.info(pathname_tmp)
[11:00:24.619]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:24.619]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:24.619]                         fi_tmp[["mtime"]])
[11:00:24.619]                     }
[11:00:24.619]                     tryCatch({
[11:00:24.619]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:24.619]                     }, error = function(ex) {
[11:00:24.619]                       msg <- conditionMessage(ex)
[11:00:24.619]                       fi_tmp <- file.info(pathname_tmp)
[11:00:24.619]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:24.619]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:24.619]                         fi_tmp[["mtime"]], msg)
[11:00:24.619]                       ex$message <- msg
[11:00:24.619]                       stop(ex)
[11:00:24.619]                     })
[11:00:24.619]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:24.619]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:24.619]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:24.619]                       fi_tmp <- file.info(pathname_tmp)
[11:00:24.619]                       fi <- file.info(pathname)
[11:00:24.619]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:24.619]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:24.619]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:24.619]                         fi[["size"]], fi[["mtime"]])
[11:00:24.619]                       stop(msg)
[11:00:24.619]                     }
[11:00:24.619]                     invisible(pathname)
[11:00:24.619]                   }
[11:00:24.619]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:24.619]                     rootPath = tempdir()) 
[11:00:24.619]                   {
[11:00:24.619]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:24.619]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:24.619]                       tmpdir = path, fileext = ".rds")
[11:00:24.619]                     save_rds(obj, file)
[11:00:24.619]                   }
[11:00:24.619]                   saveImmediateCondition(cond, path = "/tmp/RtmpuTAfww/.future/immediateConditions")
[11:00:24.619]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:24.619]                   {
[11:00:24.619]                     inherits <- base::inherits
[11:00:24.619]                     invokeRestart <- base::invokeRestart
[11:00:24.619]                     is.null <- base::is.null
[11:00:24.619]                     muffled <- FALSE
[11:00:24.619]                     if (inherits(cond, "message")) {
[11:00:24.619]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:24.619]                       if (muffled) 
[11:00:24.619]                         invokeRestart("muffleMessage")
[11:00:24.619]                     }
[11:00:24.619]                     else if (inherits(cond, "warning")) {
[11:00:24.619]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:24.619]                       if (muffled) 
[11:00:24.619]                         invokeRestart("muffleWarning")
[11:00:24.619]                     }
[11:00:24.619]                     else if (inherits(cond, "condition")) {
[11:00:24.619]                       if (!is.null(pattern)) {
[11:00:24.619]                         computeRestarts <- base::computeRestarts
[11:00:24.619]                         grepl <- base::grepl
[11:00:24.619]                         restarts <- computeRestarts(cond)
[11:00:24.619]                         for (restart in restarts) {
[11:00:24.619]                           name <- restart$name
[11:00:24.619]                           if (is.null(name)) 
[11:00:24.619]                             next
[11:00:24.619]                           if (!grepl(pattern, name)) 
[11:00:24.619]                             next
[11:00:24.619]                           invokeRestart(restart)
[11:00:24.619]                           muffled <- TRUE
[11:00:24.619]                           break
[11:00:24.619]                         }
[11:00:24.619]                       }
[11:00:24.619]                     }
[11:00:24.619]                     invisible(muffled)
[11:00:24.619]                   }
[11:00:24.619]                   muffleCondition(cond)
[11:00:24.619]                 })
[11:00:24.619]             }))
[11:00:24.619]             future::FutureResult(value = ...future.value$value, 
[11:00:24.619]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:24.619]                   ...future.rng), globalenv = if (FALSE) 
[11:00:24.619]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:24.619]                     ...future.globalenv.names))
[11:00:24.619]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:24.619]         }, condition = base::local({
[11:00:24.619]             c <- base::c
[11:00:24.619]             inherits <- base::inherits
[11:00:24.619]             invokeRestart <- base::invokeRestart
[11:00:24.619]             length <- base::length
[11:00:24.619]             list <- base::list
[11:00:24.619]             seq.int <- base::seq.int
[11:00:24.619]             signalCondition <- base::signalCondition
[11:00:24.619]             sys.calls <- base::sys.calls
[11:00:24.619]             `[[` <- base::`[[`
[11:00:24.619]             `+` <- base::`+`
[11:00:24.619]             `<<-` <- base::`<<-`
[11:00:24.619]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:24.619]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:24.619]                   3L)]
[11:00:24.619]             }
[11:00:24.619]             function(cond) {
[11:00:24.619]                 is_error <- inherits(cond, "error")
[11:00:24.619]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:24.619]                   NULL)
[11:00:24.619]                 if (is_error) {
[11:00:24.619]                   sessionInformation <- function() {
[11:00:24.619]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:24.619]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:24.619]                       search = base::search(), system = base::Sys.info())
[11:00:24.619]                   }
[11:00:24.619]                   ...future.conditions[[length(...future.conditions) + 
[11:00:24.619]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:24.619]                     cond$call), session = sessionInformation(), 
[11:00:24.619]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:24.619]                   signalCondition(cond)
[11:00:24.619]                 }
[11:00:24.619]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:24.619]                 "immediateCondition"))) {
[11:00:24.619]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:24.619]                   ...future.conditions[[length(...future.conditions) + 
[11:00:24.619]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:24.619]                   if (TRUE && !signal) {
[11:00:24.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:24.619]                     {
[11:00:24.619]                       inherits <- base::inherits
[11:00:24.619]                       invokeRestart <- base::invokeRestart
[11:00:24.619]                       is.null <- base::is.null
[11:00:24.619]                       muffled <- FALSE
[11:00:24.619]                       if (inherits(cond, "message")) {
[11:00:24.619]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:24.619]                         if (muffled) 
[11:00:24.619]                           invokeRestart("muffleMessage")
[11:00:24.619]                       }
[11:00:24.619]                       else if (inherits(cond, "warning")) {
[11:00:24.619]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:24.619]                         if (muffled) 
[11:00:24.619]                           invokeRestart("muffleWarning")
[11:00:24.619]                       }
[11:00:24.619]                       else if (inherits(cond, "condition")) {
[11:00:24.619]                         if (!is.null(pattern)) {
[11:00:24.619]                           computeRestarts <- base::computeRestarts
[11:00:24.619]                           grepl <- base::grepl
[11:00:24.619]                           restarts <- computeRestarts(cond)
[11:00:24.619]                           for (restart in restarts) {
[11:00:24.619]                             name <- restart$name
[11:00:24.619]                             if (is.null(name)) 
[11:00:24.619]                               next
[11:00:24.619]                             if (!grepl(pattern, name)) 
[11:00:24.619]                               next
[11:00:24.619]                             invokeRestart(restart)
[11:00:24.619]                             muffled <- TRUE
[11:00:24.619]                             break
[11:00:24.619]                           }
[11:00:24.619]                         }
[11:00:24.619]                       }
[11:00:24.619]                       invisible(muffled)
[11:00:24.619]                     }
[11:00:24.619]                     muffleCondition(cond, pattern = "^muffle")
[11:00:24.619]                   }
[11:00:24.619]                 }
[11:00:24.619]                 else {
[11:00:24.619]                   if (TRUE) {
[11:00:24.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:24.619]                     {
[11:00:24.619]                       inherits <- base::inherits
[11:00:24.619]                       invokeRestart <- base::invokeRestart
[11:00:24.619]                       is.null <- base::is.null
[11:00:24.619]                       muffled <- FALSE
[11:00:24.619]                       if (inherits(cond, "message")) {
[11:00:24.619]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:24.619]                         if (muffled) 
[11:00:24.619]                           invokeRestart("muffleMessage")
[11:00:24.619]                       }
[11:00:24.619]                       else if (inherits(cond, "warning")) {
[11:00:24.619]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:24.619]                         if (muffled) 
[11:00:24.619]                           invokeRestart("muffleWarning")
[11:00:24.619]                       }
[11:00:24.619]                       else if (inherits(cond, "condition")) {
[11:00:24.619]                         if (!is.null(pattern)) {
[11:00:24.619]                           computeRestarts <- base::computeRestarts
[11:00:24.619]                           grepl <- base::grepl
[11:00:24.619]                           restarts <- computeRestarts(cond)
[11:00:24.619]                           for (restart in restarts) {
[11:00:24.619]                             name <- restart$name
[11:00:24.619]                             if (is.null(name)) 
[11:00:24.619]                               next
[11:00:24.619]                             if (!grepl(pattern, name)) 
[11:00:24.619]                               next
[11:00:24.619]                             invokeRestart(restart)
[11:00:24.619]                             muffled <- TRUE
[11:00:24.619]                             break
[11:00:24.619]                           }
[11:00:24.619]                         }
[11:00:24.619]                       }
[11:00:24.619]                       invisible(muffled)
[11:00:24.619]                     }
[11:00:24.619]                     muffleCondition(cond, pattern = "^muffle")
[11:00:24.619]                   }
[11:00:24.619]                 }
[11:00:24.619]             }
[11:00:24.619]         }))
[11:00:24.619]     }, error = function(ex) {
[11:00:24.619]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:24.619]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:24.619]                 ...future.rng), started = ...future.startTime, 
[11:00:24.619]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:24.619]             version = "1.8"), class = "FutureResult")
[11:00:24.619]     }, finally = {
[11:00:24.619]         if (!identical(...future.workdir, getwd())) 
[11:00:24.619]             setwd(...future.workdir)
[11:00:24.619]         {
[11:00:24.619]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:24.619]                 ...future.oldOptions$nwarnings <- NULL
[11:00:24.619]             }
[11:00:24.619]             base::options(...future.oldOptions)
[11:00:24.619]             if (.Platform$OS.type == "windows") {
[11:00:24.619]                 old_names <- names(...future.oldEnvVars)
[11:00:24.619]                 envs <- base::Sys.getenv()
[11:00:24.619]                 names <- names(envs)
[11:00:24.619]                 common <- intersect(names, old_names)
[11:00:24.619]                 added <- setdiff(names, old_names)
[11:00:24.619]                 removed <- setdiff(old_names, names)
[11:00:24.619]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:24.619]                   envs[common]]
[11:00:24.619]                 NAMES <- toupper(changed)
[11:00:24.619]                 args <- list()
[11:00:24.619]                 for (kk in seq_along(NAMES)) {
[11:00:24.619]                   name <- changed[[kk]]
[11:00:24.619]                   NAME <- NAMES[[kk]]
[11:00:24.619]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:24.619]                     next
[11:00:24.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:24.619]                 }
[11:00:24.619]                 NAMES <- toupper(added)
[11:00:24.619]                 for (kk in seq_along(NAMES)) {
[11:00:24.619]                   name <- added[[kk]]
[11:00:24.619]                   NAME <- NAMES[[kk]]
[11:00:24.619]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:24.619]                     next
[11:00:24.619]                   args[[name]] <- ""
[11:00:24.619]                 }
[11:00:24.619]                 NAMES <- toupper(removed)
[11:00:24.619]                 for (kk in seq_along(NAMES)) {
[11:00:24.619]                   name <- removed[[kk]]
[11:00:24.619]                   NAME <- NAMES[[kk]]
[11:00:24.619]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:24.619]                     next
[11:00:24.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:24.619]                 }
[11:00:24.619]                 if (length(args) > 0) 
[11:00:24.619]                   base::do.call(base::Sys.setenv, args = args)
[11:00:24.619]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:24.619]             }
[11:00:24.619]             else {
[11:00:24.619]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:24.619]             }
[11:00:24.619]             {
[11:00:24.619]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:24.619]                   0L) {
[11:00:24.619]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:24.619]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:24.619]                   base::options(opts)
[11:00:24.619]                 }
[11:00:24.619]                 {
[11:00:24.619]                   {
[11:00:24.619]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:24.619]                     NULL
[11:00:24.619]                   }
[11:00:24.619]                   options(future.plan = NULL)
[11:00:24.619]                   if (is.na(NA_character_)) 
[11:00:24.619]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:24.619]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:24.619]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:24.619]                     .init = FALSE)
[11:00:24.619]                 }
[11:00:24.619]             }
[11:00:24.619]         }
[11:00:24.619]     })
[11:00:24.619]     if (FALSE) {
[11:00:24.619]         base::sink(type = "output", split = FALSE)
[11:00:24.619]         if (NA) {
[11:00:24.619]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:24.619]         }
[11:00:24.619]         else {
[11:00:24.619]             ...future.result["stdout"] <- base::list(NULL)
[11:00:24.619]         }
[11:00:24.619]         base::close(...future.stdout)
[11:00:24.619]         ...future.stdout <- NULL
[11:00:24.619]     }
[11:00:24.619]     ...future.result$conditions <- ...future.conditions
[11:00:24.619]     ...future.result$finished <- base::Sys.time()
[11:00:24.619]     ...future.result
[11:00:24.619] }
[11:00:24.622] assign_globals() ...
[11:00:24.622] List of 5
[11:00:24.622]  $ ...future.FUN            :function (x)  
[11:00:24.622]  $ future.call.arguments    : list()
[11:00:24.622]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:24.622]  $ ...future.elements_ii    :List of 1
[11:00:24.622]   ..$ : int 0
[11:00:24.622]  $ ...future.seeds_ii       : NULL
[11:00:24.622]  $ ...future.globals.maxSize: NULL
[11:00:24.622]  - attr(*, "where")=List of 5
[11:00:24.622]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:24.622]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[11:00:24.622]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:24.622]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:24.622]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:24.622]  - attr(*, "resolved")= logi FALSE
[11:00:24.622]  - attr(*, "total_size")= num 5632
[11:00:24.622]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:24.622]  - attr(*, "already-done")= logi TRUE
[11:00:24.634] - reassign environment for ‘...future.FUN’
[11:00:24.634] - copied ‘...future.FUN’ to environment
[11:00:24.634] - copied ‘future.call.arguments’ to environment
[11:00:24.634] - copied ‘...future.elements_ii’ to environment
[11:00:24.634] - copied ‘...future.seeds_ii’ to environment
[11:00:24.635] - copied ‘...future.globals.maxSize’ to environment
[11:00:24.635] assign_globals() ... done
[11:00:24.635] requestCore(): workers = 2
[11:00:24.637] MulticoreFuture started
[11:00:24.638] - Launch lazy future ... done
[11:00:24.638] run() for ‘MulticoreFuture’ ... done
[11:00:24.638] Created future:
[11:00:24.638] plan(): Setting new future strategy stack:
[11:00:24.639] List of future strategies:
[11:00:24.639] 1. sequential:
[11:00:24.639]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:24.639]    - tweaked: FALSE
[11:00:24.639]    - call: NULL
[11:00:24.640] plan(): nbrOfWorkers() = 1
[11:00:24.642] plan(): Setting new future strategy stack:
[11:00:24.642] List of future strategies:
[11:00:24.642] 1. multicore:
[11:00:24.642]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:24.642]    - tweaked: FALSE
[11:00:24.642]    - call: plan(strategy)
[11:00:24.645] plan(): nbrOfWorkers() = 2
[11:00:24.638] MulticoreFuture:
[11:00:24.638] Label: ‘future_lapply-2’
[11:00:24.638] Expression:
[11:00:24.638] {
[11:00:24.638]     do.call(function(...) {
[11:00:24.638]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:24.638]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:24.638]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:24.638]             on.exit(options(oopts), add = TRUE)
[11:00:24.638]         }
[11:00:24.638]         {
[11:00:24.638]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:24.638]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:24.638]                 ...future.FUN(...future.X_jj, ...)
[11:00:24.638]             })
[11:00:24.638]         }
[11:00:24.638]     }, args = future.call.arguments)
[11:00:24.638] }
[11:00:24.638] Lazy evaluation: FALSE
[11:00:24.638] Asynchronous evaluation: TRUE
[11:00:24.638] Local evaluation: TRUE
[11:00:24.638] Environment: R_GlobalEnv
[11:00:24.638] Capture standard output: NA
[11:00:24.638] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:24.638] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:24.638] Packages: <none>
[11:00:24.638] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:24.638] Resolved: TRUE
[11:00:24.638] Value: <not collected>
[11:00:24.638] Conditions captured: <none>
[11:00:24.638] Early signaling: FALSE
[11:00:24.638] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:24.638] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:24.646] Chunk #2 of 2 ... DONE
[11:00:24.647] Launching 2 futures (chunks) ... DONE
[11:00:24.647] Resolving 2 futures (chunks) ...
[11:00:24.647] resolve() on list ...
[11:00:24.647]  recursive: 0
[11:00:24.647]  length: 2
[11:00:24.647] 
[11:00:24.658] Future #2
[11:00:24.658] result() for MulticoreFuture ...
[11:00:24.659] result() for MulticoreFuture ...
[11:00:24.659] result() for MulticoreFuture ... done
[11:00:24.660] result() for MulticoreFuture ... done
[11:00:24.660] result() for MulticoreFuture ...
[11:00:24.660] result() for MulticoreFuture ... done
[11:00:24.660] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:00:24.660] - nx: 2
[11:00:24.660] - relay: TRUE
[11:00:24.660] - stdout: TRUE
[11:00:24.661] - signal: TRUE
[11:00:24.661] - resignal: FALSE
[11:00:24.661] - force: TRUE
[11:00:24.661] - relayed: [n=2] FALSE, FALSE
[11:00:24.661] - queued futures: [n=2] FALSE, FALSE
[11:00:24.661]  - until=1
[11:00:24.661]  - relaying element #1
[11:00:24.661] - relayed: [n=2] FALSE, FALSE
[11:00:24.662] - queued futures: [n=2] FALSE, TRUE
[11:00:24.662] signalConditionsASAP(NULL, pos=2) ... done
[11:00:24.662]  length: 1 (resolved future 2)
[11:00:25.097] plan(): Setting new future strategy stack:
[11:00:25.097] List of future strategies:
[11:00:25.097] 1. multicore:
[11:00:25.097]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:25.097]    - tweaked: FALSE
[11:00:25.097]    - call: plan(strategy)
[11:00:25.099] plan(): nbrOfWorkers() = 2
[11:00:25.101] Future #1
[11:00:25.101] result() for MulticoreFuture ...
[11:00:25.102] result() for MulticoreFuture ...
[11:00:25.102] result() for MulticoreFuture ... done
[11:00:25.102] result() for MulticoreFuture ... done
[11:00:25.102] result() for MulticoreFuture ...
[11:00:25.102] result() for MulticoreFuture ... done
[11:00:25.102] signalConditionsASAP(MulticoreFuture, pos=1) ...
[11:00:25.102] - nx: 2
[11:00:25.103] - relay: TRUE
[11:00:25.103] - stdout: TRUE
[11:00:25.103] - signal: TRUE
[11:00:25.103] - resignal: FALSE
[11:00:25.103] - force: TRUE
[11:00:25.103] - relayed: [n=2] FALSE, FALSE
[11:00:25.103] - queued futures: [n=2] FALSE, TRUE
[11:00:25.103]  - until=1
[11:00:25.103]  - relaying element #1
[11:00:25.104] result() for MulticoreFuture ...
[11:00:25.104] result() for MulticoreFuture ... done
[11:00:25.104] result() for MulticoreFuture ...
[11:00:25.104] result() for MulticoreFuture ... done
[11:00:25.104] result() for MulticoreFuture ...
[11:00:25.104] result() for MulticoreFuture ... done
[11:00:25.104] result() for MulticoreFuture ...
[11:00:25.104] result() for MulticoreFuture ... done
[11:00:25.104] - relayed: [n=2] TRUE, FALSE
[11:00:25.104] - queued futures: [n=2] TRUE, TRUE
[11:00:25.105] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[11:00:25.105]  length: 0 (resolved future 1)
[11:00:25.105] Relaying remaining futures
[11:00:25.105] signalConditionsASAP(NULL, pos=0) ...
[11:00:25.105] - nx: 2
[11:00:25.105] - relay: TRUE
[11:00:25.105] - stdout: TRUE
[11:00:25.105] - signal: TRUE
[11:00:25.105] - resignal: FALSE
[11:00:25.106] - force: TRUE
[11:00:25.106] - relayed: [n=2] TRUE, FALSE
[11:00:25.106] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:25.106]  - relaying element #2
[11:00:25.106] result() for MulticoreFuture ...
[11:00:25.106] result() for MulticoreFuture ... done
[11:00:25.106] result() for MulticoreFuture ...
[11:00:25.106] result() for MulticoreFuture ... done
[11:00:25.107] result() for MulticoreFuture ...
[11:00:25.107] result() for MulticoreFuture ... done
[11:00:25.107] result() for MulticoreFuture ...
[11:00:25.107] result() for MulticoreFuture ... done
[11:00:25.107] - relayed: [n=2] TRUE, TRUE
[11:00:25.107] - queued futures: [n=2] TRUE, TRUE
[11:00:25.107] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[11:00:25.107] resolve() on list ... DONE
[11:00:25.107] result() for MulticoreFuture ...
[11:00:25.108] result() for MulticoreFuture ... done
[11:00:25.108] result() for MulticoreFuture ...
[11:00:25.108] result() for MulticoreFuture ... done
[11:00:25.108] result() for MulticoreFuture ...
[11:00:25.108] result() for MulticoreFuture ... done
[11:00:25.108] result() for MulticoreFuture ...
[11:00:25.108] result() for MulticoreFuture ... done
[11:00:25.108]  - Number of value chunks collected: 2
[11:00:25.108] Resolving 2 futures (chunks) ... DONE
[11:00:25.109] Reducing values from 2 chunks ...
[11:00:25.109]  - Number of values collected after concatenation: 2
[11:00:25.109]  - Number of values expected: 2
[11:00:25.109] Reducing values from 2 chunks ... DONE
[11:00:25.109] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[11:00:25.109] future_mapply() ...
[11:00:25.112] Number of chunks: 2
[11:00:25.112] getGlobalsAndPackagesXApply() ...
[11:00:25.112]  - future.globals: TRUE
[11:00:25.112] getGlobalsAndPackages() ...
[11:00:25.112] Searching for globals...
[11:00:25.116] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[11:00:25.116] Searching for globals ... DONE
[11:00:25.116] Resolving globals: FALSE
[11:00:25.117] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[11:00:25.118] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[11:00:25.118] - globals: [1] ‘FUN’
[11:00:25.118] 
[11:00:25.118] getGlobalsAndPackages() ... DONE
[11:00:25.118]  - globals found/used: [n=1] ‘FUN’
[11:00:25.118]  - needed namespaces: [n=0] 
[11:00:25.118] Finding globals ... DONE
[11:00:25.119] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[11:00:25.119] List of 2
[11:00:25.119]  $ ...future.FUN:function (x, y)  
[11:00:25.119]  $ MoreArgs     : NULL
[11:00:25.119]  - attr(*, "where")=List of 2
[11:00:25.119]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:25.119]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[11:00:25.119]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:25.119]  - attr(*, "resolved")= logi FALSE
[11:00:25.119]  - attr(*, "total_size")= num NA
[11:00:25.122] Packages to be attached in all futures: [n=0] 
[11:00:25.122] getGlobalsAndPackagesXApply() ... DONE
[11:00:25.122] Number of futures (= number of chunks): 2
[11:00:25.122] Launching 2 futures (chunks) ...
[11:00:25.122] Chunk #1 of 2 ...
[11:00:25.123]  - Finding globals in '...' for chunk #1 ...
[11:00:25.123] getGlobalsAndPackages() ...
[11:00:25.123] Searching for globals...
[11:00:25.123] 
[11:00:25.123] Searching for globals ... DONE
[11:00:25.123] - globals: [0] <none>
[11:00:25.123] getGlobalsAndPackages() ... DONE
[11:00:25.123]    + additional globals found: [n=0] 
[11:00:25.123]    + additional namespaces needed: [n=0] 
[11:00:25.124]  - Finding globals in '...' for chunk #1 ... DONE
[11:00:25.124]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:25.124]  - seeds: <none>
[11:00:25.124]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:25.124] getGlobalsAndPackages() ...
[11:00:25.124] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:25.124] Resolving globals: FALSE
[11:00:25.124] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[11:00:25.125] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[11:00:25.125] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:25.125] 
[11:00:25.125] getGlobalsAndPackages() ... DONE
[11:00:25.126] run() for ‘Future’ ...
[11:00:25.126] - state: ‘created’
[11:00:25.126] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:25.127] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:25.128] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:25.128]   - Field: ‘label’
[11:00:25.128]   - Field: ‘local’
[11:00:25.128]   - Field: ‘owner’
[11:00:25.128]   - Field: ‘envir’
[11:00:25.128]   - Field: ‘workers’
[11:00:25.128]   - Field: ‘packages’
[11:00:25.128]   - Field: ‘gc’
[11:00:25.128]   - Field: ‘job’
[11:00:25.128]   - Field: ‘conditions’
[11:00:25.128]   - Field: ‘expr’
[11:00:25.128]   - Field: ‘uuid’
[11:00:25.129]   - Field: ‘seed’
[11:00:25.129]   - Field: ‘version’
[11:00:25.129]   - Field: ‘result’
[11:00:25.129]   - Field: ‘asynchronous’
[11:00:25.129]   - Field: ‘calls’
[11:00:25.129]   - Field: ‘globals’
[11:00:25.129]   - Field: ‘stdout’
[11:00:25.129]   - Field: ‘earlySignal’
[11:00:25.129]   - Field: ‘lazy’
[11:00:25.129]   - Field: ‘state’
[11:00:25.129] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:25.130] - Launch lazy future ...
[11:00:25.130] Packages needed by the future expression (n = 0): <none>
[11:00:25.130] Packages needed by future strategies (n = 0): <none>
[11:00:25.130] {
[11:00:25.130]     {
[11:00:25.130]         {
[11:00:25.130]             ...future.startTime <- base::Sys.time()
[11:00:25.130]             {
[11:00:25.130]                 {
[11:00:25.130]                   {
[11:00:25.130]                     {
[11:00:25.130]                       base::local({
[11:00:25.130]                         has_future <- base::requireNamespace("future", 
[11:00:25.130]                           quietly = TRUE)
[11:00:25.130]                         if (has_future) {
[11:00:25.130]                           ns <- base::getNamespace("future")
[11:00:25.130]                           version <- ns[[".package"]][["version"]]
[11:00:25.130]                           if (is.null(version)) 
[11:00:25.130]                             version <- utils::packageVersion("future")
[11:00:25.130]                         }
[11:00:25.130]                         else {
[11:00:25.130]                           version <- NULL
[11:00:25.130]                         }
[11:00:25.130]                         if (!has_future || version < "1.8.0") {
[11:00:25.130]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:25.130]                             "", base::R.version$version.string), 
[11:00:25.130]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:25.130]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:25.130]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:25.130]                               "release", "version")], collapse = " "), 
[11:00:25.130]                             hostname = base::Sys.info()[["nodename"]])
[11:00:25.130]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:25.130]                             info)
[11:00:25.130]                           info <- base::paste(info, collapse = "; ")
[11:00:25.130]                           if (!has_future) {
[11:00:25.130]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:25.130]                               info)
[11:00:25.130]                           }
[11:00:25.130]                           else {
[11:00:25.130]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:25.130]                               info, version)
[11:00:25.130]                           }
[11:00:25.130]                           base::stop(msg)
[11:00:25.130]                         }
[11:00:25.130]                       })
[11:00:25.130]                     }
[11:00:25.130]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:25.130]                     base::options(mc.cores = 1L)
[11:00:25.130]                   }
[11:00:25.130]                   ...future.strategy.old <- future::plan("list")
[11:00:25.130]                   options(future.plan = NULL)
[11:00:25.130]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:25.130]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:25.130]                 }
[11:00:25.130]                 ...future.workdir <- getwd()
[11:00:25.130]             }
[11:00:25.130]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:25.130]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:25.130]         }
[11:00:25.130]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:25.130]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:25.130]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:25.130]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:25.130]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:25.130]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:25.130]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:25.130]             base::names(...future.oldOptions))
[11:00:25.130]     }
[11:00:25.130]     if (FALSE) {
[11:00:25.130]     }
[11:00:25.130]     else {
[11:00:25.130]         if (FALSE) {
[11:00:25.130]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:25.130]                 open = "w")
[11:00:25.130]         }
[11:00:25.130]         else {
[11:00:25.130]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:25.130]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:25.130]         }
[11:00:25.130]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:25.130]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:25.130]             base::sink(type = "output", split = FALSE)
[11:00:25.130]             base::close(...future.stdout)
[11:00:25.130]         }, add = TRUE)
[11:00:25.130]     }
[11:00:25.130]     ...future.frame <- base::sys.nframe()
[11:00:25.130]     ...future.conditions <- base::list()
[11:00:25.130]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:25.130]     if (FALSE) {
[11:00:25.130]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:25.130]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:25.130]     }
[11:00:25.130]     ...future.result <- base::tryCatch({
[11:00:25.130]         base::withCallingHandlers({
[11:00:25.130]             ...future.value <- base::withVisible(base::local({
[11:00:25.130]                 withCallingHandlers({
[11:00:25.130]                   {
[11:00:25.130]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:25.130]                     if (!identical(...future.globals.maxSize.org, 
[11:00:25.130]                       ...future.globals.maxSize)) {
[11:00:25.130]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:25.130]                       on.exit(options(oopts), add = TRUE)
[11:00:25.130]                     }
[11:00:25.130]                     {
[11:00:25.130]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:25.130]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:00:25.130]                         USE.NAMES = FALSE)
[11:00:25.130]                       do.call(mapply, args = args)
[11:00:25.130]                     }
[11:00:25.130]                   }
[11:00:25.130]                 }, immediateCondition = function(cond) {
[11:00:25.130]                   save_rds <- function (object, pathname, ...) 
[11:00:25.130]                   {
[11:00:25.130]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:25.130]                     if (file_test("-f", pathname_tmp)) {
[11:00:25.130]                       fi_tmp <- file.info(pathname_tmp)
[11:00:25.130]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:25.130]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:25.130]                         fi_tmp[["mtime"]])
[11:00:25.130]                     }
[11:00:25.130]                     tryCatch({
[11:00:25.130]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:25.130]                     }, error = function(ex) {
[11:00:25.130]                       msg <- conditionMessage(ex)
[11:00:25.130]                       fi_tmp <- file.info(pathname_tmp)
[11:00:25.130]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:25.130]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:25.130]                         fi_tmp[["mtime"]], msg)
[11:00:25.130]                       ex$message <- msg
[11:00:25.130]                       stop(ex)
[11:00:25.130]                     })
[11:00:25.130]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:25.130]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:25.130]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:25.130]                       fi_tmp <- file.info(pathname_tmp)
[11:00:25.130]                       fi <- file.info(pathname)
[11:00:25.130]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:25.130]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:25.130]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:25.130]                         fi[["size"]], fi[["mtime"]])
[11:00:25.130]                       stop(msg)
[11:00:25.130]                     }
[11:00:25.130]                     invisible(pathname)
[11:00:25.130]                   }
[11:00:25.130]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:25.130]                     rootPath = tempdir()) 
[11:00:25.130]                   {
[11:00:25.130]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:25.130]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:25.130]                       tmpdir = path, fileext = ".rds")
[11:00:25.130]                     save_rds(obj, file)
[11:00:25.130]                   }
[11:00:25.130]                   saveImmediateCondition(cond, path = "/tmp/RtmpuTAfww/.future/immediateConditions")
[11:00:25.130]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:25.130]                   {
[11:00:25.130]                     inherits <- base::inherits
[11:00:25.130]                     invokeRestart <- base::invokeRestart
[11:00:25.130]                     is.null <- base::is.null
[11:00:25.130]                     muffled <- FALSE
[11:00:25.130]                     if (inherits(cond, "message")) {
[11:00:25.130]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:25.130]                       if (muffled) 
[11:00:25.130]                         invokeRestart("muffleMessage")
[11:00:25.130]                     }
[11:00:25.130]                     else if (inherits(cond, "warning")) {
[11:00:25.130]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:25.130]                       if (muffled) 
[11:00:25.130]                         invokeRestart("muffleWarning")
[11:00:25.130]                     }
[11:00:25.130]                     else if (inherits(cond, "condition")) {
[11:00:25.130]                       if (!is.null(pattern)) {
[11:00:25.130]                         computeRestarts <- base::computeRestarts
[11:00:25.130]                         grepl <- base::grepl
[11:00:25.130]                         restarts <- computeRestarts(cond)
[11:00:25.130]                         for (restart in restarts) {
[11:00:25.130]                           name <- restart$name
[11:00:25.130]                           if (is.null(name)) 
[11:00:25.130]                             next
[11:00:25.130]                           if (!grepl(pattern, name)) 
[11:00:25.130]                             next
[11:00:25.130]                           invokeRestart(restart)
[11:00:25.130]                           muffled <- TRUE
[11:00:25.130]                           break
[11:00:25.130]                         }
[11:00:25.130]                       }
[11:00:25.130]                     }
[11:00:25.130]                     invisible(muffled)
[11:00:25.130]                   }
[11:00:25.130]                   muffleCondition(cond)
[11:00:25.130]                 })
[11:00:25.130]             }))
[11:00:25.130]             future::FutureResult(value = ...future.value$value, 
[11:00:25.130]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:25.130]                   ...future.rng), globalenv = if (FALSE) 
[11:00:25.130]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:25.130]                     ...future.globalenv.names))
[11:00:25.130]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:25.130]         }, condition = base::local({
[11:00:25.130]             c <- base::c
[11:00:25.130]             inherits <- base::inherits
[11:00:25.130]             invokeRestart <- base::invokeRestart
[11:00:25.130]             length <- base::length
[11:00:25.130]             list <- base::list
[11:00:25.130]             seq.int <- base::seq.int
[11:00:25.130]             signalCondition <- base::signalCondition
[11:00:25.130]             sys.calls <- base::sys.calls
[11:00:25.130]             `[[` <- base::`[[`
[11:00:25.130]             `+` <- base::`+`
[11:00:25.130]             `<<-` <- base::`<<-`
[11:00:25.130]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:25.130]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:25.130]                   3L)]
[11:00:25.130]             }
[11:00:25.130]             function(cond) {
[11:00:25.130]                 is_error <- inherits(cond, "error")
[11:00:25.130]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:25.130]                   NULL)
[11:00:25.130]                 if (is_error) {
[11:00:25.130]                   sessionInformation <- function() {
[11:00:25.130]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:25.130]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:25.130]                       search = base::search(), system = base::Sys.info())
[11:00:25.130]                   }
[11:00:25.130]                   ...future.conditions[[length(...future.conditions) + 
[11:00:25.130]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:25.130]                     cond$call), session = sessionInformation(), 
[11:00:25.130]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:25.130]                   signalCondition(cond)
[11:00:25.130]                 }
[11:00:25.130]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:25.130]                 "immediateCondition"))) {
[11:00:25.130]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:25.130]                   ...future.conditions[[length(...future.conditions) + 
[11:00:25.130]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:25.130]                   if (TRUE && !signal) {
[11:00:25.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:25.130]                     {
[11:00:25.130]                       inherits <- base::inherits
[11:00:25.130]                       invokeRestart <- base::invokeRestart
[11:00:25.130]                       is.null <- base::is.null
[11:00:25.130]                       muffled <- FALSE
[11:00:25.130]                       if (inherits(cond, "message")) {
[11:00:25.130]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:25.130]                         if (muffled) 
[11:00:25.130]                           invokeRestart("muffleMessage")
[11:00:25.130]                       }
[11:00:25.130]                       else if (inherits(cond, "warning")) {
[11:00:25.130]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:25.130]                         if (muffled) 
[11:00:25.130]                           invokeRestart("muffleWarning")
[11:00:25.130]                       }
[11:00:25.130]                       else if (inherits(cond, "condition")) {
[11:00:25.130]                         if (!is.null(pattern)) {
[11:00:25.130]                           computeRestarts <- base::computeRestarts
[11:00:25.130]                           grepl <- base::grepl
[11:00:25.130]                           restarts <- computeRestarts(cond)
[11:00:25.130]                           for (restart in restarts) {
[11:00:25.130]                             name <- restart$name
[11:00:25.130]                             if (is.null(name)) 
[11:00:25.130]                               next
[11:00:25.130]                             if (!grepl(pattern, name)) 
[11:00:25.130]                               next
[11:00:25.130]                             invokeRestart(restart)
[11:00:25.130]                             muffled <- TRUE
[11:00:25.130]                             break
[11:00:25.130]                           }
[11:00:25.130]                         }
[11:00:25.130]                       }
[11:00:25.130]                       invisible(muffled)
[11:00:25.130]                     }
[11:00:25.130]                     muffleCondition(cond, pattern = "^muffle")
[11:00:25.130]                   }
[11:00:25.130]                 }
[11:00:25.130]                 else {
[11:00:25.130]                   if (TRUE) {
[11:00:25.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:25.130]                     {
[11:00:25.130]                       inherits <- base::inherits
[11:00:25.130]                       invokeRestart <- base::invokeRestart
[11:00:25.130]                       is.null <- base::is.null
[11:00:25.130]                       muffled <- FALSE
[11:00:25.130]                       if (inherits(cond, "message")) {
[11:00:25.130]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:25.130]                         if (muffled) 
[11:00:25.130]                           invokeRestart("muffleMessage")
[11:00:25.130]                       }
[11:00:25.130]                       else if (inherits(cond, "warning")) {
[11:00:25.130]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:25.130]                         if (muffled) 
[11:00:25.130]                           invokeRestart("muffleWarning")
[11:00:25.130]                       }
[11:00:25.130]                       else if (inherits(cond, "condition")) {
[11:00:25.130]                         if (!is.null(pattern)) {
[11:00:25.130]                           computeRestarts <- base::computeRestarts
[11:00:25.130]                           grepl <- base::grepl
[11:00:25.130]                           restarts <- computeRestarts(cond)
[11:00:25.130]                           for (restart in restarts) {
[11:00:25.130]                             name <- restart$name
[11:00:25.130]                             if (is.null(name)) 
[11:00:25.130]                               next
[11:00:25.130]                             if (!grepl(pattern, name)) 
[11:00:25.130]                               next
[11:00:25.130]                             invokeRestart(restart)
[11:00:25.130]                             muffled <- TRUE
[11:00:25.130]                             break
[11:00:25.130]                           }
[11:00:25.130]                         }
[11:00:25.130]                       }
[11:00:25.130]                       invisible(muffled)
[11:00:25.130]                     }
[11:00:25.130]                     muffleCondition(cond, pattern = "^muffle")
[11:00:25.130]                   }
[11:00:25.130]                 }
[11:00:25.130]             }
[11:00:25.130]         }))
[11:00:25.130]     }, error = function(ex) {
[11:00:25.130]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:25.130]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:25.130]                 ...future.rng), started = ...future.startTime, 
[11:00:25.130]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:25.130]             version = "1.8"), class = "FutureResult")
[11:00:25.130]     }, finally = {
[11:00:25.130]         if (!identical(...future.workdir, getwd())) 
[11:00:25.130]             setwd(...future.workdir)
[11:00:25.130]         {
[11:00:25.130]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:25.130]                 ...future.oldOptions$nwarnings <- NULL
[11:00:25.130]             }
[11:00:25.130]             base::options(...future.oldOptions)
[11:00:25.130]             if (.Platform$OS.type == "windows") {
[11:00:25.130]                 old_names <- names(...future.oldEnvVars)
[11:00:25.130]                 envs <- base::Sys.getenv()
[11:00:25.130]                 names <- names(envs)
[11:00:25.130]                 common <- intersect(names, old_names)
[11:00:25.130]                 added <- setdiff(names, old_names)
[11:00:25.130]                 removed <- setdiff(old_names, names)
[11:00:25.130]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:25.130]                   envs[common]]
[11:00:25.130]                 NAMES <- toupper(changed)
[11:00:25.130]                 args <- list()
[11:00:25.130]                 for (kk in seq_along(NAMES)) {
[11:00:25.130]                   name <- changed[[kk]]
[11:00:25.130]                   NAME <- NAMES[[kk]]
[11:00:25.130]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:25.130]                     next
[11:00:25.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:25.130]                 }
[11:00:25.130]                 NAMES <- toupper(added)
[11:00:25.130]                 for (kk in seq_along(NAMES)) {
[11:00:25.130]                   name <- added[[kk]]
[11:00:25.130]                   NAME <- NAMES[[kk]]
[11:00:25.130]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:25.130]                     next
[11:00:25.130]                   args[[name]] <- ""
[11:00:25.130]                 }
[11:00:25.130]                 NAMES <- toupper(removed)
[11:00:25.130]                 for (kk in seq_along(NAMES)) {
[11:00:25.130]                   name <- removed[[kk]]
[11:00:25.130]                   NAME <- NAMES[[kk]]
[11:00:25.130]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:25.130]                     next
[11:00:25.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:25.130]                 }
[11:00:25.130]                 if (length(args) > 0) 
[11:00:25.130]                   base::do.call(base::Sys.setenv, args = args)
[11:00:25.130]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:25.130]             }
[11:00:25.130]             else {
[11:00:25.130]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:25.130]             }
[11:00:25.130]             {
[11:00:25.130]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:25.130]                   0L) {
[11:00:25.130]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:25.130]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:25.130]                   base::options(opts)
[11:00:25.130]                 }
[11:00:25.130]                 {
[11:00:25.130]                   {
[11:00:25.130]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:25.130]                     NULL
[11:00:25.130]                   }
[11:00:25.130]                   options(future.plan = NULL)
[11:00:25.130]                   if (is.na(NA_character_)) 
[11:00:25.130]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:25.130]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:25.130]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:25.130]                     .init = FALSE)
[11:00:25.130]                 }
[11:00:25.130]             }
[11:00:25.130]         }
[11:00:25.130]     })
[11:00:25.130]     if (TRUE) {
[11:00:25.130]         base::sink(type = "output", split = FALSE)
[11:00:25.130]         if (FALSE) {
[11:00:25.130]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:25.130]         }
[11:00:25.130]         else {
[11:00:25.130]             ...future.result["stdout"] <- base::list(NULL)
[11:00:25.130]         }
[11:00:25.130]         base::close(...future.stdout)
[11:00:25.130]         ...future.stdout <- NULL
[11:00:25.130]     }
[11:00:25.130]     ...future.result$conditions <- ...future.conditions
[11:00:25.130]     ...future.result$finished <- base::Sys.time()
[11:00:25.130]     ...future.result
[11:00:25.130] }
[11:00:25.133] assign_globals() ...
[11:00:25.133] List of 5
[11:00:25.133]  $ ...future.FUN            :function (x, y)  
[11:00:25.133]  $ MoreArgs                 : NULL
[11:00:25.133]  $ ...future.elements_ii    :List of 2
[11:00:25.133]   ..$ :List of 1
[11:00:25.133]   .. ..$ : int 1
[11:00:25.133]   ..$ :List of 1
[11:00:25.133]   .. ..$ : int 0
[11:00:25.133]  $ ...future.seeds_ii       : NULL
[11:00:25.133]  $ ...future.globals.maxSize: NULL
[11:00:25.133]  - attr(*, "where")=List of 5
[11:00:25.133]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:25.133]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[11:00:25.133]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:25.133]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:25.133]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:25.133]  - attr(*, "resolved")= logi FALSE
[11:00:25.133]  - attr(*, "total_size")= num 1218
[11:00:25.133]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:25.133]  - attr(*, "already-done")= logi TRUE
[11:00:25.138] - reassign environment for ‘...future.FUN’
[11:00:25.138] - copied ‘...future.FUN’ to environment
[11:00:25.138] - copied ‘MoreArgs’ to environment
[11:00:25.138] - copied ‘...future.elements_ii’ to environment
[11:00:25.138] - copied ‘...future.seeds_ii’ to environment
[11:00:25.138] - copied ‘...future.globals.maxSize’ to environment
[11:00:25.138] assign_globals() ... done
[11:00:25.138] requestCore(): workers = 2
[11:00:25.140] MulticoreFuture started
[11:00:25.141] - Launch lazy future ... done
[11:00:25.141] run() for ‘MulticoreFuture’ ... done
[11:00:25.141] Created future:
[11:00:25.141] plan(): Setting new future strategy stack:
[11:00:25.142] List of future strategies:
[11:00:25.142] 1. sequential:
[11:00:25.142]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:25.142]    - tweaked: FALSE
[11:00:25.142]    - call: NULL
[11:00:25.143] plan(): nbrOfWorkers() = 1
[11:00:25.141] MulticoreFuture:
[11:00:25.141] Label: ‘future_mapply-1’
[11:00:25.141] Expression:
[11:00:25.141] {
[11:00:25.141]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:25.141]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:25.141]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:25.141]         on.exit(options(oopts), add = TRUE)
[11:00:25.141]     }
[11:00:25.141]     {
[11:00:25.141]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:25.141]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:00:25.141]         do.call(mapply, args = args)
[11:00:25.141]     }
[11:00:25.141] }
[11:00:25.141] Lazy evaluation: FALSE
[11:00:25.141] Asynchronous evaluation: TRUE
[11:00:25.141] Local evaluation: TRUE
[11:00:25.141] Environment: R_GlobalEnv
[11:00:25.141] Capture standard output: FALSE
[11:00:25.141] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:25.141] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:25.141] Packages: <none>
[11:00:25.141] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:25.141] Resolved: FALSE
[11:00:25.141] Value: <not collected>
[11:00:25.141] Conditions captured: <none>
[11:00:25.141] Early signaling: FALSE
[11:00:25.141] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:25.141] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:25.157] Chunk #1 of 2 ... DONE
[11:00:25.157] Chunk #2 of 2 ...
[11:00:25.158]  - Finding globals in '...' for chunk #2 ...
[11:00:25.158] getGlobalsAndPackages() ...
[11:00:25.159] Searching for globals...
[11:00:25.160] 
[11:00:25.160] Searching for globals ... DONE
[11:00:25.161] - globals: [0] <none>
[11:00:25.161] getGlobalsAndPackages() ... DONE
[11:00:25.161]    + additional globals found: [n=0] 
[11:00:25.161]    + additional namespaces needed: [n=0] 
[11:00:25.162]  - Finding globals in '...' for chunk #2 ... DONE
[11:00:25.162]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:25.162]  - seeds: <none>
[11:00:25.163]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:25.163] getGlobalsAndPackages() ...
[11:00:25.163] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:25.163] Resolving globals: FALSE
[11:00:25.164] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[11:00:25.165] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[11:00:25.165] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:25.165] 
[11:00:25.166] getGlobalsAndPackages() ... DONE
[11:00:25.166] run() for ‘Future’ ...
[11:00:25.166] - state: ‘created’
[11:00:25.166] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:25.169] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:25.169] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:25.169]   - Field: ‘label’
[11:00:25.170]   - Field: ‘local’
[11:00:25.170]   - Field: ‘owner’
[11:00:25.170]   - Field: ‘envir’
[11:00:25.170]   - Field: ‘workers’
[11:00:25.170]   - Field: ‘packages’
[11:00:25.170]   - Field: ‘gc’
[11:00:25.170]   - Field: ‘job’
[11:00:25.170]   - Field: ‘conditions’
[11:00:25.171]   - Field: ‘expr’
[11:00:25.171]   - Field: ‘uuid’
[11:00:25.171]   - Field: ‘seed’
[11:00:25.171]   - Field: ‘version’
[11:00:25.171]   - Field: ‘result’
[11:00:25.171]   - Field: ‘asynchronous’
[11:00:25.171]   - Field: ‘calls’
[11:00:25.171]   - Field: ‘globals’
[11:00:25.172]   - Field: ‘stdout’
[11:00:25.172]   - Field: ‘earlySignal’
[11:00:25.172]   - Field: ‘lazy’
[11:00:25.172]   - Field: ‘state’
[11:00:25.172] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:25.172] - Launch lazy future ...
[11:00:25.173] Packages needed by the future expression (n = 0): <none>
[11:00:25.173] Packages needed by future strategies (n = 0): <none>
[11:00:25.173] {
[11:00:25.173]     {
[11:00:25.173]         {
[11:00:25.173]             ...future.startTime <- base::Sys.time()
[11:00:25.173]             {
[11:00:25.173]                 {
[11:00:25.173]                   {
[11:00:25.173]                     {
[11:00:25.173]                       base::local({
[11:00:25.173]                         has_future <- base::requireNamespace("future", 
[11:00:25.173]                           quietly = TRUE)
[11:00:25.173]                         if (has_future) {
[11:00:25.173]                           ns <- base::getNamespace("future")
[11:00:25.173]                           version <- ns[[".package"]][["version"]]
[11:00:25.173]                           if (is.null(version)) 
[11:00:25.173]                             version <- utils::packageVersion("future")
[11:00:25.173]                         }
[11:00:25.173]                         else {
[11:00:25.173]                           version <- NULL
[11:00:25.173]                         }
[11:00:25.173]                         if (!has_future || version < "1.8.0") {
[11:00:25.173]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:25.173]                             "", base::R.version$version.string), 
[11:00:25.173]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:25.173]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:25.173]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:25.173]                               "release", "version")], collapse = " "), 
[11:00:25.173]                             hostname = base::Sys.info()[["nodename"]])
[11:00:25.173]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:25.173]                             info)
[11:00:25.173]                           info <- base::paste(info, collapse = "; ")
[11:00:25.173]                           if (!has_future) {
[11:00:25.173]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:25.173]                               info)
[11:00:25.173]                           }
[11:00:25.173]                           else {
[11:00:25.173]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:25.173]                               info, version)
[11:00:25.173]                           }
[11:00:25.173]                           base::stop(msg)
[11:00:25.173]                         }
[11:00:25.173]                       })
[11:00:25.173]                     }
[11:00:25.173]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:25.173]                     base::options(mc.cores = 1L)
[11:00:25.173]                   }
[11:00:25.173]                   ...future.strategy.old <- future::plan("list")
[11:00:25.173]                   options(future.plan = NULL)
[11:00:25.173]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:25.173]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:25.173]                 }
[11:00:25.173]                 ...future.workdir <- getwd()
[11:00:25.173]             }
[11:00:25.173]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:25.173]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:25.173]         }
[11:00:25.173]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:25.173]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:25.173]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:25.173]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:25.173]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:25.173]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:25.173]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:25.173]             base::names(...future.oldOptions))
[11:00:25.173]     }
[11:00:25.173]     if (FALSE) {
[11:00:25.173]     }
[11:00:25.173]     else {
[11:00:25.173]         if (FALSE) {
[11:00:25.173]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:25.173]                 open = "w")
[11:00:25.173]         }
[11:00:25.173]         else {
[11:00:25.173]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:25.173]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:25.173]         }
[11:00:25.173]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:25.173]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:25.173]             base::sink(type = "output", split = FALSE)
[11:00:25.173]             base::close(...future.stdout)
[11:00:25.173]         }, add = TRUE)
[11:00:25.173]     }
[11:00:25.173]     ...future.frame <- base::sys.nframe()
[11:00:25.173]     ...future.conditions <- base::list()
[11:00:25.173]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:25.173]     if (FALSE) {
[11:00:25.173]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:25.173]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:25.173]     }
[11:00:25.173]     ...future.result <- base::tryCatch({
[11:00:25.173]         base::withCallingHandlers({
[11:00:25.173]             ...future.value <- base::withVisible(base::local({
[11:00:25.173]                 withCallingHandlers({
[11:00:25.173]                   {
[11:00:25.173]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:25.173]                     if (!identical(...future.globals.maxSize.org, 
[11:00:25.173]                       ...future.globals.maxSize)) {
[11:00:25.173]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:25.173]                       on.exit(options(oopts), add = TRUE)
[11:00:25.173]                     }
[11:00:25.173]                     {
[11:00:25.173]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:25.173]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:00:25.173]                         USE.NAMES = FALSE)
[11:00:25.173]                       do.call(mapply, args = args)
[11:00:25.173]                     }
[11:00:25.173]                   }
[11:00:25.173]                 }, immediateCondition = function(cond) {
[11:00:25.173]                   save_rds <- function (object, pathname, ...) 
[11:00:25.173]                   {
[11:00:25.173]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:25.173]                     if (file_test("-f", pathname_tmp)) {
[11:00:25.173]                       fi_tmp <- file.info(pathname_tmp)
[11:00:25.173]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:25.173]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:25.173]                         fi_tmp[["mtime"]])
[11:00:25.173]                     }
[11:00:25.173]                     tryCatch({
[11:00:25.173]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:25.173]                     }, error = function(ex) {
[11:00:25.173]                       msg <- conditionMessage(ex)
[11:00:25.173]                       fi_tmp <- file.info(pathname_tmp)
[11:00:25.173]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:25.173]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:25.173]                         fi_tmp[["mtime"]], msg)
[11:00:25.173]                       ex$message <- msg
[11:00:25.173]                       stop(ex)
[11:00:25.173]                     })
[11:00:25.173]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:25.173]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:25.173]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:25.173]                       fi_tmp <- file.info(pathname_tmp)
[11:00:25.173]                       fi <- file.info(pathname)
[11:00:25.173]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:25.173]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:25.173]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:25.173]                         fi[["size"]], fi[["mtime"]])
[11:00:25.173]                       stop(msg)
[11:00:25.173]                     }
[11:00:25.173]                     invisible(pathname)
[11:00:25.173]                   }
[11:00:25.173]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:25.173]                     rootPath = tempdir()) 
[11:00:25.173]                   {
[11:00:25.173]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:25.173]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:25.173]                       tmpdir = path, fileext = ".rds")
[11:00:25.173]                     save_rds(obj, file)
[11:00:25.173]                   }
[11:00:25.173]                   saveImmediateCondition(cond, path = "/tmp/RtmpuTAfww/.future/immediateConditions")
[11:00:25.173]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:25.173]                   {
[11:00:25.173]                     inherits <- base::inherits
[11:00:25.173]                     invokeRestart <- base::invokeRestart
[11:00:25.173]                     is.null <- base::is.null
[11:00:25.173]                     muffled <- FALSE
[11:00:25.173]                     if (inherits(cond, "message")) {
[11:00:25.173]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:25.173]                       if (muffled) 
[11:00:25.173]                         invokeRestart("muffleMessage")
[11:00:25.173]                     }
[11:00:25.173]                     else if (inherits(cond, "warning")) {
[11:00:25.173]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:25.173]                       if (muffled) 
[11:00:25.173]                         invokeRestart("muffleWarning")
[11:00:25.173]                     }
[11:00:25.173]                     else if (inherits(cond, "condition")) {
[11:00:25.173]                       if (!is.null(pattern)) {
[11:00:25.173]                         computeRestarts <- base::computeRestarts
[11:00:25.173]                         grepl <- base::grepl
[11:00:25.173]                         restarts <- computeRestarts(cond)
[11:00:25.173]                         for (restart in restarts) {
[11:00:25.173]                           name <- restart$name
[11:00:25.173]                           if (is.null(name)) 
[11:00:25.173]                             next
[11:00:25.173]                           if (!grepl(pattern, name)) 
[11:00:25.173]                             next
[11:00:25.173]                           invokeRestart(restart)
[11:00:25.173]                           muffled <- TRUE
[11:00:25.173]                           break
[11:00:25.173]                         }
[11:00:25.173]                       }
[11:00:25.173]                     }
[11:00:25.173]                     invisible(muffled)
[11:00:25.173]                   }
[11:00:25.173]                   muffleCondition(cond)
[11:00:25.173]                 })
[11:00:25.173]             }))
[11:00:25.173]             future::FutureResult(value = ...future.value$value, 
[11:00:25.173]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:25.173]                   ...future.rng), globalenv = if (FALSE) 
[11:00:25.173]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:25.173]                     ...future.globalenv.names))
[11:00:25.173]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:25.173]         }, condition = base::local({
[11:00:25.173]             c <- base::c
[11:00:25.173]             inherits <- base::inherits
[11:00:25.173]             invokeRestart <- base::invokeRestart
[11:00:25.173]             length <- base::length
[11:00:25.173]             list <- base::list
[11:00:25.173]             seq.int <- base::seq.int
[11:00:25.173]             signalCondition <- base::signalCondition
[11:00:25.173]             sys.calls <- base::sys.calls
[11:00:25.173]             `[[` <- base::`[[`
[11:00:25.173]             `+` <- base::`+`
[11:00:25.173]             `<<-` <- base::`<<-`
[11:00:25.173]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:25.173]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:25.173]                   3L)]
[11:00:25.173]             }
[11:00:25.173]             function(cond) {
[11:00:25.173]                 is_error <- inherits(cond, "error")
[11:00:25.173]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:25.173]                   NULL)
[11:00:25.173]                 if (is_error) {
[11:00:25.173]                   sessionInformation <- function() {
[11:00:25.173]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:25.173]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:25.173]                       search = base::search(), system = base::Sys.info())
[11:00:25.173]                   }
[11:00:25.173]                   ...future.conditions[[length(...future.conditions) + 
[11:00:25.173]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:25.173]                     cond$call), session = sessionInformation(), 
[11:00:25.173]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:25.173]                   signalCondition(cond)
[11:00:25.173]                 }
[11:00:25.173]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:25.173]                 "immediateCondition"))) {
[11:00:25.173]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:25.173]                   ...future.conditions[[length(...future.conditions) + 
[11:00:25.173]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:25.173]                   if (TRUE && !signal) {
[11:00:25.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:25.173]                     {
[11:00:25.173]                       inherits <- base::inherits
[11:00:25.173]                       invokeRestart <- base::invokeRestart
[11:00:25.173]                       is.null <- base::is.null
[11:00:25.173]                       muffled <- FALSE
[11:00:25.173]                       if (inherits(cond, "message")) {
[11:00:25.173]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:25.173]                         if (muffled) 
[11:00:25.173]                           invokeRestart("muffleMessage")
[11:00:25.173]                       }
[11:00:25.173]                       else if (inherits(cond, "warning")) {
[11:00:25.173]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:25.173]                         if (muffled) 
[11:00:25.173]                           invokeRestart("muffleWarning")
[11:00:25.173]                       }
[11:00:25.173]                       else if (inherits(cond, "condition")) {
[11:00:25.173]                         if (!is.null(pattern)) {
[11:00:25.173]                           computeRestarts <- base::computeRestarts
[11:00:25.173]                           grepl <- base::grepl
[11:00:25.173]                           restarts <- computeRestarts(cond)
[11:00:25.173]                           for (restart in restarts) {
[11:00:25.173]                             name <- restart$name
[11:00:25.173]                             if (is.null(name)) 
[11:00:25.173]                               next
[11:00:25.173]                             if (!grepl(pattern, name)) 
[11:00:25.173]                               next
[11:00:25.173]                             invokeRestart(restart)
[11:00:25.173]                             muffled <- TRUE
[11:00:25.173]                             break
[11:00:25.173]                           }
[11:00:25.173]                         }
[11:00:25.173]                       }
[11:00:25.173]                       invisible(muffled)
[11:00:25.173]                     }
[11:00:25.173]                     muffleCondition(cond, pattern = "^muffle")
[11:00:25.173]                   }
[11:00:25.173]                 }
[11:00:25.173]                 else {
[11:00:25.173]                   if (TRUE) {
[11:00:25.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:25.173]                     {
[11:00:25.173]                       inherits <- base::inherits
[11:00:25.173]                       invokeRestart <- base::invokeRestart
[11:00:25.173]                       is.null <- base::is.null
[11:00:25.173]                       muffled <- FALSE
[11:00:25.173]                       if (inherits(cond, "message")) {
[11:00:25.173]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:25.173]                         if (muffled) 
[11:00:25.173]                           invokeRestart("muffleMessage")
[11:00:25.173]                       }
[11:00:25.173]                       else if (inherits(cond, "warning")) {
[11:00:25.173]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:25.173]                         if (muffled) 
[11:00:25.173]                           invokeRestart("muffleWarning")
[11:00:25.173]                       }
[11:00:25.173]                       else if (inherits(cond, "condition")) {
[11:00:25.173]                         if (!is.null(pattern)) {
[11:00:25.173]                           computeRestarts <- base::computeRestarts
[11:00:25.173]                           grepl <- base::grepl
[11:00:25.173]                           restarts <- computeRestarts(cond)
[11:00:25.173]                           for (restart in restarts) {
[11:00:25.173]                             name <- restart$name
[11:00:25.173]                             if (is.null(name)) 
[11:00:25.173]                               next
[11:00:25.173]                             if (!grepl(pattern, name)) 
[11:00:25.173]                               next
[11:00:25.173]                             invokeRestart(restart)
[11:00:25.173]                             muffled <- TRUE
[11:00:25.173]                             break
[11:00:25.173]                           }
[11:00:25.173]                         }
[11:00:25.173]                       }
[11:00:25.173]                       invisible(muffled)
[11:00:25.173]                     }
[11:00:25.173]                     muffleCondition(cond, pattern = "^muffle")
[11:00:25.173]                   }
[11:00:25.173]                 }
[11:00:25.173]             }
[11:00:25.173]         }))
[11:00:25.173]     }, error = function(ex) {
[11:00:25.173]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:25.173]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:25.173]                 ...future.rng), started = ...future.startTime, 
[11:00:25.173]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:25.173]             version = "1.8"), class = "FutureResult")
[11:00:25.173]     }, finally = {
[11:00:25.173]         if (!identical(...future.workdir, getwd())) 
[11:00:25.173]             setwd(...future.workdir)
[11:00:25.173]         {
[11:00:25.173]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:25.173]                 ...future.oldOptions$nwarnings <- NULL
[11:00:25.173]             }
[11:00:25.173]             base::options(...future.oldOptions)
[11:00:25.173]             if (.Platform$OS.type == "windows") {
[11:00:25.173]                 old_names <- names(...future.oldEnvVars)
[11:00:25.173]                 envs <- base::Sys.getenv()
[11:00:25.173]                 names <- names(envs)
[11:00:25.173]                 common <- intersect(names, old_names)
[11:00:25.173]                 added <- setdiff(names, old_names)
[11:00:25.173]                 removed <- setdiff(old_names, names)
[11:00:25.173]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:25.173]                   envs[common]]
[11:00:25.173]                 NAMES <- toupper(changed)
[11:00:25.173]                 args <- list()
[11:00:25.173]                 for (kk in seq_along(NAMES)) {
[11:00:25.173]                   name <- changed[[kk]]
[11:00:25.173]                   NAME <- NAMES[[kk]]
[11:00:25.173]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:25.173]                     next
[11:00:25.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:25.173]                 }
[11:00:25.173]                 NAMES <- toupper(added)
[11:00:25.173]                 for (kk in seq_along(NAMES)) {
[11:00:25.173]                   name <- added[[kk]]
[11:00:25.173]                   NAME <- NAMES[[kk]]
[11:00:25.173]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:25.173]                     next
[11:00:25.173]                   args[[name]] <- ""
[11:00:25.173]                 }
[11:00:25.173]                 NAMES <- toupper(removed)
[11:00:25.173]                 for (kk in seq_along(NAMES)) {
[11:00:25.173]                   name <- removed[[kk]]
[11:00:25.173]                   NAME <- NAMES[[kk]]
[11:00:25.173]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:25.173]                     next
[11:00:25.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:25.173]                 }
[11:00:25.173]                 if (length(args) > 0) 
[11:00:25.173]                   base::do.call(base::Sys.setenv, args = args)
[11:00:25.173]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:25.173]             }
[11:00:25.173]             else {
[11:00:25.173]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:25.173]             }
[11:00:25.173]             {
[11:00:25.173]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:25.173]                   0L) {
[11:00:25.173]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:25.173]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:25.173]                   base::options(opts)
[11:00:25.173]                 }
[11:00:25.173]                 {
[11:00:25.173]                   {
[11:00:25.173]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:25.173]                     NULL
[11:00:25.173]                   }
[11:00:25.173]                   options(future.plan = NULL)
[11:00:25.173]                   if (is.na(NA_character_)) 
[11:00:25.173]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:25.173]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:25.173]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:25.173]                     .init = FALSE)
[11:00:25.173]                 }
[11:00:25.173]             }
[11:00:25.173]         }
[11:00:25.173]     })
[11:00:25.173]     if (TRUE) {
[11:00:25.173]         base::sink(type = "output", split = FALSE)
[11:00:25.173]         if (FALSE) {
[11:00:25.173]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:25.173]         }
[11:00:25.173]         else {
[11:00:25.173]             ...future.result["stdout"] <- base::list(NULL)
[11:00:25.173]         }
[11:00:25.173]         base::close(...future.stdout)
[11:00:25.173]         ...future.stdout <- NULL
[11:00:25.173]     }
[11:00:25.173]     ...future.result$conditions <- ...future.conditions
[11:00:25.173]     ...future.result$finished <- base::Sys.time()
[11:00:25.173]     ...future.result
[11:00:25.173] }
[11:00:25.176] assign_globals() ...
[11:00:25.176] List of 5
[11:00:25.176]  $ ...future.FUN            :function (x, y)  
[11:00:25.176]  $ MoreArgs                 : NULL
[11:00:25.176]  $ ...future.elements_ii    :List of 2
[11:00:25.176]   ..$ :List of 1
[11:00:25.176]   .. ..$ : int 0
[11:00:25.176]   ..$ :List of 1
[11:00:25.176]   .. ..$ : int 1
[11:00:25.176]  $ ...future.seeds_ii       : NULL
[11:00:25.176]  $ ...future.globals.maxSize: NULL
[11:00:25.176]  - attr(*, "where")=List of 5
[11:00:25.176]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:25.176]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[11:00:25.176]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:25.176]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:25.176]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:25.176]  - attr(*, "resolved")= logi FALSE
[11:00:25.176]  - attr(*, "total_size")= num 1218
[11:00:25.176]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:25.176]  - attr(*, "already-done")= logi TRUE
[11:00:25.183] - reassign environment for ‘...future.FUN’
[11:00:25.183] - copied ‘...future.FUN’ to environment
[11:00:25.183] - copied ‘MoreArgs’ to environment
[11:00:25.183] - copied ‘...future.elements_ii’ to environment
[11:00:25.183] - copied ‘...future.seeds_ii’ to environment
[11:00:25.183] - copied ‘...future.globals.maxSize’ to environment
[11:00:25.183] assign_globals() ... done
[11:00:25.184] requestCore(): workers = 2
[11:00:25.186] MulticoreFuture started
[11:00:25.186] - Launch lazy future ... done
[11:00:25.186] run() for ‘MulticoreFuture’ ... done
[11:00:25.186] Created future:
[11:00:25.187] plan(): Setting new future strategy stack:
[11:00:25.187] List of future strategies:
[11:00:25.187] 1. sequential:
[11:00:25.187]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:25.187]    - tweaked: FALSE
[11:00:25.187]    - call: NULL
[11:00:25.188] plan(): nbrOfWorkers() = 1
[11:00:25.190] plan(): Setting new future strategy stack:
[11:00:25.190] List of future strategies:
[11:00:25.190] 1. multicore:
[11:00:25.190]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:25.190]    - tweaked: FALSE
[11:00:25.190]    - call: plan(strategy)
[11:00:25.193] plan(): nbrOfWorkers() = 2
[11:00:25.186] MulticoreFuture:
[11:00:25.186] Label: ‘future_mapply-2’
[11:00:25.186] Expression:
[11:00:25.186] {
[11:00:25.186]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:25.186]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:25.186]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:25.186]         on.exit(options(oopts), add = TRUE)
[11:00:25.186]     }
[11:00:25.186]     {
[11:00:25.186]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:25.186]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:00:25.186]         do.call(mapply, args = args)
[11:00:25.186]     }
[11:00:25.186] }
[11:00:25.186] Lazy evaluation: FALSE
[11:00:25.186] Asynchronous evaluation: TRUE
[11:00:25.186] Local evaluation: TRUE
[11:00:25.186] Environment: R_GlobalEnv
[11:00:25.186] Capture standard output: FALSE
[11:00:25.186] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:25.186] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:25.186] Packages: <none>
[11:00:25.186] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:25.186] Resolved: TRUE
[11:00:25.186] Value: <not collected>
[11:00:25.186] Conditions captured: <none>
[11:00:25.186] Early signaling: FALSE
[11:00:25.186] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:25.186] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:25.194] Chunk #2 of 2 ... DONE
[11:00:25.194] Launching 2 futures (chunks) ... DONE
[11:00:25.194] Resolving 2 futures (chunks) ...
[11:00:25.195] resolve() on list ...
[11:00:25.195]  recursive: 0
[11:00:25.195]  length: 2
[11:00:25.195] 
[11:00:25.206] Future #2
[11:00:25.206] result() for MulticoreFuture ...
[11:00:25.207] result() for MulticoreFuture ...
[11:00:25.207] result() for MulticoreFuture ... done
[11:00:25.207] result() for MulticoreFuture ... done
[11:00:25.207] result() for MulticoreFuture ...
[11:00:25.207] result() for MulticoreFuture ... done
[11:00:25.207] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:00:25.208] - nx: 2
[11:00:25.208] - relay: TRUE
[11:00:25.208] - stdout: TRUE
[11:00:25.208] - signal: TRUE
[11:00:25.208] - resignal: FALSE
[11:00:25.208] - force: TRUE
[11:00:25.208] - relayed: [n=2] FALSE, FALSE
[11:00:25.209] - queued futures: [n=2] FALSE, FALSE
[11:00:25.209]  - until=1
[11:00:25.209]  - relaying element #1
[11:00:25.209] - relayed: [n=2] FALSE, FALSE
[11:00:25.209] - queued futures: [n=2] FALSE, TRUE
[11:00:25.209] signalConditionsASAP(NULL, pos=2) ... done
[11:00:25.209]  length: 1 (resolved future 2)
[11:00:25.648] plan(): Setting new future strategy stack:
[11:00:25.649] List of future strategies:
[11:00:25.649] 1. multicore:
[11:00:25.649]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:25.649]    - tweaked: FALSE
[11:00:25.649]    - call: plan(strategy)
[11:00:25.652] plan(): nbrOfWorkers() = 2
[11:00:25.652] Future #1
[11:00:25.655] result() for MulticoreFuture ...
[11:00:25.656] result() for MulticoreFuture ...
[11:00:25.656] result() for MulticoreFuture ... done
[11:00:25.656] result() for MulticoreFuture ... done
[11:00:25.656] result() for MulticoreFuture ...
[11:00:25.656] result() for MulticoreFuture ... done
[11:00:25.657] signalConditionsASAP(MulticoreFuture, pos=1) ...
[11:00:25.657] - nx: 2
[11:00:25.657] - relay: TRUE
[11:00:25.657] - stdout: TRUE
[11:00:25.657] - signal: TRUE
[11:00:25.658] - resignal: FALSE
[11:00:25.658] - force: TRUE
[11:00:25.658] - relayed: [n=2] FALSE, FALSE
[11:00:25.658] - queued futures: [n=2] FALSE, TRUE
[11:00:25.658]  - until=1
[11:00:25.658]  - relaying element #1
[11:00:25.658] result() for MulticoreFuture ...
[11:00:25.659] result() for MulticoreFuture ... done
[11:00:25.659] result() for MulticoreFuture ...
[11:00:25.659] result() for MulticoreFuture ... done
[11:00:25.659] result() for MulticoreFuture ...
[11:00:25.659] result() for MulticoreFuture ... done
[11:00:25.659] result() for MulticoreFuture ...
[11:00:25.659] result() for MulticoreFuture ... done
[11:00:25.659] - relayed: [n=2] TRUE, FALSE
[11:00:25.660] - queued futures: [n=2] TRUE, TRUE
[11:00:25.660] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[11:00:25.660]  length: 0 (resolved future 1)
[11:00:25.660] Relaying remaining futures
[11:00:25.660] signalConditionsASAP(NULL, pos=0) ...
[11:00:25.660] - nx: 2
[11:00:25.660] - relay: TRUE
[11:00:25.660] - stdout: TRUE
[11:00:25.660] - signal: TRUE
[11:00:25.661] - resignal: FALSE
[11:00:25.661] - force: TRUE
[11:00:25.661] - relayed: [n=2] TRUE, FALSE
[11:00:25.661] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:25.661]  - relaying element #2
[11:00:25.661] result() for MulticoreFuture ...
[11:00:25.661] result() for MulticoreFuture ... done
[11:00:25.661] result() for MulticoreFuture ...
[11:00:25.661] result() for MulticoreFuture ... done
[11:00:25.662] result() for MulticoreFuture ...
[11:00:25.662] result() for MulticoreFuture ... done
[11:00:25.662] result() for MulticoreFuture ...
[11:00:25.662] result() for MulticoreFuture ... done
[11:00:25.662] - relayed: [n=2] TRUE, TRUE
[11:00:25.662] - queued futures: [n=2] TRUE, TRUE
[11:00:25.662] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[11:00:25.662] resolve() on list ... DONE
[11:00:25.662] result() for MulticoreFuture ...
[11:00:25.663] result() for MulticoreFuture ... done
[11:00:25.663] result() for MulticoreFuture ...
[11:00:25.663] result() for MulticoreFuture ... done
[11:00:25.663] result() for MulticoreFuture ...
[11:00:25.663] result() for MulticoreFuture ... done
[11:00:25.663] result() for MulticoreFuture ...
[11:00:25.663] result() for MulticoreFuture ... done
[11:00:25.663]  - Number of value chunks collected: 2
[11:00:25.663] Resolving 2 futures (chunks) ... DONE
[11:00:25.664] Reducing values from 2 chunks ...
[11:00:25.664]  - Number of values collected after concatenation: 2
[11:00:25.664]  - Number of values expected: 2
[11:00:25.664] Reducing values from 2 chunks ... DONE
[11:00:25.664] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[11:00:25.664] future_mapply() ...
[11:00:25.667] Number of chunks: 2
[11:00:25.667] getGlobalsAndPackagesXApply() ...
[11:00:25.667]  - future.globals: TRUE
[11:00:25.667] getGlobalsAndPackages() ...
[11:00:25.667] Searching for globals...
[11:00:25.669] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[11:00:25.669] Searching for globals ... DONE
[11:00:25.669] Resolving globals: FALSE
[11:00:25.670] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[11:00:25.670] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[11:00:25.670] - globals: [1] ‘FUN’
[11:00:25.670] 
[11:00:25.670] getGlobalsAndPackages() ... DONE
[11:00:25.670]  - globals found/used: [n=1] ‘FUN’
[11:00:25.670]  - needed namespaces: [n=0] 
[11:00:25.671] Finding globals ... DONE
[11:00:25.671] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[11:00:25.671] List of 2
[11:00:25.671]  $ ...future.FUN:function (x, y)  
[11:00:25.671]  $ MoreArgs     : NULL
[11:00:25.671]  - attr(*, "where")=List of 2
[11:00:25.671]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:25.671]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[11:00:25.671]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:25.671]  - attr(*, "resolved")= logi FALSE
[11:00:25.671]  - attr(*, "total_size")= num NA
[11:00:25.674] Packages to be attached in all futures: [n=0] 
[11:00:25.674] getGlobalsAndPackagesXApply() ... DONE
[11:00:25.674] Number of futures (= number of chunks): 2
[11:00:25.674] Launching 2 futures (chunks) ...
[11:00:25.674] Chunk #1 of 2 ...
[11:00:25.674]  - Finding globals in '...' for chunk #1 ...
[11:00:25.674] getGlobalsAndPackages() ...
[11:00:25.675] Searching for globals...
[11:00:25.675] 
[11:00:25.675] Searching for globals ... DONE
[11:00:25.675] - globals: [0] <none>
[11:00:25.675] getGlobalsAndPackages() ... DONE
[11:00:25.675]    + additional globals found: [n=0] 
[11:00:25.675]    + additional namespaces needed: [n=0] 
[11:00:25.675]  - Finding globals in '...' for chunk #1 ... DONE
[11:00:25.675]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:25.676]  - seeds: <none>
[11:00:25.676]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:25.676] getGlobalsAndPackages() ...
[11:00:25.676] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:25.676] Resolving globals: FALSE
[11:00:25.676] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[11:00:25.677] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[11:00:25.677] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:25.677] 
[11:00:25.677] getGlobalsAndPackages() ... DONE
[11:00:25.677] run() for ‘Future’ ...
[11:00:25.677] - state: ‘created’
[11:00:25.678] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:25.679] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:25.679] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:25.679]   - Field: ‘label’
[11:00:25.680]   - Field: ‘local’
[11:00:25.680]   - Field: ‘owner’
[11:00:25.680]   - Field: ‘envir’
[11:00:25.680]   - Field: ‘workers’
[11:00:25.681]   - Field: ‘packages’
[11:00:25.681]   - Field: ‘gc’
[11:00:25.681]   - Field: ‘job’
[11:00:25.681]   - Field: ‘conditions’
[11:00:25.682]   - Field: ‘expr’
[11:00:25.682]   - Field: ‘uuid’
[11:00:25.682]   - Field: ‘seed’
[11:00:25.682]   - Field: ‘version’
[11:00:25.682]   - Field: ‘result’
[11:00:25.682]   - Field: ‘asynchronous’
[11:00:25.682]   - Field: ‘calls’
[11:00:25.682]   - Field: ‘globals’
[11:00:25.682]   - Field: ‘stdout’
[11:00:25.682]   - Field: ‘earlySignal’
[11:00:25.683]   - Field: ‘lazy’
[11:00:25.683]   - Field: ‘state’
[11:00:25.683] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:25.683] - Launch lazy future ...
[11:00:25.683] Packages needed by the future expression (n = 0): <none>
[11:00:25.683] Packages needed by future strategies (n = 0): <none>
[11:00:25.684] {
[11:00:25.684]     {
[11:00:25.684]         {
[11:00:25.684]             ...future.startTime <- base::Sys.time()
[11:00:25.684]             {
[11:00:25.684]                 {
[11:00:25.684]                   {
[11:00:25.684]                     {
[11:00:25.684]                       base::local({
[11:00:25.684]                         has_future <- base::requireNamespace("future", 
[11:00:25.684]                           quietly = TRUE)
[11:00:25.684]                         if (has_future) {
[11:00:25.684]                           ns <- base::getNamespace("future")
[11:00:25.684]                           version <- ns[[".package"]][["version"]]
[11:00:25.684]                           if (is.null(version)) 
[11:00:25.684]                             version <- utils::packageVersion("future")
[11:00:25.684]                         }
[11:00:25.684]                         else {
[11:00:25.684]                           version <- NULL
[11:00:25.684]                         }
[11:00:25.684]                         if (!has_future || version < "1.8.0") {
[11:00:25.684]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:25.684]                             "", base::R.version$version.string), 
[11:00:25.684]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:25.684]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:25.684]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:25.684]                               "release", "version")], collapse = " "), 
[11:00:25.684]                             hostname = base::Sys.info()[["nodename"]])
[11:00:25.684]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:25.684]                             info)
[11:00:25.684]                           info <- base::paste(info, collapse = "; ")
[11:00:25.684]                           if (!has_future) {
[11:00:25.684]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:25.684]                               info)
[11:00:25.684]                           }
[11:00:25.684]                           else {
[11:00:25.684]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:25.684]                               info, version)
[11:00:25.684]                           }
[11:00:25.684]                           base::stop(msg)
[11:00:25.684]                         }
[11:00:25.684]                       })
[11:00:25.684]                     }
[11:00:25.684]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:25.684]                     base::options(mc.cores = 1L)
[11:00:25.684]                   }
[11:00:25.684]                   ...future.strategy.old <- future::plan("list")
[11:00:25.684]                   options(future.plan = NULL)
[11:00:25.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:25.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:25.684]                 }
[11:00:25.684]                 ...future.workdir <- getwd()
[11:00:25.684]             }
[11:00:25.684]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:25.684]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:25.684]         }
[11:00:25.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:25.684]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:25.684]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:25.684]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:25.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:25.684]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:25.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:25.684]             base::names(...future.oldOptions))
[11:00:25.684]     }
[11:00:25.684]     if (FALSE) {
[11:00:25.684]     }
[11:00:25.684]     else {
[11:00:25.684]         if (TRUE) {
[11:00:25.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:25.684]                 open = "w")
[11:00:25.684]         }
[11:00:25.684]         else {
[11:00:25.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:25.684]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:25.684]         }
[11:00:25.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:25.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:25.684]             base::sink(type = "output", split = FALSE)
[11:00:25.684]             base::close(...future.stdout)
[11:00:25.684]         }, add = TRUE)
[11:00:25.684]     }
[11:00:25.684]     ...future.frame <- base::sys.nframe()
[11:00:25.684]     ...future.conditions <- base::list()
[11:00:25.684]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:25.684]     if (FALSE) {
[11:00:25.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:25.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:25.684]     }
[11:00:25.684]     ...future.result <- base::tryCatch({
[11:00:25.684]         base::withCallingHandlers({
[11:00:25.684]             ...future.value <- base::withVisible(base::local({
[11:00:25.684]                 withCallingHandlers({
[11:00:25.684]                   {
[11:00:25.684]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:25.684]                     if (!identical(...future.globals.maxSize.org, 
[11:00:25.684]                       ...future.globals.maxSize)) {
[11:00:25.684]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:25.684]                       on.exit(options(oopts), add = TRUE)
[11:00:25.684]                     }
[11:00:25.684]                     {
[11:00:25.684]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:25.684]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:00:25.684]                         USE.NAMES = FALSE)
[11:00:25.684]                       do.call(mapply, args = args)
[11:00:25.684]                     }
[11:00:25.684]                   }
[11:00:25.684]                 }, immediateCondition = function(cond) {
[11:00:25.684]                   save_rds <- function (object, pathname, ...) 
[11:00:25.684]                   {
[11:00:25.684]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:25.684]                     if (file_test("-f", pathname_tmp)) {
[11:00:25.684]                       fi_tmp <- file.info(pathname_tmp)
[11:00:25.684]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:25.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:25.684]                         fi_tmp[["mtime"]])
[11:00:25.684]                     }
[11:00:25.684]                     tryCatch({
[11:00:25.684]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:25.684]                     }, error = function(ex) {
[11:00:25.684]                       msg <- conditionMessage(ex)
[11:00:25.684]                       fi_tmp <- file.info(pathname_tmp)
[11:00:25.684]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:25.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:25.684]                         fi_tmp[["mtime"]], msg)
[11:00:25.684]                       ex$message <- msg
[11:00:25.684]                       stop(ex)
[11:00:25.684]                     })
[11:00:25.684]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:25.684]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:25.684]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:25.684]                       fi_tmp <- file.info(pathname_tmp)
[11:00:25.684]                       fi <- file.info(pathname)
[11:00:25.684]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:25.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:25.684]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:25.684]                         fi[["size"]], fi[["mtime"]])
[11:00:25.684]                       stop(msg)
[11:00:25.684]                     }
[11:00:25.684]                     invisible(pathname)
[11:00:25.684]                   }
[11:00:25.684]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:25.684]                     rootPath = tempdir()) 
[11:00:25.684]                   {
[11:00:25.684]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:25.684]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:25.684]                       tmpdir = path, fileext = ".rds")
[11:00:25.684]                     save_rds(obj, file)
[11:00:25.684]                   }
[11:00:25.684]                   saveImmediateCondition(cond, path = "/tmp/RtmpuTAfww/.future/immediateConditions")
[11:00:25.684]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:25.684]                   {
[11:00:25.684]                     inherits <- base::inherits
[11:00:25.684]                     invokeRestart <- base::invokeRestart
[11:00:25.684]                     is.null <- base::is.null
[11:00:25.684]                     muffled <- FALSE
[11:00:25.684]                     if (inherits(cond, "message")) {
[11:00:25.684]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:25.684]                       if (muffled) 
[11:00:25.684]                         invokeRestart("muffleMessage")
[11:00:25.684]                     }
[11:00:25.684]                     else if (inherits(cond, "warning")) {
[11:00:25.684]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:25.684]                       if (muffled) 
[11:00:25.684]                         invokeRestart("muffleWarning")
[11:00:25.684]                     }
[11:00:25.684]                     else if (inherits(cond, "condition")) {
[11:00:25.684]                       if (!is.null(pattern)) {
[11:00:25.684]                         computeRestarts <- base::computeRestarts
[11:00:25.684]                         grepl <- base::grepl
[11:00:25.684]                         restarts <- computeRestarts(cond)
[11:00:25.684]                         for (restart in restarts) {
[11:00:25.684]                           name <- restart$name
[11:00:25.684]                           if (is.null(name)) 
[11:00:25.684]                             next
[11:00:25.684]                           if (!grepl(pattern, name)) 
[11:00:25.684]                             next
[11:00:25.684]                           invokeRestart(restart)
[11:00:25.684]                           muffled <- TRUE
[11:00:25.684]                           break
[11:00:25.684]                         }
[11:00:25.684]                       }
[11:00:25.684]                     }
[11:00:25.684]                     invisible(muffled)
[11:00:25.684]                   }
[11:00:25.684]                   muffleCondition(cond)
[11:00:25.684]                 })
[11:00:25.684]             }))
[11:00:25.684]             future::FutureResult(value = ...future.value$value, 
[11:00:25.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:25.684]                   ...future.rng), globalenv = if (FALSE) 
[11:00:25.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:25.684]                     ...future.globalenv.names))
[11:00:25.684]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:25.684]         }, condition = base::local({
[11:00:25.684]             c <- base::c
[11:00:25.684]             inherits <- base::inherits
[11:00:25.684]             invokeRestart <- base::invokeRestart
[11:00:25.684]             length <- base::length
[11:00:25.684]             list <- base::list
[11:00:25.684]             seq.int <- base::seq.int
[11:00:25.684]             signalCondition <- base::signalCondition
[11:00:25.684]             sys.calls <- base::sys.calls
[11:00:25.684]             `[[` <- base::`[[`
[11:00:25.684]             `+` <- base::`+`
[11:00:25.684]             `<<-` <- base::`<<-`
[11:00:25.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:25.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:25.684]                   3L)]
[11:00:25.684]             }
[11:00:25.684]             function(cond) {
[11:00:25.684]                 is_error <- inherits(cond, "error")
[11:00:25.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:25.684]                   NULL)
[11:00:25.684]                 if (is_error) {
[11:00:25.684]                   sessionInformation <- function() {
[11:00:25.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:25.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:25.684]                       search = base::search(), system = base::Sys.info())
[11:00:25.684]                   }
[11:00:25.684]                   ...future.conditions[[length(...future.conditions) + 
[11:00:25.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:25.684]                     cond$call), session = sessionInformation(), 
[11:00:25.684]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:25.684]                   signalCondition(cond)
[11:00:25.684]                 }
[11:00:25.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:25.684]                 "immediateCondition"))) {
[11:00:25.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:25.684]                   ...future.conditions[[length(...future.conditions) + 
[11:00:25.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:25.684]                   if (TRUE && !signal) {
[11:00:25.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:25.684]                     {
[11:00:25.684]                       inherits <- base::inherits
[11:00:25.684]                       invokeRestart <- base::invokeRestart
[11:00:25.684]                       is.null <- base::is.null
[11:00:25.684]                       muffled <- FALSE
[11:00:25.684]                       if (inherits(cond, "message")) {
[11:00:25.684]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:25.684]                         if (muffled) 
[11:00:25.684]                           invokeRestart("muffleMessage")
[11:00:25.684]                       }
[11:00:25.684]                       else if (inherits(cond, "warning")) {
[11:00:25.684]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:25.684]                         if (muffled) 
[11:00:25.684]                           invokeRestart("muffleWarning")
[11:00:25.684]                       }
[11:00:25.684]                       else if (inherits(cond, "condition")) {
[11:00:25.684]                         if (!is.null(pattern)) {
[11:00:25.684]                           computeRestarts <- base::computeRestarts
[11:00:25.684]                           grepl <- base::grepl
[11:00:25.684]                           restarts <- computeRestarts(cond)
[11:00:25.684]                           for (restart in restarts) {
[11:00:25.684]                             name <- restart$name
[11:00:25.684]                             if (is.null(name)) 
[11:00:25.684]                               next
[11:00:25.684]                             if (!grepl(pattern, name)) 
[11:00:25.684]                               next
[11:00:25.684]                             invokeRestart(restart)
[11:00:25.684]                             muffled <- TRUE
[11:00:25.684]                             break
[11:00:25.684]                           }
[11:00:25.684]                         }
[11:00:25.684]                       }
[11:00:25.684]                       invisible(muffled)
[11:00:25.684]                     }
[11:00:25.684]                     muffleCondition(cond, pattern = "^muffle")
[11:00:25.684]                   }
[11:00:25.684]                 }
[11:00:25.684]                 else {
[11:00:25.684]                   if (TRUE) {
[11:00:25.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:25.684]                     {
[11:00:25.684]                       inherits <- base::inherits
[11:00:25.684]                       invokeRestart <- base::invokeRestart
[11:00:25.684]                       is.null <- base::is.null
[11:00:25.684]                       muffled <- FALSE
[11:00:25.684]                       if (inherits(cond, "message")) {
[11:00:25.684]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:25.684]                         if (muffled) 
[11:00:25.684]                           invokeRestart("muffleMessage")
[11:00:25.684]                       }
[11:00:25.684]                       else if (inherits(cond, "warning")) {
[11:00:25.684]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:25.684]                         if (muffled) 
[11:00:25.684]                           invokeRestart("muffleWarning")
[11:00:25.684]                       }
[11:00:25.684]                       else if (inherits(cond, "condition")) {
[11:00:25.684]                         if (!is.null(pattern)) {
[11:00:25.684]                           computeRestarts <- base::computeRestarts
[11:00:25.684]                           grepl <- base::grepl
[11:00:25.684]                           restarts <- computeRestarts(cond)
[11:00:25.684]                           for (restart in restarts) {
[11:00:25.684]                             name <- restart$name
[11:00:25.684]                             if (is.null(name)) 
[11:00:25.684]                               next
[11:00:25.684]                             if (!grepl(pattern, name)) 
[11:00:25.684]                               next
[11:00:25.684]                             invokeRestart(restart)
[11:00:25.684]                             muffled <- TRUE
[11:00:25.684]                             break
[11:00:25.684]                           }
[11:00:25.684]                         }
[11:00:25.684]                       }
[11:00:25.684]                       invisible(muffled)
[11:00:25.684]                     }
[11:00:25.684]                     muffleCondition(cond, pattern = "^muffle")
[11:00:25.684]                   }
[11:00:25.684]                 }
[11:00:25.684]             }
[11:00:25.684]         }))
[11:00:25.684]     }, error = function(ex) {
[11:00:25.684]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:25.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:25.684]                 ...future.rng), started = ...future.startTime, 
[11:00:25.684]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:25.684]             version = "1.8"), class = "FutureResult")
[11:00:25.684]     }, finally = {
[11:00:25.684]         if (!identical(...future.workdir, getwd())) 
[11:00:25.684]             setwd(...future.workdir)
[11:00:25.684]         {
[11:00:25.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:25.684]                 ...future.oldOptions$nwarnings <- NULL
[11:00:25.684]             }
[11:00:25.684]             base::options(...future.oldOptions)
[11:00:25.684]             if (.Platform$OS.type == "windows") {
[11:00:25.684]                 old_names <- names(...future.oldEnvVars)
[11:00:25.684]                 envs <- base::Sys.getenv()
[11:00:25.684]                 names <- names(envs)
[11:00:25.684]                 common <- intersect(names, old_names)
[11:00:25.684]                 added <- setdiff(names, old_names)
[11:00:25.684]                 removed <- setdiff(old_names, names)
[11:00:25.684]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:25.684]                   envs[common]]
[11:00:25.684]                 NAMES <- toupper(changed)
[11:00:25.684]                 args <- list()
[11:00:25.684]                 for (kk in seq_along(NAMES)) {
[11:00:25.684]                   name <- changed[[kk]]
[11:00:25.684]                   NAME <- NAMES[[kk]]
[11:00:25.684]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:25.684]                     next
[11:00:25.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:25.684]                 }
[11:00:25.684]                 NAMES <- toupper(added)
[11:00:25.684]                 for (kk in seq_along(NAMES)) {
[11:00:25.684]                   name <- added[[kk]]
[11:00:25.684]                   NAME <- NAMES[[kk]]
[11:00:25.684]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:25.684]                     next
[11:00:25.684]                   args[[name]] <- ""
[11:00:25.684]                 }
[11:00:25.684]                 NAMES <- toupper(removed)
[11:00:25.684]                 for (kk in seq_along(NAMES)) {
[11:00:25.684]                   name <- removed[[kk]]
[11:00:25.684]                   NAME <- NAMES[[kk]]
[11:00:25.684]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:25.684]                     next
[11:00:25.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:25.684]                 }
[11:00:25.684]                 if (length(args) > 0) 
[11:00:25.684]                   base::do.call(base::Sys.setenv, args = args)
[11:00:25.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:25.684]             }
[11:00:25.684]             else {
[11:00:25.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:25.684]             }
[11:00:25.684]             {
[11:00:25.684]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:25.684]                   0L) {
[11:00:25.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:25.684]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:25.684]                   base::options(opts)
[11:00:25.684]                 }
[11:00:25.684]                 {
[11:00:25.684]                   {
[11:00:25.684]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:25.684]                     NULL
[11:00:25.684]                   }
[11:00:25.684]                   options(future.plan = NULL)
[11:00:25.684]                   if (is.na(NA_character_)) 
[11:00:25.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:25.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:25.684]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:25.684]                     .init = FALSE)
[11:00:25.684]                 }
[11:00:25.684]             }
[11:00:25.684]         }
[11:00:25.684]     })
[11:00:25.684]     if (TRUE) {
[11:00:25.684]         base::sink(type = "output", split = FALSE)
[11:00:25.684]         if (TRUE) {
[11:00:25.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:25.684]         }
[11:00:25.684]         else {
[11:00:25.684]             ...future.result["stdout"] <- base::list(NULL)
[11:00:25.684]         }
[11:00:25.684]         base::close(...future.stdout)
[11:00:25.684]         ...future.stdout <- NULL
[11:00:25.684]     }
[11:00:25.684]     ...future.result$conditions <- ...future.conditions
[11:00:25.684]     ...future.result$finished <- base::Sys.time()
[11:00:25.684]     ...future.result
[11:00:25.684] }
[11:00:25.686] assign_globals() ...
[11:00:25.686] List of 5
[11:00:25.686]  $ ...future.FUN            :function (x, y)  
[11:00:25.686]  $ MoreArgs                 : NULL
[11:00:25.686]  $ ...future.elements_ii    :List of 2
[11:00:25.686]   ..$ :List of 1
[11:00:25.686]   .. ..$ : int 1
[11:00:25.686]   ..$ :List of 1
[11:00:25.686]   .. ..$ : int 0
[11:00:25.686]  $ ...future.seeds_ii       : NULL
[11:00:25.686]  $ ...future.globals.maxSize: NULL
[11:00:25.686]  - attr(*, "where")=List of 5
[11:00:25.686]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:25.686]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[11:00:25.686]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:25.686]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:25.686]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:25.686]  - attr(*, "resolved")= logi FALSE
[11:00:25.686]  - attr(*, "total_size")= num 1218
[11:00:25.686]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:25.686]  - attr(*, "already-done")= logi TRUE
[11:00:25.691] - reassign environment for ‘...future.FUN’
[11:00:25.691] - copied ‘...future.FUN’ to environment
[11:00:25.691] - copied ‘MoreArgs’ to environment
[11:00:25.691] - copied ‘...future.elements_ii’ to environment
[11:00:25.691] - copied ‘...future.seeds_ii’ to environment
[11:00:25.691] - copied ‘...future.globals.maxSize’ to environment
[11:00:25.691] assign_globals() ... done
[11:00:25.691] requestCore(): workers = 2
[11:00:25.693] MulticoreFuture started
[11:00:25.694] - Launch lazy future ... done
[11:00:25.694] run() for ‘MulticoreFuture’ ... done
[11:00:25.694] Created future:
[11:00:25.694] plan(): Setting new future strategy stack:
[11:00:25.695] List of future strategies:
[11:00:25.695] 1. sequential:
[11:00:25.695]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:25.695]    - tweaked: FALSE
[11:00:25.695]    - call: NULL
[11:00:25.696] plan(): nbrOfWorkers() = 1
[11:00:25.694] MulticoreFuture:
[11:00:25.694] Label: ‘future_mapply-1’
[11:00:25.694] Expression:
[11:00:25.694] {
[11:00:25.694]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:25.694]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:25.694]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:25.694]         on.exit(options(oopts), add = TRUE)
[11:00:25.694]     }
[11:00:25.694]     {
[11:00:25.694]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:25.694]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:00:25.694]         do.call(mapply, args = args)
[11:00:25.694]     }
[11:00:25.694] }
[11:00:25.694] Lazy evaluation: FALSE
[11:00:25.694] Asynchronous evaluation: TRUE
[11:00:25.694] Local evaluation: TRUE
[11:00:25.694] Environment: R_GlobalEnv
[11:00:25.694] Capture standard output: TRUE
[11:00:25.694] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:25.694] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:25.694] Packages: <none>
[11:00:25.694] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:25.694] Resolved: FALSE
[11:00:25.694] Value: <not collected>
[11:00:25.694] Conditions captured: <none>
[11:00:25.694] Early signaling: FALSE
[11:00:25.694] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:25.694] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:25.707] Chunk #1 of 2 ... DONE
[11:00:25.707] Chunk #2 of 2 ...
[11:00:25.707]  - Finding globals in '...' for chunk #2 ...
[11:00:25.707] getGlobalsAndPackages() ...
[11:00:25.707] Searching for globals...
[11:00:25.708] 
[11:00:25.708] Searching for globals ... DONE
[11:00:25.708] - globals: [0] <none>
[11:00:25.709] getGlobalsAndPackages() ... DONE
[11:00:25.709]    + additional globals found: [n=0] 
[11:00:25.709]    + additional namespaces needed: [n=0] 
[11:00:25.709]  - Finding globals in '...' for chunk #2 ... DONE
[11:00:25.709]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:25.709]  - seeds: <none>
[11:00:25.709]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:25.710] getGlobalsAndPackages() ...
[11:00:25.710] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:25.710] Resolving globals: FALSE
[11:00:25.711] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[11:00:25.712] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[11:00:25.712] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:25.712] 
[11:00:25.712] getGlobalsAndPackages() ... DONE
[11:00:25.713] run() for ‘Future’ ...
[11:00:25.713] - state: ‘created’
[11:00:25.713] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:25.716] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:25.716] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:25.716]   - Field: ‘label’
[11:00:25.716]   - Field: ‘local’
[11:00:25.716]   - Field: ‘owner’
[11:00:25.717]   - Field: ‘envir’
[11:00:25.717]   - Field: ‘workers’
[11:00:25.717]   - Field: ‘packages’
[11:00:25.717]   - Field: ‘gc’
[11:00:25.717]   - Field: ‘job’
[11:00:25.717]   - Field: ‘conditions’
[11:00:25.717]   - Field: ‘expr’
[11:00:25.718]   - Field: ‘uuid’
[11:00:25.718]   - Field: ‘seed’
[11:00:25.718]   - Field: ‘version’
[11:00:25.718]   - Field: ‘result’
[11:00:25.718]   - Field: ‘asynchronous’
[11:00:25.718]   - Field: ‘calls’
[11:00:25.718]   - Field: ‘globals’
[11:00:25.718]   - Field: ‘stdout’
[11:00:25.719]   - Field: ‘earlySignal’
[11:00:25.719]   - Field: ‘lazy’
[11:00:25.719]   - Field: ‘state’
[11:00:25.719] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:25.719] - Launch lazy future ...
[11:00:25.720] Packages needed by the future expression (n = 0): <none>
[11:00:25.720] Packages needed by future strategies (n = 0): <none>
[11:00:25.720] {
[11:00:25.720]     {
[11:00:25.720]         {
[11:00:25.720]             ...future.startTime <- base::Sys.time()
[11:00:25.720]             {
[11:00:25.720]                 {
[11:00:25.720]                   {
[11:00:25.720]                     {
[11:00:25.720]                       base::local({
[11:00:25.720]                         has_future <- base::requireNamespace("future", 
[11:00:25.720]                           quietly = TRUE)
[11:00:25.720]                         if (has_future) {
[11:00:25.720]                           ns <- base::getNamespace("future")
[11:00:25.720]                           version <- ns[[".package"]][["version"]]
[11:00:25.720]                           if (is.null(version)) 
[11:00:25.720]                             version <- utils::packageVersion("future")
[11:00:25.720]                         }
[11:00:25.720]                         else {
[11:00:25.720]                           version <- NULL
[11:00:25.720]                         }
[11:00:25.720]                         if (!has_future || version < "1.8.0") {
[11:00:25.720]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:25.720]                             "", base::R.version$version.string), 
[11:00:25.720]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:25.720]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:25.720]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:25.720]                               "release", "version")], collapse = " "), 
[11:00:25.720]                             hostname = base::Sys.info()[["nodename"]])
[11:00:25.720]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:25.720]                             info)
[11:00:25.720]                           info <- base::paste(info, collapse = "; ")
[11:00:25.720]                           if (!has_future) {
[11:00:25.720]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:25.720]                               info)
[11:00:25.720]                           }
[11:00:25.720]                           else {
[11:00:25.720]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:25.720]                               info, version)
[11:00:25.720]                           }
[11:00:25.720]                           base::stop(msg)
[11:00:25.720]                         }
[11:00:25.720]                       })
[11:00:25.720]                     }
[11:00:25.720]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:25.720]                     base::options(mc.cores = 1L)
[11:00:25.720]                   }
[11:00:25.720]                   ...future.strategy.old <- future::plan("list")
[11:00:25.720]                   options(future.plan = NULL)
[11:00:25.720]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:25.720]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:25.720]                 }
[11:00:25.720]                 ...future.workdir <- getwd()
[11:00:25.720]             }
[11:00:25.720]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:25.720]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:25.720]         }
[11:00:25.720]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:25.720]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:25.720]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:25.720]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:25.720]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:25.720]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:25.720]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:25.720]             base::names(...future.oldOptions))
[11:00:25.720]     }
[11:00:25.720]     if (FALSE) {
[11:00:25.720]     }
[11:00:25.720]     else {
[11:00:25.720]         if (TRUE) {
[11:00:25.720]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:25.720]                 open = "w")
[11:00:25.720]         }
[11:00:25.720]         else {
[11:00:25.720]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:25.720]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:25.720]         }
[11:00:25.720]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:25.720]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:25.720]             base::sink(type = "output", split = FALSE)
[11:00:25.720]             base::close(...future.stdout)
[11:00:25.720]         }, add = TRUE)
[11:00:25.720]     }
[11:00:25.720]     ...future.frame <- base::sys.nframe()
[11:00:25.720]     ...future.conditions <- base::list()
[11:00:25.720]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:25.720]     if (FALSE) {
[11:00:25.720]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:25.720]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:25.720]     }
[11:00:25.720]     ...future.result <- base::tryCatch({
[11:00:25.720]         base::withCallingHandlers({
[11:00:25.720]             ...future.value <- base::withVisible(base::local({
[11:00:25.720]                 withCallingHandlers({
[11:00:25.720]                   {
[11:00:25.720]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:25.720]                     if (!identical(...future.globals.maxSize.org, 
[11:00:25.720]                       ...future.globals.maxSize)) {
[11:00:25.720]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:25.720]                       on.exit(options(oopts), add = TRUE)
[11:00:25.720]                     }
[11:00:25.720]                     {
[11:00:25.720]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:25.720]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:00:25.720]                         USE.NAMES = FALSE)
[11:00:25.720]                       do.call(mapply, args = args)
[11:00:25.720]                     }
[11:00:25.720]                   }
[11:00:25.720]                 }, immediateCondition = function(cond) {
[11:00:25.720]                   save_rds <- function (object, pathname, ...) 
[11:00:25.720]                   {
[11:00:25.720]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:25.720]                     if (file_test("-f", pathname_tmp)) {
[11:00:25.720]                       fi_tmp <- file.info(pathname_tmp)
[11:00:25.720]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:25.720]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:25.720]                         fi_tmp[["mtime"]])
[11:00:25.720]                     }
[11:00:25.720]                     tryCatch({
[11:00:25.720]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:25.720]                     }, error = function(ex) {
[11:00:25.720]                       msg <- conditionMessage(ex)
[11:00:25.720]                       fi_tmp <- file.info(pathname_tmp)
[11:00:25.720]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:25.720]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:25.720]                         fi_tmp[["mtime"]], msg)
[11:00:25.720]                       ex$message <- msg
[11:00:25.720]                       stop(ex)
[11:00:25.720]                     })
[11:00:25.720]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:25.720]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:25.720]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:25.720]                       fi_tmp <- file.info(pathname_tmp)
[11:00:25.720]                       fi <- file.info(pathname)
[11:00:25.720]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:25.720]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:25.720]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:25.720]                         fi[["size"]], fi[["mtime"]])
[11:00:25.720]                       stop(msg)
[11:00:25.720]                     }
[11:00:25.720]                     invisible(pathname)
[11:00:25.720]                   }
[11:00:25.720]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:25.720]                     rootPath = tempdir()) 
[11:00:25.720]                   {
[11:00:25.720]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:25.720]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:25.720]                       tmpdir = path, fileext = ".rds")
[11:00:25.720]                     save_rds(obj, file)
[11:00:25.720]                   }
[11:00:25.720]                   saveImmediateCondition(cond, path = "/tmp/RtmpuTAfww/.future/immediateConditions")
[11:00:25.720]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:25.720]                   {
[11:00:25.720]                     inherits <- base::inherits
[11:00:25.720]                     invokeRestart <- base::invokeRestart
[11:00:25.720]                     is.null <- base::is.null
[11:00:25.720]                     muffled <- FALSE
[11:00:25.720]                     if (inherits(cond, "message")) {
[11:00:25.720]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:25.720]                       if (muffled) 
[11:00:25.720]                         invokeRestart("muffleMessage")
[11:00:25.720]                     }
[11:00:25.720]                     else if (inherits(cond, "warning")) {
[11:00:25.720]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:25.720]                       if (muffled) 
[11:00:25.720]                         invokeRestart("muffleWarning")
[11:00:25.720]                     }
[11:00:25.720]                     else if (inherits(cond, "condition")) {
[11:00:25.720]                       if (!is.null(pattern)) {
[11:00:25.720]                         computeRestarts <- base::computeRestarts
[11:00:25.720]                         grepl <- base::grepl
[11:00:25.720]                         restarts <- computeRestarts(cond)
[11:00:25.720]                         for (restart in restarts) {
[11:00:25.720]                           name <- restart$name
[11:00:25.720]                           if (is.null(name)) 
[11:00:25.720]                             next
[11:00:25.720]                           if (!grepl(pattern, name)) 
[11:00:25.720]                             next
[11:00:25.720]                           invokeRestart(restart)
[11:00:25.720]                           muffled <- TRUE
[11:00:25.720]                           break
[11:00:25.720]                         }
[11:00:25.720]                       }
[11:00:25.720]                     }
[11:00:25.720]                     invisible(muffled)
[11:00:25.720]                   }
[11:00:25.720]                   muffleCondition(cond)
[11:00:25.720]                 })
[11:00:25.720]             }))
[11:00:25.720]             future::FutureResult(value = ...future.value$value, 
[11:00:25.720]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:25.720]                   ...future.rng), globalenv = if (FALSE) 
[11:00:25.720]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:25.720]                     ...future.globalenv.names))
[11:00:25.720]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:25.720]         }, condition = base::local({
[11:00:25.720]             c <- base::c
[11:00:25.720]             inherits <- base::inherits
[11:00:25.720]             invokeRestart <- base::invokeRestart
[11:00:25.720]             length <- base::length
[11:00:25.720]             list <- base::list
[11:00:25.720]             seq.int <- base::seq.int
[11:00:25.720]             signalCondition <- base::signalCondition
[11:00:25.720]             sys.calls <- base::sys.calls
[11:00:25.720]             `[[` <- base::`[[`
[11:00:25.720]             `+` <- base::`+`
[11:00:25.720]             `<<-` <- base::`<<-`
[11:00:25.720]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:25.720]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:25.720]                   3L)]
[11:00:25.720]             }
[11:00:25.720]             function(cond) {
[11:00:25.720]                 is_error <- inherits(cond, "error")
[11:00:25.720]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:25.720]                   NULL)
[11:00:25.720]                 if (is_error) {
[11:00:25.720]                   sessionInformation <- function() {
[11:00:25.720]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:25.720]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:25.720]                       search = base::search(), system = base::Sys.info())
[11:00:25.720]                   }
[11:00:25.720]                   ...future.conditions[[length(...future.conditions) + 
[11:00:25.720]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:25.720]                     cond$call), session = sessionInformation(), 
[11:00:25.720]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:25.720]                   signalCondition(cond)
[11:00:25.720]                 }
[11:00:25.720]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:25.720]                 "immediateCondition"))) {
[11:00:25.720]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:25.720]                   ...future.conditions[[length(...future.conditions) + 
[11:00:25.720]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:25.720]                   if (TRUE && !signal) {
[11:00:25.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:25.720]                     {
[11:00:25.720]                       inherits <- base::inherits
[11:00:25.720]                       invokeRestart <- base::invokeRestart
[11:00:25.720]                       is.null <- base::is.null
[11:00:25.720]                       muffled <- FALSE
[11:00:25.720]                       if (inherits(cond, "message")) {
[11:00:25.720]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:25.720]                         if (muffled) 
[11:00:25.720]                           invokeRestart("muffleMessage")
[11:00:25.720]                       }
[11:00:25.720]                       else if (inherits(cond, "warning")) {
[11:00:25.720]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:25.720]                         if (muffled) 
[11:00:25.720]                           invokeRestart("muffleWarning")
[11:00:25.720]                       }
[11:00:25.720]                       else if (inherits(cond, "condition")) {
[11:00:25.720]                         if (!is.null(pattern)) {
[11:00:25.720]                           computeRestarts <- base::computeRestarts
[11:00:25.720]                           grepl <- base::grepl
[11:00:25.720]                           restarts <- computeRestarts(cond)
[11:00:25.720]                           for (restart in restarts) {
[11:00:25.720]                             name <- restart$name
[11:00:25.720]                             if (is.null(name)) 
[11:00:25.720]                               next
[11:00:25.720]                             if (!grepl(pattern, name)) 
[11:00:25.720]                               next
[11:00:25.720]                             invokeRestart(restart)
[11:00:25.720]                             muffled <- TRUE
[11:00:25.720]                             break
[11:00:25.720]                           }
[11:00:25.720]                         }
[11:00:25.720]                       }
[11:00:25.720]                       invisible(muffled)
[11:00:25.720]                     }
[11:00:25.720]                     muffleCondition(cond, pattern = "^muffle")
[11:00:25.720]                   }
[11:00:25.720]                 }
[11:00:25.720]                 else {
[11:00:25.720]                   if (TRUE) {
[11:00:25.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:25.720]                     {
[11:00:25.720]                       inherits <- base::inherits
[11:00:25.720]                       invokeRestart <- base::invokeRestart
[11:00:25.720]                       is.null <- base::is.null
[11:00:25.720]                       muffled <- FALSE
[11:00:25.720]                       if (inherits(cond, "message")) {
[11:00:25.720]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:25.720]                         if (muffled) 
[11:00:25.720]                           invokeRestart("muffleMessage")
[11:00:25.720]                       }
[11:00:25.720]                       else if (inherits(cond, "warning")) {
[11:00:25.720]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:25.720]                         if (muffled) 
[11:00:25.720]                           invokeRestart("muffleWarning")
[11:00:25.720]                       }
[11:00:25.720]                       else if (inherits(cond, "condition")) {
[11:00:25.720]                         if (!is.null(pattern)) {
[11:00:25.720]                           computeRestarts <- base::computeRestarts
[11:00:25.720]                           grepl <- base::grepl
[11:00:25.720]                           restarts <- computeRestarts(cond)
[11:00:25.720]                           for (restart in restarts) {
[11:00:25.720]                             name <- restart$name
[11:00:25.720]                             if (is.null(name)) 
[11:00:25.720]                               next
[11:00:25.720]                             if (!grepl(pattern, name)) 
[11:00:25.720]                               next
[11:00:25.720]                             invokeRestart(restart)
[11:00:25.720]                             muffled <- TRUE
[11:00:25.720]                             break
[11:00:25.720]                           }
[11:00:25.720]                         }
[11:00:25.720]                       }
[11:00:25.720]                       invisible(muffled)
[11:00:25.720]                     }
[11:00:25.720]                     muffleCondition(cond, pattern = "^muffle")
[11:00:25.720]                   }
[11:00:25.720]                 }
[11:00:25.720]             }
[11:00:25.720]         }))
[11:00:25.720]     }, error = function(ex) {
[11:00:25.720]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:25.720]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:25.720]                 ...future.rng), started = ...future.startTime, 
[11:00:25.720]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:25.720]             version = "1.8"), class = "FutureResult")
[11:00:25.720]     }, finally = {
[11:00:25.720]         if (!identical(...future.workdir, getwd())) 
[11:00:25.720]             setwd(...future.workdir)
[11:00:25.720]         {
[11:00:25.720]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:25.720]                 ...future.oldOptions$nwarnings <- NULL
[11:00:25.720]             }
[11:00:25.720]             base::options(...future.oldOptions)
[11:00:25.720]             if (.Platform$OS.type == "windows") {
[11:00:25.720]                 old_names <- names(...future.oldEnvVars)
[11:00:25.720]                 envs <- base::Sys.getenv()
[11:00:25.720]                 names <- names(envs)
[11:00:25.720]                 common <- intersect(names, old_names)
[11:00:25.720]                 added <- setdiff(names, old_names)
[11:00:25.720]                 removed <- setdiff(old_names, names)
[11:00:25.720]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:25.720]                   envs[common]]
[11:00:25.720]                 NAMES <- toupper(changed)
[11:00:25.720]                 args <- list()
[11:00:25.720]                 for (kk in seq_along(NAMES)) {
[11:00:25.720]                   name <- changed[[kk]]
[11:00:25.720]                   NAME <- NAMES[[kk]]
[11:00:25.720]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:25.720]                     next
[11:00:25.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:25.720]                 }
[11:00:25.720]                 NAMES <- toupper(added)
[11:00:25.720]                 for (kk in seq_along(NAMES)) {
[11:00:25.720]                   name <- added[[kk]]
[11:00:25.720]                   NAME <- NAMES[[kk]]
[11:00:25.720]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:25.720]                     next
[11:00:25.720]                   args[[name]] <- ""
[11:00:25.720]                 }
[11:00:25.720]                 NAMES <- toupper(removed)
[11:00:25.720]                 for (kk in seq_along(NAMES)) {
[11:00:25.720]                   name <- removed[[kk]]
[11:00:25.720]                   NAME <- NAMES[[kk]]
[11:00:25.720]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:25.720]                     next
[11:00:25.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:25.720]                 }
[11:00:25.720]                 if (length(args) > 0) 
[11:00:25.720]                   base::do.call(base::Sys.setenv, args = args)
[11:00:25.720]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:25.720]             }
[11:00:25.720]             else {
[11:00:25.720]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:25.720]             }
[11:00:25.720]             {
[11:00:25.720]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:25.720]                   0L) {
[11:00:25.720]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:25.720]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:25.720]                   base::options(opts)
[11:00:25.720]                 }
[11:00:25.720]                 {
[11:00:25.720]                   {
[11:00:25.720]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:25.720]                     NULL
[11:00:25.720]                   }
[11:00:25.720]                   options(future.plan = NULL)
[11:00:25.720]                   if (is.na(NA_character_)) 
[11:00:25.720]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:25.720]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:25.720]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:25.720]                     .init = FALSE)
[11:00:25.720]                 }
[11:00:25.720]             }
[11:00:25.720]         }
[11:00:25.720]     })
[11:00:25.720]     if (TRUE) {
[11:00:25.720]         base::sink(type = "output", split = FALSE)
[11:00:25.720]         if (TRUE) {
[11:00:25.720]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:25.720]         }
[11:00:25.720]         else {
[11:00:25.720]             ...future.result["stdout"] <- base::list(NULL)
[11:00:25.720]         }
[11:00:25.720]         base::close(...future.stdout)
[11:00:25.720]         ...future.stdout <- NULL
[11:00:25.720]     }
[11:00:25.720]     ...future.result$conditions <- ...future.conditions
[11:00:25.720]     ...future.result$finished <- base::Sys.time()
[11:00:25.720]     ...future.result
[11:00:25.720] }
[11:00:25.723] assign_globals() ...
[11:00:25.724] List of 5
[11:00:25.724]  $ ...future.FUN            :function (x, y)  
[11:00:25.724]  $ MoreArgs                 : NULL
[11:00:25.724]  $ ...future.elements_ii    :List of 2
[11:00:25.724]   ..$ :List of 1
[11:00:25.724]   .. ..$ : int 0
[11:00:25.724]   ..$ :List of 1
[11:00:25.724]   .. ..$ : int 1
[11:00:25.724]  $ ...future.seeds_ii       : NULL
[11:00:25.724]  $ ...future.globals.maxSize: NULL
[11:00:25.724]  - attr(*, "where")=List of 5
[11:00:25.724]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:25.724]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[11:00:25.724]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:25.724]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:25.724]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:25.724]  - attr(*, "resolved")= logi FALSE
[11:00:25.724]  - attr(*, "total_size")= num 1218
[11:00:25.724]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:25.724]  - attr(*, "already-done")= logi TRUE
[11:00:25.736] - reassign environment for ‘...future.FUN’
[11:00:25.736] - copied ‘...future.FUN’ to environment
[11:00:25.736] - copied ‘MoreArgs’ to environment
[11:00:25.736] - copied ‘...future.elements_ii’ to environment
[11:00:25.736] - copied ‘...future.seeds_ii’ to environment
[11:00:25.736] - copied ‘...future.globals.maxSize’ to environment
[11:00:25.736] assign_globals() ... done
[11:00:25.737] requestCore(): workers = 2
[11:00:25.739] MulticoreFuture started
[11:00:25.739] - Launch lazy future ... done
[11:00:25.740] run() for ‘MulticoreFuture’ ... done
[11:00:25.740] Created future:
[11:00:25.740] plan(): Setting new future strategy stack:
[11:00:25.740] List of future strategies:
[11:00:25.740] 1. sequential:
[11:00:25.740]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:25.740]    - tweaked: FALSE
[11:00:25.740]    - call: NULL
[11:00:25.741] plan(): nbrOfWorkers() = 1
[11:00:25.743] plan(): Setting new future strategy stack:
[11:00:25.744] List of future strategies:
[11:00:25.744] 1. multicore:
[11:00:25.744]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:25.744]    - tweaked: FALSE
[11:00:25.744]    - call: plan(strategy)
[11:00:25.747] plan(): nbrOfWorkers() = 2
[11:00:25.740] MulticoreFuture:
[11:00:25.740] Label: ‘future_mapply-2’
[11:00:25.740] Expression:
[11:00:25.740] {
[11:00:25.740]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:25.740]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:25.740]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:25.740]         on.exit(options(oopts), add = TRUE)
[11:00:25.740]     }
[11:00:25.740]     {
[11:00:25.740]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:25.740]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:00:25.740]         do.call(mapply, args = args)
[11:00:25.740]     }
[11:00:25.740] }
[11:00:25.740] Lazy evaluation: FALSE
[11:00:25.740] Asynchronous evaluation: TRUE
[11:00:25.740] Local evaluation: TRUE
[11:00:25.740] Environment: R_GlobalEnv
[11:00:25.740] Capture standard output: TRUE
[11:00:25.740] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:25.740] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:25.740] Packages: <none>
[11:00:25.740] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:25.740] Resolved: TRUE
[11:00:25.740] Value: <not collected>
[11:00:25.740] Conditions captured: <none>
[11:00:25.740] Early signaling: FALSE
[11:00:25.740] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:25.740] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:25.748] Chunk #2 of 2 ... DONE
[11:00:25.748] Launching 2 futures (chunks) ... DONE
[11:00:25.748] Resolving 2 futures (chunks) ...
[11:00:25.748] resolve() on list ...
[11:00:25.748]  recursive: 0
[11:00:25.749]  length: 2
[11:00:25.749] 
[11:00:25.759] Future #2
[11:00:25.760] result() for MulticoreFuture ...
[11:00:25.761] result() for MulticoreFuture ...
[11:00:25.761] result() for MulticoreFuture ... done
[11:00:25.761] result() for MulticoreFuture ... done
[11:00:25.761] result() for MulticoreFuture ...
[11:00:25.761] result() for MulticoreFuture ... done
[11:00:25.761] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:00:25.762] - nx: 2
[11:00:25.762] - relay: TRUE
[11:00:25.762] - stdout: TRUE
[11:00:25.762] - signal: TRUE
[11:00:25.762] - resignal: FALSE
[11:00:25.762] - force: TRUE
[11:00:25.762] - relayed: [n=2] FALSE, FALSE
[11:00:25.762] - queued futures: [n=2] FALSE, FALSE
[11:00:25.762]  - until=1
[11:00:25.763]  - relaying element #1
[11:00:25.763] - relayed: [n=2] FALSE, FALSE
[11:00:25.763] - queued futures: [n=2] FALSE, TRUE
[11:00:25.763] signalConditionsASAP(NULL, pos=2) ... done
[11:00:25.763]  length: 1 (resolved future 2)
[11:00:26.198] plan(): Setting new future strategy stack:
[11:00:26.199] List of future strategies:
[11:00:26.199] 1. multicore:
[11:00:26.199]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:26.199]    - tweaked: FALSE
[11:00:26.199]    - call: plan(strategy)
[11:00:26.201] plan(): nbrOfWorkers() = 2
[11:00:26.201] Future #1
[11:00:26.202] result() for MulticoreFuture ...
[11:00:26.202] result() for MulticoreFuture ...
[11:00:26.202] result() for MulticoreFuture ... done
[11:00:26.203] result() for MulticoreFuture ... done
[11:00:26.203] result() for MulticoreFuture ...
[11:00:26.203] result() for MulticoreFuture ... done
[11:00:26.203] signalConditionsASAP(MulticoreFuture, pos=1) ...
[11:00:26.203] - nx: 2
[11:00:26.203] - relay: TRUE
[11:00:26.203] - stdout: TRUE
[11:00:26.203] - signal: TRUE
[11:00:26.203] - resignal: FALSE
[11:00:26.204] - force: TRUE
[11:00:26.204] - relayed: [n=2] FALSE, FALSE
[11:00:26.204] - queued futures: [n=2] FALSE, TRUE
[11:00:26.204]  - until=1
[11:00:26.204]  - relaying element #1
[11:00:26.204] result() for MulticoreFuture ...
[11:00:26.204] result() for MulticoreFuture ... done
[11:00:26.204] result() for MulticoreFuture ...
[11:00:26.204] result() for MulticoreFuture ... done
[11:00:26.205] result() for MulticoreFuture ...
[11:00:26.205] result() for MulticoreFuture ... done
[11:00:26.205] result() for MulticoreFuture ...
[11:00:26.205] result() for MulticoreFuture ... done
[11:00:26.205] - relayed: [n=2] TRUE, FALSE
[11:00:26.205] - queued futures: [n=2] TRUE, TRUE
[11:00:26.205] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[11:00:26.205]  length: 0 (resolved future 1)
[11:00:26.206] Relaying remaining futures
[11:00:26.206] signalConditionsASAP(NULL, pos=0) ...
[11:00:26.206] - nx: 2
[11:00:26.206] - relay: TRUE
[11:00:26.206] - stdout: TRUE
[11:00:26.206] - signal: TRUE
[11:00:26.206] - resignal: FALSE
[11:00:26.206] - force: TRUE
[11:00:26.206] - relayed: [n=2] TRUE, FALSE
[11:00:26.206] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:26.207]  - relaying element #2
[11:00:26.207] result() for MulticoreFuture ...
[11:00:26.207] result() for MulticoreFuture ... done
[11:00:26.207] result() for MulticoreFuture ...
[11:00:26.207] result() for MulticoreFuture ... done
[11:00:26.207] result() for MulticoreFuture ...
[11:00:26.207] result() for MulticoreFuture ... done
[11:00:26.207] result() for MulticoreFuture ...
[11:00:26.208] result() for MulticoreFuture ... done
[11:00:26.208] - relayed: [n=2] TRUE, TRUE
[11:00:26.208] - queued futures: [n=2] TRUE, TRUE
[11:00:26.208] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[11:00:26.208] resolve() on list ... DONE
[11:00:26.208] result() for MulticoreFuture ...
[11:00:26.208] result() for MulticoreFuture ... done
[11:00:26.208] result() for MulticoreFuture ...
[11:00:26.208] result() for MulticoreFuture ... done
[11:00:26.209] result() for MulticoreFuture ...
[11:00:26.209] result() for MulticoreFuture ... done
[11:00:26.209] result() for MulticoreFuture ...
[11:00:26.209] result() for MulticoreFuture ... done
[11:00:26.209]  - Number of value chunks collected: 2
[11:00:26.209] Resolving 2 futures (chunks) ... DONE
[11:00:26.209] Reducing values from 2 chunks ...
[11:00:26.209]  - Number of values collected after concatenation: 2
[11:00:26.209]  - Number of values expected: 2
[11:00:26.210] Reducing values from 2 chunks ... DONE
[11:00:26.210] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[11:00:26.210] future_mapply() ...
[11:00:26.212] Number of chunks: 2
[11:00:26.213] getGlobalsAndPackagesXApply() ...
[11:00:26.213]  - future.globals: TRUE
[11:00:26.213] getGlobalsAndPackages() ...
[11:00:26.213] Searching for globals...
[11:00:26.220] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[11:00:26.221] Searching for globals ... DONE
[11:00:26.221] Resolving globals: FALSE
[11:00:26.221] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[11:00:26.222] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[11:00:26.222] - globals: [1] ‘FUN’
[11:00:26.222] 
[11:00:26.222] getGlobalsAndPackages() ... DONE
[11:00:26.222]  - globals found/used: [n=1] ‘FUN’
[11:00:26.222]  - needed namespaces: [n=0] 
[11:00:26.222] Finding globals ... DONE
[11:00:26.223] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[11:00:26.223] List of 2
[11:00:26.223]  $ ...future.FUN:function (x, y)  
[11:00:26.223]  $ MoreArgs     : NULL
[11:00:26.223]  - attr(*, "where")=List of 2
[11:00:26.223]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:26.223]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[11:00:26.223]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:26.223]  - attr(*, "resolved")= logi FALSE
[11:00:26.223]  - attr(*, "total_size")= num NA
[11:00:26.226] Packages to be attached in all futures: [n=0] 
[11:00:26.226] getGlobalsAndPackagesXApply() ... DONE
[11:00:26.226] Number of futures (= number of chunks): 2
[11:00:26.226] Launching 2 futures (chunks) ...
[11:00:26.226] Chunk #1 of 2 ...
[11:00:26.226]  - Finding globals in '...' for chunk #1 ...
[11:00:26.226] getGlobalsAndPackages() ...
[11:00:26.227] Searching for globals...
[11:00:26.227] 
[11:00:26.227] Searching for globals ... DONE
[11:00:26.227] - globals: [0] <none>
[11:00:26.227] getGlobalsAndPackages() ... DONE
[11:00:26.227]    + additional globals found: [n=0] 
[11:00:26.227]    + additional namespaces needed: [n=0] 
[11:00:26.227]  - Finding globals in '...' for chunk #1 ... DONE
[11:00:26.228]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:26.228]  - seeds: <none>
[11:00:26.228]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:26.228] getGlobalsAndPackages() ...
[11:00:26.228] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:26.228] Resolving globals: FALSE
[11:00:26.228] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[11:00:26.229] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[11:00:26.229] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:26.229] 
[11:00:26.229] getGlobalsAndPackages() ... DONE
[11:00:26.229] run() for ‘Future’ ...
[11:00:26.230] - state: ‘created’
[11:00:26.230] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:26.231] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:26.231] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:26.232]   - Field: ‘label’
[11:00:26.232]   - Field: ‘local’
[11:00:26.232]   - Field: ‘owner’
[11:00:26.232]   - Field: ‘envir’
[11:00:26.232]   - Field: ‘workers’
[11:00:26.232]   - Field: ‘packages’
[11:00:26.232]   - Field: ‘gc’
[11:00:26.232]   - Field: ‘job’
[11:00:26.232]   - Field: ‘conditions’
[11:00:26.232]   - Field: ‘expr’
[11:00:26.232]   - Field: ‘uuid’
[11:00:26.233]   - Field: ‘seed’
[11:00:26.233]   - Field: ‘version’
[11:00:26.233]   - Field: ‘result’
[11:00:26.233]   - Field: ‘asynchronous’
[11:00:26.233]   - Field: ‘calls’
[11:00:26.233]   - Field: ‘globals’
[11:00:26.233]   - Field: ‘stdout’
[11:00:26.233]   - Field: ‘earlySignal’
[11:00:26.233]   - Field: ‘lazy’
[11:00:26.233]   - Field: ‘state’
[11:00:26.233] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:26.234] - Launch lazy future ...
[11:00:26.234] Packages needed by the future expression (n = 0): <none>
[11:00:26.234] Packages needed by future strategies (n = 0): <none>
[11:00:26.234] {
[11:00:26.234]     {
[11:00:26.234]         {
[11:00:26.234]             ...future.startTime <- base::Sys.time()
[11:00:26.234]             {
[11:00:26.234]                 {
[11:00:26.234]                   {
[11:00:26.234]                     {
[11:00:26.234]                       base::local({
[11:00:26.234]                         has_future <- base::requireNamespace("future", 
[11:00:26.234]                           quietly = TRUE)
[11:00:26.234]                         if (has_future) {
[11:00:26.234]                           ns <- base::getNamespace("future")
[11:00:26.234]                           version <- ns[[".package"]][["version"]]
[11:00:26.234]                           if (is.null(version)) 
[11:00:26.234]                             version <- utils::packageVersion("future")
[11:00:26.234]                         }
[11:00:26.234]                         else {
[11:00:26.234]                           version <- NULL
[11:00:26.234]                         }
[11:00:26.234]                         if (!has_future || version < "1.8.0") {
[11:00:26.234]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:26.234]                             "", base::R.version$version.string), 
[11:00:26.234]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:26.234]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:26.234]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:26.234]                               "release", "version")], collapse = " "), 
[11:00:26.234]                             hostname = base::Sys.info()[["nodename"]])
[11:00:26.234]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:26.234]                             info)
[11:00:26.234]                           info <- base::paste(info, collapse = "; ")
[11:00:26.234]                           if (!has_future) {
[11:00:26.234]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:26.234]                               info)
[11:00:26.234]                           }
[11:00:26.234]                           else {
[11:00:26.234]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:26.234]                               info, version)
[11:00:26.234]                           }
[11:00:26.234]                           base::stop(msg)
[11:00:26.234]                         }
[11:00:26.234]                       })
[11:00:26.234]                     }
[11:00:26.234]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:26.234]                     base::options(mc.cores = 1L)
[11:00:26.234]                   }
[11:00:26.234]                   ...future.strategy.old <- future::plan("list")
[11:00:26.234]                   options(future.plan = NULL)
[11:00:26.234]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:26.234]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:26.234]                 }
[11:00:26.234]                 ...future.workdir <- getwd()
[11:00:26.234]             }
[11:00:26.234]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:26.234]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:26.234]         }
[11:00:26.234]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:26.234]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:26.234]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:26.234]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:26.234]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:26.234]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:26.234]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:26.234]             base::names(...future.oldOptions))
[11:00:26.234]     }
[11:00:26.234]     if (TRUE) {
[11:00:26.234]     }
[11:00:26.234]     else {
[11:00:26.234]         if (NA) {
[11:00:26.234]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:26.234]                 open = "w")
[11:00:26.234]         }
[11:00:26.234]         else {
[11:00:26.234]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:26.234]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:26.234]         }
[11:00:26.234]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:26.234]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:26.234]             base::sink(type = "output", split = FALSE)
[11:00:26.234]             base::close(...future.stdout)
[11:00:26.234]         }, add = TRUE)
[11:00:26.234]     }
[11:00:26.234]     ...future.frame <- base::sys.nframe()
[11:00:26.234]     ...future.conditions <- base::list()
[11:00:26.234]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:26.234]     if (FALSE) {
[11:00:26.234]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:26.234]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:26.234]     }
[11:00:26.234]     ...future.result <- base::tryCatch({
[11:00:26.234]         base::withCallingHandlers({
[11:00:26.234]             ...future.value <- base::withVisible(base::local({
[11:00:26.234]                 withCallingHandlers({
[11:00:26.234]                   {
[11:00:26.234]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:26.234]                     if (!identical(...future.globals.maxSize.org, 
[11:00:26.234]                       ...future.globals.maxSize)) {
[11:00:26.234]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:26.234]                       on.exit(options(oopts), add = TRUE)
[11:00:26.234]                     }
[11:00:26.234]                     {
[11:00:26.234]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:26.234]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:00:26.234]                         USE.NAMES = FALSE)
[11:00:26.234]                       do.call(mapply, args = args)
[11:00:26.234]                     }
[11:00:26.234]                   }
[11:00:26.234]                 }, immediateCondition = function(cond) {
[11:00:26.234]                   save_rds <- function (object, pathname, ...) 
[11:00:26.234]                   {
[11:00:26.234]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:26.234]                     if (file_test("-f", pathname_tmp)) {
[11:00:26.234]                       fi_tmp <- file.info(pathname_tmp)
[11:00:26.234]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:26.234]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:26.234]                         fi_tmp[["mtime"]])
[11:00:26.234]                     }
[11:00:26.234]                     tryCatch({
[11:00:26.234]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:26.234]                     }, error = function(ex) {
[11:00:26.234]                       msg <- conditionMessage(ex)
[11:00:26.234]                       fi_tmp <- file.info(pathname_tmp)
[11:00:26.234]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:26.234]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:26.234]                         fi_tmp[["mtime"]], msg)
[11:00:26.234]                       ex$message <- msg
[11:00:26.234]                       stop(ex)
[11:00:26.234]                     })
[11:00:26.234]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:26.234]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:26.234]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:26.234]                       fi_tmp <- file.info(pathname_tmp)
[11:00:26.234]                       fi <- file.info(pathname)
[11:00:26.234]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:26.234]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:26.234]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:26.234]                         fi[["size"]], fi[["mtime"]])
[11:00:26.234]                       stop(msg)
[11:00:26.234]                     }
[11:00:26.234]                     invisible(pathname)
[11:00:26.234]                   }
[11:00:26.234]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:26.234]                     rootPath = tempdir()) 
[11:00:26.234]                   {
[11:00:26.234]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:26.234]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:26.234]                       tmpdir = path, fileext = ".rds")
[11:00:26.234]                     save_rds(obj, file)
[11:00:26.234]                   }
[11:00:26.234]                   saveImmediateCondition(cond, path = "/tmp/RtmpuTAfww/.future/immediateConditions")
[11:00:26.234]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:26.234]                   {
[11:00:26.234]                     inherits <- base::inherits
[11:00:26.234]                     invokeRestart <- base::invokeRestart
[11:00:26.234]                     is.null <- base::is.null
[11:00:26.234]                     muffled <- FALSE
[11:00:26.234]                     if (inherits(cond, "message")) {
[11:00:26.234]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:26.234]                       if (muffled) 
[11:00:26.234]                         invokeRestart("muffleMessage")
[11:00:26.234]                     }
[11:00:26.234]                     else if (inherits(cond, "warning")) {
[11:00:26.234]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:26.234]                       if (muffled) 
[11:00:26.234]                         invokeRestart("muffleWarning")
[11:00:26.234]                     }
[11:00:26.234]                     else if (inherits(cond, "condition")) {
[11:00:26.234]                       if (!is.null(pattern)) {
[11:00:26.234]                         computeRestarts <- base::computeRestarts
[11:00:26.234]                         grepl <- base::grepl
[11:00:26.234]                         restarts <- computeRestarts(cond)
[11:00:26.234]                         for (restart in restarts) {
[11:00:26.234]                           name <- restart$name
[11:00:26.234]                           if (is.null(name)) 
[11:00:26.234]                             next
[11:00:26.234]                           if (!grepl(pattern, name)) 
[11:00:26.234]                             next
[11:00:26.234]                           invokeRestart(restart)
[11:00:26.234]                           muffled <- TRUE
[11:00:26.234]                           break
[11:00:26.234]                         }
[11:00:26.234]                       }
[11:00:26.234]                     }
[11:00:26.234]                     invisible(muffled)
[11:00:26.234]                   }
[11:00:26.234]                   muffleCondition(cond)
[11:00:26.234]                 })
[11:00:26.234]             }))
[11:00:26.234]             future::FutureResult(value = ...future.value$value, 
[11:00:26.234]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:26.234]                   ...future.rng), globalenv = if (FALSE) 
[11:00:26.234]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:26.234]                     ...future.globalenv.names))
[11:00:26.234]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:26.234]         }, condition = base::local({
[11:00:26.234]             c <- base::c
[11:00:26.234]             inherits <- base::inherits
[11:00:26.234]             invokeRestart <- base::invokeRestart
[11:00:26.234]             length <- base::length
[11:00:26.234]             list <- base::list
[11:00:26.234]             seq.int <- base::seq.int
[11:00:26.234]             signalCondition <- base::signalCondition
[11:00:26.234]             sys.calls <- base::sys.calls
[11:00:26.234]             `[[` <- base::`[[`
[11:00:26.234]             `+` <- base::`+`
[11:00:26.234]             `<<-` <- base::`<<-`
[11:00:26.234]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:26.234]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:26.234]                   3L)]
[11:00:26.234]             }
[11:00:26.234]             function(cond) {
[11:00:26.234]                 is_error <- inherits(cond, "error")
[11:00:26.234]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:26.234]                   NULL)
[11:00:26.234]                 if (is_error) {
[11:00:26.234]                   sessionInformation <- function() {
[11:00:26.234]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:26.234]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:26.234]                       search = base::search(), system = base::Sys.info())
[11:00:26.234]                   }
[11:00:26.234]                   ...future.conditions[[length(...future.conditions) + 
[11:00:26.234]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:26.234]                     cond$call), session = sessionInformation(), 
[11:00:26.234]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:26.234]                   signalCondition(cond)
[11:00:26.234]                 }
[11:00:26.234]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:26.234]                 "immediateCondition"))) {
[11:00:26.234]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:26.234]                   ...future.conditions[[length(...future.conditions) + 
[11:00:26.234]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:26.234]                   if (TRUE && !signal) {
[11:00:26.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:26.234]                     {
[11:00:26.234]                       inherits <- base::inherits
[11:00:26.234]                       invokeRestart <- base::invokeRestart
[11:00:26.234]                       is.null <- base::is.null
[11:00:26.234]                       muffled <- FALSE
[11:00:26.234]                       if (inherits(cond, "message")) {
[11:00:26.234]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:26.234]                         if (muffled) 
[11:00:26.234]                           invokeRestart("muffleMessage")
[11:00:26.234]                       }
[11:00:26.234]                       else if (inherits(cond, "warning")) {
[11:00:26.234]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:26.234]                         if (muffled) 
[11:00:26.234]                           invokeRestart("muffleWarning")
[11:00:26.234]                       }
[11:00:26.234]                       else if (inherits(cond, "condition")) {
[11:00:26.234]                         if (!is.null(pattern)) {
[11:00:26.234]                           computeRestarts <- base::computeRestarts
[11:00:26.234]                           grepl <- base::grepl
[11:00:26.234]                           restarts <- computeRestarts(cond)
[11:00:26.234]                           for (restart in restarts) {
[11:00:26.234]                             name <- restart$name
[11:00:26.234]                             if (is.null(name)) 
[11:00:26.234]                               next
[11:00:26.234]                             if (!grepl(pattern, name)) 
[11:00:26.234]                               next
[11:00:26.234]                             invokeRestart(restart)
[11:00:26.234]                             muffled <- TRUE
[11:00:26.234]                             break
[11:00:26.234]                           }
[11:00:26.234]                         }
[11:00:26.234]                       }
[11:00:26.234]                       invisible(muffled)
[11:00:26.234]                     }
[11:00:26.234]                     muffleCondition(cond, pattern = "^muffle")
[11:00:26.234]                   }
[11:00:26.234]                 }
[11:00:26.234]                 else {
[11:00:26.234]                   if (TRUE) {
[11:00:26.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:26.234]                     {
[11:00:26.234]                       inherits <- base::inherits
[11:00:26.234]                       invokeRestart <- base::invokeRestart
[11:00:26.234]                       is.null <- base::is.null
[11:00:26.234]                       muffled <- FALSE
[11:00:26.234]                       if (inherits(cond, "message")) {
[11:00:26.234]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:26.234]                         if (muffled) 
[11:00:26.234]                           invokeRestart("muffleMessage")
[11:00:26.234]                       }
[11:00:26.234]                       else if (inherits(cond, "warning")) {
[11:00:26.234]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:26.234]                         if (muffled) 
[11:00:26.234]                           invokeRestart("muffleWarning")
[11:00:26.234]                       }
[11:00:26.234]                       else if (inherits(cond, "condition")) {
[11:00:26.234]                         if (!is.null(pattern)) {
[11:00:26.234]                           computeRestarts <- base::computeRestarts
[11:00:26.234]                           grepl <- base::grepl
[11:00:26.234]                           restarts <- computeRestarts(cond)
[11:00:26.234]                           for (restart in restarts) {
[11:00:26.234]                             name <- restart$name
[11:00:26.234]                             if (is.null(name)) 
[11:00:26.234]                               next
[11:00:26.234]                             if (!grepl(pattern, name)) 
[11:00:26.234]                               next
[11:00:26.234]                             invokeRestart(restart)
[11:00:26.234]                             muffled <- TRUE
[11:00:26.234]                             break
[11:00:26.234]                           }
[11:00:26.234]                         }
[11:00:26.234]                       }
[11:00:26.234]                       invisible(muffled)
[11:00:26.234]                     }
[11:00:26.234]                     muffleCondition(cond, pattern = "^muffle")
[11:00:26.234]                   }
[11:00:26.234]                 }
[11:00:26.234]             }
[11:00:26.234]         }))
[11:00:26.234]     }, error = function(ex) {
[11:00:26.234]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:26.234]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:26.234]                 ...future.rng), started = ...future.startTime, 
[11:00:26.234]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:26.234]             version = "1.8"), class = "FutureResult")
[11:00:26.234]     }, finally = {
[11:00:26.234]         if (!identical(...future.workdir, getwd())) 
[11:00:26.234]             setwd(...future.workdir)
[11:00:26.234]         {
[11:00:26.234]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:26.234]                 ...future.oldOptions$nwarnings <- NULL
[11:00:26.234]             }
[11:00:26.234]             base::options(...future.oldOptions)
[11:00:26.234]             if (.Platform$OS.type == "windows") {
[11:00:26.234]                 old_names <- names(...future.oldEnvVars)
[11:00:26.234]                 envs <- base::Sys.getenv()
[11:00:26.234]                 names <- names(envs)
[11:00:26.234]                 common <- intersect(names, old_names)
[11:00:26.234]                 added <- setdiff(names, old_names)
[11:00:26.234]                 removed <- setdiff(old_names, names)
[11:00:26.234]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:26.234]                   envs[common]]
[11:00:26.234]                 NAMES <- toupper(changed)
[11:00:26.234]                 args <- list()
[11:00:26.234]                 for (kk in seq_along(NAMES)) {
[11:00:26.234]                   name <- changed[[kk]]
[11:00:26.234]                   NAME <- NAMES[[kk]]
[11:00:26.234]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:26.234]                     next
[11:00:26.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:26.234]                 }
[11:00:26.234]                 NAMES <- toupper(added)
[11:00:26.234]                 for (kk in seq_along(NAMES)) {
[11:00:26.234]                   name <- added[[kk]]
[11:00:26.234]                   NAME <- NAMES[[kk]]
[11:00:26.234]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:26.234]                     next
[11:00:26.234]                   args[[name]] <- ""
[11:00:26.234]                 }
[11:00:26.234]                 NAMES <- toupper(removed)
[11:00:26.234]                 for (kk in seq_along(NAMES)) {
[11:00:26.234]                   name <- removed[[kk]]
[11:00:26.234]                   NAME <- NAMES[[kk]]
[11:00:26.234]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:26.234]                     next
[11:00:26.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:26.234]                 }
[11:00:26.234]                 if (length(args) > 0) 
[11:00:26.234]                   base::do.call(base::Sys.setenv, args = args)
[11:00:26.234]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:26.234]             }
[11:00:26.234]             else {
[11:00:26.234]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:26.234]             }
[11:00:26.234]             {
[11:00:26.234]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:26.234]                   0L) {
[11:00:26.234]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:26.234]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:26.234]                   base::options(opts)
[11:00:26.234]                 }
[11:00:26.234]                 {
[11:00:26.234]                   {
[11:00:26.234]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:26.234]                     NULL
[11:00:26.234]                   }
[11:00:26.234]                   options(future.plan = NULL)
[11:00:26.234]                   if (is.na(NA_character_)) 
[11:00:26.234]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:26.234]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:26.234]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:26.234]                     .init = FALSE)
[11:00:26.234]                 }
[11:00:26.234]             }
[11:00:26.234]         }
[11:00:26.234]     })
[11:00:26.234]     if (FALSE) {
[11:00:26.234]         base::sink(type = "output", split = FALSE)
[11:00:26.234]         if (NA) {
[11:00:26.234]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:26.234]         }
[11:00:26.234]         else {
[11:00:26.234]             ...future.result["stdout"] <- base::list(NULL)
[11:00:26.234]         }
[11:00:26.234]         base::close(...future.stdout)
[11:00:26.234]         ...future.stdout <- NULL
[11:00:26.234]     }
[11:00:26.234]     ...future.result$conditions <- ...future.conditions
[11:00:26.234]     ...future.result$finished <- base::Sys.time()
[11:00:26.234]     ...future.result
[11:00:26.234] }
[11:00:26.237] assign_globals() ...
[11:00:26.237] List of 5
[11:00:26.237]  $ ...future.FUN            :function (x, y)  
[11:00:26.237]  $ MoreArgs                 : NULL
[11:00:26.237]  $ ...future.elements_ii    :List of 2
[11:00:26.237]   ..$ :List of 1
[11:00:26.237]   .. ..$ : int 1
[11:00:26.237]   ..$ :List of 1
[11:00:26.237]   .. ..$ : int 0
[11:00:26.237]  $ ...future.seeds_ii       : NULL
[11:00:26.237]  $ ...future.globals.maxSize: NULL
[11:00:26.237]  - attr(*, "where")=List of 5
[11:00:26.237]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:26.237]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[11:00:26.237]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:26.237]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:26.237]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:26.237]  - attr(*, "resolved")= logi FALSE
[11:00:26.237]  - attr(*, "total_size")= num 1218
[11:00:26.237]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:26.237]  - attr(*, "already-done")= logi TRUE
[11:00:26.242] - reassign environment for ‘...future.FUN’
[11:00:26.242] - copied ‘...future.FUN’ to environment
[11:00:26.242] - copied ‘MoreArgs’ to environment
[11:00:26.242] - copied ‘...future.elements_ii’ to environment
[11:00:26.242] - copied ‘...future.seeds_ii’ to environment
[11:00:26.242] - copied ‘...future.globals.maxSize’ to environment
[11:00:26.242] assign_globals() ... done
[11:00:26.242] requestCore(): workers = 2
[11:00:26.244] MulticoreFuture started
[11:00:26.245] - Launch lazy future ... done
[11:00:26.245] run() for ‘MulticoreFuture’ ... done
[11:00:26.245] Created future:
[11:00:26.245] plan(): Setting new future strategy stack:
[11:00:26.246] List of future strategies:
[11:00:26.246] 1. sequential:
[11:00:26.246]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:26.246]    - tweaked: FALSE
[11:00:26.246]    - call: NULL
[11:00:26.246] plan(): nbrOfWorkers() = 1
[11:00:26.245] MulticoreFuture:
[11:00:26.245] Label: ‘future_mapply-1’
[11:00:26.245] Expression:
[11:00:26.245] {
[11:00:26.245]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:26.245]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:26.245]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:26.245]         on.exit(options(oopts), add = TRUE)
[11:00:26.245]     }
[11:00:26.245]     {
[11:00:26.245]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:26.245]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:00:26.245]         do.call(mapply, args = args)
[11:00:26.245]     }
[11:00:26.245] }
[11:00:26.245] Lazy evaluation: FALSE
[11:00:26.245] Asynchronous evaluation: TRUE
[11:00:26.245] Local evaluation: TRUE
[11:00:26.245] Environment: R_GlobalEnv
[11:00:26.245] Capture standard output: NA
[11:00:26.245] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:26.245] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:26.245] Packages: <none>
[11:00:26.245] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:26.245] Resolved: FALSE
[11:00:26.245] Value: <not collected>
[11:00:26.245] Conditions captured: <none>
[11:00:26.245] Early signaling: FALSE
[11:00:26.245] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:26.245] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:26.258] Chunk #1 of 2 ... DONE
[11:00:26.262] Chunk #2 of 2 ...
[11:00:26.262]  - Finding globals in '...' for chunk #2 ...
[11:00:26.262] getGlobalsAndPackages() ...
[11:00:26.263] Searching for globals...
[11:00:26.264] 
[11:00:26.265] Searching for globals ... DONE
[11:00:26.265] - globals: [0] <none>
[11:00:26.265] getGlobalsAndPackages() ... DONE
[11:00:26.266]    + additional globals found: [n=0] 
[11:00:26.266]    + additional namespaces needed: [n=0] 
[11:00:26.266]  - Finding globals in '...' for chunk #2 ... DONE
[11:00:26.267]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:26.267]  - seeds: <none>
[11:00:26.267]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:26.267] getGlobalsAndPackages() ...
[11:00:26.268] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:26.268] Resolving globals: FALSE
[11:00:26.269] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[11:00:26.270] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[11:00:26.270] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:26.271] 
[11:00:26.271] getGlobalsAndPackages() ... DONE
[11:00:26.271] run() for ‘Future’ ...
[11:00:26.272] - state: ‘created’
[11:00:26.272] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:00:26.275] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:26.275] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:00:26.275]   - Field: ‘label’
[11:00:26.275]   - Field: ‘local’
[11:00:26.275]   - Field: ‘owner’
[11:00:26.276]   - Field: ‘envir’
[11:00:26.276]   - Field: ‘workers’
[11:00:26.276]   - Field: ‘packages’
[11:00:26.276]   - Field: ‘gc’
[11:00:26.276]   - Field: ‘job’
[11:00:26.276]   - Field: ‘conditions’
[11:00:26.276]   - Field: ‘expr’
[11:00:26.277]   - Field: ‘uuid’
[11:00:26.277]   - Field: ‘seed’
[11:00:26.277]   - Field: ‘version’
[11:00:26.277]   - Field: ‘result’
[11:00:26.277]   - Field: ‘asynchronous’
[11:00:26.277]   - Field: ‘calls’
[11:00:26.277]   - Field: ‘globals’
[11:00:26.277]   - Field: ‘stdout’
[11:00:26.278]   - Field: ‘earlySignal’
[11:00:26.278]   - Field: ‘lazy’
[11:00:26.278]   - Field: ‘state’
[11:00:26.278] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:00:26.278] - Launch lazy future ...
[11:00:26.278] Packages needed by the future expression (n = 0): <none>
[11:00:26.279] Packages needed by future strategies (n = 0): <none>
[11:00:26.279] {
[11:00:26.279]     {
[11:00:26.279]         {
[11:00:26.279]             ...future.startTime <- base::Sys.time()
[11:00:26.279]             {
[11:00:26.279]                 {
[11:00:26.279]                   {
[11:00:26.279]                     {
[11:00:26.279]                       base::local({
[11:00:26.279]                         has_future <- base::requireNamespace("future", 
[11:00:26.279]                           quietly = TRUE)
[11:00:26.279]                         if (has_future) {
[11:00:26.279]                           ns <- base::getNamespace("future")
[11:00:26.279]                           version <- ns[[".package"]][["version"]]
[11:00:26.279]                           if (is.null(version)) 
[11:00:26.279]                             version <- utils::packageVersion("future")
[11:00:26.279]                         }
[11:00:26.279]                         else {
[11:00:26.279]                           version <- NULL
[11:00:26.279]                         }
[11:00:26.279]                         if (!has_future || version < "1.8.0") {
[11:00:26.279]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:26.279]                             "", base::R.version$version.string), 
[11:00:26.279]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:26.279]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:26.279]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:26.279]                               "release", "version")], collapse = " "), 
[11:00:26.279]                             hostname = base::Sys.info()[["nodename"]])
[11:00:26.279]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:26.279]                             info)
[11:00:26.279]                           info <- base::paste(info, collapse = "; ")
[11:00:26.279]                           if (!has_future) {
[11:00:26.279]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:26.279]                               info)
[11:00:26.279]                           }
[11:00:26.279]                           else {
[11:00:26.279]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:26.279]                               info, version)
[11:00:26.279]                           }
[11:00:26.279]                           base::stop(msg)
[11:00:26.279]                         }
[11:00:26.279]                       })
[11:00:26.279]                     }
[11:00:26.279]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:26.279]                     base::options(mc.cores = 1L)
[11:00:26.279]                   }
[11:00:26.279]                   ...future.strategy.old <- future::plan("list")
[11:00:26.279]                   options(future.plan = NULL)
[11:00:26.279]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:26.279]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:26.279]                 }
[11:00:26.279]                 ...future.workdir <- getwd()
[11:00:26.279]             }
[11:00:26.279]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:26.279]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:26.279]         }
[11:00:26.279]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:26.279]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:26.279]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:26.279]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:26.279]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:26.279]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:26.279]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:26.279]             base::names(...future.oldOptions))
[11:00:26.279]     }
[11:00:26.279]     if (TRUE) {
[11:00:26.279]     }
[11:00:26.279]     else {
[11:00:26.279]         if (NA) {
[11:00:26.279]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:26.279]                 open = "w")
[11:00:26.279]         }
[11:00:26.279]         else {
[11:00:26.279]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:26.279]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:26.279]         }
[11:00:26.279]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:26.279]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:26.279]             base::sink(type = "output", split = FALSE)
[11:00:26.279]             base::close(...future.stdout)
[11:00:26.279]         }, add = TRUE)
[11:00:26.279]     }
[11:00:26.279]     ...future.frame <- base::sys.nframe()
[11:00:26.279]     ...future.conditions <- base::list()
[11:00:26.279]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:26.279]     if (FALSE) {
[11:00:26.279]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:26.279]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:26.279]     }
[11:00:26.279]     ...future.result <- base::tryCatch({
[11:00:26.279]         base::withCallingHandlers({
[11:00:26.279]             ...future.value <- base::withVisible(base::local({
[11:00:26.279]                 withCallingHandlers({
[11:00:26.279]                   {
[11:00:26.279]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:26.279]                     if (!identical(...future.globals.maxSize.org, 
[11:00:26.279]                       ...future.globals.maxSize)) {
[11:00:26.279]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:26.279]                       on.exit(options(oopts), add = TRUE)
[11:00:26.279]                     }
[11:00:26.279]                     {
[11:00:26.279]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:26.279]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:00:26.279]                         USE.NAMES = FALSE)
[11:00:26.279]                       do.call(mapply, args = args)
[11:00:26.279]                     }
[11:00:26.279]                   }
[11:00:26.279]                 }, immediateCondition = function(cond) {
[11:00:26.279]                   save_rds <- function (object, pathname, ...) 
[11:00:26.279]                   {
[11:00:26.279]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:00:26.279]                     if (file_test("-f", pathname_tmp)) {
[11:00:26.279]                       fi_tmp <- file.info(pathname_tmp)
[11:00:26.279]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:00:26.279]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:26.279]                         fi_tmp[["mtime"]])
[11:00:26.279]                     }
[11:00:26.279]                     tryCatch({
[11:00:26.279]                       saveRDS(object, file = pathname_tmp, ...)
[11:00:26.279]                     }, error = function(ex) {
[11:00:26.279]                       msg <- conditionMessage(ex)
[11:00:26.279]                       fi_tmp <- file.info(pathname_tmp)
[11:00:26.279]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:00:26.279]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:26.279]                         fi_tmp[["mtime"]], msg)
[11:00:26.279]                       ex$message <- msg
[11:00:26.279]                       stop(ex)
[11:00:26.279]                     })
[11:00:26.279]                     stopifnot(file_test("-f", pathname_tmp))
[11:00:26.279]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:00:26.279]                     if (!res || file_test("-f", pathname_tmp)) {
[11:00:26.279]                       fi_tmp <- file.info(pathname_tmp)
[11:00:26.279]                       fi <- file.info(pathname)
[11:00:26.279]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:00:26.279]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:00:26.279]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:00:26.279]                         fi[["size"]], fi[["mtime"]])
[11:00:26.279]                       stop(msg)
[11:00:26.279]                     }
[11:00:26.279]                     invisible(pathname)
[11:00:26.279]                   }
[11:00:26.279]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:00:26.279]                     rootPath = tempdir()) 
[11:00:26.279]                   {
[11:00:26.279]                     obj <- list(time = Sys.time(), condition = cond)
[11:00:26.279]                     file <- tempfile(pattern = class(cond)[1], 
[11:00:26.279]                       tmpdir = path, fileext = ".rds")
[11:00:26.279]                     save_rds(obj, file)
[11:00:26.279]                   }
[11:00:26.279]                   saveImmediateCondition(cond, path = "/tmp/RtmpuTAfww/.future/immediateConditions")
[11:00:26.279]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:26.279]                   {
[11:00:26.279]                     inherits <- base::inherits
[11:00:26.279]                     invokeRestart <- base::invokeRestart
[11:00:26.279]                     is.null <- base::is.null
[11:00:26.279]                     muffled <- FALSE
[11:00:26.279]                     if (inherits(cond, "message")) {
[11:00:26.279]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:26.279]                       if (muffled) 
[11:00:26.279]                         invokeRestart("muffleMessage")
[11:00:26.279]                     }
[11:00:26.279]                     else if (inherits(cond, "warning")) {
[11:00:26.279]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:26.279]                       if (muffled) 
[11:00:26.279]                         invokeRestart("muffleWarning")
[11:00:26.279]                     }
[11:00:26.279]                     else if (inherits(cond, "condition")) {
[11:00:26.279]                       if (!is.null(pattern)) {
[11:00:26.279]                         computeRestarts <- base::computeRestarts
[11:00:26.279]                         grepl <- base::grepl
[11:00:26.279]                         restarts <- computeRestarts(cond)
[11:00:26.279]                         for (restart in restarts) {
[11:00:26.279]                           name <- restart$name
[11:00:26.279]                           if (is.null(name)) 
[11:00:26.279]                             next
[11:00:26.279]                           if (!grepl(pattern, name)) 
[11:00:26.279]                             next
[11:00:26.279]                           invokeRestart(restart)
[11:00:26.279]                           muffled <- TRUE
[11:00:26.279]                           break
[11:00:26.279]                         }
[11:00:26.279]                       }
[11:00:26.279]                     }
[11:00:26.279]                     invisible(muffled)
[11:00:26.279]                   }
[11:00:26.279]                   muffleCondition(cond)
[11:00:26.279]                 })
[11:00:26.279]             }))
[11:00:26.279]             future::FutureResult(value = ...future.value$value, 
[11:00:26.279]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:26.279]                   ...future.rng), globalenv = if (FALSE) 
[11:00:26.279]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:26.279]                     ...future.globalenv.names))
[11:00:26.279]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:26.279]         }, condition = base::local({
[11:00:26.279]             c <- base::c
[11:00:26.279]             inherits <- base::inherits
[11:00:26.279]             invokeRestart <- base::invokeRestart
[11:00:26.279]             length <- base::length
[11:00:26.279]             list <- base::list
[11:00:26.279]             seq.int <- base::seq.int
[11:00:26.279]             signalCondition <- base::signalCondition
[11:00:26.279]             sys.calls <- base::sys.calls
[11:00:26.279]             `[[` <- base::`[[`
[11:00:26.279]             `+` <- base::`+`
[11:00:26.279]             `<<-` <- base::`<<-`
[11:00:26.279]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:26.279]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:26.279]                   3L)]
[11:00:26.279]             }
[11:00:26.279]             function(cond) {
[11:00:26.279]                 is_error <- inherits(cond, "error")
[11:00:26.279]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:26.279]                   NULL)
[11:00:26.279]                 if (is_error) {
[11:00:26.279]                   sessionInformation <- function() {
[11:00:26.279]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:26.279]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:26.279]                       search = base::search(), system = base::Sys.info())
[11:00:26.279]                   }
[11:00:26.279]                   ...future.conditions[[length(...future.conditions) + 
[11:00:26.279]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:26.279]                     cond$call), session = sessionInformation(), 
[11:00:26.279]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:26.279]                   signalCondition(cond)
[11:00:26.279]                 }
[11:00:26.279]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:26.279]                 "immediateCondition"))) {
[11:00:26.279]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:26.279]                   ...future.conditions[[length(...future.conditions) + 
[11:00:26.279]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:26.279]                   if (TRUE && !signal) {
[11:00:26.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:26.279]                     {
[11:00:26.279]                       inherits <- base::inherits
[11:00:26.279]                       invokeRestart <- base::invokeRestart
[11:00:26.279]                       is.null <- base::is.null
[11:00:26.279]                       muffled <- FALSE
[11:00:26.279]                       if (inherits(cond, "message")) {
[11:00:26.279]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:26.279]                         if (muffled) 
[11:00:26.279]                           invokeRestart("muffleMessage")
[11:00:26.279]                       }
[11:00:26.279]                       else if (inherits(cond, "warning")) {
[11:00:26.279]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:26.279]                         if (muffled) 
[11:00:26.279]                           invokeRestart("muffleWarning")
[11:00:26.279]                       }
[11:00:26.279]                       else if (inherits(cond, "condition")) {
[11:00:26.279]                         if (!is.null(pattern)) {
[11:00:26.279]                           computeRestarts <- base::computeRestarts
[11:00:26.279]                           grepl <- base::grepl
[11:00:26.279]                           restarts <- computeRestarts(cond)
[11:00:26.279]                           for (restart in restarts) {
[11:00:26.279]                             name <- restart$name
[11:00:26.279]                             if (is.null(name)) 
[11:00:26.279]                               next
[11:00:26.279]                             if (!grepl(pattern, name)) 
[11:00:26.279]                               next
[11:00:26.279]                             invokeRestart(restart)
[11:00:26.279]                             muffled <- TRUE
[11:00:26.279]                             break
[11:00:26.279]                           }
[11:00:26.279]                         }
[11:00:26.279]                       }
[11:00:26.279]                       invisible(muffled)
[11:00:26.279]                     }
[11:00:26.279]                     muffleCondition(cond, pattern = "^muffle")
[11:00:26.279]                   }
[11:00:26.279]                 }
[11:00:26.279]                 else {
[11:00:26.279]                   if (TRUE) {
[11:00:26.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:26.279]                     {
[11:00:26.279]                       inherits <- base::inherits
[11:00:26.279]                       invokeRestart <- base::invokeRestart
[11:00:26.279]                       is.null <- base::is.null
[11:00:26.279]                       muffled <- FALSE
[11:00:26.279]                       if (inherits(cond, "message")) {
[11:00:26.279]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:26.279]                         if (muffled) 
[11:00:26.279]                           invokeRestart("muffleMessage")
[11:00:26.279]                       }
[11:00:26.279]                       else if (inherits(cond, "warning")) {
[11:00:26.279]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:26.279]                         if (muffled) 
[11:00:26.279]                           invokeRestart("muffleWarning")
[11:00:26.279]                       }
[11:00:26.279]                       else if (inherits(cond, "condition")) {
[11:00:26.279]                         if (!is.null(pattern)) {
[11:00:26.279]                           computeRestarts <- base::computeRestarts
[11:00:26.279]                           grepl <- base::grepl
[11:00:26.279]                           restarts <- computeRestarts(cond)
[11:00:26.279]                           for (restart in restarts) {
[11:00:26.279]                             name <- restart$name
[11:00:26.279]                             if (is.null(name)) 
[11:00:26.279]                               next
[11:00:26.279]                             if (!grepl(pattern, name)) 
[11:00:26.279]                               next
[11:00:26.279]                             invokeRestart(restart)
[11:00:26.279]                             muffled <- TRUE
[11:00:26.279]                             break
[11:00:26.279]                           }
[11:00:26.279]                         }
[11:00:26.279]                       }
[11:00:26.279]                       invisible(muffled)
[11:00:26.279]                     }
[11:00:26.279]                     muffleCondition(cond, pattern = "^muffle")
[11:00:26.279]                   }
[11:00:26.279]                 }
[11:00:26.279]             }
[11:00:26.279]         }))
[11:00:26.279]     }, error = function(ex) {
[11:00:26.279]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:26.279]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:26.279]                 ...future.rng), started = ...future.startTime, 
[11:00:26.279]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:26.279]             version = "1.8"), class = "FutureResult")
[11:00:26.279]     }, finally = {
[11:00:26.279]         if (!identical(...future.workdir, getwd())) 
[11:00:26.279]             setwd(...future.workdir)
[11:00:26.279]         {
[11:00:26.279]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:26.279]                 ...future.oldOptions$nwarnings <- NULL
[11:00:26.279]             }
[11:00:26.279]             base::options(...future.oldOptions)
[11:00:26.279]             if (.Platform$OS.type == "windows") {
[11:00:26.279]                 old_names <- names(...future.oldEnvVars)
[11:00:26.279]                 envs <- base::Sys.getenv()
[11:00:26.279]                 names <- names(envs)
[11:00:26.279]                 common <- intersect(names, old_names)
[11:00:26.279]                 added <- setdiff(names, old_names)
[11:00:26.279]                 removed <- setdiff(old_names, names)
[11:00:26.279]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:26.279]                   envs[common]]
[11:00:26.279]                 NAMES <- toupper(changed)
[11:00:26.279]                 args <- list()
[11:00:26.279]                 for (kk in seq_along(NAMES)) {
[11:00:26.279]                   name <- changed[[kk]]
[11:00:26.279]                   NAME <- NAMES[[kk]]
[11:00:26.279]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:26.279]                     next
[11:00:26.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:26.279]                 }
[11:00:26.279]                 NAMES <- toupper(added)
[11:00:26.279]                 for (kk in seq_along(NAMES)) {
[11:00:26.279]                   name <- added[[kk]]
[11:00:26.279]                   NAME <- NAMES[[kk]]
[11:00:26.279]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:26.279]                     next
[11:00:26.279]                   args[[name]] <- ""
[11:00:26.279]                 }
[11:00:26.279]                 NAMES <- toupper(removed)
[11:00:26.279]                 for (kk in seq_along(NAMES)) {
[11:00:26.279]                   name <- removed[[kk]]
[11:00:26.279]                   NAME <- NAMES[[kk]]
[11:00:26.279]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:26.279]                     next
[11:00:26.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:26.279]                 }
[11:00:26.279]                 if (length(args) > 0) 
[11:00:26.279]                   base::do.call(base::Sys.setenv, args = args)
[11:00:26.279]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:26.279]             }
[11:00:26.279]             else {
[11:00:26.279]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:26.279]             }
[11:00:26.279]             {
[11:00:26.279]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:26.279]                   0L) {
[11:00:26.279]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:26.279]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:26.279]                   base::options(opts)
[11:00:26.279]                 }
[11:00:26.279]                 {
[11:00:26.279]                   {
[11:00:26.279]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:26.279]                     NULL
[11:00:26.279]                   }
[11:00:26.279]                   options(future.plan = NULL)
[11:00:26.279]                   if (is.na(NA_character_)) 
[11:00:26.279]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:26.279]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:26.279]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:26.279]                     .init = FALSE)
[11:00:26.279]                 }
[11:00:26.279]             }
[11:00:26.279]         }
[11:00:26.279]     })
[11:00:26.279]     if (FALSE) {
[11:00:26.279]         base::sink(type = "output", split = FALSE)
[11:00:26.279]         if (NA) {
[11:00:26.279]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:26.279]         }
[11:00:26.279]         else {
[11:00:26.279]             ...future.result["stdout"] <- base::list(NULL)
[11:00:26.279]         }
[11:00:26.279]         base::close(...future.stdout)
[11:00:26.279]         ...future.stdout <- NULL
[11:00:26.279]     }
[11:00:26.279]     ...future.result$conditions <- ...future.conditions
[11:00:26.279]     ...future.result$finished <- base::Sys.time()
[11:00:26.279]     ...future.result
[11:00:26.279] }
[11:00:26.282] assign_globals() ...
[11:00:26.282] List of 5
[11:00:26.282]  $ ...future.FUN            :function (x, y)  
[11:00:26.282]  $ MoreArgs                 : NULL
[11:00:26.282]  $ ...future.elements_ii    :List of 2
[11:00:26.282]   ..$ :List of 1
[11:00:26.282]   .. ..$ : int 0
[11:00:26.282]   ..$ :List of 1
[11:00:26.282]   .. ..$ : int 1
[11:00:26.282]  $ ...future.seeds_ii       : NULL
[11:00:26.282]  $ ...future.globals.maxSize: NULL
[11:00:26.282]  - attr(*, "where")=List of 5
[11:00:26.282]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[11:00:26.282]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[11:00:26.282]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[11:00:26.282]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[11:00:26.282]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[11:00:26.282]  - attr(*, "resolved")= logi FALSE
[11:00:26.282]  - attr(*, "total_size")= num 1218
[11:00:26.282]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:26.282]  - attr(*, "already-done")= logi TRUE
[11:00:26.288] - reassign environment for ‘...future.FUN’
[11:00:26.289] - copied ‘...future.FUN’ to environment
[11:00:26.289] - copied ‘MoreArgs’ to environment
[11:00:26.289] - copied ‘...future.elements_ii’ to environment
[11:00:26.289] - copied ‘...future.seeds_ii’ to environment
[11:00:26.289] - copied ‘...future.globals.maxSize’ to environment
[11:00:26.289] assign_globals() ... done
[11:00:26.289] requestCore(): workers = 2
[11:00:26.291] MulticoreFuture started
[11:00:26.292] - Launch lazy future ... done
[11:00:26.292] run() for ‘MulticoreFuture’ ... done
[11:00:26.292] Created future:
[11:00:26.293] plan(): Setting new future strategy stack:
[11:00:26.293] List of future strategies:
[11:00:26.293] 1. sequential:
[11:00:26.293]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:26.293]    - tweaked: FALSE
[11:00:26.293]    - call: NULL
[11:00:26.294] plan(): nbrOfWorkers() = 1
[11:00:26.296] plan(): Setting new future strategy stack:
[11:00:26.296] List of future strategies:
[11:00:26.296] 1. multicore:
[11:00:26.296]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:26.296]    - tweaked: FALSE
[11:00:26.296]    - call: plan(strategy)
[11:00:26.299] plan(): nbrOfWorkers() = 2
[11:00:26.292] MulticoreFuture:
[11:00:26.292] Label: ‘future_mapply-2’
[11:00:26.292] Expression:
[11:00:26.292] {
[11:00:26.292]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:26.292]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:26.292]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:26.292]         on.exit(options(oopts), add = TRUE)
[11:00:26.292]     }
[11:00:26.292]     {
[11:00:26.292]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:26.292]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:00:26.292]         do.call(mapply, args = args)
[11:00:26.292]     }
[11:00:26.292] }
[11:00:26.292] Lazy evaluation: FALSE
[11:00:26.292] Asynchronous evaluation: TRUE
[11:00:26.292] Local evaluation: TRUE
[11:00:26.292] Environment: R_GlobalEnv
[11:00:26.292] Capture standard output: NA
[11:00:26.292] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:26.292] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:26.292] Packages: <none>
[11:00:26.292] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:26.292] Resolved: TRUE
[11:00:26.292] Value: <not collected>
[11:00:26.292] Conditions captured: <none>
[11:00:26.292] Early signaling: FALSE
[11:00:26.292] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:26.292] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:26.300] Chunk #2 of 2 ... DONE
[11:00:26.300] Launching 2 futures (chunks) ... DONE
[11:00:26.300] Resolving 2 futures (chunks) ...
[11:00:26.301] resolve() on list ...
[11:00:26.301]  recursive: 0
[11:00:26.301]  length: 2
[11:00:26.301] 
[11:00:26.312] Future #2
[11:00:26.312] result() for MulticoreFuture ...
[11:00:26.313] result() for MulticoreFuture ...
[11:00:26.313] result() for MulticoreFuture ... done
[11:00:26.313] result() for MulticoreFuture ... done
[11:00:26.313] result() for MulticoreFuture ...
[11:00:26.313] result() for MulticoreFuture ... done
[11:00:26.314] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:00:26.314] - nx: 2
[11:00:26.314] - relay: TRUE
[11:00:26.314] - stdout: TRUE
[11:00:26.314] - signal: TRUE
[11:00:26.314] - resignal: FALSE
[11:00:26.314] - force: TRUE
[11:00:26.314] - relayed: [n=2] FALSE, FALSE
[11:00:26.315] - queued futures: [n=2] FALSE, FALSE
[11:00:26.315]  - until=1
[11:00:26.315]  - relaying element #1
[11:00:26.315] - relayed: [n=2] FALSE, FALSE
[11:00:26.315] - queued futures: [n=2] FALSE, TRUE
[11:00:26.315] signalConditionsASAP(NULL, pos=2) ... done
[11:00:26.315]  length: 1 (resolved future 2)
[11:00:26.752] plan(): Setting new future strategy stack:
[11:00:26.753] List of future strategies:
[11:00:26.753] 1. multicore:
[11:00:26.753]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:00:26.753]    - tweaked: FALSE
[11:00:26.753]    - call: plan(strategy)
[11:00:26.756] plan(): nbrOfWorkers() = 2
[11:00:26.756] Future #1
[11:00:26.757] result() for MulticoreFuture ...
[11:00:26.757] result() for MulticoreFuture ...
[11:00:26.758] result() for MulticoreFuture ... done
[11:00:26.758] result() for MulticoreFuture ... done
[11:00:26.758] result() for MulticoreFuture ...
[11:00:26.758] result() for MulticoreFuture ... done
[11:00:26.758] signalConditionsASAP(MulticoreFuture, pos=1) ...
[11:00:26.758] - nx: 2
[11:00:26.758] - relay: TRUE
[11:00:26.758] - stdout: TRUE
[11:00:26.759] - signal: TRUE
[11:00:26.759] - resignal: FALSE
[11:00:26.759] - force: TRUE
[11:00:26.761] - relayed: [n=2] FALSE, FALSE
[11:00:26.761] - queued futures: [n=2] FALSE, TRUE
[11:00:26.761]  - until=1
[11:00:26.762]  - relaying element #1
[11:00:26.762] result() for MulticoreFuture ...
[11:00:26.762] result() for MulticoreFuture ... done
[11:00:26.762] result() for MulticoreFuture ...
[11:00:26.762] result() for MulticoreFuture ... done
[11:00:26.763] result() for MulticoreFuture ...
[11:00:26.763] result() for MulticoreFuture ... done
[11:00:26.763] result() for MulticoreFuture ...
[11:00:26.763] result() for MulticoreFuture ... done
[11:00:26.763] - relayed: [n=2] TRUE, FALSE
[11:00:26.763] - queued futures: [n=2] TRUE, TRUE
[11:00:26.763] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[11:00:26.764]  length: 0 (resolved future 1)
[11:00:26.764] Relaying remaining futures
[11:00:26.764] signalConditionsASAP(NULL, pos=0) ...
[11:00:26.764] - nx: 2
[11:00:26.764] - relay: TRUE
[11:00:26.764] - stdout: TRUE
[11:00:26.764] - signal: TRUE
[11:00:26.765] - resignal: FALSE
[11:00:26.765] - force: TRUE
[11:00:26.765] - relayed: [n=2] TRUE, FALSE
[11:00:26.765] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:26.765]  - relaying element #2
[11:00:26.765] result() for MulticoreFuture ...
[11:00:26.765] result() for MulticoreFuture ... done
[11:00:26.766] result() for MulticoreFuture ...
[11:00:26.766] result() for MulticoreFuture ... done
[11:00:26.766] result() for MulticoreFuture ...
[11:00:26.766] result() for MulticoreFuture ... done
[11:00:26.766] result() for MulticoreFuture ...
[11:00:26.766] result() for MulticoreFuture ... done
[11:00:26.766] - relayed: [n=2] TRUE, TRUE
[11:00:26.767] - queued futures: [n=2] TRUE, TRUE
[11:00:26.767] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[11:00:26.767] resolve() on list ... DONE
[11:00:26.767] result() for MulticoreFuture ...
[11:00:26.767] result() for MulticoreFuture ... done
[11:00:26.767] result() for MulticoreFuture ...
[11:00:26.767] result() for MulticoreFuture ... done
[11:00:26.767] result() for MulticoreFuture ...
[11:00:26.768] result() for MulticoreFuture ... done
[11:00:26.768] result() for MulticoreFuture ...
[11:00:26.768] result() for MulticoreFuture ... done
[11:00:26.768]  - Number of value chunks collected: 2
[11:00:26.768] Resolving 2 futures (chunks) ... DONE
[11:00:26.768] Reducing values from 2 chunks ...
[11:00:26.768]  - Number of values collected after concatenation: 2
[11:00:26.768]  - Number of values expected: 2
[11:00:26.768] Reducing values from 2 chunks ... DONE
[11:00:26.769] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[11:00:26.769] plan(): Setting new future strategy stack:
[11:00:26.769] List of future strategies:
[11:00:26.769] 1. multisession:
[11:00:26.769]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:00:26.769]    - tweaked: FALSE
[11:00:26.769]    - call: plan(strategy)
[11:00:26.770] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[11:00:26.770] multisession:
[11:00:26.770] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:00:26.770] - tweaked: FALSE
[11:00:26.770] - call: plan(strategy)
[11:00:26.774] getGlobalsAndPackages() ...
[11:00:26.774] Not searching for globals
[11:00:26.774] - globals: [0] <none>
[11:00:26.774] getGlobalsAndPackages() ... DONE
[11:00:27.250] Packages needed by the future expression (n = 0): <none>
[11:00:27.250] Packages needed by future strategies (n = 0): <none>
[11:00:27.251] {
[11:00:27.251]     {
[11:00:27.251]         {
[11:00:27.251]             ...future.startTime <- base::Sys.time()
[11:00:27.251]             {
[11:00:27.251]                 {
[11:00:27.251]                   {
[11:00:27.251]                     {
[11:00:27.251]                       base::local({
[11:00:27.251]                         has_future <- base::requireNamespace("future", 
[11:00:27.251]                           quietly = TRUE)
[11:00:27.251]                         if (has_future) {
[11:00:27.251]                           ns <- base::getNamespace("future")
[11:00:27.251]                           version <- ns[[".package"]][["version"]]
[11:00:27.251]                           if (is.null(version)) 
[11:00:27.251]                             version <- utils::packageVersion("future")
[11:00:27.251]                         }
[11:00:27.251]                         else {
[11:00:27.251]                           version <- NULL
[11:00:27.251]                         }
[11:00:27.251]                         if (!has_future || version < "1.8.0") {
[11:00:27.251]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:27.251]                             "", base::R.version$version.string), 
[11:00:27.251]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:27.251]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:27.251]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:27.251]                               "release", "version")], collapse = " "), 
[11:00:27.251]                             hostname = base::Sys.info()[["nodename"]])
[11:00:27.251]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:27.251]                             info)
[11:00:27.251]                           info <- base::paste(info, collapse = "; ")
[11:00:27.251]                           if (!has_future) {
[11:00:27.251]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:27.251]                               info)
[11:00:27.251]                           }
[11:00:27.251]                           else {
[11:00:27.251]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:27.251]                               info, version)
[11:00:27.251]                           }
[11:00:27.251]                           base::stop(msg)
[11:00:27.251]                         }
[11:00:27.251]                       })
[11:00:27.251]                     }
[11:00:27.251]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:27.251]                     base::options(mc.cores = 1L)
[11:00:27.251]                   }
[11:00:27.251]                   ...future.strategy.old <- future::plan("list")
[11:00:27.251]                   options(future.plan = NULL)
[11:00:27.251]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:27.251]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:27.251]                 }
[11:00:27.251]                 ...future.workdir <- getwd()
[11:00:27.251]             }
[11:00:27.251]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:27.251]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:27.251]         }
[11:00:27.251]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:27.251]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:00:27.251]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:27.251]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:27.251]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:27.251]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:27.251]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:27.251]             base::names(...future.oldOptions))
[11:00:27.251]     }
[11:00:27.251]     if (FALSE) {
[11:00:27.251]     }
[11:00:27.251]     else {
[11:00:27.251]         if (TRUE) {
[11:00:27.251]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:27.251]                 open = "w")
[11:00:27.251]         }
[11:00:27.251]         else {
[11:00:27.251]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:27.251]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:27.251]         }
[11:00:27.251]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:27.251]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:27.251]             base::sink(type = "output", split = FALSE)
[11:00:27.251]             base::close(...future.stdout)
[11:00:27.251]         }, add = TRUE)
[11:00:27.251]     }
[11:00:27.251]     ...future.frame <- base::sys.nframe()
[11:00:27.251]     ...future.conditions <- base::list()
[11:00:27.251]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:27.251]     if (FALSE) {
[11:00:27.251]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:27.251]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:27.251]     }
[11:00:27.251]     ...future.result <- base::tryCatch({
[11:00:27.251]         base::withCallingHandlers({
[11:00:27.251]             ...future.value <- base::withVisible(base::local({
[11:00:27.251]                 ...future.makeSendCondition <- base::local({
[11:00:27.251]                   sendCondition <- NULL
[11:00:27.251]                   function(frame = 1L) {
[11:00:27.251]                     if (is.function(sendCondition)) 
[11:00:27.251]                       return(sendCondition)
[11:00:27.251]                     ns <- getNamespace("parallel")
[11:00:27.251]                     if (exists("sendData", mode = "function", 
[11:00:27.251]                       envir = ns)) {
[11:00:27.251]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:27.251]                         envir = ns)
[11:00:27.251]                       envir <- sys.frame(frame)
[11:00:27.251]                       master <- NULL
[11:00:27.251]                       while (!identical(envir, .GlobalEnv) && 
[11:00:27.251]                         !identical(envir, emptyenv())) {
[11:00:27.251]                         if (exists("master", mode = "list", envir = envir, 
[11:00:27.251]                           inherits = FALSE)) {
[11:00:27.251]                           master <- get("master", mode = "list", 
[11:00:27.251]                             envir = envir, inherits = FALSE)
[11:00:27.251]                           if (inherits(master, c("SOCKnode", 
[11:00:27.251]                             "SOCK0node"))) {
[11:00:27.251]                             sendCondition <<- function(cond) {
[11:00:27.251]                               data <- list(type = "VALUE", value = cond, 
[11:00:27.251]                                 success = TRUE)
[11:00:27.251]                               parallel_sendData(master, data)
[11:00:27.251]                             }
[11:00:27.251]                             return(sendCondition)
[11:00:27.251]                           }
[11:00:27.251]                         }
[11:00:27.251]                         frame <- frame + 1L
[11:00:27.251]                         envir <- sys.frame(frame)
[11:00:27.251]                       }
[11:00:27.251]                     }
[11:00:27.251]                     sendCondition <<- function(cond) NULL
[11:00:27.251]                   }
[11:00:27.251]                 })
[11:00:27.251]                 withCallingHandlers({
[11:00:27.251]                   NA
[11:00:27.251]                 }, immediateCondition = function(cond) {
[11:00:27.251]                   sendCondition <- ...future.makeSendCondition()
[11:00:27.251]                   sendCondition(cond)
[11:00:27.251]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:27.251]                   {
[11:00:27.251]                     inherits <- base::inherits
[11:00:27.251]                     invokeRestart <- base::invokeRestart
[11:00:27.251]                     is.null <- base::is.null
[11:00:27.251]                     muffled <- FALSE
[11:00:27.251]                     if (inherits(cond, "message")) {
[11:00:27.251]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:27.251]                       if (muffled) 
[11:00:27.251]                         invokeRestart("muffleMessage")
[11:00:27.251]                     }
[11:00:27.251]                     else if (inherits(cond, "warning")) {
[11:00:27.251]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:27.251]                       if (muffled) 
[11:00:27.251]                         invokeRestart("muffleWarning")
[11:00:27.251]                     }
[11:00:27.251]                     else if (inherits(cond, "condition")) {
[11:00:27.251]                       if (!is.null(pattern)) {
[11:00:27.251]                         computeRestarts <- base::computeRestarts
[11:00:27.251]                         grepl <- base::grepl
[11:00:27.251]                         restarts <- computeRestarts(cond)
[11:00:27.251]                         for (restart in restarts) {
[11:00:27.251]                           name <- restart$name
[11:00:27.251]                           if (is.null(name)) 
[11:00:27.251]                             next
[11:00:27.251]                           if (!grepl(pattern, name)) 
[11:00:27.251]                             next
[11:00:27.251]                           invokeRestart(restart)
[11:00:27.251]                           muffled <- TRUE
[11:00:27.251]                           break
[11:00:27.251]                         }
[11:00:27.251]                       }
[11:00:27.251]                     }
[11:00:27.251]                     invisible(muffled)
[11:00:27.251]                   }
[11:00:27.251]                   muffleCondition(cond)
[11:00:27.251]                 })
[11:00:27.251]             }))
[11:00:27.251]             future::FutureResult(value = ...future.value$value, 
[11:00:27.251]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:27.251]                   ...future.rng), globalenv = if (FALSE) 
[11:00:27.251]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:27.251]                     ...future.globalenv.names))
[11:00:27.251]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:27.251]         }, condition = base::local({
[11:00:27.251]             c <- base::c
[11:00:27.251]             inherits <- base::inherits
[11:00:27.251]             invokeRestart <- base::invokeRestart
[11:00:27.251]             length <- base::length
[11:00:27.251]             list <- base::list
[11:00:27.251]             seq.int <- base::seq.int
[11:00:27.251]             signalCondition <- base::signalCondition
[11:00:27.251]             sys.calls <- base::sys.calls
[11:00:27.251]             `[[` <- base::`[[`
[11:00:27.251]             `+` <- base::`+`
[11:00:27.251]             `<<-` <- base::`<<-`
[11:00:27.251]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:27.251]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:27.251]                   3L)]
[11:00:27.251]             }
[11:00:27.251]             function(cond) {
[11:00:27.251]                 is_error <- inherits(cond, "error")
[11:00:27.251]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:27.251]                   NULL)
[11:00:27.251]                 if (is_error) {
[11:00:27.251]                   sessionInformation <- function() {
[11:00:27.251]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:27.251]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:27.251]                       search = base::search(), system = base::Sys.info())
[11:00:27.251]                   }
[11:00:27.251]                   ...future.conditions[[length(...future.conditions) + 
[11:00:27.251]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:27.251]                     cond$call), session = sessionInformation(), 
[11:00:27.251]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:27.251]                   signalCondition(cond)
[11:00:27.251]                 }
[11:00:27.251]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:27.251]                 "immediateCondition"))) {
[11:00:27.251]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:27.251]                   ...future.conditions[[length(...future.conditions) + 
[11:00:27.251]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:27.251]                   if (TRUE && !signal) {
[11:00:27.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:27.251]                     {
[11:00:27.251]                       inherits <- base::inherits
[11:00:27.251]                       invokeRestart <- base::invokeRestart
[11:00:27.251]                       is.null <- base::is.null
[11:00:27.251]                       muffled <- FALSE
[11:00:27.251]                       if (inherits(cond, "message")) {
[11:00:27.251]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:27.251]                         if (muffled) 
[11:00:27.251]                           invokeRestart("muffleMessage")
[11:00:27.251]                       }
[11:00:27.251]                       else if (inherits(cond, "warning")) {
[11:00:27.251]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:27.251]                         if (muffled) 
[11:00:27.251]                           invokeRestart("muffleWarning")
[11:00:27.251]                       }
[11:00:27.251]                       else if (inherits(cond, "condition")) {
[11:00:27.251]                         if (!is.null(pattern)) {
[11:00:27.251]                           computeRestarts <- base::computeRestarts
[11:00:27.251]                           grepl <- base::grepl
[11:00:27.251]                           restarts <- computeRestarts(cond)
[11:00:27.251]                           for (restart in restarts) {
[11:00:27.251]                             name <- restart$name
[11:00:27.251]                             if (is.null(name)) 
[11:00:27.251]                               next
[11:00:27.251]                             if (!grepl(pattern, name)) 
[11:00:27.251]                               next
[11:00:27.251]                             invokeRestart(restart)
[11:00:27.251]                             muffled <- TRUE
[11:00:27.251]                             break
[11:00:27.251]                           }
[11:00:27.251]                         }
[11:00:27.251]                       }
[11:00:27.251]                       invisible(muffled)
[11:00:27.251]                     }
[11:00:27.251]                     muffleCondition(cond, pattern = "^muffle")
[11:00:27.251]                   }
[11:00:27.251]                 }
[11:00:27.251]                 else {
[11:00:27.251]                   if (TRUE) {
[11:00:27.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:27.251]                     {
[11:00:27.251]                       inherits <- base::inherits
[11:00:27.251]                       invokeRestart <- base::invokeRestart
[11:00:27.251]                       is.null <- base::is.null
[11:00:27.251]                       muffled <- FALSE
[11:00:27.251]                       if (inherits(cond, "message")) {
[11:00:27.251]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:27.251]                         if (muffled) 
[11:00:27.251]                           invokeRestart("muffleMessage")
[11:00:27.251]                       }
[11:00:27.251]                       else if (inherits(cond, "warning")) {
[11:00:27.251]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:27.251]                         if (muffled) 
[11:00:27.251]                           invokeRestart("muffleWarning")
[11:00:27.251]                       }
[11:00:27.251]                       else if (inherits(cond, "condition")) {
[11:00:27.251]                         if (!is.null(pattern)) {
[11:00:27.251]                           computeRestarts <- base::computeRestarts
[11:00:27.251]                           grepl <- base::grepl
[11:00:27.251]                           restarts <- computeRestarts(cond)
[11:00:27.251]                           for (restart in restarts) {
[11:00:27.251]                             name <- restart$name
[11:00:27.251]                             if (is.null(name)) 
[11:00:27.251]                               next
[11:00:27.251]                             if (!grepl(pattern, name)) 
[11:00:27.251]                               next
[11:00:27.251]                             invokeRestart(restart)
[11:00:27.251]                             muffled <- TRUE
[11:00:27.251]                             break
[11:00:27.251]                           }
[11:00:27.251]                         }
[11:00:27.251]                       }
[11:00:27.251]                       invisible(muffled)
[11:00:27.251]                     }
[11:00:27.251]                     muffleCondition(cond, pattern = "^muffle")
[11:00:27.251]                   }
[11:00:27.251]                 }
[11:00:27.251]             }
[11:00:27.251]         }))
[11:00:27.251]     }, error = function(ex) {
[11:00:27.251]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:27.251]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:27.251]                 ...future.rng), started = ...future.startTime, 
[11:00:27.251]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:27.251]             version = "1.8"), class = "FutureResult")
[11:00:27.251]     }, finally = {
[11:00:27.251]         if (!identical(...future.workdir, getwd())) 
[11:00:27.251]             setwd(...future.workdir)
[11:00:27.251]         {
[11:00:27.251]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:27.251]                 ...future.oldOptions$nwarnings <- NULL
[11:00:27.251]             }
[11:00:27.251]             base::options(...future.oldOptions)
[11:00:27.251]             if (.Platform$OS.type == "windows") {
[11:00:27.251]                 old_names <- names(...future.oldEnvVars)
[11:00:27.251]                 envs <- base::Sys.getenv()
[11:00:27.251]                 names <- names(envs)
[11:00:27.251]                 common <- intersect(names, old_names)
[11:00:27.251]                 added <- setdiff(names, old_names)
[11:00:27.251]                 removed <- setdiff(old_names, names)
[11:00:27.251]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:27.251]                   envs[common]]
[11:00:27.251]                 NAMES <- toupper(changed)
[11:00:27.251]                 args <- list()
[11:00:27.251]                 for (kk in seq_along(NAMES)) {
[11:00:27.251]                   name <- changed[[kk]]
[11:00:27.251]                   NAME <- NAMES[[kk]]
[11:00:27.251]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:27.251]                     next
[11:00:27.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:27.251]                 }
[11:00:27.251]                 NAMES <- toupper(added)
[11:00:27.251]                 for (kk in seq_along(NAMES)) {
[11:00:27.251]                   name <- added[[kk]]
[11:00:27.251]                   NAME <- NAMES[[kk]]
[11:00:27.251]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:27.251]                     next
[11:00:27.251]                   args[[name]] <- ""
[11:00:27.251]                 }
[11:00:27.251]                 NAMES <- toupper(removed)
[11:00:27.251]                 for (kk in seq_along(NAMES)) {
[11:00:27.251]                   name <- removed[[kk]]
[11:00:27.251]                   NAME <- NAMES[[kk]]
[11:00:27.251]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:27.251]                     next
[11:00:27.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:27.251]                 }
[11:00:27.251]                 if (length(args) > 0) 
[11:00:27.251]                   base::do.call(base::Sys.setenv, args = args)
[11:00:27.251]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:27.251]             }
[11:00:27.251]             else {
[11:00:27.251]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:27.251]             }
[11:00:27.251]             {
[11:00:27.251]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:27.251]                   0L) {
[11:00:27.251]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:27.251]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:27.251]                   base::options(opts)
[11:00:27.251]                 }
[11:00:27.251]                 {
[11:00:27.251]                   {
[11:00:27.251]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:27.251]                     NULL
[11:00:27.251]                   }
[11:00:27.251]                   options(future.plan = NULL)
[11:00:27.251]                   if (is.na(NA_character_)) 
[11:00:27.251]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:27.251]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:27.251]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:27.251]                     .init = FALSE)
[11:00:27.251]                 }
[11:00:27.251]             }
[11:00:27.251]         }
[11:00:27.251]     })
[11:00:27.251]     if (TRUE) {
[11:00:27.251]         base::sink(type = "output", split = FALSE)
[11:00:27.251]         if (TRUE) {
[11:00:27.251]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:27.251]         }
[11:00:27.251]         else {
[11:00:27.251]             ...future.result["stdout"] <- base::list(NULL)
[11:00:27.251]         }
[11:00:27.251]         base::close(...future.stdout)
[11:00:27.251]         ...future.stdout <- NULL
[11:00:27.251]     }
[11:00:27.251]     ...future.result$conditions <- ...future.conditions
[11:00:27.251]     ...future.result$finished <- base::Sys.time()
[11:00:27.251]     ...future.result
[11:00:27.251] }
[11:00:27.302] MultisessionFuture started
[11:00:27.302] result() for ClusterFuture ...
[11:00:27.303] receiveMessageFromWorker() for ClusterFuture ...
[11:00:27.303] - Validating connection of MultisessionFuture
[11:00:27.332] - received message: FutureResult
[11:00:27.332] - Received FutureResult
[11:00:27.332] - Erased future from FutureRegistry
[11:00:27.333] result() for ClusterFuture ...
[11:00:27.333] - result already collected: FutureResult
[11:00:27.333] result() for ClusterFuture ... done
[11:00:27.333] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:27.333] result() for ClusterFuture ... done
[11:00:27.333] result() for ClusterFuture ...
[11:00:27.333] - result already collected: FutureResult
[11:00:27.333] result() for ClusterFuture ... done
[11:00:27.333] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[11:00:27.335] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[11:00:27.335] future_lapply() ...
[11:00:27.337] Number of chunks: 2
[11:00:27.337] getGlobalsAndPackagesXApply() ...
[11:00:27.337]  - future.globals: TRUE
[11:00:27.337] getGlobalsAndPackages() ...
[11:00:27.337] Searching for globals...
[11:00:27.339] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[11:00:27.339] Searching for globals ... DONE
[11:00:27.339] Resolving globals: FALSE
[11:00:27.339] The total size of the 1 globals is 841 bytes (841 bytes)
[11:00:27.340] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[11:00:27.340] - globals: [1] ‘FUN’
[11:00:27.340] 
[11:00:27.340] getGlobalsAndPackages() ... DONE
[11:00:27.340]  - globals found/used: [n=1] ‘FUN’
[11:00:27.340]  - needed namespaces: [n=0] 
[11:00:27.340] Finding globals ... DONE
[11:00:27.340]  - use_args: TRUE
[11:00:27.340]  - Getting '...' globals ...
[11:00:27.341] resolve() on list ...
[11:00:27.341]  recursive: 0
[11:00:27.341]  length: 1
[11:00:27.341]  elements: ‘...’
[11:00:27.341]  length: 0 (resolved future 1)
[11:00:27.341] resolve() on list ... DONE
[11:00:27.341]    - '...' content: [n=0] 
[11:00:27.341] List of 1
[11:00:27.341]  $ ...: list()
[11:00:27.341]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:27.341]  - attr(*, "where")=List of 1
[11:00:27.341]   ..$ ...:<environment: 0x55ceb3a425e8> 
[11:00:27.341]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:27.341]  - attr(*, "resolved")= logi TRUE
[11:00:27.341]  - attr(*, "total_size")= num NA
[11:00:27.344]  - Getting '...' globals ... DONE
[11:00:27.344] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[11:00:27.344] List of 2
[11:00:27.344]  $ ...future.FUN:function (x)  
[11:00:27.344]  $ ...          : list()
[11:00:27.344]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:27.344]  - attr(*, "where")=List of 2
[11:00:27.344]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:27.344]   ..$ ...          :<environment: 0x55ceb3a425e8> 
[11:00:27.344]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:27.344]  - attr(*, "resolved")= logi FALSE
[11:00:27.344]  - attr(*, "total_size")= num 5632
[11:00:27.347] Packages to be attached in all futures: [n=0] 
[11:00:27.347] getGlobalsAndPackagesXApply() ... DONE
[11:00:27.347] Number of futures (= number of chunks): 2
[11:00:27.347] Launching 2 futures (chunks) ...
[11:00:27.347] Chunk #1 of 2 ...
[11:00:27.347]  - Finding globals in 'X' for chunk #1 ...
[11:00:27.347] getGlobalsAndPackages() ...
[11:00:27.347] Searching for globals...
[11:00:27.348] 
[11:00:27.348] Searching for globals ... DONE
[11:00:27.348] - globals: [0] <none>
[11:00:27.348] getGlobalsAndPackages() ... DONE
[11:00:27.348]    + additional globals found: [n=0] 
[11:00:27.348]    + additional namespaces needed: [n=0] 
[11:00:27.348]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:27.348]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:27.348]  - seeds: <none>
[11:00:27.348]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:27.349] getGlobalsAndPackages() ...
[11:00:27.349] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:27.349] Resolving globals: FALSE
[11:00:27.349] Tweak future expression to call with '...' arguments ...
[11:00:27.349] {
[11:00:27.349]     do.call(function(...) {
[11:00:27.349]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:27.349]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:27.349]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:27.349]             on.exit(options(oopts), add = TRUE)
[11:00:27.349]         }
[11:00:27.349]         {
[11:00:27.349]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:27.349]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:27.349]                 ...future.FUN(...future.X_jj, ...)
[11:00:27.349]             })
[11:00:27.349]         }
[11:00:27.349]     }, args = future.call.arguments)
[11:00:27.349] }
[11:00:27.349] Tweak future expression to call with '...' arguments ... DONE
[11:00:27.350] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:27.350] 
[11:00:27.350] getGlobalsAndPackages() ... DONE
[11:00:27.350] run() for ‘Future’ ...
[11:00:27.350] - state: ‘created’
[11:00:27.350] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:27.365] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:27.365] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:27.365]   - Field: ‘node’
[11:00:27.365]   - Field: ‘label’
[11:00:27.365]   - Field: ‘local’
[11:00:27.365]   - Field: ‘owner’
[11:00:27.365]   - Field: ‘envir’
[11:00:27.366]   - Field: ‘workers’
[11:00:27.366]   - Field: ‘packages’
[11:00:27.366]   - Field: ‘gc’
[11:00:27.366]   - Field: ‘conditions’
[11:00:27.366]   - Field: ‘persistent’
[11:00:27.366]   - Field: ‘expr’
[11:00:27.366]   - Field: ‘uuid’
[11:00:27.366]   - Field: ‘seed’
[11:00:27.366]   - Field: ‘version’
[11:00:27.366]   - Field: ‘result’
[11:00:27.367]   - Field: ‘asynchronous’
[11:00:27.367]   - Field: ‘calls’
[11:00:27.367]   - Field: ‘globals’
[11:00:27.367]   - Field: ‘stdout’
[11:00:27.367]   - Field: ‘earlySignal’
[11:00:27.367]   - Field: ‘lazy’
[11:00:27.367]   - Field: ‘state’
[11:00:27.367] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:27.367] - Launch lazy future ...
[11:00:27.368] Packages needed by the future expression (n = 0): <none>
[11:00:27.368] Packages needed by future strategies (n = 0): <none>
[11:00:27.368] {
[11:00:27.368]     {
[11:00:27.368]         {
[11:00:27.368]             ...future.startTime <- base::Sys.time()
[11:00:27.368]             {
[11:00:27.368]                 {
[11:00:27.368]                   {
[11:00:27.368]                     {
[11:00:27.368]                       base::local({
[11:00:27.368]                         has_future <- base::requireNamespace("future", 
[11:00:27.368]                           quietly = TRUE)
[11:00:27.368]                         if (has_future) {
[11:00:27.368]                           ns <- base::getNamespace("future")
[11:00:27.368]                           version <- ns[[".package"]][["version"]]
[11:00:27.368]                           if (is.null(version)) 
[11:00:27.368]                             version <- utils::packageVersion("future")
[11:00:27.368]                         }
[11:00:27.368]                         else {
[11:00:27.368]                           version <- NULL
[11:00:27.368]                         }
[11:00:27.368]                         if (!has_future || version < "1.8.0") {
[11:00:27.368]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:27.368]                             "", base::R.version$version.string), 
[11:00:27.368]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:27.368]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:27.368]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:27.368]                               "release", "version")], collapse = " "), 
[11:00:27.368]                             hostname = base::Sys.info()[["nodename"]])
[11:00:27.368]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:27.368]                             info)
[11:00:27.368]                           info <- base::paste(info, collapse = "; ")
[11:00:27.368]                           if (!has_future) {
[11:00:27.368]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:27.368]                               info)
[11:00:27.368]                           }
[11:00:27.368]                           else {
[11:00:27.368]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:27.368]                               info, version)
[11:00:27.368]                           }
[11:00:27.368]                           base::stop(msg)
[11:00:27.368]                         }
[11:00:27.368]                       })
[11:00:27.368]                     }
[11:00:27.368]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:27.368]                     base::options(mc.cores = 1L)
[11:00:27.368]                   }
[11:00:27.368]                   ...future.strategy.old <- future::plan("list")
[11:00:27.368]                   options(future.plan = NULL)
[11:00:27.368]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:27.368]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:27.368]                 }
[11:00:27.368]                 ...future.workdir <- getwd()
[11:00:27.368]             }
[11:00:27.368]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:27.368]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:27.368]         }
[11:00:27.368]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:27.368]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:27.368]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:27.368]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:27.368]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:27.368]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:27.368]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:27.368]             base::names(...future.oldOptions))
[11:00:27.368]     }
[11:00:27.368]     if (FALSE) {
[11:00:27.368]     }
[11:00:27.368]     else {
[11:00:27.368]         if (FALSE) {
[11:00:27.368]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:27.368]                 open = "w")
[11:00:27.368]         }
[11:00:27.368]         else {
[11:00:27.368]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:27.368]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:27.368]         }
[11:00:27.368]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:27.368]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:27.368]             base::sink(type = "output", split = FALSE)
[11:00:27.368]             base::close(...future.stdout)
[11:00:27.368]         }, add = TRUE)
[11:00:27.368]     }
[11:00:27.368]     ...future.frame <- base::sys.nframe()
[11:00:27.368]     ...future.conditions <- base::list()
[11:00:27.368]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:27.368]     if (FALSE) {
[11:00:27.368]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:27.368]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:27.368]     }
[11:00:27.368]     ...future.result <- base::tryCatch({
[11:00:27.368]         base::withCallingHandlers({
[11:00:27.368]             ...future.value <- base::withVisible(base::local({
[11:00:27.368]                 ...future.makeSendCondition <- base::local({
[11:00:27.368]                   sendCondition <- NULL
[11:00:27.368]                   function(frame = 1L) {
[11:00:27.368]                     if (is.function(sendCondition)) 
[11:00:27.368]                       return(sendCondition)
[11:00:27.368]                     ns <- getNamespace("parallel")
[11:00:27.368]                     if (exists("sendData", mode = "function", 
[11:00:27.368]                       envir = ns)) {
[11:00:27.368]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:27.368]                         envir = ns)
[11:00:27.368]                       envir <- sys.frame(frame)
[11:00:27.368]                       master <- NULL
[11:00:27.368]                       while (!identical(envir, .GlobalEnv) && 
[11:00:27.368]                         !identical(envir, emptyenv())) {
[11:00:27.368]                         if (exists("master", mode = "list", envir = envir, 
[11:00:27.368]                           inherits = FALSE)) {
[11:00:27.368]                           master <- get("master", mode = "list", 
[11:00:27.368]                             envir = envir, inherits = FALSE)
[11:00:27.368]                           if (inherits(master, c("SOCKnode", 
[11:00:27.368]                             "SOCK0node"))) {
[11:00:27.368]                             sendCondition <<- function(cond) {
[11:00:27.368]                               data <- list(type = "VALUE", value = cond, 
[11:00:27.368]                                 success = TRUE)
[11:00:27.368]                               parallel_sendData(master, data)
[11:00:27.368]                             }
[11:00:27.368]                             return(sendCondition)
[11:00:27.368]                           }
[11:00:27.368]                         }
[11:00:27.368]                         frame <- frame + 1L
[11:00:27.368]                         envir <- sys.frame(frame)
[11:00:27.368]                       }
[11:00:27.368]                     }
[11:00:27.368]                     sendCondition <<- function(cond) NULL
[11:00:27.368]                   }
[11:00:27.368]                 })
[11:00:27.368]                 withCallingHandlers({
[11:00:27.368]                   {
[11:00:27.368]                     do.call(function(...) {
[11:00:27.368]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:27.368]                       if (!identical(...future.globals.maxSize.org, 
[11:00:27.368]                         ...future.globals.maxSize)) {
[11:00:27.368]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:27.368]                         on.exit(options(oopts), add = TRUE)
[11:00:27.368]                       }
[11:00:27.368]                       {
[11:00:27.368]                         lapply(seq_along(...future.elements_ii), 
[11:00:27.368]                           FUN = function(jj) {
[11:00:27.368]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:27.368]                             ...future.FUN(...future.X_jj, ...)
[11:00:27.368]                           })
[11:00:27.368]                       }
[11:00:27.368]                     }, args = future.call.arguments)
[11:00:27.368]                   }
[11:00:27.368]                 }, immediateCondition = function(cond) {
[11:00:27.368]                   sendCondition <- ...future.makeSendCondition()
[11:00:27.368]                   sendCondition(cond)
[11:00:27.368]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:27.368]                   {
[11:00:27.368]                     inherits <- base::inherits
[11:00:27.368]                     invokeRestart <- base::invokeRestart
[11:00:27.368]                     is.null <- base::is.null
[11:00:27.368]                     muffled <- FALSE
[11:00:27.368]                     if (inherits(cond, "message")) {
[11:00:27.368]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:27.368]                       if (muffled) 
[11:00:27.368]                         invokeRestart("muffleMessage")
[11:00:27.368]                     }
[11:00:27.368]                     else if (inherits(cond, "warning")) {
[11:00:27.368]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:27.368]                       if (muffled) 
[11:00:27.368]                         invokeRestart("muffleWarning")
[11:00:27.368]                     }
[11:00:27.368]                     else if (inherits(cond, "condition")) {
[11:00:27.368]                       if (!is.null(pattern)) {
[11:00:27.368]                         computeRestarts <- base::computeRestarts
[11:00:27.368]                         grepl <- base::grepl
[11:00:27.368]                         restarts <- computeRestarts(cond)
[11:00:27.368]                         for (restart in restarts) {
[11:00:27.368]                           name <- restart$name
[11:00:27.368]                           if (is.null(name)) 
[11:00:27.368]                             next
[11:00:27.368]                           if (!grepl(pattern, name)) 
[11:00:27.368]                             next
[11:00:27.368]                           invokeRestart(restart)
[11:00:27.368]                           muffled <- TRUE
[11:00:27.368]                           break
[11:00:27.368]                         }
[11:00:27.368]                       }
[11:00:27.368]                     }
[11:00:27.368]                     invisible(muffled)
[11:00:27.368]                   }
[11:00:27.368]                   muffleCondition(cond)
[11:00:27.368]                 })
[11:00:27.368]             }))
[11:00:27.368]             future::FutureResult(value = ...future.value$value, 
[11:00:27.368]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:27.368]                   ...future.rng), globalenv = if (FALSE) 
[11:00:27.368]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:27.368]                     ...future.globalenv.names))
[11:00:27.368]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:27.368]         }, condition = base::local({
[11:00:27.368]             c <- base::c
[11:00:27.368]             inherits <- base::inherits
[11:00:27.368]             invokeRestart <- base::invokeRestart
[11:00:27.368]             length <- base::length
[11:00:27.368]             list <- base::list
[11:00:27.368]             seq.int <- base::seq.int
[11:00:27.368]             signalCondition <- base::signalCondition
[11:00:27.368]             sys.calls <- base::sys.calls
[11:00:27.368]             `[[` <- base::`[[`
[11:00:27.368]             `+` <- base::`+`
[11:00:27.368]             `<<-` <- base::`<<-`
[11:00:27.368]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:27.368]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:27.368]                   3L)]
[11:00:27.368]             }
[11:00:27.368]             function(cond) {
[11:00:27.368]                 is_error <- inherits(cond, "error")
[11:00:27.368]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:27.368]                   NULL)
[11:00:27.368]                 if (is_error) {
[11:00:27.368]                   sessionInformation <- function() {
[11:00:27.368]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:27.368]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:27.368]                       search = base::search(), system = base::Sys.info())
[11:00:27.368]                   }
[11:00:27.368]                   ...future.conditions[[length(...future.conditions) + 
[11:00:27.368]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:27.368]                     cond$call), session = sessionInformation(), 
[11:00:27.368]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:27.368]                   signalCondition(cond)
[11:00:27.368]                 }
[11:00:27.368]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:27.368]                 "immediateCondition"))) {
[11:00:27.368]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:27.368]                   ...future.conditions[[length(...future.conditions) + 
[11:00:27.368]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:27.368]                   if (TRUE && !signal) {
[11:00:27.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:27.368]                     {
[11:00:27.368]                       inherits <- base::inherits
[11:00:27.368]                       invokeRestart <- base::invokeRestart
[11:00:27.368]                       is.null <- base::is.null
[11:00:27.368]                       muffled <- FALSE
[11:00:27.368]                       if (inherits(cond, "message")) {
[11:00:27.368]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:27.368]                         if (muffled) 
[11:00:27.368]                           invokeRestart("muffleMessage")
[11:00:27.368]                       }
[11:00:27.368]                       else if (inherits(cond, "warning")) {
[11:00:27.368]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:27.368]                         if (muffled) 
[11:00:27.368]                           invokeRestart("muffleWarning")
[11:00:27.368]                       }
[11:00:27.368]                       else if (inherits(cond, "condition")) {
[11:00:27.368]                         if (!is.null(pattern)) {
[11:00:27.368]                           computeRestarts <- base::computeRestarts
[11:00:27.368]                           grepl <- base::grepl
[11:00:27.368]                           restarts <- computeRestarts(cond)
[11:00:27.368]                           for (restart in restarts) {
[11:00:27.368]                             name <- restart$name
[11:00:27.368]                             if (is.null(name)) 
[11:00:27.368]                               next
[11:00:27.368]                             if (!grepl(pattern, name)) 
[11:00:27.368]                               next
[11:00:27.368]                             invokeRestart(restart)
[11:00:27.368]                             muffled <- TRUE
[11:00:27.368]                             break
[11:00:27.368]                           }
[11:00:27.368]                         }
[11:00:27.368]                       }
[11:00:27.368]                       invisible(muffled)
[11:00:27.368]                     }
[11:00:27.368]                     muffleCondition(cond, pattern = "^muffle")
[11:00:27.368]                   }
[11:00:27.368]                 }
[11:00:27.368]                 else {
[11:00:27.368]                   if (TRUE) {
[11:00:27.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:27.368]                     {
[11:00:27.368]                       inherits <- base::inherits
[11:00:27.368]                       invokeRestart <- base::invokeRestart
[11:00:27.368]                       is.null <- base::is.null
[11:00:27.368]                       muffled <- FALSE
[11:00:27.368]                       if (inherits(cond, "message")) {
[11:00:27.368]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:27.368]                         if (muffled) 
[11:00:27.368]                           invokeRestart("muffleMessage")
[11:00:27.368]                       }
[11:00:27.368]                       else if (inherits(cond, "warning")) {
[11:00:27.368]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:27.368]                         if (muffled) 
[11:00:27.368]                           invokeRestart("muffleWarning")
[11:00:27.368]                       }
[11:00:27.368]                       else if (inherits(cond, "condition")) {
[11:00:27.368]                         if (!is.null(pattern)) {
[11:00:27.368]                           computeRestarts <- base::computeRestarts
[11:00:27.368]                           grepl <- base::grepl
[11:00:27.368]                           restarts <- computeRestarts(cond)
[11:00:27.368]                           for (restart in restarts) {
[11:00:27.368]                             name <- restart$name
[11:00:27.368]                             if (is.null(name)) 
[11:00:27.368]                               next
[11:00:27.368]                             if (!grepl(pattern, name)) 
[11:00:27.368]                               next
[11:00:27.368]                             invokeRestart(restart)
[11:00:27.368]                             muffled <- TRUE
[11:00:27.368]                             break
[11:00:27.368]                           }
[11:00:27.368]                         }
[11:00:27.368]                       }
[11:00:27.368]                       invisible(muffled)
[11:00:27.368]                     }
[11:00:27.368]                     muffleCondition(cond, pattern = "^muffle")
[11:00:27.368]                   }
[11:00:27.368]                 }
[11:00:27.368]             }
[11:00:27.368]         }))
[11:00:27.368]     }, error = function(ex) {
[11:00:27.368]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:27.368]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:27.368]                 ...future.rng), started = ...future.startTime, 
[11:00:27.368]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:27.368]             version = "1.8"), class = "FutureResult")
[11:00:27.368]     }, finally = {
[11:00:27.368]         if (!identical(...future.workdir, getwd())) 
[11:00:27.368]             setwd(...future.workdir)
[11:00:27.368]         {
[11:00:27.368]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:27.368]                 ...future.oldOptions$nwarnings <- NULL
[11:00:27.368]             }
[11:00:27.368]             base::options(...future.oldOptions)
[11:00:27.368]             if (.Platform$OS.type == "windows") {
[11:00:27.368]                 old_names <- names(...future.oldEnvVars)
[11:00:27.368]                 envs <- base::Sys.getenv()
[11:00:27.368]                 names <- names(envs)
[11:00:27.368]                 common <- intersect(names, old_names)
[11:00:27.368]                 added <- setdiff(names, old_names)
[11:00:27.368]                 removed <- setdiff(old_names, names)
[11:00:27.368]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:27.368]                   envs[common]]
[11:00:27.368]                 NAMES <- toupper(changed)
[11:00:27.368]                 args <- list()
[11:00:27.368]                 for (kk in seq_along(NAMES)) {
[11:00:27.368]                   name <- changed[[kk]]
[11:00:27.368]                   NAME <- NAMES[[kk]]
[11:00:27.368]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:27.368]                     next
[11:00:27.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:27.368]                 }
[11:00:27.368]                 NAMES <- toupper(added)
[11:00:27.368]                 for (kk in seq_along(NAMES)) {
[11:00:27.368]                   name <- added[[kk]]
[11:00:27.368]                   NAME <- NAMES[[kk]]
[11:00:27.368]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:27.368]                     next
[11:00:27.368]                   args[[name]] <- ""
[11:00:27.368]                 }
[11:00:27.368]                 NAMES <- toupper(removed)
[11:00:27.368]                 for (kk in seq_along(NAMES)) {
[11:00:27.368]                   name <- removed[[kk]]
[11:00:27.368]                   NAME <- NAMES[[kk]]
[11:00:27.368]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:27.368]                     next
[11:00:27.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:27.368]                 }
[11:00:27.368]                 if (length(args) > 0) 
[11:00:27.368]                   base::do.call(base::Sys.setenv, args = args)
[11:00:27.368]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:27.368]             }
[11:00:27.368]             else {
[11:00:27.368]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:27.368]             }
[11:00:27.368]             {
[11:00:27.368]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:27.368]                   0L) {
[11:00:27.368]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:27.368]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:27.368]                   base::options(opts)
[11:00:27.368]                 }
[11:00:27.368]                 {
[11:00:27.368]                   {
[11:00:27.368]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:27.368]                     NULL
[11:00:27.368]                   }
[11:00:27.368]                   options(future.plan = NULL)
[11:00:27.368]                   if (is.na(NA_character_)) 
[11:00:27.368]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:27.368]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:27.368]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:27.368]                     .init = FALSE)
[11:00:27.368]                 }
[11:00:27.368]             }
[11:00:27.368]         }
[11:00:27.368]     })
[11:00:27.368]     if (TRUE) {
[11:00:27.368]         base::sink(type = "output", split = FALSE)
[11:00:27.368]         if (FALSE) {
[11:00:27.368]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:27.368]         }
[11:00:27.368]         else {
[11:00:27.368]             ...future.result["stdout"] <- base::list(NULL)
[11:00:27.368]         }
[11:00:27.368]         base::close(...future.stdout)
[11:00:27.368]         ...future.stdout <- NULL
[11:00:27.368]     }
[11:00:27.368]     ...future.result$conditions <- ...future.conditions
[11:00:27.368]     ...future.result$finished <- base::Sys.time()
[11:00:27.368]     ...future.result
[11:00:27.368] }
[11:00:27.371] Exporting 5 global objects (1.46 KiB) to cluster node #1 ...
[11:00:27.372] Exporting ‘...future.FUN’ (841 bytes) to cluster node #1 ...
[11:00:27.372] Exporting ‘...future.FUN’ (841 bytes) to cluster node #1 ... DONE
[11:00:27.372] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[11:00:27.373] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[11:00:27.373] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ...
[11:00:27.373] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ... DONE
[11:00:27.373] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[11:00:27.373] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[11:00:27.374] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[11:00:27.374] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[11:00:27.374] Exporting 5 global objects (1.46 KiB) to cluster node #1 ... DONE
[11:00:27.375] MultisessionFuture started
[11:00:27.375] - Launch lazy future ... done
[11:00:27.375] run() for ‘MultisessionFuture’ ... done
[11:00:27.375] Created future:
[11:00:27.375] MultisessionFuture:
[11:00:27.375] Label: ‘future_lapply-1’
[11:00:27.375] Expression:
[11:00:27.375] {
[11:00:27.375]     do.call(function(...) {
[11:00:27.375]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:27.375]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:27.375]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:27.375]             on.exit(options(oopts), add = TRUE)
[11:00:27.375]         }
[11:00:27.375]         {
[11:00:27.375]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:27.375]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:27.375]                 ...future.FUN(...future.X_jj, ...)
[11:00:27.375]             })
[11:00:27.375]         }
[11:00:27.375]     }, args = future.call.arguments)
[11:00:27.375] }
[11:00:27.375] Lazy evaluation: FALSE
[11:00:27.375] Asynchronous evaluation: TRUE
[11:00:27.375] Local evaluation: TRUE
[11:00:27.375] Environment: R_GlobalEnv
[11:00:27.375] Capture standard output: FALSE
[11:00:27.375] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:27.375] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:27.375] Packages: <none>
[11:00:27.375] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:27.375] Resolved: FALSE
[11:00:27.375] Value: <not collected>
[11:00:27.375] Conditions captured: <none>
[11:00:27.375] Early signaling: FALSE
[11:00:27.375] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:27.375] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:27.387] Chunk #1 of 2 ... DONE
[11:00:27.387] Chunk #2 of 2 ...
[11:00:27.387]  - Finding globals in 'X' for chunk #2 ...
[11:00:27.387] getGlobalsAndPackages() ...
[11:00:27.387] Searching for globals...
[11:00:27.388] 
[11:00:27.388] Searching for globals ... DONE
[11:00:27.388] - globals: [0] <none>
[11:00:27.388] getGlobalsAndPackages() ... DONE
[11:00:27.388]    + additional globals found: [n=0] 
[11:00:27.388]    + additional namespaces needed: [n=0] 
[11:00:27.388]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:27.388]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:27.388]  - seeds: <none>
[11:00:27.389]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:27.389] getGlobalsAndPackages() ...
[11:00:27.389] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:27.389] Resolving globals: FALSE
[11:00:27.389] Tweak future expression to call with '...' arguments ...
[11:00:27.389] {
[11:00:27.389]     do.call(function(...) {
[11:00:27.389]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:27.389]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:27.389]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:27.389]             on.exit(options(oopts), add = TRUE)
[11:00:27.389]         }
[11:00:27.389]         {
[11:00:27.389]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:27.389]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:27.389]                 ...future.FUN(...future.X_jj, ...)
[11:00:27.389]             })
[11:00:27.389]         }
[11:00:27.389]     }, args = future.call.arguments)
[11:00:27.389] }
[11:00:27.389] Tweak future expression to call with '...' arguments ... DONE
[11:00:27.390] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:27.390] 
[11:00:27.390] getGlobalsAndPackages() ... DONE
[11:00:27.390] run() for ‘Future’ ...
[11:00:27.391] - state: ‘created’
[11:00:27.391] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:27.405] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:27.405] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:27.405]   - Field: ‘node’
[11:00:27.405]   - Field: ‘label’
[11:00:27.406]   - Field: ‘local’
[11:00:27.406]   - Field: ‘owner’
[11:00:27.406]   - Field: ‘envir’
[11:00:27.406]   - Field: ‘workers’
[11:00:27.406]   - Field: ‘packages’
[11:00:27.406]   - Field: ‘gc’
[11:00:27.406]   - Field: ‘conditions’
[11:00:27.406]   - Field: ‘persistent’
[11:00:27.406]   - Field: ‘expr’
[11:00:27.406]   - Field: ‘uuid’
[11:00:27.407]   - Field: ‘seed’
[11:00:27.407]   - Field: ‘version’
[11:00:27.407]   - Field: ‘result’
[11:00:27.407]   - Field: ‘asynchronous’
[11:00:27.407]   - Field: ‘calls’
[11:00:27.407]   - Field: ‘globals’
[11:00:27.407]   - Field: ‘stdout’
[11:00:27.407]   - Field: ‘earlySignal’
[11:00:27.407]   - Field: ‘lazy’
[11:00:27.407]   - Field: ‘state’
[11:00:27.408] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:27.408] - Launch lazy future ...
[11:00:27.408] Packages needed by the future expression (n = 0): <none>
[11:00:27.408] Packages needed by future strategies (n = 0): <none>
[11:00:27.409] {
[11:00:27.409]     {
[11:00:27.409]         {
[11:00:27.409]             ...future.startTime <- base::Sys.time()
[11:00:27.409]             {
[11:00:27.409]                 {
[11:00:27.409]                   {
[11:00:27.409]                     {
[11:00:27.409]                       base::local({
[11:00:27.409]                         has_future <- base::requireNamespace("future", 
[11:00:27.409]                           quietly = TRUE)
[11:00:27.409]                         if (has_future) {
[11:00:27.409]                           ns <- base::getNamespace("future")
[11:00:27.409]                           version <- ns[[".package"]][["version"]]
[11:00:27.409]                           if (is.null(version)) 
[11:00:27.409]                             version <- utils::packageVersion("future")
[11:00:27.409]                         }
[11:00:27.409]                         else {
[11:00:27.409]                           version <- NULL
[11:00:27.409]                         }
[11:00:27.409]                         if (!has_future || version < "1.8.0") {
[11:00:27.409]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:27.409]                             "", base::R.version$version.string), 
[11:00:27.409]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:27.409]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:27.409]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:27.409]                               "release", "version")], collapse = " "), 
[11:00:27.409]                             hostname = base::Sys.info()[["nodename"]])
[11:00:27.409]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:27.409]                             info)
[11:00:27.409]                           info <- base::paste(info, collapse = "; ")
[11:00:27.409]                           if (!has_future) {
[11:00:27.409]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:27.409]                               info)
[11:00:27.409]                           }
[11:00:27.409]                           else {
[11:00:27.409]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:27.409]                               info, version)
[11:00:27.409]                           }
[11:00:27.409]                           base::stop(msg)
[11:00:27.409]                         }
[11:00:27.409]                       })
[11:00:27.409]                     }
[11:00:27.409]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:27.409]                     base::options(mc.cores = 1L)
[11:00:27.409]                   }
[11:00:27.409]                   ...future.strategy.old <- future::plan("list")
[11:00:27.409]                   options(future.plan = NULL)
[11:00:27.409]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:27.409]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:27.409]                 }
[11:00:27.409]                 ...future.workdir <- getwd()
[11:00:27.409]             }
[11:00:27.409]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:27.409]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:27.409]         }
[11:00:27.409]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:27.409]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:27.409]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:27.409]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:27.409]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:27.409]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:27.409]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:27.409]             base::names(...future.oldOptions))
[11:00:27.409]     }
[11:00:27.409]     if (FALSE) {
[11:00:27.409]     }
[11:00:27.409]     else {
[11:00:27.409]         if (FALSE) {
[11:00:27.409]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:27.409]                 open = "w")
[11:00:27.409]         }
[11:00:27.409]         else {
[11:00:27.409]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:27.409]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:27.409]         }
[11:00:27.409]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:27.409]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:27.409]             base::sink(type = "output", split = FALSE)
[11:00:27.409]             base::close(...future.stdout)
[11:00:27.409]         }, add = TRUE)
[11:00:27.409]     }
[11:00:27.409]     ...future.frame <- base::sys.nframe()
[11:00:27.409]     ...future.conditions <- base::list()
[11:00:27.409]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:27.409]     if (FALSE) {
[11:00:27.409]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:27.409]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:27.409]     }
[11:00:27.409]     ...future.result <- base::tryCatch({
[11:00:27.409]         base::withCallingHandlers({
[11:00:27.409]             ...future.value <- base::withVisible(base::local({
[11:00:27.409]                 ...future.makeSendCondition <- base::local({
[11:00:27.409]                   sendCondition <- NULL
[11:00:27.409]                   function(frame = 1L) {
[11:00:27.409]                     if (is.function(sendCondition)) 
[11:00:27.409]                       return(sendCondition)
[11:00:27.409]                     ns <- getNamespace("parallel")
[11:00:27.409]                     if (exists("sendData", mode = "function", 
[11:00:27.409]                       envir = ns)) {
[11:00:27.409]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:27.409]                         envir = ns)
[11:00:27.409]                       envir <- sys.frame(frame)
[11:00:27.409]                       master <- NULL
[11:00:27.409]                       while (!identical(envir, .GlobalEnv) && 
[11:00:27.409]                         !identical(envir, emptyenv())) {
[11:00:27.409]                         if (exists("master", mode = "list", envir = envir, 
[11:00:27.409]                           inherits = FALSE)) {
[11:00:27.409]                           master <- get("master", mode = "list", 
[11:00:27.409]                             envir = envir, inherits = FALSE)
[11:00:27.409]                           if (inherits(master, c("SOCKnode", 
[11:00:27.409]                             "SOCK0node"))) {
[11:00:27.409]                             sendCondition <<- function(cond) {
[11:00:27.409]                               data <- list(type = "VALUE", value = cond, 
[11:00:27.409]                                 success = TRUE)
[11:00:27.409]                               parallel_sendData(master, data)
[11:00:27.409]                             }
[11:00:27.409]                             return(sendCondition)
[11:00:27.409]                           }
[11:00:27.409]                         }
[11:00:27.409]                         frame <- frame + 1L
[11:00:27.409]                         envir <- sys.frame(frame)
[11:00:27.409]                       }
[11:00:27.409]                     }
[11:00:27.409]                     sendCondition <<- function(cond) NULL
[11:00:27.409]                   }
[11:00:27.409]                 })
[11:00:27.409]                 withCallingHandlers({
[11:00:27.409]                   {
[11:00:27.409]                     do.call(function(...) {
[11:00:27.409]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:27.409]                       if (!identical(...future.globals.maxSize.org, 
[11:00:27.409]                         ...future.globals.maxSize)) {
[11:00:27.409]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:27.409]                         on.exit(options(oopts), add = TRUE)
[11:00:27.409]                       }
[11:00:27.409]                       {
[11:00:27.409]                         lapply(seq_along(...future.elements_ii), 
[11:00:27.409]                           FUN = function(jj) {
[11:00:27.409]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:27.409]                             ...future.FUN(...future.X_jj, ...)
[11:00:27.409]                           })
[11:00:27.409]                       }
[11:00:27.409]                     }, args = future.call.arguments)
[11:00:27.409]                   }
[11:00:27.409]                 }, immediateCondition = function(cond) {
[11:00:27.409]                   sendCondition <- ...future.makeSendCondition()
[11:00:27.409]                   sendCondition(cond)
[11:00:27.409]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:27.409]                   {
[11:00:27.409]                     inherits <- base::inherits
[11:00:27.409]                     invokeRestart <- base::invokeRestart
[11:00:27.409]                     is.null <- base::is.null
[11:00:27.409]                     muffled <- FALSE
[11:00:27.409]                     if (inherits(cond, "message")) {
[11:00:27.409]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:27.409]                       if (muffled) 
[11:00:27.409]                         invokeRestart("muffleMessage")
[11:00:27.409]                     }
[11:00:27.409]                     else if (inherits(cond, "warning")) {
[11:00:27.409]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:27.409]                       if (muffled) 
[11:00:27.409]                         invokeRestart("muffleWarning")
[11:00:27.409]                     }
[11:00:27.409]                     else if (inherits(cond, "condition")) {
[11:00:27.409]                       if (!is.null(pattern)) {
[11:00:27.409]                         computeRestarts <- base::computeRestarts
[11:00:27.409]                         grepl <- base::grepl
[11:00:27.409]                         restarts <- computeRestarts(cond)
[11:00:27.409]                         for (restart in restarts) {
[11:00:27.409]                           name <- restart$name
[11:00:27.409]                           if (is.null(name)) 
[11:00:27.409]                             next
[11:00:27.409]                           if (!grepl(pattern, name)) 
[11:00:27.409]                             next
[11:00:27.409]                           invokeRestart(restart)
[11:00:27.409]                           muffled <- TRUE
[11:00:27.409]                           break
[11:00:27.409]                         }
[11:00:27.409]                       }
[11:00:27.409]                     }
[11:00:27.409]                     invisible(muffled)
[11:00:27.409]                   }
[11:00:27.409]                   muffleCondition(cond)
[11:00:27.409]                 })
[11:00:27.409]             }))
[11:00:27.409]             future::FutureResult(value = ...future.value$value, 
[11:00:27.409]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:27.409]                   ...future.rng), globalenv = if (FALSE) 
[11:00:27.409]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:27.409]                     ...future.globalenv.names))
[11:00:27.409]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:27.409]         }, condition = base::local({
[11:00:27.409]             c <- base::c
[11:00:27.409]             inherits <- base::inherits
[11:00:27.409]             invokeRestart <- base::invokeRestart
[11:00:27.409]             length <- base::length
[11:00:27.409]             list <- base::list
[11:00:27.409]             seq.int <- base::seq.int
[11:00:27.409]             signalCondition <- base::signalCondition
[11:00:27.409]             sys.calls <- base::sys.calls
[11:00:27.409]             `[[` <- base::`[[`
[11:00:27.409]             `+` <- base::`+`
[11:00:27.409]             `<<-` <- base::`<<-`
[11:00:27.409]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:27.409]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:27.409]                   3L)]
[11:00:27.409]             }
[11:00:27.409]             function(cond) {
[11:00:27.409]                 is_error <- inherits(cond, "error")
[11:00:27.409]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:27.409]                   NULL)
[11:00:27.409]                 if (is_error) {
[11:00:27.409]                   sessionInformation <- function() {
[11:00:27.409]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:27.409]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:27.409]                       search = base::search(), system = base::Sys.info())
[11:00:27.409]                   }
[11:00:27.409]                   ...future.conditions[[length(...future.conditions) + 
[11:00:27.409]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:27.409]                     cond$call), session = sessionInformation(), 
[11:00:27.409]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:27.409]                   signalCondition(cond)
[11:00:27.409]                 }
[11:00:27.409]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:27.409]                 "immediateCondition"))) {
[11:00:27.409]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:27.409]                   ...future.conditions[[length(...future.conditions) + 
[11:00:27.409]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:27.409]                   if (TRUE && !signal) {
[11:00:27.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:27.409]                     {
[11:00:27.409]                       inherits <- base::inherits
[11:00:27.409]                       invokeRestart <- base::invokeRestart
[11:00:27.409]                       is.null <- base::is.null
[11:00:27.409]                       muffled <- FALSE
[11:00:27.409]                       if (inherits(cond, "message")) {
[11:00:27.409]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:27.409]                         if (muffled) 
[11:00:27.409]                           invokeRestart("muffleMessage")
[11:00:27.409]                       }
[11:00:27.409]                       else if (inherits(cond, "warning")) {
[11:00:27.409]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:27.409]                         if (muffled) 
[11:00:27.409]                           invokeRestart("muffleWarning")
[11:00:27.409]                       }
[11:00:27.409]                       else if (inherits(cond, "condition")) {
[11:00:27.409]                         if (!is.null(pattern)) {
[11:00:27.409]                           computeRestarts <- base::computeRestarts
[11:00:27.409]                           grepl <- base::grepl
[11:00:27.409]                           restarts <- computeRestarts(cond)
[11:00:27.409]                           for (restart in restarts) {
[11:00:27.409]                             name <- restart$name
[11:00:27.409]                             if (is.null(name)) 
[11:00:27.409]                               next
[11:00:27.409]                             if (!grepl(pattern, name)) 
[11:00:27.409]                               next
[11:00:27.409]                             invokeRestart(restart)
[11:00:27.409]                             muffled <- TRUE
[11:00:27.409]                             break
[11:00:27.409]                           }
[11:00:27.409]                         }
[11:00:27.409]                       }
[11:00:27.409]                       invisible(muffled)
[11:00:27.409]                     }
[11:00:27.409]                     muffleCondition(cond, pattern = "^muffle")
[11:00:27.409]                   }
[11:00:27.409]                 }
[11:00:27.409]                 else {
[11:00:27.409]                   if (TRUE) {
[11:00:27.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:27.409]                     {
[11:00:27.409]                       inherits <- base::inherits
[11:00:27.409]                       invokeRestart <- base::invokeRestart
[11:00:27.409]                       is.null <- base::is.null
[11:00:27.409]                       muffled <- FALSE
[11:00:27.409]                       if (inherits(cond, "message")) {
[11:00:27.409]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:27.409]                         if (muffled) 
[11:00:27.409]                           invokeRestart("muffleMessage")
[11:00:27.409]                       }
[11:00:27.409]                       else if (inherits(cond, "warning")) {
[11:00:27.409]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:27.409]                         if (muffled) 
[11:00:27.409]                           invokeRestart("muffleWarning")
[11:00:27.409]                       }
[11:00:27.409]                       else if (inherits(cond, "condition")) {
[11:00:27.409]                         if (!is.null(pattern)) {
[11:00:27.409]                           computeRestarts <- base::computeRestarts
[11:00:27.409]                           grepl <- base::grepl
[11:00:27.409]                           restarts <- computeRestarts(cond)
[11:00:27.409]                           for (restart in restarts) {
[11:00:27.409]                             name <- restart$name
[11:00:27.409]                             if (is.null(name)) 
[11:00:27.409]                               next
[11:00:27.409]                             if (!grepl(pattern, name)) 
[11:00:27.409]                               next
[11:00:27.409]                             invokeRestart(restart)
[11:00:27.409]                             muffled <- TRUE
[11:00:27.409]                             break
[11:00:27.409]                           }
[11:00:27.409]                         }
[11:00:27.409]                       }
[11:00:27.409]                       invisible(muffled)
[11:00:27.409]                     }
[11:00:27.409]                     muffleCondition(cond, pattern = "^muffle")
[11:00:27.409]                   }
[11:00:27.409]                 }
[11:00:27.409]             }
[11:00:27.409]         }))
[11:00:27.409]     }, error = function(ex) {
[11:00:27.409]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:27.409]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:27.409]                 ...future.rng), started = ...future.startTime, 
[11:00:27.409]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:27.409]             version = "1.8"), class = "FutureResult")
[11:00:27.409]     }, finally = {
[11:00:27.409]         if (!identical(...future.workdir, getwd())) 
[11:00:27.409]             setwd(...future.workdir)
[11:00:27.409]         {
[11:00:27.409]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:27.409]                 ...future.oldOptions$nwarnings <- NULL
[11:00:27.409]             }
[11:00:27.409]             base::options(...future.oldOptions)
[11:00:27.409]             if (.Platform$OS.type == "windows") {
[11:00:27.409]                 old_names <- names(...future.oldEnvVars)
[11:00:27.409]                 envs <- base::Sys.getenv()
[11:00:27.409]                 names <- names(envs)
[11:00:27.409]                 common <- intersect(names, old_names)
[11:00:27.409]                 added <- setdiff(names, old_names)
[11:00:27.409]                 removed <- setdiff(old_names, names)
[11:00:27.409]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:27.409]                   envs[common]]
[11:00:27.409]                 NAMES <- toupper(changed)
[11:00:27.409]                 args <- list()
[11:00:27.409]                 for (kk in seq_along(NAMES)) {
[11:00:27.409]                   name <- changed[[kk]]
[11:00:27.409]                   NAME <- NAMES[[kk]]
[11:00:27.409]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:27.409]                     next
[11:00:27.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:27.409]                 }
[11:00:27.409]                 NAMES <- toupper(added)
[11:00:27.409]                 for (kk in seq_along(NAMES)) {
[11:00:27.409]                   name <- added[[kk]]
[11:00:27.409]                   NAME <- NAMES[[kk]]
[11:00:27.409]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:27.409]                     next
[11:00:27.409]                   args[[name]] <- ""
[11:00:27.409]                 }
[11:00:27.409]                 NAMES <- toupper(removed)
[11:00:27.409]                 for (kk in seq_along(NAMES)) {
[11:00:27.409]                   name <- removed[[kk]]
[11:00:27.409]                   NAME <- NAMES[[kk]]
[11:00:27.409]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:27.409]                     next
[11:00:27.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:27.409]                 }
[11:00:27.409]                 if (length(args) > 0) 
[11:00:27.409]                   base::do.call(base::Sys.setenv, args = args)
[11:00:27.409]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:27.409]             }
[11:00:27.409]             else {
[11:00:27.409]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:27.409]             }
[11:00:27.409]             {
[11:00:27.409]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:27.409]                   0L) {
[11:00:27.409]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:27.409]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:27.409]                   base::options(opts)
[11:00:27.409]                 }
[11:00:27.409]                 {
[11:00:27.409]                   {
[11:00:27.409]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:27.409]                     NULL
[11:00:27.409]                   }
[11:00:27.409]                   options(future.plan = NULL)
[11:00:27.409]                   if (is.na(NA_character_)) 
[11:00:27.409]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:27.409]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:27.409]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:27.409]                     .init = FALSE)
[11:00:27.409]                 }
[11:00:27.409]             }
[11:00:27.409]         }
[11:00:27.409]     })
[11:00:27.409]     if (TRUE) {
[11:00:27.409]         base::sink(type = "output", split = FALSE)
[11:00:27.409]         if (FALSE) {
[11:00:27.409]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:27.409]         }
[11:00:27.409]         else {
[11:00:27.409]             ...future.result["stdout"] <- base::list(NULL)
[11:00:27.409]         }
[11:00:27.409]         base::close(...future.stdout)
[11:00:27.409]         ...future.stdout <- NULL
[11:00:27.409]     }
[11:00:27.409]     ...future.result$conditions <- ...future.conditions
[11:00:27.409]     ...future.result$finished <- base::Sys.time()
[11:00:27.409]     ...future.result
[11:00:27.409] }
[11:00:27.460] Exporting 5 global objects (1.46 KiB) to cluster node #2 ...
[11:00:27.460] Exporting ‘...future.FUN’ (841 bytes) to cluster node #2 ...
[11:00:27.461] Exporting ‘...future.FUN’ (841 bytes) to cluster node #2 ... DONE
[11:00:27.461] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[11:00:27.461] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[11:00:27.461] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ...
[11:00:27.462] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ... DONE
[11:00:27.462] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[11:00:27.462] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[11:00:27.462] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[11:00:27.463] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[11:00:27.463] Exporting 5 global objects (1.46 KiB) to cluster node #2 ... DONE
[11:00:27.464] MultisessionFuture started
[11:00:27.464] - Launch lazy future ... done
[11:00:27.464] run() for ‘MultisessionFuture’ ... done
[11:00:27.464] Created future:
[11:00:27.464] MultisessionFuture:
[11:00:27.464] Label: ‘future_lapply-2’
[11:00:27.464] Expression:
[11:00:27.464] {
[11:00:27.464]     do.call(function(...) {
[11:00:27.464]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:27.464]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:27.464]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:27.464]             on.exit(options(oopts), add = TRUE)
[11:00:27.464]         }
[11:00:27.464]         {
[11:00:27.464]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:27.464]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:27.464]                 ...future.FUN(...future.X_jj, ...)
[11:00:27.464]             })
[11:00:27.464]         }
[11:00:27.464]     }, args = future.call.arguments)
[11:00:27.464] }
[11:00:27.464] Lazy evaluation: FALSE
[11:00:27.464] Asynchronous evaluation: TRUE
[11:00:27.464] Local evaluation: TRUE
[11:00:27.464] Environment: R_GlobalEnv
[11:00:27.464] Capture standard output: FALSE
[11:00:27.464] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:27.464] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:27.464] Packages: <none>
[11:00:27.464] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:27.464] Resolved: FALSE
[11:00:27.464] Value: <not collected>
[11:00:27.464] Conditions captured: <none>
[11:00:27.464] Early signaling: FALSE
[11:00:27.464] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:27.464] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:27.476] Chunk #2 of 2 ... DONE
[11:00:27.476] Launching 2 futures (chunks) ... DONE
[11:00:27.476] Resolving 2 futures (chunks) ...
[11:00:27.476] resolve() on list ...
[11:00:27.476]  recursive: 0
[11:00:27.477]  length: 2
[11:00:27.477] 
[11:00:27.551] receiveMessageFromWorker() for ClusterFuture ...
[11:00:27.551] - Validating connection of MultisessionFuture
[11:00:27.551] - received message: FutureResult
[11:00:27.551] - Received FutureResult
[11:00:27.551] - Erased future from FutureRegistry
[11:00:27.552] result() for ClusterFuture ...
[11:00:27.552] - result already collected: FutureResult
[11:00:27.552] result() for ClusterFuture ... done
[11:00:27.552] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:27.552] Future #2
[11:00:27.552] result() for ClusterFuture ...
[11:00:27.552] - result already collected: FutureResult
[11:00:27.552] result() for ClusterFuture ... done
[11:00:27.552] result() for ClusterFuture ...
[11:00:27.553] - result already collected: FutureResult
[11:00:27.553] result() for ClusterFuture ... done
[11:00:27.553] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:00:27.553] - nx: 2
[11:00:27.553] - relay: TRUE
[11:00:27.553] - stdout: TRUE
[11:00:27.553] - signal: TRUE
[11:00:27.553] - resignal: FALSE
[11:00:27.553] - force: TRUE
[11:00:27.554] - relayed: [n=2] FALSE, FALSE
[11:00:27.554] - queued futures: [n=2] FALSE, FALSE
[11:00:27.554]  - until=1
[11:00:27.554]  - relaying element #1
[11:00:27.554] - relayed: [n=2] FALSE, FALSE
[11:00:27.554] - queued futures: [n=2] FALSE, TRUE
[11:00:27.554] signalConditionsASAP(NULL, pos=2) ... done
[11:00:27.554]  length: 1 (resolved future 2)
[11:00:27.921] receiveMessageFromWorker() for ClusterFuture ...
[11:00:27.921] - Validating connection of MultisessionFuture
[11:00:27.922] - received message: FutureResult
[11:00:27.922] - Received FutureResult
[11:00:27.922] - Erased future from FutureRegistry
[11:00:27.922] result() for ClusterFuture ...
[11:00:27.922] - result already collected: FutureResult
[11:00:27.922] result() for ClusterFuture ... done
[11:00:27.922] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:27.923] Future #1
[11:00:27.923] result() for ClusterFuture ...
[11:00:27.923] - result already collected: FutureResult
[11:00:27.923] result() for ClusterFuture ... done
[11:00:27.923] result() for ClusterFuture ...
[11:00:27.923] - result already collected: FutureResult
[11:00:27.923] result() for ClusterFuture ... done
[11:00:27.923] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:00:27.923] - nx: 2
[11:00:27.924] - relay: TRUE
[11:00:27.924] - stdout: TRUE
[11:00:27.924] - signal: TRUE
[11:00:27.924] - resignal: FALSE
[11:00:27.924] - force: TRUE
[11:00:27.924] - relayed: [n=2] FALSE, FALSE
[11:00:27.924] - queued futures: [n=2] FALSE, TRUE
[11:00:27.924]  - until=1
[11:00:27.924]  - relaying element #1
[11:00:27.924] result() for ClusterFuture ...
[11:00:27.925] - result already collected: FutureResult
[11:00:27.925] result() for ClusterFuture ... done
[11:00:27.925] result() for ClusterFuture ...
[11:00:27.925] - result already collected: FutureResult
[11:00:27.925] result() for ClusterFuture ... done
[11:00:27.925] result() for ClusterFuture ...
[11:00:27.925] - result already collected: FutureResult
[11:00:27.925] result() for ClusterFuture ... done
[11:00:27.925] result() for ClusterFuture ...
[11:00:27.925] - result already collected: FutureResult
[11:00:27.926] result() for ClusterFuture ... done
[11:00:27.926] - relayed: [n=2] TRUE, FALSE
[11:00:27.926] - queued futures: [n=2] TRUE, TRUE
[11:00:27.926] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:00:27.926]  length: 0 (resolved future 1)
[11:00:27.926] Relaying remaining futures
[11:00:27.926] signalConditionsASAP(NULL, pos=0) ...
[11:00:27.926] - nx: 2
[11:00:27.926] - relay: TRUE
[11:00:27.926] - stdout: TRUE
[11:00:27.927] - signal: TRUE
[11:00:27.927] - resignal: FALSE
[11:00:27.927] - force: TRUE
[11:00:27.927] - relayed: [n=2] TRUE, FALSE
[11:00:27.927] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:27.927]  - relaying element #2
[11:00:27.927] result() for ClusterFuture ...
[11:00:27.928] - result already collected: FutureResult
[11:00:27.928] result() for ClusterFuture ... done
[11:00:27.928] result() for ClusterFuture ...
[11:00:27.928] - result already collected: FutureResult
[11:00:27.928] result() for ClusterFuture ... done
[11:00:27.928] result() for ClusterFuture ...
[11:00:27.928] - result already collected: FutureResult
[11:00:27.929] result() for ClusterFuture ... done
[11:00:27.929] result() for ClusterFuture ...
[11:00:27.929] - result already collected: FutureResult
[11:00:27.929] result() for ClusterFuture ... done
[11:00:27.929] - relayed: [n=2] TRUE, TRUE
[11:00:27.929] - queued futures: [n=2] TRUE, TRUE
[11:00:27.929] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[11:00:27.930] resolve() on list ... DONE
[11:00:27.930] result() for ClusterFuture ...
[11:00:27.930] - result already collected: FutureResult
[11:00:27.930] result() for ClusterFuture ... done
[11:00:27.930] result() for ClusterFuture ...
[11:00:27.930] - result already collected: FutureResult
[11:00:27.930] result() for ClusterFuture ... done
[11:00:27.930] result() for ClusterFuture ...
[11:00:27.931] - result already collected: FutureResult
[11:00:27.931] result() for ClusterFuture ... done
[11:00:27.931] result() for ClusterFuture ...
[11:00:27.931] - result already collected: FutureResult
[11:00:27.931] result() for ClusterFuture ... done
[11:00:27.931]  - Number of value chunks collected: 2
[11:00:27.931] Resolving 2 futures (chunks) ... DONE
[11:00:27.931] Reducing values from 2 chunks ...
[11:00:27.931]  - Number of values collected after concatenation: 2
[11:00:27.932]  - Number of values expected: 2
[11:00:27.932] Reducing values from 2 chunks ... DONE
[11:00:27.932] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[11:00:27.932] future_lapply() ...
[11:00:27.935] Number of chunks: 2
[11:00:27.935] getGlobalsAndPackagesXApply() ...
[11:00:27.935]  - future.globals: TRUE
[11:00:27.935] getGlobalsAndPackages() ...
[11:00:27.935] Searching for globals...
[11:00:27.937] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[11:00:27.937] Searching for globals ... DONE
[11:00:27.937] Resolving globals: FALSE
[11:00:27.938] The total size of the 1 globals is 841 bytes (841 bytes)
[11:00:27.938] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[11:00:27.938] - globals: [1] ‘FUN’
[11:00:27.939] 
[11:00:27.939] getGlobalsAndPackages() ... DONE
[11:00:27.939]  - globals found/used: [n=1] ‘FUN’
[11:00:27.939]  - needed namespaces: [n=0] 
[11:00:27.939] Finding globals ... DONE
[11:00:27.939]  - use_args: TRUE
[11:00:27.939]  - Getting '...' globals ...
[11:00:27.940] resolve() on list ...
[11:00:27.940]  recursive: 0
[11:00:27.940]  length: 1
[11:00:27.940]  elements: ‘...’
[11:00:27.940]  length: 0 (resolved future 1)
[11:00:27.940] resolve() on list ... DONE
[11:00:27.940]    - '...' content: [n=0] 
[11:00:27.940] List of 1
[11:00:27.940]  $ ...: list()
[11:00:27.940]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:27.940]  - attr(*, "where")=List of 1
[11:00:27.940]   ..$ ...:<environment: 0x55ceb60c8b58> 
[11:00:27.940]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:27.940]  - attr(*, "resolved")= logi TRUE
[11:00:27.940]  - attr(*, "total_size")= num NA
[11:00:27.945]  - Getting '...' globals ... DONE
[11:00:27.945] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[11:00:27.945] List of 2
[11:00:27.945]  $ ...future.FUN:function (x)  
[11:00:27.945]  $ ...          : list()
[11:00:27.945]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:27.945]  - attr(*, "where")=List of 2
[11:00:27.945]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:27.945]   ..$ ...          :<environment: 0x55ceb60c8b58> 
[11:00:27.945]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:27.945]  - attr(*, "resolved")= logi FALSE
[11:00:27.945]  - attr(*, "total_size")= num 5632
[11:00:27.948] Packages to be attached in all futures: [n=0] 
[11:00:27.948] getGlobalsAndPackagesXApply() ... DONE
[11:00:27.948] Number of futures (= number of chunks): 2
[11:00:27.948] Launching 2 futures (chunks) ...
[11:00:27.948] Chunk #1 of 2 ...
[11:00:27.948]  - Finding globals in 'X' for chunk #1 ...
[11:00:27.948] getGlobalsAndPackages() ...
[11:00:27.948] Searching for globals...
[11:00:27.949] 
[11:00:27.949] Searching for globals ... DONE
[11:00:27.949] - globals: [0] <none>
[11:00:27.949] getGlobalsAndPackages() ... DONE
[11:00:27.949]    + additional globals found: [n=0] 
[11:00:27.949]    + additional namespaces needed: [n=0] 
[11:00:27.949]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:27.949]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:27.949]  - seeds: <none>
[11:00:27.949]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:27.950] getGlobalsAndPackages() ...
[11:00:27.950] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:27.950] Resolving globals: FALSE
[11:00:27.950] Tweak future expression to call with '...' arguments ...
[11:00:27.950] {
[11:00:27.950]     do.call(function(...) {
[11:00:27.950]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:27.950]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:27.950]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:27.950]             on.exit(options(oopts), add = TRUE)
[11:00:27.950]         }
[11:00:27.950]         {
[11:00:27.950]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:27.950]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:27.950]                 ...future.FUN(...future.X_jj, ...)
[11:00:27.950]             })
[11:00:27.950]         }
[11:00:27.950]     }, args = future.call.arguments)
[11:00:27.950] }
[11:00:27.950] Tweak future expression to call with '...' arguments ... DONE
[11:00:27.950] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:27.951] 
[11:00:27.951] getGlobalsAndPackages() ... DONE
[11:00:27.951] run() for ‘Future’ ...
[11:00:27.951] - state: ‘created’
[11:00:27.951] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:27.965] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:27.965] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:27.965]   - Field: ‘node’
[11:00:27.965]   - Field: ‘label’
[11:00:27.965]   - Field: ‘local’
[11:00:27.965]   - Field: ‘owner’
[11:00:27.965]   - Field: ‘envir’
[11:00:27.965]   - Field: ‘workers’
[11:00:27.965]   - Field: ‘packages’
[11:00:27.965]   - Field: ‘gc’
[11:00:27.966]   - Field: ‘conditions’
[11:00:27.966]   - Field: ‘persistent’
[11:00:27.966]   - Field: ‘expr’
[11:00:27.966]   - Field: ‘uuid’
[11:00:27.966]   - Field: ‘seed’
[11:00:27.966]   - Field: ‘version’
[11:00:27.966]   - Field: ‘result’
[11:00:27.966]   - Field: ‘asynchronous’
[11:00:27.966]   - Field: ‘calls’
[11:00:27.966]   - Field: ‘globals’
[11:00:27.966]   - Field: ‘stdout’
[11:00:27.966]   - Field: ‘earlySignal’
[11:00:27.967]   - Field: ‘lazy’
[11:00:27.967]   - Field: ‘state’
[11:00:27.967] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:27.967] - Launch lazy future ...
[11:00:27.967] Packages needed by the future expression (n = 0): <none>
[11:00:27.967] Packages needed by future strategies (n = 0): <none>
[11:00:27.968] {
[11:00:27.968]     {
[11:00:27.968]         {
[11:00:27.968]             ...future.startTime <- base::Sys.time()
[11:00:27.968]             {
[11:00:27.968]                 {
[11:00:27.968]                   {
[11:00:27.968]                     {
[11:00:27.968]                       base::local({
[11:00:27.968]                         has_future <- base::requireNamespace("future", 
[11:00:27.968]                           quietly = TRUE)
[11:00:27.968]                         if (has_future) {
[11:00:27.968]                           ns <- base::getNamespace("future")
[11:00:27.968]                           version <- ns[[".package"]][["version"]]
[11:00:27.968]                           if (is.null(version)) 
[11:00:27.968]                             version <- utils::packageVersion("future")
[11:00:27.968]                         }
[11:00:27.968]                         else {
[11:00:27.968]                           version <- NULL
[11:00:27.968]                         }
[11:00:27.968]                         if (!has_future || version < "1.8.0") {
[11:00:27.968]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:27.968]                             "", base::R.version$version.string), 
[11:00:27.968]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:27.968]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:27.968]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:27.968]                               "release", "version")], collapse = " "), 
[11:00:27.968]                             hostname = base::Sys.info()[["nodename"]])
[11:00:27.968]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:27.968]                             info)
[11:00:27.968]                           info <- base::paste(info, collapse = "; ")
[11:00:27.968]                           if (!has_future) {
[11:00:27.968]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:27.968]                               info)
[11:00:27.968]                           }
[11:00:27.968]                           else {
[11:00:27.968]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:27.968]                               info, version)
[11:00:27.968]                           }
[11:00:27.968]                           base::stop(msg)
[11:00:27.968]                         }
[11:00:27.968]                       })
[11:00:27.968]                     }
[11:00:27.968]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:27.968]                     base::options(mc.cores = 1L)
[11:00:27.968]                   }
[11:00:27.968]                   ...future.strategy.old <- future::plan("list")
[11:00:27.968]                   options(future.plan = NULL)
[11:00:27.968]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:27.968]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:27.968]                 }
[11:00:27.968]                 ...future.workdir <- getwd()
[11:00:27.968]             }
[11:00:27.968]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:27.968]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:27.968]         }
[11:00:27.968]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:27.968]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:27.968]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:27.968]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:27.968]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:27.968]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:27.968]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:27.968]             base::names(...future.oldOptions))
[11:00:27.968]     }
[11:00:27.968]     if (FALSE) {
[11:00:27.968]     }
[11:00:27.968]     else {
[11:00:27.968]         if (TRUE) {
[11:00:27.968]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:27.968]                 open = "w")
[11:00:27.968]         }
[11:00:27.968]         else {
[11:00:27.968]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:27.968]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:27.968]         }
[11:00:27.968]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:27.968]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:27.968]             base::sink(type = "output", split = FALSE)
[11:00:27.968]             base::close(...future.stdout)
[11:00:27.968]         }, add = TRUE)
[11:00:27.968]     }
[11:00:27.968]     ...future.frame <- base::sys.nframe()
[11:00:27.968]     ...future.conditions <- base::list()
[11:00:27.968]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:27.968]     if (FALSE) {
[11:00:27.968]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:27.968]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:27.968]     }
[11:00:27.968]     ...future.result <- base::tryCatch({
[11:00:27.968]         base::withCallingHandlers({
[11:00:27.968]             ...future.value <- base::withVisible(base::local({
[11:00:27.968]                 ...future.makeSendCondition <- base::local({
[11:00:27.968]                   sendCondition <- NULL
[11:00:27.968]                   function(frame = 1L) {
[11:00:27.968]                     if (is.function(sendCondition)) 
[11:00:27.968]                       return(sendCondition)
[11:00:27.968]                     ns <- getNamespace("parallel")
[11:00:27.968]                     if (exists("sendData", mode = "function", 
[11:00:27.968]                       envir = ns)) {
[11:00:27.968]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:27.968]                         envir = ns)
[11:00:27.968]                       envir <- sys.frame(frame)
[11:00:27.968]                       master <- NULL
[11:00:27.968]                       while (!identical(envir, .GlobalEnv) && 
[11:00:27.968]                         !identical(envir, emptyenv())) {
[11:00:27.968]                         if (exists("master", mode = "list", envir = envir, 
[11:00:27.968]                           inherits = FALSE)) {
[11:00:27.968]                           master <- get("master", mode = "list", 
[11:00:27.968]                             envir = envir, inherits = FALSE)
[11:00:27.968]                           if (inherits(master, c("SOCKnode", 
[11:00:27.968]                             "SOCK0node"))) {
[11:00:27.968]                             sendCondition <<- function(cond) {
[11:00:27.968]                               data <- list(type = "VALUE", value = cond, 
[11:00:27.968]                                 success = TRUE)
[11:00:27.968]                               parallel_sendData(master, data)
[11:00:27.968]                             }
[11:00:27.968]                             return(sendCondition)
[11:00:27.968]                           }
[11:00:27.968]                         }
[11:00:27.968]                         frame <- frame + 1L
[11:00:27.968]                         envir <- sys.frame(frame)
[11:00:27.968]                       }
[11:00:27.968]                     }
[11:00:27.968]                     sendCondition <<- function(cond) NULL
[11:00:27.968]                   }
[11:00:27.968]                 })
[11:00:27.968]                 withCallingHandlers({
[11:00:27.968]                   {
[11:00:27.968]                     do.call(function(...) {
[11:00:27.968]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:27.968]                       if (!identical(...future.globals.maxSize.org, 
[11:00:27.968]                         ...future.globals.maxSize)) {
[11:00:27.968]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:27.968]                         on.exit(options(oopts), add = TRUE)
[11:00:27.968]                       }
[11:00:27.968]                       {
[11:00:27.968]                         lapply(seq_along(...future.elements_ii), 
[11:00:27.968]                           FUN = function(jj) {
[11:00:27.968]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:27.968]                             ...future.FUN(...future.X_jj, ...)
[11:00:27.968]                           })
[11:00:27.968]                       }
[11:00:27.968]                     }, args = future.call.arguments)
[11:00:27.968]                   }
[11:00:27.968]                 }, immediateCondition = function(cond) {
[11:00:27.968]                   sendCondition <- ...future.makeSendCondition()
[11:00:27.968]                   sendCondition(cond)
[11:00:27.968]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:27.968]                   {
[11:00:27.968]                     inherits <- base::inherits
[11:00:27.968]                     invokeRestart <- base::invokeRestart
[11:00:27.968]                     is.null <- base::is.null
[11:00:27.968]                     muffled <- FALSE
[11:00:27.968]                     if (inherits(cond, "message")) {
[11:00:27.968]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:27.968]                       if (muffled) 
[11:00:27.968]                         invokeRestart("muffleMessage")
[11:00:27.968]                     }
[11:00:27.968]                     else if (inherits(cond, "warning")) {
[11:00:27.968]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:27.968]                       if (muffled) 
[11:00:27.968]                         invokeRestart("muffleWarning")
[11:00:27.968]                     }
[11:00:27.968]                     else if (inherits(cond, "condition")) {
[11:00:27.968]                       if (!is.null(pattern)) {
[11:00:27.968]                         computeRestarts <- base::computeRestarts
[11:00:27.968]                         grepl <- base::grepl
[11:00:27.968]                         restarts <- computeRestarts(cond)
[11:00:27.968]                         for (restart in restarts) {
[11:00:27.968]                           name <- restart$name
[11:00:27.968]                           if (is.null(name)) 
[11:00:27.968]                             next
[11:00:27.968]                           if (!grepl(pattern, name)) 
[11:00:27.968]                             next
[11:00:27.968]                           invokeRestart(restart)
[11:00:27.968]                           muffled <- TRUE
[11:00:27.968]                           break
[11:00:27.968]                         }
[11:00:27.968]                       }
[11:00:27.968]                     }
[11:00:27.968]                     invisible(muffled)
[11:00:27.968]                   }
[11:00:27.968]                   muffleCondition(cond)
[11:00:27.968]                 })
[11:00:27.968]             }))
[11:00:27.968]             future::FutureResult(value = ...future.value$value, 
[11:00:27.968]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:27.968]                   ...future.rng), globalenv = if (FALSE) 
[11:00:27.968]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:27.968]                     ...future.globalenv.names))
[11:00:27.968]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:27.968]         }, condition = base::local({
[11:00:27.968]             c <- base::c
[11:00:27.968]             inherits <- base::inherits
[11:00:27.968]             invokeRestart <- base::invokeRestart
[11:00:27.968]             length <- base::length
[11:00:27.968]             list <- base::list
[11:00:27.968]             seq.int <- base::seq.int
[11:00:27.968]             signalCondition <- base::signalCondition
[11:00:27.968]             sys.calls <- base::sys.calls
[11:00:27.968]             `[[` <- base::`[[`
[11:00:27.968]             `+` <- base::`+`
[11:00:27.968]             `<<-` <- base::`<<-`
[11:00:27.968]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:27.968]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:27.968]                   3L)]
[11:00:27.968]             }
[11:00:27.968]             function(cond) {
[11:00:27.968]                 is_error <- inherits(cond, "error")
[11:00:27.968]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:27.968]                   NULL)
[11:00:27.968]                 if (is_error) {
[11:00:27.968]                   sessionInformation <- function() {
[11:00:27.968]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:27.968]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:27.968]                       search = base::search(), system = base::Sys.info())
[11:00:27.968]                   }
[11:00:27.968]                   ...future.conditions[[length(...future.conditions) + 
[11:00:27.968]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:27.968]                     cond$call), session = sessionInformation(), 
[11:00:27.968]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:27.968]                   signalCondition(cond)
[11:00:27.968]                 }
[11:00:27.968]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:27.968]                 "immediateCondition"))) {
[11:00:27.968]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:27.968]                   ...future.conditions[[length(...future.conditions) + 
[11:00:27.968]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:27.968]                   if (TRUE && !signal) {
[11:00:27.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:27.968]                     {
[11:00:27.968]                       inherits <- base::inherits
[11:00:27.968]                       invokeRestart <- base::invokeRestart
[11:00:27.968]                       is.null <- base::is.null
[11:00:27.968]                       muffled <- FALSE
[11:00:27.968]                       if (inherits(cond, "message")) {
[11:00:27.968]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:27.968]                         if (muffled) 
[11:00:27.968]                           invokeRestart("muffleMessage")
[11:00:27.968]                       }
[11:00:27.968]                       else if (inherits(cond, "warning")) {
[11:00:27.968]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:27.968]                         if (muffled) 
[11:00:27.968]                           invokeRestart("muffleWarning")
[11:00:27.968]                       }
[11:00:27.968]                       else if (inherits(cond, "condition")) {
[11:00:27.968]                         if (!is.null(pattern)) {
[11:00:27.968]                           computeRestarts <- base::computeRestarts
[11:00:27.968]                           grepl <- base::grepl
[11:00:27.968]                           restarts <- computeRestarts(cond)
[11:00:27.968]                           for (restart in restarts) {
[11:00:27.968]                             name <- restart$name
[11:00:27.968]                             if (is.null(name)) 
[11:00:27.968]                               next
[11:00:27.968]                             if (!grepl(pattern, name)) 
[11:00:27.968]                               next
[11:00:27.968]                             invokeRestart(restart)
[11:00:27.968]                             muffled <- TRUE
[11:00:27.968]                             break
[11:00:27.968]                           }
[11:00:27.968]                         }
[11:00:27.968]                       }
[11:00:27.968]                       invisible(muffled)
[11:00:27.968]                     }
[11:00:27.968]                     muffleCondition(cond, pattern = "^muffle")
[11:00:27.968]                   }
[11:00:27.968]                 }
[11:00:27.968]                 else {
[11:00:27.968]                   if (TRUE) {
[11:00:27.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:27.968]                     {
[11:00:27.968]                       inherits <- base::inherits
[11:00:27.968]                       invokeRestart <- base::invokeRestart
[11:00:27.968]                       is.null <- base::is.null
[11:00:27.968]                       muffled <- FALSE
[11:00:27.968]                       if (inherits(cond, "message")) {
[11:00:27.968]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:27.968]                         if (muffled) 
[11:00:27.968]                           invokeRestart("muffleMessage")
[11:00:27.968]                       }
[11:00:27.968]                       else if (inherits(cond, "warning")) {
[11:00:27.968]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:27.968]                         if (muffled) 
[11:00:27.968]                           invokeRestart("muffleWarning")
[11:00:27.968]                       }
[11:00:27.968]                       else if (inherits(cond, "condition")) {
[11:00:27.968]                         if (!is.null(pattern)) {
[11:00:27.968]                           computeRestarts <- base::computeRestarts
[11:00:27.968]                           grepl <- base::grepl
[11:00:27.968]                           restarts <- computeRestarts(cond)
[11:00:27.968]                           for (restart in restarts) {
[11:00:27.968]                             name <- restart$name
[11:00:27.968]                             if (is.null(name)) 
[11:00:27.968]                               next
[11:00:27.968]                             if (!grepl(pattern, name)) 
[11:00:27.968]                               next
[11:00:27.968]                             invokeRestart(restart)
[11:00:27.968]                             muffled <- TRUE
[11:00:27.968]                             break
[11:00:27.968]                           }
[11:00:27.968]                         }
[11:00:27.968]                       }
[11:00:27.968]                       invisible(muffled)
[11:00:27.968]                     }
[11:00:27.968]                     muffleCondition(cond, pattern = "^muffle")
[11:00:27.968]                   }
[11:00:27.968]                 }
[11:00:27.968]             }
[11:00:27.968]         }))
[11:00:27.968]     }, error = function(ex) {
[11:00:27.968]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:27.968]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:27.968]                 ...future.rng), started = ...future.startTime, 
[11:00:27.968]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:27.968]             version = "1.8"), class = "FutureResult")
[11:00:27.968]     }, finally = {
[11:00:27.968]         if (!identical(...future.workdir, getwd())) 
[11:00:27.968]             setwd(...future.workdir)
[11:00:27.968]         {
[11:00:27.968]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:27.968]                 ...future.oldOptions$nwarnings <- NULL
[11:00:27.968]             }
[11:00:27.968]             base::options(...future.oldOptions)
[11:00:27.968]             if (.Platform$OS.type == "windows") {
[11:00:27.968]                 old_names <- names(...future.oldEnvVars)
[11:00:27.968]                 envs <- base::Sys.getenv()
[11:00:27.968]                 names <- names(envs)
[11:00:27.968]                 common <- intersect(names, old_names)
[11:00:27.968]                 added <- setdiff(names, old_names)
[11:00:27.968]                 removed <- setdiff(old_names, names)
[11:00:27.968]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:27.968]                   envs[common]]
[11:00:27.968]                 NAMES <- toupper(changed)
[11:00:27.968]                 args <- list()
[11:00:27.968]                 for (kk in seq_along(NAMES)) {
[11:00:27.968]                   name <- changed[[kk]]
[11:00:27.968]                   NAME <- NAMES[[kk]]
[11:00:27.968]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:27.968]                     next
[11:00:27.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:27.968]                 }
[11:00:27.968]                 NAMES <- toupper(added)
[11:00:27.968]                 for (kk in seq_along(NAMES)) {
[11:00:27.968]                   name <- added[[kk]]
[11:00:27.968]                   NAME <- NAMES[[kk]]
[11:00:27.968]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:27.968]                     next
[11:00:27.968]                   args[[name]] <- ""
[11:00:27.968]                 }
[11:00:27.968]                 NAMES <- toupper(removed)
[11:00:27.968]                 for (kk in seq_along(NAMES)) {
[11:00:27.968]                   name <- removed[[kk]]
[11:00:27.968]                   NAME <- NAMES[[kk]]
[11:00:27.968]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:27.968]                     next
[11:00:27.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:27.968]                 }
[11:00:27.968]                 if (length(args) > 0) 
[11:00:27.968]                   base::do.call(base::Sys.setenv, args = args)
[11:00:27.968]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:27.968]             }
[11:00:27.968]             else {
[11:00:27.968]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:27.968]             }
[11:00:27.968]             {
[11:00:27.968]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:27.968]                   0L) {
[11:00:27.968]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:27.968]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:27.968]                   base::options(opts)
[11:00:27.968]                 }
[11:00:27.968]                 {
[11:00:27.968]                   {
[11:00:27.968]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:27.968]                     NULL
[11:00:27.968]                   }
[11:00:27.968]                   options(future.plan = NULL)
[11:00:27.968]                   if (is.na(NA_character_)) 
[11:00:27.968]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:27.968]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:27.968]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:27.968]                     .init = FALSE)
[11:00:27.968]                 }
[11:00:27.968]             }
[11:00:27.968]         }
[11:00:27.968]     })
[11:00:27.968]     if (TRUE) {
[11:00:27.968]         base::sink(type = "output", split = FALSE)
[11:00:27.968]         if (TRUE) {
[11:00:27.968]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:27.968]         }
[11:00:27.968]         else {
[11:00:27.968]             ...future.result["stdout"] <- base::list(NULL)
[11:00:27.968]         }
[11:00:27.968]         base::close(...future.stdout)
[11:00:27.968]         ...future.stdout <- NULL
[11:00:27.968]     }
[11:00:27.968]     ...future.result$conditions <- ...future.conditions
[11:00:27.968]     ...future.result$finished <- base::Sys.time()
[11:00:27.968]     ...future.result
[11:00:27.968] }
[11:00:27.970] Exporting 5 global objects (1.46 KiB) to cluster node #1 ...
[11:00:27.970] Exporting ‘...future.FUN’ (841 bytes) to cluster node #1 ...
[11:00:27.971] Exporting ‘...future.FUN’ (841 bytes) to cluster node #1 ... DONE
[11:00:27.971] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[11:00:27.971] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[11:00:27.972] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ...
[11:00:27.972] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ... DONE
[11:00:27.972] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[11:00:27.972] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[11:00:27.972] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[11:00:27.973] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[11:00:27.973] Exporting 5 global objects (1.46 KiB) to cluster node #1 ... DONE
[11:00:27.973] MultisessionFuture started
[11:00:27.973] - Launch lazy future ... done
[11:00:27.973] run() for ‘MultisessionFuture’ ... done
[11:00:27.973] Created future:
[11:00:27.973] MultisessionFuture:
[11:00:27.973] Label: ‘future_lapply-1’
[11:00:27.973] Expression:
[11:00:27.973] {
[11:00:27.973]     do.call(function(...) {
[11:00:27.973]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:27.973]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:27.973]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:27.973]             on.exit(options(oopts), add = TRUE)
[11:00:27.973]         }
[11:00:27.973]         {
[11:00:27.973]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:27.973]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:27.973]                 ...future.FUN(...future.X_jj, ...)
[11:00:27.973]             })
[11:00:27.973]         }
[11:00:27.973]     }, args = future.call.arguments)
[11:00:27.973] }
[11:00:27.973] Lazy evaluation: FALSE
[11:00:27.973] Asynchronous evaluation: TRUE
[11:00:27.973] Local evaluation: TRUE
[11:00:27.973] Environment: R_GlobalEnv
[11:00:27.973] Capture standard output: TRUE
[11:00:27.973] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:27.973] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:27.973] Packages: <none>
[11:00:27.973] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:27.973] Resolved: FALSE
[11:00:27.973] Value: <not collected>
[11:00:27.973] Conditions captured: <none>
[11:00:27.973] Early signaling: FALSE
[11:00:27.973] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:27.973] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:27.985] Chunk #1 of 2 ... DONE
[11:00:27.985] Chunk #2 of 2 ...
[11:00:27.985]  - Finding globals in 'X' for chunk #2 ...
[11:00:27.985] getGlobalsAndPackages() ...
[11:00:27.985] Searching for globals...
[11:00:27.986] 
[11:00:27.986] Searching for globals ... DONE
[11:00:27.986] - globals: [0] <none>
[11:00:27.986] getGlobalsAndPackages() ... DONE
[11:00:27.986]    + additional globals found: [n=0] 
[11:00:27.986]    + additional namespaces needed: [n=0] 
[11:00:27.986]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:27.986]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:27.986]  - seeds: <none>
[11:00:27.986]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:27.986] getGlobalsAndPackages() ...
[11:00:27.986] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:27.987] Resolving globals: FALSE
[11:00:27.987] Tweak future expression to call with '...' arguments ...
[11:00:27.987] {
[11:00:27.987]     do.call(function(...) {
[11:00:27.987]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:27.987]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:27.987]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:27.987]             on.exit(options(oopts), add = TRUE)
[11:00:27.987]         }
[11:00:27.987]         {
[11:00:27.987]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:27.987]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:27.987]                 ...future.FUN(...future.X_jj, ...)
[11:00:27.987]             })
[11:00:27.987]         }
[11:00:27.987]     }, args = future.call.arguments)
[11:00:27.987] }
[11:00:27.987] Tweak future expression to call with '...' arguments ... DONE
[11:00:27.987] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:27.987] 
[11:00:27.988] getGlobalsAndPackages() ... DONE
[11:00:27.988] run() for ‘Future’ ...
[11:00:27.988] - state: ‘created’
[11:00:27.988] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:28.003] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:28.003] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:28.003]   - Field: ‘node’
[11:00:28.004]   - Field: ‘label’
[11:00:28.004]   - Field: ‘local’
[11:00:28.004]   - Field: ‘owner’
[11:00:28.004]   - Field: ‘envir’
[11:00:28.004]   - Field: ‘workers’
[11:00:28.004]   - Field: ‘packages’
[11:00:28.004]   - Field: ‘gc’
[11:00:28.004]   - Field: ‘conditions’
[11:00:28.004]   - Field: ‘persistent’
[11:00:28.004]   - Field: ‘expr’
[11:00:28.004]   - Field: ‘uuid’
[11:00:28.004]   - Field: ‘seed’
[11:00:28.005]   - Field: ‘version’
[11:00:28.005]   - Field: ‘result’
[11:00:28.005]   - Field: ‘asynchronous’
[11:00:28.005]   - Field: ‘calls’
[11:00:28.005]   - Field: ‘globals’
[11:00:28.005]   - Field: ‘stdout’
[11:00:28.005]   - Field: ‘earlySignal’
[11:00:28.005]   - Field: ‘lazy’
[11:00:28.005]   - Field: ‘state’
[11:00:28.005] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:28.005] - Launch lazy future ...
[11:00:28.006] Packages needed by the future expression (n = 0): <none>
[11:00:28.006] Packages needed by future strategies (n = 0): <none>
[11:00:28.006] {
[11:00:28.006]     {
[11:00:28.006]         {
[11:00:28.006]             ...future.startTime <- base::Sys.time()
[11:00:28.006]             {
[11:00:28.006]                 {
[11:00:28.006]                   {
[11:00:28.006]                     {
[11:00:28.006]                       base::local({
[11:00:28.006]                         has_future <- base::requireNamespace("future", 
[11:00:28.006]                           quietly = TRUE)
[11:00:28.006]                         if (has_future) {
[11:00:28.006]                           ns <- base::getNamespace("future")
[11:00:28.006]                           version <- ns[[".package"]][["version"]]
[11:00:28.006]                           if (is.null(version)) 
[11:00:28.006]                             version <- utils::packageVersion("future")
[11:00:28.006]                         }
[11:00:28.006]                         else {
[11:00:28.006]                           version <- NULL
[11:00:28.006]                         }
[11:00:28.006]                         if (!has_future || version < "1.8.0") {
[11:00:28.006]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:28.006]                             "", base::R.version$version.string), 
[11:00:28.006]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:28.006]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:28.006]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:28.006]                               "release", "version")], collapse = " "), 
[11:00:28.006]                             hostname = base::Sys.info()[["nodename"]])
[11:00:28.006]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:28.006]                             info)
[11:00:28.006]                           info <- base::paste(info, collapse = "; ")
[11:00:28.006]                           if (!has_future) {
[11:00:28.006]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:28.006]                               info)
[11:00:28.006]                           }
[11:00:28.006]                           else {
[11:00:28.006]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:28.006]                               info, version)
[11:00:28.006]                           }
[11:00:28.006]                           base::stop(msg)
[11:00:28.006]                         }
[11:00:28.006]                       })
[11:00:28.006]                     }
[11:00:28.006]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:28.006]                     base::options(mc.cores = 1L)
[11:00:28.006]                   }
[11:00:28.006]                   ...future.strategy.old <- future::plan("list")
[11:00:28.006]                   options(future.plan = NULL)
[11:00:28.006]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:28.006]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:28.006]                 }
[11:00:28.006]                 ...future.workdir <- getwd()
[11:00:28.006]             }
[11:00:28.006]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:28.006]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:28.006]         }
[11:00:28.006]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:28.006]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:28.006]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:28.006]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:28.006]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:28.006]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:28.006]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:28.006]             base::names(...future.oldOptions))
[11:00:28.006]     }
[11:00:28.006]     if (FALSE) {
[11:00:28.006]     }
[11:00:28.006]     else {
[11:00:28.006]         if (TRUE) {
[11:00:28.006]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:28.006]                 open = "w")
[11:00:28.006]         }
[11:00:28.006]         else {
[11:00:28.006]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:28.006]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:28.006]         }
[11:00:28.006]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:28.006]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:28.006]             base::sink(type = "output", split = FALSE)
[11:00:28.006]             base::close(...future.stdout)
[11:00:28.006]         }, add = TRUE)
[11:00:28.006]     }
[11:00:28.006]     ...future.frame <- base::sys.nframe()
[11:00:28.006]     ...future.conditions <- base::list()
[11:00:28.006]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:28.006]     if (FALSE) {
[11:00:28.006]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:28.006]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:28.006]     }
[11:00:28.006]     ...future.result <- base::tryCatch({
[11:00:28.006]         base::withCallingHandlers({
[11:00:28.006]             ...future.value <- base::withVisible(base::local({
[11:00:28.006]                 ...future.makeSendCondition <- base::local({
[11:00:28.006]                   sendCondition <- NULL
[11:00:28.006]                   function(frame = 1L) {
[11:00:28.006]                     if (is.function(sendCondition)) 
[11:00:28.006]                       return(sendCondition)
[11:00:28.006]                     ns <- getNamespace("parallel")
[11:00:28.006]                     if (exists("sendData", mode = "function", 
[11:00:28.006]                       envir = ns)) {
[11:00:28.006]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:28.006]                         envir = ns)
[11:00:28.006]                       envir <- sys.frame(frame)
[11:00:28.006]                       master <- NULL
[11:00:28.006]                       while (!identical(envir, .GlobalEnv) && 
[11:00:28.006]                         !identical(envir, emptyenv())) {
[11:00:28.006]                         if (exists("master", mode = "list", envir = envir, 
[11:00:28.006]                           inherits = FALSE)) {
[11:00:28.006]                           master <- get("master", mode = "list", 
[11:00:28.006]                             envir = envir, inherits = FALSE)
[11:00:28.006]                           if (inherits(master, c("SOCKnode", 
[11:00:28.006]                             "SOCK0node"))) {
[11:00:28.006]                             sendCondition <<- function(cond) {
[11:00:28.006]                               data <- list(type = "VALUE", value = cond, 
[11:00:28.006]                                 success = TRUE)
[11:00:28.006]                               parallel_sendData(master, data)
[11:00:28.006]                             }
[11:00:28.006]                             return(sendCondition)
[11:00:28.006]                           }
[11:00:28.006]                         }
[11:00:28.006]                         frame <- frame + 1L
[11:00:28.006]                         envir <- sys.frame(frame)
[11:00:28.006]                       }
[11:00:28.006]                     }
[11:00:28.006]                     sendCondition <<- function(cond) NULL
[11:00:28.006]                   }
[11:00:28.006]                 })
[11:00:28.006]                 withCallingHandlers({
[11:00:28.006]                   {
[11:00:28.006]                     do.call(function(...) {
[11:00:28.006]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:28.006]                       if (!identical(...future.globals.maxSize.org, 
[11:00:28.006]                         ...future.globals.maxSize)) {
[11:00:28.006]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:28.006]                         on.exit(options(oopts), add = TRUE)
[11:00:28.006]                       }
[11:00:28.006]                       {
[11:00:28.006]                         lapply(seq_along(...future.elements_ii), 
[11:00:28.006]                           FUN = function(jj) {
[11:00:28.006]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:28.006]                             ...future.FUN(...future.X_jj, ...)
[11:00:28.006]                           })
[11:00:28.006]                       }
[11:00:28.006]                     }, args = future.call.arguments)
[11:00:28.006]                   }
[11:00:28.006]                 }, immediateCondition = function(cond) {
[11:00:28.006]                   sendCondition <- ...future.makeSendCondition()
[11:00:28.006]                   sendCondition(cond)
[11:00:28.006]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:28.006]                   {
[11:00:28.006]                     inherits <- base::inherits
[11:00:28.006]                     invokeRestart <- base::invokeRestart
[11:00:28.006]                     is.null <- base::is.null
[11:00:28.006]                     muffled <- FALSE
[11:00:28.006]                     if (inherits(cond, "message")) {
[11:00:28.006]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:28.006]                       if (muffled) 
[11:00:28.006]                         invokeRestart("muffleMessage")
[11:00:28.006]                     }
[11:00:28.006]                     else if (inherits(cond, "warning")) {
[11:00:28.006]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:28.006]                       if (muffled) 
[11:00:28.006]                         invokeRestart("muffleWarning")
[11:00:28.006]                     }
[11:00:28.006]                     else if (inherits(cond, "condition")) {
[11:00:28.006]                       if (!is.null(pattern)) {
[11:00:28.006]                         computeRestarts <- base::computeRestarts
[11:00:28.006]                         grepl <- base::grepl
[11:00:28.006]                         restarts <- computeRestarts(cond)
[11:00:28.006]                         for (restart in restarts) {
[11:00:28.006]                           name <- restart$name
[11:00:28.006]                           if (is.null(name)) 
[11:00:28.006]                             next
[11:00:28.006]                           if (!grepl(pattern, name)) 
[11:00:28.006]                             next
[11:00:28.006]                           invokeRestart(restart)
[11:00:28.006]                           muffled <- TRUE
[11:00:28.006]                           break
[11:00:28.006]                         }
[11:00:28.006]                       }
[11:00:28.006]                     }
[11:00:28.006]                     invisible(muffled)
[11:00:28.006]                   }
[11:00:28.006]                   muffleCondition(cond)
[11:00:28.006]                 })
[11:00:28.006]             }))
[11:00:28.006]             future::FutureResult(value = ...future.value$value, 
[11:00:28.006]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:28.006]                   ...future.rng), globalenv = if (FALSE) 
[11:00:28.006]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:28.006]                     ...future.globalenv.names))
[11:00:28.006]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:28.006]         }, condition = base::local({
[11:00:28.006]             c <- base::c
[11:00:28.006]             inherits <- base::inherits
[11:00:28.006]             invokeRestart <- base::invokeRestart
[11:00:28.006]             length <- base::length
[11:00:28.006]             list <- base::list
[11:00:28.006]             seq.int <- base::seq.int
[11:00:28.006]             signalCondition <- base::signalCondition
[11:00:28.006]             sys.calls <- base::sys.calls
[11:00:28.006]             `[[` <- base::`[[`
[11:00:28.006]             `+` <- base::`+`
[11:00:28.006]             `<<-` <- base::`<<-`
[11:00:28.006]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:28.006]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:28.006]                   3L)]
[11:00:28.006]             }
[11:00:28.006]             function(cond) {
[11:00:28.006]                 is_error <- inherits(cond, "error")
[11:00:28.006]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:28.006]                   NULL)
[11:00:28.006]                 if (is_error) {
[11:00:28.006]                   sessionInformation <- function() {
[11:00:28.006]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:28.006]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:28.006]                       search = base::search(), system = base::Sys.info())
[11:00:28.006]                   }
[11:00:28.006]                   ...future.conditions[[length(...future.conditions) + 
[11:00:28.006]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:28.006]                     cond$call), session = sessionInformation(), 
[11:00:28.006]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:28.006]                   signalCondition(cond)
[11:00:28.006]                 }
[11:00:28.006]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:28.006]                 "immediateCondition"))) {
[11:00:28.006]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:28.006]                   ...future.conditions[[length(...future.conditions) + 
[11:00:28.006]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:28.006]                   if (TRUE && !signal) {
[11:00:28.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:28.006]                     {
[11:00:28.006]                       inherits <- base::inherits
[11:00:28.006]                       invokeRestart <- base::invokeRestart
[11:00:28.006]                       is.null <- base::is.null
[11:00:28.006]                       muffled <- FALSE
[11:00:28.006]                       if (inherits(cond, "message")) {
[11:00:28.006]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:28.006]                         if (muffled) 
[11:00:28.006]                           invokeRestart("muffleMessage")
[11:00:28.006]                       }
[11:00:28.006]                       else if (inherits(cond, "warning")) {
[11:00:28.006]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:28.006]                         if (muffled) 
[11:00:28.006]                           invokeRestart("muffleWarning")
[11:00:28.006]                       }
[11:00:28.006]                       else if (inherits(cond, "condition")) {
[11:00:28.006]                         if (!is.null(pattern)) {
[11:00:28.006]                           computeRestarts <- base::computeRestarts
[11:00:28.006]                           grepl <- base::grepl
[11:00:28.006]                           restarts <- computeRestarts(cond)
[11:00:28.006]                           for (restart in restarts) {
[11:00:28.006]                             name <- restart$name
[11:00:28.006]                             if (is.null(name)) 
[11:00:28.006]                               next
[11:00:28.006]                             if (!grepl(pattern, name)) 
[11:00:28.006]                               next
[11:00:28.006]                             invokeRestart(restart)
[11:00:28.006]                             muffled <- TRUE
[11:00:28.006]                             break
[11:00:28.006]                           }
[11:00:28.006]                         }
[11:00:28.006]                       }
[11:00:28.006]                       invisible(muffled)
[11:00:28.006]                     }
[11:00:28.006]                     muffleCondition(cond, pattern = "^muffle")
[11:00:28.006]                   }
[11:00:28.006]                 }
[11:00:28.006]                 else {
[11:00:28.006]                   if (TRUE) {
[11:00:28.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:28.006]                     {
[11:00:28.006]                       inherits <- base::inherits
[11:00:28.006]                       invokeRestart <- base::invokeRestart
[11:00:28.006]                       is.null <- base::is.null
[11:00:28.006]                       muffled <- FALSE
[11:00:28.006]                       if (inherits(cond, "message")) {
[11:00:28.006]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:28.006]                         if (muffled) 
[11:00:28.006]                           invokeRestart("muffleMessage")
[11:00:28.006]                       }
[11:00:28.006]                       else if (inherits(cond, "warning")) {
[11:00:28.006]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:28.006]                         if (muffled) 
[11:00:28.006]                           invokeRestart("muffleWarning")
[11:00:28.006]                       }
[11:00:28.006]                       else if (inherits(cond, "condition")) {
[11:00:28.006]                         if (!is.null(pattern)) {
[11:00:28.006]                           computeRestarts <- base::computeRestarts
[11:00:28.006]                           grepl <- base::grepl
[11:00:28.006]                           restarts <- computeRestarts(cond)
[11:00:28.006]                           for (restart in restarts) {
[11:00:28.006]                             name <- restart$name
[11:00:28.006]                             if (is.null(name)) 
[11:00:28.006]                               next
[11:00:28.006]                             if (!grepl(pattern, name)) 
[11:00:28.006]                               next
[11:00:28.006]                             invokeRestart(restart)
[11:00:28.006]                             muffled <- TRUE
[11:00:28.006]                             break
[11:00:28.006]                           }
[11:00:28.006]                         }
[11:00:28.006]                       }
[11:00:28.006]                       invisible(muffled)
[11:00:28.006]                     }
[11:00:28.006]                     muffleCondition(cond, pattern = "^muffle")
[11:00:28.006]                   }
[11:00:28.006]                 }
[11:00:28.006]             }
[11:00:28.006]         }))
[11:00:28.006]     }, error = function(ex) {
[11:00:28.006]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:28.006]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:28.006]                 ...future.rng), started = ...future.startTime, 
[11:00:28.006]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:28.006]             version = "1.8"), class = "FutureResult")
[11:00:28.006]     }, finally = {
[11:00:28.006]         if (!identical(...future.workdir, getwd())) 
[11:00:28.006]             setwd(...future.workdir)
[11:00:28.006]         {
[11:00:28.006]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:28.006]                 ...future.oldOptions$nwarnings <- NULL
[11:00:28.006]             }
[11:00:28.006]             base::options(...future.oldOptions)
[11:00:28.006]             if (.Platform$OS.type == "windows") {
[11:00:28.006]                 old_names <- names(...future.oldEnvVars)
[11:00:28.006]                 envs <- base::Sys.getenv()
[11:00:28.006]                 names <- names(envs)
[11:00:28.006]                 common <- intersect(names, old_names)
[11:00:28.006]                 added <- setdiff(names, old_names)
[11:00:28.006]                 removed <- setdiff(old_names, names)
[11:00:28.006]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:28.006]                   envs[common]]
[11:00:28.006]                 NAMES <- toupper(changed)
[11:00:28.006]                 args <- list()
[11:00:28.006]                 for (kk in seq_along(NAMES)) {
[11:00:28.006]                   name <- changed[[kk]]
[11:00:28.006]                   NAME <- NAMES[[kk]]
[11:00:28.006]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:28.006]                     next
[11:00:28.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:28.006]                 }
[11:00:28.006]                 NAMES <- toupper(added)
[11:00:28.006]                 for (kk in seq_along(NAMES)) {
[11:00:28.006]                   name <- added[[kk]]
[11:00:28.006]                   NAME <- NAMES[[kk]]
[11:00:28.006]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:28.006]                     next
[11:00:28.006]                   args[[name]] <- ""
[11:00:28.006]                 }
[11:00:28.006]                 NAMES <- toupper(removed)
[11:00:28.006]                 for (kk in seq_along(NAMES)) {
[11:00:28.006]                   name <- removed[[kk]]
[11:00:28.006]                   NAME <- NAMES[[kk]]
[11:00:28.006]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:28.006]                     next
[11:00:28.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:28.006]                 }
[11:00:28.006]                 if (length(args) > 0) 
[11:00:28.006]                   base::do.call(base::Sys.setenv, args = args)
[11:00:28.006]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:28.006]             }
[11:00:28.006]             else {
[11:00:28.006]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:28.006]             }
[11:00:28.006]             {
[11:00:28.006]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:28.006]                   0L) {
[11:00:28.006]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:28.006]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:28.006]                   base::options(opts)
[11:00:28.006]                 }
[11:00:28.006]                 {
[11:00:28.006]                   {
[11:00:28.006]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:28.006]                     NULL
[11:00:28.006]                   }
[11:00:28.006]                   options(future.plan = NULL)
[11:00:28.006]                   if (is.na(NA_character_)) 
[11:00:28.006]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:28.006]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:28.006]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:28.006]                     .init = FALSE)
[11:00:28.006]                 }
[11:00:28.006]             }
[11:00:28.006]         }
[11:00:28.006]     })
[11:00:28.006]     if (TRUE) {
[11:00:28.006]         base::sink(type = "output", split = FALSE)
[11:00:28.006]         if (TRUE) {
[11:00:28.006]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:28.006]         }
[11:00:28.006]         else {
[11:00:28.006]             ...future.result["stdout"] <- base::list(NULL)
[11:00:28.006]         }
[11:00:28.006]         base::close(...future.stdout)
[11:00:28.006]         ...future.stdout <- NULL
[11:00:28.006]     }
[11:00:28.006]     ...future.result$conditions <- ...future.conditions
[11:00:28.006]     ...future.result$finished <- base::Sys.time()
[11:00:28.006]     ...future.result
[11:00:28.006] }
[11:00:28.009] Exporting 5 global objects (1.46 KiB) to cluster node #2 ...
[11:00:28.009] Exporting ‘...future.FUN’ (841 bytes) to cluster node #2 ...
[11:00:28.009] Exporting ‘...future.FUN’ (841 bytes) to cluster node #2 ... DONE
[11:00:28.009] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[11:00:28.010] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[11:00:28.010] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ...
[11:00:28.010] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ... DONE
[11:00:28.011] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[11:00:28.011] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[11:00:28.011] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[11:00:28.011] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[11:00:28.011] Exporting 5 global objects (1.46 KiB) to cluster node #2 ... DONE
[11:00:28.012] MultisessionFuture started
[11:00:28.012] - Launch lazy future ... done
[11:00:28.012] run() for ‘MultisessionFuture’ ... done
[11:00:28.012] Created future:
[11:00:28.012] MultisessionFuture:
[11:00:28.012] Label: ‘future_lapply-2’
[11:00:28.012] Expression:
[11:00:28.012] {
[11:00:28.012]     do.call(function(...) {
[11:00:28.012]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:28.012]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:28.012]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:28.012]             on.exit(options(oopts), add = TRUE)
[11:00:28.012]         }
[11:00:28.012]         {
[11:00:28.012]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:28.012]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:28.012]                 ...future.FUN(...future.X_jj, ...)
[11:00:28.012]             })
[11:00:28.012]         }
[11:00:28.012]     }, args = future.call.arguments)
[11:00:28.012] }
[11:00:28.012] Lazy evaluation: FALSE
[11:00:28.012] Asynchronous evaluation: TRUE
[11:00:28.012] Local evaluation: TRUE
[11:00:28.012] Environment: R_GlobalEnv
[11:00:28.012] Capture standard output: TRUE
[11:00:28.012] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:28.012] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:28.012] Packages: <none>
[11:00:28.012] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:28.012] Resolved: FALSE
[11:00:28.012] Value: <not collected>
[11:00:28.012] Conditions captured: <none>
[11:00:28.012] Early signaling: FALSE
[11:00:28.012] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:28.012] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:28.024] Chunk #2 of 2 ... DONE
[11:00:28.024] Launching 2 futures (chunks) ... DONE
[11:00:28.024] Resolving 2 futures (chunks) ...
[11:00:28.024] resolve() on list ...
[11:00:28.024]  recursive: 0
[11:00:28.024]  length: 2
[11:00:28.024] 
[11:00:28.066] receiveMessageFromWorker() for ClusterFuture ...
[11:00:28.067] - Validating connection of MultisessionFuture
[11:00:28.067] - received message: FutureResult
[11:00:28.067] - Received FutureResult
[11:00:28.067] - Erased future from FutureRegistry
[11:00:28.067] result() for ClusterFuture ...
[11:00:28.067] - result already collected: FutureResult
[11:00:28.067] result() for ClusterFuture ... done
[11:00:28.067] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:28.067] Future #2
[11:00:28.068] result() for ClusterFuture ...
[11:00:28.068] - result already collected: FutureResult
[11:00:28.068] result() for ClusterFuture ... done
[11:00:28.068] result() for ClusterFuture ...
[11:00:28.068] - result already collected: FutureResult
[11:00:28.068] result() for ClusterFuture ... done
[11:00:28.068] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:00:28.068] - nx: 2
[11:00:28.068] - relay: TRUE
[11:00:28.068] - stdout: TRUE
[11:00:28.068] - signal: TRUE
[11:00:28.068] - resignal: FALSE
[11:00:28.068] - force: TRUE
[11:00:28.069] - relayed: [n=2] FALSE, FALSE
[11:00:28.069] - queued futures: [n=2] FALSE, FALSE
[11:00:28.069]  - until=1
[11:00:28.069]  - relaying element #1
[11:00:28.069] - relayed: [n=2] FALSE, FALSE
[11:00:28.069] - queued futures: [n=2] FALSE, TRUE
[11:00:28.069] signalConditionsASAP(NULL, pos=2) ... done
[11:00:28.069]  length: 1 (resolved future 2)
[11:00:28.516] receiveMessageFromWorker() for ClusterFuture ...
[11:00:28.516] - Validating connection of MultisessionFuture
[11:00:28.516] - received message: FutureResult
[11:00:28.516] - Received FutureResult
[11:00:28.517] - Erased future from FutureRegistry
[11:00:28.517] result() for ClusterFuture ...
[11:00:28.517] - result already collected: FutureResult
[11:00:28.517] result() for ClusterFuture ... done
[11:00:28.517] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:28.517] Future #1
[11:00:28.517] result() for ClusterFuture ...
[11:00:28.517] - result already collected: FutureResult
[11:00:28.517] result() for ClusterFuture ... done
[11:00:28.517] result() for ClusterFuture ...
[11:00:28.517] - result already collected: FutureResult
[11:00:28.518] result() for ClusterFuture ... done
[11:00:28.518] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:00:28.518] - nx: 2
[11:00:28.518] - relay: TRUE
[11:00:28.518] - stdout: TRUE
[11:00:28.518] - signal: TRUE
[11:00:28.518] - resignal: FALSE
[11:00:28.518] - force: TRUE
[11:00:28.518] - relayed: [n=2] FALSE, FALSE
[11:00:28.518] - queued futures: [n=2] FALSE, TRUE
[11:00:28.518]  - until=1
[11:00:28.518]  - relaying element #1
[11:00:28.518] result() for ClusterFuture ...
[11:00:28.519] - result already collected: FutureResult
[11:00:28.519] result() for ClusterFuture ... done
[11:00:28.519] result() for ClusterFuture ...
[11:00:28.519] - result already collected: FutureResult
[11:00:28.519] result() for ClusterFuture ... done
[11:00:28.519] result() for ClusterFuture ...
[11:00:28.519] - result already collected: FutureResult
[11:00:28.519] result() for ClusterFuture ... done
[11:00:28.519] result() for ClusterFuture ...
[11:00:28.519] - result already collected: FutureResult
[11:00:28.519] result() for ClusterFuture ... done
[11:00:28.519] - relayed: [n=2] TRUE, FALSE
[11:00:28.520] - queued futures: [n=2] TRUE, TRUE
[11:00:28.520] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:00:28.520]  length: 0 (resolved future 1)
[11:00:28.520] Relaying remaining futures
[11:00:28.520] signalConditionsASAP(NULL, pos=0) ...
[11:00:28.520] - nx: 2
[11:00:28.520] - relay: TRUE
[11:00:28.520] - stdout: TRUE
[11:00:28.520] - signal: TRUE
[11:00:28.520] - resignal: FALSE
[11:00:28.520] - force: TRUE
[11:00:28.520] - relayed: [n=2] TRUE, FALSE
[11:00:28.520] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:28.521]  - relaying element #2
[11:00:28.521] result() for ClusterFuture ...
[11:00:28.521] - result already collected: FutureResult
[11:00:28.521] result() for ClusterFuture ... done
[11:00:28.521] result() for ClusterFuture ...
[11:00:28.521] - result already collected: FutureResult
[11:00:28.521] result() for ClusterFuture ... done
[11:00:28.521] result() for ClusterFuture ...
[11:00:28.521] - result already collected: FutureResult
[11:00:28.521] result() for ClusterFuture ... done
[11:00:28.521] result() for ClusterFuture ...
[11:00:28.522] - result already collected: FutureResult
[11:00:28.522] result() for ClusterFuture ... done
[11:00:28.522] - relayed: [n=2] TRUE, TRUE
[11:00:28.522] - queued futures: [n=2] TRUE, TRUE
[11:00:28.522] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[11:00:28.522] resolve() on list ... DONE
[11:00:28.522] result() for ClusterFuture ...
[11:00:28.522] - result already collected: FutureResult
[11:00:28.522] result() for ClusterFuture ... done
[11:00:28.522] result() for ClusterFuture ...
[11:00:28.522] - result already collected: FutureResult
[11:00:28.522] result() for ClusterFuture ... done
[11:00:28.523] result() for ClusterFuture ...
[11:00:28.523] - result already collected: FutureResult
[11:00:28.523] result() for ClusterFuture ... done
[11:00:28.523] result() for ClusterFuture ...
[11:00:28.523] - result already collected: FutureResult
[11:00:28.523] result() for ClusterFuture ... done
[11:00:28.523]  - Number of value chunks collected: 2
[11:00:28.523] Resolving 2 futures (chunks) ... DONE
[11:00:28.523] Reducing values from 2 chunks ...
[11:00:28.523]  - Number of values collected after concatenation: 2
[11:00:28.523]  - Number of values expected: 2
[11:00:28.523] Reducing values from 2 chunks ... DONE
[11:00:28.524] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[11:00:28.524] future_lapply() ...
[11:00:28.526] Number of chunks: 2
[11:00:28.526] getGlobalsAndPackagesXApply() ...
[11:00:28.526]  - future.globals: TRUE
[11:00:28.526] getGlobalsAndPackages() ...
[11:00:28.526] Searching for globals...
[11:00:28.528] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[11:00:28.528] Searching for globals ... DONE
[11:00:28.528] Resolving globals: FALSE
[11:00:28.528] The total size of the 1 globals is 841 bytes (841 bytes)
[11:00:28.529] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[11:00:28.529] - globals: [1] ‘FUN’
[11:00:28.529] 
[11:00:28.529] getGlobalsAndPackages() ... DONE
[11:00:28.529]  - globals found/used: [n=1] ‘FUN’
[11:00:28.529]  - needed namespaces: [n=0] 
[11:00:28.529] Finding globals ... DONE
[11:00:28.529]  - use_args: TRUE
[11:00:28.529]  - Getting '...' globals ...
[11:00:28.530] resolve() on list ...
[11:00:28.530]  recursive: 0
[11:00:28.530]  length: 1
[11:00:28.530]  elements: ‘...’
[11:00:28.530]  length: 0 (resolved future 1)
[11:00:28.530] resolve() on list ... DONE
[11:00:28.530]    - '...' content: [n=0] 
[11:00:28.530] List of 1
[11:00:28.530]  $ ...: list()
[11:00:28.530]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:28.530]  - attr(*, "where")=List of 1
[11:00:28.530]   ..$ ...:<environment: 0x55ceb5923250> 
[11:00:28.530]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:28.530]  - attr(*, "resolved")= logi TRUE
[11:00:28.530]  - attr(*, "total_size")= num NA
[11:00:28.533]  - Getting '...' globals ... DONE
[11:00:28.533] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[11:00:28.533] List of 2
[11:00:28.533]  $ ...future.FUN:function (x)  
[11:00:28.533]  $ ...          : list()
[11:00:28.533]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[11:00:28.533]  - attr(*, "where")=List of 2
[11:00:28.533]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:28.533]   ..$ ...          :<environment: 0x55ceb5923250> 
[11:00:28.533]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:28.533]  - attr(*, "resolved")= logi FALSE
[11:00:28.533]  - attr(*, "total_size")= num 5632
[11:00:28.536] Packages to be attached in all futures: [n=0] 
[11:00:28.536] getGlobalsAndPackagesXApply() ... DONE
[11:00:28.536] Number of futures (= number of chunks): 2
[11:00:28.536] Launching 2 futures (chunks) ...
[11:00:28.536] Chunk #1 of 2 ...
[11:00:28.536]  - Finding globals in 'X' for chunk #1 ...
[11:00:28.536] getGlobalsAndPackages() ...
[11:00:28.536] Searching for globals...
[11:00:28.537] 
[11:00:28.537] Searching for globals ... DONE
[11:00:28.537] - globals: [0] <none>
[11:00:28.537] getGlobalsAndPackages() ... DONE
[11:00:28.537]    + additional globals found: [n=0] 
[11:00:28.537]    + additional namespaces needed: [n=0] 
[11:00:28.537]  - Finding globals in 'X' for chunk #1 ... DONE
[11:00:28.537]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:28.537]  - seeds: <none>
[11:00:28.537]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:28.537] getGlobalsAndPackages() ...
[11:00:28.537] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:28.538] Resolving globals: FALSE
[11:00:28.538] Tweak future expression to call with '...' arguments ...
[11:00:28.538] {
[11:00:28.538]     do.call(function(...) {
[11:00:28.538]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:28.538]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:28.538]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:28.538]             on.exit(options(oopts), add = TRUE)
[11:00:28.538]         }
[11:00:28.538]         {
[11:00:28.538]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:28.538]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:28.538]                 ...future.FUN(...future.X_jj, ...)
[11:00:28.538]             })
[11:00:28.538]         }
[11:00:28.538]     }, args = future.call.arguments)
[11:00:28.538] }
[11:00:28.538] Tweak future expression to call with '...' arguments ... DONE
[11:00:28.538] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:28.538] 
[11:00:28.539] getGlobalsAndPackages() ... DONE
[11:00:28.539] run() for ‘Future’ ...
[11:00:28.539] - state: ‘created’
[11:00:28.539] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:28.553] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:28.553] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:28.553]   - Field: ‘node’
[11:00:28.553]   - Field: ‘label’
[11:00:28.553]   - Field: ‘local’
[11:00:28.553]   - Field: ‘owner’
[11:00:28.553]   - Field: ‘envir’
[11:00:28.553]   - Field: ‘workers’
[11:00:28.553]   - Field: ‘packages’
[11:00:28.553]   - Field: ‘gc’
[11:00:28.554]   - Field: ‘conditions’
[11:00:28.554]   - Field: ‘persistent’
[11:00:28.554]   - Field: ‘expr’
[11:00:28.554]   - Field: ‘uuid’
[11:00:28.554]   - Field: ‘seed’
[11:00:28.554]   - Field: ‘version’
[11:00:28.554]   - Field: ‘result’
[11:00:28.554]   - Field: ‘asynchronous’
[11:00:28.554]   - Field: ‘calls’
[11:00:28.554]   - Field: ‘globals’
[11:00:28.554]   - Field: ‘stdout’
[11:00:28.554]   - Field: ‘earlySignal’
[11:00:28.555]   - Field: ‘lazy’
[11:00:28.555]   - Field: ‘state’
[11:00:28.555] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:28.555] - Launch lazy future ...
[11:00:28.555] Packages needed by the future expression (n = 0): <none>
[11:00:28.555] Packages needed by future strategies (n = 0): <none>
[11:00:28.556] {
[11:00:28.556]     {
[11:00:28.556]         {
[11:00:28.556]             ...future.startTime <- base::Sys.time()
[11:00:28.556]             {
[11:00:28.556]                 {
[11:00:28.556]                   {
[11:00:28.556]                     {
[11:00:28.556]                       base::local({
[11:00:28.556]                         has_future <- base::requireNamespace("future", 
[11:00:28.556]                           quietly = TRUE)
[11:00:28.556]                         if (has_future) {
[11:00:28.556]                           ns <- base::getNamespace("future")
[11:00:28.556]                           version <- ns[[".package"]][["version"]]
[11:00:28.556]                           if (is.null(version)) 
[11:00:28.556]                             version <- utils::packageVersion("future")
[11:00:28.556]                         }
[11:00:28.556]                         else {
[11:00:28.556]                           version <- NULL
[11:00:28.556]                         }
[11:00:28.556]                         if (!has_future || version < "1.8.0") {
[11:00:28.556]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:28.556]                             "", base::R.version$version.string), 
[11:00:28.556]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:28.556]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:28.556]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:28.556]                               "release", "version")], collapse = " "), 
[11:00:28.556]                             hostname = base::Sys.info()[["nodename"]])
[11:00:28.556]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:28.556]                             info)
[11:00:28.556]                           info <- base::paste(info, collapse = "; ")
[11:00:28.556]                           if (!has_future) {
[11:00:28.556]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:28.556]                               info)
[11:00:28.556]                           }
[11:00:28.556]                           else {
[11:00:28.556]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:28.556]                               info, version)
[11:00:28.556]                           }
[11:00:28.556]                           base::stop(msg)
[11:00:28.556]                         }
[11:00:28.556]                       })
[11:00:28.556]                     }
[11:00:28.556]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:28.556]                     base::options(mc.cores = 1L)
[11:00:28.556]                   }
[11:00:28.556]                   ...future.strategy.old <- future::plan("list")
[11:00:28.556]                   options(future.plan = NULL)
[11:00:28.556]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:28.556]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:28.556]                 }
[11:00:28.556]                 ...future.workdir <- getwd()
[11:00:28.556]             }
[11:00:28.556]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:28.556]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:28.556]         }
[11:00:28.556]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:28.556]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:28.556]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:28.556]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:28.556]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:28.556]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:28.556]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:28.556]             base::names(...future.oldOptions))
[11:00:28.556]     }
[11:00:28.556]     if (TRUE) {
[11:00:28.556]     }
[11:00:28.556]     else {
[11:00:28.556]         if (NA) {
[11:00:28.556]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:28.556]                 open = "w")
[11:00:28.556]         }
[11:00:28.556]         else {
[11:00:28.556]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:28.556]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:28.556]         }
[11:00:28.556]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:28.556]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:28.556]             base::sink(type = "output", split = FALSE)
[11:00:28.556]             base::close(...future.stdout)
[11:00:28.556]         }, add = TRUE)
[11:00:28.556]     }
[11:00:28.556]     ...future.frame <- base::sys.nframe()
[11:00:28.556]     ...future.conditions <- base::list()
[11:00:28.556]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:28.556]     if (FALSE) {
[11:00:28.556]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:28.556]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:28.556]     }
[11:00:28.556]     ...future.result <- base::tryCatch({
[11:00:28.556]         base::withCallingHandlers({
[11:00:28.556]             ...future.value <- base::withVisible(base::local({
[11:00:28.556]                 ...future.makeSendCondition <- base::local({
[11:00:28.556]                   sendCondition <- NULL
[11:00:28.556]                   function(frame = 1L) {
[11:00:28.556]                     if (is.function(sendCondition)) 
[11:00:28.556]                       return(sendCondition)
[11:00:28.556]                     ns <- getNamespace("parallel")
[11:00:28.556]                     if (exists("sendData", mode = "function", 
[11:00:28.556]                       envir = ns)) {
[11:00:28.556]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:28.556]                         envir = ns)
[11:00:28.556]                       envir <- sys.frame(frame)
[11:00:28.556]                       master <- NULL
[11:00:28.556]                       while (!identical(envir, .GlobalEnv) && 
[11:00:28.556]                         !identical(envir, emptyenv())) {
[11:00:28.556]                         if (exists("master", mode = "list", envir = envir, 
[11:00:28.556]                           inherits = FALSE)) {
[11:00:28.556]                           master <- get("master", mode = "list", 
[11:00:28.556]                             envir = envir, inherits = FALSE)
[11:00:28.556]                           if (inherits(master, c("SOCKnode", 
[11:00:28.556]                             "SOCK0node"))) {
[11:00:28.556]                             sendCondition <<- function(cond) {
[11:00:28.556]                               data <- list(type = "VALUE", value = cond, 
[11:00:28.556]                                 success = TRUE)
[11:00:28.556]                               parallel_sendData(master, data)
[11:00:28.556]                             }
[11:00:28.556]                             return(sendCondition)
[11:00:28.556]                           }
[11:00:28.556]                         }
[11:00:28.556]                         frame <- frame + 1L
[11:00:28.556]                         envir <- sys.frame(frame)
[11:00:28.556]                       }
[11:00:28.556]                     }
[11:00:28.556]                     sendCondition <<- function(cond) NULL
[11:00:28.556]                   }
[11:00:28.556]                 })
[11:00:28.556]                 withCallingHandlers({
[11:00:28.556]                   {
[11:00:28.556]                     do.call(function(...) {
[11:00:28.556]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:28.556]                       if (!identical(...future.globals.maxSize.org, 
[11:00:28.556]                         ...future.globals.maxSize)) {
[11:00:28.556]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:28.556]                         on.exit(options(oopts), add = TRUE)
[11:00:28.556]                       }
[11:00:28.556]                       {
[11:00:28.556]                         lapply(seq_along(...future.elements_ii), 
[11:00:28.556]                           FUN = function(jj) {
[11:00:28.556]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:28.556]                             ...future.FUN(...future.X_jj, ...)
[11:00:28.556]                           })
[11:00:28.556]                       }
[11:00:28.556]                     }, args = future.call.arguments)
[11:00:28.556]                   }
[11:00:28.556]                 }, immediateCondition = function(cond) {
[11:00:28.556]                   sendCondition <- ...future.makeSendCondition()
[11:00:28.556]                   sendCondition(cond)
[11:00:28.556]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:28.556]                   {
[11:00:28.556]                     inherits <- base::inherits
[11:00:28.556]                     invokeRestart <- base::invokeRestart
[11:00:28.556]                     is.null <- base::is.null
[11:00:28.556]                     muffled <- FALSE
[11:00:28.556]                     if (inherits(cond, "message")) {
[11:00:28.556]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:28.556]                       if (muffled) 
[11:00:28.556]                         invokeRestart("muffleMessage")
[11:00:28.556]                     }
[11:00:28.556]                     else if (inherits(cond, "warning")) {
[11:00:28.556]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:28.556]                       if (muffled) 
[11:00:28.556]                         invokeRestart("muffleWarning")
[11:00:28.556]                     }
[11:00:28.556]                     else if (inherits(cond, "condition")) {
[11:00:28.556]                       if (!is.null(pattern)) {
[11:00:28.556]                         computeRestarts <- base::computeRestarts
[11:00:28.556]                         grepl <- base::grepl
[11:00:28.556]                         restarts <- computeRestarts(cond)
[11:00:28.556]                         for (restart in restarts) {
[11:00:28.556]                           name <- restart$name
[11:00:28.556]                           if (is.null(name)) 
[11:00:28.556]                             next
[11:00:28.556]                           if (!grepl(pattern, name)) 
[11:00:28.556]                             next
[11:00:28.556]                           invokeRestart(restart)
[11:00:28.556]                           muffled <- TRUE
[11:00:28.556]                           break
[11:00:28.556]                         }
[11:00:28.556]                       }
[11:00:28.556]                     }
[11:00:28.556]                     invisible(muffled)
[11:00:28.556]                   }
[11:00:28.556]                   muffleCondition(cond)
[11:00:28.556]                 })
[11:00:28.556]             }))
[11:00:28.556]             future::FutureResult(value = ...future.value$value, 
[11:00:28.556]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:28.556]                   ...future.rng), globalenv = if (FALSE) 
[11:00:28.556]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:28.556]                     ...future.globalenv.names))
[11:00:28.556]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:28.556]         }, condition = base::local({
[11:00:28.556]             c <- base::c
[11:00:28.556]             inherits <- base::inherits
[11:00:28.556]             invokeRestart <- base::invokeRestart
[11:00:28.556]             length <- base::length
[11:00:28.556]             list <- base::list
[11:00:28.556]             seq.int <- base::seq.int
[11:00:28.556]             signalCondition <- base::signalCondition
[11:00:28.556]             sys.calls <- base::sys.calls
[11:00:28.556]             `[[` <- base::`[[`
[11:00:28.556]             `+` <- base::`+`
[11:00:28.556]             `<<-` <- base::`<<-`
[11:00:28.556]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:28.556]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:28.556]                   3L)]
[11:00:28.556]             }
[11:00:28.556]             function(cond) {
[11:00:28.556]                 is_error <- inherits(cond, "error")
[11:00:28.556]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:28.556]                   NULL)
[11:00:28.556]                 if (is_error) {
[11:00:28.556]                   sessionInformation <- function() {
[11:00:28.556]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:28.556]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:28.556]                       search = base::search(), system = base::Sys.info())
[11:00:28.556]                   }
[11:00:28.556]                   ...future.conditions[[length(...future.conditions) + 
[11:00:28.556]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:28.556]                     cond$call), session = sessionInformation(), 
[11:00:28.556]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:28.556]                   signalCondition(cond)
[11:00:28.556]                 }
[11:00:28.556]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:28.556]                 "immediateCondition"))) {
[11:00:28.556]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:28.556]                   ...future.conditions[[length(...future.conditions) + 
[11:00:28.556]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:28.556]                   if (TRUE && !signal) {
[11:00:28.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:28.556]                     {
[11:00:28.556]                       inherits <- base::inherits
[11:00:28.556]                       invokeRestart <- base::invokeRestart
[11:00:28.556]                       is.null <- base::is.null
[11:00:28.556]                       muffled <- FALSE
[11:00:28.556]                       if (inherits(cond, "message")) {
[11:00:28.556]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:28.556]                         if (muffled) 
[11:00:28.556]                           invokeRestart("muffleMessage")
[11:00:28.556]                       }
[11:00:28.556]                       else if (inherits(cond, "warning")) {
[11:00:28.556]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:28.556]                         if (muffled) 
[11:00:28.556]                           invokeRestart("muffleWarning")
[11:00:28.556]                       }
[11:00:28.556]                       else if (inherits(cond, "condition")) {
[11:00:28.556]                         if (!is.null(pattern)) {
[11:00:28.556]                           computeRestarts <- base::computeRestarts
[11:00:28.556]                           grepl <- base::grepl
[11:00:28.556]                           restarts <- computeRestarts(cond)
[11:00:28.556]                           for (restart in restarts) {
[11:00:28.556]                             name <- restart$name
[11:00:28.556]                             if (is.null(name)) 
[11:00:28.556]                               next
[11:00:28.556]                             if (!grepl(pattern, name)) 
[11:00:28.556]                               next
[11:00:28.556]                             invokeRestart(restart)
[11:00:28.556]                             muffled <- TRUE
[11:00:28.556]                             break
[11:00:28.556]                           }
[11:00:28.556]                         }
[11:00:28.556]                       }
[11:00:28.556]                       invisible(muffled)
[11:00:28.556]                     }
[11:00:28.556]                     muffleCondition(cond, pattern = "^muffle")
[11:00:28.556]                   }
[11:00:28.556]                 }
[11:00:28.556]                 else {
[11:00:28.556]                   if (TRUE) {
[11:00:28.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:28.556]                     {
[11:00:28.556]                       inherits <- base::inherits
[11:00:28.556]                       invokeRestart <- base::invokeRestart
[11:00:28.556]                       is.null <- base::is.null
[11:00:28.556]                       muffled <- FALSE
[11:00:28.556]                       if (inherits(cond, "message")) {
[11:00:28.556]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:28.556]                         if (muffled) 
[11:00:28.556]                           invokeRestart("muffleMessage")
[11:00:28.556]                       }
[11:00:28.556]                       else if (inherits(cond, "warning")) {
[11:00:28.556]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:28.556]                         if (muffled) 
[11:00:28.556]                           invokeRestart("muffleWarning")
[11:00:28.556]                       }
[11:00:28.556]                       else if (inherits(cond, "condition")) {
[11:00:28.556]                         if (!is.null(pattern)) {
[11:00:28.556]                           computeRestarts <- base::computeRestarts
[11:00:28.556]                           grepl <- base::grepl
[11:00:28.556]                           restarts <- computeRestarts(cond)
[11:00:28.556]                           for (restart in restarts) {
[11:00:28.556]                             name <- restart$name
[11:00:28.556]                             if (is.null(name)) 
[11:00:28.556]                               next
[11:00:28.556]                             if (!grepl(pattern, name)) 
[11:00:28.556]                               next
[11:00:28.556]                             invokeRestart(restart)
[11:00:28.556]                             muffled <- TRUE
[11:00:28.556]                             break
[11:00:28.556]                           }
[11:00:28.556]                         }
[11:00:28.556]                       }
[11:00:28.556]                       invisible(muffled)
[11:00:28.556]                     }
[11:00:28.556]                     muffleCondition(cond, pattern = "^muffle")
[11:00:28.556]                   }
[11:00:28.556]                 }
[11:00:28.556]             }
[11:00:28.556]         }))
[11:00:28.556]     }, error = function(ex) {
[11:00:28.556]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:28.556]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:28.556]                 ...future.rng), started = ...future.startTime, 
[11:00:28.556]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:28.556]             version = "1.8"), class = "FutureResult")
[11:00:28.556]     }, finally = {
[11:00:28.556]         if (!identical(...future.workdir, getwd())) 
[11:00:28.556]             setwd(...future.workdir)
[11:00:28.556]         {
[11:00:28.556]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:28.556]                 ...future.oldOptions$nwarnings <- NULL
[11:00:28.556]             }
[11:00:28.556]             base::options(...future.oldOptions)
[11:00:28.556]             if (.Platform$OS.type == "windows") {
[11:00:28.556]                 old_names <- names(...future.oldEnvVars)
[11:00:28.556]                 envs <- base::Sys.getenv()
[11:00:28.556]                 names <- names(envs)
[11:00:28.556]                 common <- intersect(names, old_names)
[11:00:28.556]                 added <- setdiff(names, old_names)
[11:00:28.556]                 removed <- setdiff(old_names, names)
[11:00:28.556]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:28.556]                   envs[common]]
[11:00:28.556]                 NAMES <- toupper(changed)
[11:00:28.556]                 args <- list()
[11:00:28.556]                 for (kk in seq_along(NAMES)) {
[11:00:28.556]                   name <- changed[[kk]]
[11:00:28.556]                   NAME <- NAMES[[kk]]
[11:00:28.556]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:28.556]                     next
[11:00:28.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:28.556]                 }
[11:00:28.556]                 NAMES <- toupper(added)
[11:00:28.556]                 for (kk in seq_along(NAMES)) {
[11:00:28.556]                   name <- added[[kk]]
[11:00:28.556]                   NAME <- NAMES[[kk]]
[11:00:28.556]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:28.556]                     next
[11:00:28.556]                   args[[name]] <- ""
[11:00:28.556]                 }
[11:00:28.556]                 NAMES <- toupper(removed)
[11:00:28.556]                 for (kk in seq_along(NAMES)) {
[11:00:28.556]                   name <- removed[[kk]]
[11:00:28.556]                   NAME <- NAMES[[kk]]
[11:00:28.556]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:28.556]                     next
[11:00:28.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:28.556]                 }
[11:00:28.556]                 if (length(args) > 0) 
[11:00:28.556]                   base::do.call(base::Sys.setenv, args = args)
[11:00:28.556]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:28.556]             }
[11:00:28.556]             else {
[11:00:28.556]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:28.556]             }
[11:00:28.556]             {
[11:00:28.556]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:28.556]                   0L) {
[11:00:28.556]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:28.556]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:28.556]                   base::options(opts)
[11:00:28.556]                 }
[11:00:28.556]                 {
[11:00:28.556]                   {
[11:00:28.556]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:28.556]                     NULL
[11:00:28.556]                   }
[11:00:28.556]                   options(future.plan = NULL)
[11:00:28.556]                   if (is.na(NA_character_)) 
[11:00:28.556]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:28.556]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:28.556]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:28.556]                     .init = FALSE)
[11:00:28.556]                 }
[11:00:28.556]             }
[11:00:28.556]         }
[11:00:28.556]     })
[11:00:28.556]     if (FALSE) {
[11:00:28.556]         base::sink(type = "output", split = FALSE)
[11:00:28.556]         if (NA) {
[11:00:28.556]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:28.556]         }
[11:00:28.556]         else {
[11:00:28.556]             ...future.result["stdout"] <- base::list(NULL)
[11:00:28.556]         }
[11:00:28.556]         base::close(...future.stdout)
[11:00:28.556]         ...future.stdout <- NULL
[11:00:28.556]     }
[11:00:28.556]     ...future.result$conditions <- ...future.conditions
[11:00:28.556]     ...future.result$finished <- base::Sys.time()
[11:00:28.556]     ...future.result
[11:00:28.556] }
[11:00:28.558] Exporting 5 global objects (1.46 KiB) to cluster node #1 ...
[11:00:28.559] Exporting ‘...future.FUN’ (841 bytes) to cluster node #1 ...
[11:00:28.559] Exporting ‘...future.FUN’ (841 bytes) to cluster node #1 ... DONE
[11:00:28.559] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[11:00:28.559] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[11:00:28.559] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ...
[11:00:28.560] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ... DONE
[11:00:28.560] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[11:00:28.560] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[11:00:28.560] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[11:00:28.561] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[11:00:28.561] Exporting 5 global objects (1.46 KiB) to cluster node #1 ... DONE
[11:00:28.561] MultisessionFuture started
[11:00:28.561] - Launch lazy future ... done
[11:00:28.561] run() for ‘MultisessionFuture’ ... done
[11:00:28.562] Created future:
[11:00:28.562] MultisessionFuture:
[11:00:28.562] Label: ‘future_lapply-1’
[11:00:28.562] Expression:
[11:00:28.562] {
[11:00:28.562]     do.call(function(...) {
[11:00:28.562]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:28.562]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:28.562]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:28.562]             on.exit(options(oopts), add = TRUE)
[11:00:28.562]         }
[11:00:28.562]         {
[11:00:28.562]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:28.562]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:28.562]                 ...future.FUN(...future.X_jj, ...)
[11:00:28.562]             })
[11:00:28.562]         }
[11:00:28.562]     }, args = future.call.arguments)
[11:00:28.562] }
[11:00:28.562] Lazy evaluation: FALSE
[11:00:28.562] Asynchronous evaluation: TRUE
[11:00:28.562] Local evaluation: TRUE
[11:00:28.562] Environment: R_GlobalEnv
[11:00:28.562] Capture standard output: NA
[11:00:28.562] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:28.562] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:28.562] Packages: <none>
[11:00:28.562] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:28.562] Resolved: FALSE
[11:00:28.562] Value: <not collected>
[11:00:28.562] Conditions captured: <none>
[11:00:28.562] Early signaling: FALSE
[11:00:28.562] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:28.562] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:28.573] Chunk #1 of 2 ... DONE
[11:00:28.573] Chunk #2 of 2 ...
[11:00:28.573]  - Finding globals in 'X' for chunk #2 ...
[11:00:28.573] getGlobalsAndPackages() ...
[11:00:28.573] Searching for globals...
[11:00:28.575] 
[11:00:28.576] Searching for globals ... DONE
[11:00:28.576] - globals: [0] <none>
[11:00:28.576] getGlobalsAndPackages() ... DONE
[11:00:28.576]    + additional globals found: [n=0] 
[11:00:28.576]    + additional namespaces needed: [n=0] 
[11:00:28.576]  - Finding globals in 'X' for chunk #2 ... DONE
[11:00:28.576]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:28.576]  - seeds: <none>
[11:00:28.576]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:28.576] getGlobalsAndPackages() ...
[11:00:28.576] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:28.577] Resolving globals: FALSE
[11:00:28.577] Tweak future expression to call with '...' arguments ...
[11:00:28.577] {
[11:00:28.577]     do.call(function(...) {
[11:00:28.577]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:28.577]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:28.577]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:28.577]             on.exit(options(oopts), add = TRUE)
[11:00:28.577]         }
[11:00:28.577]         {
[11:00:28.577]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:28.577]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:28.577]                 ...future.FUN(...future.X_jj, ...)
[11:00:28.577]             })
[11:00:28.577]         }
[11:00:28.577]     }, args = future.call.arguments)
[11:00:28.577] }
[11:00:28.577] Tweak future expression to call with '...' arguments ... DONE
[11:00:28.577] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:28.577] 
[11:00:28.577] getGlobalsAndPackages() ... DONE
[11:00:28.578] run() for ‘Future’ ...
[11:00:28.578] - state: ‘created’
[11:00:28.578] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:28.592] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:28.592] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:28.592]   - Field: ‘node’
[11:00:28.593]   - Field: ‘label’
[11:00:28.593]   - Field: ‘local’
[11:00:28.593]   - Field: ‘owner’
[11:00:28.593]   - Field: ‘envir’
[11:00:28.593]   - Field: ‘workers’
[11:00:28.593]   - Field: ‘packages’
[11:00:28.593]   - Field: ‘gc’
[11:00:28.593]   - Field: ‘conditions’
[11:00:28.593]   - Field: ‘persistent’
[11:00:28.593]   - Field: ‘expr’
[11:00:28.593]   - Field: ‘uuid’
[11:00:28.593]   - Field: ‘seed’
[11:00:28.594]   - Field: ‘version’
[11:00:28.594]   - Field: ‘result’
[11:00:28.594]   - Field: ‘asynchronous’
[11:00:28.594]   - Field: ‘calls’
[11:00:28.594]   - Field: ‘globals’
[11:00:28.594]   - Field: ‘stdout’
[11:00:28.594]   - Field: ‘earlySignal’
[11:00:28.594]   - Field: ‘lazy’
[11:00:28.594]   - Field: ‘state’
[11:00:28.594] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:28.594] - Launch lazy future ...
[11:00:28.595] Packages needed by the future expression (n = 0): <none>
[11:00:28.595] Packages needed by future strategies (n = 0): <none>
[11:00:28.595] {
[11:00:28.595]     {
[11:00:28.595]         {
[11:00:28.595]             ...future.startTime <- base::Sys.time()
[11:00:28.595]             {
[11:00:28.595]                 {
[11:00:28.595]                   {
[11:00:28.595]                     {
[11:00:28.595]                       base::local({
[11:00:28.595]                         has_future <- base::requireNamespace("future", 
[11:00:28.595]                           quietly = TRUE)
[11:00:28.595]                         if (has_future) {
[11:00:28.595]                           ns <- base::getNamespace("future")
[11:00:28.595]                           version <- ns[[".package"]][["version"]]
[11:00:28.595]                           if (is.null(version)) 
[11:00:28.595]                             version <- utils::packageVersion("future")
[11:00:28.595]                         }
[11:00:28.595]                         else {
[11:00:28.595]                           version <- NULL
[11:00:28.595]                         }
[11:00:28.595]                         if (!has_future || version < "1.8.0") {
[11:00:28.595]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:28.595]                             "", base::R.version$version.string), 
[11:00:28.595]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:28.595]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:28.595]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:28.595]                               "release", "version")], collapse = " "), 
[11:00:28.595]                             hostname = base::Sys.info()[["nodename"]])
[11:00:28.595]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:28.595]                             info)
[11:00:28.595]                           info <- base::paste(info, collapse = "; ")
[11:00:28.595]                           if (!has_future) {
[11:00:28.595]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:28.595]                               info)
[11:00:28.595]                           }
[11:00:28.595]                           else {
[11:00:28.595]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:28.595]                               info, version)
[11:00:28.595]                           }
[11:00:28.595]                           base::stop(msg)
[11:00:28.595]                         }
[11:00:28.595]                       })
[11:00:28.595]                     }
[11:00:28.595]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:28.595]                     base::options(mc.cores = 1L)
[11:00:28.595]                   }
[11:00:28.595]                   ...future.strategy.old <- future::plan("list")
[11:00:28.595]                   options(future.plan = NULL)
[11:00:28.595]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:28.595]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:28.595]                 }
[11:00:28.595]                 ...future.workdir <- getwd()
[11:00:28.595]             }
[11:00:28.595]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:28.595]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:28.595]         }
[11:00:28.595]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:28.595]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:28.595]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:28.595]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:28.595]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:28.595]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:28.595]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:28.595]             base::names(...future.oldOptions))
[11:00:28.595]     }
[11:00:28.595]     if (TRUE) {
[11:00:28.595]     }
[11:00:28.595]     else {
[11:00:28.595]         if (NA) {
[11:00:28.595]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:28.595]                 open = "w")
[11:00:28.595]         }
[11:00:28.595]         else {
[11:00:28.595]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:28.595]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:28.595]         }
[11:00:28.595]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:28.595]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:28.595]             base::sink(type = "output", split = FALSE)
[11:00:28.595]             base::close(...future.stdout)
[11:00:28.595]         }, add = TRUE)
[11:00:28.595]     }
[11:00:28.595]     ...future.frame <- base::sys.nframe()
[11:00:28.595]     ...future.conditions <- base::list()
[11:00:28.595]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:28.595]     if (FALSE) {
[11:00:28.595]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:28.595]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:28.595]     }
[11:00:28.595]     ...future.result <- base::tryCatch({
[11:00:28.595]         base::withCallingHandlers({
[11:00:28.595]             ...future.value <- base::withVisible(base::local({
[11:00:28.595]                 ...future.makeSendCondition <- base::local({
[11:00:28.595]                   sendCondition <- NULL
[11:00:28.595]                   function(frame = 1L) {
[11:00:28.595]                     if (is.function(sendCondition)) 
[11:00:28.595]                       return(sendCondition)
[11:00:28.595]                     ns <- getNamespace("parallel")
[11:00:28.595]                     if (exists("sendData", mode = "function", 
[11:00:28.595]                       envir = ns)) {
[11:00:28.595]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:28.595]                         envir = ns)
[11:00:28.595]                       envir <- sys.frame(frame)
[11:00:28.595]                       master <- NULL
[11:00:28.595]                       while (!identical(envir, .GlobalEnv) && 
[11:00:28.595]                         !identical(envir, emptyenv())) {
[11:00:28.595]                         if (exists("master", mode = "list", envir = envir, 
[11:00:28.595]                           inherits = FALSE)) {
[11:00:28.595]                           master <- get("master", mode = "list", 
[11:00:28.595]                             envir = envir, inherits = FALSE)
[11:00:28.595]                           if (inherits(master, c("SOCKnode", 
[11:00:28.595]                             "SOCK0node"))) {
[11:00:28.595]                             sendCondition <<- function(cond) {
[11:00:28.595]                               data <- list(type = "VALUE", value = cond, 
[11:00:28.595]                                 success = TRUE)
[11:00:28.595]                               parallel_sendData(master, data)
[11:00:28.595]                             }
[11:00:28.595]                             return(sendCondition)
[11:00:28.595]                           }
[11:00:28.595]                         }
[11:00:28.595]                         frame <- frame + 1L
[11:00:28.595]                         envir <- sys.frame(frame)
[11:00:28.595]                       }
[11:00:28.595]                     }
[11:00:28.595]                     sendCondition <<- function(cond) NULL
[11:00:28.595]                   }
[11:00:28.595]                 })
[11:00:28.595]                 withCallingHandlers({
[11:00:28.595]                   {
[11:00:28.595]                     do.call(function(...) {
[11:00:28.595]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:28.595]                       if (!identical(...future.globals.maxSize.org, 
[11:00:28.595]                         ...future.globals.maxSize)) {
[11:00:28.595]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:28.595]                         on.exit(options(oopts), add = TRUE)
[11:00:28.595]                       }
[11:00:28.595]                       {
[11:00:28.595]                         lapply(seq_along(...future.elements_ii), 
[11:00:28.595]                           FUN = function(jj) {
[11:00:28.595]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:28.595]                             ...future.FUN(...future.X_jj, ...)
[11:00:28.595]                           })
[11:00:28.595]                       }
[11:00:28.595]                     }, args = future.call.arguments)
[11:00:28.595]                   }
[11:00:28.595]                 }, immediateCondition = function(cond) {
[11:00:28.595]                   sendCondition <- ...future.makeSendCondition()
[11:00:28.595]                   sendCondition(cond)
[11:00:28.595]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:28.595]                   {
[11:00:28.595]                     inherits <- base::inherits
[11:00:28.595]                     invokeRestart <- base::invokeRestart
[11:00:28.595]                     is.null <- base::is.null
[11:00:28.595]                     muffled <- FALSE
[11:00:28.595]                     if (inherits(cond, "message")) {
[11:00:28.595]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:28.595]                       if (muffled) 
[11:00:28.595]                         invokeRestart("muffleMessage")
[11:00:28.595]                     }
[11:00:28.595]                     else if (inherits(cond, "warning")) {
[11:00:28.595]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:28.595]                       if (muffled) 
[11:00:28.595]                         invokeRestart("muffleWarning")
[11:00:28.595]                     }
[11:00:28.595]                     else if (inherits(cond, "condition")) {
[11:00:28.595]                       if (!is.null(pattern)) {
[11:00:28.595]                         computeRestarts <- base::computeRestarts
[11:00:28.595]                         grepl <- base::grepl
[11:00:28.595]                         restarts <- computeRestarts(cond)
[11:00:28.595]                         for (restart in restarts) {
[11:00:28.595]                           name <- restart$name
[11:00:28.595]                           if (is.null(name)) 
[11:00:28.595]                             next
[11:00:28.595]                           if (!grepl(pattern, name)) 
[11:00:28.595]                             next
[11:00:28.595]                           invokeRestart(restart)
[11:00:28.595]                           muffled <- TRUE
[11:00:28.595]                           break
[11:00:28.595]                         }
[11:00:28.595]                       }
[11:00:28.595]                     }
[11:00:28.595]                     invisible(muffled)
[11:00:28.595]                   }
[11:00:28.595]                   muffleCondition(cond)
[11:00:28.595]                 })
[11:00:28.595]             }))
[11:00:28.595]             future::FutureResult(value = ...future.value$value, 
[11:00:28.595]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:28.595]                   ...future.rng), globalenv = if (FALSE) 
[11:00:28.595]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:28.595]                     ...future.globalenv.names))
[11:00:28.595]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:28.595]         }, condition = base::local({
[11:00:28.595]             c <- base::c
[11:00:28.595]             inherits <- base::inherits
[11:00:28.595]             invokeRestart <- base::invokeRestart
[11:00:28.595]             length <- base::length
[11:00:28.595]             list <- base::list
[11:00:28.595]             seq.int <- base::seq.int
[11:00:28.595]             signalCondition <- base::signalCondition
[11:00:28.595]             sys.calls <- base::sys.calls
[11:00:28.595]             `[[` <- base::`[[`
[11:00:28.595]             `+` <- base::`+`
[11:00:28.595]             `<<-` <- base::`<<-`
[11:00:28.595]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:28.595]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:28.595]                   3L)]
[11:00:28.595]             }
[11:00:28.595]             function(cond) {
[11:00:28.595]                 is_error <- inherits(cond, "error")
[11:00:28.595]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:28.595]                   NULL)
[11:00:28.595]                 if (is_error) {
[11:00:28.595]                   sessionInformation <- function() {
[11:00:28.595]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:28.595]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:28.595]                       search = base::search(), system = base::Sys.info())
[11:00:28.595]                   }
[11:00:28.595]                   ...future.conditions[[length(...future.conditions) + 
[11:00:28.595]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:28.595]                     cond$call), session = sessionInformation(), 
[11:00:28.595]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:28.595]                   signalCondition(cond)
[11:00:28.595]                 }
[11:00:28.595]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:28.595]                 "immediateCondition"))) {
[11:00:28.595]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:28.595]                   ...future.conditions[[length(...future.conditions) + 
[11:00:28.595]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:28.595]                   if (TRUE && !signal) {
[11:00:28.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:28.595]                     {
[11:00:28.595]                       inherits <- base::inherits
[11:00:28.595]                       invokeRestart <- base::invokeRestart
[11:00:28.595]                       is.null <- base::is.null
[11:00:28.595]                       muffled <- FALSE
[11:00:28.595]                       if (inherits(cond, "message")) {
[11:00:28.595]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:28.595]                         if (muffled) 
[11:00:28.595]                           invokeRestart("muffleMessage")
[11:00:28.595]                       }
[11:00:28.595]                       else if (inherits(cond, "warning")) {
[11:00:28.595]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:28.595]                         if (muffled) 
[11:00:28.595]                           invokeRestart("muffleWarning")
[11:00:28.595]                       }
[11:00:28.595]                       else if (inherits(cond, "condition")) {
[11:00:28.595]                         if (!is.null(pattern)) {
[11:00:28.595]                           computeRestarts <- base::computeRestarts
[11:00:28.595]                           grepl <- base::grepl
[11:00:28.595]                           restarts <- computeRestarts(cond)
[11:00:28.595]                           for (restart in restarts) {
[11:00:28.595]                             name <- restart$name
[11:00:28.595]                             if (is.null(name)) 
[11:00:28.595]                               next
[11:00:28.595]                             if (!grepl(pattern, name)) 
[11:00:28.595]                               next
[11:00:28.595]                             invokeRestart(restart)
[11:00:28.595]                             muffled <- TRUE
[11:00:28.595]                             break
[11:00:28.595]                           }
[11:00:28.595]                         }
[11:00:28.595]                       }
[11:00:28.595]                       invisible(muffled)
[11:00:28.595]                     }
[11:00:28.595]                     muffleCondition(cond, pattern = "^muffle")
[11:00:28.595]                   }
[11:00:28.595]                 }
[11:00:28.595]                 else {
[11:00:28.595]                   if (TRUE) {
[11:00:28.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:28.595]                     {
[11:00:28.595]                       inherits <- base::inherits
[11:00:28.595]                       invokeRestart <- base::invokeRestart
[11:00:28.595]                       is.null <- base::is.null
[11:00:28.595]                       muffled <- FALSE
[11:00:28.595]                       if (inherits(cond, "message")) {
[11:00:28.595]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:28.595]                         if (muffled) 
[11:00:28.595]                           invokeRestart("muffleMessage")
[11:00:28.595]                       }
[11:00:28.595]                       else if (inherits(cond, "warning")) {
[11:00:28.595]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:28.595]                         if (muffled) 
[11:00:28.595]                           invokeRestart("muffleWarning")
[11:00:28.595]                       }
[11:00:28.595]                       else if (inherits(cond, "condition")) {
[11:00:28.595]                         if (!is.null(pattern)) {
[11:00:28.595]                           computeRestarts <- base::computeRestarts
[11:00:28.595]                           grepl <- base::grepl
[11:00:28.595]                           restarts <- computeRestarts(cond)
[11:00:28.595]                           for (restart in restarts) {
[11:00:28.595]                             name <- restart$name
[11:00:28.595]                             if (is.null(name)) 
[11:00:28.595]                               next
[11:00:28.595]                             if (!grepl(pattern, name)) 
[11:00:28.595]                               next
[11:00:28.595]                             invokeRestart(restart)
[11:00:28.595]                             muffled <- TRUE
[11:00:28.595]                             break
[11:00:28.595]                           }
[11:00:28.595]                         }
[11:00:28.595]                       }
[11:00:28.595]                       invisible(muffled)
[11:00:28.595]                     }
[11:00:28.595]                     muffleCondition(cond, pattern = "^muffle")
[11:00:28.595]                   }
[11:00:28.595]                 }
[11:00:28.595]             }
[11:00:28.595]         }))
[11:00:28.595]     }, error = function(ex) {
[11:00:28.595]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:28.595]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:28.595]                 ...future.rng), started = ...future.startTime, 
[11:00:28.595]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:28.595]             version = "1.8"), class = "FutureResult")
[11:00:28.595]     }, finally = {
[11:00:28.595]         if (!identical(...future.workdir, getwd())) 
[11:00:28.595]             setwd(...future.workdir)
[11:00:28.595]         {
[11:00:28.595]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:28.595]                 ...future.oldOptions$nwarnings <- NULL
[11:00:28.595]             }
[11:00:28.595]             base::options(...future.oldOptions)
[11:00:28.595]             if (.Platform$OS.type == "windows") {
[11:00:28.595]                 old_names <- names(...future.oldEnvVars)
[11:00:28.595]                 envs <- base::Sys.getenv()
[11:00:28.595]                 names <- names(envs)
[11:00:28.595]                 common <- intersect(names, old_names)
[11:00:28.595]                 added <- setdiff(names, old_names)
[11:00:28.595]                 removed <- setdiff(old_names, names)
[11:00:28.595]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:28.595]                   envs[common]]
[11:00:28.595]                 NAMES <- toupper(changed)
[11:00:28.595]                 args <- list()
[11:00:28.595]                 for (kk in seq_along(NAMES)) {
[11:00:28.595]                   name <- changed[[kk]]
[11:00:28.595]                   NAME <- NAMES[[kk]]
[11:00:28.595]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:28.595]                     next
[11:00:28.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:28.595]                 }
[11:00:28.595]                 NAMES <- toupper(added)
[11:00:28.595]                 for (kk in seq_along(NAMES)) {
[11:00:28.595]                   name <- added[[kk]]
[11:00:28.595]                   NAME <- NAMES[[kk]]
[11:00:28.595]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:28.595]                     next
[11:00:28.595]                   args[[name]] <- ""
[11:00:28.595]                 }
[11:00:28.595]                 NAMES <- toupper(removed)
[11:00:28.595]                 for (kk in seq_along(NAMES)) {
[11:00:28.595]                   name <- removed[[kk]]
[11:00:28.595]                   NAME <- NAMES[[kk]]
[11:00:28.595]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:28.595]                     next
[11:00:28.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:28.595]                 }
[11:00:28.595]                 if (length(args) > 0) 
[11:00:28.595]                   base::do.call(base::Sys.setenv, args = args)
[11:00:28.595]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:28.595]             }
[11:00:28.595]             else {
[11:00:28.595]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:28.595]             }
[11:00:28.595]             {
[11:00:28.595]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:28.595]                   0L) {
[11:00:28.595]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:28.595]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:28.595]                   base::options(opts)
[11:00:28.595]                 }
[11:00:28.595]                 {
[11:00:28.595]                   {
[11:00:28.595]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:28.595]                     NULL
[11:00:28.595]                   }
[11:00:28.595]                   options(future.plan = NULL)
[11:00:28.595]                   if (is.na(NA_character_)) 
[11:00:28.595]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:28.595]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:28.595]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:28.595]                     .init = FALSE)
[11:00:28.595]                 }
[11:00:28.595]             }
[11:00:28.595]         }
[11:00:28.595]     })
[11:00:28.595]     if (FALSE) {
[11:00:28.595]         base::sink(type = "output", split = FALSE)
[11:00:28.595]         if (NA) {
[11:00:28.595]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:28.595]         }
[11:00:28.595]         else {
[11:00:28.595]             ...future.result["stdout"] <- base::list(NULL)
[11:00:28.595]         }
[11:00:28.595]         base::close(...future.stdout)
[11:00:28.595]         ...future.stdout <- NULL
[11:00:28.595]     }
[11:00:28.595]     ...future.result$conditions <- ...future.conditions
[11:00:28.595]     ...future.result$finished <- base::Sys.time()
[11:00:28.595]     ...future.result
[11:00:28.595] }
[11:00:28.598] Exporting 5 global objects (1.46 KiB) to cluster node #2 ...
[11:00:28.598] Exporting ‘...future.FUN’ (841 bytes) to cluster node #2 ...
[11:00:28.598] Exporting ‘...future.FUN’ (841 bytes) to cluster node #2 ... DONE
[11:00:28.598] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[11:00:28.599] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[11:00:28.599] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ...
[11:00:28.599] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ... DONE
[11:00:28.599] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[11:00:28.600] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[11:00:28.600] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[11:00:28.600] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[11:00:28.600] Exporting 5 global objects (1.46 KiB) to cluster node #2 ... DONE
[11:00:28.601] MultisessionFuture started
[11:00:28.601] - Launch lazy future ... done
[11:00:28.601] run() for ‘MultisessionFuture’ ... done
[11:00:28.601] Created future:
[11:00:28.601] MultisessionFuture:
[11:00:28.601] Label: ‘future_lapply-2’
[11:00:28.601] Expression:
[11:00:28.601] {
[11:00:28.601]     do.call(function(...) {
[11:00:28.601]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:28.601]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:28.601]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:28.601]             on.exit(options(oopts), add = TRUE)
[11:00:28.601]         }
[11:00:28.601]         {
[11:00:28.601]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[11:00:28.601]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[11:00:28.601]                 ...future.FUN(...future.X_jj, ...)
[11:00:28.601]             })
[11:00:28.601]         }
[11:00:28.601]     }, args = future.call.arguments)
[11:00:28.601] }
[11:00:28.601] Lazy evaluation: FALSE
[11:00:28.601] Asynchronous evaluation: TRUE
[11:00:28.601] Local evaluation: TRUE
[11:00:28.601] Environment: R_GlobalEnv
[11:00:28.601] Capture standard output: NA
[11:00:28.601] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:28.601] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:28.601] Packages: <none>
[11:00:28.601] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:28.601] Resolved: FALSE
[11:00:28.601] Value: <not collected>
[11:00:28.601] Conditions captured: <none>
[11:00:28.601] Early signaling: FALSE
[11:00:28.601] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:28.601] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:28.613] Chunk #2 of 2 ... DONE
[11:00:28.613] Launching 2 futures (chunks) ... DONE
[11:00:28.613] Resolving 2 futures (chunks) ...
[11:00:28.613] resolve() on list ...
[11:00:28.613]  recursive: 0
[11:00:28.613]  length: 2
[11:00:28.613] 
[11:00:28.655] receiveMessageFromWorker() for ClusterFuture ...
[11:00:28.656] - Validating connection of MultisessionFuture
[11:00:28.656] - received message: FutureResult
[11:00:28.656] - Received FutureResult
[11:00:28.656] - Erased future from FutureRegistry
[11:00:28.656] result() for ClusterFuture ...
[11:00:28.656] - result already collected: FutureResult
[11:00:28.656] result() for ClusterFuture ... done
[11:00:28.656] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:28.656] Future #2
[11:00:28.656] result() for ClusterFuture ...
[11:00:28.656] - result already collected: FutureResult
[11:00:28.657] result() for ClusterFuture ... done
[11:00:28.657] result() for ClusterFuture ...
[11:00:28.657] - result already collected: FutureResult
[11:00:28.657] result() for ClusterFuture ... done
[11:00:28.657] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:00:28.657] - nx: 2
[11:00:28.657] - relay: TRUE
[11:00:28.657] - stdout: TRUE
[11:00:28.657] - signal: TRUE
[11:00:28.657] - resignal: FALSE
[11:00:28.657] - force: TRUE
[11:00:28.657] - relayed: [n=2] FALSE, FALSE
[11:00:28.658] - queued futures: [n=2] FALSE, FALSE
[11:00:28.658]  - until=1
[11:00:28.658]  - relaying element #1
[11:00:28.658] - relayed: [n=2] FALSE, FALSE
[11:00:28.658] - queued futures: [n=2] FALSE, TRUE
[11:00:28.658] signalConditionsASAP(NULL, pos=2) ... done
[11:00:28.658]  length: 1 (resolved future 2)
[11:00:29.104] receiveMessageFromWorker() for ClusterFuture ...
[11:00:29.104] - Validating connection of MultisessionFuture
[11:00:29.104] - received message: FutureResult
[11:00:29.104] - Received FutureResult
[11:00:29.104] - Erased future from FutureRegistry
[11:00:29.105] result() for ClusterFuture ...
[11:00:29.105] - result already collected: FutureResult
[11:00:29.105] result() for ClusterFuture ... done
[11:00:29.105] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:29.105] Future #1
[11:00:29.105] result() for ClusterFuture ...
[11:00:29.105] - result already collected: FutureResult
[11:00:29.105] result() for ClusterFuture ... done
[11:00:29.105] result() for ClusterFuture ...
[11:00:29.105] - result already collected: FutureResult
[11:00:29.105] result() for ClusterFuture ... done
[11:00:29.105] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:00:29.106] - nx: 2
[11:00:29.106] - relay: TRUE
[11:00:29.106] - stdout: TRUE
[11:00:29.106] - signal: TRUE
[11:00:29.106] - resignal: FALSE
[11:00:29.106] - force: TRUE
[11:00:29.106] - relayed: [n=2] FALSE, FALSE
[11:00:29.106] - queued futures: [n=2] FALSE, TRUE
[11:00:29.106]  - until=1
[11:00:29.106]  - relaying element #1
[11:00:29.106] result() for ClusterFuture ...
[11:00:29.106] - result already collected: FutureResult
[11:00:29.106] result() for ClusterFuture ... done
[11:00:29.107] result() for ClusterFuture ...
[11:00:29.107] - result already collected: FutureResult
[11:00:29.107] result() for ClusterFuture ... done
[11:00:29.107] result() for ClusterFuture ...
[11:00:29.107] - result already collected: FutureResult
[11:00:29.107] result() for ClusterFuture ... done
[11:00:29.107] result() for ClusterFuture ...
[11:00:29.107] - result already collected: FutureResult
[11:00:29.107] result() for ClusterFuture ... done
[11:00:29.107] - relayed: [n=2] TRUE, FALSE
[11:00:29.107] - queued futures: [n=2] TRUE, TRUE
[11:00:29.107] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:00:29.108]  length: 0 (resolved future 1)
[11:00:29.108] Relaying remaining futures
[11:00:29.108] signalConditionsASAP(NULL, pos=0) ...
[11:00:29.108] - nx: 2
[11:00:29.108] - relay: TRUE
[11:00:29.108] - stdout: TRUE
[11:00:29.108] - signal: TRUE
[11:00:29.108] - resignal: FALSE
[11:00:29.108] - force: TRUE
[11:00:29.108] - relayed: [n=2] TRUE, FALSE
[11:00:29.108] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:29.108]  - relaying element #2
[11:00:29.109] result() for ClusterFuture ...
[11:00:29.109] - result already collected: FutureResult
[11:00:29.109] result() for ClusterFuture ... done
[11:00:29.109] result() for ClusterFuture ...
[11:00:29.109] - result already collected: FutureResult
[11:00:29.109] result() for ClusterFuture ... done
[11:00:29.109] result() for ClusterFuture ...
[11:00:29.109] - result already collected: FutureResult
[11:00:29.109] result() for ClusterFuture ... done
[11:00:29.109] result() for ClusterFuture ...
[11:00:29.109] - result already collected: FutureResult
[11:00:29.109] result() for ClusterFuture ... done
[11:00:29.110] - relayed: [n=2] TRUE, TRUE
[11:00:29.110] - queued futures: [n=2] TRUE, TRUE
[11:00:29.110] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[11:00:29.110] resolve() on list ... DONE
[11:00:29.110] result() for ClusterFuture ...
[11:00:29.110] - result already collected: FutureResult
[11:00:29.110] result() for ClusterFuture ... done
[11:00:29.110] result() for ClusterFuture ...
[11:00:29.110] - result already collected: FutureResult
[11:00:29.110] result() for ClusterFuture ... done
[11:00:29.110] result() for ClusterFuture ...
[11:00:29.110] - result already collected: FutureResult
[11:00:29.110] result() for ClusterFuture ... done
[11:00:29.111] result() for ClusterFuture ...
[11:00:29.111] - result already collected: FutureResult
[11:00:29.111] result() for ClusterFuture ... done
[11:00:29.111]  - Number of value chunks collected: 2
[11:00:29.111] Resolving 2 futures (chunks) ... DONE
[11:00:29.111] Reducing values from 2 chunks ...
[11:00:29.111]  - Number of values collected after concatenation: 2
[11:00:29.111]  - Number of values expected: 2
[11:00:29.111] Reducing values from 2 chunks ... DONE
[11:00:29.111] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[11:00:29.112] future_mapply() ...
[11:00:29.113] Number of chunks: 2
[11:00:29.113] getGlobalsAndPackagesXApply() ...
[11:00:29.113]  - future.globals: TRUE
[11:00:29.114] getGlobalsAndPackages() ...
[11:00:29.114] Searching for globals...
[11:00:29.115] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[11:00:29.115] Searching for globals ... DONE
[11:00:29.115] Resolving globals: FALSE
[11:00:29.116] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[11:00:29.116] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[11:00:29.116] - globals: [1] ‘FUN’
[11:00:29.116] 
[11:00:29.116] getGlobalsAndPackages() ... DONE
[11:00:29.116]  - globals found/used: [n=1] ‘FUN’
[11:00:29.117]  - needed namespaces: [n=0] 
[11:00:29.117] Finding globals ... DONE
[11:00:29.117] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[11:00:29.117] List of 2
[11:00:29.117]  $ ...future.FUN:function (x, y)  
[11:00:29.117]  $ MoreArgs     : NULL
[11:00:29.117]  - attr(*, "where")=List of 2
[11:00:29.117]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:29.117]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[11:00:29.117]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:29.117]  - attr(*, "resolved")= logi FALSE
[11:00:29.117]  - attr(*, "total_size")= num NA
[11:00:29.119] Packages to be attached in all futures: [n=0] 
[11:00:29.119] getGlobalsAndPackagesXApply() ... DONE
[11:00:29.120] Number of futures (= number of chunks): 2
[11:00:29.120] Launching 2 futures (chunks) ...
[11:00:29.120] Chunk #1 of 2 ...
[11:00:29.120]  - Finding globals in '...' for chunk #1 ...
[11:00:29.120] getGlobalsAndPackages() ...
[11:00:29.120] Searching for globals...
[11:00:29.120] 
[11:00:29.120] Searching for globals ... DONE
[11:00:29.121] - globals: [0] <none>
[11:00:29.121] getGlobalsAndPackages() ... DONE
[11:00:29.121]    + additional globals found: [n=0] 
[11:00:29.121]    + additional namespaces needed: [n=0] 
[11:00:29.121]  - Finding globals in '...' for chunk #1 ... DONE
[11:00:29.121]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:29.121]  - seeds: <none>
[11:00:29.121]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:29.121] getGlobalsAndPackages() ...
[11:00:29.121] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:29.121] Resolving globals: FALSE
[11:00:29.122] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[11:00:29.122] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[11:00:29.122] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:29.122] 
[11:00:29.122] getGlobalsAndPackages() ... DONE
[11:00:29.123] run() for ‘Future’ ...
[11:00:29.123] - state: ‘created’
[11:00:29.123] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:29.137] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:29.137] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:29.137]   - Field: ‘node’
[11:00:29.137]   - Field: ‘label’
[11:00:29.137]   - Field: ‘local’
[11:00:29.137]   - Field: ‘owner’
[11:00:29.137]   - Field: ‘envir’
[11:00:29.137]   - Field: ‘workers’
[11:00:29.137]   - Field: ‘packages’
[11:00:29.137]   - Field: ‘gc’
[11:00:29.138]   - Field: ‘conditions’
[11:00:29.138]   - Field: ‘persistent’
[11:00:29.138]   - Field: ‘expr’
[11:00:29.138]   - Field: ‘uuid’
[11:00:29.138]   - Field: ‘seed’
[11:00:29.138]   - Field: ‘version’
[11:00:29.138]   - Field: ‘result’
[11:00:29.138]   - Field: ‘asynchronous’
[11:00:29.138]   - Field: ‘calls’
[11:00:29.138]   - Field: ‘globals’
[11:00:29.138]   - Field: ‘stdout’
[11:00:29.138]   - Field: ‘earlySignal’
[11:00:29.139]   - Field: ‘lazy’
[11:00:29.139]   - Field: ‘state’
[11:00:29.139] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:29.139] - Launch lazy future ...
[11:00:29.139] Packages needed by the future expression (n = 0): <none>
[11:00:29.139] Packages needed by future strategies (n = 0): <none>
[11:00:29.140] {
[11:00:29.140]     {
[11:00:29.140]         {
[11:00:29.140]             ...future.startTime <- base::Sys.time()
[11:00:29.140]             {
[11:00:29.140]                 {
[11:00:29.140]                   {
[11:00:29.140]                     {
[11:00:29.140]                       base::local({
[11:00:29.140]                         has_future <- base::requireNamespace("future", 
[11:00:29.140]                           quietly = TRUE)
[11:00:29.140]                         if (has_future) {
[11:00:29.140]                           ns <- base::getNamespace("future")
[11:00:29.140]                           version <- ns[[".package"]][["version"]]
[11:00:29.140]                           if (is.null(version)) 
[11:00:29.140]                             version <- utils::packageVersion("future")
[11:00:29.140]                         }
[11:00:29.140]                         else {
[11:00:29.140]                           version <- NULL
[11:00:29.140]                         }
[11:00:29.140]                         if (!has_future || version < "1.8.0") {
[11:00:29.140]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:29.140]                             "", base::R.version$version.string), 
[11:00:29.140]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:29.140]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:29.140]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:29.140]                               "release", "version")], collapse = " "), 
[11:00:29.140]                             hostname = base::Sys.info()[["nodename"]])
[11:00:29.140]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:29.140]                             info)
[11:00:29.140]                           info <- base::paste(info, collapse = "; ")
[11:00:29.140]                           if (!has_future) {
[11:00:29.140]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:29.140]                               info)
[11:00:29.140]                           }
[11:00:29.140]                           else {
[11:00:29.140]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:29.140]                               info, version)
[11:00:29.140]                           }
[11:00:29.140]                           base::stop(msg)
[11:00:29.140]                         }
[11:00:29.140]                       })
[11:00:29.140]                     }
[11:00:29.140]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:29.140]                     base::options(mc.cores = 1L)
[11:00:29.140]                   }
[11:00:29.140]                   ...future.strategy.old <- future::plan("list")
[11:00:29.140]                   options(future.plan = NULL)
[11:00:29.140]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:29.140]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:29.140]                 }
[11:00:29.140]                 ...future.workdir <- getwd()
[11:00:29.140]             }
[11:00:29.140]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:29.140]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:29.140]         }
[11:00:29.140]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:29.140]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:29.140]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:29.140]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:29.140]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:29.140]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:29.140]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:29.140]             base::names(...future.oldOptions))
[11:00:29.140]     }
[11:00:29.140]     if (FALSE) {
[11:00:29.140]     }
[11:00:29.140]     else {
[11:00:29.140]         if (FALSE) {
[11:00:29.140]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:29.140]                 open = "w")
[11:00:29.140]         }
[11:00:29.140]         else {
[11:00:29.140]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:29.140]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:29.140]         }
[11:00:29.140]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:29.140]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:29.140]             base::sink(type = "output", split = FALSE)
[11:00:29.140]             base::close(...future.stdout)
[11:00:29.140]         }, add = TRUE)
[11:00:29.140]     }
[11:00:29.140]     ...future.frame <- base::sys.nframe()
[11:00:29.140]     ...future.conditions <- base::list()
[11:00:29.140]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:29.140]     if (FALSE) {
[11:00:29.140]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:29.140]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:29.140]     }
[11:00:29.140]     ...future.result <- base::tryCatch({
[11:00:29.140]         base::withCallingHandlers({
[11:00:29.140]             ...future.value <- base::withVisible(base::local({
[11:00:29.140]                 ...future.makeSendCondition <- base::local({
[11:00:29.140]                   sendCondition <- NULL
[11:00:29.140]                   function(frame = 1L) {
[11:00:29.140]                     if (is.function(sendCondition)) 
[11:00:29.140]                       return(sendCondition)
[11:00:29.140]                     ns <- getNamespace("parallel")
[11:00:29.140]                     if (exists("sendData", mode = "function", 
[11:00:29.140]                       envir = ns)) {
[11:00:29.140]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:29.140]                         envir = ns)
[11:00:29.140]                       envir <- sys.frame(frame)
[11:00:29.140]                       master <- NULL
[11:00:29.140]                       while (!identical(envir, .GlobalEnv) && 
[11:00:29.140]                         !identical(envir, emptyenv())) {
[11:00:29.140]                         if (exists("master", mode = "list", envir = envir, 
[11:00:29.140]                           inherits = FALSE)) {
[11:00:29.140]                           master <- get("master", mode = "list", 
[11:00:29.140]                             envir = envir, inherits = FALSE)
[11:00:29.140]                           if (inherits(master, c("SOCKnode", 
[11:00:29.140]                             "SOCK0node"))) {
[11:00:29.140]                             sendCondition <<- function(cond) {
[11:00:29.140]                               data <- list(type = "VALUE", value = cond, 
[11:00:29.140]                                 success = TRUE)
[11:00:29.140]                               parallel_sendData(master, data)
[11:00:29.140]                             }
[11:00:29.140]                             return(sendCondition)
[11:00:29.140]                           }
[11:00:29.140]                         }
[11:00:29.140]                         frame <- frame + 1L
[11:00:29.140]                         envir <- sys.frame(frame)
[11:00:29.140]                       }
[11:00:29.140]                     }
[11:00:29.140]                     sendCondition <<- function(cond) NULL
[11:00:29.140]                   }
[11:00:29.140]                 })
[11:00:29.140]                 withCallingHandlers({
[11:00:29.140]                   {
[11:00:29.140]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:29.140]                     if (!identical(...future.globals.maxSize.org, 
[11:00:29.140]                       ...future.globals.maxSize)) {
[11:00:29.140]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:29.140]                       on.exit(options(oopts), add = TRUE)
[11:00:29.140]                     }
[11:00:29.140]                     {
[11:00:29.140]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:29.140]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:00:29.140]                         USE.NAMES = FALSE)
[11:00:29.140]                       do.call(mapply, args = args)
[11:00:29.140]                     }
[11:00:29.140]                   }
[11:00:29.140]                 }, immediateCondition = function(cond) {
[11:00:29.140]                   sendCondition <- ...future.makeSendCondition()
[11:00:29.140]                   sendCondition(cond)
[11:00:29.140]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:29.140]                   {
[11:00:29.140]                     inherits <- base::inherits
[11:00:29.140]                     invokeRestart <- base::invokeRestart
[11:00:29.140]                     is.null <- base::is.null
[11:00:29.140]                     muffled <- FALSE
[11:00:29.140]                     if (inherits(cond, "message")) {
[11:00:29.140]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:29.140]                       if (muffled) 
[11:00:29.140]                         invokeRestart("muffleMessage")
[11:00:29.140]                     }
[11:00:29.140]                     else if (inherits(cond, "warning")) {
[11:00:29.140]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:29.140]                       if (muffled) 
[11:00:29.140]                         invokeRestart("muffleWarning")
[11:00:29.140]                     }
[11:00:29.140]                     else if (inherits(cond, "condition")) {
[11:00:29.140]                       if (!is.null(pattern)) {
[11:00:29.140]                         computeRestarts <- base::computeRestarts
[11:00:29.140]                         grepl <- base::grepl
[11:00:29.140]                         restarts <- computeRestarts(cond)
[11:00:29.140]                         for (restart in restarts) {
[11:00:29.140]                           name <- restart$name
[11:00:29.140]                           if (is.null(name)) 
[11:00:29.140]                             next
[11:00:29.140]                           if (!grepl(pattern, name)) 
[11:00:29.140]                             next
[11:00:29.140]                           invokeRestart(restart)
[11:00:29.140]                           muffled <- TRUE
[11:00:29.140]                           break
[11:00:29.140]                         }
[11:00:29.140]                       }
[11:00:29.140]                     }
[11:00:29.140]                     invisible(muffled)
[11:00:29.140]                   }
[11:00:29.140]                   muffleCondition(cond)
[11:00:29.140]                 })
[11:00:29.140]             }))
[11:00:29.140]             future::FutureResult(value = ...future.value$value, 
[11:00:29.140]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:29.140]                   ...future.rng), globalenv = if (FALSE) 
[11:00:29.140]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:29.140]                     ...future.globalenv.names))
[11:00:29.140]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:29.140]         }, condition = base::local({
[11:00:29.140]             c <- base::c
[11:00:29.140]             inherits <- base::inherits
[11:00:29.140]             invokeRestart <- base::invokeRestart
[11:00:29.140]             length <- base::length
[11:00:29.140]             list <- base::list
[11:00:29.140]             seq.int <- base::seq.int
[11:00:29.140]             signalCondition <- base::signalCondition
[11:00:29.140]             sys.calls <- base::sys.calls
[11:00:29.140]             `[[` <- base::`[[`
[11:00:29.140]             `+` <- base::`+`
[11:00:29.140]             `<<-` <- base::`<<-`
[11:00:29.140]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:29.140]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:29.140]                   3L)]
[11:00:29.140]             }
[11:00:29.140]             function(cond) {
[11:00:29.140]                 is_error <- inherits(cond, "error")
[11:00:29.140]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:29.140]                   NULL)
[11:00:29.140]                 if (is_error) {
[11:00:29.140]                   sessionInformation <- function() {
[11:00:29.140]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:29.140]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:29.140]                       search = base::search(), system = base::Sys.info())
[11:00:29.140]                   }
[11:00:29.140]                   ...future.conditions[[length(...future.conditions) + 
[11:00:29.140]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:29.140]                     cond$call), session = sessionInformation(), 
[11:00:29.140]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:29.140]                   signalCondition(cond)
[11:00:29.140]                 }
[11:00:29.140]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:29.140]                 "immediateCondition"))) {
[11:00:29.140]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:29.140]                   ...future.conditions[[length(...future.conditions) + 
[11:00:29.140]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:29.140]                   if (TRUE && !signal) {
[11:00:29.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:29.140]                     {
[11:00:29.140]                       inherits <- base::inherits
[11:00:29.140]                       invokeRestart <- base::invokeRestart
[11:00:29.140]                       is.null <- base::is.null
[11:00:29.140]                       muffled <- FALSE
[11:00:29.140]                       if (inherits(cond, "message")) {
[11:00:29.140]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:29.140]                         if (muffled) 
[11:00:29.140]                           invokeRestart("muffleMessage")
[11:00:29.140]                       }
[11:00:29.140]                       else if (inherits(cond, "warning")) {
[11:00:29.140]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:29.140]                         if (muffled) 
[11:00:29.140]                           invokeRestart("muffleWarning")
[11:00:29.140]                       }
[11:00:29.140]                       else if (inherits(cond, "condition")) {
[11:00:29.140]                         if (!is.null(pattern)) {
[11:00:29.140]                           computeRestarts <- base::computeRestarts
[11:00:29.140]                           grepl <- base::grepl
[11:00:29.140]                           restarts <- computeRestarts(cond)
[11:00:29.140]                           for (restart in restarts) {
[11:00:29.140]                             name <- restart$name
[11:00:29.140]                             if (is.null(name)) 
[11:00:29.140]                               next
[11:00:29.140]                             if (!grepl(pattern, name)) 
[11:00:29.140]                               next
[11:00:29.140]                             invokeRestart(restart)
[11:00:29.140]                             muffled <- TRUE
[11:00:29.140]                             break
[11:00:29.140]                           }
[11:00:29.140]                         }
[11:00:29.140]                       }
[11:00:29.140]                       invisible(muffled)
[11:00:29.140]                     }
[11:00:29.140]                     muffleCondition(cond, pattern = "^muffle")
[11:00:29.140]                   }
[11:00:29.140]                 }
[11:00:29.140]                 else {
[11:00:29.140]                   if (TRUE) {
[11:00:29.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:29.140]                     {
[11:00:29.140]                       inherits <- base::inherits
[11:00:29.140]                       invokeRestart <- base::invokeRestart
[11:00:29.140]                       is.null <- base::is.null
[11:00:29.140]                       muffled <- FALSE
[11:00:29.140]                       if (inherits(cond, "message")) {
[11:00:29.140]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:29.140]                         if (muffled) 
[11:00:29.140]                           invokeRestart("muffleMessage")
[11:00:29.140]                       }
[11:00:29.140]                       else if (inherits(cond, "warning")) {
[11:00:29.140]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:29.140]                         if (muffled) 
[11:00:29.140]                           invokeRestart("muffleWarning")
[11:00:29.140]                       }
[11:00:29.140]                       else if (inherits(cond, "condition")) {
[11:00:29.140]                         if (!is.null(pattern)) {
[11:00:29.140]                           computeRestarts <- base::computeRestarts
[11:00:29.140]                           grepl <- base::grepl
[11:00:29.140]                           restarts <- computeRestarts(cond)
[11:00:29.140]                           for (restart in restarts) {
[11:00:29.140]                             name <- restart$name
[11:00:29.140]                             if (is.null(name)) 
[11:00:29.140]                               next
[11:00:29.140]                             if (!grepl(pattern, name)) 
[11:00:29.140]                               next
[11:00:29.140]                             invokeRestart(restart)
[11:00:29.140]                             muffled <- TRUE
[11:00:29.140]                             break
[11:00:29.140]                           }
[11:00:29.140]                         }
[11:00:29.140]                       }
[11:00:29.140]                       invisible(muffled)
[11:00:29.140]                     }
[11:00:29.140]                     muffleCondition(cond, pattern = "^muffle")
[11:00:29.140]                   }
[11:00:29.140]                 }
[11:00:29.140]             }
[11:00:29.140]         }))
[11:00:29.140]     }, error = function(ex) {
[11:00:29.140]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:29.140]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:29.140]                 ...future.rng), started = ...future.startTime, 
[11:00:29.140]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:29.140]             version = "1.8"), class = "FutureResult")
[11:00:29.140]     }, finally = {
[11:00:29.140]         if (!identical(...future.workdir, getwd())) 
[11:00:29.140]             setwd(...future.workdir)
[11:00:29.140]         {
[11:00:29.140]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:29.140]                 ...future.oldOptions$nwarnings <- NULL
[11:00:29.140]             }
[11:00:29.140]             base::options(...future.oldOptions)
[11:00:29.140]             if (.Platform$OS.type == "windows") {
[11:00:29.140]                 old_names <- names(...future.oldEnvVars)
[11:00:29.140]                 envs <- base::Sys.getenv()
[11:00:29.140]                 names <- names(envs)
[11:00:29.140]                 common <- intersect(names, old_names)
[11:00:29.140]                 added <- setdiff(names, old_names)
[11:00:29.140]                 removed <- setdiff(old_names, names)
[11:00:29.140]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:29.140]                   envs[common]]
[11:00:29.140]                 NAMES <- toupper(changed)
[11:00:29.140]                 args <- list()
[11:00:29.140]                 for (kk in seq_along(NAMES)) {
[11:00:29.140]                   name <- changed[[kk]]
[11:00:29.140]                   NAME <- NAMES[[kk]]
[11:00:29.140]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:29.140]                     next
[11:00:29.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:29.140]                 }
[11:00:29.140]                 NAMES <- toupper(added)
[11:00:29.140]                 for (kk in seq_along(NAMES)) {
[11:00:29.140]                   name <- added[[kk]]
[11:00:29.140]                   NAME <- NAMES[[kk]]
[11:00:29.140]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:29.140]                     next
[11:00:29.140]                   args[[name]] <- ""
[11:00:29.140]                 }
[11:00:29.140]                 NAMES <- toupper(removed)
[11:00:29.140]                 for (kk in seq_along(NAMES)) {
[11:00:29.140]                   name <- removed[[kk]]
[11:00:29.140]                   NAME <- NAMES[[kk]]
[11:00:29.140]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:29.140]                     next
[11:00:29.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:29.140]                 }
[11:00:29.140]                 if (length(args) > 0) 
[11:00:29.140]                   base::do.call(base::Sys.setenv, args = args)
[11:00:29.140]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:29.140]             }
[11:00:29.140]             else {
[11:00:29.140]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:29.140]             }
[11:00:29.140]             {
[11:00:29.140]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:29.140]                   0L) {
[11:00:29.140]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:29.140]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:29.140]                   base::options(opts)
[11:00:29.140]                 }
[11:00:29.140]                 {
[11:00:29.140]                   {
[11:00:29.140]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:29.140]                     NULL
[11:00:29.140]                   }
[11:00:29.140]                   options(future.plan = NULL)
[11:00:29.140]                   if (is.na(NA_character_)) 
[11:00:29.140]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:29.140]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:29.140]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:29.140]                     .init = FALSE)
[11:00:29.140]                 }
[11:00:29.140]             }
[11:00:29.140]         }
[11:00:29.140]     })
[11:00:29.140]     if (TRUE) {
[11:00:29.140]         base::sink(type = "output", split = FALSE)
[11:00:29.140]         if (FALSE) {
[11:00:29.140]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:29.140]         }
[11:00:29.140]         else {
[11:00:29.140]             ...future.result["stdout"] <- base::list(NULL)
[11:00:29.140]         }
[11:00:29.140]         base::close(...future.stdout)
[11:00:29.140]         ...future.stdout <- NULL
[11:00:29.140]     }
[11:00:29.140]     ...future.result$conditions <- ...future.conditions
[11:00:29.140]     ...future.result$finished <- base::Sys.time()
[11:00:29.140]     ...future.result
[11:00:29.140] }
[11:00:29.142] Exporting 5 global objects (1.63 KiB) to cluster node #1 ...
[11:00:29.142] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[11:00:29.143] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[11:00:29.143] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[11:00:29.143] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[11:00:29.143] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ...
[11:00:29.144] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ... DONE
[11:00:29.144] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[11:00:29.144] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[11:00:29.144] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[11:00:29.145] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[11:00:29.145] Exporting 5 global objects (1.63 KiB) to cluster node #1 ... DONE
[11:00:29.145] MultisessionFuture started
[11:00:29.145] - Launch lazy future ... done
[11:00:29.145] run() for ‘MultisessionFuture’ ... done
[11:00:29.146] Created future:
[11:00:29.146] MultisessionFuture:
[11:00:29.146] Label: ‘future_mapply-1’
[11:00:29.146] Expression:
[11:00:29.146] {
[11:00:29.146]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:29.146]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:29.146]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:29.146]         on.exit(options(oopts), add = TRUE)
[11:00:29.146]     }
[11:00:29.146]     {
[11:00:29.146]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:29.146]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:00:29.146]         do.call(mapply, args = args)
[11:00:29.146]     }
[11:00:29.146] }
[11:00:29.146] Lazy evaluation: FALSE
[11:00:29.146] Asynchronous evaluation: TRUE
[11:00:29.146] Local evaluation: TRUE
[11:00:29.146] Environment: R_GlobalEnv
[11:00:29.146] Capture standard output: FALSE
[11:00:29.146] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:29.146] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:29.146] Packages: <none>
[11:00:29.146] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:29.146] Resolved: FALSE
[11:00:29.146] Value: <not collected>
[11:00:29.146] Conditions captured: <none>
[11:00:29.146] Early signaling: FALSE
[11:00:29.146] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:29.146] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:29.157] Chunk #1 of 2 ... DONE
[11:00:29.157] Chunk #2 of 2 ...
[11:00:29.157]  - Finding globals in '...' for chunk #2 ...
[11:00:29.157] getGlobalsAndPackages() ...
[11:00:29.157] Searching for globals...
[11:00:29.158] 
[11:00:29.158] Searching for globals ... DONE
[11:00:29.158] - globals: [0] <none>
[11:00:29.158] getGlobalsAndPackages() ... DONE
[11:00:29.158]    + additional globals found: [n=0] 
[11:00:29.158]    + additional namespaces needed: [n=0] 
[11:00:29.158]  - Finding globals in '...' for chunk #2 ... DONE
[11:00:29.158]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:29.158]  - seeds: <none>
[11:00:29.158]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:29.159] getGlobalsAndPackages() ...
[11:00:29.159] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:29.159] Resolving globals: FALSE
[11:00:29.159] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[11:00:29.160] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[11:00:29.160] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:29.160] 
[11:00:29.160] getGlobalsAndPackages() ... DONE
[11:00:29.160] run() for ‘Future’ ...
[11:00:29.160] - state: ‘created’
[11:00:29.160] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:29.174] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:29.174] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:29.174]   - Field: ‘node’
[11:00:29.174]   - Field: ‘label’
[11:00:29.174]   - Field: ‘local’
[11:00:29.175]   - Field: ‘owner’
[11:00:29.175]   - Field: ‘envir’
[11:00:29.175]   - Field: ‘workers’
[11:00:29.175]   - Field: ‘packages’
[11:00:29.175]   - Field: ‘gc’
[11:00:29.175]   - Field: ‘conditions’
[11:00:29.175]   - Field: ‘persistent’
[11:00:29.175]   - Field: ‘expr’
[11:00:29.175]   - Field: ‘uuid’
[11:00:29.175]   - Field: ‘seed’
[11:00:29.175]   - Field: ‘version’
[11:00:29.175]   - Field: ‘result’
[11:00:29.176]   - Field: ‘asynchronous’
[11:00:29.176]   - Field: ‘calls’
[11:00:29.176]   - Field: ‘globals’
[11:00:29.176]   - Field: ‘stdout’
[11:00:29.176]   - Field: ‘earlySignal’
[11:00:29.176]   - Field: ‘lazy’
[11:00:29.176]   - Field: ‘state’
[11:00:29.176] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:29.176] - Launch lazy future ...
[11:00:29.176] Packages needed by the future expression (n = 0): <none>
[11:00:29.177] Packages needed by future strategies (n = 0): <none>
[11:00:29.177] {
[11:00:29.177]     {
[11:00:29.177]         {
[11:00:29.177]             ...future.startTime <- base::Sys.time()
[11:00:29.177]             {
[11:00:29.177]                 {
[11:00:29.177]                   {
[11:00:29.177]                     {
[11:00:29.177]                       base::local({
[11:00:29.177]                         has_future <- base::requireNamespace("future", 
[11:00:29.177]                           quietly = TRUE)
[11:00:29.177]                         if (has_future) {
[11:00:29.177]                           ns <- base::getNamespace("future")
[11:00:29.177]                           version <- ns[[".package"]][["version"]]
[11:00:29.177]                           if (is.null(version)) 
[11:00:29.177]                             version <- utils::packageVersion("future")
[11:00:29.177]                         }
[11:00:29.177]                         else {
[11:00:29.177]                           version <- NULL
[11:00:29.177]                         }
[11:00:29.177]                         if (!has_future || version < "1.8.0") {
[11:00:29.177]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:29.177]                             "", base::R.version$version.string), 
[11:00:29.177]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:29.177]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:29.177]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:29.177]                               "release", "version")], collapse = " "), 
[11:00:29.177]                             hostname = base::Sys.info()[["nodename"]])
[11:00:29.177]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:29.177]                             info)
[11:00:29.177]                           info <- base::paste(info, collapse = "; ")
[11:00:29.177]                           if (!has_future) {
[11:00:29.177]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:29.177]                               info)
[11:00:29.177]                           }
[11:00:29.177]                           else {
[11:00:29.177]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:29.177]                               info, version)
[11:00:29.177]                           }
[11:00:29.177]                           base::stop(msg)
[11:00:29.177]                         }
[11:00:29.177]                       })
[11:00:29.177]                     }
[11:00:29.177]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:29.177]                     base::options(mc.cores = 1L)
[11:00:29.177]                   }
[11:00:29.177]                   ...future.strategy.old <- future::plan("list")
[11:00:29.177]                   options(future.plan = NULL)
[11:00:29.177]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:29.177]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:29.177]                 }
[11:00:29.177]                 ...future.workdir <- getwd()
[11:00:29.177]             }
[11:00:29.177]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:29.177]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:29.177]         }
[11:00:29.177]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:29.177]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:29.177]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:29.177]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:29.177]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:29.177]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:29.177]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:29.177]             base::names(...future.oldOptions))
[11:00:29.177]     }
[11:00:29.177]     if (FALSE) {
[11:00:29.177]     }
[11:00:29.177]     else {
[11:00:29.177]         if (FALSE) {
[11:00:29.177]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:29.177]                 open = "w")
[11:00:29.177]         }
[11:00:29.177]         else {
[11:00:29.177]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:29.177]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:29.177]         }
[11:00:29.177]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:29.177]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:29.177]             base::sink(type = "output", split = FALSE)
[11:00:29.177]             base::close(...future.stdout)
[11:00:29.177]         }, add = TRUE)
[11:00:29.177]     }
[11:00:29.177]     ...future.frame <- base::sys.nframe()
[11:00:29.177]     ...future.conditions <- base::list()
[11:00:29.177]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:29.177]     if (FALSE) {
[11:00:29.177]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:29.177]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:29.177]     }
[11:00:29.177]     ...future.result <- base::tryCatch({
[11:00:29.177]         base::withCallingHandlers({
[11:00:29.177]             ...future.value <- base::withVisible(base::local({
[11:00:29.177]                 ...future.makeSendCondition <- base::local({
[11:00:29.177]                   sendCondition <- NULL
[11:00:29.177]                   function(frame = 1L) {
[11:00:29.177]                     if (is.function(sendCondition)) 
[11:00:29.177]                       return(sendCondition)
[11:00:29.177]                     ns <- getNamespace("parallel")
[11:00:29.177]                     if (exists("sendData", mode = "function", 
[11:00:29.177]                       envir = ns)) {
[11:00:29.177]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:29.177]                         envir = ns)
[11:00:29.177]                       envir <- sys.frame(frame)
[11:00:29.177]                       master <- NULL
[11:00:29.177]                       while (!identical(envir, .GlobalEnv) && 
[11:00:29.177]                         !identical(envir, emptyenv())) {
[11:00:29.177]                         if (exists("master", mode = "list", envir = envir, 
[11:00:29.177]                           inherits = FALSE)) {
[11:00:29.177]                           master <- get("master", mode = "list", 
[11:00:29.177]                             envir = envir, inherits = FALSE)
[11:00:29.177]                           if (inherits(master, c("SOCKnode", 
[11:00:29.177]                             "SOCK0node"))) {
[11:00:29.177]                             sendCondition <<- function(cond) {
[11:00:29.177]                               data <- list(type = "VALUE", value = cond, 
[11:00:29.177]                                 success = TRUE)
[11:00:29.177]                               parallel_sendData(master, data)
[11:00:29.177]                             }
[11:00:29.177]                             return(sendCondition)
[11:00:29.177]                           }
[11:00:29.177]                         }
[11:00:29.177]                         frame <- frame + 1L
[11:00:29.177]                         envir <- sys.frame(frame)
[11:00:29.177]                       }
[11:00:29.177]                     }
[11:00:29.177]                     sendCondition <<- function(cond) NULL
[11:00:29.177]                   }
[11:00:29.177]                 })
[11:00:29.177]                 withCallingHandlers({
[11:00:29.177]                   {
[11:00:29.177]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:29.177]                     if (!identical(...future.globals.maxSize.org, 
[11:00:29.177]                       ...future.globals.maxSize)) {
[11:00:29.177]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:29.177]                       on.exit(options(oopts), add = TRUE)
[11:00:29.177]                     }
[11:00:29.177]                     {
[11:00:29.177]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:29.177]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:00:29.177]                         USE.NAMES = FALSE)
[11:00:29.177]                       do.call(mapply, args = args)
[11:00:29.177]                     }
[11:00:29.177]                   }
[11:00:29.177]                 }, immediateCondition = function(cond) {
[11:00:29.177]                   sendCondition <- ...future.makeSendCondition()
[11:00:29.177]                   sendCondition(cond)
[11:00:29.177]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:29.177]                   {
[11:00:29.177]                     inherits <- base::inherits
[11:00:29.177]                     invokeRestart <- base::invokeRestart
[11:00:29.177]                     is.null <- base::is.null
[11:00:29.177]                     muffled <- FALSE
[11:00:29.177]                     if (inherits(cond, "message")) {
[11:00:29.177]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:29.177]                       if (muffled) 
[11:00:29.177]                         invokeRestart("muffleMessage")
[11:00:29.177]                     }
[11:00:29.177]                     else if (inherits(cond, "warning")) {
[11:00:29.177]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:29.177]                       if (muffled) 
[11:00:29.177]                         invokeRestart("muffleWarning")
[11:00:29.177]                     }
[11:00:29.177]                     else if (inherits(cond, "condition")) {
[11:00:29.177]                       if (!is.null(pattern)) {
[11:00:29.177]                         computeRestarts <- base::computeRestarts
[11:00:29.177]                         grepl <- base::grepl
[11:00:29.177]                         restarts <- computeRestarts(cond)
[11:00:29.177]                         for (restart in restarts) {
[11:00:29.177]                           name <- restart$name
[11:00:29.177]                           if (is.null(name)) 
[11:00:29.177]                             next
[11:00:29.177]                           if (!grepl(pattern, name)) 
[11:00:29.177]                             next
[11:00:29.177]                           invokeRestart(restart)
[11:00:29.177]                           muffled <- TRUE
[11:00:29.177]                           break
[11:00:29.177]                         }
[11:00:29.177]                       }
[11:00:29.177]                     }
[11:00:29.177]                     invisible(muffled)
[11:00:29.177]                   }
[11:00:29.177]                   muffleCondition(cond)
[11:00:29.177]                 })
[11:00:29.177]             }))
[11:00:29.177]             future::FutureResult(value = ...future.value$value, 
[11:00:29.177]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:29.177]                   ...future.rng), globalenv = if (FALSE) 
[11:00:29.177]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:29.177]                     ...future.globalenv.names))
[11:00:29.177]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:29.177]         }, condition = base::local({
[11:00:29.177]             c <- base::c
[11:00:29.177]             inherits <- base::inherits
[11:00:29.177]             invokeRestart <- base::invokeRestart
[11:00:29.177]             length <- base::length
[11:00:29.177]             list <- base::list
[11:00:29.177]             seq.int <- base::seq.int
[11:00:29.177]             signalCondition <- base::signalCondition
[11:00:29.177]             sys.calls <- base::sys.calls
[11:00:29.177]             `[[` <- base::`[[`
[11:00:29.177]             `+` <- base::`+`
[11:00:29.177]             `<<-` <- base::`<<-`
[11:00:29.177]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:29.177]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:29.177]                   3L)]
[11:00:29.177]             }
[11:00:29.177]             function(cond) {
[11:00:29.177]                 is_error <- inherits(cond, "error")
[11:00:29.177]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:29.177]                   NULL)
[11:00:29.177]                 if (is_error) {
[11:00:29.177]                   sessionInformation <- function() {
[11:00:29.177]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:29.177]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:29.177]                       search = base::search(), system = base::Sys.info())
[11:00:29.177]                   }
[11:00:29.177]                   ...future.conditions[[length(...future.conditions) + 
[11:00:29.177]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:29.177]                     cond$call), session = sessionInformation(), 
[11:00:29.177]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:29.177]                   signalCondition(cond)
[11:00:29.177]                 }
[11:00:29.177]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:29.177]                 "immediateCondition"))) {
[11:00:29.177]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:29.177]                   ...future.conditions[[length(...future.conditions) + 
[11:00:29.177]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:29.177]                   if (TRUE && !signal) {
[11:00:29.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:29.177]                     {
[11:00:29.177]                       inherits <- base::inherits
[11:00:29.177]                       invokeRestart <- base::invokeRestart
[11:00:29.177]                       is.null <- base::is.null
[11:00:29.177]                       muffled <- FALSE
[11:00:29.177]                       if (inherits(cond, "message")) {
[11:00:29.177]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:29.177]                         if (muffled) 
[11:00:29.177]                           invokeRestart("muffleMessage")
[11:00:29.177]                       }
[11:00:29.177]                       else if (inherits(cond, "warning")) {
[11:00:29.177]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:29.177]                         if (muffled) 
[11:00:29.177]                           invokeRestart("muffleWarning")
[11:00:29.177]                       }
[11:00:29.177]                       else if (inherits(cond, "condition")) {
[11:00:29.177]                         if (!is.null(pattern)) {
[11:00:29.177]                           computeRestarts <- base::computeRestarts
[11:00:29.177]                           grepl <- base::grepl
[11:00:29.177]                           restarts <- computeRestarts(cond)
[11:00:29.177]                           for (restart in restarts) {
[11:00:29.177]                             name <- restart$name
[11:00:29.177]                             if (is.null(name)) 
[11:00:29.177]                               next
[11:00:29.177]                             if (!grepl(pattern, name)) 
[11:00:29.177]                               next
[11:00:29.177]                             invokeRestart(restart)
[11:00:29.177]                             muffled <- TRUE
[11:00:29.177]                             break
[11:00:29.177]                           }
[11:00:29.177]                         }
[11:00:29.177]                       }
[11:00:29.177]                       invisible(muffled)
[11:00:29.177]                     }
[11:00:29.177]                     muffleCondition(cond, pattern = "^muffle")
[11:00:29.177]                   }
[11:00:29.177]                 }
[11:00:29.177]                 else {
[11:00:29.177]                   if (TRUE) {
[11:00:29.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:29.177]                     {
[11:00:29.177]                       inherits <- base::inherits
[11:00:29.177]                       invokeRestart <- base::invokeRestart
[11:00:29.177]                       is.null <- base::is.null
[11:00:29.177]                       muffled <- FALSE
[11:00:29.177]                       if (inherits(cond, "message")) {
[11:00:29.177]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:29.177]                         if (muffled) 
[11:00:29.177]                           invokeRestart("muffleMessage")
[11:00:29.177]                       }
[11:00:29.177]                       else if (inherits(cond, "warning")) {
[11:00:29.177]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:29.177]                         if (muffled) 
[11:00:29.177]                           invokeRestart("muffleWarning")
[11:00:29.177]                       }
[11:00:29.177]                       else if (inherits(cond, "condition")) {
[11:00:29.177]                         if (!is.null(pattern)) {
[11:00:29.177]                           computeRestarts <- base::computeRestarts
[11:00:29.177]                           grepl <- base::grepl
[11:00:29.177]                           restarts <- computeRestarts(cond)
[11:00:29.177]                           for (restart in restarts) {
[11:00:29.177]                             name <- restart$name
[11:00:29.177]                             if (is.null(name)) 
[11:00:29.177]                               next
[11:00:29.177]                             if (!grepl(pattern, name)) 
[11:00:29.177]                               next
[11:00:29.177]                             invokeRestart(restart)
[11:00:29.177]                             muffled <- TRUE
[11:00:29.177]                             break
[11:00:29.177]                           }
[11:00:29.177]                         }
[11:00:29.177]                       }
[11:00:29.177]                       invisible(muffled)
[11:00:29.177]                     }
[11:00:29.177]                     muffleCondition(cond, pattern = "^muffle")
[11:00:29.177]                   }
[11:00:29.177]                 }
[11:00:29.177]             }
[11:00:29.177]         }))
[11:00:29.177]     }, error = function(ex) {
[11:00:29.177]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:29.177]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:29.177]                 ...future.rng), started = ...future.startTime, 
[11:00:29.177]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:29.177]             version = "1.8"), class = "FutureResult")
[11:00:29.177]     }, finally = {
[11:00:29.177]         if (!identical(...future.workdir, getwd())) 
[11:00:29.177]             setwd(...future.workdir)
[11:00:29.177]         {
[11:00:29.177]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:29.177]                 ...future.oldOptions$nwarnings <- NULL
[11:00:29.177]             }
[11:00:29.177]             base::options(...future.oldOptions)
[11:00:29.177]             if (.Platform$OS.type == "windows") {
[11:00:29.177]                 old_names <- names(...future.oldEnvVars)
[11:00:29.177]                 envs <- base::Sys.getenv()
[11:00:29.177]                 names <- names(envs)
[11:00:29.177]                 common <- intersect(names, old_names)
[11:00:29.177]                 added <- setdiff(names, old_names)
[11:00:29.177]                 removed <- setdiff(old_names, names)
[11:00:29.177]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:29.177]                   envs[common]]
[11:00:29.177]                 NAMES <- toupper(changed)
[11:00:29.177]                 args <- list()
[11:00:29.177]                 for (kk in seq_along(NAMES)) {
[11:00:29.177]                   name <- changed[[kk]]
[11:00:29.177]                   NAME <- NAMES[[kk]]
[11:00:29.177]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:29.177]                     next
[11:00:29.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:29.177]                 }
[11:00:29.177]                 NAMES <- toupper(added)
[11:00:29.177]                 for (kk in seq_along(NAMES)) {
[11:00:29.177]                   name <- added[[kk]]
[11:00:29.177]                   NAME <- NAMES[[kk]]
[11:00:29.177]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:29.177]                     next
[11:00:29.177]                   args[[name]] <- ""
[11:00:29.177]                 }
[11:00:29.177]                 NAMES <- toupper(removed)
[11:00:29.177]                 for (kk in seq_along(NAMES)) {
[11:00:29.177]                   name <- removed[[kk]]
[11:00:29.177]                   NAME <- NAMES[[kk]]
[11:00:29.177]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:29.177]                     next
[11:00:29.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:29.177]                 }
[11:00:29.177]                 if (length(args) > 0) 
[11:00:29.177]                   base::do.call(base::Sys.setenv, args = args)
[11:00:29.177]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:29.177]             }
[11:00:29.177]             else {
[11:00:29.177]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:29.177]             }
[11:00:29.177]             {
[11:00:29.177]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:29.177]                   0L) {
[11:00:29.177]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:29.177]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:29.177]                   base::options(opts)
[11:00:29.177]                 }
[11:00:29.177]                 {
[11:00:29.177]                   {
[11:00:29.177]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:29.177]                     NULL
[11:00:29.177]                   }
[11:00:29.177]                   options(future.plan = NULL)
[11:00:29.177]                   if (is.na(NA_character_)) 
[11:00:29.177]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:29.177]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:29.177]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:29.177]                     .init = FALSE)
[11:00:29.177]                 }
[11:00:29.177]             }
[11:00:29.177]         }
[11:00:29.177]     })
[11:00:29.177]     if (TRUE) {
[11:00:29.177]         base::sink(type = "output", split = FALSE)
[11:00:29.177]         if (FALSE) {
[11:00:29.177]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:29.177]         }
[11:00:29.177]         else {
[11:00:29.177]             ...future.result["stdout"] <- base::list(NULL)
[11:00:29.177]         }
[11:00:29.177]         base::close(...future.stdout)
[11:00:29.177]         ...future.stdout <- NULL
[11:00:29.177]     }
[11:00:29.177]     ...future.result$conditions <- ...future.conditions
[11:00:29.177]     ...future.result$finished <- base::Sys.time()
[11:00:29.177]     ...future.result
[11:00:29.177] }
[11:00:29.180] Exporting 5 global objects (1.63 KiB) to cluster node #2 ...
[11:00:29.180] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[11:00:29.180] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[11:00:29.180] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[11:00:29.181] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[11:00:29.181] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ...
[11:00:29.181] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ... DONE
[11:00:29.181] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[11:00:29.182] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[11:00:29.182] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[11:00:29.182] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[11:00:29.182] Exporting 5 global objects (1.63 KiB) to cluster node #2 ... DONE
[11:00:29.183] MultisessionFuture started
[11:00:29.183] - Launch lazy future ... done
[11:00:29.183] run() for ‘MultisessionFuture’ ... done
[11:00:29.183] Created future:
[11:00:29.183] MultisessionFuture:
[11:00:29.183] Label: ‘future_mapply-2’
[11:00:29.183] Expression:
[11:00:29.183] {
[11:00:29.183]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:29.183]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:29.183]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:29.183]         on.exit(options(oopts), add = TRUE)
[11:00:29.183]     }
[11:00:29.183]     {
[11:00:29.183]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:29.183]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:00:29.183]         do.call(mapply, args = args)
[11:00:29.183]     }
[11:00:29.183] }
[11:00:29.183] Lazy evaluation: FALSE
[11:00:29.183] Asynchronous evaluation: TRUE
[11:00:29.183] Local evaluation: TRUE
[11:00:29.183] Environment: R_GlobalEnv
[11:00:29.183] Capture standard output: FALSE
[11:00:29.183] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:29.183] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:29.183] Packages: <none>
[11:00:29.183] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:29.183] Resolved: FALSE
[11:00:29.183] Value: <not collected>
[11:00:29.183] Conditions captured: <none>
[11:00:29.183] Early signaling: FALSE
[11:00:29.183] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:29.183] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:29.194] Chunk #2 of 2 ... DONE
[11:00:29.195] Launching 2 futures (chunks) ... DONE
[11:00:29.195] Resolving 2 futures (chunks) ...
[11:00:29.195] resolve() on list ...
[11:00:29.195]  recursive: 0
[11:00:29.195]  length: 2
[11:00:29.195] 
[11:00:29.237] receiveMessageFromWorker() for ClusterFuture ...
[11:00:29.237] - Validating connection of MultisessionFuture
[11:00:29.237] - received message: FutureResult
[11:00:29.238] - Received FutureResult
[11:00:29.238] - Erased future from FutureRegistry
[11:00:29.238] result() for ClusterFuture ...
[11:00:29.238] - result already collected: FutureResult
[11:00:29.238] result() for ClusterFuture ... done
[11:00:29.238] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:29.238] Future #2
[11:00:29.238] result() for ClusterFuture ...
[11:00:29.238] - result already collected: FutureResult
[11:00:29.238] result() for ClusterFuture ... done
[11:00:29.238] result() for ClusterFuture ...
[11:00:29.239] - result already collected: FutureResult
[11:00:29.239] result() for ClusterFuture ... done
[11:00:29.239] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:00:29.239] - nx: 2
[11:00:29.239] - relay: TRUE
[11:00:29.239] - stdout: TRUE
[11:00:29.239] - signal: TRUE
[11:00:29.239] - resignal: FALSE
[11:00:29.239] - force: TRUE
[11:00:29.239] - relayed: [n=2] FALSE, FALSE
[11:00:29.239] - queued futures: [n=2] FALSE, FALSE
[11:00:29.239]  - until=1
[11:00:29.240]  - relaying element #1
[11:00:29.240] - relayed: [n=2] FALSE, FALSE
[11:00:29.240] - queued futures: [n=2] FALSE, TRUE
[11:00:29.240] signalConditionsASAP(NULL, pos=2) ... done
[11:00:29.240]  length: 1 (resolved future 2)
[11:00:29.688] receiveMessageFromWorker() for ClusterFuture ...
[11:00:29.688] - Validating connection of MultisessionFuture
[11:00:29.688] - received message: FutureResult
[11:00:29.688] - Received FutureResult
[11:00:29.689] - Erased future from FutureRegistry
[11:00:29.689] result() for ClusterFuture ...
[11:00:29.689] - result already collected: FutureResult
[11:00:29.689] result() for ClusterFuture ... done
[11:00:29.689] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:29.689] Future #1
[11:00:29.689] result() for ClusterFuture ...
[11:00:29.689] - result already collected: FutureResult
[11:00:29.689] result() for ClusterFuture ... done
[11:00:29.689] result() for ClusterFuture ...
[11:00:29.689] - result already collected: FutureResult
[11:00:29.689] result() for ClusterFuture ... done
[11:00:29.690] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:00:29.690] - nx: 2
[11:00:29.690] - relay: TRUE
[11:00:29.690] - stdout: TRUE
[11:00:29.690] - signal: TRUE
[11:00:29.690] - resignal: FALSE
[11:00:29.690] - force: TRUE
[11:00:29.690] - relayed: [n=2] FALSE, FALSE
[11:00:29.690] - queued futures: [n=2] FALSE, TRUE
[11:00:29.690]  - until=1
[11:00:29.690]  - relaying element #1
[11:00:29.690] result() for ClusterFuture ...
[11:00:29.690] - result already collected: FutureResult
[11:00:29.691] result() for ClusterFuture ... done
[11:00:29.691] result() for ClusterFuture ...
[11:00:29.691] - result already collected: FutureResult
[11:00:29.691] result() for ClusterFuture ... done
[11:00:29.691] result() for ClusterFuture ...
[11:00:29.691] - result already collected: FutureResult
[11:00:29.691] result() for ClusterFuture ... done
[11:00:29.691] result() for ClusterFuture ...
[11:00:29.691] - result already collected: FutureResult
[11:00:29.691] result() for ClusterFuture ... done
[11:00:29.691] - relayed: [n=2] TRUE, FALSE
[11:00:29.691] - queued futures: [n=2] TRUE, TRUE
[11:00:29.692] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:00:29.692]  length: 0 (resolved future 1)
[11:00:29.692] Relaying remaining futures
[11:00:29.692] signalConditionsASAP(NULL, pos=0) ...
[11:00:29.692] - nx: 2
[11:00:29.692] - relay: TRUE
[11:00:29.692] - stdout: TRUE
[11:00:29.692] - signal: TRUE
[11:00:29.692] - resignal: FALSE
[11:00:29.692] - force: TRUE
[11:00:29.692] - relayed: [n=2] TRUE, FALSE
[11:00:29.692] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:29.692]  - relaying element #2
[11:00:29.693] result() for ClusterFuture ...
[11:00:29.693] - result already collected: FutureResult
[11:00:29.693] result() for ClusterFuture ... done
[11:00:29.693] result() for ClusterFuture ...
[11:00:29.693] - result already collected: FutureResult
[11:00:29.693] result() for ClusterFuture ... done
[11:00:29.693] result() for ClusterFuture ...
[11:00:29.693] - result already collected: FutureResult
[11:00:29.693] result() for ClusterFuture ... done
[11:00:29.693] result() for ClusterFuture ...
[11:00:29.693] - result already collected: FutureResult
[11:00:29.693] result() for ClusterFuture ... done
[11:00:29.694] - relayed: [n=2] TRUE, TRUE
[11:00:29.694] - queued futures: [n=2] TRUE, TRUE
[11:00:29.694] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[11:00:29.694] resolve() on list ... DONE
[11:00:29.694] result() for ClusterFuture ...
[11:00:29.694] - result already collected: FutureResult
[11:00:29.694] result() for ClusterFuture ... done
[11:00:29.694] result() for ClusterFuture ...
[11:00:29.694] - result already collected: FutureResult
[11:00:29.694] result() for ClusterFuture ... done
[11:00:29.694] result() for ClusterFuture ...
[11:00:29.694] - result already collected: FutureResult
[11:00:29.694] result() for ClusterFuture ... done
[11:00:29.695] result() for ClusterFuture ...
[11:00:29.695] - result already collected: FutureResult
[11:00:29.695] result() for ClusterFuture ... done
[11:00:29.695]  - Number of value chunks collected: 2
[11:00:29.695] Resolving 2 futures (chunks) ... DONE
[11:00:29.695] Reducing values from 2 chunks ...
[11:00:29.695]  - Number of values collected after concatenation: 2
[11:00:29.695]  - Number of values expected: 2
[11:00:29.695] Reducing values from 2 chunks ... DONE
[11:00:29.695] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[11:00:29.696] future_mapply() ...
[11:00:29.697] Number of chunks: 2
[11:00:29.697] getGlobalsAndPackagesXApply() ...
[11:00:29.697]  - future.globals: TRUE
[11:00:29.698] getGlobalsAndPackages() ...
[11:00:29.698] Searching for globals...
[11:00:29.699] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[11:00:29.699] Searching for globals ... DONE
[11:00:29.699] Resolving globals: FALSE
[11:00:29.700] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[11:00:29.700] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[11:00:29.700] - globals: [1] ‘FUN’
[11:00:29.700] 
[11:00:29.700] getGlobalsAndPackages() ... DONE
[11:00:29.700]  - globals found/used: [n=1] ‘FUN’
[11:00:29.700]  - needed namespaces: [n=0] 
[11:00:29.701] Finding globals ... DONE
[11:00:29.701] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[11:00:29.701] List of 2
[11:00:29.701]  $ ...future.FUN:function (x, y)  
[11:00:29.701]  $ MoreArgs     : NULL
[11:00:29.701]  - attr(*, "where")=List of 2
[11:00:29.701]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:29.701]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[11:00:29.701]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:29.701]  - attr(*, "resolved")= logi FALSE
[11:00:29.701]  - attr(*, "total_size")= num NA
[11:00:29.703] Packages to be attached in all futures: [n=0] 
[11:00:29.703] getGlobalsAndPackagesXApply() ... DONE
[11:00:29.703] Number of futures (= number of chunks): 2
[11:00:29.704] Launching 2 futures (chunks) ...
[11:00:29.704] Chunk #1 of 2 ...
[11:00:29.704]  - Finding globals in '...' for chunk #1 ...
[11:00:29.704] getGlobalsAndPackages() ...
[11:00:29.704] Searching for globals...
[11:00:29.704] 
[11:00:29.704] Searching for globals ... DONE
[11:00:29.704] - globals: [0] <none>
[11:00:29.705] getGlobalsAndPackages() ... DONE
[11:00:29.705]    + additional globals found: [n=0] 
[11:00:29.705]    + additional namespaces needed: [n=0] 
[11:00:29.705]  - Finding globals in '...' for chunk #1 ... DONE
[11:00:29.705]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:29.705]  - seeds: <none>
[11:00:29.705]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:29.705] getGlobalsAndPackages() ...
[11:00:29.705] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:29.705] Resolving globals: FALSE
[11:00:29.706] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[11:00:29.706] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[11:00:29.706] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:29.706] 
[11:00:29.706] getGlobalsAndPackages() ... DONE
[11:00:29.707] run() for ‘Future’ ...
[11:00:29.707] - state: ‘created’
[11:00:29.707] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:29.722] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:29.722] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:29.722]   - Field: ‘node’
[11:00:29.722]   - Field: ‘label’
[11:00:29.722]   - Field: ‘local’
[11:00:29.722]   - Field: ‘owner’
[11:00:29.722]   - Field: ‘envir’
[11:00:29.722]   - Field: ‘workers’
[11:00:29.723]   - Field: ‘packages’
[11:00:29.723]   - Field: ‘gc’
[11:00:29.723]   - Field: ‘conditions’
[11:00:29.723]   - Field: ‘persistent’
[11:00:29.723]   - Field: ‘expr’
[11:00:29.723]   - Field: ‘uuid’
[11:00:29.723]   - Field: ‘seed’
[11:00:29.723]   - Field: ‘version’
[11:00:29.723]   - Field: ‘result’
[11:00:29.723]   - Field: ‘asynchronous’
[11:00:29.723]   - Field: ‘calls’
[11:00:29.723]   - Field: ‘globals’
[11:00:29.724]   - Field: ‘stdout’
[11:00:29.724]   - Field: ‘earlySignal’
[11:00:29.724]   - Field: ‘lazy’
[11:00:29.724]   - Field: ‘state’
[11:00:29.724] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:29.724] - Launch lazy future ...
[11:00:29.724] Packages needed by the future expression (n = 0): <none>
[11:00:29.724] Packages needed by future strategies (n = 0): <none>
[11:00:29.725] {
[11:00:29.725]     {
[11:00:29.725]         {
[11:00:29.725]             ...future.startTime <- base::Sys.time()
[11:00:29.725]             {
[11:00:29.725]                 {
[11:00:29.725]                   {
[11:00:29.725]                     {
[11:00:29.725]                       base::local({
[11:00:29.725]                         has_future <- base::requireNamespace("future", 
[11:00:29.725]                           quietly = TRUE)
[11:00:29.725]                         if (has_future) {
[11:00:29.725]                           ns <- base::getNamespace("future")
[11:00:29.725]                           version <- ns[[".package"]][["version"]]
[11:00:29.725]                           if (is.null(version)) 
[11:00:29.725]                             version <- utils::packageVersion("future")
[11:00:29.725]                         }
[11:00:29.725]                         else {
[11:00:29.725]                           version <- NULL
[11:00:29.725]                         }
[11:00:29.725]                         if (!has_future || version < "1.8.0") {
[11:00:29.725]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:29.725]                             "", base::R.version$version.string), 
[11:00:29.725]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:29.725]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:29.725]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:29.725]                               "release", "version")], collapse = " "), 
[11:00:29.725]                             hostname = base::Sys.info()[["nodename"]])
[11:00:29.725]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:29.725]                             info)
[11:00:29.725]                           info <- base::paste(info, collapse = "; ")
[11:00:29.725]                           if (!has_future) {
[11:00:29.725]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:29.725]                               info)
[11:00:29.725]                           }
[11:00:29.725]                           else {
[11:00:29.725]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:29.725]                               info, version)
[11:00:29.725]                           }
[11:00:29.725]                           base::stop(msg)
[11:00:29.725]                         }
[11:00:29.725]                       })
[11:00:29.725]                     }
[11:00:29.725]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:29.725]                     base::options(mc.cores = 1L)
[11:00:29.725]                   }
[11:00:29.725]                   ...future.strategy.old <- future::plan("list")
[11:00:29.725]                   options(future.plan = NULL)
[11:00:29.725]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:29.725]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:29.725]                 }
[11:00:29.725]                 ...future.workdir <- getwd()
[11:00:29.725]             }
[11:00:29.725]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:29.725]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:29.725]         }
[11:00:29.725]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:29.725]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:29.725]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:29.725]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:29.725]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:29.725]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:29.725]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:29.725]             base::names(...future.oldOptions))
[11:00:29.725]     }
[11:00:29.725]     if (FALSE) {
[11:00:29.725]     }
[11:00:29.725]     else {
[11:00:29.725]         if (TRUE) {
[11:00:29.725]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:29.725]                 open = "w")
[11:00:29.725]         }
[11:00:29.725]         else {
[11:00:29.725]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:29.725]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:29.725]         }
[11:00:29.725]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:29.725]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:29.725]             base::sink(type = "output", split = FALSE)
[11:00:29.725]             base::close(...future.stdout)
[11:00:29.725]         }, add = TRUE)
[11:00:29.725]     }
[11:00:29.725]     ...future.frame <- base::sys.nframe()
[11:00:29.725]     ...future.conditions <- base::list()
[11:00:29.725]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:29.725]     if (FALSE) {
[11:00:29.725]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:29.725]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:29.725]     }
[11:00:29.725]     ...future.result <- base::tryCatch({
[11:00:29.725]         base::withCallingHandlers({
[11:00:29.725]             ...future.value <- base::withVisible(base::local({
[11:00:29.725]                 ...future.makeSendCondition <- base::local({
[11:00:29.725]                   sendCondition <- NULL
[11:00:29.725]                   function(frame = 1L) {
[11:00:29.725]                     if (is.function(sendCondition)) 
[11:00:29.725]                       return(sendCondition)
[11:00:29.725]                     ns <- getNamespace("parallel")
[11:00:29.725]                     if (exists("sendData", mode = "function", 
[11:00:29.725]                       envir = ns)) {
[11:00:29.725]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:29.725]                         envir = ns)
[11:00:29.725]                       envir <- sys.frame(frame)
[11:00:29.725]                       master <- NULL
[11:00:29.725]                       while (!identical(envir, .GlobalEnv) && 
[11:00:29.725]                         !identical(envir, emptyenv())) {
[11:00:29.725]                         if (exists("master", mode = "list", envir = envir, 
[11:00:29.725]                           inherits = FALSE)) {
[11:00:29.725]                           master <- get("master", mode = "list", 
[11:00:29.725]                             envir = envir, inherits = FALSE)
[11:00:29.725]                           if (inherits(master, c("SOCKnode", 
[11:00:29.725]                             "SOCK0node"))) {
[11:00:29.725]                             sendCondition <<- function(cond) {
[11:00:29.725]                               data <- list(type = "VALUE", value = cond, 
[11:00:29.725]                                 success = TRUE)
[11:00:29.725]                               parallel_sendData(master, data)
[11:00:29.725]                             }
[11:00:29.725]                             return(sendCondition)
[11:00:29.725]                           }
[11:00:29.725]                         }
[11:00:29.725]                         frame <- frame + 1L
[11:00:29.725]                         envir <- sys.frame(frame)
[11:00:29.725]                       }
[11:00:29.725]                     }
[11:00:29.725]                     sendCondition <<- function(cond) NULL
[11:00:29.725]                   }
[11:00:29.725]                 })
[11:00:29.725]                 withCallingHandlers({
[11:00:29.725]                   {
[11:00:29.725]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:29.725]                     if (!identical(...future.globals.maxSize.org, 
[11:00:29.725]                       ...future.globals.maxSize)) {
[11:00:29.725]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:29.725]                       on.exit(options(oopts), add = TRUE)
[11:00:29.725]                     }
[11:00:29.725]                     {
[11:00:29.725]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:29.725]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:00:29.725]                         USE.NAMES = FALSE)
[11:00:29.725]                       do.call(mapply, args = args)
[11:00:29.725]                     }
[11:00:29.725]                   }
[11:00:29.725]                 }, immediateCondition = function(cond) {
[11:00:29.725]                   sendCondition <- ...future.makeSendCondition()
[11:00:29.725]                   sendCondition(cond)
[11:00:29.725]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:29.725]                   {
[11:00:29.725]                     inherits <- base::inherits
[11:00:29.725]                     invokeRestart <- base::invokeRestart
[11:00:29.725]                     is.null <- base::is.null
[11:00:29.725]                     muffled <- FALSE
[11:00:29.725]                     if (inherits(cond, "message")) {
[11:00:29.725]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:29.725]                       if (muffled) 
[11:00:29.725]                         invokeRestart("muffleMessage")
[11:00:29.725]                     }
[11:00:29.725]                     else if (inherits(cond, "warning")) {
[11:00:29.725]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:29.725]                       if (muffled) 
[11:00:29.725]                         invokeRestart("muffleWarning")
[11:00:29.725]                     }
[11:00:29.725]                     else if (inherits(cond, "condition")) {
[11:00:29.725]                       if (!is.null(pattern)) {
[11:00:29.725]                         computeRestarts <- base::computeRestarts
[11:00:29.725]                         grepl <- base::grepl
[11:00:29.725]                         restarts <- computeRestarts(cond)
[11:00:29.725]                         for (restart in restarts) {
[11:00:29.725]                           name <- restart$name
[11:00:29.725]                           if (is.null(name)) 
[11:00:29.725]                             next
[11:00:29.725]                           if (!grepl(pattern, name)) 
[11:00:29.725]                             next
[11:00:29.725]                           invokeRestart(restart)
[11:00:29.725]                           muffled <- TRUE
[11:00:29.725]                           break
[11:00:29.725]                         }
[11:00:29.725]                       }
[11:00:29.725]                     }
[11:00:29.725]                     invisible(muffled)
[11:00:29.725]                   }
[11:00:29.725]                   muffleCondition(cond)
[11:00:29.725]                 })
[11:00:29.725]             }))
[11:00:29.725]             future::FutureResult(value = ...future.value$value, 
[11:00:29.725]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:29.725]                   ...future.rng), globalenv = if (FALSE) 
[11:00:29.725]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:29.725]                     ...future.globalenv.names))
[11:00:29.725]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:29.725]         }, condition = base::local({
[11:00:29.725]             c <- base::c
[11:00:29.725]             inherits <- base::inherits
[11:00:29.725]             invokeRestart <- base::invokeRestart
[11:00:29.725]             length <- base::length
[11:00:29.725]             list <- base::list
[11:00:29.725]             seq.int <- base::seq.int
[11:00:29.725]             signalCondition <- base::signalCondition
[11:00:29.725]             sys.calls <- base::sys.calls
[11:00:29.725]             `[[` <- base::`[[`
[11:00:29.725]             `+` <- base::`+`
[11:00:29.725]             `<<-` <- base::`<<-`
[11:00:29.725]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:29.725]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:29.725]                   3L)]
[11:00:29.725]             }
[11:00:29.725]             function(cond) {
[11:00:29.725]                 is_error <- inherits(cond, "error")
[11:00:29.725]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:29.725]                   NULL)
[11:00:29.725]                 if (is_error) {
[11:00:29.725]                   sessionInformation <- function() {
[11:00:29.725]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:29.725]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:29.725]                       search = base::search(), system = base::Sys.info())
[11:00:29.725]                   }
[11:00:29.725]                   ...future.conditions[[length(...future.conditions) + 
[11:00:29.725]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:29.725]                     cond$call), session = sessionInformation(), 
[11:00:29.725]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:29.725]                   signalCondition(cond)
[11:00:29.725]                 }
[11:00:29.725]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:29.725]                 "immediateCondition"))) {
[11:00:29.725]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:29.725]                   ...future.conditions[[length(...future.conditions) + 
[11:00:29.725]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:29.725]                   if (TRUE && !signal) {
[11:00:29.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:29.725]                     {
[11:00:29.725]                       inherits <- base::inherits
[11:00:29.725]                       invokeRestart <- base::invokeRestart
[11:00:29.725]                       is.null <- base::is.null
[11:00:29.725]                       muffled <- FALSE
[11:00:29.725]                       if (inherits(cond, "message")) {
[11:00:29.725]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:29.725]                         if (muffled) 
[11:00:29.725]                           invokeRestart("muffleMessage")
[11:00:29.725]                       }
[11:00:29.725]                       else if (inherits(cond, "warning")) {
[11:00:29.725]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:29.725]                         if (muffled) 
[11:00:29.725]                           invokeRestart("muffleWarning")
[11:00:29.725]                       }
[11:00:29.725]                       else if (inherits(cond, "condition")) {
[11:00:29.725]                         if (!is.null(pattern)) {
[11:00:29.725]                           computeRestarts <- base::computeRestarts
[11:00:29.725]                           grepl <- base::grepl
[11:00:29.725]                           restarts <- computeRestarts(cond)
[11:00:29.725]                           for (restart in restarts) {
[11:00:29.725]                             name <- restart$name
[11:00:29.725]                             if (is.null(name)) 
[11:00:29.725]                               next
[11:00:29.725]                             if (!grepl(pattern, name)) 
[11:00:29.725]                               next
[11:00:29.725]                             invokeRestart(restart)
[11:00:29.725]                             muffled <- TRUE
[11:00:29.725]                             break
[11:00:29.725]                           }
[11:00:29.725]                         }
[11:00:29.725]                       }
[11:00:29.725]                       invisible(muffled)
[11:00:29.725]                     }
[11:00:29.725]                     muffleCondition(cond, pattern = "^muffle")
[11:00:29.725]                   }
[11:00:29.725]                 }
[11:00:29.725]                 else {
[11:00:29.725]                   if (TRUE) {
[11:00:29.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:29.725]                     {
[11:00:29.725]                       inherits <- base::inherits
[11:00:29.725]                       invokeRestart <- base::invokeRestart
[11:00:29.725]                       is.null <- base::is.null
[11:00:29.725]                       muffled <- FALSE
[11:00:29.725]                       if (inherits(cond, "message")) {
[11:00:29.725]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:29.725]                         if (muffled) 
[11:00:29.725]                           invokeRestart("muffleMessage")
[11:00:29.725]                       }
[11:00:29.725]                       else if (inherits(cond, "warning")) {
[11:00:29.725]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:29.725]                         if (muffled) 
[11:00:29.725]                           invokeRestart("muffleWarning")
[11:00:29.725]                       }
[11:00:29.725]                       else if (inherits(cond, "condition")) {
[11:00:29.725]                         if (!is.null(pattern)) {
[11:00:29.725]                           computeRestarts <- base::computeRestarts
[11:00:29.725]                           grepl <- base::grepl
[11:00:29.725]                           restarts <- computeRestarts(cond)
[11:00:29.725]                           for (restart in restarts) {
[11:00:29.725]                             name <- restart$name
[11:00:29.725]                             if (is.null(name)) 
[11:00:29.725]                               next
[11:00:29.725]                             if (!grepl(pattern, name)) 
[11:00:29.725]                               next
[11:00:29.725]                             invokeRestart(restart)
[11:00:29.725]                             muffled <- TRUE
[11:00:29.725]                             break
[11:00:29.725]                           }
[11:00:29.725]                         }
[11:00:29.725]                       }
[11:00:29.725]                       invisible(muffled)
[11:00:29.725]                     }
[11:00:29.725]                     muffleCondition(cond, pattern = "^muffle")
[11:00:29.725]                   }
[11:00:29.725]                 }
[11:00:29.725]             }
[11:00:29.725]         }))
[11:00:29.725]     }, error = function(ex) {
[11:00:29.725]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:29.725]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:29.725]                 ...future.rng), started = ...future.startTime, 
[11:00:29.725]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:29.725]             version = "1.8"), class = "FutureResult")
[11:00:29.725]     }, finally = {
[11:00:29.725]         if (!identical(...future.workdir, getwd())) 
[11:00:29.725]             setwd(...future.workdir)
[11:00:29.725]         {
[11:00:29.725]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:29.725]                 ...future.oldOptions$nwarnings <- NULL
[11:00:29.725]             }
[11:00:29.725]             base::options(...future.oldOptions)
[11:00:29.725]             if (.Platform$OS.type == "windows") {
[11:00:29.725]                 old_names <- names(...future.oldEnvVars)
[11:00:29.725]                 envs <- base::Sys.getenv()
[11:00:29.725]                 names <- names(envs)
[11:00:29.725]                 common <- intersect(names, old_names)
[11:00:29.725]                 added <- setdiff(names, old_names)
[11:00:29.725]                 removed <- setdiff(old_names, names)
[11:00:29.725]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:29.725]                   envs[common]]
[11:00:29.725]                 NAMES <- toupper(changed)
[11:00:29.725]                 args <- list()
[11:00:29.725]                 for (kk in seq_along(NAMES)) {
[11:00:29.725]                   name <- changed[[kk]]
[11:00:29.725]                   NAME <- NAMES[[kk]]
[11:00:29.725]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:29.725]                     next
[11:00:29.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:29.725]                 }
[11:00:29.725]                 NAMES <- toupper(added)
[11:00:29.725]                 for (kk in seq_along(NAMES)) {
[11:00:29.725]                   name <- added[[kk]]
[11:00:29.725]                   NAME <- NAMES[[kk]]
[11:00:29.725]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:29.725]                     next
[11:00:29.725]                   args[[name]] <- ""
[11:00:29.725]                 }
[11:00:29.725]                 NAMES <- toupper(removed)
[11:00:29.725]                 for (kk in seq_along(NAMES)) {
[11:00:29.725]                   name <- removed[[kk]]
[11:00:29.725]                   NAME <- NAMES[[kk]]
[11:00:29.725]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:29.725]                     next
[11:00:29.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:29.725]                 }
[11:00:29.725]                 if (length(args) > 0) 
[11:00:29.725]                   base::do.call(base::Sys.setenv, args = args)
[11:00:29.725]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:29.725]             }
[11:00:29.725]             else {
[11:00:29.725]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:29.725]             }
[11:00:29.725]             {
[11:00:29.725]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:29.725]                   0L) {
[11:00:29.725]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:29.725]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:29.725]                   base::options(opts)
[11:00:29.725]                 }
[11:00:29.725]                 {
[11:00:29.725]                   {
[11:00:29.725]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:29.725]                     NULL
[11:00:29.725]                   }
[11:00:29.725]                   options(future.plan = NULL)
[11:00:29.725]                   if (is.na(NA_character_)) 
[11:00:29.725]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:29.725]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:29.725]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:29.725]                     .init = FALSE)
[11:00:29.725]                 }
[11:00:29.725]             }
[11:00:29.725]         }
[11:00:29.725]     })
[11:00:29.725]     if (TRUE) {
[11:00:29.725]         base::sink(type = "output", split = FALSE)
[11:00:29.725]         if (TRUE) {
[11:00:29.725]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:29.725]         }
[11:00:29.725]         else {
[11:00:29.725]             ...future.result["stdout"] <- base::list(NULL)
[11:00:29.725]         }
[11:00:29.725]         base::close(...future.stdout)
[11:00:29.725]         ...future.stdout <- NULL
[11:00:29.725]     }
[11:00:29.725]     ...future.result$conditions <- ...future.conditions
[11:00:29.725]     ...future.result$finished <- base::Sys.time()
[11:00:29.725]     ...future.result
[11:00:29.725] }
[11:00:29.727] Exporting 5 global objects (1.63 KiB) to cluster node #1 ...
[11:00:29.727] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[11:00:29.728] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[11:00:29.728] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[11:00:29.728] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[11:00:29.728] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ...
[11:00:29.729] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ... DONE
[11:00:29.729] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[11:00:29.729] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[11:00:29.729] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[11:00:29.730] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[11:00:29.730] Exporting 5 global objects (1.63 KiB) to cluster node #1 ... DONE
[11:00:29.730] MultisessionFuture started
[11:00:29.730] - Launch lazy future ... done
[11:00:29.730] run() for ‘MultisessionFuture’ ... done
[11:00:29.731] Created future:
[11:00:29.731] MultisessionFuture:
[11:00:29.731] Label: ‘future_mapply-1’
[11:00:29.731] Expression:
[11:00:29.731] {
[11:00:29.731]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:29.731]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:29.731]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:29.731]         on.exit(options(oopts), add = TRUE)
[11:00:29.731]     }
[11:00:29.731]     {
[11:00:29.731]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:29.731]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:00:29.731]         do.call(mapply, args = args)
[11:00:29.731]     }
[11:00:29.731] }
[11:00:29.731] Lazy evaluation: FALSE
[11:00:29.731] Asynchronous evaluation: TRUE
[11:00:29.731] Local evaluation: TRUE
[11:00:29.731] Environment: R_GlobalEnv
[11:00:29.731] Capture standard output: TRUE
[11:00:29.731] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:29.731] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:29.731] Packages: <none>
[11:00:29.731] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:29.731] Resolved: FALSE
[11:00:29.731] Value: <not collected>
[11:00:29.731] Conditions captured: <none>
[11:00:29.731] Early signaling: FALSE
[11:00:29.731] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:29.731] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:29.742] Chunk #1 of 2 ... DONE
[11:00:29.742] Chunk #2 of 2 ...
[11:00:29.742]  - Finding globals in '...' for chunk #2 ...
[11:00:29.742] getGlobalsAndPackages() ...
[11:00:29.742] Searching for globals...
[11:00:29.743] 
[11:00:29.743] Searching for globals ... DONE
[11:00:29.743] - globals: [0] <none>
[11:00:29.743] getGlobalsAndPackages() ... DONE
[11:00:29.743]    + additional globals found: [n=0] 
[11:00:29.743]    + additional namespaces needed: [n=0] 
[11:00:29.743]  - Finding globals in '...' for chunk #2 ... DONE
[11:00:29.743]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:29.743]  - seeds: <none>
[11:00:29.744]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:29.744] getGlobalsAndPackages() ...
[11:00:29.744] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:29.744] Resolving globals: FALSE
[11:00:29.744] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[11:00:29.745] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[11:00:29.745] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:29.745] 
[11:00:29.745] getGlobalsAndPackages() ... DONE
[11:00:29.745] run() for ‘Future’ ...
[11:00:29.745] - state: ‘created’
[11:00:29.745] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:29.759] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:29.759] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:29.759]   - Field: ‘node’
[11:00:29.759]   - Field: ‘label’
[11:00:29.759]   - Field: ‘local’
[11:00:29.759]   - Field: ‘owner’
[11:00:29.759]   - Field: ‘envir’
[11:00:29.760]   - Field: ‘workers’
[11:00:29.760]   - Field: ‘packages’
[11:00:29.760]   - Field: ‘gc’
[11:00:29.760]   - Field: ‘conditions’
[11:00:29.760]   - Field: ‘persistent’
[11:00:29.760]   - Field: ‘expr’
[11:00:29.760]   - Field: ‘uuid’
[11:00:29.760]   - Field: ‘seed’
[11:00:29.760]   - Field: ‘version’
[11:00:29.760]   - Field: ‘result’
[11:00:29.760]   - Field: ‘asynchronous’
[11:00:29.760]   - Field: ‘calls’
[11:00:29.761]   - Field: ‘globals’
[11:00:29.761]   - Field: ‘stdout’
[11:00:29.761]   - Field: ‘earlySignal’
[11:00:29.761]   - Field: ‘lazy’
[11:00:29.761]   - Field: ‘state’
[11:00:29.761] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:29.761] - Launch lazy future ...
[11:00:29.761] Packages needed by the future expression (n = 0): <none>
[11:00:29.761] Packages needed by future strategies (n = 0): <none>
[11:00:29.762] {
[11:00:29.762]     {
[11:00:29.762]         {
[11:00:29.762]             ...future.startTime <- base::Sys.time()
[11:00:29.762]             {
[11:00:29.762]                 {
[11:00:29.762]                   {
[11:00:29.762]                     {
[11:00:29.762]                       base::local({
[11:00:29.762]                         has_future <- base::requireNamespace("future", 
[11:00:29.762]                           quietly = TRUE)
[11:00:29.762]                         if (has_future) {
[11:00:29.762]                           ns <- base::getNamespace("future")
[11:00:29.762]                           version <- ns[[".package"]][["version"]]
[11:00:29.762]                           if (is.null(version)) 
[11:00:29.762]                             version <- utils::packageVersion("future")
[11:00:29.762]                         }
[11:00:29.762]                         else {
[11:00:29.762]                           version <- NULL
[11:00:29.762]                         }
[11:00:29.762]                         if (!has_future || version < "1.8.0") {
[11:00:29.762]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:29.762]                             "", base::R.version$version.string), 
[11:00:29.762]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:29.762]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:29.762]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:29.762]                               "release", "version")], collapse = " "), 
[11:00:29.762]                             hostname = base::Sys.info()[["nodename"]])
[11:00:29.762]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:29.762]                             info)
[11:00:29.762]                           info <- base::paste(info, collapse = "; ")
[11:00:29.762]                           if (!has_future) {
[11:00:29.762]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:29.762]                               info)
[11:00:29.762]                           }
[11:00:29.762]                           else {
[11:00:29.762]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:29.762]                               info, version)
[11:00:29.762]                           }
[11:00:29.762]                           base::stop(msg)
[11:00:29.762]                         }
[11:00:29.762]                       })
[11:00:29.762]                     }
[11:00:29.762]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:29.762]                     base::options(mc.cores = 1L)
[11:00:29.762]                   }
[11:00:29.762]                   ...future.strategy.old <- future::plan("list")
[11:00:29.762]                   options(future.plan = NULL)
[11:00:29.762]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:29.762]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:29.762]                 }
[11:00:29.762]                 ...future.workdir <- getwd()
[11:00:29.762]             }
[11:00:29.762]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:29.762]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:29.762]         }
[11:00:29.762]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:29.762]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:29.762]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:29.762]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:29.762]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:29.762]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:29.762]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:29.762]             base::names(...future.oldOptions))
[11:00:29.762]     }
[11:00:29.762]     if (FALSE) {
[11:00:29.762]     }
[11:00:29.762]     else {
[11:00:29.762]         if (TRUE) {
[11:00:29.762]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:29.762]                 open = "w")
[11:00:29.762]         }
[11:00:29.762]         else {
[11:00:29.762]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:29.762]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:29.762]         }
[11:00:29.762]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:29.762]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:29.762]             base::sink(type = "output", split = FALSE)
[11:00:29.762]             base::close(...future.stdout)
[11:00:29.762]         }, add = TRUE)
[11:00:29.762]     }
[11:00:29.762]     ...future.frame <- base::sys.nframe()
[11:00:29.762]     ...future.conditions <- base::list()
[11:00:29.762]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:29.762]     if (FALSE) {
[11:00:29.762]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:29.762]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:29.762]     }
[11:00:29.762]     ...future.result <- base::tryCatch({
[11:00:29.762]         base::withCallingHandlers({
[11:00:29.762]             ...future.value <- base::withVisible(base::local({
[11:00:29.762]                 ...future.makeSendCondition <- base::local({
[11:00:29.762]                   sendCondition <- NULL
[11:00:29.762]                   function(frame = 1L) {
[11:00:29.762]                     if (is.function(sendCondition)) 
[11:00:29.762]                       return(sendCondition)
[11:00:29.762]                     ns <- getNamespace("parallel")
[11:00:29.762]                     if (exists("sendData", mode = "function", 
[11:00:29.762]                       envir = ns)) {
[11:00:29.762]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:29.762]                         envir = ns)
[11:00:29.762]                       envir <- sys.frame(frame)
[11:00:29.762]                       master <- NULL
[11:00:29.762]                       while (!identical(envir, .GlobalEnv) && 
[11:00:29.762]                         !identical(envir, emptyenv())) {
[11:00:29.762]                         if (exists("master", mode = "list", envir = envir, 
[11:00:29.762]                           inherits = FALSE)) {
[11:00:29.762]                           master <- get("master", mode = "list", 
[11:00:29.762]                             envir = envir, inherits = FALSE)
[11:00:29.762]                           if (inherits(master, c("SOCKnode", 
[11:00:29.762]                             "SOCK0node"))) {
[11:00:29.762]                             sendCondition <<- function(cond) {
[11:00:29.762]                               data <- list(type = "VALUE", value = cond, 
[11:00:29.762]                                 success = TRUE)
[11:00:29.762]                               parallel_sendData(master, data)
[11:00:29.762]                             }
[11:00:29.762]                             return(sendCondition)
[11:00:29.762]                           }
[11:00:29.762]                         }
[11:00:29.762]                         frame <- frame + 1L
[11:00:29.762]                         envir <- sys.frame(frame)
[11:00:29.762]                       }
[11:00:29.762]                     }
[11:00:29.762]                     sendCondition <<- function(cond) NULL
[11:00:29.762]                   }
[11:00:29.762]                 })
[11:00:29.762]                 withCallingHandlers({
[11:00:29.762]                   {
[11:00:29.762]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:29.762]                     if (!identical(...future.globals.maxSize.org, 
[11:00:29.762]                       ...future.globals.maxSize)) {
[11:00:29.762]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:29.762]                       on.exit(options(oopts), add = TRUE)
[11:00:29.762]                     }
[11:00:29.762]                     {
[11:00:29.762]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:29.762]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:00:29.762]                         USE.NAMES = FALSE)
[11:00:29.762]                       do.call(mapply, args = args)
[11:00:29.762]                     }
[11:00:29.762]                   }
[11:00:29.762]                 }, immediateCondition = function(cond) {
[11:00:29.762]                   sendCondition <- ...future.makeSendCondition()
[11:00:29.762]                   sendCondition(cond)
[11:00:29.762]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:29.762]                   {
[11:00:29.762]                     inherits <- base::inherits
[11:00:29.762]                     invokeRestart <- base::invokeRestart
[11:00:29.762]                     is.null <- base::is.null
[11:00:29.762]                     muffled <- FALSE
[11:00:29.762]                     if (inherits(cond, "message")) {
[11:00:29.762]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:29.762]                       if (muffled) 
[11:00:29.762]                         invokeRestart("muffleMessage")
[11:00:29.762]                     }
[11:00:29.762]                     else if (inherits(cond, "warning")) {
[11:00:29.762]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:29.762]                       if (muffled) 
[11:00:29.762]                         invokeRestart("muffleWarning")
[11:00:29.762]                     }
[11:00:29.762]                     else if (inherits(cond, "condition")) {
[11:00:29.762]                       if (!is.null(pattern)) {
[11:00:29.762]                         computeRestarts <- base::computeRestarts
[11:00:29.762]                         grepl <- base::grepl
[11:00:29.762]                         restarts <- computeRestarts(cond)
[11:00:29.762]                         for (restart in restarts) {
[11:00:29.762]                           name <- restart$name
[11:00:29.762]                           if (is.null(name)) 
[11:00:29.762]                             next
[11:00:29.762]                           if (!grepl(pattern, name)) 
[11:00:29.762]                             next
[11:00:29.762]                           invokeRestart(restart)
[11:00:29.762]                           muffled <- TRUE
[11:00:29.762]                           break
[11:00:29.762]                         }
[11:00:29.762]                       }
[11:00:29.762]                     }
[11:00:29.762]                     invisible(muffled)
[11:00:29.762]                   }
[11:00:29.762]                   muffleCondition(cond)
[11:00:29.762]                 })
[11:00:29.762]             }))
[11:00:29.762]             future::FutureResult(value = ...future.value$value, 
[11:00:29.762]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:29.762]                   ...future.rng), globalenv = if (FALSE) 
[11:00:29.762]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:29.762]                     ...future.globalenv.names))
[11:00:29.762]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:29.762]         }, condition = base::local({
[11:00:29.762]             c <- base::c
[11:00:29.762]             inherits <- base::inherits
[11:00:29.762]             invokeRestart <- base::invokeRestart
[11:00:29.762]             length <- base::length
[11:00:29.762]             list <- base::list
[11:00:29.762]             seq.int <- base::seq.int
[11:00:29.762]             signalCondition <- base::signalCondition
[11:00:29.762]             sys.calls <- base::sys.calls
[11:00:29.762]             `[[` <- base::`[[`
[11:00:29.762]             `+` <- base::`+`
[11:00:29.762]             `<<-` <- base::`<<-`
[11:00:29.762]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:29.762]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:29.762]                   3L)]
[11:00:29.762]             }
[11:00:29.762]             function(cond) {
[11:00:29.762]                 is_error <- inherits(cond, "error")
[11:00:29.762]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:29.762]                   NULL)
[11:00:29.762]                 if (is_error) {
[11:00:29.762]                   sessionInformation <- function() {
[11:00:29.762]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:29.762]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:29.762]                       search = base::search(), system = base::Sys.info())
[11:00:29.762]                   }
[11:00:29.762]                   ...future.conditions[[length(...future.conditions) + 
[11:00:29.762]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:29.762]                     cond$call), session = sessionInformation(), 
[11:00:29.762]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:29.762]                   signalCondition(cond)
[11:00:29.762]                 }
[11:00:29.762]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:29.762]                 "immediateCondition"))) {
[11:00:29.762]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:29.762]                   ...future.conditions[[length(...future.conditions) + 
[11:00:29.762]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:29.762]                   if (TRUE && !signal) {
[11:00:29.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:29.762]                     {
[11:00:29.762]                       inherits <- base::inherits
[11:00:29.762]                       invokeRestart <- base::invokeRestart
[11:00:29.762]                       is.null <- base::is.null
[11:00:29.762]                       muffled <- FALSE
[11:00:29.762]                       if (inherits(cond, "message")) {
[11:00:29.762]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:29.762]                         if (muffled) 
[11:00:29.762]                           invokeRestart("muffleMessage")
[11:00:29.762]                       }
[11:00:29.762]                       else if (inherits(cond, "warning")) {
[11:00:29.762]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:29.762]                         if (muffled) 
[11:00:29.762]                           invokeRestart("muffleWarning")
[11:00:29.762]                       }
[11:00:29.762]                       else if (inherits(cond, "condition")) {
[11:00:29.762]                         if (!is.null(pattern)) {
[11:00:29.762]                           computeRestarts <- base::computeRestarts
[11:00:29.762]                           grepl <- base::grepl
[11:00:29.762]                           restarts <- computeRestarts(cond)
[11:00:29.762]                           for (restart in restarts) {
[11:00:29.762]                             name <- restart$name
[11:00:29.762]                             if (is.null(name)) 
[11:00:29.762]                               next
[11:00:29.762]                             if (!grepl(pattern, name)) 
[11:00:29.762]                               next
[11:00:29.762]                             invokeRestart(restart)
[11:00:29.762]                             muffled <- TRUE
[11:00:29.762]                             break
[11:00:29.762]                           }
[11:00:29.762]                         }
[11:00:29.762]                       }
[11:00:29.762]                       invisible(muffled)
[11:00:29.762]                     }
[11:00:29.762]                     muffleCondition(cond, pattern = "^muffle")
[11:00:29.762]                   }
[11:00:29.762]                 }
[11:00:29.762]                 else {
[11:00:29.762]                   if (TRUE) {
[11:00:29.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:29.762]                     {
[11:00:29.762]                       inherits <- base::inherits
[11:00:29.762]                       invokeRestart <- base::invokeRestart
[11:00:29.762]                       is.null <- base::is.null
[11:00:29.762]                       muffled <- FALSE
[11:00:29.762]                       if (inherits(cond, "message")) {
[11:00:29.762]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:29.762]                         if (muffled) 
[11:00:29.762]                           invokeRestart("muffleMessage")
[11:00:29.762]                       }
[11:00:29.762]                       else if (inherits(cond, "warning")) {
[11:00:29.762]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:29.762]                         if (muffled) 
[11:00:29.762]                           invokeRestart("muffleWarning")
[11:00:29.762]                       }
[11:00:29.762]                       else if (inherits(cond, "condition")) {
[11:00:29.762]                         if (!is.null(pattern)) {
[11:00:29.762]                           computeRestarts <- base::computeRestarts
[11:00:29.762]                           grepl <- base::grepl
[11:00:29.762]                           restarts <- computeRestarts(cond)
[11:00:29.762]                           for (restart in restarts) {
[11:00:29.762]                             name <- restart$name
[11:00:29.762]                             if (is.null(name)) 
[11:00:29.762]                               next
[11:00:29.762]                             if (!grepl(pattern, name)) 
[11:00:29.762]                               next
[11:00:29.762]                             invokeRestart(restart)
[11:00:29.762]                             muffled <- TRUE
[11:00:29.762]                             break
[11:00:29.762]                           }
[11:00:29.762]                         }
[11:00:29.762]                       }
[11:00:29.762]                       invisible(muffled)
[11:00:29.762]                     }
[11:00:29.762]                     muffleCondition(cond, pattern = "^muffle")
[11:00:29.762]                   }
[11:00:29.762]                 }
[11:00:29.762]             }
[11:00:29.762]         }))
[11:00:29.762]     }, error = function(ex) {
[11:00:29.762]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:29.762]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:29.762]                 ...future.rng), started = ...future.startTime, 
[11:00:29.762]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:29.762]             version = "1.8"), class = "FutureResult")
[11:00:29.762]     }, finally = {
[11:00:29.762]         if (!identical(...future.workdir, getwd())) 
[11:00:29.762]             setwd(...future.workdir)
[11:00:29.762]         {
[11:00:29.762]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:29.762]                 ...future.oldOptions$nwarnings <- NULL
[11:00:29.762]             }
[11:00:29.762]             base::options(...future.oldOptions)
[11:00:29.762]             if (.Platform$OS.type == "windows") {
[11:00:29.762]                 old_names <- names(...future.oldEnvVars)
[11:00:29.762]                 envs <- base::Sys.getenv()
[11:00:29.762]                 names <- names(envs)
[11:00:29.762]                 common <- intersect(names, old_names)
[11:00:29.762]                 added <- setdiff(names, old_names)
[11:00:29.762]                 removed <- setdiff(old_names, names)
[11:00:29.762]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:29.762]                   envs[common]]
[11:00:29.762]                 NAMES <- toupper(changed)
[11:00:29.762]                 args <- list()
[11:00:29.762]                 for (kk in seq_along(NAMES)) {
[11:00:29.762]                   name <- changed[[kk]]
[11:00:29.762]                   NAME <- NAMES[[kk]]
[11:00:29.762]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:29.762]                     next
[11:00:29.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:29.762]                 }
[11:00:29.762]                 NAMES <- toupper(added)
[11:00:29.762]                 for (kk in seq_along(NAMES)) {
[11:00:29.762]                   name <- added[[kk]]
[11:00:29.762]                   NAME <- NAMES[[kk]]
[11:00:29.762]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:29.762]                     next
[11:00:29.762]                   args[[name]] <- ""
[11:00:29.762]                 }
[11:00:29.762]                 NAMES <- toupper(removed)
[11:00:29.762]                 for (kk in seq_along(NAMES)) {
[11:00:29.762]                   name <- removed[[kk]]
[11:00:29.762]                   NAME <- NAMES[[kk]]
[11:00:29.762]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:29.762]                     next
[11:00:29.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:29.762]                 }
[11:00:29.762]                 if (length(args) > 0) 
[11:00:29.762]                   base::do.call(base::Sys.setenv, args = args)
[11:00:29.762]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:29.762]             }
[11:00:29.762]             else {
[11:00:29.762]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:29.762]             }
[11:00:29.762]             {
[11:00:29.762]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:29.762]                   0L) {
[11:00:29.762]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:29.762]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:29.762]                   base::options(opts)
[11:00:29.762]                 }
[11:00:29.762]                 {
[11:00:29.762]                   {
[11:00:29.762]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:29.762]                     NULL
[11:00:29.762]                   }
[11:00:29.762]                   options(future.plan = NULL)
[11:00:29.762]                   if (is.na(NA_character_)) 
[11:00:29.762]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:29.762]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:29.762]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:29.762]                     .init = FALSE)
[11:00:29.762]                 }
[11:00:29.762]             }
[11:00:29.762]         }
[11:00:29.762]     })
[11:00:29.762]     if (TRUE) {
[11:00:29.762]         base::sink(type = "output", split = FALSE)
[11:00:29.762]         if (TRUE) {
[11:00:29.762]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:29.762]         }
[11:00:29.762]         else {
[11:00:29.762]             ...future.result["stdout"] <- base::list(NULL)
[11:00:29.762]         }
[11:00:29.762]         base::close(...future.stdout)
[11:00:29.762]         ...future.stdout <- NULL
[11:00:29.762]     }
[11:00:29.762]     ...future.result$conditions <- ...future.conditions
[11:00:29.762]     ...future.result$finished <- base::Sys.time()
[11:00:29.762]     ...future.result
[11:00:29.762] }
[11:00:29.764] Exporting 5 global objects (1.63 KiB) to cluster node #2 ...
[11:00:29.765] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[11:00:29.765] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[11:00:29.765] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[11:00:29.765] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[11:00:29.766] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ...
[11:00:29.766] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ... DONE
[11:00:29.766] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[11:00:29.766] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[11:00:29.767] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[11:00:29.767] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[11:00:29.767] Exporting 5 global objects (1.63 KiB) to cluster node #2 ... DONE
[11:00:29.768] MultisessionFuture started
[11:00:29.768] - Launch lazy future ... done
[11:00:29.768] run() for ‘MultisessionFuture’ ... done
[11:00:29.768] Created future:
[11:00:29.768] MultisessionFuture:
[11:00:29.768] Label: ‘future_mapply-2’
[11:00:29.768] Expression:
[11:00:29.768] {
[11:00:29.768]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:29.768]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:29.768]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:29.768]         on.exit(options(oopts), add = TRUE)
[11:00:29.768]     }
[11:00:29.768]     {
[11:00:29.768]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:29.768]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:00:29.768]         do.call(mapply, args = args)
[11:00:29.768]     }
[11:00:29.768] }
[11:00:29.768] Lazy evaluation: FALSE
[11:00:29.768] Asynchronous evaluation: TRUE
[11:00:29.768] Local evaluation: TRUE
[11:00:29.768] Environment: R_GlobalEnv
[11:00:29.768] Capture standard output: TRUE
[11:00:29.768] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:29.768] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:29.768] Packages: <none>
[11:00:29.768] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:29.768] Resolved: FALSE
[11:00:29.768] Value: <not collected>
[11:00:29.768] Conditions captured: <none>
[11:00:29.768] Early signaling: FALSE
[11:00:29.768] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:29.768] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:29.779] Chunk #2 of 2 ... DONE
[11:00:29.779] Launching 2 futures (chunks) ... DONE
[11:00:29.779] Resolving 2 futures (chunks) ...
[11:00:29.780] resolve() on list ...
[11:00:29.780]  recursive: 0
[11:00:29.780]  length: 2
[11:00:29.780] 
[11:00:29.822] receiveMessageFromWorker() for ClusterFuture ...
[11:00:29.822] - Validating connection of MultisessionFuture
[11:00:29.822] - received message: FutureResult
[11:00:29.822] - Received FutureResult
[11:00:29.823] - Erased future from FutureRegistry
[11:00:29.823] result() for ClusterFuture ...
[11:00:29.823] - result already collected: FutureResult
[11:00:29.823] result() for ClusterFuture ... done
[11:00:29.823] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:29.823] Future #2
[11:00:29.823] result() for ClusterFuture ...
[11:00:29.823] - result already collected: FutureResult
[11:00:29.823] result() for ClusterFuture ... done
[11:00:29.823] result() for ClusterFuture ...
[11:00:29.824] - result already collected: FutureResult
[11:00:29.824] result() for ClusterFuture ... done
[11:00:29.824] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:00:29.824] - nx: 2
[11:00:29.824] - relay: TRUE
[11:00:29.824] - stdout: TRUE
[11:00:29.824] - signal: TRUE
[11:00:29.824] - resignal: FALSE
[11:00:29.824] - force: TRUE
[11:00:29.824] - relayed: [n=2] FALSE, FALSE
[11:00:29.824] - queued futures: [n=2] FALSE, FALSE
[11:00:29.824]  - until=1
[11:00:29.825]  - relaying element #1
[11:00:29.825] - relayed: [n=2] FALSE, FALSE
[11:00:29.825] - queued futures: [n=2] FALSE, TRUE
[11:00:29.825] signalConditionsASAP(NULL, pos=2) ... done
[11:00:29.825]  length: 1 (resolved future 2)
[11:00:30.273] receiveMessageFromWorker() for ClusterFuture ...
[11:00:30.273] - Validating connection of MultisessionFuture
[11:00:30.273] - received message: FutureResult
[11:00:30.274] - Received FutureResult
[11:00:30.274] - Erased future from FutureRegistry
[11:00:30.274] result() for ClusterFuture ...
[11:00:30.274] - result already collected: FutureResult
[11:00:30.274] result() for ClusterFuture ... done
[11:00:30.274] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:30.274] Future #1
[11:00:30.274] result() for ClusterFuture ...
[11:00:30.274] - result already collected: FutureResult
[11:00:30.274] result() for ClusterFuture ... done
[11:00:30.274] result() for ClusterFuture ...
[11:00:30.275] - result already collected: FutureResult
[11:00:30.275] result() for ClusterFuture ... done
[11:00:30.275] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:00:30.275] - nx: 2
[11:00:30.275] - relay: TRUE
[11:00:30.275] - stdout: TRUE
[11:00:30.275] - signal: TRUE
[11:00:30.275] - resignal: FALSE
[11:00:30.275] - force: TRUE
[11:00:30.275] - relayed: [n=2] FALSE, FALSE
[11:00:30.275] - queued futures: [n=2] FALSE, TRUE
[11:00:30.275]  - until=1
[11:00:30.275]  - relaying element #1
[11:00:30.276] result() for ClusterFuture ...
[11:00:30.276] - result already collected: FutureResult
[11:00:30.276] result() for ClusterFuture ... done
[11:00:30.276] result() for ClusterFuture ...
[11:00:30.276] - result already collected: FutureResult
[11:00:30.276] result() for ClusterFuture ... done
[11:00:30.276] result() for ClusterFuture ...
[11:00:30.276] - result already collected: FutureResult
[11:00:30.276] result() for ClusterFuture ... done
[11:00:30.276] result() for ClusterFuture ...
[11:00:30.276] - result already collected: FutureResult
[11:00:30.276] result() for ClusterFuture ... done
[11:00:30.277] - relayed: [n=2] TRUE, FALSE
[11:00:30.277] - queued futures: [n=2] TRUE, TRUE
[11:00:30.277] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:00:30.277]  length: 0 (resolved future 1)
[11:00:30.277] Relaying remaining futures
[11:00:30.277] signalConditionsASAP(NULL, pos=0) ...
[11:00:30.277] - nx: 2
[11:00:30.277] - relay: TRUE
[11:00:30.277] - stdout: TRUE
[11:00:30.277] - signal: TRUE
[11:00:30.277] - resignal: FALSE
[11:00:30.277] - force: TRUE
[11:00:30.277] - relayed: [n=2] TRUE, FALSE
[11:00:30.278] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:30.278]  - relaying element #2
[11:00:30.278] result() for ClusterFuture ...
[11:00:30.278] - result already collected: FutureResult
[11:00:30.278] result() for ClusterFuture ... done
[11:00:30.278] result() for ClusterFuture ...
[11:00:30.278] - result already collected: FutureResult
[11:00:30.278] result() for ClusterFuture ... done
[11:00:30.278] result() for ClusterFuture ...
[11:00:30.278] - result already collected: FutureResult
[11:00:30.278] result() for ClusterFuture ... done
[11:00:30.279] result() for ClusterFuture ...
[11:00:30.279] - result already collected: FutureResult
[11:00:30.279] result() for ClusterFuture ... done
[11:00:30.279] - relayed: [n=2] TRUE, TRUE
[11:00:30.279] - queued futures: [n=2] TRUE, TRUE
[11:00:30.279] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[11:00:30.279] resolve() on list ... DONE
[11:00:30.279] result() for ClusterFuture ...
[11:00:30.279] - result already collected: FutureResult
[11:00:30.279] result() for ClusterFuture ... done
[11:00:30.279] result() for ClusterFuture ...
[11:00:30.279] - result already collected: FutureResult
[11:00:30.279] result() for ClusterFuture ... done
[11:00:30.280] result() for ClusterFuture ...
[11:00:30.280] - result already collected: FutureResult
[11:00:30.280] result() for ClusterFuture ... done
[11:00:30.280] result() for ClusterFuture ...
[11:00:30.280] - result already collected: FutureResult
[11:00:30.280] result() for ClusterFuture ... done
[11:00:30.280]  - Number of value chunks collected: 2
[11:00:30.280] Resolving 2 futures (chunks) ... DONE
[11:00:30.280] Reducing values from 2 chunks ...
[11:00:30.280]  - Number of values collected after concatenation: 2
[11:00:30.280]  - Number of values expected: 2
[11:00:30.280] Reducing values from 2 chunks ... DONE
[11:00:30.281] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[11:00:30.281] future_mapply() ...
[11:00:30.283] Number of chunks: 2
[11:00:30.283] getGlobalsAndPackagesXApply() ...
[11:00:30.283]  - future.globals: TRUE
[11:00:30.283] getGlobalsAndPackages() ...
[11:00:30.283] Searching for globals...
[11:00:30.284] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[11:00:30.285] Searching for globals ... DONE
[11:00:30.285] Resolving globals: FALSE
[11:00:30.285] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[11:00:30.285] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[11:00:30.286] - globals: [1] ‘FUN’
[11:00:30.286] 
[11:00:30.286] getGlobalsAndPackages() ... DONE
[11:00:30.286]  - globals found/used: [n=1] ‘FUN’
[11:00:30.286]  - needed namespaces: [n=0] 
[11:00:30.286] Finding globals ... DONE
[11:00:30.286] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[11:00:30.286] List of 2
[11:00:30.286]  $ ...future.FUN:function (x, y)  
[11:00:30.286]  $ MoreArgs     : NULL
[11:00:30.286]  - attr(*, "where")=List of 2
[11:00:30.286]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:00:30.286]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[11:00:30.286]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:00:30.286]  - attr(*, "resolved")= logi FALSE
[11:00:30.286]  - attr(*, "total_size")= num NA
[11:00:30.289] Packages to be attached in all futures: [n=0] 
[11:00:30.289] getGlobalsAndPackagesXApply() ... DONE
[11:00:30.289] Number of futures (= number of chunks): 2
[11:00:30.289] Launching 2 futures (chunks) ...
[11:00:30.289] Chunk #1 of 2 ...
[11:00:30.289]  - Finding globals in '...' for chunk #1 ...
[11:00:30.289] getGlobalsAndPackages() ...
[11:00:30.289] Searching for globals...
[11:00:30.290] 
[11:00:30.290] Searching for globals ... DONE
[11:00:30.290] - globals: [0] <none>
[11:00:30.290] getGlobalsAndPackages() ... DONE
[11:00:30.290]    + additional globals found: [n=0] 
[11:00:30.290]    + additional namespaces needed: [n=0] 
[11:00:30.290]  - Finding globals in '...' for chunk #1 ... DONE
[11:00:30.290]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:30.290]  - seeds: <none>
[11:00:30.291]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:30.291] getGlobalsAndPackages() ...
[11:00:30.291] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:30.291] Resolving globals: FALSE
[11:00:30.291] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[11:00:30.292] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[11:00:30.294] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:30.294] 
[11:00:30.294] getGlobalsAndPackages() ... DONE
[11:00:30.294] run() for ‘Future’ ...
[11:00:30.294] - state: ‘created’
[11:00:30.294] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:30.309] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:30.309] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:30.309]   - Field: ‘node’
[11:00:30.309]   - Field: ‘label’
[11:00:30.309]   - Field: ‘local’
[11:00:30.310]   - Field: ‘owner’
[11:00:30.310]   - Field: ‘envir’
[11:00:30.310]   - Field: ‘workers’
[11:00:30.310]   - Field: ‘packages’
[11:00:30.310]   - Field: ‘gc’
[11:00:30.310]   - Field: ‘conditions’
[11:00:30.310]   - Field: ‘persistent’
[11:00:30.310]   - Field: ‘expr’
[11:00:30.310]   - Field: ‘uuid’
[11:00:30.310]   - Field: ‘seed’
[11:00:30.310]   - Field: ‘version’
[11:00:30.310]   - Field: ‘result’
[11:00:30.311]   - Field: ‘asynchronous’
[11:00:30.311]   - Field: ‘calls’
[11:00:30.311]   - Field: ‘globals’
[11:00:30.311]   - Field: ‘stdout’
[11:00:30.311]   - Field: ‘earlySignal’
[11:00:30.311]   - Field: ‘lazy’
[11:00:30.311]   - Field: ‘state’
[11:00:30.311] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:30.311] - Launch lazy future ...
[11:00:30.311] Packages needed by the future expression (n = 0): <none>
[11:00:30.312] Packages needed by future strategies (n = 0): <none>
[11:00:30.312] {
[11:00:30.312]     {
[11:00:30.312]         {
[11:00:30.312]             ...future.startTime <- base::Sys.time()
[11:00:30.312]             {
[11:00:30.312]                 {
[11:00:30.312]                   {
[11:00:30.312]                     {
[11:00:30.312]                       base::local({
[11:00:30.312]                         has_future <- base::requireNamespace("future", 
[11:00:30.312]                           quietly = TRUE)
[11:00:30.312]                         if (has_future) {
[11:00:30.312]                           ns <- base::getNamespace("future")
[11:00:30.312]                           version <- ns[[".package"]][["version"]]
[11:00:30.312]                           if (is.null(version)) 
[11:00:30.312]                             version <- utils::packageVersion("future")
[11:00:30.312]                         }
[11:00:30.312]                         else {
[11:00:30.312]                           version <- NULL
[11:00:30.312]                         }
[11:00:30.312]                         if (!has_future || version < "1.8.0") {
[11:00:30.312]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:30.312]                             "", base::R.version$version.string), 
[11:00:30.312]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:30.312]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:30.312]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:30.312]                               "release", "version")], collapse = " "), 
[11:00:30.312]                             hostname = base::Sys.info()[["nodename"]])
[11:00:30.312]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:30.312]                             info)
[11:00:30.312]                           info <- base::paste(info, collapse = "; ")
[11:00:30.312]                           if (!has_future) {
[11:00:30.312]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:30.312]                               info)
[11:00:30.312]                           }
[11:00:30.312]                           else {
[11:00:30.312]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:30.312]                               info, version)
[11:00:30.312]                           }
[11:00:30.312]                           base::stop(msg)
[11:00:30.312]                         }
[11:00:30.312]                       })
[11:00:30.312]                     }
[11:00:30.312]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:30.312]                     base::options(mc.cores = 1L)
[11:00:30.312]                   }
[11:00:30.312]                   ...future.strategy.old <- future::plan("list")
[11:00:30.312]                   options(future.plan = NULL)
[11:00:30.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:30.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:30.312]                 }
[11:00:30.312]                 ...future.workdir <- getwd()
[11:00:30.312]             }
[11:00:30.312]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:30.312]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:30.312]         }
[11:00:30.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:30.312]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:30.312]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:30.312]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:30.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:30.312]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:30.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:30.312]             base::names(...future.oldOptions))
[11:00:30.312]     }
[11:00:30.312]     if (TRUE) {
[11:00:30.312]     }
[11:00:30.312]     else {
[11:00:30.312]         if (NA) {
[11:00:30.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:30.312]                 open = "w")
[11:00:30.312]         }
[11:00:30.312]         else {
[11:00:30.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:30.312]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:30.312]         }
[11:00:30.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:30.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:30.312]             base::sink(type = "output", split = FALSE)
[11:00:30.312]             base::close(...future.stdout)
[11:00:30.312]         }, add = TRUE)
[11:00:30.312]     }
[11:00:30.312]     ...future.frame <- base::sys.nframe()
[11:00:30.312]     ...future.conditions <- base::list()
[11:00:30.312]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:30.312]     if (FALSE) {
[11:00:30.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:30.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:30.312]     }
[11:00:30.312]     ...future.result <- base::tryCatch({
[11:00:30.312]         base::withCallingHandlers({
[11:00:30.312]             ...future.value <- base::withVisible(base::local({
[11:00:30.312]                 ...future.makeSendCondition <- base::local({
[11:00:30.312]                   sendCondition <- NULL
[11:00:30.312]                   function(frame = 1L) {
[11:00:30.312]                     if (is.function(sendCondition)) 
[11:00:30.312]                       return(sendCondition)
[11:00:30.312]                     ns <- getNamespace("parallel")
[11:00:30.312]                     if (exists("sendData", mode = "function", 
[11:00:30.312]                       envir = ns)) {
[11:00:30.312]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:30.312]                         envir = ns)
[11:00:30.312]                       envir <- sys.frame(frame)
[11:00:30.312]                       master <- NULL
[11:00:30.312]                       while (!identical(envir, .GlobalEnv) && 
[11:00:30.312]                         !identical(envir, emptyenv())) {
[11:00:30.312]                         if (exists("master", mode = "list", envir = envir, 
[11:00:30.312]                           inherits = FALSE)) {
[11:00:30.312]                           master <- get("master", mode = "list", 
[11:00:30.312]                             envir = envir, inherits = FALSE)
[11:00:30.312]                           if (inherits(master, c("SOCKnode", 
[11:00:30.312]                             "SOCK0node"))) {
[11:00:30.312]                             sendCondition <<- function(cond) {
[11:00:30.312]                               data <- list(type = "VALUE", value = cond, 
[11:00:30.312]                                 success = TRUE)
[11:00:30.312]                               parallel_sendData(master, data)
[11:00:30.312]                             }
[11:00:30.312]                             return(sendCondition)
[11:00:30.312]                           }
[11:00:30.312]                         }
[11:00:30.312]                         frame <- frame + 1L
[11:00:30.312]                         envir <- sys.frame(frame)
[11:00:30.312]                       }
[11:00:30.312]                     }
[11:00:30.312]                     sendCondition <<- function(cond) NULL
[11:00:30.312]                   }
[11:00:30.312]                 })
[11:00:30.312]                 withCallingHandlers({
[11:00:30.312]                   {
[11:00:30.312]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:30.312]                     if (!identical(...future.globals.maxSize.org, 
[11:00:30.312]                       ...future.globals.maxSize)) {
[11:00:30.312]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:30.312]                       on.exit(options(oopts), add = TRUE)
[11:00:30.312]                     }
[11:00:30.312]                     {
[11:00:30.312]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:30.312]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:00:30.312]                         USE.NAMES = FALSE)
[11:00:30.312]                       do.call(mapply, args = args)
[11:00:30.312]                     }
[11:00:30.312]                   }
[11:00:30.312]                 }, immediateCondition = function(cond) {
[11:00:30.312]                   sendCondition <- ...future.makeSendCondition()
[11:00:30.312]                   sendCondition(cond)
[11:00:30.312]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:30.312]                   {
[11:00:30.312]                     inherits <- base::inherits
[11:00:30.312]                     invokeRestart <- base::invokeRestart
[11:00:30.312]                     is.null <- base::is.null
[11:00:30.312]                     muffled <- FALSE
[11:00:30.312]                     if (inherits(cond, "message")) {
[11:00:30.312]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:30.312]                       if (muffled) 
[11:00:30.312]                         invokeRestart("muffleMessage")
[11:00:30.312]                     }
[11:00:30.312]                     else if (inherits(cond, "warning")) {
[11:00:30.312]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:30.312]                       if (muffled) 
[11:00:30.312]                         invokeRestart("muffleWarning")
[11:00:30.312]                     }
[11:00:30.312]                     else if (inherits(cond, "condition")) {
[11:00:30.312]                       if (!is.null(pattern)) {
[11:00:30.312]                         computeRestarts <- base::computeRestarts
[11:00:30.312]                         grepl <- base::grepl
[11:00:30.312]                         restarts <- computeRestarts(cond)
[11:00:30.312]                         for (restart in restarts) {
[11:00:30.312]                           name <- restart$name
[11:00:30.312]                           if (is.null(name)) 
[11:00:30.312]                             next
[11:00:30.312]                           if (!grepl(pattern, name)) 
[11:00:30.312]                             next
[11:00:30.312]                           invokeRestart(restart)
[11:00:30.312]                           muffled <- TRUE
[11:00:30.312]                           break
[11:00:30.312]                         }
[11:00:30.312]                       }
[11:00:30.312]                     }
[11:00:30.312]                     invisible(muffled)
[11:00:30.312]                   }
[11:00:30.312]                   muffleCondition(cond)
[11:00:30.312]                 })
[11:00:30.312]             }))
[11:00:30.312]             future::FutureResult(value = ...future.value$value, 
[11:00:30.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:30.312]                   ...future.rng), globalenv = if (FALSE) 
[11:00:30.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:30.312]                     ...future.globalenv.names))
[11:00:30.312]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:30.312]         }, condition = base::local({
[11:00:30.312]             c <- base::c
[11:00:30.312]             inherits <- base::inherits
[11:00:30.312]             invokeRestart <- base::invokeRestart
[11:00:30.312]             length <- base::length
[11:00:30.312]             list <- base::list
[11:00:30.312]             seq.int <- base::seq.int
[11:00:30.312]             signalCondition <- base::signalCondition
[11:00:30.312]             sys.calls <- base::sys.calls
[11:00:30.312]             `[[` <- base::`[[`
[11:00:30.312]             `+` <- base::`+`
[11:00:30.312]             `<<-` <- base::`<<-`
[11:00:30.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:30.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:30.312]                   3L)]
[11:00:30.312]             }
[11:00:30.312]             function(cond) {
[11:00:30.312]                 is_error <- inherits(cond, "error")
[11:00:30.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:30.312]                   NULL)
[11:00:30.312]                 if (is_error) {
[11:00:30.312]                   sessionInformation <- function() {
[11:00:30.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:30.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:30.312]                       search = base::search(), system = base::Sys.info())
[11:00:30.312]                   }
[11:00:30.312]                   ...future.conditions[[length(...future.conditions) + 
[11:00:30.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:30.312]                     cond$call), session = sessionInformation(), 
[11:00:30.312]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:30.312]                   signalCondition(cond)
[11:00:30.312]                 }
[11:00:30.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:30.312]                 "immediateCondition"))) {
[11:00:30.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:30.312]                   ...future.conditions[[length(...future.conditions) + 
[11:00:30.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:30.312]                   if (TRUE && !signal) {
[11:00:30.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:30.312]                     {
[11:00:30.312]                       inherits <- base::inherits
[11:00:30.312]                       invokeRestart <- base::invokeRestart
[11:00:30.312]                       is.null <- base::is.null
[11:00:30.312]                       muffled <- FALSE
[11:00:30.312]                       if (inherits(cond, "message")) {
[11:00:30.312]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:30.312]                         if (muffled) 
[11:00:30.312]                           invokeRestart("muffleMessage")
[11:00:30.312]                       }
[11:00:30.312]                       else if (inherits(cond, "warning")) {
[11:00:30.312]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:30.312]                         if (muffled) 
[11:00:30.312]                           invokeRestart("muffleWarning")
[11:00:30.312]                       }
[11:00:30.312]                       else if (inherits(cond, "condition")) {
[11:00:30.312]                         if (!is.null(pattern)) {
[11:00:30.312]                           computeRestarts <- base::computeRestarts
[11:00:30.312]                           grepl <- base::grepl
[11:00:30.312]                           restarts <- computeRestarts(cond)
[11:00:30.312]                           for (restart in restarts) {
[11:00:30.312]                             name <- restart$name
[11:00:30.312]                             if (is.null(name)) 
[11:00:30.312]                               next
[11:00:30.312]                             if (!grepl(pattern, name)) 
[11:00:30.312]                               next
[11:00:30.312]                             invokeRestart(restart)
[11:00:30.312]                             muffled <- TRUE
[11:00:30.312]                             break
[11:00:30.312]                           }
[11:00:30.312]                         }
[11:00:30.312]                       }
[11:00:30.312]                       invisible(muffled)
[11:00:30.312]                     }
[11:00:30.312]                     muffleCondition(cond, pattern = "^muffle")
[11:00:30.312]                   }
[11:00:30.312]                 }
[11:00:30.312]                 else {
[11:00:30.312]                   if (TRUE) {
[11:00:30.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:30.312]                     {
[11:00:30.312]                       inherits <- base::inherits
[11:00:30.312]                       invokeRestart <- base::invokeRestart
[11:00:30.312]                       is.null <- base::is.null
[11:00:30.312]                       muffled <- FALSE
[11:00:30.312]                       if (inherits(cond, "message")) {
[11:00:30.312]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:30.312]                         if (muffled) 
[11:00:30.312]                           invokeRestart("muffleMessage")
[11:00:30.312]                       }
[11:00:30.312]                       else if (inherits(cond, "warning")) {
[11:00:30.312]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:30.312]                         if (muffled) 
[11:00:30.312]                           invokeRestart("muffleWarning")
[11:00:30.312]                       }
[11:00:30.312]                       else if (inherits(cond, "condition")) {
[11:00:30.312]                         if (!is.null(pattern)) {
[11:00:30.312]                           computeRestarts <- base::computeRestarts
[11:00:30.312]                           grepl <- base::grepl
[11:00:30.312]                           restarts <- computeRestarts(cond)
[11:00:30.312]                           for (restart in restarts) {
[11:00:30.312]                             name <- restart$name
[11:00:30.312]                             if (is.null(name)) 
[11:00:30.312]                               next
[11:00:30.312]                             if (!grepl(pattern, name)) 
[11:00:30.312]                               next
[11:00:30.312]                             invokeRestart(restart)
[11:00:30.312]                             muffled <- TRUE
[11:00:30.312]                             break
[11:00:30.312]                           }
[11:00:30.312]                         }
[11:00:30.312]                       }
[11:00:30.312]                       invisible(muffled)
[11:00:30.312]                     }
[11:00:30.312]                     muffleCondition(cond, pattern = "^muffle")
[11:00:30.312]                   }
[11:00:30.312]                 }
[11:00:30.312]             }
[11:00:30.312]         }))
[11:00:30.312]     }, error = function(ex) {
[11:00:30.312]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:30.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:30.312]                 ...future.rng), started = ...future.startTime, 
[11:00:30.312]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:30.312]             version = "1.8"), class = "FutureResult")
[11:00:30.312]     }, finally = {
[11:00:30.312]         if (!identical(...future.workdir, getwd())) 
[11:00:30.312]             setwd(...future.workdir)
[11:00:30.312]         {
[11:00:30.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:30.312]                 ...future.oldOptions$nwarnings <- NULL
[11:00:30.312]             }
[11:00:30.312]             base::options(...future.oldOptions)
[11:00:30.312]             if (.Platform$OS.type == "windows") {
[11:00:30.312]                 old_names <- names(...future.oldEnvVars)
[11:00:30.312]                 envs <- base::Sys.getenv()
[11:00:30.312]                 names <- names(envs)
[11:00:30.312]                 common <- intersect(names, old_names)
[11:00:30.312]                 added <- setdiff(names, old_names)
[11:00:30.312]                 removed <- setdiff(old_names, names)
[11:00:30.312]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:30.312]                   envs[common]]
[11:00:30.312]                 NAMES <- toupper(changed)
[11:00:30.312]                 args <- list()
[11:00:30.312]                 for (kk in seq_along(NAMES)) {
[11:00:30.312]                   name <- changed[[kk]]
[11:00:30.312]                   NAME <- NAMES[[kk]]
[11:00:30.312]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:30.312]                     next
[11:00:30.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:30.312]                 }
[11:00:30.312]                 NAMES <- toupper(added)
[11:00:30.312]                 for (kk in seq_along(NAMES)) {
[11:00:30.312]                   name <- added[[kk]]
[11:00:30.312]                   NAME <- NAMES[[kk]]
[11:00:30.312]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:30.312]                     next
[11:00:30.312]                   args[[name]] <- ""
[11:00:30.312]                 }
[11:00:30.312]                 NAMES <- toupper(removed)
[11:00:30.312]                 for (kk in seq_along(NAMES)) {
[11:00:30.312]                   name <- removed[[kk]]
[11:00:30.312]                   NAME <- NAMES[[kk]]
[11:00:30.312]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:30.312]                     next
[11:00:30.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:30.312]                 }
[11:00:30.312]                 if (length(args) > 0) 
[11:00:30.312]                   base::do.call(base::Sys.setenv, args = args)
[11:00:30.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:30.312]             }
[11:00:30.312]             else {
[11:00:30.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:30.312]             }
[11:00:30.312]             {
[11:00:30.312]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:30.312]                   0L) {
[11:00:30.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:30.312]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:30.312]                   base::options(opts)
[11:00:30.312]                 }
[11:00:30.312]                 {
[11:00:30.312]                   {
[11:00:30.312]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:30.312]                     NULL
[11:00:30.312]                   }
[11:00:30.312]                   options(future.plan = NULL)
[11:00:30.312]                   if (is.na(NA_character_)) 
[11:00:30.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:30.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:30.312]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:30.312]                     .init = FALSE)
[11:00:30.312]                 }
[11:00:30.312]             }
[11:00:30.312]         }
[11:00:30.312]     })
[11:00:30.312]     if (FALSE) {
[11:00:30.312]         base::sink(type = "output", split = FALSE)
[11:00:30.312]         if (NA) {
[11:00:30.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:30.312]         }
[11:00:30.312]         else {
[11:00:30.312]             ...future.result["stdout"] <- base::list(NULL)
[11:00:30.312]         }
[11:00:30.312]         base::close(...future.stdout)
[11:00:30.312]         ...future.stdout <- NULL
[11:00:30.312]     }
[11:00:30.312]     ...future.result$conditions <- ...future.conditions
[11:00:30.312]     ...future.result$finished <- base::Sys.time()
[11:00:30.312]     ...future.result
[11:00:30.312] }
[11:00:30.315] Exporting 5 global objects (1.63 KiB) to cluster node #1 ...
[11:00:30.315] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[11:00:30.315] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[11:00:30.315] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[11:00:30.316] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[11:00:30.316] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ...
[11:00:30.316] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ... DONE
[11:00:30.316] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[11:00:30.316] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[11:00:30.317] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[11:00:30.317] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[11:00:30.317] Exporting 5 global objects (1.63 KiB) to cluster node #1 ... DONE
[11:00:30.317] MultisessionFuture started
[11:00:30.318] - Launch lazy future ... done
[11:00:30.318] run() for ‘MultisessionFuture’ ... done
[11:00:30.318] Created future:
[11:00:30.318] MultisessionFuture:
[11:00:30.318] Label: ‘future_mapply-1’
[11:00:30.318] Expression:
[11:00:30.318] {
[11:00:30.318]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:30.318]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:30.318]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:30.318]         on.exit(options(oopts), add = TRUE)
[11:00:30.318]     }
[11:00:30.318]     {
[11:00:30.318]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:30.318]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:00:30.318]         do.call(mapply, args = args)
[11:00:30.318]     }
[11:00:30.318] }
[11:00:30.318] Lazy evaluation: FALSE
[11:00:30.318] Asynchronous evaluation: TRUE
[11:00:30.318] Local evaluation: TRUE
[11:00:30.318] Environment: R_GlobalEnv
[11:00:30.318] Capture standard output: NA
[11:00:30.318] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:30.318] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:30.318] Packages: <none>
[11:00:30.318] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:30.318] Resolved: FALSE
[11:00:30.318] Value: <not collected>
[11:00:30.318] Conditions captured: <none>
[11:00:30.318] Early signaling: FALSE
[11:00:30.318] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:30.318] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:30.329] Chunk #1 of 2 ... DONE
[11:00:30.329] Chunk #2 of 2 ...
[11:00:30.329]  - Finding globals in '...' for chunk #2 ...
[11:00:30.330] getGlobalsAndPackages() ...
[11:00:30.330] Searching for globals...
[11:00:30.330] 
[11:00:30.330] Searching for globals ... DONE
[11:00:30.330] - globals: [0] <none>
[11:00:30.330] getGlobalsAndPackages() ... DONE
[11:00:30.330]    + additional globals found: [n=0] 
[11:00:30.330]    + additional namespaces needed: [n=0] 
[11:00:30.330]  - Finding globals in '...' for chunk #2 ... DONE
[11:00:30.331]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[11:00:30.331]  - seeds: <none>
[11:00:30.331]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:30.331] getGlobalsAndPackages() ...
[11:00:30.331] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:30.331] Resolving globals: FALSE
[11:00:30.331] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[11:00:30.332] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[11:00:30.332] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:00:30.332] 
[11:00:30.332] getGlobalsAndPackages() ... DONE
[11:00:30.332] run() for ‘Future’ ...
[11:00:30.332] - state: ‘created’
[11:00:30.333] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:00:30.347] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:30.347] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:00:30.347]   - Field: ‘node’
[11:00:30.347]   - Field: ‘label’
[11:00:30.347]   - Field: ‘local’
[11:00:30.347]   - Field: ‘owner’
[11:00:30.347]   - Field: ‘envir’
[11:00:30.347]   - Field: ‘workers’
[11:00:30.347]   - Field: ‘packages’
[11:00:30.347]   - Field: ‘gc’
[11:00:30.347]   - Field: ‘conditions’
[11:00:30.348]   - Field: ‘persistent’
[11:00:30.348]   - Field: ‘expr’
[11:00:30.348]   - Field: ‘uuid’
[11:00:30.348]   - Field: ‘seed’
[11:00:30.348]   - Field: ‘version’
[11:00:30.348]   - Field: ‘result’
[11:00:30.348]   - Field: ‘asynchronous’
[11:00:30.348]   - Field: ‘calls’
[11:00:30.348]   - Field: ‘globals’
[11:00:30.348]   - Field: ‘stdout’
[11:00:30.348]   - Field: ‘earlySignal’
[11:00:30.348]   - Field: ‘lazy’
[11:00:30.349]   - Field: ‘state’
[11:00:30.349] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:00:30.349] - Launch lazy future ...
[11:00:30.349] Packages needed by the future expression (n = 0): <none>
[11:00:30.349] Packages needed by future strategies (n = 0): <none>
[11:00:30.349] {
[11:00:30.349]     {
[11:00:30.349]         {
[11:00:30.349]             ...future.startTime <- base::Sys.time()
[11:00:30.349]             {
[11:00:30.349]                 {
[11:00:30.349]                   {
[11:00:30.349]                     {
[11:00:30.349]                       base::local({
[11:00:30.349]                         has_future <- base::requireNamespace("future", 
[11:00:30.349]                           quietly = TRUE)
[11:00:30.349]                         if (has_future) {
[11:00:30.349]                           ns <- base::getNamespace("future")
[11:00:30.349]                           version <- ns[[".package"]][["version"]]
[11:00:30.349]                           if (is.null(version)) 
[11:00:30.349]                             version <- utils::packageVersion("future")
[11:00:30.349]                         }
[11:00:30.349]                         else {
[11:00:30.349]                           version <- NULL
[11:00:30.349]                         }
[11:00:30.349]                         if (!has_future || version < "1.8.0") {
[11:00:30.349]                           info <- base::c(r_version = base::gsub("R version ", 
[11:00:30.349]                             "", base::R.version$version.string), 
[11:00:30.349]                             platform = base::sprintf("%s (%s-bit)", 
[11:00:30.349]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:00:30.349]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:00:30.349]                               "release", "version")], collapse = " "), 
[11:00:30.349]                             hostname = base::Sys.info()[["nodename"]])
[11:00:30.349]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:00:30.349]                             info)
[11:00:30.349]                           info <- base::paste(info, collapse = "; ")
[11:00:30.349]                           if (!has_future) {
[11:00:30.349]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:00:30.349]                               info)
[11:00:30.349]                           }
[11:00:30.349]                           else {
[11:00:30.349]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:00:30.349]                               info, version)
[11:00:30.349]                           }
[11:00:30.349]                           base::stop(msg)
[11:00:30.349]                         }
[11:00:30.349]                       })
[11:00:30.349]                     }
[11:00:30.349]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:00:30.349]                     base::options(mc.cores = 1L)
[11:00:30.349]                   }
[11:00:30.349]                   ...future.strategy.old <- future::plan("list")
[11:00:30.349]                   options(future.plan = NULL)
[11:00:30.349]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:00:30.349]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:00:30.349]                 }
[11:00:30.349]                 ...future.workdir <- getwd()
[11:00:30.349]             }
[11:00:30.349]             ...future.oldOptions <- base::as.list(base::.Options)
[11:00:30.349]             ...future.oldEnvVars <- base::Sys.getenv()
[11:00:30.349]         }
[11:00:30.349]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:00:30.349]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[11:00:30.349]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:00:30.349]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:00:30.349]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:00:30.349]             future.stdout.windows.reencode = NULL, width = 80L)
[11:00:30.349]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:00:30.349]             base::names(...future.oldOptions))
[11:00:30.349]     }
[11:00:30.349]     if (TRUE) {
[11:00:30.349]     }
[11:00:30.349]     else {
[11:00:30.349]         if (NA) {
[11:00:30.349]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:00:30.349]                 open = "w")
[11:00:30.349]         }
[11:00:30.349]         else {
[11:00:30.349]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:00:30.349]                 windows = "NUL", "/dev/null"), open = "w")
[11:00:30.349]         }
[11:00:30.349]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:00:30.349]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:00:30.349]             base::sink(type = "output", split = FALSE)
[11:00:30.349]             base::close(...future.stdout)
[11:00:30.349]         }, add = TRUE)
[11:00:30.349]     }
[11:00:30.349]     ...future.frame <- base::sys.nframe()
[11:00:30.349]     ...future.conditions <- base::list()
[11:00:30.349]     ...future.rng <- base::globalenv()$.Random.seed
[11:00:30.349]     if (FALSE) {
[11:00:30.349]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:00:30.349]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:00:30.349]     }
[11:00:30.349]     ...future.result <- base::tryCatch({
[11:00:30.349]         base::withCallingHandlers({
[11:00:30.349]             ...future.value <- base::withVisible(base::local({
[11:00:30.349]                 ...future.makeSendCondition <- base::local({
[11:00:30.349]                   sendCondition <- NULL
[11:00:30.349]                   function(frame = 1L) {
[11:00:30.349]                     if (is.function(sendCondition)) 
[11:00:30.349]                       return(sendCondition)
[11:00:30.349]                     ns <- getNamespace("parallel")
[11:00:30.349]                     if (exists("sendData", mode = "function", 
[11:00:30.349]                       envir = ns)) {
[11:00:30.349]                       parallel_sendData <- get("sendData", mode = "function", 
[11:00:30.349]                         envir = ns)
[11:00:30.349]                       envir <- sys.frame(frame)
[11:00:30.349]                       master <- NULL
[11:00:30.349]                       while (!identical(envir, .GlobalEnv) && 
[11:00:30.349]                         !identical(envir, emptyenv())) {
[11:00:30.349]                         if (exists("master", mode = "list", envir = envir, 
[11:00:30.349]                           inherits = FALSE)) {
[11:00:30.349]                           master <- get("master", mode = "list", 
[11:00:30.349]                             envir = envir, inherits = FALSE)
[11:00:30.349]                           if (inherits(master, c("SOCKnode", 
[11:00:30.349]                             "SOCK0node"))) {
[11:00:30.349]                             sendCondition <<- function(cond) {
[11:00:30.349]                               data <- list(type = "VALUE", value = cond, 
[11:00:30.349]                                 success = TRUE)
[11:00:30.349]                               parallel_sendData(master, data)
[11:00:30.349]                             }
[11:00:30.349]                             return(sendCondition)
[11:00:30.349]                           }
[11:00:30.349]                         }
[11:00:30.349]                         frame <- frame + 1L
[11:00:30.349]                         envir <- sys.frame(frame)
[11:00:30.349]                       }
[11:00:30.349]                     }
[11:00:30.349]                     sendCondition <<- function(cond) NULL
[11:00:30.349]                   }
[11:00:30.349]                 })
[11:00:30.349]                 withCallingHandlers({
[11:00:30.349]                   {
[11:00:30.349]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:30.349]                     if (!identical(...future.globals.maxSize.org, 
[11:00:30.349]                       ...future.globals.maxSize)) {
[11:00:30.349]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:30.349]                       on.exit(options(oopts), add = TRUE)
[11:00:30.349]                     }
[11:00:30.349]                     {
[11:00:30.349]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:30.349]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:00:30.349]                         USE.NAMES = FALSE)
[11:00:30.349]                       do.call(mapply, args = args)
[11:00:30.349]                     }
[11:00:30.349]                   }
[11:00:30.349]                 }, immediateCondition = function(cond) {
[11:00:30.349]                   sendCondition <- ...future.makeSendCondition()
[11:00:30.349]                   sendCondition(cond)
[11:00:30.349]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:30.349]                   {
[11:00:30.349]                     inherits <- base::inherits
[11:00:30.349]                     invokeRestart <- base::invokeRestart
[11:00:30.349]                     is.null <- base::is.null
[11:00:30.349]                     muffled <- FALSE
[11:00:30.349]                     if (inherits(cond, "message")) {
[11:00:30.349]                       muffled <- grepl(pattern, "muffleMessage")
[11:00:30.349]                       if (muffled) 
[11:00:30.349]                         invokeRestart("muffleMessage")
[11:00:30.349]                     }
[11:00:30.349]                     else if (inherits(cond, "warning")) {
[11:00:30.349]                       muffled <- grepl(pattern, "muffleWarning")
[11:00:30.349]                       if (muffled) 
[11:00:30.349]                         invokeRestart("muffleWarning")
[11:00:30.349]                     }
[11:00:30.349]                     else if (inherits(cond, "condition")) {
[11:00:30.349]                       if (!is.null(pattern)) {
[11:00:30.349]                         computeRestarts <- base::computeRestarts
[11:00:30.349]                         grepl <- base::grepl
[11:00:30.349]                         restarts <- computeRestarts(cond)
[11:00:30.349]                         for (restart in restarts) {
[11:00:30.349]                           name <- restart$name
[11:00:30.349]                           if (is.null(name)) 
[11:00:30.349]                             next
[11:00:30.349]                           if (!grepl(pattern, name)) 
[11:00:30.349]                             next
[11:00:30.349]                           invokeRestart(restart)
[11:00:30.349]                           muffled <- TRUE
[11:00:30.349]                           break
[11:00:30.349]                         }
[11:00:30.349]                       }
[11:00:30.349]                     }
[11:00:30.349]                     invisible(muffled)
[11:00:30.349]                   }
[11:00:30.349]                   muffleCondition(cond)
[11:00:30.349]                 })
[11:00:30.349]             }))
[11:00:30.349]             future::FutureResult(value = ...future.value$value, 
[11:00:30.349]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:30.349]                   ...future.rng), globalenv = if (FALSE) 
[11:00:30.349]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:00:30.349]                     ...future.globalenv.names))
[11:00:30.349]                 else NULL, started = ...future.startTime, version = "1.8")
[11:00:30.349]         }, condition = base::local({
[11:00:30.349]             c <- base::c
[11:00:30.349]             inherits <- base::inherits
[11:00:30.349]             invokeRestart <- base::invokeRestart
[11:00:30.349]             length <- base::length
[11:00:30.349]             list <- base::list
[11:00:30.349]             seq.int <- base::seq.int
[11:00:30.349]             signalCondition <- base::signalCondition
[11:00:30.349]             sys.calls <- base::sys.calls
[11:00:30.349]             `[[` <- base::`[[`
[11:00:30.349]             `+` <- base::`+`
[11:00:30.349]             `<<-` <- base::`<<-`
[11:00:30.349]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:00:30.349]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:00:30.349]                   3L)]
[11:00:30.349]             }
[11:00:30.349]             function(cond) {
[11:00:30.349]                 is_error <- inherits(cond, "error")
[11:00:30.349]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:00:30.349]                   NULL)
[11:00:30.349]                 if (is_error) {
[11:00:30.349]                   sessionInformation <- function() {
[11:00:30.349]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:00:30.349]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:00:30.349]                       search = base::search(), system = base::Sys.info())
[11:00:30.349]                   }
[11:00:30.349]                   ...future.conditions[[length(...future.conditions) + 
[11:00:30.349]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:00:30.349]                     cond$call), session = sessionInformation(), 
[11:00:30.349]                     timestamp = base::Sys.time(), signaled = 0L)
[11:00:30.349]                   signalCondition(cond)
[11:00:30.349]                 }
[11:00:30.349]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:00:30.349]                 "immediateCondition"))) {
[11:00:30.349]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:00:30.349]                   ...future.conditions[[length(...future.conditions) + 
[11:00:30.349]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:00:30.349]                   if (TRUE && !signal) {
[11:00:30.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:30.349]                     {
[11:00:30.349]                       inherits <- base::inherits
[11:00:30.349]                       invokeRestart <- base::invokeRestart
[11:00:30.349]                       is.null <- base::is.null
[11:00:30.349]                       muffled <- FALSE
[11:00:30.349]                       if (inherits(cond, "message")) {
[11:00:30.349]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:30.349]                         if (muffled) 
[11:00:30.349]                           invokeRestart("muffleMessage")
[11:00:30.349]                       }
[11:00:30.349]                       else if (inherits(cond, "warning")) {
[11:00:30.349]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:30.349]                         if (muffled) 
[11:00:30.349]                           invokeRestart("muffleWarning")
[11:00:30.349]                       }
[11:00:30.349]                       else if (inherits(cond, "condition")) {
[11:00:30.349]                         if (!is.null(pattern)) {
[11:00:30.349]                           computeRestarts <- base::computeRestarts
[11:00:30.349]                           grepl <- base::grepl
[11:00:30.349]                           restarts <- computeRestarts(cond)
[11:00:30.349]                           for (restart in restarts) {
[11:00:30.349]                             name <- restart$name
[11:00:30.349]                             if (is.null(name)) 
[11:00:30.349]                               next
[11:00:30.349]                             if (!grepl(pattern, name)) 
[11:00:30.349]                               next
[11:00:30.349]                             invokeRestart(restart)
[11:00:30.349]                             muffled <- TRUE
[11:00:30.349]                             break
[11:00:30.349]                           }
[11:00:30.349]                         }
[11:00:30.349]                       }
[11:00:30.349]                       invisible(muffled)
[11:00:30.349]                     }
[11:00:30.349]                     muffleCondition(cond, pattern = "^muffle")
[11:00:30.349]                   }
[11:00:30.349]                 }
[11:00:30.349]                 else {
[11:00:30.349]                   if (TRUE) {
[11:00:30.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:00:30.349]                     {
[11:00:30.349]                       inherits <- base::inherits
[11:00:30.349]                       invokeRestart <- base::invokeRestart
[11:00:30.349]                       is.null <- base::is.null
[11:00:30.349]                       muffled <- FALSE
[11:00:30.349]                       if (inherits(cond, "message")) {
[11:00:30.349]                         muffled <- grepl(pattern, "muffleMessage")
[11:00:30.349]                         if (muffled) 
[11:00:30.349]                           invokeRestart("muffleMessage")
[11:00:30.349]                       }
[11:00:30.349]                       else if (inherits(cond, "warning")) {
[11:00:30.349]                         muffled <- grepl(pattern, "muffleWarning")
[11:00:30.349]                         if (muffled) 
[11:00:30.349]                           invokeRestart("muffleWarning")
[11:00:30.349]                       }
[11:00:30.349]                       else if (inherits(cond, "condition")) {
[11:00:30.349]                         if (!is.null(pattern)) {
[11:00:30.349]                           computeRestarts <- base::computeRestarts
[11:00:30.349]                           grepl <- base::grepl
[11:00:30.349]                           restarts <- computeRestarts(cond)
[11:00:30.349]                           for (restart in restarts) {
[11:00:30.349]                             name <- restart$name
[11:00:30.349]                             if (is.null(name)) 
[11:00:30.349]                               next
[11:00:30.349]                             if (!grepl(pattern, name)) 
[11:00:30.349]                               next
[11:00:30.349]                             invokeRestart(restart)
[11:00:30.349]                             muffled <- TRUE
[11:00:30.349]                             break
[11:00:30.349]                           }
[11:00:30.349]                         }
[11:00:30.349]                       }
[11:00:30.349]                       invisible(muffled)
[11:00:30.349]                     }
[11:00:30.349]                     muffleCondition(cond, pattern = "^muffle")
[11:00:30.349]                   }
[11:00:30.349]                 }
[11:00:30.349]             }
[11:00:30.349]         }))
[11:00:30.349]     }, error = function(ex) {
[11:00:30.349]         base::structure(base::list(value = NULL, visible = NULL, 
[11:00:30.349]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:00:30.349]                 ...future.rng), started = ...future.startTime, 
[11:00:30.349]             finished = Sys.time(), session_uuid = NA_character_, 
[11:00:30.349]             version = "1.8"), class = "FutureResult")
[11:00:30.349]     }, finally = {
[11:00:30.349]         if (!identical(...future.workdir, getwd())) 
[11:00:30.349]             setwd(...future.workdir)
[11:00:30.349]         {
[11:00:30.349]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:00:30.349]                 ...future.oldOptions$nwarnings <- NULL
[11:00:30.349]             }
[11:00:30.349]             base::options(...future.oldOptions)
[11:00:30.349]             if (.Platform$OS.type == "windows") {
[11:00:30.349]                 old_names <- names(...future.oldEnvVars)
[11:00:30.349]                 envs <- base::Sys.getenv()
[11:00:30.349]                 names <- names(envs)
[11:00:30.349]                 common <- intersect(names, old_names)
[11:00:30.349]                 added <- setdiff(names, old_names)
[11:00:30.349]                 removed <- setdiff(old_names, names)
[11:00:30.349]                 changed <- common[...future.oldEnvVars[common] != 
[11:00:30.349]                   envs[common]]
[11:00:30.349]                 NAMES <- toupper(changed)
[11:00:30.349]                 args <- list()
[11:00:30.349]                 for (kk in seq_along(NAMES)) {
[11:00:30.349]                   name <- changed[[kk]]
[11:00:30.349]                   NAME <- NAMES[[kk]]
[11:00:30.349]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:30.349]                     next
[11:00:30.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:30.349]                 }
[11:00:30.349]                 NAMES <- toupper(added)
[11:00:30.349]                 for (kk in seq_along(NAMES)) {
[11:00:30.349]                   name <- added[[kk]]
[11:00:30.349]                   NAME <- NAMES[[kk]]
[11:00:30.349]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:30.349]                     next
[11:00:30.349]                   args[[name]] <- ""
[11:00:30.349]                 }
[11:00:30.349]                 NAMES <- toupper(removed)
[11:00:30.349]                 for (kk in seq_along(NAMES)) {
[11:00:30.349]                   name <- removed[[kk]]
[11:00:30.349]                   NAME <- NAMES[[kk]]
[11:00:30.349]                   if (name != NAME && is.element(NAME, old_names)) 
[11:00:30.349]                     next
[11:00:30.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:00:30.349]                 }
[11:00:30.349]                 if (length(args) > 0) 
[11:00:30.349]                   base::do.call(base::Sys.setenv, args = args)
[11:00:30.349]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:00:30.349]             }
[11:00:30.349]             else {
[11:00:30.349]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:00:30.349]             }
[11:00:30.349]             {
[11:00:30.349]                 if (base::length(...future.futureOptionsAdded) > 
[11:00:30.349]                   0L) {
[11:00:30.349]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:00:30.349]                   base::names(opts) <- ...future.futureOptionsAdded
[11:00:30.349]                   base::options(opts)
[11:00:30.349]                 }
[11:00:30.349]                 {
[11:00:30.349]                   {
[11:00:30.349]                     base::options(mc.cores = ...future.mc.cores.old)
[11:00:30.349]                     NULL
[11:00:30.349]                   }
[11:00:30.349]                   options(future.plan = NULL)
[11:00:30.349]                   if (is.na(NA_character_)) 
[11:00:30.349]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:00:30.349]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:00:30.349]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:00:30.349]                     .init = FALSE)
[11:00:30.349]                 }
[11:00:30.349]             }
[11:00:30.349]         }
[11:00:30.349]     })
[11:00:30.349]     if (FALSE) {
[11:00:30.349]         base::sink(type = "output", split = FALSE)
[11:00:30.349]         if (NA) {
[11:00:30.349]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:00:30.349]         }
[11:00:30.349]         else {
[11:00:30.349]             ...future.result["stdout"] <- base::list(NULL)
[11:00:30.349]         }
[11:00:30.349]         base::close(...future.stdout)
[11:00:30.349]         ...future.stdout <- NULL
[11:00:30.349]     }
[11:00:30.349]     ...future.result$conditions <- ...future.conditions
[11:00:30.349]     ...future.result$finished <- base::Sys.time()
[11:00:30.349]     ...future.result
[11:00:30.349] }
[11:00:30.352] Exporting 5 global objects (1.63 KiB) to cluster node #2 ...
[11:00:30.352] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[11:00:30.353] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[11:00:30.353] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[11:00:30.353] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[11:00:30.353] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ...
[11:00:30.354] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ... DONE
[11:00:30.354] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[11:00:30.354] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[11:00:30.354] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[11:00:30.355] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[11:00:30.355] Exporting 5 global objects (1.63 KiB) to cluster node #2 ... DONE
[11:00:30.355] MultisessionFuture started
[11:00:30.355] - Launch lazy future ... done
[11:00:30.355] run() for ‘MultisessionFuture’ ... done
[11:00:30.356] Created future:
[11:00:30.356] MultisessionFuture:
[11:00:30.356] Label: ‘future_mapply-2’
[11:00:30.356] Expression:
[11:00:30.356] {
[11:00:30.356]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:00:30.356]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:00:30.356]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:00:30.356]         on.exit(options(oopts), add = TRUE)
[11:00:30.356]     }
[11:00:30.356]     {
[11:00:30.356]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[11:00:30.356]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:00:30.356]         do.call(mapply, args = args)
[11:00:30.356]     }
[11:00:30.356] }
[11:00:30.356] Lazy evaluation: FALSE
[11:00:30.356] Asynchronous evaluation: TRUE
[11:00:30.356] Local evaluation: TRUE
[11:00:30.356] Environment: R_GlobalEnv
[11:00:30.356] Capture standard output: NA
[11:00:30.356] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:00:30.356] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[11:00:30.356] Packages: <none>
[11:00:30.356] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[11:00:30.356] Resolved: FALSE
[11:00:30.356] Value: <not collected>
[11:00:30.356] Conditions captured: <none>
[11:00:30.356] Early signaling: FALSE
[11:00:30.356] Owner process: a229dad1-edc1-d00d-d29b-68964695864f
[11:00:30.356] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:00:30.367] Chunk #2 of 2 ... DONE
[11:00:30.367] Launching 2 futures (chunks) ... DONE
[11:00:30.367] Resolving 2 futures (chunks) ...
[11:00:30.367] resolve() on list ...
[11:00:30.367]  recursive: 0
[11:00:30.368]  length: 2
[11:00:30.368] 
[11:00:30.410] receiveMessageFromWorker() for ClusterFuture ...
[11:00:30.410] - Validating connection of MultisessionFuture
[11:00:30.410] - received message: FutureResult
[11:00:30.410] - Received FutureResult
[11:00:30.410] - Erased future from FutureRegistry
[11:00:30.410] result() for ClusterFuture ...
[11:00:30.410] - result already collected: FutureResult
[11:00:30.410] result() for ClusterFuture ... done
[11:00:30.410] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:30.411] Future #2
[11:00:30.411] result() for ClusterFuture ...
[11:00:30.411] - result already collected: FutureResult
[11:00:30.411] result() for ClusterFuture ... done
[11:00:30.411] result() for ClusterFuture ...
[11:00:30.411] - result already collected: FutureResult
[11:00:30.411] result() for ClusterFuture ... done
[11:00:30.411] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:00:30.411] - nx: 2
[11:00:30.411] - relay: TRUE
[11:00:30.411] - stdout: TRUE
[11:00:30.411] - signal: TRUE
[11:00:30.412] - resignal: FALSE
[11:00:30.412] - force: TRUE
[11:00:30.412] - relayed: [n=2] FALSE, FALSE
[11:00:30.412] - queued futures: [n=2] FALSE, FALSE
[11:00:30.412]  - until=1
[11:00:30.412]  - relaying element #1
[11:00:30.412] - relayed: [n=2] FALSE, FALSE
[11:00:30.412] - queued futures: [n=2] FALSE, TRUE
[11:00:30.412] signalConditionsASAP(NULL, pos=2) ... done
[11:00:30.412]  length: 1 (resolved future 2)
[11:00:30.860] receiveMessageFromWorker() for ClusterFuture ...
[11:00:30.860] - Validating connection of MultisessionFuture
[11:00:30.860] - received message: FutureResult
[11:00:30.860] - Received FutureResult
[11:00:30.861] - Erased future from FutureRegistry
[11:00:30.861] result() for ClusterFuture ...
[11:00:30.861] - result already collected: FutureResult
[11:00:30.861] result() for ClusterFuture ... done
[11:00:30.861] receiveMessageFromWorker() for ClusterFuture ... done
[11:00:30.861] Future #1
[11:00:30.861] result() for ClusterFuture ...
[11:00:30.861] - result already collected: FutureResult
[11:00:30.861] result() for ClusterFuture ... done
[11:00:30.861] result() for ClusterFuture ...
[11:00:30.861] - result already collected: FutureResult
[11:00:30.862] result() for ClusterFuture ... done
[11:00:30.862] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:00:30.862] - nx: 2
[11:00:30.862] - relay: TRUE
[11:00:30.862] - stdout: TRUE
[11:00:30.862] - signal: TRUE
[11:00:30.862] - resignal: FALSE
[11:00:30.862] - force: TRUE
[11:00:30.862] - relayed: [n=2] FALSE, FALSE
[11:00:30.862] - queued futures: [n=2] FALSE, TRUE
[11:00:30.862]  - until=1
[11:00:30.862]  - relaying element #1
[11:00:30.862] result() for ClusterFuture ...
[11:00:30.863] - result already collected: FutureResult
[11:00:30.863] result() for ClusterFuture ... done
[11:00:30.863] result() for ClusterFuture ...
[11:00:30.863] - result already collected: FutureResult
[11:00:30.863] result() for ClusterFuture ... done
[11:00:30.863] result() for ClusterFuture ...
[11:00:30.863] - result already collected: FutureResult
[11:00:30.863] result() for ClusterFuture ... done
[11:00:30.863] result() for ClusterFuture ...
[11:00:30.863] - result already collected: FutureResult
[11:00:30.863] result() for ClusterFuture ... done
[11:00:30.863] - relayed: [n=2] TRUE, FALSE
[11:00:30.864] - queued futures: [n=2] TRUE, TRUE
[11:00:30.864] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:00:30.864]  length: 0 (resolved future 1)
[11:00:30.864] Relaying remaining futures
[11:00:30.864] signalConditionsASAP(NULL, pos=0) ...
[11:00:30.864] - nx: 2
[11:00:30.864] - relay: TRUE
[11:00:30.864] - stdout: TRUE
[11:00:30.864] - signal: TRUE
[11:00:30.864] - resignal: FALSE
[11:00:30.864] - force: TRUE
[11:00:30.864] - relayed: [n=2] TRUE, FALSE
[11:00:30.864] - queued futures: [n=2] TRUE, TRUE
 - flush all
[11:00:30.865]  - relaying element #2
[11:00:30.865] result() for ClusterFuture ...
[11:00:30.865] - result already collected: FutureResult
[11:00:30.865] result() for ClusterFuture ... done
[11:00:30.865] result() for ClusterFuture ...
[11:00:30.865] - result already collected: FutureResult
[11:00:30.865] result() for ClusterFuture ... done
[11:00:30.865] result() for ClusterFuture ...
[11:00:30.865] - result already collected: FutureResult
[11:00:30.865] result() for ClusterFuture ... done
[11:00:30.865] result() for ClusterFuture ...
[11:00:30.866] - result already collected: FutureResult
[11:00:30.866] result() for ClusterFuture ... done
[11:00:30.866] - relayed: [n=2] TRUE, TRUE
[11:00:30.866] - queued futures: [n=2] TRUE, TRUE
[11:00:30.866] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[11:00:30.866] resolve() on list ... DONE
[11:00:30.866] result() for ClusterFuture ...
[11:00:30.866] - result already collected: FutureResult
[11:00:30.866] result() for ClusterFuture ... done
[11:00:30.866] result() for ClusterFuture ...
[11:00:30.866] - result already collected: FutureResult
[11:00:30.866] result() for ClusterFuture ... done
[11:00:30.866] result() for ClusterFuture ...
[11:00:30.867] - result already collected: FutureResult
[11:00:30.867] result() for ClusterFuture ... done
[11:00:30.867] result() for ClusterFuture ...
[11:00:30.867] - result already collected: FutureResult
[11:00:30.867] result() for ClusterFuture ... done
[11:00:30.867]  - Number of value chunks collected: 2
[11:00:30.867] Resolving 2 futures (chunks) ... DONE
[11:00:30.867] Reducing values from 2 chunks ...
[11:00:30.867]  - Number of values collected after concatenation: 2
[11:00:30.867]  - Number of values expected: 2
[11:00:30.867] Reducing values from 2 chunks ... DONE
[11:00:30.867] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 2 cores ... DONE
> 
> message("*** future_*apply() and 'future.stdout' ... DONE")
*** future_*apply() and 'future.stdout' ... DONE
> 
> source("incl/end.R")
[11:00:30.868] plan(): Setting new future strategy stack:
[11:00:30.868] List of future strategies:
[11:00:30.868] 1. FutureStrategy:
[11:00:30.868]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:00:30.868]    - tweaked: FALSE
[11:00:30.868]    - call: future::plan(oplan)
[11:00:30.869] plan(): nbrOfWorkers() = 1
> 
