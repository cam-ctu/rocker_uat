
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[10:20:04.715] plan(): Setting new future strategy stack:
[10:20:04.715] List of future strategies:
[10:20:04.715] 1. sequential:
[10:20:04.715]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:04.715]    - tweaked: FALSE
[10:20:04.715]    - call: future::plan("sequential")
[10:20:04.729] plan(): nbrOfWorkers() = 1
> 
> message("*** future_*apply() and 'future.stdout' ...")
*** future_*apply() and 'future.stdout' ...
> 
> options(future.debug = TRUE)
> 
> truth <- list()
> 
> out <- utils::capture.output({
+   y <- lapply(1:0, FUN = function(x) {
+     print(x)
+   })
+ })
> truth[["lapply"]] <- list(value = y, stdout = out)
> 
> out <- utils::capture.output({
+   y <- mapply(1:0, 0:1, FUN = function(x, y) {
+     print(list(x = x, y = y))
+   })
+ })
> truth[["mapply"]] <- list(value = y, stdout = out)
> 
> for (cores in 1:availCores) {
+   message(sprintf("  - Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+   
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("* plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     for (fun in names(truth)) {
+       for (stdout in c(FALSE, TRUE, NA)) {
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ...", fun, stdout))
+   
+         out <- utils::capture.output({
+           if (fun == "lapply") {
+             y <- future_lapply(1:0, FUN = function(x) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+ 	      print(x)
+             }, future.stdout = stdout)
+ 	  } else if (fun == "mapply") {
+             y <- future_mapply(1:0, 0:1, FUN = function(x, y) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+               print(list(x = x, y = y))
+             }, future.stdout = stdout)
+ 	  }
+         })
+         stopifnot(identical(y, truth[[fun]]$value))
+   
+         if (isTRUE(stdout)) {
+           stopifnot(identical(out, truth[[fun]]$stdout))
+         } else if (is.na(stdout)) {
+         } else {
+           stopifnot(nchar(out) == 0)
+         }
+       
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ... DONE", fun, stdout))
+       } ## for (stdout ...)
+     } ## for (fun ...)
+     
+     message(sprintf("* plan('%s') ... DONE", strategy))
+   }
+   
+   message(sprintf("  - Testing with %d cores ... DONE", cores))
+ }
  - Testing with 1 cores ...
* plan('sequential') ...
[10:20:04.767] plan(): Setting new future strategy stack:
[10:20:04.767] List of future strategies:
[10:20:04.767] 1. sequential:
[10:20:04.767]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:04.767]    - tweaked: FALSE
[10:20:04.767]    - call: plan(strategy)
[10:20:04.778] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[10:20:04.778] future_lapply() ...
[10:20:04.782] Number of chunks: 1
[10:20:04.782] getGlobalsAndPackagesXApply() ...
[10:20:04.782]  - future.globals: TRUE
[10:20:04.783] getGlobalsAndPackages() ...
[10:20:04.783] Searching for globals...
[10:20:04.785] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:20:04.785] Searching for globals ... DONE
[10:20:04.785] Resolving globals: FALSE
[10:20:04.786] The total size of the 1 globals is 841 bytes (841 bytes)
[10:20:04.787] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[10:20:04.787] - globals: [1] ‘FUN’
[10:20:04.787] 
[10:20:04.787] getGlobalsAndPackages() ... DONE
[10:20:04.787]  - globals found/used: [n=1] ‘FUN’
[10:20:04.787]  - needed namespaces: [n=0] 
[10:20:04.787] Finding globals ... DONE
[10:20:04.787]  - use_args: TRUE
[10:20:04.787]  - Getting '...' globals ...
[10:20:04.788] resolve() on list ...
[10:20:04.788]  recursive: 0
[10:20:04.788]  length: 1
[10:20:04.789]  elements: ‘...’
[10:20:04.789]  length: 0 (resolved future 1)
[10:20:04.789] resolve() on list ... DONE
[10:20:04.789]    - '...' content: [n=0] 
[10:20:04.789] List of 1
[10:20:04.789]  $ ...: list()
[10:20:04.789]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:04.789]  - attr(*, "where")=List of 1
[10:20:04.789]   ..$ ...:<environment: 0x557fc2150550> 
[10:20:04.789]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:04.789]  - attr(*, "resolved")= logi TRUE
[10:20:04.789]  - attr(*, "total_size")= num NA
[10:20:04.795]  - Getting '...' globals ... DONE
[10:20:04.795] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:20:04.795] List of 2
[10:20:04.795]  $ ...future.FUN:function (x)  
[10:20:04.795]  $ ...          : list()
[10:20:04.795]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:04.795]  - attr(*, "where")=List of 2
[10:20:04.795]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:04.795]   ..$ ...          :<environment: 0x557fc2150550> 
[10:20:04.795]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:04.795]  - attr(*, "resolved")= logi FALSE
[10:20:04.795]  - attr(*, "total_size")= num 5632
[10:20:04.798] Packages to be attached in all futures: [n=0] 
[10:20:04.798] getGlobalsAndPackagesXApply() ... DONE
[10:20:04.798] Number of futures (= number of chunks): 1
[10:20:04.798] Launching 1 futures (chunks) ...
[10:20:04.798] Chunk #1 of 1 ...
[10:20:04.799]  - Finding globals in 'X' for chunk #1 ...
[10:20:04.799] getGlobalsAndPackages() ...
[10:20:04.799] Searching for globals...
[10:20:04.799] 
[10:20:04.799] Searching for globals ... DONE
[10:20:04.799] - globals: [0] <none>
[10:20:04.799] getGlobalsAndPackages() ... DONE
[10:20:04.799]    + additional globals found: [n=0] 
[10:20:04.799]    + additional namespaces needed: [n=0] 
[10:20:04.799]  - Finding globals in 'X' for chunk #1 ... DONE
[10:20:04.800]  - seeds: <none>
[10:20:04.800]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:04.800] getGlobalsAndPackages() ...
[10:20:04.800] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:04.800] Resolving globals: FALSE
[10:20:04.800] Tweak future expression to call with '...' arguments ...
[10:20:04.800] {
[10:20:04.800]     do.call(function(...) {
[10:20:04.800]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:04.800]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:04.800]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:04.800]             on.exit(options(oopts), add = TRUE)
[10:20:04.800]         }
[10:20:04.800]         {
[10:20:04.800]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:04.800]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:04.800]                 ...future.FUN(...future.X_jj, ...)
[10:20:04.800]             })
[10:20:04.800]         }
[10:20:04.800]     }, args = future.call.arguments)
[10:20:04.800] }
[10:20:04.800] Tweak future expression to call with '...' arguments ... DONE
[10:20:04.801] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:04.801] 
[10:20:04.801] getGlobalsAndPackages() ... DONE
[10:20:04.802] run() for ‘Future’ ...
[10:20:04.802] - state: ‘created’
[10:20:04.802] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:20:04.802] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:04.802] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:04.802]   - Field: ‘label’
[10:20:04.802]   - Field: ‘local’
[10:20:04.803]   - Field: ‘owner’
[10:20:04.803]   - Field: ‘envir’
[10:20:04.803]   - Field: ‘packages’
[10:20:04.803]   - Field: ‘gc’
[10:20:04.803]   - Field: ‘conditions’
[10:20:04.803]   - Field: ‘expr’
[10:20:04.803]   - Field: ‘uuid’
[10:20:04.803]   - Field: ‘seed’
[10:20:04.803]   - Field: ‘version’
[10:20:04.803]   - Field: ‘result’
[10:20:04.803]   - Field: ‘asynchronous’
[10:20:04.803]   - Field: ‘calls’
[10:20:04.804]   - Field: ‘globals’
[10:20:04.804]   - Field: ‘stdout’
[10:20:04.804]   - Field: ‘earlySignal’
[10:20:04.804]   - Field: ‘lazy’
[10:20:04.804]   - Field: ‘state’
[10:20:04.804] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:04.804] - Launch lazy future ...
[10:20:04.805] Packages needed by the future expression (n = 0): <none>
[10:20:04.805] Packages needed by future strategies (n = 0): <none>
[10:20:04.805] {
[10:20:04.805]     {
[10:20:04.805]         {
[10:20:04.805]             ...future.startTime <- base::Sys.time()
[10:20:04.805]             {
[10:20:04.805]                 {
[10:20:04.805]                   {
[10:20:04.805]                     base::local({
[10:20:04.805]                       has_future <- base::requireNamespace("future", 
[10:20:04.805]                         quietly = TRUE)
[10:20:04.805]                       if (has_future) {
[10:20:04.805]                         ns <- base::getNamespace("future")
[10:20:04.805]                         version <- ns[[".package"]][["version"]]
[10:20:04.805]                         if (is.null(version)) 
[10:20:04.805]                           version <- utils::packageVersion("future")
[10:20:04.805]                       }
[10:20:04.805]                       else {
[10:20:04.805]                         version <- NULL
[10:20:04.805]                       }
[10:20:04.805]                       if (!has_future || version < "1.8.0") {
[10:20:04.805]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:04.805]                           "", base::R.version$version.string), 
[10:20:04.805]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:04.805]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:04.805]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:04.805]                             "release", "version")], collapse = " "), 
[10:20:04.805]                           hostname = base::Sys.info()[["nodename"]])
[10:20:04.805]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:04.805]                           info)
[10:20:04.805]                         info <- base::paste(info, collapse = "; ")
[10:20:04.805]                         if (!has_future) {
[10:20:04.805]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:04.805]                             info)
[10:20:04.805]                         }
[10:20:04.805]                         else {
[10:20:04.805]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:04.805]                             info, version)
[10:20:04.805]                         }
[10:20:04.805]                         base::stop(msg)
[10:20:04.805]                       }
[10:20:04.805]                     })
[10:20:04.805]                   }
[10:20:04.805]                   ...future.strategy.old <- future::plan("list")
[10:20:04.805]                   options(future.plan = NULL)
[10:20:04.805]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:04.805]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:04.805]                 }
[10:20:04.805]                 ...future.workdir <- getwd()
[10:20:04.805]             }
[10:20:04.805]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:04.805]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:04.805]         }
[10:20:04.805]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:04.805]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:04.805]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:04.805]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:04.805]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:04.805]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:04.805]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:04.805]             base::names(...future.oldOptions))
[10:20:04.805]     }
[10:20:04.805]     if (FALSE) {
[10:20:04.805]     }
[10:20:04.805]     else {
[10:20:04.805]         if (FALSE) {
[10:20:04.805]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:04.805]                 open = "w")
[10:20:04.805]         }
[10:20:04.805]         else {
[10:20:04.805]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:04.805]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:04.805]         }
[10:20:04.805]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:04.805]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:04.805]             base::sink(type = "output", split = FALSE)
[10:20:04.805]             base::close(...future.stdout)
[10:20:04.805]         }, add = TRUE)
[10:20:04.805]     }
[10:20:04.805]     ...future.frame <- base::sys.nframe()
[10:20:04.805]     ...future.conditions <- base::list()
[10:20:04.805]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:04.805]     if (FALSE) {
[10:20:04.805]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:04.805]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:04.805]     }
[10:20:04.805]     ...future.result <- base::tryCatch({
[10:20:04.805]         base::withCallingHandlers({
[10:20:04.805]             ...future.value <- base::withVisible(base::local({
[10:20:04.805]                 do.call(function(...) {
[10:20:04.805]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:04.805]                   if (!identical(...future.globals.maxSize.org, 
[10:20:04.805]                     ...future.globals.maxSize)) {
[10:20:04.805]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:04.805]                     on.exit(options(oopts), add = TRUE)
[10:20:04.805]                   }
[10:20:04.805]                   {
[10:20:04.805]                     lapply(seq_along(...future.elements_ii), 
[10:20:04.805]                       FUN = function(jj) {
[10:20:04.805]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:04.805]                         ...future.FUN(...future.X_jj, ...)
[10:20:04.805]                       })
[10:20:04.805]                   }
[10:20:04.805]                 }, args = future.call.arguments)
[10:20:04.805]             }))
[10:20:04.805]             future::FutureResult(value = ...future.value$value, 
[10:20:04.805]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:04.805]                   ...future.rng), globalenv = if (FALSE) 
[10:20:04.805]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:04.805]                     ...future.globalenv.names))
[10:20:04.805]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:04.805]         }, condition = base::local({
[10:20:04.805]             c <- base::c
[10:20:04.805]             inherits <- base::inherits
[10:20:04.805]             invokeRestart <- base::invokeRestart
[10:20:04.805]             length <- base::length
[10:20:04.805]             list <- base::list
[10:20:04.805]             seq.int <- base::seq.int
[10:20:04.805]             signalCondition <- base::signalCondition
[10:20:04.805]             sys.calls <- base::sys.calls
[10:20:04.805]             `[[` <- base::`[[`
[10:20:04.805]             `+` <- base::`+`
[10:20:04.805]             `<<-` <- base::`<<-`
[10:20:04.805]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:04.805]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:04.805]                   3L)]
[10:20:04.805]             }
[10:20:04.805]             function(cond) {
[10:20:04.805]                 is_error <- inherits(cond, "error")
[10:20:04.805]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:04.805]                   NULL)
[10:20:04.805]                 if (is_error) {
[10:20:04.805]                   sessionInformation <- function() {
[10:20:04.805]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:04.805]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:04.805]                       search = base::search(), system = base::Sys.info())
[10:20:04.805]                   }
[10:20:04.805]                   ...future.conditions[[length(...future.conditions) + 
[10:20:04.805]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:04.805]                     cond$call), session = sessionInformation(), 
[10:20:04.805]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:04.805]                   signalCondition(cond)
[10:20:04.805]                 }
[10:20:04.805]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:04.805]                 "immediateCondition"))) {
[10:20:04.805]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:04.805]                   ...future.conditions[[length(...future.conditions) + 
[10:20:04.805]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:04.805]                   if (TRUE && !signal) {
[10:20:04.805]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:04.805]                     {
[10:20:04.805]                       inherits <- base::inherits
[10:20:04.805]                       invokeRestart <- base::invokeRestart
[10:20:04.805]                       is.null <- base::is.null
[10:20:04.805]                       muffled <- FALSE
[10:20:04.805]                       if (inherits(cond, "message")) {
[10:20:04.805]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:04.805]                         if (muffled) 
[10:20:04.805]                           invokeRestart("muffleMessage")
[10:20:04.805]                       }
[10:20:04.805]                       else if (inherits(cond, "warning")) {
[10:20:04.805]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:04.805]                         if (muffled) 
[10:20:04.805]                           invokeRestart("muffleWarning")
[10:20:04.805]                       }
[10:20:04.805]                       else if (inherits(cond, "condition")) {
[10:20:04.805]                         if (!is.null(pattern)) {
[10:20:04.805]                           computeRestarts <- base::computeRestarts
[10:20:04.805]                           grepl <- base::grepl
[10:20:04.805]                           restarts <- computeRestarts(cond)
[10:20:04.805]                           for (restart in restarts) {
[10:20:04.805]                             name <- restart$name
[10:20:04.805]                             if (is.null(name)) 
[10:20:04.805]                               next
[10:20:04.805]                             if (!grepl(pattern, name)) 
[10:20:04.805]                               next
[10:20:04.805]                             invokeRestart(restart)
[10:20:04.805]                             muffled <- TRUE
[10:20:04.805]                             break
[10:20:04.805]                           }
[10:20:04.805]                         }
[10:20:04.805]                       }
[10:20:04.805]                       invisible(muffled)
[10:20:04.805]                     }
[10:20:04.805]                     muffleCondition(cond, pattern = "^muffle")
[10:20:04.805]                   }
[10:20:04.805]                 }
[10:20:04.805]                 else {
[10:20:04.805]                   if (TRUE) {
[10:20:04.805]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:04.805]                     {
[10:20:04.805]                       inherits <- base::inherits
[10:20:04.805]                       invokeRestart <- base::invokeRestart
[10:20:04.805]                       is.null <- base::is.null
[10:20:04.805]                       muffled <- FALSE
[10:20:04.805]                       if (inherits(cond, "message")) {
[10:20:04.805]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:04.805]                         if (muffled) 
[10:20:04.805]                           invokeRestart("muffleMessage")
[10:20:04.805]                       }
[10:20:04.805]                       else if (inherits(cond, "warning")) {
[10:20:04.805]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:04.805]                         if (muffled) 
[10:20:04.805]                           invokeRestart("muffleWarning")
[10:20:04.805]                       }
[10:20:04.805]                       else if (inherits(cond, "condition")) {
[10:20:04.805]                         if (!is.null(pattern)) {
[10:20:04.805]                           computeRestarts <- base::computeRestarts
[10:20:04.805]                           grepl <- base::grepl
[10:20:04.805]                           restarts <- computeRestarts(cond)
[10:20:04.805]                           for (restart in restarts) {
[10:20:04.805]                             name <- restart$name
[10:20:04.805]                             if (is.null(name)) 
[10:20:04.805]                               next
[10:20:04.805]                             if (!grepl(pattern, name)) 
[10:20:04.805]                               next
[10:20:04.805]                             invokeRestart(restart)
[10:20:04.805]                             muffled <- TRUE
[10:20:04.805]                             break
[10:20:04.805]                           }
[10:20:04.805]                         }
[10:20:04.805]                       }
[10:20:04.805]                       invisible(muffled)
[10:20:04.805]                     }
[10:20:04.805]                     muffleCondition(cond, pattern = "^muffle")
[10:20:04.805]                   }
[10:20:04.805]                 }
[10:20:04.805]             }
[10:20:04.805]         }))
[10:20:04.805]     }, error = function(ex) {
[10:20:04.805]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:04.805]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:04.805]                 ...future.rng), started = ...future.startTime, 
[10:20:04.805]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:04.805]             version = "1.8"), class = "FutureResult")
[10:20:04.805]     }, finally = {
[10:20:04.805]         if (!identical(...future.workdir, getwd())) 
[10:20:04.805]             setwd(...future.workdir)
[10:20:04.805]         {
[10:20:04.805]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:04.805]                 ...future.oldOptions$nwarnings <- NULL
[10:20:04.805]             }
[10:20:04.805]             base::options(...future.oldOptions)
[10:20:04.805]             if (.Platform$OS.type == "windows") {
[10:20:04.805]                 old_names <- names(...future.oldEnvVars)
[10:20:04.805]                 envs <- base::Sys.getenv()
[10:20:04.805]                 names <- names(envs)
[10:20:04.805]                 common <- intersect(names, old_names)
[10:20:04.805]                 added <- setdiff(names, old_names)
[10:20:04.805]                 removed <- setdiff(old_names, names)
[10:20:04.805]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:04.805]                   envs[common]]
[10:20:04.805]                 NAMES <- toupper(changed)
[10:20:04.805]                 args <- list()
[10:20:04.805]                 for (kk in seq_along(NAMES)) {
[10:20:04.805]                   name <- changed[[kk]]
[10:20:04.805]                   NAME <- NAMES[[kk]]
[10:20:04.805]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:04.805]                     next
[10:20:04.805]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:04.805]                 }
[10:20:04.805]                 NAMES <- toupper(added)
[10:20:04.805]                 for (kk in seq_along(NAMES)) {
[10:20:04.805]                   name <- added[[kk]]
[10:20:04.805]                   NAME <- NAMES[[kk]]
[10:20:04.805]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:04.805]                     next
[10:20:04.805]                   args[[name]] <- ""
[10:20:04.805]                 }
[10:20:04.805]                 NAMES <- toupper(removed)
[10:20:04.805]                 for (kk in seq_along(NAMES)) {
[10:20:04.805]                   name <- removed[[kk]]
[10:20:04.805]                   NAME <- NAMES[[kk]]
[10:20:04.805]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:04.805]                     next
[10:20:04.805]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:04.805]                 }
[10:20:04.805]                 if (length(args) > 0) 
[10:20:04.805]                   base::do.call(base::Sys.setenv, args = args)
[10:20:04.805]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:04.805]             }
[10:20:04.805]             else {
[10:20:04.805]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:04.805]             }
[10:20:04.805]             {
[10:20:04.805]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:04.805]                   0L) {
[10:20:04.805]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:04.805]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:04.805]                   base::options(opts)
[10:20:04.805]                 }
[10:20:04.805]                 {
[10:20:04.805]                   {
[10:20:04.805]                     NULL
[10:20:04.805]                     RNGkind("Mersenne-Twister")
[10:20:04.805]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:04.805]                       inherits = FALSE)
[10:20:04.805]                   }
[10:20:04.805]                   options(future.plan = NULL)
[10:20:04.805]                   if (is.na(NA_character_)) 
[10:20:04.805]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:04.805]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:04.805]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:04.805]                     .init = FALSE)
[10:20:04.805]                 }
[10:20:04.805]             }
[10:20:04.805]         }
[10:20:04.805]     })
[10:20:04.805]     if (TRUE) {
[10:20:04.805]         base::sink(type = "output", split = FALSE)
[10:20:04.805]         if (FALSE) {
[10:20:04.805]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:04.805]         }
[10:20:04.805]         else {
[10:20:04.805]             ...future.result["stdout"] <- base::list(NULL)
[10:20:04.805]         }
[10:20:04.805]         base::close(...future.stdout)
[10:20:04.805]         ...future.stdout <- NULL
[10:20:04.805]     }
[10:20:04.805]     ...future.result$conditions <- ...future.conditions
[10:20:04.805]     ...future.result$finished <- base::Sys.time()
[10:20:04.805]     ...future.result
[10:20:04.805] }
[10:20:04.807] assign_globals() ...
[10:20:04.807] List of 5
[10:20:04.807]  $ ...future.FUN            :function (x)  
[10:20:04.807]  $ future.call.arguments    : list()
[10:20:04.807]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:04.807]  $ ...future.elements_ii    :List of 2
[10:20:04.807]   ..$ : int 1
[10:20:04.807]   ..$ : int 0
[10:20:04.807]  $ ...future.seeds_ii       : NULL
[10:20:04.807]  $ ...future.globals.maxSize: NULL
[10:20:04.807]  - attr(*, "where")=List of 5
[10:20:04.807]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:04.807]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:20:04.807]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:04.807]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:04.807]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:04.807]  - attr(*, "resolved")= logi FALSE
[10:20:04.807]  - attr(*, "total_size")= num 5632
[10:20:04.807]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:04.807]  - attr(*, "already-done")= logi TRUE
[10:20:04.812] - reassign environment for ‘...future.FUN’
[10:20:04.812] - copied ‘...future.FUN’ to environment
[10:20:04.812] - copied ‘future.call.arguments’ to environment
[10:20:04.812] - copied ‘...future.elements_ii’ to environment
[10:20:04.812] - copied ‘...future.seeds_ii’ to environment
[10:20:04.813] - copied ‘...future.globals.maxSize’ to environment
[10:20:04.813] assign_globals() ... done
[10:20:04.813] plan(): Setting new future strategy stack:
[10:20:04.813] List of future strategies:
[10:20:04.813] 1. sequential:
[10:20:04.813]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:04.813]    - tweaked: FALSE
[10:20:04.813]    - call: NULL
[10:20:04.813] plan(): nbrOfWorkers() = 1
[10:20:05.315] plan(): Setting new future strategy stack:
[10:20:05.315] List of future strategies:
[10:20:05.315] 1. sequential:
[10:20:05.315]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:05.315]    - tweaked: FALSE
[10:20:05.315]    - call: plan(strategy)
[10:20:05.316] plan(): nbrOfWorkers() = 1
[10:20:05.316] SequentialFuture started (and completed)
[10:20:05.317] - Launch lazy future ... done
[10:20:05.317] run() for ‘SequentialFuture’ ... done
[10:20:05.317] Created future:
[10:20:05.317] SequentialFuture:
[10:20:05.317] Label: ‘future_lapply-1’
[10:20:05.317] Expression:
[10:20:05.317] {
[10:20:05.317]     do.call(function(...) {
[10:20:05.317]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:05.317]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:05.317]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:05.317]             on.exit(options(oopts), add = TRUE)
[10:20:05.317]         }
[10:20:05.317]         {
[10:20:05.317]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:05.317]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:05.317]                 ...future.FUN(...future.X_jj, ...)
[10:20:05.317]             })
[10:20:05.317]         }
[10:20:05.317]     }, args = future.call.arguments)
[10:20:05.317] }
[10:20:05.317] Lazy evaluation: FALSE
[10:20:05.317] Asynchronous evaluation: FALSE
[10:20:05.317] Local evaluation: TRUE
[10:20:05.317] Environment: R_GlobalEnv
[10:20:05.317] Capture standard output: FALSE
[10:20:05.317] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:05.317] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:05.317] Packages: <none>
[10:20:05.317] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:05.317] Resolved: TRUE
[10:20:05.317] Value: 55 bytes of class ‘list’
[10:20:05.317] Early signaling: FALSE
[10:20:05.317] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:05.317] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:05.318] Chunk #1 of 1 ... DONE
[10:20:05.318] Launching 1 futures (chunks) ... DONE
[10:20:05.319] Resolving 1 futures (chunks) ...
[10:20:05.319] resolve() on list ...
[10:20:05.319]  recursive: 0
[10:20:05.319]  length: 1
[10:20:05.319] 
[10:20:05.319] resolved() for ‘SequentialFuture’ ...
[10:20:05.319] - state: ‘finished’
[10:20:05.319] - run: TRUE
[10:20:05.319] - result: ‘FutureResult’
[10:20:05.319] resolved() for ‘SequentialFuture’ ... done
[10:20:05.320] Future #1
[10:20:05.320] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:20:05.320] - nx: 1
[10:20:05.320] - relay: TRUE
[10:20:05.320] - stdout: TRUE
[10:20:05.320] - signal: TRUE
[10:20:05.320] - resignal: FALSE
[10:20:05.320] - force: TRUE
[10:20:05.320] - relayed: [n=1] FALSE
[10:20:05.321] - queued futures: [n=1] FALSE
[10:20:05.321]  - until=1
[10:20:05.321]  - relaying element #1
[10:20:05.321] - relayed: [n=1] TRUE
[10:20:05.321] - queued futures: [n=1] TRUE
[10:20:05.321] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:20:05.324]  length: 0 (resolved future 1)
[10:20:05.324] Relaying remaining futures
[10:20:05.324] signalConditionsASAP(NULL, pos=0) ...
[10:20:05.324] - nx: 1
[10:20:05.324] - relay: TRUE
[10:20:05.324] - stdout: TRUE
[10:20:05.324] - signal: TRUE
[10:20:05.324] - resignal: FALSE
[10:20:05.324] - force: TRUE
[10:20:05.324] - relayed: [n=1] TRUE
[10:20:05.325] - queued futures: [n=1] TRUE
 - flush all
[10:20:05.325] - relayed: [n=1] TRUE
[10:20:05.325] - queued futures: [n=1] TRUE
[10:20:05.325] signalConditionsASAP(NULL, pos=0) ... done
[10:20:05.325] resolve() on list ... DONE
[10:20:05.325]  - Number of value chunks collected: 1
[10:20:05.325] Resolving 1 futures (chunks) ... DONE
[10:20:05.325] Reducing values from 1 chunks ...
[10:20:05.326]  - Number of values collected after concatenation: 2
[10:20:05.326]  - Number of values expected: 2
[10:20:05.326] Reducing values from 1 chunks ... DONE
[10:20:05.326] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[10:20:05.327] future_lapply() ...
[10:20:05.328] Number of chunks: 1
[10:20:05.328] getGlobalsAndPackagesXApply() ...
[10:20:05.328]  - future.globals: TRUE
[10:20:05.328] getGlobalsAndPackages() ...
[10:20:05.328] Searching for globals...
[10:20:05.329] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:20:05.330] Searching for globals ... DONE
[10:20:05.330] Resolving globals: FALSE
[10:20:05.330] The total size of the 1 globals is 841 bytes (841 bytes)
[10:20:05.330] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[10:20:05.331] - globals: [1] ‘FUN’
[10:20:05.331] 
[10:20:05.331] getGlobalsAndPackages() ... DONE
[10:20:05.331]  - globals found/used: [n=1] ‘FUN’
[10:20:05.331]  - needed namespaces: [n=0] 
[10:20:05.331] Finding globals ... DONE
[10:20:05.331]  - use_args: TRUE
[10:20:05.331]  - Getting '...' globals ...
[10:20:05.331] resolve() on list ...
[10:20:05.332]  recursive: 0
[10:20:05.332]  length: 1
[10:20:05.332]  elements: ‘...’
[10:20:05.332]  length: 0 (resolved future 1)
[10:20:05.332] resolve() on list ... DONE
[10:20:05.332]    - '...' content: [n=0] 
[10:20:05.332] List of 1
[10:20:05.332]  $ ...: list()
[10:20:05.332]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:05.332]  - attr(*, "where")=List of 1
[10:20:05.332]   ..$ ...:<environment: 0x557fc093ba60> 
[10:20:05.332]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:05.332]  - attr(*, "resolved")= logi TRUE
[10:20:05.332]  - attr(*, "total_size")= num NA
[10:20:05.334]  - Getting '...' globals ... DONE
[10:20:05.335] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:20:05.335] List of 2
[10:20:05.335]  $ ...future.FUN:function (x)  
[10:20:05.335]  $ ...          : list()
[10:20:05.335]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:05.335]  - attr(*, "where")=List of 2
[10:20:05.335]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:05.335]   ..$ ...          :<environment: 0x557fc093ba60> 
[10:20:05.335]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:05.335]  - attr(*, "resolved")= logi FALSE
[10:20:05.335]  - attr(*, "total_size")= num 5632
[10:20:05.337] Packages to be attached in all futures: [n=0] 
[10:20:05.337] getGlobalsAndPackagesXApply() ... DONE
[10:20:05.338] Number of futures (= number of chunks): 1
[10:20:05.338] Launching 1 futures (chunks) ...
[10:20:05.338] Chunk #1 of 1 ...
[10:20:05.338]  - Finding globals in 'X' for chunk #1 ...
[10:20:05.338] getGlobalsAndPackages() ...
[10:20:05.338] Searching for globals...
[10:20:05.338] 
[10:20:05.338] Searching for globals ... DONE
[10:20:05.338] - globals: [0] <none>
[10:20:05.339] getGlobalsAndPackages() ... DONE
[10:20:05.339]    + additional globals found: [n=0] 
[10:20:05.339]    + additional namespaces needed: [n=0] 
[10:20:05.339]  - Finding globals in 'X' for chunk #1 ... DONE
[10:20:05.339]  - seeds: <none>
[10:20:05.339]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:05.339] getGlobalsAndPackages() ...
[10:20:05.339] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:05.339] Resolving globals: FALSE
[10:20:05.339] Tweak future expression to call with '...' arguments ...
[10:20:05.339] {
[10:20:05.339]     do.call(function(...) {
[10:20:05.339]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:05.339]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:05.339]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:05.339]             on.exit(options(oopts), add = TRUE)
[10:20:05.339]         }
[10:20:05.339]         {
[10:20:05.339]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:05.339]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:05.339]                 ...future.FUN(...future.X_jj, ...)
[10:20:05.339]             })
[10:20:05.339]         }
[10:20:05.339]     }, args = future.call.arguments)
[10:20:05.339] }
[10:20:05.340] Tweak future expression to call with '...' arguments ... DONE
[10:20:05.340] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:05.340] 
[10:20:05.340] getGlobalsAndPackages() ... DONE
[10:20:05.340] run() for ‘Future’ ...
[10:20:05.341] - state: ‘created’
[10:20:05.341] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:20:05.341] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:05.341] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:05.341]   - Field: ‘label’
[10:20:05.341]   - Field: ‘local’
[10:20:05.341]   - Field: ‘owner’
[10:20:05.341]   - Field: ‘envir’
[10:20:05.342]   - Field: ‘packages’
[10:20:05.342]   - Field: ‘gc’
[10:20:05.342]   - Field: ‘conditions’
[10:20:05.342]   - Field: ‘expr’
[10:20:05.342]   - Field: ‘uuid’
[10:20:05.342]   - Field: ‘seed’
[10:20:05.342]   - Field: ‘version’
[10:20:05.342]   - Field: ‘result’
[10:20:05.342]   - Field: ‘asynchronous’
[10:20:05.342]   - Field: ‘calls’
[10:20:05.342]   - Field: ‘globals’
[10:20:05.342]   - Field: ‘stdout’
[10:20:05.343]   - Field: ‘earlySignal’
[10:20:05.343]   - Field: ‘lazy’
[10:20:05.343]   - Field: ‘state’
[10:20:05.343] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:05.343] - Launch lazy future ...
[10:20:05.343] Packages needed by the future expression (n = 0): <none>
[10:20:05.343] Packages needed by future strategies (n = 0): <none>
[10:20:05.344] {
[10:20:05.344]     {
[10:20:05.344]         {
[10:20:05.344]             ...future.startTime <- base::Sys.time()
[10:20:05.344]             {
[10:20:05.344]                 {
[10:20:05.344]                   {
[10:20:05.344]                     base::local({
[10:20:05.344]                       has_future <- base::requireNamespace("future", 
[10:20:05.344]                         quietly = TRUE)
[10:20:05.344]                       if (has_future) {
[10:20:05.344]                         ns <- base::getNamespace("future")
[10:20:05.344]                         version <- ns[[".package"]][["version"]]
[10:20:05.344]                         if (is.null(version)) 
[10:20:05.344]                           version <- utils::packageVersion("future")
[10:20:05.344]                       }
[10:20:05.344]                       else {
[10:20:05.344]                         version <- NULL
[10:20:05.344]                       }
[10:20:05.344]                       if (!has_future || version < "1.8.0") {
[10:20:05.344]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:05.344]                           "", base::R.version$version.string), 
[10:20:05.344]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:05.344]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:05.344]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:05.344]                             "release", "version")], collapse = " "), 
[10:20:05.344]                           hostname = base::Sys.info()[["nodename"]])
[10:20:05.344]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:05.344]                           info)
[10:20:05.344]                         info <- base::paste(info, collapse = "; ")
[10:20:05.344]                         if (!has_future) {
[10:20:05.344]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:05.344]                             info)
[10:20:05.344]                         }
[10:20:05.344]                         else {
[10:20:05.344]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:05.344]                             info, version)
[10:20:05.344]                         }
[10:20:05.344]                         base::stop(msg)
[10:20:05.344]                       }
[10:20:05.344]                     })
[10:20:05.344]                   }
[10:20:05.344]                   ...future.strategy.old <- future::plan("list")
[10:20:05.344]                   options(future.plan = NULL)
[10:20:05.344]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:05.344]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:05.344]                 }
[10:20:05.344]                 ...future.workdir <- getwd()
[10:20:05.344]             }
[10:20:05.344]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:05.344]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:05.344]         }
[10:20:05.344]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:05.344]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:05.344]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:05.344]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:05.344]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:05.344]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:05.344]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:05.344]             base::names(...future.oldOptions))
[10:20:05.344]     }
[10:20:05.344]     if (FALSE) {
[10:20:05.344]     }
[10:20:05.344]     else {
[10:20:05.344]         if (TRUE) {
[10:20:05.344]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:05.344]                 open = "w")
[10:20:05.344]         }
[10:20:05.344]         else {
[10:20:05.344]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:05.344]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:05.344]         }
[10:20:05.344]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:05.344]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:05.344]             base::sink(type = "output", split = FALSE)
[10:20:05.344]             base::close(...future.stdout)
[10:20:05.344]         }, add = TRUE)
[10:20:05.344]     }
[10:20:05.344]     ...future.frame <- base::sys.nframe()
[10:20:05.344]     ...future.conditions <- base::list()
[10:20:05.344]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:05.344]     if (FALSE) {
[10:20:05.344]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:05.344]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:05.344]     }
[10:20:05.344]     ...future.result <- base::tryCatch({
[10:20:05.344]         base::withCallingHandlers({
[10:20:05.344]             ...future.value <- base::withVisible(base::local({
[10:20:05.344]                 do.call(function(...) {
[10:20:05.344]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:05.344]                   if (!identical(...future.globals.maxSize.org, 
[10:20:05.344]                     ...future.globals.maxSize)) {
[10:20:05.344]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:05.344]                     on.exit(options(oopts), add = TRUE)
[10:20:05.344]                   }
[10:20:05.344]                   {
[10:20:05.344]                     lapply(seq_along(...future.elements_ii), 
[10:20:05.344]                       FUN = function(jj) {
[10:20:05.344]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:05.344]                         ...future.FUN(...future.X_jj, ...)
[10:20:05.344]                       })
[10:20:05.344]                   }
[10:20:05.344]                 }, args = future.call.arguments)
[10:20:05.344]             }))
[10:20:05.344]             future::FutureResult(value = ...future.value$value, 
[10:20:05.344]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:05.344]                   ...future.rng), globalenv = if (FALSE) 
[10:20:05.344]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:05.344]                     ...future.globalenv.names))
[10:20:05.344]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:05.344]         }, condition = base::local({
[10:20:05.344]             c <- base::c
[10:20:05.344]             inherits <- base::inherits
[10:20:05.344]             invokeRestart <- base::invokeRestart
[10:20:05.344]             length <- base::length
[10:20:05.344]             list <- base::list
[10:20:05.344]             seq.int <- base::seq.int
[10:20:05.344]             signalCondition <- base::signalCondition
[10:20:05.344]             sys.calls <- base::sys.calls
[10:20:05.344]             `[[` <- base::`[[`
[10:20:05.344]             `+` <- base::`+`
[10:20:05.344]             `<<-` <- base::`<<-`
[10:20:05.344]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:05.344]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:05.344]                   3L)]
[10:20:05.344]             }
[10:20:05.344]             function(cond) {
[10:20:05.344]                 is_error <- inherits(cond, "error")
[10:20:05.344]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:05.344]                   NULL)
[10:20:05.344]                 if (is_error) {
[10:20:05.344]                   sessionInformation <- function() {
[10:20:05.344]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:05.344]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:05.344]                       search = base::search(), system = base::Sys.info())
[10:20:05.344]                   }
[10:20:05.344]                   ...future.conditions[[length(...future.conditions) + 
[10:20:05.344]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:05.344]                     cond$call), session = sessionInformation(), 
[10:20:05.344]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:05.344]                   signalCondition(cond)
[10:20:05.344]                 }
[10:20:05.344]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:05.344]                 "immediateCondition"))) {
[10:20:05.344]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:05.344]                   ...future.conditions[[length(...future.conditions) + 
[10:20:05.344]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:05.344]                   if (TRUE && !signal) {
[10:20:05.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:05.344]                     {
[10:20:05.344]                       inherits <- base::inherits
[10:20:05.344]                       invokeRestart <- base::invokeRestart
[10:20:05.344]                       is.null <- base::is.null
[10:20:05.344]                       muffled <- FALSE
[10:20:05.344]                       if (inherits(cond, "message")) {
[10:20:05.344]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:05.344]                         if (muffled) 
[10:20:05.344]                           invokeRestart("muffleMessage")
[10:20:05.344]                       }
[10:20:05.344]                       else if (inherits(cond, "warning")) {
[10:20:05.344]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:05.344]                         if (muffled) 
[10:20:05.344]                           invokeRestart("muffleWarning")
[10:20:05.344]                       }
[10:20:05.344]                       else if (inherits(cond, "condition")) {
[10:20:05.344]                         if (!is.null(pattern)) {
[10:20:05.344]                           computeRestarts <- base::computeRestarts
[10:20:05.344]                           grepl <- base::grepl
[10:20:05.344]                           restarts <- computeRestarts(cond)
[10:20:05.344]                           for (restart in restarts) {
[10:20:05.344]                             name <- restart$name
[10:20:05.344]                             if (is.null(name)) 
[10:20:05.344]                               next
[10:20:05.344]                             if (!grepl(pattern, name)) 
[10:20:05.344]                               next
[10:20:05.344]                             invokeRestart(restart)
[10:20:05.344]                             muffled <- TRUE
[10:20:05.344]                             break
[10:20:05.344]                           }
[10:20:05.344]                         }
[10:20:05.344]                       }
[10:20:05.344]                       invisible(muffled)
[10:20:05.344]                     }
[10:20:05.344]                     muffleCondition(cond, pattern = "^muffle")
[10:20:05.344]                   }
[10:20:05.344]                 }
[10:20:05.344]                 else {
[10:20:05.344]                   if (TRUE) {
[10:20:05.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:05.344]                     {
[10:20:05.344]                       inherits <- base::inherits
[10:20:05.344]                       invokeRestart <- base::invokeRestart
[10:20:05.344]                       is.null <- base::is.null
[10:20:05.344]                       muffled <- FALSE
[10:20:05.344]                       if (inherits(cond, "message")) {
[10:20:05.344]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:05.344]                         if (muffled) 
[10:20:05.344]                           invokeRestart("muffleMessage")
[10:20:05.344]                       }
[10:20:05.344]                       else if (inherits(cond, "warning")) {
[10:20:05.344]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:05.344]                         if (muffled) 
[10:20:05.344]                           invokeRestart("muffleWarning")
[10:20:05.344]                       }
[10:20:05.344]                       else if (inherits(cond, "condition")) {
[10:20:05.344]                         if (!is.null(pattern)) {
[10:20:05.344]                           computeRestarts <- base::computeRestarts
[10:20:05.344]                           grepl <- base::grepl
[10:20:05.344]                           restarts <- computeRestarts(cond)
[10:20:05.344]                           for (restart in restarts) {
[10:20:05.344]                             name <- restart$name
[10:20:05.344]                             if (is.null(name)) 
[10:20:05.344]                               next
[10:20:05.344]                             if (!grepl(pattern, name)) 
[10:20:05.344]                               next
[10:20:05.344]                             invokeRestart(restart)
[10:20:05.344]                             muffled <- TRUE
[10:20:05.344]                             break
[10:20:05.344]                           }
[10:20:05.344]                         }
[10:20:05.344]                       }
[10:20:05.344]                       invisible(muffled)
[10:20:05.344]                     }
[10:20:05.344]                     muffleCondition(cond, pattern = "^muffle")
[10:20:05.344]                   }
[10:20:05.344]                 }
[10:20:05.344]             }
[10:20:05.344]         }))
[10:20:05.344]     }, error = function(ex) {
[10:20:05.344]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:05.344]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:05.344]                 ...future.rng), started = ...future.startTime, 
[10:20:05.344]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:05.344]             version = "1.8"), class = "FutureResult")
[10:20:05.344]     }, finally = {
[10:20:05.344]         if (!identical(...future.workdir, getwd())) 
[10:20:05.344]             setwd(...future.workdir)
[10:20:05.344]         {
[10:20:05.344]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:05.344]                 ...future.oldOptions$nwarnings <- NULL
[10:20:05.344]             }
[10:20:05.344]             base::options(...future.oldOptions)
[10:20:05.344]             if (.Platform$OS.type == "windows") {
[10:20:05.344]                 old_names <- names(...future.oldEnvVars)
[10:20:05.344]                 envs <- base::Sys.getenv()
[10:20:05.344]                 names <- names(envs)
[10:20:05.344]                 common <- intersect(names, old_names)
[10:20:05.344]                 added <- setdiff(names, old_names)
[10:20:05.344]                 removed <- setdiff(old_names, names)
[10:20:05.344]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:05.344]                   envs[common]]
[10:20:05.344]                 NAMES <- toupper(changed)
[10:20:05.344]                 args <- list()
[10:20:05.344]                 for (kk in seq_along(NAMES)) {
[10:20:05.344]                   name <- changed[[kk]]
[10:20:05.344]                   NAME <- NAMES[[kk]]
[10:20:05.344]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:05.344]                     next
[10:20:05.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:05.344]                 }
[10:20:05.344]                 NAMES <- toupper(added)
[10:20:05.344]                 for (kk in seq_along(NAMES)) {
[10:20:05.344]                   name <- added[[kk]]
[10:20:05.344]                   NAME <- NAMES[[kk]]
[10:20:05.344]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:05.344]                     next
[10:20:05.344]                   args[[name]] <- ""
[10:20:05.344]                 }
[10:20:05.344]                 NAMES <- toupper(removed)
[10:20:05.344]                 for (kk in seq_along(NAMES)) {
[10:20:05.344]                   name <- removed[[kk]]
[10:20:05.344]                   NAME <- NAMES[[kk]]
[10:20:05.344]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:05.344]                     next
[10:20:05.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:05.344]                 }
[10:20:05.344]                 if (length(args) > 0) 
[10:20:05.344]                   base::do.call(base::Sys.setenv, args = args)
[10:20:05.344]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:05.344]             }
[10:20:05.344]             else {
[10:20:05.344]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:05.344]             }
[10:20:05.344]             {
[10:20:05.344]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:05.344]                   0L) {
[10:20:05.344]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:05.344]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:05.344]                   base::options(opts)
[10:20:05.344]                 }
[10:20:05.344]                 {
[10:20:05.344]                   {
[10:20:05.344]                     NULL
[10:20:05.344]                     RNGkind("Mersenne-Twister")
[10:20:05.344]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:05.344]                       inherits = FALSE)
[10:20:05.344]                   }
[10:20:05.344]                   options(future.plan = NULL)
[10:20:05.344]                   if (is.na(NA_character_)) 
[10:20:05.344]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:05.344]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:05.344]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:05.344]                     .init = FALSE)
[10:20:05.344]                 }
[10:20:05.344]             }
[10:20:05.344]         }
[10:20:05.344]     })
[10:20:05.344]     if (TRUE) {
[10:20:05.344]         base::sink(type = "output", split = FALSE)
[10:20:05.344]         if (TRUE) {
[10:20:05.344]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:05.344]         }
[10:20:05.344]         else {
[10:20:05.344]             ...future.result["stdout"] <- base::list(NULL)
[10:20:05.344]         }
[10:20:05.344]         base::close(...future.stdout)
[10:20:05.344]         ...future.stdout <- NULL
[10:20:05.344]     }
[10:20:05.344]     ...future.result$conditions <- ...future.conditions
[10:20:05.344]     ...future.result$finished <- base::Sys.time()
[10:20:05.344]     ...future.result
[10:20:05.344] }
[10:20:05.345] assign_globals() ...
[10:20:05.345] List of 5
[10:20:05.345]  $ ...future.FUN            :function (x)  
[10:20:05.345]  $ future.call.arguments    : list()
[10:20:05.345]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:05.345]  $ ...future.elements_ii    :List of 2
[10:20:05.345]   ..$ : int 1
[10:20:05.345]   ..$ : int 0
[10:20:05.345]  $ ...future.seeds_ii       : NULL
[10:20:05.345]  $ ...future.globals.maxSize: NULL
[10:20:05.345]  - attr(*, "where")=List of 5
[10:20:05.345]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:05.345]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:20:05.345]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:05.345]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:05.345]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:05.345]  - attr(*, "resolved")= logi FALSE
[10:20:05.345]  - attr(*, "total_size")= num 5632
[10:20:05.345]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:05.345]  - attr(*, "already-done")= logi TRUE
[10:20:05.352] - reassign environment for ‘...future.FUN’
[10:20:05.352] - copied ‘...future.FUN’ to environment
[10:20:05.352] - copied ‘future.call.arguments’ to environment
[10:20:05.352] - copied ‘...future.elements_ii’ to environment
[10:20:05.352] - copied ‘...future.seeds_ii’ to environment
[10:20:05.352] - copied ‘...future.globals.maxSize’ to environment
[10:20:05.352] assign_globals() ... done
[10:20:05.352] plan(): Setting new future strategy stack:
[10:20:05.352] List of future strategies:
[10:20:05.352] 1. sequential:
[10:20:05.352]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:05.352]    - tweaked: FALSE
[10:20:05.352]    - call: NULL
[10:20:05.353] plan(): nbrOfWorkers() = 1
[10:20:05.855] plan(): Setting new future strategy stack:
[10:20:05.855] List of future strategies:
[10:20:05.855] 1. sequential:
[10:20:05.855]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:05.855]    - tweaked: FALSE
[10:20:05.855]    - call: plan(strategy)
[10:20:05.855] plan(): nbrOfWorkers() = 1
[10:20:05.856] SequentialFuture started (and completed)
[10:20:05.856] - Launch lazy future ... done
[10:20:05.856] run() for ‘SequentialFuture’ ... done
[10:20:05.856] Created future:
[10:20:05.856] SequentialFuture:
[10:20:05.856] Label: ‘future_lapply-1’
[10:20:05.856] Expression:
[10:20:05.856] {
[10:20:05.856]     do.call(function(...) {
[10:20:05.856]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:05.856]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:05.856]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:05.856]             on.exit(options(oopts), add = TRUE)
[10:20:05.856]         }
[10:20:05.856]         {
[10:20:05.856]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:05.856]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:05.856]                 ...future.FUN(...future.X_jj, ...)
[10:20:05.856]             })
[10:20:05.856]         }
[10:20:05.856]     }, args = future.call.arguments)
[10:20:05.856] }
[10:20:05.856] Lazy evaluation: FALSE
[10:20:05.856] Asynchronous evaluation: FALSE
[10:20:05.856] Local evaluation: TRUE
[10:20:05.856] Environment: R_GlobalEnv
[10:20:05.856] Capture standard output: TRUE
[10:20:05.856] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:05.856] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:05.856] Packages: <none>
[10:20:05.856] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:05.856] Resolved: TRUE
[10:20:05.856] Value: 55 bytes of class ‘list’
[10:20:05.856] Early signaling: FALSE
[10:20:05.856] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:05.856] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:05.857] Chunk #1 of 1 ... DONE
[10:20:05.857] Launching 1 futures (chunks) ... DONE
[10:20:05.857] Resolving 1 futures (chunks) ...
[10:20:05.857] resolve() on list ...
[10:20:05.857]  recursive: 0
[10:20:05.858]  length: 1
[10:20:05.858] 
[10:20:05.858] resolved() for ‘SequentialFuture’ ...
[10:20:05.858] - state: ‘finished’
[10:20:05.858] - run: TRUE
[10:20:05.858] - result: ‘FutureResult’
[10:20:05.858] resolved() for ‘SequentialFuture’ ... done
[10:20:05.858] Future #1
[10:20:05.858] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:20:05.858] - nx: 1
[10:20:05.858] - relay: TRUE
[10:20:05.859] - stdout: TRUE
[10:20:05.859] - signal: TRUE
[10:20:05.859] - resignal: FALSE
[10:20:05.859] - force: TRUE
[10:20:05.859] - relayed: [n=1] FALSE
[10:20:05.859] - queued futures: [n=1] FALSE
[10:20:05.859]  - until=1
[10:20:05.859]  - relaying element #1
[10:20:05.859] - relayed: [n=1] TRUE
[10:20:05.859] - queued futures: [n=1] TRUE
[10:20:05.860] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:20:05.860]  length: 0 (resolved future 1)
[10:20:05.860] Relaying remaining futures
[10:20:05.860] signalConditionsASAP(NULL, pos=0) ...
[10:20:05.860] - nx: 1
[10:20:05.860] - relay: TRUE
[10:20:05.860] - stdout: TRUE
[10:20:05.860] - signal: TRUE
[10:20:05.860] - resignal: FALSE
[10:20:05.860] - force: TRUE
[10:20:05.860] - relayed: [n=1] TRUE
[10:20:05.860] - queued futures: [n=1] TRUE
 - flush all
[10:20:05.861] - relayed: [n=1] TRUE
[10:20:05.861] - queued futures: [n=1] TRUE
[10:20:05.861] signalConditionsASAP(NULL, pos=0) ... done
[10:20:05.861] resolve() on list ... DONE
[10:20:05.861]  - Number of value chunks collected: 1
[10:20:05.861] Resolving 1 futures (chunks) ... DONE
[10:20:05.861] Reducing values from 1 chunks ...
[10:20:05.861]  - Number of values collected after concatenation: 2
[10:20:05.861]  - Number of values expected: 2
[10:20:05.861] Reducing values from 1 chunks ... DONE
[10:20:05.861] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[10:20:05.862] future_lapply() ...
[10:20:05.862] Number of chunks: 1
[10:20:05.863] getGlobalsAndPackagesXApply() ...
[10:20:05.863]  - future.globals: TRUE
[10:20:05.863] getGlobalsAndPackages() ...
[10:20:05.863] Searching for globals...
[10:20:05.864] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:20:05.864] Searching for globals ... DONE
[10:20:05.864] Resolving globals: FALSE
[10:20:05.865] The total size of the 1 globals is 841 bytes (841 bytes)
[10:20:05.865] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[10:20:05.865] - globals: [1] ‘FUN’
[10:20:05.865] 
[10:20:05.865] getGlobalsAndPackages() ... DONE
[10:20:05.866]  - globals found/used: [n=1] ‘FUN’
[10:20:05.866]  - needed namespaces: [n=0] 
[10:20:05.866] Finding globals ... DONE
[10:20:05.866]  - use_args: TRUE
[10:20:05.866]  - Getting '...' globals ...
[10:20:05.866] resolve() on list ...
[10:20:05.866]  recursive: 0
[10:20:05.866]  length: 1
[10:20:05.866]  elements: ‘...’
[10:20:05.867]  length: 0 (resolved future 1)
[10:20:05.867] resolve() on list ... DONE
[10:20:05.867]    - '...' content: [n=0] 
[10:20:05.867] List of 1
[10:20:05.867]  $ ...: list()
[10:20:05.867]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:05.867]  - attr(*, "where")=List of 1
[10:20:05.867]   ..$ ...:<environment: 0x557fc17a1f58> 
[10:20:05.867]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:05.867]  - attr(*, "resolved")= logi TRUE
[10:20:05.867]  - attr(*, "total_size")= num NA
[10:20:05.869]  - Getting '...' globals ... DONE
[10:20:05.869] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:20:05.870] List of 2
[10:20:05.870]  $ ...future.FUN:function (x)  
[10:20:05.870]  $ ...          : list()
[10:20:05.870]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:05.870]  - attr(*, "where")=List of 2
[10:20:05.870]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:05.870]   ..$ ...          :<environment: 0x557fc17a1f58> 
[10:20:05.870]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:05.870]  - attr(*, "resolved")= logi FALSE
[10:20:05.870]  - attr(*, "total_size")= num 5632
[10:20:05.872] Packages to be attached in all futures: [n=0] 
[10:20:05.872] getGlobalsAndPackagesXApply() ... DONE
[10:20:05.873] Number of futures (= number of chunks): 1
[10:20:05.873] Launching 1 futures (chunks) ...
[10:20:05.873] Chunk #1 of 1 ...
[10:20:05.873]  - Finding globals in 'X' for chunk #1 ...
[10:20:05.873] getGlobalsAndPackages() ...
[10:20:05.873] Searching for globals...
[10:20:05.873] 
[10:20:05.873] Searching for globals ... DONE
[10:20:05.873] - globals: [0] <none>
[10:20:05.874] getGlobalsAndPackages() ... DONE
[10:20:05.874]    + additional globals found: [n=0] 
[10:20:05.874]    + additional namespaces needed: [n=0] 
[10:20:05.874]  - Finding globals in 'X' for chunk #1 ... DONE
[10:20:05.874]  - seeds: <none>
[10:20:05.874]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:05.874] getGlobalsAndPackages() ...
[10:20:05.874] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:05.874] Resolving globals: FALSE
[10:20:05.874] Tweak future expression to call with '...' arguments ...
[10:20:05.874] {
[10:20:05.874]     do.call(function(...) {
[10:20:05.874]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:05.874]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:05.874]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:05.874]             on.exit(options(oopts), add = TRUE)
[10:20:05.874]         }
[10:20:05.874]         {
[10:20:05.874]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:05.874]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:05.874]                 ...future.FUN(...future.X_jj, ...)
[10:20:05.874]             })
[10:20:05.874]         }
[10:20:05.874]     }, args = future.call.arguments)
[10:20:05.874] }
[10:20:05.877] Tweak future expression to call with '...' arguments ... DONE
[10:20:05.877] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:05.877] 
[10:20:05.877] getGlobalsAndPackages() ... DONE
[10:20:05.877] run() for ‘Future’ ...
[10:20:05.878] - state: ‘created’
[10:20:05.878] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:20:05.878] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:05.878] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:05.878]   - Field: ‘label’
[10:20:05.878]   - Field: ‘local’
[10:20:05.878]   - Field: ‘owner’
[10:20:05.878]   - Field: ‘envir’
[10:20:05.879]   - Field: ‘packages’
[10:20:05.879]   - Field: ‘gc’
[10:20:05.879]   - Field: ‘conditions’
[10:20:05.879]   - Field: ‘expr’
[10:20:05.879]   - Field: ‘uuid’
[10:20:05.879]   - Field: ‘seed’
[10:20:05.879]   - Field: ‘version’
[10:20:05.879]   - Field: ‘result’
[10:20:05.879]   - Field: ‘asynchronous’
[10:20:05.879]   - Field: ‘calls’
[10:20:05.879]   - Field: ‘globals’
[10:20:05.879]   - Field: ‘stdout’
[10:20:05.880]   - Field: ‘earlySignal’
[10:20:05.880]   - Field: ‘lazy’
[10:20:05.880]   - Field: ‘state’
[10:20:05.880] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:05.880] - Launch lazy future ...
[10:20:05.880] Packages needed by the future expression (n = 0): <none>
[10:20:05.880] Packages needed by future strategies (n = 0): <none>
[10:20:05.881] {
[10:20:05.881]     {
[10:20:05.881]         {
[10:20:05.881]             ...future.startTime <- base::Sys.time()
[10:20:05.881]             {
[10:20:05.881]                 {
[10:20:05.881]                   {
[10:20:05.881]                     base::local({
[10:20:05.881]                       has_future <- base::requireNamespace("future", 
[10:20:05.881]                         quietly = TRUE)
[10:20:05.881]                       if (has_future) {
[10:20:05.881]                         ns <- base::getNamespace("future")
[10:20:05.881]                         version <- ns[[".package"]][["version"]]
[10:20:05.881]                         if (is.null(version)) 
[10:20:05.881]                           version <- utils::packageVersion("future")
[10:20:05.881]                       }
[10:20:05.881]                       else {
[10:20:05.881]                         version <- NULL
[10:20:05.881]                       }
[10:20:05.881]                       if (!has_future || version < "1.8.0") {
[10:20:05.881]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:05.881]                           "", base::R.version$version.string), 
[10:20:05.881]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:05.881]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:05.881]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:05.881]                             "release", "version")], collapse = " "), 
[10:20:05.881]                           hostname = base::Sys.info()[["nodename"]])
[10:20:05.881]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:05.881]                           info)
[10:20:05.881]                         info <- base::paste(info, collapse = "; ")
[10:20:05.881]                         if (!has_future) {
[10:20:05.881]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:05.881]                             info)
[10:20:05.881]                         }
[10:20:05.881]                         else {
[10:20:05.881]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:05.881]                             info, version)
[10:20:05.881]                         }
[10:20:05.881]                         base::stop(msg)
[10:20:05.881]                       }
[10:20:05.881]                     })
[10:20:05.881]                   }
[10:20:05.881]                   ...future.strategy.old <- future::plan("list")
[10:20:05.881]                   options(future.plan = NULL)
[10:20:05.881]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:05.881]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:05.881]                 }
[10:20:05.881]                 ...future.workdir <- getwd()
[10:20:05.881]             }
[10:20:05.881]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:05.881]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:05.881]         }
[10:20:05.881]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:05.881]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:05.881]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:05.881]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:05.881]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:05.881]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:05.881]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:05.881]             base::names(...future.oldOptions))
[10:20:05.881]     }
[10:20:05.881]     if (TRUE) {
[10:20:05.881]     }
[10:20:05.881]     else {
[10:20:05.881]         if (NA) {
[10:20:05.881]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:05.881]                 open = "w")
[10:20:05.881]         }
[10:20:05.881]         else {
[10:20:05.881]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:05.881]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:05.881]         }
[10:20:05.881]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:05.881]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:05.881]             base::sink(type = "output", split = FALSE)
[10:20:05.881]             base::close(...future.stdout)
[10:20:05.881]         }, add = TRUE)
[10:20:05.881]     }
[10:20:05.881]     ...future.frame <- base::sys.nframe()
[10:20:05.881]     ...future.conditions <- base::list()
[10:20:05.881]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:05.881]     if (FALSE) {
[10:20:05.881]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:05.881]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:05.881]     }
[10:20:05.881]     ...future.result <- base::tryCatch({
[10:20:05.881]         base::withCallingHandlers({
[10:20:05.881]             ...future.value <- base::withVisible(base::local({
[10:20:05.881]                 do.call(function(...) {
[10:20:05.881]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:05.881]                   if (!identical(...future.globals.maxSize.org, 
[10:20:05.881]                     ...future.globals.maxSize)) {
[10:20:05.881]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:05.881]                     on.exit(options(oopts), add = TRUE)
[10:20:05.881]                   }
[10:20:05.881]                   {
[10:20:05.881]                     lapply(seq_along(...future.elements_ii), 
[10:20:05.881]                       FUN = function(jj) {
[10:20:05.881]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:05.881]                         ...future.FUN(...future.X_jj, ...)
[10:20:05.881]                       })
[10:20:05.881]                   }
[10:20:05.881]                 }, args = future.call.arguments)
[10:20:05.881]             }))
[10:20:05.881]             future::FutureResult(value = ...future.value$value, 
[10:20:05.881]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:05.881]                   ...future.rng), globalenv = if (FALSE) 
[10:20:05.881]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:05.881]                     ...future.globalenv.names))
[10:20:05.881]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:05.881]         }, condition = base::local({
[10:20:05.881]             c <- base::c
[10:20:05.881]             inherits <- base::inherits
[10:20:05.881]             invokeRestart <- base::invokeRestart
[10:20:05.881]             length <- base::length
[10:20:05.881]             list <- base::list
[10:20:05.881]             seq.int <- base::seq.int
[10:20:05.881]             signalCondition <- base::signalCondition
[10:20:05.881]             sys.calls <- base::sys.calls
[10:20:05.881]             `[[` <- base::`[[`
[10:20:05.881]             `+` <- base::`+`
[10:20:05.881]             `<<-` <- base::`<<-`
[10:20:05.881]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:05.881]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:05.881]                   3L)]
[10:20:05.881]             }
[10:20:05.881]             function(cond) {
[10:20:05.881]                 is_error <- inherits(cond, "error")
[10:20:05.881]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:05.881]                   NULL)
[10:20:05.881]                 if (is_error) {
[10:20:05.881]                   sessionInformation <- function() {
[10:20:05.881]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:05.881]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:05.881]                       search = base::search(), system = base::Sys.info())
[10:20:05.881]                   }
[10:20:05.881]                   ...future.conditions[[length(...future.conditions) + 
[10:20:05.881]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:05.881]                     cond$call), session = sessionInformation(), 
[10:20:05.881]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:05.881]                   signalCondition(cond)
[10:20:05.881]                 }
[10:20:05.881]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:05.881]                 "immediateCondition"))) {
[10:20:05.881]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:05.881]                   ...future.conditions[[length(...future.conditions) + 
[10:20:05.881]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:05.881]                   if (TRUE && !signal) {
[10:20:05.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:05.881]                     {
[10:20:05.881]                       inherits <- base::inherits
[10:20:05.881]                       invokeRestart <- base::invokeRestart
[10:20:05.881]                       is.null <- base::is.null
[10:20:05.881]                       muffled <- FALSE
[10:20:05.881]                       if (inherits(cond, "message")) {
[10:20:05.881]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:05.881]                         if (muffled) 
[10:20:05.881]                           invokeRestart("muffleMessage")
[10:20:05.881]                       }
[10:20:05.881]                       else if (inherits(cond, "warning")) {
[10:20:05.881]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:05.881]                         if (muffled) 
[10:20:05.881]                           invokeRestart("muffleWarning")
[10:20:05.881]                       }
[10:20:05.881]                       else if (inherits(cond, "condition")) {
[10:20:05.881]                         if (!is.null(pattern)) {
[10:20:05.881]                           computeRestarts <- base::computeRestarts
[10:20:05.881]                           grepl <- base::grepl
[10:20:05.881]                           restarts <- computeRestarts(cond)
[10:20:05.881]                           for (restart in restarts) {
[10:20:05.881]                             name <- restart$name
[10:20:05.881]                             if (is.null(name)) 
[10:20:05.881]                               next
[10:20:05.881]                             if (!grepl(pattern, name)) 
[10:20:05.881]                               next
[10:20:05.881]                             invokeRestart(restart)
[10:20:05.881]                             muffled <- TRUE
[10:20:05.881]                             break
[10:20:05.881]                           }
[10:20:05.881]                         }
[10:20:05.881]                       }
[10:20:05.881]                       invisible(muffled)
[10:20:05.881]                     }
[10:20:05.881]                     muffleCondition(cond, pattern = "^muffle")
[10:20:05.881]                   }
[10:20:05.881]                 }
[10:20:05.881]                 else {
[10:20:05.881]                   if (TRUE) {
[10:20:05.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:05.881]                     {
[10:20:05.881]                       inherits <- base::inherits
[10:20:05.881]                       invokeRestart <- base::invokeRestart
[10:20:05.881]                       is.null <- base::is.null
[10:20:05.881]                       muffled <- FALSE
[10:20:05.881]                       if (inherits(cond, "message")) {
[10:20:05.881]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:05.881]                         if (muffled) 
[10:20:05.881]                           invokeRestart("muffleMessage")
[10:20:05.881]                       }
[10:20:05.881]                       else if (inherits(cond, "warning")) {
[10:20:05.881]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:05.881]                         if (muffled) 
[10:20:05.881]                           invokeRestart("muffleWarning")
[10:20:05.881]                       }
[10:20:05.881]                       else if (inherits(cond, "condition")) {
[10:20:05.881]                         if (!is.null(pattern)) {
[10:20:05.881]                           computeRestarts <- base::computeRestarts
[10:20:05.881]                           grepl <- base::grepl
[10:20:05.881]                           restarts <- computeRestarts(cond)
[10:20:05.881]                           for (restart in restarts) {
[10:20:05.881]                             name <- restart$name
[10:20:05.881]                             if (is.null(name)) 
[10:20:05.881]                               next
[10:20:05.881]                             if (!grepl(pattern, name)) 
[10:20:05.881]                               next
[10:20:05.881]                             invokeRestart(restart)
[10:20:05.881]                             muffled <- TRUE
[10:20:05.881]                             break
[10:20:05.881]                           }
[10:20:05.881]                         }
[10:20:05.881]                       }
[10:20:05.881]                       invisible(muffled)
[10:20:05.881]                     }
[10:20:05.881]                     muffleCondition(cond, pattern = "^muffle")
[10:20:05.881]                   }
[10:20:05.881]                 }
[10:20:05.881]             }
[10:20:05.881]         }))
[10:20:05.881]     }, error = function(ex) {
[10:20:05.881]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:05.881]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:05.881]                 ...future.rng), started = ...future.startTime, 
[10:20:05.881]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:05.881]             version = "1.8"), class = "FutureResult")
[10:20:05.881]     }, finally = {
[10:20:05.881]         if (!identical(...future.workdir, getwd())) 
[10:20:05.881]             setwd(...future.workdir)
[10:20:05.881]         {
[10:20:05.881]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:05.881]                 ...future.oldOptions$nwarnings <- NULL
[10:20:05.881]             }
[10:20:05.881]             base::options(...future.oldOptions)
[10:20:05.881]             if (.Platform$OS.type == "windows") {
[10:20:05.881]                 old_names <- names(...future.oldEnvVars)
[10:20:05.881]                 envs <- base::Sys.getenv()
[10:20:05.881]                 names <- names(envs)
[10:20:05.881]                 common <- intersect(names, old_names)
[10:20:05.881]                 added <- setdiff(names, old_names)
[10:20:05.881]                 removed <- setdiff(old_names, names)
[10:20:05.881]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:05.881]                   envs[common]]
[10:20:05.881]                 NAMES <- toupper(changed)
[10:20:05.881]                 args <- list()
[10:20:05.881]                 for (kk in seq_along(NAMES)) {
[10:20:05.881]                   name <- changed[[kk]]
[10:20:05.881]                   NAME <- NAMES[[kk]]
[10:20:05.881]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:05.881]                     next
[10:20:05.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:05.881]                 }
[10:20:05.881]                 NAMES <- toupper(added)
[10:20:05.881]                 for (kk in seq_along(NAMES)) {
[10:20:05.881]                   name <- added[[kk]]
[10:20:05.881]                   NAME <- NAMES[[kk]]
[10:20:05.881]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:05.881]                     next
[10:20:05.881]                   args[[name]] <- ""
[10:20:05.881]                 }
[10:20:05.881]                 NAMES <- toupper(removed)
[10:20:05.881]                 for (kk in seq_along(NAMES)) {
[10:20:05.881]                   name <- removed[[kk]]
[10:20:05.881]                   NAME <- NAMES[[kk]]
[10:20:05.881]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:05.881]                     next
[10:20:05.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:05.881]                 }
[10:20:05.881]                 if (length(args) > 0) 
[10:20:05.881]                   base::do.call(base::Sys.setenv, args = args)
[10:20:05.881]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:05.881]             }
[10:20:05.881]             else {
[10:20:05.881]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:05.881]             }
[10:20:05.881]             {
[10:20:05.881]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:05.881]                   0L) {
[10:20:05.881]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:05.881]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:05.881]                   base::options(opts)
[10:20:05.881]                 }
[10:20:05.881]                 {
[10:20:05.881]                   {
[10:20:05.881]                     NULL
[10:20:05.881]                     RNGkind("Mersenne-Twister")
[10:20:05.881]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:05.881]                       inherits = FALSE)
[10:20:05.881]                   }
[10:20:05.881]                   options(future.plan = NULL)
[10:20:05.881]                   if (is.na(NA_character_)) 
[10:20:05.881]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:05.881]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:05.881]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:05.881]                     .init = FALSE)
[10:20:05.881]                 }
[10:20:05.881]             }
[10:20:05.881]         }
[10:20:05.881]     })
[10:20:05.881]     if (FALSE) {
[10:20:05.881]         base::sink(type = "output", split = FALSE)
[10:20:05.881]         if (NA) {
[10:20:05.881]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:05.881]         }
[10:20:05.881]         else {
[10:20:05.881]             ...future.result["stdout"] <- base::list(NULL)
[10:20:05.881]         }
[10:20:05.881]         base::close(...future.stdout)
[10:20:05.881]         ...future.stdout <- NULL
[10:20:05.881]     }
[10:20:05.881]     ...future.result$conditions <- ...future.conditions
[10:20:05.881]     ...future.result$finished <- base::Sys.time()
[10:20:05.881]     ...future.result
[10:20:05.881] }
[10:20:05.882] assign_globals() ...
[10:20:05.883] List of 5
[10:20:05.883]  $ ...future.FUN            :function (x)  
[10:20:05.883]  $ future.call.arguments    : list()
[10:20:05.883]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:05.883]  $ ...future.elements_ii    :List of 2
[10:20:05.883]   ..$ : int 1
[10:20:05.883]   ..$ : int 0
[10:20:05.883]  $ ...future.seeds_ii       : NULL
[10:20:05.883]  $ ...future.globals.maxSize: NULL
[10:20:05.883]  - attr(*, "where")=List of 5
[10:20:05.883]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:05.883]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:20:05.883]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:05.883]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:05.883]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:05.883]  - attr(*, "resolved")= logi FALSE
[10:20:05.883]  - attr(*, "total_size")= num 5632
[10:20:05.883]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:05.883]  - attr(*, "already-done")= logi TRUE
[10:20:05.887] - reassign environment for ‘...future.FUN’
[10:20:05.888] - copied ‘...future.FUN’ to environment
[10:20:05.888] - copied ‘future.call.arguments’ to environment
[10:20:05.888] - copied ‘...future.elements_ii’ to environment
[10:20:05.888] - copied ‘...future.seeds_ii’ to environment
[10:20:05.888] - copied ‘...future.globals.maxSize’ to environment
[10:20:05.888] assign_globals() ... done
[10:20:05.888] plan(): Setting new future strategy stack:
[10:20:05.888] List of future strategies:
[10:20:05.888] 1. sequential:
[10:20:05.888]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:05.888]    - tweaked: FALSE
[10:20:05.888]    - call: NULL
[10:20:05.889] plan(): nbrOfWorkers() = 1
[10:20:06.391] plan(): Setting new future strategy stack:
[10:20:06.391] List of future strategies:
[10:20:06.391] 1. sequential:
[10:20:06.391]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:06.391]    - tweaked: FALSE
[10:20:06.391]    - call: plan(strategy)
[10:20:06.391] plan(): nbrOfWorkers() = 1
[10:20:06.392] SequentialFuture started (and completed)
[10:20:06.392] - Launch lazy future ... done
[10:20:06.392] run() for ‘SequentialFuture’ ... done
[10:20:06.392] Created future:
[10:20:06.392] SequentialFuture:
[10:20:06.392] Label: ‘future_lapply-1’
[10:20:06.392] Expression:
[10:20:06.392] {
[10:20:06.392]     do.call(function(...) {
[10:20:06.392]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:06.392]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:06.392]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:06.392]             on.exit(options(oopts), add = TRUE)
[10:20:06.392]         }
[10:20:06.392]         {
[10:20:06.392]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:06.392]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:06.392]                 ...future.FUN(...future.X_jj, ...)
[10:20:06.392]             })
[10:20:06.392]         }
[10:20:06.392]     }, args = future.call.arguments)
[10:20:06.392] }
[10:20:06.392] Lazy evaluation: FALSE
[10:20:06.392] Asynchronous evaluation: FALSE
[10:20:06.392] Local evaluation: TRUE
[10:20:06.392] Environment: R_GlobalEnv
[10:20:06.392] Capture standard output: NA
[10:20:06.392] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:06.392] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:06.392] Packages: <none>
[10:20:06.392] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:06.392] Resolved: TRUE
[10:20:06.392] Value: 55 bytes of class ‘list’
[10:20:06.392] Early signaling: FALSE
[10:20:06.392] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:06.392] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:06.393] Chunk #1 of 1 ... DONE
[10:20:06.393] Launching 1 futures (chunks) ... DONE
[10:20:06.393] Resolving 1 futures (chunks) ...
[10:20:06.393] resolve() on list ...
[10:20:06.393]  recursive: 0
[10:20:06.393]  length: 1
[10:20:06.393] 
[10:20:06.394] resolved() for ‘SequentialFuture’ ...
[10:20:06.394] - state: ‘finished’
[10:20:06.394] - run: TRUE
[10:20:06.394] - result: ‘FutureResult’
[10:20:06.394] resolved() for ‘SequentialFuture’ ... done
[10:20:06.394] Future #1
[10:20:06.394] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:20:06.394] - nx: 1
[10:20:06.394] - relay: TRUE
[10:20:06.394] - stdout: TRUE
[10:20:06.394] - signal: TRUE
[10:20:06.395] - resignal: FALSE
[10:20:06.395] - force: TRUE
[10:20:06.395] - relayed: [n=1] FALSE
[10:20:06.395] - queued futures: [n=1] FALSE
[10:20:06.395]  - until=1
[10:20:06.395]  - relaying element #1
[10:20:06.395] - relayed: [n=1] TRUE
[10:20:06.395] - queued futures: [n=1] TRUE
[10:20:06.395] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:20:06.395]  length: 0 (resolved future 1)
[10:20:06.395] Relaying remaining futures
[10:20:06.396] signalConditionsASAP(NULL, pos=0) ...
[10:20:06.396] - nx: 1
[10:20:06.396] - relay: TRUE
[10:20:06.396] - stdout: TRUE
[10:20:06.396] - signal: TRUE
[10:20:06.396] - resignal: FALSE
[10:20:06.396] - force: TRUE
[10:20:06.396] - relayed: [n=1] TRUE
[10:20:06.396] - queued futures: [n=1] TRUE
 - flush all
[10:20:06.396] - relayed: [n=1] TRUE
[10:20:06.396] - queued futures: [n=1] TRUE
[10:20:06.396] signalConditionsASAP(NULL, pos=0) ... done
[10:20:06.397] resolve() on list ... DONE
[10:20:06.397]  - Number of value chunks collected: 1
[10:20:06.397] Resolving 1 futures (chunks) ... DONE
[10:20:06.397] Reducing values from 1 chunks ...
[10:20:06.397]  - Number of values collected after concatenation: 2
[10:20:06.397]  - Number of values expected: 2
[10:20:06.397] Reducing values from 1 chunks ... DONE
[10:20:06.397] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[10:20:06.398] future_mapply() ...
[10:20:06.398] Number of chunks: 1
[10:20:06.398] getGlobalsAndPackagesXApply() ...
[10:20:06.398]  - future.globals: TRUE
[10:20:06.398] getGlobalsAndPackages() ...
[10:20:06.398] Searching for globals...
[10:20:06.400] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:20:06.400] Searching for globals ... DONE
[10:20:06.400] Resolving globals: FALSE
[10:20:06.400] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[10:20:06.401] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[10:20:06.401] - globals: [1] ‘FUN’
[10:20:06.401] 
[10:20:06.401] getGlobalsAndPackages() ... DONE
[10:20:06.401]  - globals found/used: [n=1] ‘FUN’
[10:20:06.401]  - needed namespaces: [n=0] 
[10:20:06.401] Finding globals ... DONE
[10:20:06.401] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:20:06.401] List of 2
[10:20:06.401]  $ ...future.FUN:function (x, y)  
[10:20:06.401]  $ MoreArgs     : NULL
[10:20:06.401]  - attr(*, "where")=List of 2
[10:20:06.401]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:06.401]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:20:06.401]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:06.401]  - attr(*, "resolved")= logi FALSE
[10:20:06.401]  - attr(*, "total_size")= num NA
[10:20:06.406] Packages to be attached in all futures: [n=0] 
[10:20:06.406] getGlobalsAndPackagesXApply() ... DONE
[10:20:06.406] Number of futures (= number of chunks): 1
[10:20:06.406] Launching 1 futures (chunks) ...
[10:20:06.406] Chunk #1 of 1 ...
[10:20:06.406]  - Finding globals in '...' for chunk #1 ...
[10:20:06.406] getGlobalsAndPackages() ...
[10:20:06.406] Searching for globals...
[10:20:06.407] 
[10:20:06.407] Searching for globals ... DONE
[10:20:06.407] - globals: [0] <none>
[10:20:06.407] getGlobalsAndPackages() ... DONE
[10:20:06.407]    + additional globals found: [n=0] 
[10:20:06.407]    + additional namespaces needed: [n=0] 
[10:20:06.407]  - Finding globals in '...' for chunk #1 ... DONE
[10:20:06.407]  - seeds: <none>
[10:20:06.407]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:06.407] getGlobalsAndPackages() ...
[10:20:06.407] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:06.408] Resolving globals: FALSE
[10:20:06.408] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[10:20:06.408] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:20:06.409] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:06.409] 
[10:20:06.409] getGlobalsAndPackages() ... DONE
[10:20:06.409] run() for ‘Future’ ...
[10:20:06.409] - state: ‘created’
[10:20:06.409] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:20:06.409] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:06.410] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:06.410]   - Field: ‘label’
[10:20:06.410]   - Field: ‘local’
[10:20:06.410]   - Field: ‘owner’
[10:20:06.410]   - Field: ‘envir’
[10:20:06.410]   - Field: ‘packages’
[10:20:06.410]   - Field: ‘gc’
[10:20:06.410]   - Field: ‘conditions’
[10:20:06.410]   - Field: ‘expr’
[10:20:06.410]   - Field: ‘uuid’
[10:20:06.410]   - Field: ‘seed’
[10:20:06.411]   - Field: ‘version’
[10:20:06.411]   - Field: ‘result’
[10:20:06.411]   - Field: ‘asynchronous’
[10:20:06.411]   - Field: ‘calls’
[10:20:06.411]   - Field: ‘globals’
[10:20:06.411]   - Field: ‘stdout’
[10:20:06.411]   - Field: ‘earlySignal’
[10:20:06.411]   - Field: ‘lazy’
[10:20:06.411]   - Field: ‘state’
[10:20:06.411] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:06.411] - Launch lazy future ...
[10:20:06.412] Packages needed by the future expression (n = 0): <none>
[10:20:06.412] Packages needed by future strategies (n = 0): <none>
[10:20:06.412] {
[10:20:06.412]     {
[10:20:06.412]         {
[10:20:06.412]             ...future.startTime <- base::Sys.time()
[10:20:06.412]             {
[10:20:06.412]                 {
[10:20:06.412]                   {
[10:20:06.412]                     base::local({
[10:20:06.412]                       has_future <- base::requireNamespace("future", 
[10:20:06.412]                         quietly = TRUE)
[10:20:06.412]                       if (has_future) {
[10:20:06.412]                         ns <- base::getNamespace("future")
[10:20:06.412]                         version <- ns[[".package"]][["version"]]
[10:20:06.412]                         if (is.null(version)) 
[10:20:06.412]                           version <- utils::packageVersion("future")
[10:20:06.412]                       }
[10:20:06.412]                       else {
[10:20:06.412]                         version <- NULL
[10:20:06.412]                       }
[10:20:06.412]                       if (!has_future || version < "1.8.0") {
[10:20:06.412]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:06.412]                           "", base::R.version$version.string), 
[10:20:06.412]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:06.412]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:06.412]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:06.412]                             "release", "version")], collapse = " "), 
[10:20:06.412]                           hostname = base::Sys.info()[["nodename"]])
[10:20:06.412]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:06.412]                           info)
[10:20:06.412]                         info <- base::paste(info, collapse = "; ")
[10:20:06.412]                         if (!has_future) {
[10:20:06.412]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:06.412]                             info)
[10:20:06.412]                         }
[10:20:06.412]                         else {
[10:20:06.412]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:06.412]                             info, version)
[10:20:06.412]                         }
[10:20:06.412]                         base::stop(msg)
[10:20:06.412]                       }
[10:20:06.412]                     })
[10:20:06.412]                   }
[10:20:06.412]                   ...future.strategy.old <- future::plan("list")
[10:20:06.412]                   options(future.plan = NULL)
[10:20:06.412]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:06.412]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:06.412]                 }
[10:20:06.412]                 ...future.workdir <- getwd()
[10:20:06.412]             }
[10:20:06.412]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:06.412]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:06.412]         }
[10:20:06.412]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:06.412]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:06.412]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:06.412]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:06.412]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:06.412]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:06.412]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:06.412]             base::names(...future.oldOptions))
[10:20:06.412]     }
[10:20:06.412]     if (FALSE) {
[10:20:06.412]     }
[10:20:06.412]     else {
[10:20:06.412]         if (FALSE) {
[10:20:06.412]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:06.412]                 open = "w")
[10:20:06.412]         }
[10:20:06.412]         else {
[10:20:06.412]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:06.412]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:06.412]         }
[10:20:06.412]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:06.412]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:06.412]             base::sink(type = "output", split = FALSE)
[10:20:06.412]             base::close(...future.stdout)
[10:20:06.412]         }, add = TRUE)
[10:20:06.412]     }
[10:20:06.412]     ...future.frame <- base::sys.nframe()
[10:20:06.412]     ...future.conditions <- base::list()
[10:20:06.412]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:06.412]     if (FALSE) {
[10:20:06.412]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:06.412]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:06.412]     }
[10:20:06.412]     ...future.result <- base::tryCatch({
[10:20:06.412]         base::withCallingHandlers({
[10:20:06.412]             ...future.value <- base::withVisible(base::local({
[10:20:06.412]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:06.412]                 if (!identical(...future.globals.maxSize.org, 
[10:20:06.412]                   ...future.globals.maxSize)) {
[10:20:06.412]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:06.412]                   on.exit(options(oopts), add = TRUE)
[10:20:06.412]                 }
[10:20:06.412]                 {
[10:20:06.412]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:06.412]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:20:06.412]                     USE.NAMES = FALSE)
[10:20:06.412]                   do.call(mapply, args = args)
[10:20:06.412]                 }
[10:20:06.412]             }))
[10:20:06.412]             future::FutureResult(value = ...future.value$value, 
[10:20:06.412]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:06.412]                   ...future.rng), globalenv = if (FALSE) 
[10:20:06.412]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:06.412]                     ...future.globalenv.names))
[10:20:06.412]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:06.412]         }, condition = base::local({
[10:20:06.412]             c <- base::c
[10:20:06.412]             inherits <- base::inherits
[10:20:06.412]             invokeRestart <- base::invokeRestart
[10:20:06.412]             length <- base::length
[10:20:06.412]             list <- base::list
[10:20:06.412]             seq.int <- base::seq.int
[10:20:06.412]             signalCondition <- base::signalCondition
[10:20:06.412]             sys.calls <- base::sys.calls
[10:20:06.412]             `[[` <- base::`[[`
[10:20:06.412]             `+` <- base::`+`
[10:20:06.412]             `<<-` <- base::`<<-`
[10:20:06.412]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:06.412]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:06.412]                   3L)]
[10:20:06.412]             }
[10:20:06.412]             function(cond) {
[10:20:06.412]                 is_error <- inherits(cond, "error")
[10:20:06.412]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:06.412]                   NULL)
[10:20:06.412]                 if (is_error) {
[10:20:06.412]                   sessionInformation <- function() {
[10:20:06.412]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:06.412]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:06.412]                       search = base::search(), system = base::Sys.info())
[10:20:06.412]                   }
[10:20:06.412]                   ...future.conditions[[length(...future.conditions) + 
[10:20:06.412]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:06.412]                     cond$call), session = sessionInformation(), 
[10:20:06.412]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:06.412]                   signalCondition(cond)
[10:20:06.412]                 }
[10:20:06.412]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:06.412]                 "immediateCondition"))) {
[10:20:06.412]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:06.412]                   ...future.conditions[[length(...future.conditions) + 
[10:20:06.412]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:06.412]                   if (TRUE && !signal) {
[10:20:06.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:06.412]                     {
[10:20:06.412]                       inherits <- base::inherits
[10:20:06.412]                       invokeRestart <- base::invokeRestart
[10:20:06.412]                       is.null <- base::is.null
[10:20:06.412]                       muffled <- FALSE
[10:20:06.412]                       if (inherits(cond, "message")) {
[10:20:06.412]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:06.412]                         if (muffled) 
[10:20:06.412]                           invokeRestart("muffleMessage")
[10:20:06.412]                       }
[10:20:06.412]                       else if (inherits(cond, "warning")) {
[10:20:06.412]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:06.412]                         if (muffled) 
[10:20:06.412]                           invokeRestart("muffleWarning")
[10:20:06.412]                       }
[10:20:06.412]                       else if (inherits(cond, "condition")) {
[10:20:06.412]                         if (!is.null(pattern)) {
[10:20:06.412]                           computeRestarts <- base::computeRestarts
[10:20:06.412]                           grepl <- base::grepl
[10:20:06.412]                           restarts <- computeRestarts(cond)
[10:20:06.412]                           for (restart in restarts) {
[10:20:06.412]                             name <- restart$name
[10:20:06.412]                             if (is.null(name)) 
[10:20:06.412]                               next
[10:20:06.412]                             if (!grepl(pattern, name)) 
[10:20:06.412]                               next
[10:20:06.412]                             invokeRestart(restart)
[10:20:06.412]                             muffled <- TRUE
[10:20:06.412]                             break
[10:20:06.412]                           }
[10:20:06.412]                         }
[10:20:06.412]                       }
[10:20:06.412]                       invisible(muffled)
[10:20:06.412]                     }
[10:20:06.412]                     muffleCondition(cond, pattern = "^muffle")
[10:20:06.412]                   }
[10:20:06.412]                 }
[10:20:06.412]                 else {
[10:20:06.412]                   if (TRUE) {
[10:20:06.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:06.412]                     {
[10:20:06.412]                       inherits <- base::inherits
[10:20:06.412]                       invokeRestart <- base::invokeRestart
[10:20:06.412]                       is.null <- base::is.null
[10:20:06.412]                       muffled <- FALSE
[10:20:06.412]                       if (inherits(cond, "message")) {
[10:20:06.412]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:06.412]                         if (muffled) 
[10:20:06.412]                           invokeRestart("muffleMessage")
[10:20:06.412]                       }
[10:20:06.412]                       else if (inherits(cond, "warning")) {
[10:20:06.412]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:06.412]                         if (muffled) 
[10:20:06.412]                           invokeRestart("muffleWarning")
[10:20:06.412]                       }
[10:20:06.412]                       else if (inherits(cond, "condition")) {
[10:20:06.412]                         if (!is.null(pattern)) {
[10:20:06.412]                           computeRestarts <- base::computeRestarts
[10:20:06.412]                           grepl <- base::grepl
[10:20:06.412]                           restarts <- computeRestarts(cond)
[10:20:06.412]                           for (restart in restarts) {
[10:20:06.412]                             name <- restart$name
[10:20:06.412]                             if (is.null(name)) 
[10:20:06.412]                               next
[10:20:06.412]                             if (!grepl(pattern, name)) 
[10:20:06.412]                               next
[10:20:06.412]                             invokeRestart(restart)
[10:20:06.412]                             muffled <- TRUE
[10:20:06.412]                             break
[10:20:06.412]                           }
[10:20:06.412]                         }
[10:20:06.412]                       }
[10:20:06.412]                       invisible(muffled)
[10:20:06.412]                     }
[10:20:06.412]                     muffleCondition(cond, pattern = "^muffle")
[10:20:06.412]                   }
[10:20:06.412]                 }
[10:20:06.412]             }
[10:20:06.412]         }))
[10:20:06.412]     }, error = function(ex) {
[10:20:06.412]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:06.412]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:06.412]                 ...future.rng), started = ...future.startTime, 
[10:20:06.412]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:06.412]             version = "1.8"), class = "FutureResult")
[10:20:06.412]     }, finally = {
[10:20:06.412]         if (!identical(...future.workdir, getwd())) 
[10:20:06.412]             setwd(...future.workdir)
[10:20:06.412]         {
[10:20:06.412]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:06.412]                 ...future.oldOptions$nwarnings <- NULL
[10:20:06.412]             }
[10:20:06.412]             base::options(...future.oldOptions)
[10:20:06.412]             if (.Platform$OS.type == "windows") {
[10:20:06.412]                 old_names <- names(...future.oldEnvVars)
[10:20:06.412]                 envs <- base::Sys.getenv()
[10:20:06.412]                 names <- names(envs)
[10:20:06.412]                 common <- intersect(names, old_names)
[10:20:06.412]                 added <- setdiff(names, old_names)
[10:20:06.412]                 removed <- setdiff(old_names, names)
[10:20:06.412]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:06.412]                   envs[common]]
[10:20:06.412]                 NAMES <- toupper(changed)
[10:20:06.412]                 args <- list()
[10:20:06.412]                 for (kk in seq_along(NAMES)) {
[10:20:06.412]                   name <- changed[[kk]]
[10:20:06.412]                   NAME <- NAMES[[kk]]
[10:20:06.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:06.412]                     next
[10:20:06.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:06.412]                 }
[10:20:06.412]                 NAMES <- toupper(added)
[10:20:06.412]                 for (kk in seq_along(NAMES)) {
[10:20:06.412]                   name <- added[[kk]]
[10:20:06.412]                   NAME <- NAMES[[kk]]
[10:20:06.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:06.412]                     next
[10:20:06.412]                   args[[name]] <- ""
[10:20:06.412]                 }
[10:20:06.412]                 NAMES <- toupper(removed)
[10:20:06.412]                 for (kk in seq_along(NAMES)) {
[10:20:06.412]                   name <- removed[[kk]]
[10:20:06.412]                   NAME <- NAMES[[kk]]
[10:20:06.412]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:06.412]                     next
[10:20:06.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:06.412]                 }
[10:20:06.412]                 if (length(args) > 0) 
[10:20:06.412]                   base::do.call(base::Sys.setenv, args = args)
[10:20:06.412]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:06.412]             }
[10:20:06.412]             else {
[10:20:06.412]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:06.412]             }
[10:20:06.412]             {
[10:20:06.412]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:06.412]                   0L) {
[10:20:06.412]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:06.412]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:06.412]                   base::options(opts)
[10:20:06.412]                 }
[10:20:06.412]                 {
[10:20:06.412]                   {
[10:20:06.412]                     NULL
[10:20:06.412]                     RNGkind("Mersenne-Twister")
[10:20:06.412]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:06.412]                       inherits = FALSE)
[10:20:06.412]                   }
[10:20:06.412]                   options(future.plan = NULL)
[10:20:06.412]                   if (is.na(NA_character_)) 
[10:20:06.412]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:06.412]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:06.412]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:06.412]                     .init = FALSE)
[10:20:06.412]                 }
[10:20:06.412]             }
[10:20:06.412]         }
[10:20:06.412]     })
[10:20:06.412]     if (TRUE) {
[10:20:06.412]         base::sink(type = "output", split = FALSE)
[10:20:06.412]         if (FALSE) {
[10:20:06.412]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:06.412]         }
[10:20:06.412]         else {
[10:20:06.412]             ...future.result["stdout"] <- base::list(NULL)
[10:20:06.412]         }
[10:20:06.412]         base::close(...future.stdout)
[10:20:06.412]         ...future.stdout <- NULL
[10:20:06.412]     }
[10:20:06.412]     ...future.result$conditions <- ...future.conditions
[10:20:06.412]     ...future.result$finished <- base::Sys.time()
[10:20:06.412]     ...future.result
[10:20:06.412] }
[10:20:06.414] assign_globals() ...
[10:20:06.414] List of 5
[10:20:06.414]  $ ...future.FUN            :function (x, y)  
[10:20:06.414]  $ MoreArgs                 : NULL
[10:20:06.414]  $ ...future.elements_ii    :List of 2
[10:20:06.414]   ..$ :List of 2
[10:20:06.414]   .. ..$ : int 1
[10:20:06.414]   .. ..$ : int 0
[10:20:06.414]   ..$ :List of 2
[10:20:06.414]   .. ..$ : int 0
[10:20:06.414]   .. ..$ : int 1
[10:20:06.414]  $ ...future.seeds_ii       : NULL
[10:20:06.414]  $ ...future.globals.maxSize: NULL
[10:20:06.414]  - attr(*, "where")=List of 5
[10:20:06.414]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:06.414]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:20:06.414]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:06.414]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:06.414]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:06.414]  - attr(*, "resolved")= logi FALSE
[10:20:06.414]  - attr(*, "total_size")= num 1242
[10:20:06.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:06.414]  - attr(*, "already-done")= logi TRUE
[10:20:06.419] - reassign environment for ‘...future.FUN’
[10:20:06.419] - copied ‘...future.FUN’ to environment
[10:20:06.419] - copied ‘MoreArgs’ to environment
[10:20:06.420] - copied ‘...future.elements_ii’ to environment
[10:20:06.420] - copied ‘...future.seeds_ii’ to environment
[10:20:06.420] - copied ‘...future.globals.maxSize’ to environment
[10:20:06.420] assign_globals() ... done
[10:20:06.420] plan(): Setting new future strategy stack:
[10:20:06.420] List of future strategies:
[10:20:06.420] 1. sequential:
[10:20:06.420]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:06.420]    - tweaked: FALSE
[10:20:06.420]    - call: NULL
[10:20:06.421] plan(): nbrOfWorkers() = 1
[10:20:06.922] plan(): Setting new future strategy stack:
[10:20:06.923] List of future strategies:
[10:20:06.923] 1. sequential:
[10:20:06.923]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:06.923]    - tweaked: FALSE
[10:20:06.923]    - call: plan(strategy)
[10:20:06.923] plan(): nbrOfWorkers() = 1
[10:20:06.923] SequentialFuture started (and completed)
[10:20:06.924] - Launch lazy future ... done
[10:20:06.924] run() for ‘SequentialFuture’ ... done
[10:20:06.924] Created future:
[10:20:06.924] SequentialFuture:
[10:20:06.924] Label: ‘future_mapply-1’
[10:20:06.924] Expression:
[10:20:06.924] {
[10:20:06.924]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:06.924]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:06.924]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:06.924]         on.exit(options(oopts), add = TRUE)
[10:20:06.924]     }
[10:20:06.924]     {
[10:20:06.924]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:06.924]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:20:06.924]         do.call(mapply, args = args)
[10:20:06.924]     }
[10:20:06.924] }
[10:20:06.924] Lazy evaluation: FALSE
[10:20:06.924] Asynchronous evaluation: FALSE
[10:20:06.924] Local evaluation: TRUE
[10:20:06.924] Environment: R_GlobalEnv
[10:20:06.924] Capture standard output: FALSE
[10:20:06.924] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:06.924] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:06.924] Packages: <none>
[10:20:06.924] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:06.924] Resolved: TRUE
[10:20:06.924] Value: 184 bytes of class ‘list’
[10:20:06.924] Early signaling: FALSE
[10:20:06.924] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:06.924] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:06.925] Chunk #1 of 1 ... DONE
[10:20:06.925] Launching 1 futures (chunks) ... DONE
[10:20:06.925] Resolving 1 futures (chunks) ...
[10:20:06.925] resolve() on list ...
[10:20:06.925]  recursive: 0
[10:20:06.925]  length: 1
[10:20:06.925] 
[10:20:06.925] resolved() for ‘SequentialFuture’ ...
[10:20:06.926] - state: ‘finished’
[10:20:06.926] - run: TRUE
[10:20:06.926] - result: ‘FutureResult’
[10:20:06.926] resolved() for ‘SequentialFuture’ ... done
[10:20:06.926] Future #1
[10:20:06.926] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:20:06.926] - nx: 1
[10:20:06.926] - relay: TRUE
[10:20:06.926] - stdout: TRUE
[10:20:06.926] - signal: TRUE
[10:20:06.926] - resignal: FALSE
[10:20:06.926] - force: TRUE
[10:20:06.927] - relayed: [n=1] FALSE
[10:20:06.927] - queued futures: [n=1] FALSE
[10:20:06.927]  - until=1
[10:20:06.927]  - relaying element #1
[10:20:06.927] - relayed: [n=1] TRUE
[10:20:06.927] - queued futures: [n=1] TRUE
[10:20:06.927] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:20:06.927]  length: 0 (resolved future 1)
[10:20:06.927] Relaying remaining futures
[10:20:06.927] signalConditionsASAP(NULL, pos=0) ...
[10:20:06.927] - nx: 1
[10:20:06.928] - relay: TRUE
[10:20:06.928] - stdout: TRUE
[10:20:06.928] - signal: TRUE
[10:20:06.928] - resignal: FALSE
[10:20:06.928] - force: TRUE
[10:20:06.928] - relayed: [n=1] TRUE
[10:20:06.928] - queued futures: [n=1] TRUE
 - flush all
[10:20:06.928] - relayed: [n=1] TRUE
[10:20:06.928] - queued futures: [n=1] TRUE
[10:20:06.929] signalConditionsASAP(NULL, pos=0) ... done
[10:20:06.929] resolve() on list ... DONE
[10:20:06.929]  - Number of value chunks collected: 1
[10:20:06.929] Resolving 1 futures (chunks) ... DONE
[10:20:06.929] Reducing values from 1 chunks ...
[10:20:06.929]  - Number of values collected after concatenation: 2
[10:20:06.929]  - Number of values expected: 2
[10:20:06.929] Reducing values from 1 chunks ... DONE
[10:20:06.929] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[10:20:06.931] future_mapply() ...
[10:20:06.932] Number of chunks: 1
[10:20:06.932] getGlobalsAndPackagesXApply() ...
[10:20:06.932]  - future.globals: TRUE
[10:20:06.932] getGlobalsAndPackages() ...
[10:20:06.932] Searching for globals...
[10:20:06.933] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:20:06.934] Searching for globals ... DONE
[10:20:06.934] Resolving globals: FALSE
[10:20:06.934] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[10:20:06.934] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[10:20:06.935] - globals: [1] ‘FUN’
[10:20:06.935] 
[10:20:06.935] getGlobalsAndPackages() ... DONE
[10:20:06.935]  - globals found/used: [n=1] ‘FUN’
[10:20:06.935]  - needed namespaces: [n=0] 
[10:20:06.935] Finding globals ... DONE
[10:20:06.935] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:20:06.935] List of 2
[10:20:06.935]  $ ...future.FUN:function (x, y)  
[10:20:06.935]  $ MoreArgs     : NULL
[10:20:06.935]  - attr(*, "where")=List of 2
[10:20:06.935]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:06.935]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:20:06.935]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:06.935]  - attr(*, "resolved")= logi FALSE
[10:20:06.935]  - attr(*, "total_size")= num NA
[10:20:06.938] Packages to be attached in all futures: [n=0] 
[10:20:06.938] getGlobalsAndPackagesXApply() ... DONE
[10:20:06.938] Number of futures (= number of chunks): 1
[10:20:06.938] Launching 1 futures (chunks) ...
[10:20:06.938] Chunk #1 of 1 ...
[10:20:06.938]  - Finding globals in '...' for chunk #1 ...
[10:20:06.938] getGlobalsAndPackages() ...
[10:20:06.938] Searching for globals...
[10:20:06.939] 
[10:20:06.939] Searching for globals ... DONE
[10:20:06.939] - globals: [0] <none>
[10:20:06.939] getGlobalsAndPackages() ... DONE
[10:20:06.939]    + additional globals found: [n=0] 
[10:20:06.939]    + additional namespaces needed: [n=0] 
[10:20:06.939]  - Finding globals in '...' for chunk #1 ... DONE
[10:20:06.939]  - seeds: <none>
[10:20:06.939]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:06.940] getGlobalsAndPackages() ...
[10:20:06.940] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:06.940] Resolving globals: FALSE
[10:20:06.940] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[10:20:06.940] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:20:06.941] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:06.941] 
[10:20:06.941] getGlobalsAndPackages() ... DONE
[10:20:06.941] run() for ‘Future’ ...
[10:20:06.941] - state: ‘created’
[10:20:06.941] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:20:06.942] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:06.942] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:06.942]   - Field: ‘label’
[10:20:06.942]   - Field: ‘local’
[10:20:06.942]   - Field: ‘owner’
[10:20:06.942]   - Field: ‘envir’
[10:20:06.942]   - Field: ‘packages’
[10:20:06.942]   - Field: ‘gc’
[10:20:06.942]   - Field: ‘conditions’
[10:20:06.942]   - Field: ‘expr’
[10:20:06.942]   - Field: ‘uuid’
[10:20:06.943]   - Field: ‘seed’
[10:20:06.943]   - Field: ‘version’
[10:20:06.943]   - Field: ‘result’
[10:20:06.943]   - Field: ‘asynchronous’
[10:20:06.943]   - Field: ‘calls’
[10:20:06.943]   - Field: ‘globals’
[10:20:06.943]   - Field: ‘stdout’
[10:20:06.943]   - Field: ‘earlySignal’
[10:20:06.943]   - Field: ‘lazy’
[10:20:06.943]   - Field: ‘state’
[10:20:06.943] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:06.943] - Launch lazy future ...
[10:20:06.944] Packages needed by the future expression (n = 0): <none>
[10:20:06.944] Packages needed by future strategies (n = 0): <none>
[10:20:06.944] {
[10:20:06.944]     {
[10:20:06.944]         {
[10:20:06.944]             ...future.startTime <- base::Sys.time()
[10:20:06.944]             {
[10:20:06.944]                 {
[10:20:06.944]                   {
[10:20:06.944]                     base::local({
[10:20:06.944]                       has_future <- base::requireNamespace("future", 
[10:20:06.944]                         quietly = TRUE)
[10:20:06.944]                       if (has_future) {
[10:20:06.944]                         ns <- base::getNamespace("future")
[10:20:06.944]                         version <- ns[[".package"]][["version"]]
[10:20:06.944]                         if (is.null(version)) 
[10:20:06.944]                           version <- utils::packageVersion("future")
[10:20:06.944]                       }
[10:20:06.944]                       else {
[10:20:06.944]                         version <- NULL
[10:20:06.944]                       }
[10:20:06.944]                       if (!has_future || version < "1.8.0") {
[10:20:06.944]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:06.944]                           "", base::R.version$version.string), 
[10:20:06.944]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:06.944]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:06.944]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:06.944]                             "release", "version")], collapse = " "), 
[10:20:06.944]                           hostname = base::Sys.info()[["nodename"]])
[10:20:06.944]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:06.944]                           info)
[10:20:06.944]                         info <- base::paste(info, collapse = "; ")
[10:20:06.944]                         if (!has_future) {
[10:20:06.944]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:06.944]                             info)
[10:20:06.944]                         }
[10:20:06.944]                         else {
[10:20:06.944]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:06.944]                             info, version)
[10:20:06.944]                         }
[10:20:06.944]                         base::stop(msg)
[10:20:06.944]                       }
[10:20:06.944]                     })
[10:20:06.944]                   }
[10:20:06.944]                   ...future.strategy.old <- future::plan("list")
[10:20:06.944]                   options(future.plan = NULL)
[10:20:06.944]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:06.944]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:06.944]                 }
[10:20:06.944]                 ...future.workdir <- getwd()
[10:20:06.944]             }
[10:20:06.944]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:06.944]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:06.944]         }
[10:20:06.944]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:06.944]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:06.944]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:06.944]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:06.944]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:06.944]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:06.944]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:06.944]             base::names(...future.oldOptions))
[10:20:06.944]     }
[10:20:06.944]     if (FALSE) {
[10:20:06.944]     }
[10:20:06.944]     else {
[10:20:06.944]         if (TRUE) {
[10:20:06.944]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:06.944]                 open = "w")
[10:20:06.944]         }
[10:20:06.944]         else {
[10:20:06.944]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:06.944]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:06.944]         }
[10:20:06.944]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:06.944]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:06.944]             base::sink(type = "output", split = FALSE)
[10:20:06.944]             base::close(...future.stdout)
[10:20:06.944]         }, add = TRUE)
[10:20:06.944]     }
[10:20:06.944]     ...future.frame <- base::sys.nframe()
[10:20:06.944]     ...future.conditions <- base::list()
[10:20:06.944]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:06.944]     if (FALSE) {
[10:20:06.944]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:06.944]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:06.944]     }
[10:20:06.944]     ...future.result <- base::tryCatch({
[10:20:06.944]         base::withCallingHandlers({
[10:20:06.944]             ...future.value <- base::withVisible(base::local({
[10:20:06.944]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:06.944]                 if (!identical(...future.globals.maxSize.org, 
[10:20:06.944]                   ...future.globals.maxSize)) {
[10:20:06.944]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:06.944]                   on.exit(options(oopts), add = TRUE)
[10:20:06.944]                 }
[10:20:06.944]                 {
[10:20:06.944]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:06.944]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:20:06.944]                     USE.NAMES = FALSE)
[10:20:06.944]                   do.call(mapply, args = args)
[10:20:06.944]                 }
[10:20:06.944]             }))
[10:20:06.944]             future::FutureResult(value = ...future.value$value, 
[10:20:06.944]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:06.944]                   ...future.rng), globalenv = if (FALSE) 
[10:20:06.944]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:06.944]                     ...future.globalenv.names))
[10:20:06.944]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:06.944]         }, condition = base::local({
[10:20:06.944]             c <- base::c
[10:20:06.944]             inherits <- base::inherits
[10:20:06.944]             invokeRestart <- base::invokeRestart
[10:20:06.944]             length <- base::length
[10:20:06.944]             list <- base::list
[10:20:06.944]             seq.int <- base::seq.int
[10:20:06.944]             signalCondition <- base::signalCondition
[10:20:06.944]             sys.calls <- base::sys.calls
[10:20:06.944]             `[[` <- base::`[[`
[10:20:06.944]             `+` <- base::`+`
[10:20:06.944]             `<<-` <- base::`<<-`
[10:20:06.944]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:06.944]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:06.944]                   3L)]
[10:20:06.944]             }
[10:20:06.944]             function(cond) {
[10:20:06.944]                 is_error <- inherits(cond, "error")
[10:20:06.944]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:06.944]                   NULL)
[10:20:06.944]                 if (is_error) {
[10:20:06.944]                   sessionInformation <- function() {
[10:20:06.944]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:06.944]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:06.944]                       search = base::search(), system = base::Sys.info())
[10:20:06.944]                   }
[10:20:06.944]                   ...future.conditions[[length(...future.conditions) + 
[10:20:06.944]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:06.944]                     cond$call), session = sessionInformation(), 
[10:20:06.944]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:06.944]                   signalCondition(cond)
[10:20:06.944]                 }
[10:20:06.944]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:06.944]                 "immediateCondition"))) {
[10:20:06.944]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:06.944]                   ...future.conditions[[length(...future.conditions) + 
[10:20:06.944]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:06.944]                   if (TRUE && !signal) {
[10:20:06.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:06.944]                     {
[10:20:06.944]                       inherits <- base::inherits
[10:20:06.944]                       invokeRestart <- base::invokeRestart
[10:20:06.944]                       is.null <- base::is.null
[10:20:06.944]                       muffled <- FALSE
[10:20:06.944]                       if (inherits(cond, "message")) {
[10:20:06.944]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:06.944]                         if (muffled) 
[10:20:06.944]                           invokeRestart("muffleMessage")
[10:20:06.944]                       }
[10:20:06.944]                       else if (inherits(cond, "warning")) {
[10:20:06.944]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:06.944]                         if (muffled) 
[10:20:06.944]                           invokeRestart("muffleWarning")
[10:20:06.944]                       }
[10:20:06.944]                       else if (inherits(cond, "condition")) {
[10:20:06.944]                         if (!is.null(pattern)) {
[10:20:06.944]                           computeRestarts <- base::computeRestarts
[10:20:06.944]                           grepl <- base::grepl
[10:20:06.944]                           restarts <- computeRestarts(cond)
[10:20:06.944]                           for (restart in restarts) {
[10:20:06.944]                             name <- restart$name
[10:20:06.944]                             if (is.null(name)) 
[10:20:06.944]                               next
[10:20:06.944]                             if (!grepl(pattern, name)) 
[10:20:06.944]                               next
[10:20:06.944]                             invokeRestart(restart)
[10:20:06.944]                             muffled <- TRUE
[10:20:06.944]                             break
[10:20:06.944]                           }
[10:20:06.944]                         }
[10:20:06.944]                       }
[10:20:06.944]                       invisible(muffled)
[10:20:06.944]                     }
[10:20:06.944]                     muffleCondition(cond, pattern = "^muffle")
[10:20:06.944]                   }
[10:20:06.944]                 }
[10:20:06.944]                 else {
[10:20:06.944]                   if (TRUE) {
[10:20:06.944]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:06.944]                     {
[10:20:06.944]                       inherits <- base::inherits
[10:20:06.944]                       invokeRestart <- base::invokeRestart
[10:20:06.944]                       is.null <- base::is.null
[10:20:06.944]                       muffled <- FALSE
[10:20:06.944]                       if (inherits(cond, "message")) {
[10:20:06.944]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:06.944]                         if (muffled) 
[10:20:06.944]                           invokeRestart("muffleMessage")
[10:20:06.944]                       }
[10:20:06.944]                       else if (inherits(cond, "warning")) {
[10:20:06.944]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:06.944]                         if (muffled) 
[10:20:06.944]                           invokeRestart("muffleWarning")
[10:20:06.944]                       }
[10:20:06.944]                       else if (inherits(cond, "condition")) {
[10:20:06.944]                         if (!is.null(pattern)) {
[10:20:06.944]                           computeRestarts <- base::computeRestarts
[10:20:06.944]                           grepl <- base::grepl
[10:20:06.944]                           restarts <- computeRestarts(cond)
[10:20:06.944]                           for (restart in restarts) {
[10:20:06.944]                             name <- restart$name
[10:20:06.944]                             if (is.null(name)) 
[10:20:06.944]                               next
[10:20:06.944]                             if (!grepl(pattern, name)) 
[10:20:06.944]                               next
[10:20:06.944]                             invokeRestart(restart)
[10:20:06.944]                             muffled <- TRUE
[10:20:06.944]                             break
[10:20:06.944]                           }
[10:20:06.944]                         }
[10:20:06.944]                       }
[10:20:06.944]                       invisible(muffled)
[10:20:06.944]                     }
[10:20:06.944]                     muffleCondition(cond, pattern = "^muffle")
[10:20:06.944]                   }
[10:20:06.944]                 }
[10:20:06.944]             }
[10:20:06.944]         }))
[10:20:06.944]     }, error = function(ex) {
[10:20:06.944]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:06.944]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:06.944]                 ...future.rng), started = ...future.startTime, 
[10:20:06.944]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:06.944]             version = "1.8"), class = "FutureResult")
[10:20:06.944]     }, finally = {
[10:20:06.944]         if (!identical(...future.workdir, getwd())) 
[10:20:06.944]             setwd(...future.workdir)
[10:20:06.944]         {
[10:20:06.944]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:06.944]                 ...future.oldOptions$nwarnings <- NULL
[10:20:06.944]             }
[10:20:06.944]             base::options(...future.oldOptions)
[10:20:06.944]             if (.Platform$OS.type == "windows") {
[10:20:06.944]                 old_names <- names(...future.oldEnvVars)
[10:20:06.944]                 envs <- base::Sys.getenv()
[10:20:06.944]                 names <- names(envs)
[10:20:06.944]                 common <- intersect(names, old_names)
[10:20:06.944]                 added <- setdiff(names, old_names)
[10:20:06.944]                 removed <- setdiff(old_names, names)
[10:20:06.944]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:06.944]                   envs[common]]
[10:20:06.944]                 NAMES <- toupper(changed)
[10:20:06.944]                 args <- list()
[10:20:06.944]                 for (kk in seq_along(NAMES)) {
[10:20:06.944]                   name <- changed[[kk]]
[10:20:06.944]                   NAME <- NAMES[[kk]]
[10:20:06.944]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:06.944]                     next
[10:20:06.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:06.944]                 }
[10:20:06.944]                 NAMES <- toupper(added)
[10:20:06.944]                 for (kk in seq_along(NAMES)) {
[10:20:06.944]                   name <- added[[kk]]
[10:20:06.944]                   NAME <- NAMES[[kk]]
[10:20:06.944]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:06.944]                     next
[10:20:06.944]                   args[[name]] <- ""
[10:20:06.944]                 }
[10:20:06.944]                 NAMES <- toupper(removed)
[10:20:06.944]                 for (kk in seq_along(NAMES)) {
[10:20:06.944]                   name <- removed[[kk]]
[10:20:06.944]                   NAME <- NAMES[[kk]]
[10:20:06.944]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:06.944]                     next
[10:20:06.944]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:06.944]                 }
[10:20:06.944]                 if (length(args) > 0) 
[10:20:06.944]                   base::do.call(base::Sys.setenv, args = args)
[10:20:06.944]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:06.944]             }
[10:20:06.944]             else {
[10:20:06.944]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:06.944]             }
[10:20:06.944]             {
[10:20:06.944]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:06.944]                   0L) {
[10:20:06.944]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:06.944]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:06.944]                   base::options(opts)
[10:20:06.944]                 }
[10:20:06.944]                 {
[10:20:06.944]                   {
[10:20:06.944]                     NULL
[10:20:06.944]                     RNGkind("Mersenne-Twister")
[10:20:06.944]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:06.944]                       inherits = FALSE)
[10:20:06.944]                   }
[10:20:06.944]                   options(future.plan = NULL)
[10:20:06.944]                   if (is.na(NA_character_)) 
[10:20:06.944]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:06.944]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:06.944]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:06.944]                     .init = FALSE)
[10:20:06.944]                 }
[10:20:06.944]             }
[10:20:06.944]         }
[10:20:06.944]     })
[10:20:06.944]     if (TRUE) {
[10:20:06.944]         base::sink(type = "output", split = FALSE)
[10:20:06.944]         if (TRUE) {
[10:20:06.944]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:06.944]         }
[10:20:06.944]         else {
[10:20:06.944]             ...future.result["stdout"] <- base::list(NULL)
[10:20:06.944]         }
[10:20:06.944]         base::close(...future.stdout)
[10:20:06.944]         ...future.stdout <- NULL
[10:20:06.944]     }
[10:20:06.944]     ...future.result$conditions <- ...future.conditions
[10:20:06.944]     ...future.result$finished <- base::Sys.time()
[10:20:06.944]     ...future.result
[10:20:06.944] }
[10:20:06.946] assign_globals() ...
[10:20:06.946] List of 5
[10:20:06.946]  $ ...future.FUN            :function (x, y)  
[10:20:06.946]  $ MoreArgs                 : NULL
[10:20:06.946]  $ ...future.elements_ii    :List of 2
[10:20:06.946]   ..$ :List of 2
[10:20:06.946]   .. ..$ : int 1
[10:20:06.946]   .. ..$ : int 0
[10:20:06.946]   ..$ :List of 2
[10:20:06.946]   .. ..$ : int 0
[10:20:06.946]   .. ..$ : int 1
[10:20:06.946]  $ ...future.seeds_ii       : NULL
[10:20:06.946]  $ ...future.globals.maxSize: NULL
[10:20:06.946]  - attr(*, "where")=List of 5
[10:20:06.946]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:06.946]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:20:06.946]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:06.946]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:06.946]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:06.946]  - attr(*, "resolved")= logi FALSE
[10:20:06.946]  - attr(*, "total_size")= num 1242
[10:20:06.946]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:06.946]  - attr(*, "already-done")= logi TRUE
[10:20:06.951] - reassign environment for ‘...future.FUN’
[10:20:06.951] - copied ‘...future.FUN’ to environment
[10:20:06.951] - copied ‘MoreArgs’ to environment
[10:20:06.952] - copied ‘...future.elements_ii’ to environment
[10:20:06.952] - copied ‘...future.seeds_ii’ to environment
[10:20:06.952] - copied ‘...future.globals.maxSize’ to environment
[10:20:06.952] assign_globals() ... done
[10:20:06.952] plan(): Setting new future strategy stack:
[10:20:06.952] List of future strategies:
[10:20:06.952] 1. sequential:
[10:20:06.952]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:06.952]    - tweaked: FALSE
[10:20:06.952]    - call: NULL
[10:20:06.953] plan(): nbrOfWorkers() = 1
[10:20:07.454] plan(): Setting new future strategy stack:
[10:20:07.454] List of future strategies:
[10:20:07.454] 1. sequential:
[10:20:07.454]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:07.454]    - tweaked: FALSE
[10:20:07.454]    - call: plan(strategy)
[10:20:07.455] plan(): nbrOfWorkers() = 1
[10:20:07.455] SequentialFuture started (and completed)
[10:20:07.455] - Launch lazy future ... done
[10:20:07.455] run() for ‘SequentialFuture’ ... done
[10:20:07.456] Created future:
[10:20:07.457] SequentialFuture:
[10:20:07.457] Label: ‘future_mapply-1’
[10:20:07.457] Expression:
[10:20:07.457] {
[10:20:07.457]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:07.457]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:07.457]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:07.457]         on.exit(options(oopts), add = TRUE)
[10:20:07.457]     }
[10:20:07.457]     {
[10:20:07.457]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:07.457]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:20:07.457]         do.call(mapply, args = args)
[10:20:07.457]     }
[10:20:07.457] }
[10:20:07.457] Lazy evaluation: FALSE
[10:20:07.457] Asynchronous evaluation: FALSE
[10:20:07.457] Local evaluation: TRUE
[10:20:07.457] Environment: R_GlobalEnv
[10:20:07.457] Capture standard output: TRUE
[10:20:07.457] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:07.457] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:07.457] Packages: <none>
[10:20:07.457] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:07.457] Resolved: TRUE
[10:20:07.457] Value: 184 bytes of class ‘list’
[10:20:07.457] Early signaling: FALSE
[10:20:07.457] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:07.457] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:07.458] Chunk #1 of 1 ... DONE
[10:20:07.458] Launching 1 futures (chunks) ... DONE
[10:20:07.458] Resolving 1 futures (chunks) ...
[10:20:07.459] resolve() on list ...
[10:20:07.459]  recursive: 0
[10:20:07.459]  length: 1
[10:20:07.459] 
[10:20:07.459] resolved() for ‘SequentialFuture’ ...
[10:20:07.459] - state: ‘finished’
[10:20:07.459] - run: TRUE
[10:20:07.459] - result: ‘FutureResult’
[10:20:07.459] resolved() for ‘SequentialFuture’ ... done
[10:20:07.459] Future #1
[10:20:07.460] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:20:07.460] - nx: 1
[10:20:07.460] - relay: TRUE
[10:20:07.460] - stdout: TRUE
[10:20:07.460] - signal: TRUE
[10:20:07.460] - resignal: FALSE
[10:20:07.460] - force: TRUE
[10:20:07.460] - relayed: [n=1] FALSE
[10:20:07.460] - queued futures: [n=1] FALSE
[10:20:07.460]  - until=1
[10:20:07.460]  - relaying element #1
[10:20:07.460] - relayed: [n=1] TRUE
[10:20:07.461] - queued futures: [n=1] TRUE
[10:20:07.461] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:20:07.461]  length: 0 (resolved future 1)
[10:20:07.461] Relaying remaining futures
[10:20:07.461] signalConditionsASAP(NULL, pos=0) ...
[10:20:07.461] - nx: 1
[10:20:07.461] - relay: TRUE
[10:20:07.461] - stdout: TRUE
[10:20:07.461] - signal: TRUE
[10:20:07.461] - resignal: FALSE
[10:20:07.461] - force: TRUE
[10:20:07.461] - relayed: [n=1] TRUE
[10:20:07.462] - queued futures: [n=1] TRUE
 - flush all
[10:20:07.462] - relayed: [n=1] TRUE
[10:20:07.462] - queued futures: [n=1] TRUE
[10:20:07.462] signalConditionsASAP(NULL, pos=0) ... done
[10:20:07.462] resolve() on list ... DONE
[10:20:07.462]  - Number of value chunks collected: 1
[10:20:07.462] Resolving 1 futures (chunks) ... DONE
[10:20:07.462] Reducing values from 1 chunks ...
[10:20:07.462]  - Number of values collected after concatenation: 2
[10:20:07.462]  - Number of values expected: 2
[10:20:07.462] Reducing values from 1 chunks ... DONE
[10:20:07.463] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[10:20:07.463] future_mapply() ...
[10:20:07.463] Number of chunks: 1
[10:20:07.463] getGlobalsAndPackagesXApply() ...
[10:20:07.463]  - future.globals: TRUE
[10:20:07.463] getGlobalsAndPackages() ...
[10:20:07.463] Searching for globals...
[10:20:07.465] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:20:07.465] Searching for globals ... DONE
[10:20:07.465] Resolving globals: FALSE
[10:20:07.466] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[10:20:07.466] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[10:20:07.466] - globals: [1] ‘FUN’
[10:20:07.466] 
[10:20:07.466] getGlobalsAndPackages() ... DONE
[10:20:07.466]  - globals found/used: [n=1] ‘FUN’
[10:20:07.466]  - needed namespaces: [n=0] 
[10:20:07.466] Finding globals ... DONE
[10:20:07.467] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:20:07.467] List of 2
[10:20:07.467]  $ ...future.FUN:function (x, y)  
[10:20:07.467]  $ MoreArgs     : NULL
[10:20:07.467]  - attr(*, "where")=List of 2
[10:20:07.467]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:07.467]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:20:07.467]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:07.467]  - attr(*, "resolved")= logi FALSE
[10:20:07.467]  - attr(*, "total_size")= num NA
[10:20:07.469] Packages to be attached in all futures: [n=0] 
[10:20:07.469] getGlobalsAndPackagesXApply() ... DONE
[10:20:07.469] Number of futures (= number of chunks): 1
[10:20:07.470] Launching 1 futures (chunks) ...
[10:20:07.470] Chunk #1 of 1 ...
[10:20:07.470]  - Finding globals in '...' for chunk #1 ...
[10:20:07.470] getGlobalsAndPackages() ...
[10:20:07.470] Searching for globals...
[10:20:07.470] 
[10:20:07.470] Searching for globals ... DONE
[10:20:07.470] - globals: [0] <none>
[10:20:07.470] getGlobalsAndPackages() ... DONE
[10:20:07.471]    + additional globals found: [n=0] 
[10:20:07.471]    + additional namespaces needed: [n=0] 
[10:20:07.471]  - Finding globals in '...' for chunk #1 ... DONE
[10:20:07.471]  - seeds: <none>
[10:20:07.471]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:07.471] getGlobalsAndPackages() ...
[10:20:07.471] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:07.471] Resolving globals: FALSE
[10:20:07.472] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[10:20:07.472] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:20:07.472] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:07.472] 
[10:20:07.472] getGlobalsAndPackages() ... DONE
[10:20:07.473] run() for ‘Future’ ...
[10:20:07.473] - state: ‘created’
[10:20:07.473] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:20:07.473] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:07.473] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:07.473]   - Field: ‘label’
[10:20:07.473]   - Field: ‘local’
[10:20:07.473]   - Field: ‘owner’
[10:20:07.474]   - Field: ‘envir’
[10:20:07.474]   - Field: ‘packages’
[10:20:07.474]   - Field: ‘gc’
[10:20:07.474]   - Field: ‘conditions’
[10:20:07.474]   - Field: ‘expr’
[10:20:07.474]   - Field: ‘uuid’
[10:20:07.474]   - Field: ‘seed’
[10:20:07.474]   - Field: ‘version’
[10:20:07.474]   - Field: ‘result’
[10:20:07.474]   - Field: ‘asynchronous’
[10:20:07.474]   - Field: ‘calls’
[10:20:07.475]   - Field: ‘globals’
[10:20:07.475]   - Field: ‘stdout’
[10:20:07.475]   - Field: ‘earlySignal’
[10:20:07.475]   - Field: ‘lazy’
[10:20:07.475]   - Field: ‘state’
[10:20:07.475] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:07.475] - Launch lazy future ...
[10:20:07.475] Packages needed by the future expression (n = 0): <none>
[10:20:07.475] Packages needed by future strategies (n = 0): <none>
[10:20:07.476] {
[10:20:07.476]     {
[10:20:07.476]         {
[10:20:07.476]             ...future.startTime <- base::Sys.time()
[10:20:07.476]             {
[10:20:07.476]                 {
[10:20:07.476]                   {
[10:20:07.476]                     base::local({
[10:20:07.476]                       has_future <- base::requireNamespace("future", 
[10:20:07.476]                         quietly = TRUE)
[10:20:07.476]                       if (has_future) {
[10:20:07.476]                         ns <- base::getNamespace("future")
[10:20:07.476]                         version <- ns[[".package"]][["version"]]
[10:20:07.476]                         if (is.null(version)) 
[10:20:07.476]                           version <- utils::packageVersion("future")
[10:20:07.476]                       }
[10:20:07.476]                       else {
[10:20:07.476]                         version <- NULL
[10:20:07.476]                       }
[10:20:07.476]                       if (!has_future || version < "1.8.0") {
[10:20:07.476]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:07.476]                           "", base::R.version$version.string), 
[10:20:07.476]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:07.476]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:07.476]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:07.476]                             "release", "version")], collapse = " "), 
[10:20:07.476]                           hostname = base::Sys.info()[["nodename"]])
[10:20:07.476]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:07.476]                           info)
[10:20:07.476]                         info <- base::paste(info, collapse = "; ")
[10:20:07.476]                         if (!has_future) {
[10:20:07.476]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:07.476]                             info)
[10:20:07.476]                         }
[10:20:07.476]                         else {
[10:20:07.476]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:07.476]                             info, version)
[10:20:07.476]                         }
[10:20:07.476]                         base::stop(msg)
[10:20:07.476]                       }
[10:20:07.476]                     })
[10:20:07.476]                   }
[10:20:07.476]                   ...future.strategy.old <- future::plan("list")
[10:20:07.476]                   options(future.plan = NULL)
[10:20:07.476]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:07.476]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:07.476]                 }
[10:20:07.476]                 ...future.workdir <- getwd()
[10:20:07.476]             }
[10:20:07.476]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:07.476]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:07.476]         }
[10:20:07.476]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:07.476]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:07.476]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:07.476]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:07.476]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:07.476]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:07.476]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:07.476]             base::names(...future.oldOptions))
[10:20:07.476]     }
[10:20:07.476]     if (TRUE) {
[10:20:07.476]     }
[10:20:07.476]     else {
[10:20:07.476]         if (NA) {
[10:20:07.476]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:07.476]                 open = "w")
[10:20:07.476]         }
[10:20:07.476]         else {
[10:20:07.476]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:07.476]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:07.476]         }
[10:20:07.476]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:07.476]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:07.476]             base::sink(type = "output", split = FALSE)
[10:20:07.476]             base::close(...future.stdout)
[10:20:07.476]         }, add = TRUE)
[10:20:07.476]     }
[10:20:07.476]     ...future.frame <- base::sys.nframe()
[10:20:07.476]     ...future.conditions <- base::list()
[10:20:07.476]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:07.476]     if (FALSE) {
[10:20:07.476]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:07.476]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:07.476]     }
[10:20:07.476]     ...future.result <- base::tryCatch({
[10:20:07.476]         base::withCallingHandlers({
[10:20:07.476]             ...future.value <- base::withVisible(base::local({
[10:20:07.476]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:07.476]                 if (!identical(...future.globals.maxSize.org, 
[10:20:07.476]                   ...future.globals.maxSize)) {
[10:20:07.476]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:07.476]                   on.exit(options(oopts), add = TRUE)
[10:20:07.476]                 }
[10:20:07.476]                 {
[10:20:07.476]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:07.476]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:20:07.476]                     USE.NAMES = FALSE)
[10:20:07.476]                   do.call(mapply, args = args)
[10:20:07.476]                 }
[10:20:07.476]             }))
[10:20:07.476]             future::FutureResult(value = ...future.value$value, 
[10:20:07.476]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:07.476]                   ...future.rng), globalenv = if (FALSE) 
[10:20:07.476]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:07.476]                     ...future.globalenv.names))
[10:20:07.476]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:07.476]         }, condition = base::local({
[10:20:07.476]             c <- base::c
[10:20:07.476]             inherits <- base::inherits
[10:20:07.476]             invokeRestart <- base::invokeRestart
[10:20:07.476]             length <- base::length
[10:20:07.476]             list <- base::list
[10:20:07.476]             seq.int <- base::seq.int
[10:20:07.476]             signalCondition <- base::signalCondition
[10:20:07.476]             sys.calls <- base::sys.calls
[10:20:07.476]             `[[` <- base::`[[`
[10:20:07.476]             `+` <- base::`+`
[10:20:07.476]             `<<-` <- base::`<<-`
[10:20:07.476]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:07.476]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:07.476]                   3L)]
[10:20:07.476]             }
[10:20:07.476]             function(cond) {
[10:20:07.476]                 is_error <- inherits(cond, "error")
[10:20:07.476]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:07.476]                   NULL)
[10:20:07.476]                 if (is_error) {
[10:20:07.476]                   sessionInformation <- function() {
[10:20:07.476]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:07.476]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:07.476]                       search = base::search(), system = base::Sys.info())
[10:20:07.476]                   }
[10:20:07.476]                   ...future.conditions[[length(...future.conditions) + 
[10:20:07.476]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:07.476]                     cond$call), session = sessionInformation(), 
[10:20:07.476]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:07.476]                   signalCondition(cond)
[10:20:07.476]                 }
[10:20:07.476]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:07.476]                 "immediateCondition"))) {
[10:20:07.476]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:07.476]                   ...future.conditions[[length(...future.conditions) + 
[10:20:07.476]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:07.476]                   if (TRUE && !signal) {
[10:20:07.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:07.476]                     {
[10:20:07.476]                       inherits <- base::inherits
[10:20:07.476]                       invokeRestart <- base::invokeRestart
[10:20:07.476]                       is.null <- base::is.null
[10:20:07.476]                       muffled <- FALSE
[10:20:07.476]                       if (inherits(cond, "message")) {
[10:20:07.476]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:07.476]                         if (muffled) 
[10:20:07.476]                           invokeRestart("muffleMessage")
[10:20:07.476]                       }
[10:20:07.476]                       else if (inherits(cond, "warning")) {
[10:20:07.476]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:07.476]                         if (muffled) 
[10:20:07.476]                           invokeRestart("muffleWarning")
[10:20:07.476]                       }
[10:20:07.476]                       else if (inherits(cond, "condition")) {
[10:20:07.476]                         if (!is.null(pattern)) {
[10:20:07.476]                           computeRestarts <- base::computeRestarts
[10:20:07.476]                           grepl <- base::grepl
[10:20:07.476]                           restarts <- computeRestarts(cond)
[10:20:07.476]                           for (restart in restarts) {
[10:20:07.476]                             name <- restart$name
[10:20:07.476]                             if (is.null(name)) 
[10:20:07.476]                               next
[10:20:07.476]                             if (!grepl(pattern, name)) 
[10:20:07.476]                               next
[10:20:07.476]                             invokeRestart(restart)
[10:20:07.476]                             muffled <- TRUE
[10:20:07.476]                             break
[10:20:07.476]                           }
[10:20:07.476]                         }
[10:20:07.476]                       }
[10:20:07.476]                       invisible(muffled)
[10:20:07.476]                     }
[10:20:07.476]                     muffleCondition(cond, pattern = "^muffle")
[10:20:07.476]                   }
[10:20:07.476]                 }
[10:20:07.476]                 else {
[10:20:07.476]                   if (TRUE) {
[10:20:07.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:07.476]                     {
[10:20:07.476]                       inherits <- base::inherits
[10:20:07.476]                       invokeRestart <- base::invokeRestart
[10:20:07.476]                       is.null <- base::is.null
[10:20:07.476]                       muffled <- FALSE
[10:20:07.476]                       if (inherits(cond, "message")) {
[10:20:07.476]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:07.476]                         if (muffled) 
[10:20:07.476]                           invokeRestart("muffleMessage")
[10:20:07.476]                       }
[10:20:07.476]                       else if (inherits(cond, "warning")) {
[10:20:07.476]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:07.476]                         if (muffled) 
[10:20:07.476]                           invokeRestart("muffleWarning")
[10:20:07.476]                       }
[10:20:07.476]                       else if (inherits(cond, "condition")) {
[10:20:07.476]                         if (!is.null(pattern)) {
[10:20:07.476]                           computeRestarts <- base::computeRestarts
[10:20:07.476]                           grepl <- base::grepl
[10:20:07.476]                           restarts <- computeRestarts(cond)
[10:20:07.476]                           for (restart in restarts) {
[10:20:07.476]                             name <- restart$name
[10:20:07.476]                             if (is.null(name)) 
[10:20:07.476]                               next
[10:20:07.476]                             if (!grepl(pattern, name)) 
[10:20:07.476]                               next
[10:20:07.476]                             invokeRestart(restart)
[10:20:07.476]                             muffled <- TRUE
[10:20:07.476]                             break
[10:20:07.476]                           }
[10:20:07.476]                         }
[10:20:07.476]                       }
[10:20:07.476]                       invisible(muffled)
[10:20:07.476]                     }
[10:20:07.476]                     muffleCondition(cond, pattern = "^muffle")
[10:20:07.476]                   }
[10:20:07.476]                 }
[10:20:07.476]             }
[10:20:07.476]         }))
[10:20:07.476]     }, error = function(ex) {
[10:20:07.476]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:07.476]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:07.476]                 ...future.rng), started = ...future.startTime, 
[10:20:07.476]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:07.476]             version = "1.8"), class = "FutureResult")
[10:20:07.476]     }, finally = {
[10:20:07.476]         if (!identical(...future.workdir, getwd())) 
[10:20:07.476]             setwd(...future.workdir)
[10:20:07.476]         {
[10:20:07.476]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:07.476]                 ...future.oldOptions$nwarnings <- NULL
[10:20:07.476]             }
[10:20:07.476]             base::options(...future.oldOptions)
[10:20:07.476]             if (.Platform$OS.type == "windows") {
[10:20:07.476]                 old_names <- names(...future.oldEnvVars)
[10:20:07.476]                 envs <- base::Sys.getenv()
[10:20:07.476]                 names <- names(envs)
[10:20:07.476]                 common <- intersect(names, old_names)
[10:20:07.476]                 added <- setdiff(names, old_names)
[10:20:07.476]                 removed <- setdiff(old_names, names)
[10:20:07.476]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:07.476]                   envs[common]]
[10:20:07.476]                 NAMES <- toupper(changed)
[10:20:07.476]                 args <- list()
[10:20:07.476]                 for (kk in seq_along(NAMES)) {
[10:20:07.476]                   name <- changed[[kk]]
[10:20:07.476]                   NAME <- NAMES[[kk]]
[10:20:07.476]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:07.476]                     next
[10:20:07.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:07.476]                 }
[10:20:07.476]                 NAMES <- toupper(added)
[10:20:07.476]                 for (kk in seq_along(NAMES)) {
[10:20:07.476]                   name <- added[[kk]]
[10:20:07.476]                   NAME <- NAMES[[kk]]
[10:20:07.476]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:07.476]                     next
[10:20:07.476]                   args[[name]] <- ""
[10:20:07.476]                 }
[10:20:07.476]                 NAMES <- toupper(removed)
[10:20:07.476]                 for (kk in seq_along(NAMES)) {
[10:20:07.476]                   name <- removed[[kk]]
[10:20:07.476]                   NAME <- NAMES[[kk]]
[10:20:07.476]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:07.476]                     next
[10:20:07.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:07.476]                 }
[10:20:07.476]                 if (length(args) > 0) 
[10:20:07.476]                   base::do.call(base::Sys.setenv, args = args)
[10:20:07.476]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:07.476]             }
[10:20:07.476]             else {
[10:20:07.476]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:07.476]             }
[10:20:07.476]             {
[10:20:07.476]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:07.476]                   0L) {
[10:20:07.476]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:07.476]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:07.476]                   base::options(opts)
[10:20:07.476]                 }
[10:20:07.476]                 {
[10:20:07.476]                   {
[10:20:07.476]                     NULL
[10:20:07.476]                     RNGkind("Mersenne-Twister")
[10:20:07.476]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:07.476]                       inherits = FALSE)
[10:20:07.476]                   }
[10:20:07.476]                   options(future.plan = NULL)
[10:20:07.476]                   if (is.na(NA_character_)) 
[10:20:07.476]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:07.476]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:07.476]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:07.476]                     .init = FALSE)
[10:20:07.476]                 }
[10:20:07.476]             }
[10:20:07.476]         }
[10:20:07.476]     })
[10:20:07.476]     if (FALSE) {
[10:20:07.476]         base::sink(type = "output", split = FALSE)
[10:20:07.476]         if (NA) {
[10:20:07.476]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:07.476]         }
[10:20:07.476]         else {
[10:20:07.476]             ...future.result["stdout"] <- base::list(NULL)
[10:20:07.476]         }
[10:20:07.476]         base::close(...future.stdout)
[10:20:07.476]         ...future.stdout <- NULL
[10:20:07.476]     }
[10:20:07.476]     ...future.result$conditions <- ...future.conditions
[10:20:07.476]     ...future.result$finished <- base::Sys.time()
[10:20:07.476]     ...future.result
[10:20:07.476] }
[10:20:07.477] assign_globals() ...
[10:20:07.478] List of 5
[10:20:07.478]  $ ...future.FUN            :function (x, y)  
[10:20:07.478]  $ MoreArgs                 : NULL
[10:20:07.478]  $ ...future.elements_ii    :List of 2
[10:20:07.478]   ..$ :List of 2
[10:20:07.478]   .. ..$ : int 1
[10:20:07.478]   .. ..$ : int 0
[10:20:07.478]   ..$ :List of 2
[10:20:07.478]   .. ..$ : int 0
[10:20:07.478]   .. ..$ : int 1
[10:20:07.478]  $ ...future.seeds_ii       : NULL
[10:20:07.478]  $ ...future.globals.maxSize: NULL
[10:20:07.478]  - attr(*, "where")=List of 5
[10:20:07.478]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:07.478]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:20:07.478]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:07.478]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:07.478]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:07.478]  - attr(*, "resolved")= logi FALSE
[10:20:07.478]  - attr(*, "total_size")= num 1242
[10:20:07.478]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:07.478]  - attr(*, "already-done")= logi TRUE
[10:20:07.484] - reassign environment for ‘...future.FUN’
[10:20:07.484] - copied ‘...future.FUN’ to environment
[10:20:07.484] - copied ‘MoreArgs’ to environment
[10:20:07.484] - copied ‘...future.elements_ii’ to environment
[10:20:07.484] - copied ‘...future.seeds_ii’ to environment
[10:20:07.485] - copied ‘...future.globals.maxSize’ to environment
[10:20:07.485] assign_globals() ... done
[10:20:07.485] plan(): Setting new future strategy stack:
[10:20:07.485] List of future strategies:
[10:20:07.485] 1. sequential:
[10:20:07.485]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:07.485]    - tweaked: FALSE
[10:20:07.485]    - call: NULL
[10:20:07.485] plan(): nbrOfWorkers() = 1
[10:20:07.987] plan(): Setting new future strategy stack:
[10:20:07.987] List of future strategies:
[10:20:07.987] 1. sequential:
[10:20:07.987]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:07.987]    - tweaked: FALSE
[10:20:07.987]    - call: plan(strategy)
[10:20:07.988] plan(): nbrOfWorkers() = 1
[10:20:07.988] SequentialFuture started (and completed)
[10:20:07.988] - Launch lazy future ... done
[10:20:07.988] run() for ‘SequentialFuture’ ... done
[10:20:07.988] Created future:
[10:20:07.988] SequentialFuture:
[10:20:07.988] Label: ‘future_mapply-1’
[10:20:07.988] Expression:
[10:20:07.988] {
[10:20:07.988]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:07.988]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:07.988]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:07.988]         on.exit(options(oopts), add = TRUE)
[10:20:07.988]     }
[10:20:07.988]     {
[10:20:07.988]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:07.988]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:20:07.988]         do.call(mapply, args = args)
[10:20:07.988]     }
[10:20:07.988] }
[10:20:07.988] Lazy evaluation: FALSE
[10:20:07.988] Asynchronous evaluation: FALSE
[10:20:07.988] Local evaluation: TRUE
[10:20:07.988] Environment: R_GlobalEnv
[10:20:07.988] Capture standard output: NA
[10:20:07.988] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:07.988] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:07.988] Packages: <none>
[10:20:07.988] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:07.988] Resolved: TRUE
[10:20:07.988] Value: 184 bytes of class ‘list’
[10:20:07.988] Early signaling: FALSE
[10:20:07.988] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:07.988] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:07.989] Chunk #1 of 1 ... DONE
[10:20:07.989] Launching 1 futures (chunks) ... DONE
[10:20:07.989] Resolving 1 futures (chunks) ...
[10:20:07.990] resolve() on list ...
[10:20:07.990]  recursive: 0
[10:20:07.990]  length: 1
[10:20:07.990] 
[10:20:07.990] resolved() for ‘SequentialFuture’ ...
[10:20:07.990] - state: ‘finished’
[10:20:07.990] - run: TRUE
[10:20:07.990] - result: ‘FutureResult’
[10:20:07.990] resolved() for ‘SequentialFuture’ ... done
[10:20:07.990] Future #1
[10:20:07.991] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:20:07.991] - nx: 1
[10:20:07.991] - relay: TRUE
[10:20:07.991] - stdout: TRUE
[10:20:07.991] - signal: TRUE
[10:20:07.991] - resignal: FALSE
[10:20:07.991] - force: TRUE
[10:20:07.991] - relayed: [n=1] FALSE
[10:20:07.991] - queued futures: [n=1] FALSE
[10:20:07.991]  - until=1
[10:20:07.991]  - relaying element #1
[10:20:07.992] - relayed: [n=1] TRUE
[10:20:07.992] - queued futures: [n=1] TRUE
[10:20:07.992] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:20:07.992]  length: 0 (resolved future 1)
[10:20:07.992] Relaying remaining futures
[10:20:07.992] signalConditionsASAP(NULL, pos=0) ...
[10:20:07.992] - nx: 1
[10:20:07.992] - relay: TRUE
[10:20:07.992] - stdout: TRUE
[10:20:07.992] - signal: TRUE
[10:20:07.992] - resignal: FALSE
[10:20:07.992] - force: TRUE
[10:20:07.992] - relayed: [n=1] TRUE
[10:20:07.993] - queued futures: [n=1] TRUE
 - flush all
[10:20:07.993] - relayed: [n=1] TRUE
[10:20:07.993] - queued futures: [n=1] TRUE
[10:20:07.993] signalConditionsASAP(NULL, pos=0) ... done
[10:20:07.993] resolve() on list ... DONE
[10:20:07.993]  - Number of value chunks collected: 1
[10:20:07.993] Resolving 1 futures (chunks) ... DONE
[10:20:07.993] Reducing values from 1 chunks ...
[10:20:07.993]  - Number of values collected after concatenation: 2
[10:20:07.993]  - Number of values expected: 2
[10:20:07.993] Reducing values from 1 chunks ... DONE
[10:20:07.994] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('sequential') ... DONE
* plan('multicore') ...
[10:20:07.994] plan(): Setting new future strategy stack:
[10:20:07.994] List of future strategies:
[10:20:07.994] 1. multicore:
[10:20:07.994]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:20:07.994]    - tweaked: FALSE
[10:20:07.994]    - call: plan(strategy)
[10:20:07.996] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[10:20:07.996] future_lapply() ...
[10:20:07.998] Number of chunks: 1
[10:20:07.998] getGlobalsAndPackagesXApply() ...
[10:20:07.998]  - future.globals: TRUE
[10:20:07.998] getGlobalsAndPackages() ...
[10:20:07.999] Searching for globals...
[10:20:08.000] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:20:08.000] Searching for globals ... DONE
[10:20:08.000] Resolving globals: FALSE
[10:20:08.000] The total size of the 1 globals is 841 bytes (841 bytes)
[10:20:08.001] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[10:20:08.001] - globals: [1] ‘FUN’
[10:20:08.001] 
[10:20:08.001] getGlobalsAndPackages() ... DONE
[10:20:08.001]  - globals found/used: [n=1] ‘FUN’
[10:20:08.001]  - needed namespaces: [n=0] 
[10:20:08.001] Finding globals ... DONE
[10:20:08.001]  - use_args: TRUE
[10:20:08.002]  - Getting '...' globals ...
[10:20:08.002] resolve() on list ...
[10:20:08.002]  recursive: 0
[10:20:08.002]  length: 1
[10:20:08.002]  elements: ‘...’
[10:20:08.002]  length: 0 (resolved future 1)
[10:20:08.002] resolve() on list ... DONE
[10:20:08.002]    - '...' content: [n=0] 
[10:20:08.002] List of 1
[10:20:08.002]  $ ...: list()
[10:20:08.002]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:08.002]  - attr(*, "where")=List of 1
[10:20:08.002]   ..$ ...:<environment: 0x557fc19987d8> 
[10:20:08.002]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:08.002]  - attr(*, "resolved")= logi TRUE
[10:20:08.002]  - attr(*, "total_size")= num NA
[10:20:08.005]  - Getting '...' globals ... DONE
[10:20:08.005] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:20:08.005] List of 2
[10:20:08.005]  $ ...future.FUN:function (x)  
[10:20:08.005]  $ ...          : list()
[10:20:08.005]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:08.005]  - attr(*, "where")=List of 2
[10:20:08.005]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:08.005]   ..$ ...          :<environment: 0x557fc19987d8> 
[10:20:08.005]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:08.005]  - attr(*, "resolved")= logi FALSE
[10:20:08.005]  - attr(*, "total_size")= num 5632
[10:20:08.010] Packages to be attached in all futures: [n=0] 
[10:20:08.010] getGlobalsAndPackagesXApply() ... DONE
[10:20:08.010] Number of futures (= number of chunks): 1
[10:20:08.010] Launching 1 futures (chunks) ...
[10:20:08.010] Chunk #1 of 1 ...
[10:20:08.010]  - Finding globals in 'X' for chunk #1 ...
[10:20:08.010] getGlobalsAndPackages() ...
[10:20:08.011] Searching for globals...
[10:20:08.011] 
[10:20:08.011] Searching for globals ... DONE
[10:20:08.011] - globals: [0] <none>
[10:20:08.011] getGlobalsAndPackages() ... DONE
[10:20:08.011]    + additional globals found: [n=0] 
[10:20:08.011]    + additional namespaces needed: [n=0] 
[10:20:08.011]  - Finding globals in 'X' for chunk #1 ... DONE
[10:20:08.011]  - seeds: <none>
[10:20:08.011]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:08.012] getGlobalsAndPackages() ...
[10:20:08.012] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:08.012] Resolving globals: FALSE
[10:20:08.012] Tweak future expression to call with '...' arguments ...
[10:20:08.012] {
[10:20:08.012]     do.call(function(...) {
[10:20:08.012]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:08.012]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:08.012]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:08.012]             on.exit(options(oopts), add = TRUE)
[10:20:08.012]         }
[10:20:08.012]         {
[10:20:08.012]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:08.012]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:08.012]                 ...future.FUN(...future.X_jj, ...)
[10:20:08.012]             })
[10:20:08.012]         }
[10:20:08.012]     }, args = future.call.arguments)
[10:20:08.012] }
[10:20:08.012] Tweak future expression to call with '...' arguments ... DONE
[10:20:08.013] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:08.013] 
[10:20:08.013] getGlobalsAndPackages() ... DONE
[10:20:08.013] run() for ‘Future’ ...
[10:20:08.013] - state: ‘created’
[10:20:08.013] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:20:08.015] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:08.015] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:08.015]   - Field: ‘label’
[10:20:08.015]   - Field: ‘local’
[10:20:08.015]   - Field: ‘owner’
[10:20:08.015]   - Field: ‘envir’
[10:20:08.015]   - Field: ‘packages’
[10:20:08.016]   - Field: ‘gc’
[10:20:08.016]   - Field: ‘conditions’
[10:20:08.016]   - Field: ‘expr’
[10:20:08.016]   - Field: ‘uuid’
[10:20:08.016]   - Field: ‘seed’
[10:20:08.016]   - Field: ‘version’
[10:20:08.016]   - Field: ‘result’
[10:20:08.016]   - Field: ‘asynchronous’
[10:20:08.016]   - Field: ‘calls’
[10:20:08.016]   - Field: ‘globals’
[10:20:08.016]   - Field: ‘stdout’
[10:20:08.016]   - Field: ‘earlySignal’
[10:20:08.017]   - Field: ‘lazy’
[10:20:08.017]   - Field: ‘state’
[10:20:08.017] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:08.017] - Launch lazy future ...
[10:20:08.017] Packages needed by the future expression (n = 0): <none>
[10:20:08.017] Packages needed by future strategies (n = 0): <none>
[10:20:08.018] {
[10:20:08.018]     {
[10:20:08.018]         {
[10:20:08.018]             ...future.startTime <- base::Sys.time()
[10:20:08.018]             {
[10:20:08.018]                 {
[10:20:08.018]                   {
[10:20:08.018]                     base::local({
[10:20:08.018]                       has_future <- base::requireNamespace("future", 
[10:20:08.018]                         quietly = TRUE)
[10:20:08.018]                       if (has_future) {
[10:20:08.018]                         ns <- base::getNamespace("future")
[10:20:08.018]                         version <- ns[[".package"]][["version"]]
[10:20:08.018]                         if (is.null(version)) 
[10:20:08.018]                           version <- utils::packageVersion("future")
[10:20:08.018]                       }
[10:20:08.018]                       else {
[10:20:08.018]                         version <- NULL
[10:20:08.018]                       }
[10:20:08.018]                       if (!has_future || version < "1.8.0") {
[10:20:08.018]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:08.018]                           "", base::R.version$version.string), 
[10:20:08.018]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:08.018]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:08.018]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:08.018]                             "release", "version")], collapse = " "), 
[10:20:08.018]                           hostname = base::Sys.info()[["nodename"]])
[10:20:08.018]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:08.018]                           info)
[10:20:08.018]                         info <- base::paste(info, collapse = "; ")
[10:20:08.018]                         if (!has_future) {
[10:20:08.018]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:08.018]                             info)
[10:20:08.018]                         }
[10:20:08.018]                         else {
[10:20:08.018]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:08.018]                             info, version)
[10:20:08.018]                         }
[10:20:08.018]                         base::stop(msg)
[10:20:08.018]                       }
[10:20:08.018]                     })
[10:20:08.018]                   }
[10:20:08.018]                   ...future.strategy.old <- future::plan("list")
[10:20:08.018]                   options(future.plan = NULL)
[10:20:08.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:08.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:08.018]                 }
[10:20:08.018]                 ...future.workdir <- getwd()
[10:20:08.018]             }
[10:20:08.018]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:08.018]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:08.018]         }
[10:20:08.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:08.018]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:08.018]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:08.018]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:08.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:08.018]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:08.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:08.018]             base::names(...future.oldOptions))
[10:20:08.018]     }
[10:20:08.018]     if (FALSE) {
[10:20:08.018]     }
[10:20:08.018]     else {
[10:20:08.018]         if (FALSE) {
[10:20:08.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:08.018]                 open = "w")
[10:20:08.018]         }
[10:20:08.018]         else {
[10:20:08.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:08.018]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:08.018]         }
[10:20:08.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:08.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:08.018]             base::sink(type = "output", split = FALSE)
[10:20:08.018]             base::close(...future.stdout)
[10:20:08.018]         }, add = TRUE)
[10:20:08.018]     }
[10:20:08.018]     ...future.frame <- base::sys.nframe()
[10:20:08.018]     ...future.conditions <- base::list()
[10:20:08.018]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:08.018]     if (FALSE) {
[10:20:08.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:08.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:08.018]     }
[10:20:08.018]     ...future.result <- base::tryCatch({
[10:20:08.018]         base::withCallingHandlers({
[10:20:08.018]             ...future.value <- base::withVisible(base::local({
[10:20:08.018]                 do.call(function(...) {
[10:20:08.018]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:08.018]                   if (!identical(...future.globals.maxSize.org, 
[10:20:08.018]                     ...future.globals.maxSize)) {
[10:20:08.018]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:08.018]                     on.exit(options(oopts), add = TRUE)
[10:20:08.018]                   }
[10:20:08.018]                   {
[10:20:08.018]                     lapply(seq_along(...future.elements_ii), 
[10:20:08.018]                       FUN = function(jj) {
[10:20:08.018]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:08.018]                         ...future.FUN(...future.X_jj, ...)
[10:20:08.018]                       })
[10:20:08.018]                   }
[10:20:08.018]                 }, args = future.call.arguments)
[10:20:08.018]             }))
[10:20:08.018]             future::FutureResult(value = ...future.value$value, 
[10:20:08.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:08.018]                   ...future.rng), globalenv = if (FALSE) 
[10:20:08.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:08.018]                     ...future.globalenv.names))
[10:20:08.018]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:08.018]         }, condition = base::local({
[10:20:08.018]             c <- base::c
[10:20:08.018]             inherits <- base::inherits
[10:20:08.018]             invokeRestart <- base::invokeRestart
[10:20:08.018]             length <- base::length
[10:20:08.018]             list <- base::list
[10:20:08.018]             seq.int <- base::seq.int
[10:20:08.018]             signalCondition <- base::signalCondition
[10:20:08.018]             sys.calls <- base::sys.calls
[10:20:08.018]             `[[` <- base::`[[`
[10:20:08.018]             `+` <- base::`+`
[10:20:08.018]             `<<-` <- base::`<<-`
[10:20:08.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:08.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:08.018]                   3L)]
[10:20:08.018]             }
[10:20:08.018]             function(cond) {
[10:20:08.018]                 is_error <- inherits(cond, "error")
[10:20:08.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:08.018]                   NULL)
[10:20:08.018]                 if (is_error) {
[10:20:08.018]                   sessionInformation <- function() {
[10:20:08.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:08.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:08.018]                       search = base::search(), system = base::Sys.info())
[10:20:08.018]                   }
[10:20:08.018]                   ...future.conditions[[length(...future.conditions) + 
[10:20:08.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:08.018]                     cond$call), session = sessionInformation(), 
[10:20:08.018]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:08.018]                   signalCondition(cond)
[10:20:08.018]                 }
[10:20:08.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:08.018]                 "immediateCondition"))) {
[10:20:08.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:08.018]                   ...future.conditions[[length(...future.conditions) + 
[10:20:08.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:08.018]                   if (TRUE && !signal) {
[10:20:08.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:08.018]                     {
[10:20:08.018]                       inherits <- base::inherits
[10:20:08.018]                       invokeRestart <- base::invokeRestart
[10:20:08.018]                       is.null <- base::is.null
[10:20:08.018]                       muffled <- FALSE
[10:20:08.018]                       if (inherits(cond, "message")) {
[10:20:08.018]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:08.018]                         if (muffled) 
[10:20:08.018]                           invokeRestart("muffleMessage")
[10:20:08.018]                       }
[10:20:08.018]                       else if (inherits(cond, "warning")) {
[10:20:08.018]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:08.018]                         if (muffled) 
[10:20:08.018]                           invokeRestart("muffleWarning")
[10:20:08.018]                       }
[10:20:08.018]                       else if (inherits(cond, "condition")) {
[10:20:08.018]                         if (!is.null(pattern)) {
[10:20:08.018]                           computeRestarts <- base::computeRestarts
[10:20:08.018]                           grepl <- base::grepl
[10:20:08.018]                           restarts <- computeRestarts(cond)
[10:20:08.018]                           for (restart in restarts) {
[10:20:08.018]                             name <- restart$name
[10:20:08.018]                             if (is.null(name)) 
[10:20:08.018]                               next
[10:20:08.018]                             if (!grepl(pattern, name)) 
[10:20:08.018]                               next
[10:20:08.018]                             invokeRestart(restart)
[10:20:08.018]                             muffled <- TRUE
[10:20:08.018]                             break
[10:20:08.018]                           }
[10:20:08.018]                         }
[10:20:08.018]                       }
[10:20:08.018]                       invisible(muffled)
[10:20:08.018]                     }
[10:20:08.018]                     muffleCondition(cond, pattern = "^muffle")
[10:20:08.018]                   }
[10:20:08.018]                 }
[10:20:08.018]                 else {
[10:20:08.018]                   if (TRUE) {
[10:20:08.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:08.018]                     {
[10:20:08.018]                       inherits <- base::inherits
[10:20:08.018]                       invokeRestart <- base::invokeRestart
[10:20:08.018]                       is.null <- base::is.null
[10:20:08.018]                       muffled <- FALSE
[10:20:08.018]                       if (inherits(cond, "message")) {
[10:20:08.018]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:08.018]                         if (muffled) 
[10:20:08.018]                           invokeRestart("muffleMessage")
[10:20:08.018]                       }
[10:20:08.018]                       else if (inherits(cond, "warning")) {
[10:20:08.018]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:08.018]                         if (muffled) 
[10:20:08.018]                           invokeRestart("muffleWarning")
[10:20:08.018]                       }
[10:20:08.018]                       else if (inherits(cond, "condition")) {
[10:20:08.018]                         if (!is.null(pattern)) {
[10:20:08.018]                           computeRestarts <- base::computeRestarts
[10:20:08.018]                           grepl <- base::grepl
[10:20:08.018]                           restarts <- computeRestarts(cond)
[10:20:08.018]                           for (restart in restarts) {
[10:20:08.018]                             name <- restart$name
[10:20:08.018]                             if (is.null(name)) 
[10:20:08.018]                               next
[10:20:08.018]                             if (!grepl(pattern, name)) 
[10:20:08.018]                               next
[10:20:08.018]                             invokeRestart(restart)
[10:20:08.018]                             muffled <- TRUE
[10:20:08.018]                             break
[10:20:08.018]                           }
[10:20:08.018]                         }
[10:20:08.018]                       }
[10:20:08.018]                       invisible(muffled)
[10:20:08.018]                     }
[10:20:08.018]                     muffleCondition(cond, pattern = "^muffle")
[10:20:08.018]                   }
[10:20:08.018]                 }
[10:20:08.018]             }
[10:20:08.018]         }))
[10:20:08.018]     }, error = function(ex) {
[10:20:08.018]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:08.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:08.018]                 ...future.rng), started = ...future.startTime, 
[10:20:08.018]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:08.018]             version = "1.8"), class = "FutureResult")
[10:20:08.018]     }, finally = {
[10:20:08.018]         if (!identical(...future.workdir, getwd())) 
[10:20:08.018]             setwd(...future.workdir)
[10:20:08.018]         {
[10:20:08.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:08.018]                 ...future.oldOptions$nwarnings <- NULL
[10:20:08.018]             }
[10:20:08.018]             base::options(...future.oldOptions)
[10:20:08.018]             if (.Platform$OS.type == "windows") {
[10:20:08.018]                 old_names <- names(...future.oldEnvVars)
[10:20:08.018]                 envs <- base::Sys.getenv()
[10:20:08.018]                 names <- names(envs)
[10:20:08.018]                 common <- intersect(names, old_names)
[10:20:08.018]                 added <- setdiff(names, old_names)
[10:20:08.018]                 removed <- setdiff(old_names, names)
[10:20:08.018]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:08.018]                   envs[common]]
[10:20:08.018]                 NAMES <- toupper(changed)
[10:20:08.018]                 args <- list()
[10:20:08.018]                 for (kk in seq_along(NAMES)) {
[10:20:08.018]                   name <- changed[[kk]]
[10:20:08.018]                   NAME <- NAMES[[kk]]
[10:20:08.018]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:08.018]                     next
[10:20:08.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:08.018]                 }
[10:20:08.018]                 NAMES <- toupper(added)
[10:20:08.018]                 for (kk in seq_along(NAMES)) {
[10:20:08.018]                   name <- added[[kk]]
[10:20:08.018]                   NAME <- NAMES[[kk]]
[10:20:08.018]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:08.018]                     next
[10:20:08.018]                   args[[name]] <- ""
[10:20:08.018]                 }
[10:20:08.018]                 NAMES <- toupper(removed)
[10:20:08.018]                 for (kk in seq_along(NAMES)) {
[10:20:08.018]                   name <- removed[[kk]]
[10:20:08.018]                   NAME <- NAMES[[kk]]
[10:20:08.018]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:08.018]                     next
[10:20:08.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:08.018]                 }
[10:20:08.018]                 if (length(args) > 0) 
[10:20:08.018]                   base::do.call(base::Sys.setenv, args = args)
[10:20:08.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:08.018]             }
[10:20:08.018]             else {
[10:20:08.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:08.018]             }
[10:20:08.018]             {
[10:20:08.018]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:08.018]                   0L) {
[10:20:08.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:08.018]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:08.018]                   base::options(opts)
[10:20:08.018]                 }
[10:20:08.018]                 {
[10:20:08.018]                   {
[10:20:08.018]                     NULL
[10:20:08.018]                     RNGkind("Mersenne-Twister")
[10:20:08.018]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:08.018]                       inherits = FALSE)
[10:20:08.018]                   }
[10:20:08.018]                   options(future.plan = NULL)
[10:20:08.018]                   if (is.na(NA_character_)) 
[10:20:08.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:08.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:08.018]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:08.018]                     .init = FALSE)
[10:20:08.018]                 }
[10:20:08.018]             }
[10:20:08.018]         }
[10:20:08.018]     })
[10:20:08.018]     if (TRUE) {
[10:20:08.018]         base::sink(type = "output", split = FALSE)
[10:20:08.018]         if (FALSE) {
[10:20:08.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:08.018]         }
[10:20:08.018]         else {
[10:20:08.018]             ...future.result["stdout"] <- base::list(NULL)
[10:20:08.018]         }
[10:20:08.018]         base::close(...future.stdout)
[10:20:08.018]         ...future.stdout <- NULL
[10:20:08.018]     }
[10:20:08.018]     ...future.result$conditions <- ...future.conditions
[10:20:08.018]     ...future.result$finished <- base::Sys.time()
[10:20:08.018]     ...future.result
[10:20:08.018] }
[10:20:08.019] assign_globals() ...
[10:20:08.019] List of 5
[10:20:08.019]  $ ...future.FUN            :function (x)  
[10:20:08.019]  $ future.call.arguments    : list()
[10:20:08.019]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:08.019]  $ ...future.elements_ii    :List of 2
[10:20:08.019]   ..$ : int 1
[10:20:08.019]   ..$ : int 0
[10:20:08.019]  $ ...future.seeds_ii       : NULL
[10:20:08.019]  $ ...future.globals.maxSize: NULL
[10:20:08.019]  - attr(*, "where")=List of 5
[10:20:08.019]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:08.019]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:20:08.019]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:08.019]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:08.019]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:08.019]  - attr(*, "resolved")= logi FALSE
[10:20:08.019]  - attr(*, "total_size")= num 5632
[10:20:08.019]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:08.019]  - attr(*, "already-done")= logi TRUE
[10:20:08.024] - reassign environment for ‘...future.FUN’
[10:20:08.024] - copied ‘...future.FUN’ to environment
[10:20:08.024] - copied ‘future.call.arguments’ to environment
[10:20:08.024] - copied ‘...future.elements_ii’ to environment
[10:20:08.025] - copied ‘...future.seeds_ii’ to environment
[10:20:08.025] - copied ‘...future.globals.maxSize’ to environment
[10:20:08.025] assign_globals() ... done
[10:20:08.025] plan(): Setting new future strategy stack:
[10:20:08.025] List of future strategies:
[10:20:08.025] 1. sequential:
[10:20:08.025]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:08.025]    - tweaked: FALSE
[10:20:08.025]    - call: NULL
[10:20:08.026] plan(): nbrOfWorkers() = 1
[10:20:08.527] plan(): Setting new future strategy stack:
[10:20:08.527] List of future strategies:
[10:20:08.527] 1. multicore:
[10:20:08.527]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:20:08.527]    - tweaked: FALSE
[10:20:08.527]    - call: plan(strategy)
[10:20:08.529] plan(): nbrOfWorkers() = 1
[10:20:08.530] SequentialFuture started (and completed)
[10:20:08.530] - Launch lazy future ... done
[10:20:08.530] run() for ‘SequentialFuture’ ... done
[10:20:08.530] Created future:
[10:20:08.530] SequentialFuture:
[10:20:08.530] Label: ‘future_lapply-1’
[10:20:08.530] Expression:
[10:20:08.530] {
[10:20:08.530]     do.call(function(...) {
[10:20:08.530]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:08.530]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:08.530]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:08.530]             on.exit(options(oopts), add = TRUE)
[10:20:08.530]         }
[10:20:08.530]         {
[10:20:08.530]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:08.530]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:08.530]                 ...future.FUN(...future.X_jj, ...)
[10:20:08.530]             })
[10:20:08.530]         }
[10:20:08.530]     }, args = future.call.arguments)
[10:20:08.530] }
[10:20:08.530] Lazy evaluation: FALSE
[10:20:08.530] Asynchronous evaluation: FALSE
[10:20:08.530] Local evaluation: TRUE
[10:20:08.530] Environment: R_GlobalEnv
[10:20:08.530] Capture standard output: FALSE
[10:20:08.530] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:08.530] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:08.530] Packages: <none>
[10:20:08.530] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:08.530] Resolved: TRUE
[10:20:08.530] Value: 55 bytes of class ‘list’
[10:20:08.530] Early signaling: FALSE
[10:20:08.530] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:08.530] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:08.531] Chunk #1 of 1 ... DONE
[10:20:08.531] Launching 1 futures (chunks) ... DONE
[10:20:08.531] Resolving 1 futures (chunks) ...
[10:20:08.531] resolve() on list ...
[10:20:08.531]  recursive: 0
[10:20:08.531]  length: 1
[10:20:08.532] 
[10:20:08.532] resolved() for ‘SequentialFuture’ ...
[10:20:08.532] - state: ‘finished’
[10:20:08.532] - run: TRUE
[10:20:08.532] - result: ‘FutureResult’
[10:20:08.532] resolved() for ‘SequentialFuture’ ... done
[10:20:08.532] Future #1
[10:20:08.532] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:20:08.532] - nx: 1
[10:20:08.532] - relay: TRUE
[10:20:08.532] - stdout: TRUE
[10:20:08.533] - signal: TRUE
[10:20:08.533] - resignal: FALSE
[10:20:08.533] - force: TRUE
[10:20:08.533] - relayed: [n=1] FALSE
[10:20:08.533] - queued futures: [n=1] FALSE
[10:20:08.533]  - until=1
[10:20:08.533]  - relaying element #1
[10:20:08.533] - relayed: [n=1] TRUE
[10:20:08.533] - queued futures: [n=1] TRUE
[10:20:08.533] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:20:08.533]  length: 0 (resolved future 1)
[10:20:08.534] Relaying remaining futures
[10:20:08.534] signalConditionsASAP(NULL, pos=0) ...
[10:20:08.534] - nx: 1
[10:20:08.534] - relay: TRUE
[10:20:08.534] - stdout: TRUE
[10:20:08.534] - signal: TRUE
[10:20:08.534] - resignal: FALSE
[10:20:08.534] - force: TRUE
[10:20:08.534] - relayed: [n=1] TRUE
[10:20:08.536] - queued futures: [n=1] TRUE
 - flush all
[10:20:08.536] - relayed: [n=1] TRUE
[10:20:08.536] - queued futures: [n=1] TRUE
[10:20:08.536] signalConditionsASAP(NULL, pos=0) ... done
[10:20:08.536] resolve() on list ... DONE
[10:20:08.537]  - Number of value chunks collected: 1
[10:20:08.537] Resolving 1 futures (chunks) ... DONE
[10:20:08.537] Reducing values from 1 chunks ...
[10:20:08.537]  - Number of values collected after concatenation: 2
[10:20:08.537]  - Number of values expected: 2
[10:20:08.537] Reducing values from 1 chunks ... DONE
[10:20:08.537] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[10:20:08.537] future_lapply() ...
[10:20:08.539] Number of chunks: 1
[10:20:08.539] getGlobalsAndPackagesXApply() ...
[10:20:08.540]  - future.globals: TRUE
[10:20:08.540] getGlobalsAndPackages() ...
[10:20:08.540] Searching for globals...
[10:20:08.541] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:20:08.541] Searching for globals ... DONE
[10:20:08.541] Resolving globals: FALSE
[10:20:08.542] The total size of the 1 globals is 841 bytes (841 bytes)
[10:20:08.542] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[10:20:08.542] - globals: [1] ‘FUN’
[10:20:08.542] 
[10:20:08.542] getGlobalsAndPackages() ... DONE
[10:20:08.542]  - globals found/used: [n=1] ‘FUN’
[10:20:08.542]  - needed namespaces: [n=0] 
[10:20:08.543] Finding globals ... DONE
[10:20:08.543]  - use_args: TRUE
[10:20:08.543]  - Getting '...' globals ...
[10:20:08.543] resolve() on list ...
[10:20:08.543]  recursive: 0
[10:20:08.543]  length: 1
[10:20:08.543]  elements: ‘...’
[10:20:08.543]  length: 0 (resolved future 1)
[10:20:08.543] resolve() on list ... DONE
[10:20:08.544]    - '...' content: [n=0] 
[10:20:08.544] List of 1
[10:20:08.544]  $ ...: list()
[10:20:08.544]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:08.544]  - attr(*, "where")=List of 1
[10:20:08.544]   ..$ ...:<environment: 0x557fc129ab28> 
[10:20:08.544]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:08.544]  - attr(*, "resolved")= logi TRUE
[10:20:08.544]  - attr(*, "total_size")= num NA
[10:20:08.546]  - Getting '...' globals ... DONE
[10:20:08.546] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:20:08.546] List of 2
[10:20:08.546]  $ ...future.FUN:function (x)  
[10:20:08.546]  $ ...          : list()
[10:20:08.546]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:08.546]  - attr(*, "where")=List of 2
[10:20:08.546]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:08.546]   ..$ ...          :<environment: 0x557fc129ab28> 
[10:20:08.546]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:08.546]  - attr(*, "resolved")= logi FALSE
[10:20:08.546]  - attr(*, "total_size")= num 5632
[10:20:08.549] Packages to be attached in all futures: [n=0] 
[10:20:08.549] getGlobalsAndPackagesXApply() ... DONE
[10:20:08.549] Number of futures (= number of chunks): 1
[10:20:08.549] Launching 1 futures (chunks) ...
[10:20:08.549] Chunk #1 of 1 ...
[10:20:08.549]  - Finding globals in 'X' for chunk #1 ...
[10:20:08.549] getGlobalsAndPackages() ...
[10:20:08.550] Searching for globals...
[10:20:08.550] 
[10:20:08.550] Searching for globals ... DONE
[10:20:08.550] - globals: [0] <none>
[10:20:08.550] getGlobalsAndPackages() ... DONE
[10:20:08.550]    + additional globals found: [n=0] 
[10:20:08.550]    + additional namespaces needed: [n=0] 
[10:20:08.550]  - Finding globals in 'X' for chunk #1 ... DONE
[10:20:08.550]  - seeds: <none>
[10:20:08.550]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:08.551] getGlobalsAndPackages() ...
[10:20:08.551] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:08.551] Resolving globals: FALSE
[10:20:08.551] Tweak future expression to call with '...' arguments ...
[10:20:08.551] {
[10:20:08.551]     do.call(function(...) {
[10:20:08.551]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:08.551]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:08.551]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:08.551]             on.exit(options(oopts), add = TRUE)
[10:20:08.551]         }
[10:20:08.551]         {
[10:20:08.551]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:08.551]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:08.551]                 ...future.FUN(...future.X_jj, ...)
[10:20:08.551]             })
[10:20:08.551]         }
[10:20:08.551]     }, args = future.call.arguments)
[10:20:08.551] }
[10:20:08.551] Tweak future expression to call with '...' arguments ... DONE
[10:20:08.552] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:08.552] 
[10:20:08.552] getGlobalsAndPackages() ... DONE
[10:20:08.552] run() for ‘Future’ ...
[10:20:08.552] - state: ‘created’
[10:20:08.552] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:20:08.554] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:08.554] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:08.554]   - Field: ‘label’
[10:20:08.554]   - Field: ‘local’
[10:20:08.554]   - Field: ‘owner’
[10:20:08.554]   - Field: ‘envir’
[10:20:08.554]   - Field: ‘packages’
[10:20:08.554]   - Field: ‘gc’
[10:20:08.555]   - Field: ‘conditions’
[10:20:08.555]   - Field: ‘expr’
[10:20:08.555]   - Field: ‘uuid’
[10:20:08.555]   - Field: ‘seed’
[10:20:08.555]   - Field: ‘version’
[10:20:08.555]   - Field: ‘result’
[10:20:08.555]   - Field: ‘asynchronous’
[10:20:08.555]   - Field: ‘calls’
[10:20:08.555]   - Field: ‘globals’
[10:20:08.555]   - Field: ‘stdout’
[10:20:08.555]   - Field: ‘earlySignal’
[10:20:08.555]   - Field: ‘lazy’
[10:20:08.556]   - Field: ‘state’
[10:20:08.556] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:08.556] - Launch lazy future ...
[10:20:08.556] Packages needed by the future expression (n = 0): <none>
[10:20:08.556] Packages needed by future strategies (n = 0): <none>
[10:20:08.556] {
[10:20:08.556]     {
[10:20:08.556]         {
[10:20:08.556]             ...future.startTime <- base::Sys.time()
[10:20:08.556]             {
[10:20:08.556]                 {
[10:20:08.556]                   {
[10:20:08.556]                     base::local({
[10:20:08.556]                       has_future <- base::requireNamespace("future", 
[10:20:08.556]                         quietly = TRUE)
[10:20:08.556]                       if (has_future) {
[10:20:08.556]                         ns <- base::getNamespace("future")
[10:20:08.556]                         version <- ns[[".package"]][["version"]]
[10:20:08.556]                         if (is.null(version)) 
[10:20:08.556]                           version <- utils::packageVersion("future")
[10:20:08.556]                       }
[10:20:08.556]                       else {
[10:20:08.556]                         version <- NULL
[10:20:08.556]                       }
[10:20:08.556]                       if (!has_future || version < "1.8.0") {
[10:20:08.556]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:08.556]                           "", base::R.version$version.string), 
[10:20:08.556]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:08.556]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:08.556]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:08.556]                             "release", "version")], collapse = " "), 
[10:20:08.556]                           hostname = base::Sys.info()[["nodename"]])
[10:20:08.556]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:08.556]                           info)
[10:20:08.556]                         info <- base::paste(info, collapse = "; ")
[10:20:08.556]                         if (!has_future) {
[10:20:08.556]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:08.556]                             info)
[10:20:08.556]                         }
[10:20:08.556]                         else {
[10:20:08.556]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:08.556]                             info, version)
[10:20:08.556]                         }
[10:20:08.556]                         base::stop(msg)
[10:20:08.556]                       }
[10:20:08.556]                     })
[10:20:08.556]                   }
[10:20:08.556]                   ...future.strategy.old <- future::plan("list")
[10:20:08.556]                   options(future.plan = NULL)
[10:20:08.556]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:08.556]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:08.556]                 }
[10:20:08.556]                 ...future.workdir <- getwd()
[10:20:08.556]             }
[10:20:08.556]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:08.556]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:08.556]         }
[10:20:08.556]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:08.556]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:08.556]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:08.556]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:08.556]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:08.556]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:08.556]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:08.556]             base::names(...future.oldOptions))
[10:20:08.556]     }
[10:20:08.556]     if (FALSE) {
[10:20:08.556]     }
[10:20:08.556]     else {
[10:20:08.556]         if (TRUE) {
[10:20:08.556]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:08.556]                 open = "w")
[10:20:08.556]         }
[10:20:08.556]         else {
[10:20:08.556]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:08.556]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:08.556]         }
[10:20:08.556]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:08.556]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:08.556]             base::sink(type = "output", split = FALSE)
[10:20:08.556]             base::close(...future.stdout)
[10:20:08.556]         }, add = TRUE)
[10:20:08.556]     }
[10:20:08.556]     ...future.frame <- base::sys.nframe()
[10:20:08.556]     ...future.conditions <- base::list()
[10:20:08.556]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:08.556]     if (FALSE) {
[10:20:08.556]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:08.556]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:08.556]     }
[10:20:08.556]     ...future.result <- base::tryCatch({
[10:20:08.556]         base::withCallingHandlers({
[10:20:08.556]             ...future.value <- base::withVisible(base::local({
[10:20:08.556]                 do.call(function(...) {
[10:20:08.556]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:08.556]                   if (!identical(...future.globals.maxSize.org, 
[10:20:08.556]                     ...future.globals.maxSize)) {
[10:20:08.556]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:08.556]                     on.exit(options(oopts), add = TRUE)
[10:20:08.556]                   }
[10:20:08.556]                   {
[10:20:08.556]                     lapply(seq_along(...future.elements_ii), 
[10:20:08.556]                       FUN = function(jj) {
[10:20:08.556]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:08.556]                         ...future.FUN(...future.X_jj, ...)
[10:20:08.556]                       })
[10:20:08.556]                   }
[10:20:08.556]                 }, args = future.call.arguments)
[10:20:08.556]             }))
[10:20:08.556]             future::FutureResult(value = ...future.value$value, 
[10:20:08.556]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:08.556]                   ...future.rng), globalenv = if (FALSE) 
[10:20:08.556]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:08.556]                     ...future.globalenv.names))
[10:20:08.556]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:08.556]         }, condition = base::local({
[10:20:08.556]             c <- base::c
[10:20:08.556]             inherits <- base::inherits
[10:20:08.556]             invokeRestart <- base::invokeRestart
[10:20:08.556]             length <- base::length
[10:20:08.556]             list <- base::list
[10:20:08.556]             seq.int <- base::seq.int
[10:20:08.556]             signalCondition <- base::signalCondition
[10:20:08.556]             sys.calls <- base::sys.calls
[10:20:08.556]             `[[` <- base::`[[`
[10:20:08.556]             `+` <- base::`+`
[10:20:08.556]             `<<-` <- base::`<<-`
[10:20:08.556]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:08.556]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:08.556]                   3L)]
[10:20:08.556]             }
[10:20:08.556]             function(cond) {
[10:20:08.556]                 is_error <- inherits(cond, "error")
[10:20:08.556]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:08.556]                   NULL)
[10:20:08.556]                 if (is_error) {
[10:20:08.556]                   sessionInformation <- function() {
[10:20:08.556]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:08.556]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:08.556]                       search = base::search(), system = base::Sys.info())
[10:20:08.556]                   }
[10:20:08.556]                   ...future.conditions[[length(...future.conditions) + 
[10:20:08.556]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:08.556]                     cond$call), session = sessionInformation(), 
[10:20:08.556]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:08.556]                   signalCondition(cond)
[10:20:08.556]                 }
[10:20:08.556]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:08.556]                 "immediateCondition"))) {
[10:20:08.556]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:08.556]                   ...future.conditions[[length(...future.conditions) + 
[10:20:08.556]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:08.556]                   if (TRUE && !signal) {
[10:20:08.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:08.556]                     {
[10:20:08.556]                       inherits <- base::inherits
[10:20:08.556]                       invokeRestart <- base::invokeRestart
[10:20:08.556]                       is.null <- base::is.null
[10:20:08.556]                       muffled <- FALSE
[10:20:08.556]                       if (inherits(cond, "message")) {
[10:20:08.556]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:08.556]                         if (muffled) 
[10:20:08.556]                           invokeRestart("muffleMessage")
[10:20:08.556]                       }
[10:20:08.556]                       else if (inherits(cond, "warning")) {
[10:20:08.556]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:08.556]                         if (muffled) 
[10:20:08.556]                           invokeRestart("muffleWarning")
[10:20:08.556]                       }
[10:20:08.556]                       else if (inherits(cond, "condition")) {
[10:20:08.556]                         if (!is.null(pattern)) {
[10:20:08.556]                           computeRestarts <- base::computeRestarts
[10:20:08.556]                           grepl <- base::grepl
[10:20:08.556]                           restarts <- computeRestarts(cond)
[10:20:08.556]                           for (restart in restarts) {
[10:20:08.556]                             name <- restart$name
[10:20:08.556]                             if (is.null(name)) 
[10:20:08.556]                               next
[10:20:08.556]                             if (!grepl(pattern, name)) 
[10:20:08.556]                               next
[10:20:08.556]                             invokeRestart(restart)
[10:20:08.556]                             muffled <- TRUE
[10:20:08.556]                             break
[10:20:08.556]                           }
[10:20:08.556]                         }
[10:20:08.556]                       }
[10:20:08.556]                       invisible(muffled)
[10:20:08.556]                     }
[10:20:08.556]                     muffleCondition(cond, pattern = "^muffle")
[10:20:08.556]                   }
[10:20:08.556]                 }
[10:20:08.556]                 else {
[10:20:08.556]                   if (TRUE) {
[10:20:08.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:08.556]                     {
[10:20:08.556]                       inherits <- base::inherits
[10:20:08.556]                       invokeRestart <- base::invokeRestart
[10:20:08.556]                       is.null <- base::is.null
[10:20:08.556]                       muffled <- FALSE
[10:20:08.556]                       if (inherits(cond, "message")) {
[10:20:08.556]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:08.556]                         if (muffled) 
[10:20:08.556]                           invokeRestart("muffleMessage")
[10:20:08.556]                       }
[10:20:08.556]                       else if (inherits(cond, "warning")) {
[10:20:08.556]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:08.556]                         if (muffled) 
[10:20:08.556]                           invokeRestart("muffleWarning")
[10:20:08.556]                       }
[10:20:08.556]                       else if (inherits(cond, "condition")) {
[10:20:08.556]                         if (!is.null(pattern)) {
[10:20:08.556]                           computeRestarts <- base::computeRestarts
[10:20:08.556]                           grepl <- base::grepl
[10:20:08.556]                           restarts <- computeRestarts(cond)
[10:20:08.556]                           for (restart in restarts) {
[10:20:08.556]                             name <- restart$name
[10:20:08.556]                             if (is.null(name)) 
[10:20:08.556]                               next
[10:20:08.556]                             if (!grepl(pattern, name)) 
[10:20:08.556]                               next
[10:20:08.556]                             invokeRestart(restart)
[10:20:08.556]                             muffled <- TRUE
[10:20:08.556]                             break
[10:20:08.556]                           }
[10:20:08.556]                         }
[10:20:08.556]                       }
[10:20:08.556]                       invisible(muffled)
[10:20:08.556]                     }
[10:20:08.556]                     muffleCondition(cond, pattern = "^muffle")
[10:20:08.556]                   }
[10:20:08.556]                 }
[10:20:08.556]             }
[10:20:08.556]         }))
[10:20:08.556]     }, error = function(ex) {
[10:20:08.556]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:08.556]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:08.556]                 ...future.rng), started = ...future.startTime, 
[10:20:08.556]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:08.556]             version = "1.8"), class = "FutureResult")
[10:20:08.556]     }, finally = {
[10:20:08.556]         if (!identical(...future.workdir, getwd())) 
[10:20:08.556]             setwd(...future.workdir)
[10:20:08.556]         {
[10:20:08.556]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:08.556]                 ...future.oldOptions$nwarnings <- NULL
[10:20:08.556]             }
[10:20:08.556]             base::options(...future.oldOptions)
[10:20:08.556]             if (.Platform$OS.type == "windows") {
[10:20:08.556]                 old_names <- names(...future.oldEnvVars)
[10:20:08.556]                 envs <- base::Sys.getenv()
[10:20:08.556]                 names <- names(envs)
[10:20:08.556]                 common <- intersect(names, old_names)
[10:20:08.556]                 added <- setdiff(names, old_names)
[10:20:08.556]                 removed <- setdiff(old_names, names)
[10:20:08.556]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:08.556]                   envs[common]]
[10:20:08.556]                 NAMES <- toupper(changed)
[10:20:08.556]                 args <- list()
[10:20:08.556]                 for (kk in seq_along(NAMES)) {
[10:20:08.556]                   name <- changed[[kk]]
[10:20:08.556]                   NAME <- NAMES[[kk]]
[10:20:08.556]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:08.556]                     next
[10:20:08.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:08.556]                 }
[10:20:08.556]                 NAMES <- toupper(added)
[10:20:08.556]                 for (kk in seq_along(NAMES)) {
[10:20:08.556]                   name <- added[[kk]]
[10:20:08.556]                   NAME <- NAMES[[kk]]
[10:20:08.556]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:08.556]                     next
[10:20:08.556]                   args[[name]] <- ""
[10:20:08.556]                 }
[10:20:08.556]                 NAMES <- toupper(removed)
[10:20:08.556]                 for (kk in seq_along(NAMES)) {
[10:20:08.556]                   name <- removed[[kk]]
[10:20:08.556]                   NAME <- NAMES[[kk]]
[10:20:08.556]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:08.556]                     next
[10:20:08.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:08.556]                 }
[10:20:08.556]                 if (length(args) > 0) 
[10:20:08.556]                   base::do.call(base::Sys.setenv, args = args)
[10:20:08.556]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:08.556]             }
[10:20:08.556]             else {
[10:20:08.556]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:08.556]             }
[10:20:08.556]             {
[10:20:08.556]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:08.556]                   0L) {
[10:20:08.556]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:08.556]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:08.556]                   base::options(opts)
[10:20:08.556]                 }
[10:20:08.556]                 {
[10:20:08.556]                   {
[10:20:08.556]                     NULL
[10:20:08.556]                     RNGkind("Mersenne-Twister")
[10:20:08.556]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:08.556]                       inherits = FALSE)
[10:20:08.556]                   }
[10:20:08.556]                   options(future.plan = NULL)
[10:20:08.556]                   if (is.na(NA_character_)) 
[10:20:08.556]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:08.556]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:08.556]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:08.556]                     .init = FALSE)
[10:20:08.556]                 }
[10:20:08.556]             }
[10:20:08.556]         }
[10:20:08.556]     })
[10:20:08.556]     if (TRUE) {
[10:20:08.556]         base::sink(type = "output", split = FALSE)
[10:20:08.556]         if (TRUE) {
[10:20:08.556]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:08.556]         }
[10:20:08.556]         else {
[10:20:08.556]             ...future.result["stdout"] <- base::list(NULL)
[10:20:08.556]         }
[10:20:08.556]         base::close(...future.stdout)
[10:20:08.556]         ...future.stdout <- NULL
[10:20:08.556]     }
[10:20:08.556]     ...future.result$conditions <- ...future.conditions
[10:20:08.556]     ...future.result$finished <- base::Sys.time()
[10:20:08.556]     ...future.result
[10:20:08.556] }
[10:20:08.558] assign_globals() ...
[10:20:08.558] List of 5
[10:20:08.558]  $ ...future.FUN            :function (x)  
[10:20:08.558]  $ future.call.arguments    : list()
[10:20:08.558]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:08.558]  $ ...future.elements_ii    :List of 2
[10:20:08.558]   ..$ : int 1
[10:20:08.558]   ..$ : int 0
[10:20:08.558]  $ ...future.seeds_ii       : NULL
[10:20:08.558]  $ ...future.globals.maxSize: NULL
[10:20:08.558]  - attr(*, "where")=List of 5
[10:20:08.558]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:08.558]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:20:08.558]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:08.558]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:08.558]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:08.558]  - attr(*, "resolved")= logi FALSE
[10:20:08.558]  - attr(*, "total_size")= num 5632
[10:20:08.558]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:08.558]  - attr(*, "already-done")= logi TRUE
[10:20:08.565] - reassign environment for ‘...future.FUN’
[10:20:08.565] - copied ‘...future.FUN’ to environment
[10:20:08.565] - copied ‘future.call.arguments’ to environment
[10:20:08.565] - copied ‘...future.elements_ii’ to environment
[10:20:08.565] - copied ‘...future.seeds_ii’ to environment
[10:20:08.565] - copied ‘...future.globals.maxSize’ to environment
[10:20:08.565] assign_globals() ... done
[10:20:08.566] plan(): Setting new future strategy stack:
[10:20:08.566] List of future strategies:
[10:20:08.566] 1. sequential:
[10:20:08.566]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:08.566]    - tweaked: FALSE
[10:20:08.566]    - call: NULL
[10:20:08.566] plan(): nbrOfWorkers() = 1
[10:20:09.068] plan(): Setting new future strategy stack:
[10:20:09.068] List of future strategies:
[10:20:09.068] 1. multicore:
[10:20:09.068]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:20:09.068]    - tweaked: FALSE
[10:20:09.068]    - call: plan(strategy)
[10:20:09.070] plan(): nbrOfWorkers() = 1
[10:20:09.070] SequentialFuture started (and completed)
[10:20:09.070] - Launch lazy future ... done
[10:20:09.070] run() for ‘SequentialFuture’ ... done
[10:20:09.070] Created future:
[10:20:09.071] SequentialFuture:
[10:20:09.071] Label: ‘future_lapply-1’
[10:20:09.071] Expression:
[10:20:09.071] {
[10:20:09.071]     do.call(function(...) {
[10:20:09.071]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:09.071]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:09.071]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:09.071]             on.exit(options(oopts), add = TRUE)
[10:20:09.071]         }
[10:20:09.071]         {
[10:20:09.071]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:09.071]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:09.071]                 ...future.FUN(...future.X_jj, ...)
[10:20:09.071]             })
[10:20:09.071]         }
[10:20:09.071]     }, args = future.call.arguments)
[10:20:09.071] }
[10:20:09.071] Lazy evaluation: FALSE
[10:20:09.071] Asynchronous evaluation: FALSE
[10:20:09.071] Local evaluation: TRUE
[10:20:09.071] Environment: R_GlobalEnv
[10:20:09.071] Capture standard output: TRUE
[10:20:09.071] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:09.071] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:09.071] Packages: <none>
[10:20:09.071] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:09.071] Resolved: TRUE
[10:20:09.071] Value: 55 bytes of class ‘list’
[10:20:09.071] Early signaling: FALSE
[10:20:09.071] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:09.071] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:09.071] Chunk #1 of 1 ... DONE
[10:20:09.072] Launching 1 futures (chunks) ... DONE
[10:20:09.072] Resolving 1 futures (chunks) ...
[10:20:09.072] resolve() on list ...
[10:20:09.072]  recursive: 0
[10:20:09.072]  length: 1
[10:20:09.072] 
[10:20:09.072] resolved() for ‘SequentialFuture’ ...
[10:20:09.072] - state: ‘finished’
[10:20:09.072] - run: TRUE
[10:20:09.072] - result: ‘FutureResult’
[10:20:09.072] resolved() for ‘SequentialFuture’ ... done
[10:20:09.072] Future #1
[10:20:09.073] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:20:09.073] - nx: 1
[10:20:09.073] - relay: TRUE
[10:20:09.073] - stdout: TRUE
[10:20:09.073] - signal: TRUE
[10:20:09.073] - resignal: FALSE
[10:20:09.073] - force: TRUE
[10:20:09.073] - relayed: [n=1] FALSE
[10:20:09.073] - queued futures: [n=1] FALSE
[10:20:09.073]  - until=1
[10:20:09.073]  - relaying element #1
[10:20:09.074] - relayed: [n=1] TRUE
[10:20:09.074] - queued futures: [n=1] TRUE
[10:20:09.074] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:20:09.074]  length: 0 (resolved future 1)
[10:20:09.074] Relaying remaining futures
[10:20:09.074] signalConditionsASAP(NULL, pos=0) ...
[10:20:09.074] - nx: 1
[10:20:09.074] - relay: TRUE
[10:20:09.074] - stdout: TRUE
[10:20:09.074] - signal: TRUE
[10:20:09.074] - resignal: FALSE
[10:20:09.075] - force: TRUE
[10:20:09.075] - relayed: [n=1] TRUE
[10:20:09.075] - queued futures: [n=1] TRUE
 - flush all
[10:20:09.075] - relayed: [n=1] TRUE
[10:20:09.075] - queued futures: [n=1] TRUE
[10:20:09.075] signalConditionsASAP(NULL, pos=0) ... done
[10:20:09.075] resolve() on list ... DONE
[10:20:09.075]  - Number of value chunks collected: 1
[10:20:09.075] Resolving 1 futures (chunks) ... DONE
[10:20:09.075] Reducing values from 1 chunks ...
[10:20:09.075]  - Number of values collected after concatenation: 2
[10:20:09.076]  - Number of values expected: 2
[10:20:09.076] Reducing values from 1 chunks ... DONE
[10:20:09.076] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[10:20:09.076] future_lapply() ...
[10:20:09.078] Number of chunks: 1
[10:20:09.078] getGlobalsAndPackagesXApply() ...
[10:20:09.078]  - future.globals: TRUE
[10:20:09.078] getGlobalsAndPackages() ...
[10:20:09.078] Searching for globals...
[10:20:09.080] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:20:09.080] Searching for globals ... DONE
[10:20:09.080] Resolving globals: FALSE
[10:20:09.080] The total size of the 1 globals is 841 bytes (841 bytes)
[10:20:09.081] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[10:20:09.081] - globals: [1] ‘FUN’
[10:20:09.081] 
[10:20:09.081] getGlobalsAndPackages() ... DONE
[10:20:09.081]  - globals found/used: [n=1] ‘FUN’
[10:20:09.081]  - needed namespaces: [n=0] 
[10:20:09.081] Finding globals ... DONE
[10:20:09.081]  - use_args: TRUE
[10:20:09.081]  - Getting '...' globals ...
[10:20:09.082] resolve() on list ...
[10:20:09.082]  recursive: 0
[10:20:09.082]  length: 1
[10:20:09.082]  elements: ‘...’
[10:20:09.082]  length: 0 (resolved future 1)
[10:20:09.082] resolve() on list ... DONE
[10:20:09.082]    - '...' content: [n=0] 
[10:20:09.082] List of 1
[10:20:09.082]  $ ...: list()
[10:20:09.082]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:09.082]  - attr(*, "where")=List of 1
[10:20:09.082]   ..$ ...:<environment: 0x557fc1d97188> 
[10:20:09.082]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:09.082]  - attr(*, "resolved")= logi TRUE
[10:20:09.082]  - attr(*, "total_size")= num NA
[10:20:09.085]  - Getting '...' globals ... DONE
[10:20:09.085] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:20:09.085] List of 2
[10:20:09.085]  $ ...future.FUN:function (x)  
[10:20:09.085]  $ ...          : list()
[10:20:09.085]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:09.085]  - attr(*, "where")=List of 2
[10:20:09.085]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:09.085]   ..$ ...          :<environment: 0x557fc1d97188> 
[10:20:09.085]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:09.085]  - attr(*, "resolved")= logi FALSE
[10:20:09.085]  - attr(*, "total_size")= num 5632
[10:20:09.089] Packages to be attached in all futures: [n=0] 
[10:20:09.090] getGlobalsAndPackagesXApply() ... DONE
[10:20:09.090] Number of futures (= number of chunks): 1
[10:20:09.090] Launching 1 futures (chunks) ...
[10:20:09.090] Chunk #1 of 1 ...
[10:20:09.090]  - Finding globals in 'X' for chunk #1 ...
[10:20:09.090] getGlobalsAndPackages() ...
[10:20:09.090] Searching for globals...
[10:20:09.090] 
[10:20:09.091] Searching for globals ... DONE
[10:20:09.091] - globals: [0] <none>
[10:20:09.091] getGlobalsAndPackages() ... DONE
[10:20:09.091]    + additional globals found: [n=0] 
[10:20:09.091]    + additional namespaces needed: [n=0] 
[10:20:09.091]  - Finding globals in 'X' for chunk #1 ... DONE
[10:20:09.091]  - seeds: <none>
[10:20:09.091]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:09.091] getGlobalsAndPackages() ...
[10:20:09.091] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:09.091] Resolving globals: FALSE
[10:20:09.092] Tweak future expression to call with '...' arguments ...
[10:20:09.092] {
[10:20:09.092]     do.call(function(...) {
[10:20:09.092]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:09.092]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:09.092]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:09.092]             on.exit(options(oopts), add = TRUE)
[10:20:09.092]         }
[10:20:09.092]         {
[10:20:09.092]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:09.092]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:09.092]                 ...future.FUN(...future.X_jj, ...)
[10:20:09.092]             })
[10:20:09.092]         }
[10:20:09.092]     }, args = future.call.arguments)
[10:20:09.092] }
[10:20:09.092] Tweak future expression to call with '...' arguments ... DONE
[10:20:09.092] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:09.092] 
[10:20:09.093] getGlobalsAndPackages() ... DONE
[10:20:09.093] run() for ‘Future’ ...
[10:20:09.093] - state: ‘created’
[10:20:09.093] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:20:09.095] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:09.095] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:09.095]   - Field: ‘label’
[10:20:09.095]   - Field: ‘local’
[10:20:09.095]   - Field: ‘owner’
[10:20:09.095]   - Field: ‘envir’
[10:20:09.095]   - Field: ‘packages’
[10:20:09.095]   - Field: ‘gc’
[10:20:09.095]   - Field: ‘conditions’
[10:20:09.095]   - Field: ‘expr’
[10:20:09.095]   - Field: ‘uuid’
[10:20:09.096]   - Field: ‘seed’
[10:20:09.096]   - Field: ‘version’
[10:20:09.096]   - Field: ‘result’
[10:20:09.096]   - Field: ‘asynchronous’
[10:20:09.096]   - Field: ‘calls’
[10:20:09.096]   - Field: ‘globals’
[10:20:09.096]   - Field: ‘stdout’
[10:20:09.096]   - Field: ‘earlySignal’
[10:20:09.096]   - Field: ‘lazy’
[10:20:09.096]   - Field: ‘state’
[10:20:09.096] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:09.096] - Launch lazy future ...
[10:20:09.097] Packages needed by the future expression (n = 0): <none>
[10:20:09.097] Packages needed by future strategies (n = 0): <none>
[10:20:09.097] {
[10:20:09.097]     {
[10:20:09.097]         {
[10:20:09.097]             ...future.startTime <- base::Sys.time()
[10:20:09.097]             {
[10:20:09.097]                 {
[10:20:09.097]                   {
[10:20:09.097]                     base::local({
[10:20:09.097]                       has_future <- base::requireNamespace("future", 
[10:20:09.097]                         quietly = TRUE)
[10:20:09.097]                       if (has_future) {
[10:20:09.097]                         ns <- base::getNamespace("future")
[10:20:09.097]                         version <- ns[[".package"]][["version"]]
[10:20:09.097]                         if (is.null(version)) 
[10:20:09.097]                           version <- utils::packageVersion("future")
[10:20:09.097]                       }
[10:20:09.097]                       else {
[10:20:09.097]                         version <- NULL
[10:20:09.097]                       }
[10:20:09.097]                       if (!has_future || version < "1.8.0") {
[10:20:09.097]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:09.097]                           "", base::R.version$version.string), 
[10:20:09.097]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:09.097]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:09.097]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:09.097]                             "release", "version")], collapse = " "), 
[10:20:09.097]                           hostname = base::Sys.info()[["nodename"]])
[10:20:09.097]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:09.097]                           info)
[10:20:09.097]                         info <- base::paste(info, collapse = "; ")
[10:20:09.097]                         if (!has_future) {
[10:20:09.097]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:09.097]                             info)
[10:20:09.097]                         }
[10:20:09.097]                         else {
[10:20:09.097]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:09.097]                             info, version)
[10:20:09.097]                         }
[10:20:09.097]                         base::stop(msg)
[10:20:09.097]                       }
[10:20:09.097]                     })
[10:20:09.097]                   }
[10:20:09.097]                   ...future.strategy.old <- future::plan("list")
[10:20:09.097]                   options(future.plan = NULL)
[10:20:09.097]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:09.097]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:09.097]                 }
[10:20:09.097]                 ...future.workdir <- getwd()
[10:20:09.097]             }
[10:20:09.097]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:09.097]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:09.097]         }
[10:20:09.097]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:09.097]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:09.097]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:09.097]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:09.097]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:09.097]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:09.097]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:09.097]             base::names(...future.oldOptions))
[10:20:09.097]     }
[10:20:09.097]     if (TRUE) {
[10:20:09.097]     }
[10:20:09.097]     else {
[10:20:09.097]         if (NA) {
[10:20:09.097]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:09.097]                 open = "w")
[10:20:09.097]         }
[10:20:09.097]         else {
[10:20:09.097]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:09.097]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:09.097]         }
[10:20:09.097]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:09.097]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:09.097]             base::sink(type = "output", split = FALSE)
[10:20:09.097]             base::close(...future.stdout)
[10:20:09.097]         }, add = TRUE)
[10:20:09.097]     }
[10:20:09.097]     ...future.frame <- base::sys.nframe()
[10:20:09.097]     ...future.conditions <- base::list()
[10:20:09.097]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:09.097]     if (FALSE) {
[10:20:09.097]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:09.097]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:09.097]     }
[10:20:09.097]     ...future.result <- base::tryCatch({
[10:20:09.097]         base::withCallingHandlers({
[10:20:09.097]             ...future.value <- base::withVisible(base::local({
[10:20:09.097]                 do.call(function(...) {
[10:20:09.097]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:09.097]                   if (!identical(...future.globals.maxSize.org, 
[10:20:09.097]                     ...future.globals.maxSize)) {
[10:20:09.097]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:09.097]                     on.exit(options(oopts), add = TRUE)
[10:20:09.097]                   }
[10:20:09.097]                   {
[10:20:09.097]                     lapply(seq_along(...future.elements_ii), 
[10:20:09.097]                       FUN = function(jj) {
[10:20:09.097]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:09.097]                         ...future.FUN(...future.X_jj, ...)
[10:20:09.097]                       })
[10:20:09.097]                   }
[10:20:09.097]                 }, args = future.call.arguments)
[10:20:09.097]             }))
[10:20:09.097]             future::FutureResult(value = ...future.value$value, 
[10:20:09.097]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:09.097]                   ...future.rng), globalenv = if (FALSE) 
[10:20:09.097]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:09.097]                     ...future.globalenv.names))
[10:20:09.097]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:09.097]         }, condition = base::local({
[10:20:09.097]             c <- base::c
[10:20:09.097]             inherits <- base::inherits
[10:20:09.097]             invokeRestart <- base::invokeRestart
[10:20:09.097]             length <- base::length
[10:20:09.097]             list <- base::list
[10:20:09.097]             seq.int <- base::seq.int
[10:20:09.097]             signalCondition <- base::signalCondition
[10:20:09.097]             sys.calls <- base::sys.calls
[10:20:09.097]             `[[` <- base::`[[`
[10:20:09.097]             `+` <- base::`+`
[10:20:09.097]             `<<-` <- base::`<<-`
[10:20:09.097]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:09.097]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:09.097]                   3L)]
[10:20:09.097]             }
[10:20:09.097]             function(cond) {
[10:20:09.097]                 is_error <- inherits(cond, "error")
[10:20:09.097]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:09.097]                   NULL)
[10:20:09.097]                 if (is_error) {
[10:20:09.097]                   sessionInformation <- function() {
[10:20:09.097]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:09.097]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:09.097]                       search = base::search(), system = base::Sys.info())
[10:20:09.097]                   }
[10:20:09.097]                   ...future.conditions[[length(...future.conditions) + 
[10:20:09.097]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:09.097]                     cond$call), session = sessionInformation(), 
[10:20:09.097]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:09.097]                   signalCondition(cond)
[10:20:09.097]                 }
[10:20:09.097]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:09.097]                 "immediateCondition"))) {
[10:20:09.097]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:09.097]                   ...future.conditions[[length(...future.conditions) + 
[10:20:09.097]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:09.097]                   if (TRUE && !signal) {
[10:20:09.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:09.097]                     {
[10:20:09.097]                       inherits <- base::inherits
[10:20:09.097]                       invokeRestart <- base::invokeRestart
[10:20:09.097]                       is.null <- base::is.null
[10:20:09.097]                       muffled <- FALSE
[10:20:09.097]                       if (inherits(cond, "message")) {
[10:20:09.097]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:09.097]                         if (muffled) 
[10:20:09.097]                           invokeRestart("muffleMessage")
[10:20:09.097]                       }
[10:20:09.097]                       else if (inherits(cond, "warning")) {
[10:20:09.097]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:09.097]                         if (muffled) 
[10:20:09.097]                           invokeRestart("muffleWarning")
[10:20:09.097]                       }
[10:20:09.097]                       else if (inherits(cond, "condition")) {
[10:20:09.097]                         if (!is.null(pattern)) {
[10:20:09.097]                           computeRestarts <- base::computeRestarts
[10:20:09.097]                           grepl <- base::grepl
[10:20:09.097]                           restarts <- computeRestarts(cond)
[10:20:09.097]                           for (restart in restarts) {
[10:20:09.097]                             name <- restart$name
[10:20:09.097]                             if (is.null(name)) 
[10:20:09.097]                               next
[10:20:09.097]                             if (!grepl(pattern, name)) 
[10:20:09.097]                               next
[10:20:09.097]                             invokeRestart(restart)
[10:20:09.097]                             muffled <- TRUE
[10:20:09.097]                             break
[10:20:09.097]                           }
[10:20:09.097]                         }
[10:20:09.097]                       }
[10:20:09.097]                       invisible(muffled)
[10:20:09.097]                     }
[10:20:09.097]                     muffleCondition(cond, pattern = "^muffle")
[10:20:09.097]                   }
[10:20:09.097]                 }
[10:20:09.097]                 else {
[10:20:09.097]                   if (TRUE) {
[10:20:09.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:09.097]                     {
[10:20:09.097]                       inherits <- base::inherits
[10:20:09.097]                       invokeRestart <- base::invokeRestart
[10:20:09.097]                       is.null <- base::is.null
[10:20:09.097]                       muffled <- FALSE
[10:20:09.097]                       if (inherits(cond, "message")) {
[10:20:09.097]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:09.097]                         if (muffled) 
[10:20:09.097]                           invokeRestart("muffleMessage")
[10:20:09.097]                       }
[10:20:09.097]                       else if (inherits(cond, "warning")) {
[10:20:09.097]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:09.097]                         if (muffled) 
[10:20:09.097]                           invokeRestart("muffleWarning")
[10:20:09.097]                       }
[10:20:09.097]                       else if (inherits(cond, "condition")) {
[10:20:09.097]                         if (!is.null(pattern)) {
[10:20:09.097]                           computeRestarts <- base::computeRestarts
[10:20:09.097]                           grepl <- base::grepl
[10:20:09.097]                           restarts <- computeRestarts(cond)
[10:20:09.097]                           for (restart in restarts) {
[10:20:09.097]                             name <- restart$name
[10:20:09.097]                             if (is.null(name)) 
[10:20:09.097]                               next
[10:20:09.097]                             if (!grepl(pattern, name)) 
[10:20:09.097]                               next
[10:20:09.097]                             invokeRestart(restart)
[10:20:09.097]                             muffled <- TRUE
[10:20:09.097]                             break
[10:20:09.097]                           }
[10:20:09.097]                         }
[10:20:09.097]                       }
[10:20:09.097]                       invisible(muffled)
[10:20:09.097]                     }
[10:20:09.097]                     muffleCondition(cond, pattern = "^muffle")
[10:20:09.097]                   }
[10:20:09.097]                 }
[10:20:09.097]             }
[10:20:09.097]         }))
[10:20:09.097]     }, error = function(ex) {
[10:20:09.097]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:09.097]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:09.097]                 ...future.rng), started = ...future.startTime, 
[10:20:09.097]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:09.097]             version = "1.8"), class = "FutureResult")
[10:20:09.097]     }, finally = {
[10:20:09.097]         if (!identical(...future.workdir, getwd())) 
[10:20:09.097]             setwd(...future.workdir)
[10:20:09.097]         {
[10:20:09.097]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:09.097]                 ...future.oldOptions$nwarnings <- NULL
[10:20:09.097]             }
[10:20:09.097]             base::options(...future.oldOptions)
[10:20:09.097]             if (.Platform$OS.type == "windows") {
[10:20:09.097]                 old_names <- names(...future.oldEnvVars)
[10:20:09.097]                 envs <- base::Sys.getenv()
[10:20:09.097]                 names <- names(envs)
[10:20:09.097]                 common <- intersect(names, old_names)
[10:20:09.097]                 added <- setdiff(names, old_names)
[10:20:09.097]                 removed <- setdiff(old_names, names)
[10:20:09.097]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:09.097]                   envs[common]]
[10:20:09.097]                 NAMES <- toupper(changed)
[10:20:09.097]                 args <- list()
[10:20:09.097]                 for (kk in seq_along(NAMES)) {
[10:20:09.097]                   name <- changed[[kk]]
[10:20:09.097]                   NAME <- NAMES[[kk]]
[10:20:09.097]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:09.097]                     next
[10:20:09.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:09.097]                 }
[10:20:09.097]                 NAMES <- toupper(added)
[10:20:09.097]                 for (kk in seq_along(NAMES)) {
[10:20:09.097]                   name <- added[[kk]]
[10:20:09.097]                   NAME <- NAMES[[kk]]
[10:20:09.097]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:09.097]                     next
[10:20:09.097]                   args[[name]] <- ""
[10:20:09.097]                 }
[10:20:09.097]                 NAMES <- toupper(removed)
[10:20:09.097]                 for (kk in seq_along(NAMES)) {
[10:20:09.097]                   name <- removed[[kk]]
[10:20:09.097]                   NAME <- NAMES[[kk]]
[10:20:09.097]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:09.097]                     next
[10:20:09.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:09.097]                 }
[10:20:09.097]                 if (length(args) > 0) 
[10:20:09.097]                   base::do.call(base::Sys.setenv, args = args)
[10:20:09.097]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:09.097]             }
[10:20:09.097]             else {
[10:20:09.097]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:09.097]             }
[10:20:09.097]             {
[10:20:09.097]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:09.097]                   0L) {
[10:20:09.097]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:09.097]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:09.097]                   base::options(opts)
[10:20:09.097]                 }
[10:20:09.097]                 {
[10:20:09.097]                   {
[10:20:09.097]                     NULL
[10:20:09.097]                     RNGkind("Mersenne-Twister")
[10:20:09.097]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:09.097]                       inherits = FALSE)
[10:20:09.097]                   }
[10:20:09.097]                   options(future.plan = NULL)
[10:20:09.097]                   if (is.na(NA_character_)) 
[10:20:09.097]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:09.097]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:09.097]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:09.097]                     .init = FALSE)
[10:20:09.097]                 }
[10:20:09.097]             }
[10:20:09.097]         }
[10:20:09.097]     })
[10:20:09.097]     if (FALSE) {
[10:20:09.097]         base::sink(type = "output", split = FALSE)
[10:20:09.097]         if (NA) {
[10:20:09.097]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:09.097]         }
[10:20:09.097]         else {
[10:20:09.097]             ...future.result["stdout"] <- base::list(NULL)
[10:20:09.097]         }
[10:20:09.097]         base::close(...future.stdout)
[10:20:09.097]         ...future.stdout <- NULL
[10:20:09.097]     }
[10:20:09.097]     ...future.result$conditions <- ...future.conditions
[10:20:09.097]     ...future.result$finished <- base::Sys.time()
[10:20:09.097]     ...future.result
[10:20:09.097] }
[10:20:09.099] assign_globals() ...
[10:20:09.099] List of 5
[10:20:09.099]  $ ...future.FUN            :function (x)  
[10:20:09.099]  $ future.call.arguments    : list()
[10:20:09.099]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:09.099]  $ ...future.elements_ii    :List of 2
[10:20:09.099]   ..$ : int 1
[10:20:09.099]   ..$ : int 0
[10:20:09.099]  $ ...future.seeds_ii       : NULL
[10:20:09.099]  $ ...future.globals.maxSize: NULL
[10:20:09.099]  - attr(*, "where")=List of 5
[10:20:09.099]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:09.099]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:20:09.099]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:09.099]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:09.099]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:09.099]  - attr(*, "resolved")= logi FALSE
[10:20:09.099]  - attr(*, "total_size")= num 5632
[10:20:09.099]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:09.099]  - attr(*, "already-done")= logi TRUE
[10:20:09.104] - reassign environment for ‘...future.FUN’
[10:20:09.104] - copied ‘...future.FUN’ to environment
[10:20:09.104] - copied ‘future.call.arguments’ to environment
[10:20:09.104] - copied ‘...future.elements_ii’ to environment
[10:20:09.104] - copied ‘...future.seeds_ii’ to environment
[10:20:09.104] - copied ‘...future.globals.maxSize’ to environment
[10:20:09.104] assign_globals() ... done
[10:20:09.105] plan(): Setting new future strategy stack:
[10:20:09.105] List of future strategies:
[10:20:09.105] 1. sequential:
[10:20:09.105]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:09.105]    - tweaked: FALSE
[10:20:09.105]    - call: NULL
[10:20:09.105] plan(): nbrOfWorkers() = 1
[10:20:09.607] plan(): Setting new future strategy stack:
[10:20:09.607] List of future strategies:
[10:20:09.607] 1. multicore:
[10:20:09.607]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:20:09.607]    - tweaked: FALSE
[10:20:09.607]    - call: plan(strategy)
[10:20:09.609] plan(): nbrOfWorkers() = 1
[10:20:09.609] SequentialFuture started (and completed)
[10:20:09.609] - Launch lazy future ... done
[10:20:09.609] run() for ‘SequentialFuture’ ... done
[10:20:09.609] Created future:
[10:20:09.609] SequentialFuture:
[10:20:09.609] Label: ‘future_lapply-1’
[10:20:09.609] Expression:
[10:20:09.609] {
[10:20:09.609]     do.call(function(...) {
[10:20:09.609]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:09.609]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:09.609]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:09.609]             on.exit(options(oopts), add = TRUE)
[10:20:09.609]         }
[10:20:09.609]         {
[10:20:09.609]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:09.609]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:09.609]                 ...future.FUN(...future.X_jj, ...)
[10:20:09.609]             })
[10:20:09.609]         }
[10:20:09.609]     }, args = future.call.arguments)
[10:20:09.609] }
[10:20:09.609] Lazy evaluation: FALSE
[10:20:09.609] Asynchronous evaluation: FALSE
[10:20:09.609] Local evaluation: TRUE
[10:20:09.609] Environment: R_GlobalEnv
[10:20:09.609] Capture standard output: NA
[10:20:09.609] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:09.609] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:09.609] Packages: <none>
[10:20:09.609] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:09.609] Resolved: TRUE
[10:20:09.609] Value: 55 bytes of class ‘list’
[10:20:09.609] Early signaling: FALSE
[10:20:09.609] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:09.609] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:09.610] Chunk #1 of 1 ... DONE
[10:20:09.610] Launching 1 futures (chunks) ... DONE
[10:20:09.611] Resolving 1 futures (chunks) ...
[10:20:09.611] resolve() on list ...
[10:20:09.611]  recursive: 0
[10:20:09.611]  length: 1
[10:20:09.611] 
[10:20:09.611] resolved() for ‘SequentialFuture’ ...
[10:20:09.611] - state: ‘finished’
[10:20:09.611] - run: TRUE
[10:20:09.611] - result: ‘FutureResult’
[10:20:09.611] resolved() for ‘SequentialFuture’ ... done
[10:20:09.611] Future #1
[10:20:09.612] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:20:09.612] - nx: 1
[10:20:09.612] - relay: TRUE
[10:20:09.612] - stdout: TRUE
[10:20:09.612] - signal: TRUE
[10:20:09.612] - resignal: FALSE
[10:20:09.612] - force: TRUE
[10:20:09.612] - relayed: [n=1] FALSE
[10:20:09.612] - queued futures: [n=1] FALSE
[10:20:09.612]  - until=1
[10:20:09.612]  - relaying element #1
[10:20:09.614] - relayed: [n=1] TRUE
[10:20:09.614] - queued futures: [n=1] TRUE
[10:20:09.615] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:20:09.615]  length: 0 (resolved future 1)
[10:20:09.615] Relaying remaining futures
[10:20:09.615] signalConditionsASAP(NULL, pos=0) ...
[10:20:09.615] - nx: 1
[10:20:09.615] - relay: TRUE
[10:20:09.615] - stdout: TRUE
[10:20:09.615] - signal: TRUE
[10:20:09.615] - resignal: FALSE
[10:20:09.615] - force: TRUE
[10:20:09.615] - relayed: [n=1] TRUE
[10:20:09.615] - queued futures: [n=1] TRUE
 - flush all
[10:20:09.616] - relayed: [n=1] TRUE
[10:20:09.616] - queued futures: [n=1] TRUE
[10:20:09.616] signalConditionsASAP(NULL, pos=0) ... done
[10:20:09.616] resolve() on list ... DONE
[10:20:09.616]  - Number of value chunks collected: 1
[10:20:09.616] Resolving 1 futures (chunks) ... DONE
[10:20:09.616] Reducing values from 1 chunks ...
[10:20:09.616]  - Number of values collected after concatenation: 2
[10:20:09.616]  - Number of values expected: 2
[10:20:09.616] Reducing values from 1 chunks ... DONE
[10:20:09.616] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[10:20:09.617] future_mapply() ...
[10:20:09.618] Number of chunks: 1
[10:20:09.618] getGlobalsAndPackagesXApply() ...
[10:20:09.618]  - future.globals: TRUE
[10:20:09.618] getGlobalsAndPackages() ...
[10:20:09.619] Searching for globals...
[10:20:09.620] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:20:09.620] Searching for globals ... DONE
[10:20:09.620] Resolving globals: FALSE
[10:20:09.621] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[10:20:09.621] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[10:20:09.621] - globals: [1] ‘FUN’
[10:20:09.621] 
[10:20:09.621] getGlobalsAndPackages() ... DONE
[10:20:09.621]  - globals found/used: [n=1] ‘FUN’
[10:20:09.621]  - needed namespaces: [n=0] 
[10:20:09.622] Finding globals ... DONE
[10:20:09.622] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:20:09.622] List of 2
[10:20:09.622]  $ ...future.FUN:function (x, y)  
[10:20:09.622]  $ MoreArgs     : NULL
[10:20:09.622]  - attr(*, "where")=List of 2
[10:20:09.622]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:09.622]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:20:09.622]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:09.622]  - attr(*, "resolved")= logi FALSE
[10:20:09.622]  - attr(*, "total_size")= num NA
[10:20:09.624] Packages to be attached in all futures: [n=0] 
[10:20:09.624] getGlobalsAndPackagesXApply() ... DONE
[10:20:09.625] Number of futures (= number of chunks): 1
[10:20:09.625] Launching 1 futures (chunks) ...
[10:20:09.625] Chunk #1 of 1 ...
[10:20:09.625]  - Finding globals in '...' for chunk #1 ...
[10:20:09.625] getGlobalsAndPackages() ...
[10:20:09.625] Searching for globals...
[10:20:09.625] 
[10:20:09.625] Searching for globals ... DONE
[10:20:09.625] - globals: [0] <none>
[10:20:09.626] getGlobalsAndPackages() ... DONE
[10:20:09.626]    + additional globals found: [n=0] 
[10:20:09.626]    + additional namespaces needed: [n=0] 
[10:20:09.626]  - Finding globals in '...' for chunk #1 ... DONE
[10:20:09.626]  - seeds: <none>
[10:20:09.626]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:09.626] getGlobalsAndPackages() ...
[10:20:09.626] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:09.626] Resolving globals: FALSE
[10:20:09.627] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[10:20:09.627] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:20:09.627] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:09.627] 
[10:20:09.627] getGlobalsAndPackages() ... DONE
[10:20:09.628] run() for ‘Future’ ...
[10:20:09.628] - state: ‘created’
[10:20:09.628] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:20:09.629] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:09.630] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:09.630]   - Field: ‘label’
[10:20:09.630]   - Field: ‘local’
[10:20:09.630]   - Field: ‘owner’
[10:20:09.630]   - Field: ‘envir’
[10:20:09.630]   - Field: ‘packages’
[10:20:09.630]   - Field: ‘gc’
[10:20:09.630]   - Field: ‘conditions’
[10:20:09.630]   - Field: ‘expr’
[10:20:09.630]   - Field: ‘uuid’
[10:20:09.630]   - Field: ‘seed’
[10:20:09.630]   - Field: ‘version’
[10:20:09.631]   - Field: ‘result’
[10:20:09.631]   - Field: ‘asynchronous’
[10:20:09.631]   - Field: ‘calls’
[10:20:09.631]   - Field: ‘globals’
[10:20:09.631]   - Field: ‘stdout’
[10:20:09.631]   - Field: ‘earlySignal’
[10:20:09.631]   - Field: ‘lazy’
[10:20:09.631]   - Field: ‘state’
[10:20:09.631] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:09.631] - Launch lazy future ...
[10:20:09.631] Packages needed by the future expression (n = 0): <none>
[10:20:09.632] Packages needed by future strategies (n = 0): <none>
[10:20:09.632] {
[10:20:09.632]     {
[10:20:09.632]         {
[10:20:09.632]             ...future.startTime <- base::Sys.time()
[10:20:09.632]             {
[10:20:09.632]                 {
[10:20:09.632]                   {
[10:20:09.632]                     base::local({
[10:20:09.632]                       has_future <- base::requireNamespace("future", 
[10:20:09.632]                         quietly = TRUE)
[10:20:09.632]                       if (has_future) {
[10:20:09.632]                         ns <- base::getNamespace("future")
[10:20:09.632]                         version <- ns[[".package"]][["version"]]
[10:20:09.632]                         if (is.null(version)) 
[10:20:09.632]                           version <- utils::packageVersion("future")
[10:20:09.632]                       }
[10:20:09.632]                       else {
[10:20:09.632]                         version <- NULL
[10:20:09.632]                       }
[10:20:09.632]                       if (!has_future || version < "1.8.0") {
[10:20:09.632]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:09.632]                           "", base::R.version$version.string), 
[10:20:09.632]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:09.632]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:09.632]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:09.632]                             "release", "version")], collapse = " "), 
[10:20:09.632]                           hostname = base::Sys.info()[["nodename"]])
[10:20:09.632]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:09.632]                           info)
[10:20:09.632]                         info <- base::paste(info, collapse = "; ")
[10:20:09.632]                         if (!has_future) {
[10:20:09.632]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:09.632]                             info)
[10:20:09.632]                         }
[10:20:09.632]                         else {
[10:20:09.632]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:09.632]                             info, version)
[10:20:09.632]                         }
[10:20:09.632]                         base::stop(msg)
[10:20:09.632]                       }
[10:20:09.632]                     })
[10:20:09.632]                   }
[10:20:09.632]                   ...future.strategy.old <- future::plan("list")
[10:20:09.632]                   options(future.plan = NULL)
[10:20:09.632]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:09.632]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:09.632]                 }
[10:20:09.632]                 ...future.workdir <- getwd()
[10:20:09.632]             }
[10:20:09.632]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:09.632]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:09.632]         }
[10:20:09.632]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:09.632]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:09.632]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:09.632]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:09.632]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:09.632]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:09.632]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:09.632]             base::names(...future.oldOptions))
[10:20:09.632]     }
[10:20:09.632]     if (FALSE) {
[10:20:09.632]     }
[10:20:09.632]     else {
[10:20:09.632]         if (FALSE) {
[10:20:09.632]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:09.632]                 open = "w")
[10:20:09.632]         }
[10:20:09.632]         else {
[10:20:09.632]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:09.632]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:09.632]         }
[10:20:09.632]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:09.632]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:09.632]             base::sink(type = "output", split = FALSE)
[10:20:09.632]             base::close(...future.stdout)
[10:20:09.632]         }, add = TRUE)
[10:20:09.632]     }
[10:20:09.632]     ...future.frame <- base::sys.nframe()
[10:20:09.632]     ...future.conditions <- base::list()
[10:20:09.632]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:09.632]     if (FALSE) {
[10:20:09.632]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:09.632]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:09.632]     }
[10:20:09.632]     ...future.result <- base::tryCatch({
[10:20:09.632]         base::withCallingHandlers({
[10:20:09.632]             ...future.value <- base::withVisible(base::local({
[10:20:09.632]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:09.632]                 if (!identical(...future.globals.maxSize.org, 
[10:20:09.632]                   ...future.globals.maxSize)) {
[10:20:09.632]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:09.632]                   on.exit(options(oopts), add = TRUE)
[10:20:09.632]                 }
[10:20:09.632]                 {
[10:20:09.632]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:09.632]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:20:09.632]                     USE.NAMES = FALSE)
[10:20:09.632]                   do.call(mapply, args = args)
[10:20:09.632]                 }
[10:20:09.632]             }))
[10:20:09.632]             future::FutureResult(value = ...future.value$value, 
[10:20:09.632]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:09.632]                   ...future.rng), globalenv = if (FALSE) 
[10:20:09.632]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:09.632]                     ...future.globalenv.names))
[10:20:09.632]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:09.632]         }, condition = base::local({
[10:20:09.632]             c <- base::c
[10:20:09.632]             inherits <- base::inherits
[10:20:09.632]             invokeRestart <- base::invokeRestart
[10:20:09.632]             length <- base::length
[10:20:09.632]             list <- base::list
[10:20:09.632]             seq.int <- base::seq.int
[10:20:09.632]             signalCondition <- base::signalCondition
[10:20:09.632]             sys.calls <- base::sys.calls
[10:20:09.632]             `[[` <- base::`[[`
[10:20:09.632]             `+` <- base::`+`
[10:20:09.632]             `<<-` <- base::`<<-`
[10:20:09.632]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:09.632]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:09.632]                   3L)]
[10:20:09.632]             }
[10:20:09.632]             function(cond) {
[10:20:09.632]                 is_error <- inherits(cond, "error")
[10:20:09.632]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:09.632]                   NULL)
[10:20:09.632]                 if (is_error) {
[10:20:09.632]                   sessionInformation <- function() {
[10:20:09.632]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:09.632]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:09.632]                       search = base::search(), system = base::Sys.info())
[10:20:09.632]                   }
[10:20:09.632]                   ...future.conditions[[length(...future.conditions) + 
[10:20:09.632]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:09.632]                     cond$call), session = sessionInformation(), 
[10:20:09.632]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:09.632]                   signalCondition(cond)
[10:20:09.632]                 }
[10:20:09.632]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:09.632]                 "immediateCondition"))) {
[10:20:09.632]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:09.632]                   ...future.conditions[[length(...future.conditions) + 
[10:20:09.632]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:09.632]                   if (TRUE && !signal) {
[10:20:09.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:09.632]                     {
[10:20:09.632]                       inherits <- base::inherits
[10:20:09.632]                       invokeRestart <- base::invokeRestart
[10:20:09.632]                       is.null <- base::is.null
[10:20:09.632]                       muffled <- FALSE
[10:20:09.632]                       if (inherits(cond, "message")) {
[10:20:09.632]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:09.632]                         if (muffled) 
[10:20:09.632]                           invokeRestart("muffleMessage")
[10:20:09.632]                       }
[10:20:09.632]                       else if (inherits(cond, "warning")) {
[10:20:09.632]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:09.632]                         if (muffled) 
[10:20:09.632]                           invokeRestart("muffleWarning")
[10:20:09.632]                       }
[10:20:09.632]                       else if (inherits(cond, "condition")) {
[10:20:09.632]                         if (!is.null(pattern)) {
[10:20:09.632]                           computeRestarts <- base::computeRestarts
[10:20:09.632]                           grepl <- base::grepl
[10:20:09.632]                           restarts <- computeRestarts(cond)
[10:20:09.632]                           for (restart in restarts) {
[10:20:09.632]                             name <- restart$name
[10:20:09.632]                             if (is.null(name)) 
[10:20:09.632]                               next
[10:20:09.632]                             if (!grepl(pattern, name)) 
[10:20:09.632]                               next
[10:20:09.632]                             invokeRestart(restart)
[10:20:09.632]                             muffled <- TRUE
[10:20:09.632]                             break
[10:20:09.632]                           }
[10:20:09.632]                         }
[10:20:09.632]                       }
[10:20:09.632]                       invisible(muffled)
[10:20:09.632]                     }
[10:20:09.632]                     muffleCondition(cond, pattern = "^muffle")
[10:20:09.632]                   }
[10:20:09.632]                 }
[10:20:09.632]                 else {
[10:20:09.632]                   if (TRUE) {
[10:20:09.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:09.632]                     {
[10:20:09.632]                       inherits <- base::inherits
[10:20:09.632]                       invokeRestart <- base::invokeRestart
[10:20:09.632]                       is.null <- base::is.null
[10:20:09.632]                       muffled <- FALSE
[10:20:09.632]                       if (inherits(cond, "message")) {
[10:20:09.632]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:09.632]                         if (muffled) 
[10:20:09.632]                           invokeRestart("muffleMessage")
[10:20:09.632]                       }
[10:20:09.632]                       else if (inherits(cond, "warning")) {
[10:20:09.632]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:09.632]                         if (muffled) 
[10:20:09.632]                           invokeRestart("muffleWarning")
[10:20:09.632]                       }
[10:20:09.632]                       else if (inherits(cond, "condition")) {
[10:20:09.632]                         if (!is.null(pattern)) {
[10:20:09.632]                           computeRestarts <- base::computeRestarts
[10:20:09.632]                           grepl <- base::grepl
[10:20:09.632]                           restarts <- computeRestarts(cond)
[10:20:09.632]                           for (restart in restarts) {
[10:20:09.632]                             name <- restart$name
[10:20:09.632]                             if (is.null(name)) 
[10:20:09.632]                               next
[10:20:09.632]                             if (!grepl(pattern, name)) 
[10:20:09.632]                               next
[10:20:09.632]                             invokeRestart(restart)
[10:20:09.632]                             muffled <- TRUE
[10:20:09.632]                             break
[10:20:09.632]                           }
[10:20:09.632]                         }
[10:20:09.632]                       }
[10:20:09.632]                       invisible(muffled)
[10:20:09.632]                     }
[10:20:09.632]                     muffleCondition(cond, pattern = "^muffle")
[10:20:09.632]                   }
[10:20:09.632]                 }
[10:20:09.632]             }
[10:20:09.632]         }))
[10:20:09.632]     }, error = function(ex) {
[10:20:09.632]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:09.632]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:09.632]                 ...future.rng), started = ...future.startTime, 
[10:20:09.632]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:09.632]             version = "1.8"), class = "FutureResult")
[10:20:09.632]     }, finally = {
[10:20:09.632]         if (!identical(...future.workdir, getwd())) 
[10:20:09.632]             setwd(...future.workdir)
[10:20:09.632]         {
[10:20:09.632]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:09.632]                 ...future.oldOptions$nwarnings <- NULL
[10:20:09.632]             }
[10:20:09.632]             base::options(...future.oldOptions)
[10:20:09.632]             if (.Platform$OS.type == "windows") {
[10:20:09.632]                 old_names <- names(...future.oldEnvVars)
[10:20:09.632]                 envs <- base::Sys.getenv()
[10:20:09.632]                 names <- names(envs)
[10:20:09.632]                 common <- intersect(names, old_names)
[10:20:09.632]                 added <- setdiff(names, old_names)
[10:20:09.632]                 removed <- setdiff(old_names, names)
[10:20:09.632]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:09.632]                   envs[common]]
[10:20:09.632]                 NAMES <- toupper(changed)
[10:20:09.632]                 args <- list()
[10:20:09.632]                 for (kk in seq_along(NAMES)) {
[10:20:09.632]                   name <- changed[[kk]]
[10:20:09.632]                   NAME <- NAMES[[kk]]
[10:20:09.632]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:09.632]                     next
[10:20:09.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:09.632]                 }
[10:20:09.632]                 NAMES <- toupper(added)
[10:20:09.632]                 for (kk in seq_along(NAMES)) {
[10:20:09.632]                   name <- added[[kk]]
[10:20:09.632]                   NAME <- NAMES[[kk]]
[10:20:09.632]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:09.632]                     next
[10:20:09.632]                   args[[name]] <- ""
[10:20:09.632]                 }
[10:20:09.632]                 NAMES <- toupper(removed)
[10:20:09.632]                 for (kk in seq_along(NAMES)) {
[10:20:09.632]                   name <- removed[[kk]]
[10:20:09.632]                   NAME <- NAMES[[kk]]
[10:20:09.632]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:09.632]                     next
[10:20:09.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:09.632]                 }
[10:20:09.632]                 if (length(args) > 0) 
[10:20:09.632]                   base::do.call(base::Sys.setenv, args = args)
[10:20:09.632]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:09.632]             }
[10:20:09.632]             else {
[10:20:09.632]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:09.632]             }
[10:20:09.632]             {
[10:20:09.632]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:09.632]                   0L) {
[10:20:09.632]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:09.632]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:09.632]                   base::options(opts)
[10:20:09.632]                 }
[10:20:09.632]                 {
[10:20:09.632]                   {
[10:20:09.632]                     NULL
[10:20:09.632]                     RNGkind("Mersenne-Twister")
[10:20:09.632]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:09.632]                       inherits = FALSE)
[10:20:09.632]                   }
[10:20:09.632]                   options(future.plan = NULL)
[10:20:09.632]                   if (is.na(NA_character_)) 
[10:20:09.632]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:09.632]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:09.632]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:09.632]                     .init = FALSE)
[10:20:09.632]                 }
[10:20:09.632]             }
[10:20:09.632]         }
[10:20:09.632]     })
[10:20:09.632]     if (TRUE) {
[10:20:09.632]         base::sink(type = "output", split = FALSE)
[10:20:09.632]         if (FALSE) {
[10:20:09.632]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:09.632]         }
[10:20:09.632]         else {
[10:20:09.632]             ...future.result["stdout"] <- base::list(NULL)
[10:20:09.632]         }
[10:20:09.632]         base::close(...future.stdout)
[10:20:09.632]         ...future.stdout <- NULL
[10:20:09.632]     }
[10:20:09.632]     ...future.result$conditions <- ...future.conditions
[10:20:09.632]     ...future.result$finished <- base::Sys.time()
[10:20:09.632]     ...future.result
[10:20:09.632] }
[10:20:09.634] assign_globals() ...
[10:20:09.634] List of 5
[10:20:09.634]  $ ...future.FUN            :function (x, y)  
[10:20:09.634]  $ MoreArgs                 : NULL
[10:20:09.634]  $ ...future.elements_ii    :List of 2
[10:20:09.634]   ..$ :List of 2
[10:20:09.634]   .. ..$ : int 1
[10:20:09.634]   .. ..$ : int 0
[10:20:09.634]   ..$ :List of 2
[10:20:09.634]   .. ..$ : int 0
[10:20:09.634]   .. ..$ : int 1
[10:20:09.634]  $ ...future.seeds_ii       : NULL
[10:20:09.634]  $ ...future.globals.maxSize: NULL
[10:20:09.634]  - attr(*, "where")=List of 5
[10:20:09.634]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:09.634]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:20:09.634]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:09.634]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:09.634]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:09.634]  - attr(*, "resolved")= logi FALSE
[10:20:09.634]  - attr(*, "total_size")= num 1242
[10:20:09.634]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:09.634]  - attr(*, "already-done")= logi TRUE
[10:20:09.640] - reassign environment for ‘...future.FUN’
[10:20:09.640] - copied ‘...future.FUN’ to environment
[10:20:09.640] - copied ‘MoreArgs’ to environment
[10:20:09.640] - copied ‘...future.elements_ii’ to environment
[10:20:09.641] - copied ‘...future.seeds_ii’ to environment
[10:20:09.641] - copied ‘...future.globals.maxSize’ to environment
[10:20:09.641] assign_globals() ... done
[10:20:09.641] plan(): Setting new future strategy stack:
[10:20:09.641] List of future strategies:
[10:20:09.641] 1. sequential:
[10:20:09.641]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:09.641]    - tweaked: FALSE
[10:20:09.641]    - call: NULL
[10:20:09.641] plan(): nbrOfWorkers() = 1
[10:20:10.143] plan(): Setting new future strategy stack:
[10:20:10.143] List of future strategies:
[10:20:10.143] 1. multicore:
[10:20:10.143]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:20:10.143]    - tweaked: FALSE
[10:20:10.143]    - call: plan(strategy)
[10:20:10.145] plan(): nbrOfWorkers() = 1
[10:20:10.145] SequentialFuture started (and completed)
[10:20:10.145] - Launch lazy future ... done
[10:20:10.146] run() for ‘SequentialFuture’ ... done
[10:20:10.146] Created future:
[10:20:10.146] SequentialFuture:
[10:20:10.146] Label: ‘future_mapply-1’
[10:20:10.146] Expression:
[10:20:10.146] {
[10:20:10.146]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:10.146]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:10.146]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:10.146]         on.exit(options(oopts), add = TRUE)
[10:20:10.146]     }
[10:20:10.146]     {
[10:20:10.146]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:10.146]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:20:10.146]         do.call(mapply, args = args)
[10:20:10.146]     }
[10:20:10.146] }
[10:20:10.146] Lazy evaluation: FALSE
[10:20:10.146] Asynchronous evaluation: FALSE
[10:20:10.146] Local evaluation: TRUE
[10:20:10.146] Environment: R_GlobalEnv
[10:20:10.146] Capture standard output: FALSE
[10:20:10.146] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:10.146] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:10.146] Packages: <none>
[10:20:10.146] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:10.146] Resolved: TRUE
[10:20:10.146] Value: 184 bytes of class ‘list’
[10:20:10.146] Early signaling: FALSE
[10:20:10.146] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:10.146] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:10.147] Chunk #1 of 1 ... DONE
[10:20:10.147] Launching 1 futures (chunks) ... DONE
[10:20:10.147] Resolving 1 futures (chunks) ...
[10:20:10.147] resolve() on list ...
[10:20:10.147]  recursive: 0
[10:20:10.147]  length: 1
[10:20:10.147] 
[10:20:10.147] resolved() for ‘SequentialFuture’ ...
[10:20:10.147] - state: ‘finished’
[10:20:10.147] - run: TRUE
[10:20:10.148] - result: ‘FutureResult’
[10:20:10.148] resolved() for ‘SequentialFuture’ ... done
[10:20:10.148] Future #1
[10:20:10.148] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:20:10.148] - nx: 1
[10:20:10.148] - relay: TRUE
[10:20:10.148] - stdout: TRUE
[10:20:10.148] - signal: TRUE
[10:20:10.148] - resignal: FALSE
[10:20:10.148] - force: TRUE
[10:20:10.148] - relayed: [n=1] FALSE
[10:20:10.149] - queued futures: [n=1] FALSE
[10:20:10.149]  - until=1
[10:20:10.149]  - relaying element #1
[10:20:10.149] - relayed: [n=1] TRUE
[10:20:10.149] - queued futures: [n=1] TRUE
[10:20:10.149] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:20:10.149]  length: 0 (resolved future 1)
[10:20:10.149] Relaying remaining futures
[10:20:10.149] signalConditionsASAP(NULL, pos=0) ...
[10:20:10.149] - nx: 1
[10:20:10.149] - relay: TRUE
[10:20:10.149] - stdout: TRUE
[10:20:10.150] - signal: TRUE
[10:20:10.150] - resignal: FALSE
[10:20:10.150] - force: TRUE
[10:20:10.150] - relayed: [n=1] TRUE
[10:20:10.150] - queued futures: [n=1] TRUE
 - flush all
[10:20:10.150] - relayed: [n=1] TRUE
[10:20:10.150] - queued futures: [n=1] TRUE
[10:20:10.150] signalConditionsASAP(NULL, pos=0) ... done
[10:20:10.150] resolve() on list ... DONE
[10:20:10.150]  - Number of value chunks collected: 1
[10:20:10.150] Resolving 1 futures (chunks) ... DONE
[10:20:10.151] Reducing values from 1 chunks ...
[10:20:10.151]  - Number of values collected after concatenation: 2
[10:20:10.151]  - Number of values expected: 2
[10:20:10.151] Reducing values from 1 chunks ... DONE
[10:20:10.151] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[10:20:10.151] future_mapply() ...
[10:20:10.153] Number of chunks: 1
[10:20:10.153] getGlobalsAndPackagesXApply() ...
[10:20:10.153]  - future.globals: TRUE
[10:20:10.154] getGlobalsAndPackages() ...
[10:20:10.154] Searching for globals...
[10:20:10.156] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:20:10.156] Searching for globals ... DONE
[10:20:10.156] Resolving globals: FALSE
[10:20:10.156] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[10:20:10.157] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[10:20:10.157] - globals: [1] ‘FUN’
[10:20:10.157] 
[10:20:10.157] getGlobalsAndPackages() ... DONE
[10:20:10.157]  - globals found/used: [n=1] ‘FUN’
[10:20:10.157]  - needed namespaces: [n=0] 
[10:20:10.157] Finding globals ... DONE
[10:20:10.157] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:20:10.157] List of 2
[10:20:10.157]  $ ...future.FUN:function (x, y)  
[10:20:10.157]  $ MoreArgs     : NULL
[10:20:10.157]  - attr(*, "where")=List of 2
[10:20:10.157]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:10.157]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:20:10.157]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:10.157]  - attr(*, "resolved")= logi FALSE
[10:20:10.157]  - attr(*, "total_size")= num NA
[10:20:10.160] Packages to be attached in all futures: [n=0] 
[10:20:10.160] getGlobalsAndPackagesXApply() ... DONE
[10:20:10.160] Number of futures (= number of chunks): 1
[10:20:10.160] Launching 1 futures (chunks) ...
[10:20:10.161] Chunk #1 of 1 ...
[10:20:10.161]  - Finding globals in '...' for chunk #1 ...
[10:20:10.161] getGlobalsAndPackages() ...
[10:20:10.161] Searching for globals...
[10:20:10.161] 
[10:20:10.161] Searching for globals ... DONE
[10:20:10.161] - globals: [0] <none>
[10:20:10.161] getGlobalsAndPackages() ... DONE
[10:20:10.161]    + additional globals found: [n=0] 
[10:20:10.162]    + additional namespaces needed: [n=0] 
[10:20:10.162]  - Finding globals in '...' for chunk #1 ... DONE
[10:20:10.162]  - seeds: <none>
[10:20:10.162]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:10.162] getGlobalsAndPackages() ...
[10:20:10.162] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:10.162] Resolving globals: FALSE
[10:20:10.164] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[10:20:10.165] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:20:10.165] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:10.165] 
[10:20:10.165] getGlobalsAndPackages() ... DONE
[10:20:10.165] run() for ‘Future’ ...
[10:20:10.165] - state: ‘created’
[10:20:10.165] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:20:10.167] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:10.167] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:10.167]   - Field: ‘label’
[10:20:10.167]   - Field: ‘local’
[10:20:10.167]   - Field: ‘owner’
[10:20:10.167]   - Field: ‘envir’
[10:20:10.168]   - Field: ‘packages’
[10:20:10.168]   - Field: ‘gc’
[10:20:10.168]   - Field: ‘conditions’
[10:20:10.168]   - Field: ‘expr’
[10:20:10.168]   - Field: ‘uuid’
[10:20:10.168]   - Field: ‘seed’
[10:20:10.168]   - Field: ‘version’
[10:20:10.168]   - Field: ‘result’
[10:20:10.168]   - Field: ‘asynchronous’
[10:20:10.168]   - Field: ‘calls’
[10:20:10.168]   - Field: ‘globals’
[10:20:10.168]   - Field: ‘stdout’
[10:20:10.169]   - Field: ‘earlySignal’
[10:20:10.169]   - Field: ‘lazy’
[10:20:10.169]   - Field: ‘state’
[10:20:10.169] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:10.169] - Launch lazy future ...
[10:20:10.169] Packages needed by the future expression (n = 0): <none>
[10:20:10.169] Packages needed by future strategies (n = 0): <none>
[10:20:10.170] {
[10:20:10.170]     {
[10:20:10.170]         {
[10:20:10.170]             ...future.startTime <- base::Sys.time()
[10:20:10.170]             {
[10:20:10.170]                 {
[10:20:10.170]                   {
[10:20:10.170]                     base::local({
[10:20:10.170]                       has_future <- base::requireNamespace("future", 
[10:20:10.170]                         quietly = TRUE)
[10:20:10.170]                       if (has_future) {
[10:20:10.170]                         ns <- base::getNamespace("future")
[10:20:10.170]                         version <- ns[[".package"]][["version"]]
[10:20:10.170]                         if (is.null(version)) 
[10:20:10.170]                           version <- utils::packageVersion("future")
[10:20:10.170]                       }
[10:20:10.170]                       else {
[10:20:10.170]                         version <- NULL
[10:20:10.170]                       }
[10:20:10.170]                       if (!has_future || version < "1.8.0") {
[10:20:10.170]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:10.170]                           "", base::R.version$version.string), 
[10:20:10.170]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:10.170]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:10.170]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:10.170]                             "release", "version")], collapse = " "), 
[10:20:10.170]                           hostname = base::Sys.info()[["nodename"]])
[10:20:10.170]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:10.170]                           info)
[10:20:10.170]                         info <- base::paste(info, collapse = "; ")
[10:20:10.170]                         if (!has_future) {
[10:20:10.170]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:10.170]                             info)
[10:20:10.170]                         }
[10:20:10.170]                         else {
[10:20:10.170]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:10.170]                             info, version)
[10:20:10.170]                         }
[10:20:10.170]                         base::stop(msg)
[10:20:10.170]                       }
[10:20:10.170]                     })
[10:20:10.170]                   }
[10:20:10.170]                   ...future.strategy.old <- future::plan("list")
[10:20:10.170]                   options(future.plan = NULL)
[10:20:10.170]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:10.170]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:10.170]                 }
[10:20:10.170]                 ...future.workdir <- getwd()
[10:20:10.170]             }
[10:20:10.170]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:10.170]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:10.170]         }
[10:20:10.170]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:10.170]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:10.170]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:10.170]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:10.170]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:10.170]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:10.170]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:10.170]             base::names(...future.oldOptions))
[10:20:10.170]     }
[10:20:10.170]     if (FALSE) {
[10:20:10.170]     }
[10:20:10.170]     else {
[10:20:10.170]         if (TRUE) {
[10:20:10.170]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:10.170]                 open = "w")
[10:20:10.170]         }
[10:20:10.170]         else {
[10:20:10.170]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:10.170]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:10.170]         }
[10:20:10.170]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:10.170]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:10.170]             base::sink(type = "output", split = FALSE)
[10:20:10.170]             base::close(...future.stdout)
[10:20:10.170]         }, add = TRUE)
[10:20:10.170]     }
[10:20:10.170]     ...future.frame <- base::sys.nframe()
[10:20:10.170]     ...future.conditions <- base::list()
[10:20:10.170]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:10.170]     if (FALSE) {
[10:20:10.170]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:10.170]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:10.170]     }
[10:20:10.170]     ...future.result <- base::tryCatch({
[10:20:10.170]         base::withCallingHandlers({
[10:20:10.170]             ...future.value <- base::withVisible(base::local({
[10:20:10.170]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:10.170]                 if (!identical(...future.globals.maxSize.org, 
[10:20:10.170]                   ...future.globals.maxSize)) {
[10:20:10.170]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:10.170]                   on.exit(options(oopts), add = TRUE)
[10:20:10.170]                 }
[10:20:10.170]                 {
[10:20:10.170]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:10.170]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:20:10.170]                     USE.NAMES = FALSE)
[10:20:10.170]                   do.call(mapply, args = args)
[10:20:10.170]                 }
[10:20:10.170]             }))
[10:20:10.170]             future::FutureResult(value = ...future.value$value, 
[10:20:10.170]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:10.170]                   ...future.rng), globalenv = if (FALSE) 
[10:20:10.170]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:10.170]                     ...future.globalenv.names))
[10:20:10.170]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:10.170]         }, condition = base::local({
[10:20:10.170]             c <- base::c
[10:20:10.170]             inherits <- base::inherits
[10:20:10.170]             invokeRestart <- base::invokeRestart
[10:20:10.170]             length <- base::length
[10:20:10.170]             list <- base::list
[10:20:10.170]             seq.int <- base::seq.int
[10:20:10.170]             signalCondition <- base::signalCondition
[10:20:10.170]             sys.calls <- base::sys.calls
[10:20:10.170]             `[[` <- base::`[[`
[10:20:10.170]             `+` <- base::`+`
[10:20:10.170]             `<<-` <- base::`<<-`
[10:20:10.170]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:10.170]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:10.170]                   3L)]
[10:20:10.170]             }
[10:20:10.170]             function(cond) {
[10:20:10.170]                 is_error <- inherits(cond, "error")
[10:20:10.170]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:10.170]                   NULL)
[10:20:10.170]                 if (is_error) {
[10:20:10.170]                   sessionInformation <- function() {
[10:20:10.170]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:10.170]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:10.170]                       search = base::search(), system = base::Sys.info())
[10:20:10.170]                   }
[10:20:10.170]                   ...future.conditions[[length(...future.conditions) + 
[10:20:10.170]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:10.170]                     cond$call), session = sessionInformation(), 
[10:20:10.170]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:10.170]                   signalCondition(cond)
[10:20:10.170]                 }
[10:20:10.170]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:10.170]                 "immediateCondition"))) {
[10:20:10.170]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:10.170]                   ...future.conditions[[length(...future.conditions) + 
[10:20:10.170]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:10.170]                   if (TRUE && !signal) {
[10:20:10.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:10.170]                     {
[10:20:10.170]                       inherits <- base::inherits
[10:20:10.170]                       invokeRestart <- base::invokeRestart
[10:20:10.170]                       is.null <- base::is.null
[10:20:10.170]                       muffled <- FALSE
[10:20:10.170]                       if (inherits(cond, "message")) {
[10:20:10.170]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:10.170]                         if (muffled) 
[10:20:10.170]                           invokeRestart("muffleMessage")
[10:20:10.170]                       }
[10:20:10.170]                       else if (inherits(cond, "warning")) {
[10:20:10.170]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:10.170]                         if (muffled) 
[10:20:10.170]                           invokeRestart("muffleWarning")
[10:20:10.170]                       }
[10:20:10.170]                       else if (inherits(cond, "condition")) {
[10:20:10.170]                         if (!is.null(pattern)) {
[10:20:10.170]                           computeRestarts <- base::computeRestarts
[10:20:10.170]                           grepl <- base::grepl
[10:20:10.170]                           restarts <- computeRestarts(cond)
[10:20:10.170]                           for (restart in restarts) {
[10:20:10.170]                             name <- restart$name
[10:20:10.170]                             if (is.null(name)) 
[10:20:10.170]                               next
[10:20:10.170]                             if (!grepl(pattern, name)) 
[10:20:10.170]                               next
[10:20:10.170]                             invokeRestart(restart)
[10:20:10.170]                             muffled <- TRUE
[10:20:10.170]                             break
[10:20:10.170]                           }
[10:20:10.170]                         }
[10:20:10.170]                       }
[10:20:10.170]                       invisible(muffled)
[10:20:10.170]                     }
[10:20:10.170]                     muffleCondition(cond, pattern = "^muffle")
[10:20:10.170]                   }
[10:20:10.170]                 }
[10:20:10.170]                 else {
[10:20:10.170]                   if (TRUE) {
[10:20:10.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:10.170]                     {
[10:20:10.170]                       inherits <- base::inherits
[10:20:10.170]                       invokeRestart <- base::invokeRestart
[10:20:10.170]                       is.null <- base::is.null
[10:20:10.170]                       muffled <- FALSE
[10:20:10.170]                       if (inherits(cond, "message")) {
[10:20:10.170]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:10.170]                         if (muffled) 
[10:20:10.170]                           invokeRestart("muffleMessage")
[10:20:10.170]                       }
[10:20:10.170]                       else if (inherits(cond, "warning")) {
[10:20:10.170]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:10.170]                         if (muffled) 
[10:20:10.170]                           invokeRestart("muffleWarning")
[10:20:10.170]                       }
[10:20:10.170]                       else if (inherits(cond, "condition")) {
[10:20:10.170]                         if (!is.null(pattern)) {
[10:20:10.170]                           computeRestarts <- base::computeRestarts
[10:20:10.170]                           grepl <- base::grepl
[10:20:10.170]                           restarts <- computeRestarts(cond)
[10:20:10.170]                           for (restart in restarts) {
[10:20:10.170]                             name <- restart$name
[10:20:10.170]                             if (is.null(name)) 
[10:20:10.170]                               next
[10:20:10.170]                             if (!grepl(pattern, name)) 
[10:20:10.170]                               next
[10:20:10.170]                             invokeRestart(restart)
[10:20:10.170]                             muffled <- TRUE
[10:20:10.170]                             break
[10:20:10.170]                           }
[10:20:10.170]                         }
[10:20:10.170]                       }
[10:20:10.170]                       invisible(muffled)
[10:20:10.170]                     }
[10:20:10.170]                     muffleCondition(cond, pattern = "^muffle")
[10:20:10.170]                   }
[10:20:10.170]                 }
[10:20:10.170]             }
[10:20:10.170]         }))
[10:20:10.170]     }, error = function(ex) {
[10:20:10.170]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:10.170]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:10.170]                 ...future.rng), started = ...future.startTime, 
[10:20:10.170]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:10.170]             version = "1.8"), class = "FutureResult")
[10:20:10.170]     }, finally = {
[10:20:10.170]         if (!identical(...future.workdir, getwd())) 
[10:20:10.170]             setwd(...future.workdir)
[10:20:10.170]         {
[10:20:10.170]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:10.170]                 ...future.oldOptions$nwarnings <- NULL
[10:20:10.170]             }
[10:20:10.170]             base::options(...future.oldOptions)
[10:20:10.170]             if (.Platform$OS.type == "windows") {
[10:20:10.170]                 old_names <- names(...future.oldEnvVars)
[10:20:10.170]                 envs <- base::Sys.getenv()
[10:20:10.170]                 names <- names(envs)
[10:20:10.170]                 common <- intersect(names, old_names)
[10:20:10.170]                 added <- setdiff(names, old_names)
[10:20:10.170]                 removed <- setdiff(old_names, names)
[10:20:10.170]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:10.170]                   envs[common]]
[10:20:10.170]                 NAMES <- toupper(changed)
[10:20:10.170]                 args <- list()
[10:20:10.170]                 for (kk in seq_along(NAMES)) {
[10:20:10.170]                   name <- changed[[kk]]
[10:20:10.170]                   NAME <- NAMES[[kk]]
[10:20:10.170]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:10.170]                     next
[10:20:10.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:10.170]                 }
[10:20:10.170]                 NAMES <- toupper(added)
[10:20:10.170]                 for (kk in seq_along(NAMES)) {
[10:20:10.170]                   name <- added[[kk]]
[10:20:10.170]                   NAME <- NAMES[[kk]]
[10:20:10.170]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:10.170]                     next
[10:20:10.170]                   args[[name]] <- ""
[10:20:10.170]                 }
[10:20:10.170]                 NAMES <- toupper(removed)
[10:20:10.170]                 for (kk in seq_along(NAMES)) {
[10:20:10.170]                   name <- removed[[kk]]
[10:20:10.170]                   NAME <- NAMES[[kk]]
[10:20:10.170]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:10.170]                     next
[10:20:10.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:10.170]                 }
[10:20:10.170]                 if (length(args) > 0) 
[10:20:10.170]                   base::do.call(base::Sys.setenv, args = args)
[10:20:10.170]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:10.170]             }
[10:20:10.170]             else {
[10:20:10.170]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:10.170]             }
[10:20:10.170]             {
[10:20:10.170]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:10.170]                   0L) {
[10:20:10.170]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:10.170]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:10.170]                   base::options(opts)
[10:20:10.170]                 }
[10:20:10.170]                 {
[10:20:10.170]                   {
[10:20:10.170]                     NULL
[10:20:10.170]                     RNGkind("Mersenne-Twister")
[10:20:10.170]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:10.170]                       inherits = FALSE)
[10:20:10.170]                   }
[10:20:10.170]                   options(future.plan = NULL)
[10:20:10.170]                   if (is.na(NA_character_)) 
[10:20:10.170]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:10.170]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:10.170]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:10.170]                     .init = FALSE)
[10:20:10.170]                 }
[10:20:10.170]             }
[10:20:10.170]         }
[10:20:10.170]     })
[10:20:10.170]     if (TRUE) {
[10:20:10.170]         base::sink(type = "output", split = FALSE)
[10:20:10.170]         if (TRUE) {
[10:20:10.170]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:10.170]         }
[10:20:10.170]         else {
[10:20:10.170]             ...future.result["stdout"] <- base::list(NULL)
[10:20:10.170]         }
[10:20:10.170]         base::close(...future.stdout)
[10:20:10.170]         ...future.stdout <- NULL
[10:20:10.170]     }
[10:20:10.170]     ...future.result$conditions <- ...future.conditions
[10:20:10.170]     ...future.result$finished <- base::Sys.time()
[10:20:10.170]     ...future.result
[10:20:10.170] }
[10:20:10.171] assign_globals() ...
[10:20:10.171] List of 5
[10:20:10.171]  $ ...future.FUN            :function (x, y)  
[10:20:10.171]  $ MoreArgs                 : NULL
[10:20:10.171]  $ ...future.elements_ii    :List of 2
[10:20:10.171]   ..$ :List of 2
[10:20:10.171]   .. ..$ : int 1
[10:20:10.171]   .. ..$ : int 0
[10:20:10.171]   ..$ :List of 2
[10:20:10.171]   .. ..$ : int 0
[10:20:10.171]   .. ..$ : int 1
[10:20:10.171]  $ ...future.seeds_ii       : NULL
[10:20:10.171]  $ ...future.globals.maxSize: NULL
[10:20:10.171]  - attr(*, "where")=List of 5
[10:20:10.171]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:10.171]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:20:10.171]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:10.171]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:10.171]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:10.171]  - attr(*, "resolved")= logi FALSE
[10:20:10.171]  - attr(*, "total_size")= num 1242
[10:20:10.171]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:10.171]  - attr(*, "already-done")= logi TRUE
[10:20:10.177] - reassign environment for ‘...future.FUN’
[10:20:10.177] - copied ‘...future.FUN’ to environment
[10:20:10.177] - copied ‘MoreArgs’ to environment
[10:20:10.177] - copied ‘...future.elements_ii’ to environment
[10:20:10.177] - copied ‘...future.seeds_ii’ to environment
[10:20:10.177] - copied ‘...future.globals.maxSize’ to environment
[10:20:10.177] assign_globals() ... done
[10:20:10.177] plan(): Setting new future strategy stack:
[10:20:10.178] List of future strategies:
[10:20:10.178] 1. sequential:
[10:20:10.178]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:10.178]    - tweaked: FALSE
[10:20:10.178]    - call: NULL
[10:20:10.178] plan(): nbrOfWorkers() = 1
[10:20:10.680] plan(): Setting new future strategy stack:
[10:20:10.680] List of future strategies:
[10:20:10.680] 1. multicore:
[10:20:10.680]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:20:10.680]    - tweaked: FALSE
[10:20:10.680]    - call: plan(strategy)
[10:20:10.682] plan(): nbrOfWorkers() = 1
[10:20:10.682] SequentialFuture started (and completed)
[10:20:10.682] - Launch lazy future ... done
[10:20:10.682] run() for ‘SequentialFuture’ ... done
[10:20:10.682] Created future:
[10:20:10.682] SequentialFuture:
[10:20:10.682] Label: ‘future_mapply-1’
[10:20:10.682] Expression:
[10:20:10.682] {
[10:20:10.682]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:10.682]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:10.682]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:10.682]         on.exit(options(oopts), add = TRUE)
[10:20:10.682]     }
[10:20:10.682]     {
[10:20:10.682]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:10.682]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:20:10.682]         do.call(mapply, args = args)
[10:20:10.682]     }
[10:20:10.682] }
[10:20:10.682] Lazy evaluation: FALSE
[10:20:10.682] Asynchronous evaluation: FALSE
[10:20:10.682] Local evaluation: TRUE
[10:20:10.682] Environment: R_GlobalEnv
[10:20:10.682] Capture standard output: TRUE
[10:20:10.682] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:10.682] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:10.682] Packages: <none>
[10:20:10.682] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:10.682] Resolved: TRUE
[10:20:10.682] Value: 184 bytes of class ‘list’
[10:20:10.682] Early signaling: FALSE
[10:20:10.682] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:10.682] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:10.683] Chunk #1 of 1 ... DONE
[10:20:10.683] Launching 1 futures (chunks) ... DONE
[10:20:10.683] Resolving 1 futures (chunks) ...
[10:20:10.684] resolve() on list ...
[10:20:10.684]  recursive: 0
[10:20:10.684]  length: 1
[10:20:10.684] 
[10:20:10.684] resolved() for ‘SequentialFuture’ ...
[10:20:10.684] - state: ‘finished’
[10:20:10.684] - run: TRUE
[10:20:10.684] - result: ‘FutureResult’
[10:20:10.684] resolved() for ‘SequentialFuture’ ... done
[10:20:10.684] Future #1
[10:20:10.684] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:20:10.685] - nx: 1
[10:20:10.685] - relay: TRUE
[10:20:10.685] - stdout: TRUE
[10:20:10.685] - signal: TRUE
[10:20:10.685] - resignal: FALSE
[10:20:10.685] - force: TRUE
[10:20:10.685] - relayed: [n=1] FALSE
[10:20:10.685] - queued futures: [n=1] FALSE
[10:20:10.685]  - until=1
[10:20:10.685]  - relaying element #1
[10:20:10.686] - relayed: [n=1] TRUE
[10:20:10.686] - queued futures: [n=1] TRUE
[10:20:10.686] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:20:10.686]  length: 0 (resolved future 1)
[10:20:10.686] Relaying remaining futures
[10:20:10.686] signalConditionsASAP(NULL, pos=0) ...
[10:20:10.686] - nx: 1
[10:20:10.686] - relay: TRUE
[10:20:10.686] - stdout: TRUE
[10:20:10.686] - signal: TRUE
[10:20:10.686] - resignal: FALSE
[10:20:10.686] - force: TRUE
[10:20:10.686] - relayed: [n=1] TRUE
[10:20:10.687] - queued futures: [n=1] TRUE
 - flush all
[10:20:10.687] - relayed: [n=1] TRUE
[10:20:10.687] - queued futures: [n=1] TRUE
[10:20:10.687] signalConditionsASAP(NULL, pos=0) ... done
[10:20:10.687] resolve() on list ... DONE
[10:20:10.687]  - Number of value chunks collected: 1
[10:20:10.687] Resolving 1 futures (chunks) ... DONE
[10:20:10.687] Reducing values from 1 chunks ...
[10:20:10.687]  - Number of values collected after concatenation: 2
[10:20:10.687]  - Number of values expected: 2
[10:20:10.688] Reducing values from 1 chunks ... DONE
[10:20:10.688] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[10:20:10.688] future_mapply() ...
[10:20:10.691] Number of chunks: 1
[10:20:10.691] getGlobalsAndPackagesXApply() ...
[10:20:10.691]  - future.globals: TRUE
[10:20:10.692] getGlobalsAndPackages() ...
[10:20:10.692] Searching for globals...
[10:20:10.693] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:20:10.693] Searching for globals ... DONE
[10:20:10.693] Resolving globals: FALSE
[10:20:10.694] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[10:20:10.694] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[10:20:10.694] - globals: [1] ‘FUN’
[10:20:10.694] 
[10:20:10.694] getGlobalsAndPackages() ... DONE
[10:20:10.694]  - globals found/used: [n=1] ‘FUN’
[10:20:10.695]  - needed namespaces: [n=0] 
[10:20:10.695] Finding globals ... DONE
[10:20:10.695] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:20:10.695] List of 2
[10:20:10.695]  $ ...future.FUN:function (x, y)  
[10:20:10.695]  $ MoreArgs     : NULL
[10:20:10.695]  - attr(*, "where")=List of 2
[10:20:10.695]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:10.695]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:20:10.695]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:10.695]  - attr(*, "resolved")= logi FALSE
[10:20:10.695]  - attr(*, "total_size")= num NA
[10:20:10.697] Packages to be attached in all futures: [n=0] 
[10:20:10.697] getGlobalsAndPackagesXApply() ... DONE
[10:20:10.698] Number of futures (= number of chunks): 1
[10:20:10.698] Launching 1 futures (chunks) ...
[10:20:10.698] Chunk #1 of 1 ...
[10:20:10.698]  - Finding globals in '...' for chunk #1 ...
[10:20:10.698] getGlobalsAndPackages() ...
[10:20:10.698] Searching for globals...
[10:20:10.698] 
[10:20:10.698] Searching for globals ... DONE
[10:20:10.699] - globals: [0] <none>
[10:20:10.699] getGlobalsAndPackages() ... DONE
[10:20:10.699]    + additional globals found: [n=0] 
[10:20:10.699]    + additional namespaces needed: [n=0] 
[10:20:10.699]  - Finding globals in '...' for chunk #1 ... DONE
[10:20:10.699]  - seeds: <none>
[10:20:10.699]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:10.699] getGlobalsAndPackages() ...
[10:20:10.699] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:10.699] Resolving globals: FALSE
[10:20:10.700] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[10:20:10.700] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:20:10.700] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:10.700] 
[10:20:10.700] getGlobalsAndPackages() ... DONE
[10:20:10.701] run() for ‘Future’ ...
[10:20:10.701] - state: ‘created’
[10:20:10.701] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:20:10.702] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:10.703] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:10.703]   - Field: ‘label’
[10:20:10.703]   - Field: ‘local’
[10:20:10.703]   - Field: ‘owner’
[10:20:10.703]   - Field: ‘envir’
[10:20:10.703]   - Field: ‘packages’
[10:20:10.703]   - Field: ‘gc’
[10:20:10.703]   - Field: ‘conditions’
[10:20:10.703]   - Field: ‘expr’
[10:20:10.703]   - Field: ‘uuid’
[10:20:10.703]   - Field: ‘seed’
[10:20:10.703]   - Field: ‘version’
[10:20:10.704]   - Field: ‘result’
[10:20:10.704]   - Field: ‘asynchronous’
[10:20:10.704]   - Field: ‘calls’
[10:20:10.704]   - Field: ‘globals’
[10:20:10.704]   - Field: ‘stdout’
[10:20:10.704]   - Field: ‘earlySignal’
[10:20:10.704]   - Field: ‘lazy’
[10:20:10.704]   - Field: ‘state’
[10:20:10.704] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:10.704] - Launch lazy future ...
[10:20:10.705] Packages needed by the future expression (n = 0): <none>
[10:20:10.705] Packages needed by future strategies (n = 0): <none>
[10:20:10.705] {
[10:20:10.705]     {
[10:20:10.705]         {
[10:20:10.705]             ...future.startTime <- base::Sys.time()
[10:20:10.705]             {
[10:20:10.705]                 {
[10:20:10.705]                   {
[10:20:10.705]                     base::local({
[10:20:10.705]                       has_future <- base::requireNamespace("future", 
[10:20:10.705]                         quietly = TRUE)
[10:20:10.705]                       if (has_future) {
[10:20:10.705]                         ns <- base::getNamespace("future")
[10:20:10.705]                         version <- ns[[".package"]][["version"]]
[10:20:10.705]                         if (is.null(version)) 
[10:20:10.705]                           version <- utils::packageVersion("future")
[10:20:10.705]                       }
[10:20:10.705]                       else {
[10:20:10.705]                         version <- NULL
[10:20:10.705]                       }
[10:20:10.705]                       if (!has_future || version < "1.8.0") {
[10:20:10.705]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:10.705]                           "", base::R.version$version.string), 
[10:20:10.705]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:10.705]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:10.705]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:10.705]                             "release", "version")], collapse = " "), 
[10:20:10.705]                           hostname = base::Sys.info()[["nodename"]])
[10:20:10.705]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:10.705]                           info)
[10:20:10.705]                         info <- base::paste(info, collapse = "; ")
[10:20:10.705]                         if (!has_future) {
[10:20:10.705]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:10.705]                             info)
[10:20:10.705]                         }
[10:20:10.705]                         else {
[10:20:10.705]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:10.705]                             info, version)
[10:20:10.705]                         }
[10:20:10.705]                         base::stop(msg)
[10:20:10.705]                       }
[10:20:10.705]                     })
[10:20:10.705]                   }
[10:20:10.705]                   ...future.strategy.old <- future::plan("list")
[10:20:10.705]                   options(future.plan = NULL)
[10:20:10.705]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:10.705]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:10.705]                 }
[10:20:10.705]                 ...future.workdir <- getwd()
[10:20:10.705]             }
[10:20:10.705]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:10.705]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:10.705]         }
[10:20:10.705]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:10.705]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:10.705]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:10.705]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:10.705]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:10.705]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:10.705]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:10.705]             base::names(...future.oldOptions))
[10:20:10.705]     }
[10:20:10.705]     if (TRUE) {
[10:20:10.705]     }
[10:20:10.705]     else {
[10:20:10.705]         if (NA) {
[10:20:10.705]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:10.705]                 open = "w")
[10:20:10.705]         }
[10:20:10.705]         else {
[10:20:10.705]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:10.705]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:10.705]         }
[10:20:10.705]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:10.705]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:10.705]             base::sink(type = "output", split = FALSE)
[10:20:10.705]             base::close(...future.stdout)
[10:20:10.705]         }, add = TRUE)
[10:20:10.705]     }
[10:20:10.705]     ...future.frame <- base::sys.nframe()
[10:20:10.705]     ...future.conditions <- base::list()
[10:20:10.705]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:10.705]     if (FALSE) {
[10:20:10.705]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:10.705]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:10.705]     }
[10:20:10.705]     ...future.result <- base::tryCatch({
[10:20:10.705]         base::withCallingHandlers({
[10:20:10.705]             ...future.value <- base::withVisible(base::local({
[10:20:10.705]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:10.705]                 if (!identical(...future.globals.maxSize.org, 
[10:20:10.705]                   ...future.globals.maxSize)) {
[10:20:10.705]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:10.705]                   on.exit(options(oopts), add = TRUE)
[10:20:10.705]                 }
[10:20:10.705]                 {
[10:20:10.705]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:10.705]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:20:10.705]                     USE.NAMES = FALSE)
[10:20:10.705]                   do.call(mapply, args = args)
[10:20:10.705]                 }
[10:20:10.705]             }))
[10:20:10.705]             future::FutureResult(value = ...future.value$value, 
[10:20:10.705]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:10.705]                   ...future.rng), globalenv = if (FALSE) 
[10:20:10.705]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:10.705]                     ...future.globalenv.names))
[10:20:10.705]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:10.705]         }, condition = base::local({
[10:20:10.705]             c <- base::c
[10:20:10.705]             inherits <- base::inherits
[10:20:10.705]             invokeRestart <- base::invokeRestart
[10:20:10.705]             length <- base::length
[10:20:10.705]             list <- base::list
[10:20:10.705]             seq.int <- base::seq.int
[10:20:10.705]             signalCondition <- base::signalCondition
[10:20:10.705]             sys.calls <- base::sys.calls
[10:20:10.705]             `[[` <- base::`[[`
[10:20:10.705]             `+` <- base::`+`
[10:20:10.705]             `<<-` <- base::`<<-`
[10:20:10.705]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:10.705]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:10.705]                   3L)]
[10:20:10.705]             }
[10:20:10.705]             function(cond) {
[10:20:10.705]                 is_error <- inherits(cond, "error")
[10:20:10.705]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:10.705]                   NULL)
[10:20:10.705]                 if (is_error) {
[10:20:10.705]                   sessionInformation <- function() {
[10:20:10.705]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:10.705]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:10.705]                       search = base::search(), system = base::Sys.info())
[10:20:10.705]                   }
[10:20:10.705]                   ...future.conditions[[length(...future.conditions) + 
[10:20:10.705]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:10.705]                     cond$call), session = sessionInformation(), 
[10:20:10.705]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:10.705]                   signalCondition(cond)
[10:20:10.705]                 }
[10:20:10.705]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:10.705]                 "immediateCondition"))) {
[10:20:10.705]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:10.705]                   ...future.conditions[[length(...future.conditions) + 
[10:20:10.705]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:10.705]                   if (TRUE && !signal) {
[10:20:10.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:10.705]                     {
[10:20:10.705]                       inherits <- base::inherits
[10:20:10.705]                       invokeRestart <- base::invokeRestart
[10:20:10.705]                       is.null <- base::is.null
[10:20:10.705]                       muffled <- FALSE
[10:20:10.705]                       if (inherits(cond, "message")) {
[10:20:10.705]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:10.705]                         if (muffled) 
[10:20:10.705]                           invokeRestart("muffleMessage")
[10:20:10.705]                       }
[10:20:10.705]                       else if (inherits(cond, "warning")) {
[10:20:10.705]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:10.705]                         if (muffled) 
[10:20:10.705]                           invokeRestart("muffleWarning")
[10:20:10.705]                       }
[10:20:10.705]                       else if (inherits(cond, "condition")) {
[10:20:10.705]                         if (!is.null(pattern)) {
[10:20:10.705]                           computeRestarts <- base::computeRestarts
[10:20:10.705]                           grepl <- base::grepl
[10:20:10.705]                           restarts <- computeRestarts(cond)
[10:20:10.705]                           for (restart in restarts) {
[10:20:10.705]                             name <- restart$name
[10:20:10.705]                             if (is.null(name)) 
[10:20:10.705]                               next
[10:20:10.705]                             if (!grepl(pattern, name)) 
[10:20:10.705]                               next
[10:20:10.705]                             invokeRestart(restart)
[10:20:10.705]                             muffled <- TRUE
[10:20:10.705]                             break
[10:20:10.705]                           }
[10:20:10.705]                         }
[10:20:10.705]                       }
[10:20:10.705]                       invisible(muffled)
[10:20:10.705]                     }
[10:20:10.705]                     muffleCondition(cond, pattern = "^muffle")
[10:20:10.705]                   }
[10:20:10.705]                 }
[10:20:10.705]                 else {
[10:20:10.705]                   if (TRUE) {
[10:20:10.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:10.705]                     {
[10:20:10.705]                       inherits <- base::inherits
[10:20:10.705]                       invokeRestart <- base::invokeRestart
[10:20:10.705]                       is.null <- base::is.null
[10:20:10.705]                       muffled <- FALSE
[10:20:10.705]                       if (inherits(cond, "message")) {
[10:20:10.705]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:10.705]                         if (muffled) 
[10:20:10.705]                           invokeRestart("muffleMessage")
[10:20:10.705]                       }
[10:20:10.705]                       else if (inherits(cond, "warning")) {
[10:20:10.705]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:10.705]                         if (muffled) 
[10:20:10.705]                           invokeRestart("muffleWarning")
[10:20:10.705]                       }
[10:20:10.705]                       else if (inherits(cond, "condition")) {
[10:20:10.705]                         if (!is.null(pattern)) {
[10:20:10.705]                           computeRestarts <- base::computeRestarts
[10:20:10.705]                           grepl <- base::grepl
[10:20:10.705]                           restarts <- computeRestarts(cond)
[10:20:10.705]                           for (restart in restarts) {
[10:20:10.705]                             name <- restart$name
[10:20:10.705]                             if (is.null(name)) 
[10:20:10.705]                               next
[10:20:10.705]                             if (!grepl(pattern, name)) 
[10:20:10.705]                               next
[10:20:10.705]                             invokeRestart(restart)
[10:20:10.705]                             muffled <- TRUE
[10:20:10.705]                             break
[10:20:10.705]                           }
[10:20:10.705]                         }
[10:20:10.705]                       }
[10:20:10.705]                       invisible(muffled)
[10:20:10.705]                     }
[10:20:10.705]                     muffleCondition(cond, pattern = "^muffle")
[10:20:10.705]                   }
[10:20:10.705]                 }
[10:20:10.705]             }
[10:20:10.705]         }))
[10:20:10.705]     }, error = function(ex) {
[10:20:10.705]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:10.705]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:10.705]                 ...future.rng), started = ...future.startTime, 
[10:20:10.705]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:10.705]             version = "1.8"), class = "FutureResult")
[10:20:10.705]     }, finally = {
[10:20:10.705]         if (!identical(...future.workdir, getwd())) 
[10:20:10.705]             setwd(...future.workdir)
[10:20:10.705]         {
[10:20:10.705]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:10.705]                 ...future.oldOptions$nwarnings <- NULL
[10:20:10.705]             }
[10:20:10.705]             base::options(...future.oldOptions)
[10:20:10.705]             if (.Platform$OS.type == "windows") {
[10:20:10.705]                 old_names <- names(...future.oldEnvVars)
[10:20:10.705]                 envs <- base::Sys.getenv()
[10:20:10.705]                 names <- names(envs)
[10:20:10.705]                 common <- intersect(names, old_names)
[10:20:10.705]                 added <- setdiff(names, old_names)
[10:20:10.705]                 removed <- setdiff(old_names, names)
[10:20:10.705]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:10.705]                   envs[common]]
[10:20:10.705]                 NAMES <- toupper(changed)
[10:20:10.705]                 args <- list()
[10:20:10.705]                 for (kk in seq_along(NAMES)) {
[10:20:10.705]                   name <- changed[[kk]]
[10:20:10.705]                   NAME <- NAMES[[kk]]
[10:20:10.705]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:10.705]                     next
[10:20:10.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:10.705]                 }
[10:20:10.705]                 NAMES <- toupper(added)
[10:20:10.705]                 for (kk in seq_along(NAMES)) {
[10:20:10.705]                   name <- added[[kk]]
[10:20:10.705]                   NAME <- NAMES[[kk]]
[10:20:10.705]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:10.705]                     next
[10:20:10.705]                   args[[name]] <- ""
[10:20:10.705]                 }
[10:20:10.705]                 NAMES <- toupper(removed)
[10:20:10.705]                 for (kk in seq_along(NAMES)) {
[10:20:10.705]                   name <- removed[[kk]]
[10:20:10.705]                   NAME <- NAMES[[kk]]
[10:20:10.705]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:10.705]                     next
[10:20:10.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:10.705]                 }
[10:20:10.705]                 if (length(args) > 0) 
[10:20:10.705]                   base::do.call(base::Sys.setenv, args = args)
[10:20:10.705]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:10.705]             }
[10:20:10.705]             else {
[10:20:10.705]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:10.705]             }
[10:20:10.705]             {
[10:20:10.705]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:10.705]                   0L) {
[10:20:10.705]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:10.705]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:10.705]                   base::options(opts)
[10:20:10.705]                 }
[10:20:10.705]                 {
[10:20:10.705]                   {
[10:20:10.705]                     NULL
[10:20:10.705]                     RNGkind("Mersenne-Twister")
[10:20:10.705]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:10.705]                       inherits = FALSE)
[10:20:10.705]                   }
[10:20:10.705]                   options(future.plan = NULL)
[10:20:10.705]                   if (is.na(NA_character_)) 
[10:20:10.705]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:10.705]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:10.705]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:10.705]                     .init = FALSE)
[10:20:10.705]                 }
[10:20:10.705]             }
[10:20:10.705]         }
[10:20:10.705]     })
[10:20:10.705]     if (FALSE) {
[10:20:10.705]         base::sink(type = "output", split = FALSE)
[10:20:10.705]         if (NA) {
[10:20:10.705]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:10.705]         }
[10:20:10.705]         else {
[10:20:10.705]             ...future.result["stdout"] <- base::list(NULL)
[10:20:10.705]         }
[10:20:10.705]         base::close(...future.stdout)
[10:20:10.705]         ...future.stdout <- NULL
[10:20:10.705]     }
[10:20:10.705]     ...future.result$conditions <- ...future.conditions
[10:20:10.705]     ...future.result$finished <- base::Sys.time()
[10:20:10.705]     ...future.result
[10:20:10.705] }
[10:20:10.707] assign_globals() ...
[10:20:10.707] List of 5
[10:20:10.707]  $ ...future.FUN            :function (x, y)  
[10:20:10.707]  $ MoreArgs                 : NULL
[10:20:10.707]  $ ...future.elements_ii    :List of 2
[10:20:10.707]   ..$ :List of 2
[10:20:10.707]   .. ..$ : int 1
[10:20:10.707]   .. ..$ : int 0
[10:20:10.707]   ..$ :List of 2
[10:20:10.707]   .. ..$ : int 0
[10:20:10.707]   .. ..$ : int 1
[10:20:10.707]  $ ...future.seeds_ii       : NULL
[10:20:10.707]  $ ...future.globals.maxSize: NULL
[10:20:10.707]  - attr(*, "where")=List of 5
[10:20:10.707]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:10.707]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:20:10.707]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:10.707]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:10.707]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:10.707]  - attr(*, "resolved")= logi FALSE
[10:20:10.707]  - attr(*, "total_size")= num 1242
[10:20:10.707]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:10.707]  - attr(*, "already-done")= logi TRUE
[10:20:10.712] - reassign environment for ‘...future.FUN’
[10:20:10.712] - copied ‘...future.FUN’ to environment
[10:20:10.712] - copied ‘MoreArgs’ to environment
[10:20:10.712] - copied ‘...future.elements_ii’ to environment
[10:20:10.714] - copied ‘...future.seeds_ii’ to environment
[10:20:10.714] - copied ‘...future.globals.maxSize’ to environment
[10:20:10.714] assign_globals() ... done
[10:20:10.714] plan(): Setting new future strategy stack:
[10:20:10.714] List of future strategies:
[10:20:10.714] 1. sequential:
[10:20:10.714]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:10.714]    - tweaked: FALSE
[10:20:10.714]    - call: NULL
[10:20:10.715] plan(): nbrOfWorkers() = 1
[10:20:11.216] plan(): Setting new future strategy stack:
[10:20:11.217] List of future strategies:
[10:20:11.217] 1. multicore:
[10:20:11.217]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:20:11.217]    - tweaked: FALSE
[10:20:11.217]    - call: plan(strategy)
[10:20:11.218] plan(): nbrOfWorkers() = 1
[10:20:11.219] SequentialFuture started (and completed)
[10:20:11.219] - Launch lazy future ... done
[10:20:11.219] run() for ‘SequentialFuture’ ... done
[10:20:11.219] Created future:
[10:20:11.219] SequentialFuture:
[10:20:11.219] Label: ‘future_mapply-1’
[10:20:11.219] Expression:
[10:20:11.219] {
[10:20:11.219]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:11.219]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:11.219]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:11.219]         on.exit(options(oopts), add = TRUE)
[10:20:11.219]     }
[10:20:11.219]     {
[10:20:11.219]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:11.219]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:20:11.219]         do.call(mapply, args = args)
[10:20:11.219]     }
[10:20:11.219] }
[10:20:11.219] Lazy evaluation: FALSE
[10:20:11.219] Asynchronous evaluation: FALSE
[10:20:11.219] Local evaluation: TRUE
[10:20:11.219] Environment: R_GlobalEnv
[10:20:11.219] Capture standard output: NA
[10:20:11.219] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:11.219] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:11.219] Packages: <none>
[10:20:11.219] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:11.219] Resolved: TRUE
[10:20:11.219] Value: 184 bytes of class ‘list’
[10:20:11.219] Early signaling: FALSE
[10:20:11.219] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:11.219] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:11.220] Chunk #1 of 1 ... DONE
[10:20:11.220] Launching 1 futures (chunks) ... DONE
[10:20:11.220] Resolving 1 futures (chunks) ...
[10:20:11.220] resolve() on list ...
[10:20:11.220]  recursive: 0
[10:20:11.221]  length: 1
[10:20:11.221] 
[10:20:11.221] resolved() for ‘SequentialFuture’ ...
[10:20:11.221] - state: ‘finished’
[10:20:11.221] - run: TRUE
[10:20:11.221] - result: ‘FutureResult’
[10:20:11.221] resolved() for ‘SequentialFuture’ ... done
[10:20:11.221] Future #1
[10:20:11.221] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:20:11.221] - nx: 1
[10:20:11.221] - relay: TRUE
[10:20:11.222] - stdout: TRUE
[10:20:11.222] - signal: TRUE
[10:20:11.222] - resignal: FALSE
[10:20:11.222] - force: TRUE
[10:20:11.222] - relayed: [n=1] FALSE
[10:20:11.222] - queued futures: [n=1] FALSE
[10:20:11.222]  - until=1
[10:20:11.222]  - relaying element #1
[10:20:11.222] - relayed: [n=1] TRUE
[10:20:11.222] - queued futures: [n=1] TRUE
[10:20:11.222] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:20:11.223]  length: 0 (resolved future 1)
[10:20:11.223] Relaying remaining futures
[10:20:11.223] signalConditionsASAP(NULL, pos=0) ...
[10:20:11.223] - nx: 1
[10:20:11.223] - relay: TRUE
[10:20:11.223] - stdout: TRUE
[10:20:11.223] - signal: TRUE
[10:20:11.223] - resignal: FALSE
[10:20:11.223] - force: TRUE
[10:20:11.223] - relayed: [n=1] TRUE
[10:20:11.223] - queued futures: [n=1] TRUE
 - flush all
[10:20:11.223] - relayed: [n=1] TRUE
[10:20:11.223] - queued futures: [n=1] TRUE
[10:20:11.224] signalConditionsASAP(NULL, pos=0) ... done
[10:20:11.224] resolve() on list ... DONE
[10:20:11.224]  - Number of value chunks collected: 1
[10:20:11.224] Resolving 1 futures (chunks) ... DONE
[10:20:11.224] Reducing values from 1 chunks ...
[10:20:11.224]  - Number of values collected after concatenation: 2
[10:20:11.224]  - Number of values expected: 2
[10:20:11.224] Reducing values from 1 chunks ... DONE
[10:20:11.224] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[10:20:11.225] plan(): Setting new future strategy stack:
[10:20:11.225] List of future strategies:
[10:20:11.225] 1. multisession:
[10:20:11.225]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:20:11.225]    - tweaked: FALSE
[10:20:11.225]    - call: plan(strategy)
[10:20:11.225] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:20:11.225] multisession:
[10:20:11.225] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:20:11.225] - tweaked: FALSE
[10:20:11.225] - call: plan(strategy)
[10:20:11.227] getGlobalsAndPackages() ...
[10:20:11.227] Not searching for globals
[10:20:11.227] - globals: [0] <none>
[10:20:11.227] getGlobalsAndPackages() ... DONE
[10:20:11.228] Packages needed by the future expression (n = 0): <none>
[10:20:11.228] Packages needed by future strategies (n = 0): <none>
[10:20:11.228] {
[10:20:11.228]     {
[10:20:11.228]         {
[10:20:11.228]             ...future.startTime <- base::Sys.time()
[10:20:11.228]             {
[10:20:11.228]                 {
[10:20:11.228]                   {
[10:20:11.228]                     base::local({
[10:20:11.228]                       has_future <- base::requireNamespace("future", 
[10:20:11.228]                         quietly = TRUE)
[10:20:11.228]                       if (has_future) {
[10:20:11.228]                         ns <- base::getNamespace("future")
[10:20:11.228]                         version <- ns[[".package"]][["version"]]
[10:20:11.228]                         if (is.null(version)) 
[10:20:11.228]                           version <- utils::packageVersion("future")
[10:20:11.228]                       }
[10:20:11.228]                       else {
[10:20:11.228]                         version <- NULL
[10:20:11.228]                       }
[10:20:11.228]                       if (!has_future || version < "1.8.0") {
[10:20:11.228]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:11.228]                           "", base::R.version$version.string), 
[10:20:11.228]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:11.228]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:11.228]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:11.228]                             "release", "version")], collapse = " "), 
[10:20:11.228]                           hostname = base::Sys.info()[["nodename"]])
[10:20:11.228]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:11.228]                           info)
[10:20:11.228]                         info <- base::paste(info, collapse = "; ")
[10:20:11.228]                         if (!has_future) {
[10:20:11.228]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:11.228]                             info)
[10:20:11.228]                         }
[10:20:11.228]                         else {
[10:20:11.228]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:11.228]                             info, version)
[10:20:11.228]                         }
[10:20:11.228]                         base::stop(msg)
[10:20:11.228]                       }
[10:20:11.228]                     })
[10:20:11.228]                   }
[10:20:11.228]                   ...future.strategy.old <- future::plan("list")
[10:20:11.228]                   options(future.plan = NULL)
[10:20:11.228]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:11.228]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:11.228]                 }
[10:20:11.228]                 ...future.workdir <- getwd()
[10:20:11.228]             }
[10:20:11.228]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:11.228]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:11.228]         }
[10:20:11.228]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:11.228]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:11.228]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:11.228]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:11.228]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:11.228]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:11.228]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:11.228]             base::names(...future.oldOptions))
[10:20:11.228]     }
[10:20:11.228]     if (FALSE) {
[10:20:11.228]     }
[10:20:11.228]     else {
[10:20:11.228]         if (TRUE) {
[10:20:11.228]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:11.228]                 open = "w")
[10:20:11.228]         }
[10:20:11.228]         else {
[10:20:11.228]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:11.228]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:11.228]         }
[10:20:11.228]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:11.228]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:11.228]             base::sink(type = "output", split = FALSE)
[10:20:11.228]             base::close(...future.stdout)
[10:20:11.228]         }, add = TRUE)
[10:20:11.228]     }
[10:20:11.228]     ...future.frame <- base::sys.nframe()
[10:20:11.228]     ...future.conditions <- base::list()
[10:20:11.228]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:11.228]     if (FALSE) {
[10:20:11.228]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:11.228]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:11.228]     }
[10:20:11.228]     ...future.result <- base::tryCatch({
[10:20:11.228]         base::withCallingHandlers({
[10:20:11.228]             ...future.value <- base::withVisible(base::local(NA))
[10:20:11.228]             future::FutureResult(value = ...future.value$value, 
[10:20:11.228]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:11.228]                   ...future.rng), globalenv = if (FALSE) 
[10:20:11.228]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:11.228]                     ...future.globalenv.names))
[10:20:11.228]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:11.228]         }, condition = base::local({
[10:20:11.228]             c <- base::c
[10:20:11.228]             inherits <- base::inherits
[10:20:11.228]             invokeRestart <- base::invokeRestart
[10:20:11.228]             length <- base::length
[10:20:11.228]             list <- base::list
[10:20:11.228]             seq.int <- base::seq.int
[10:20:11.228]             signalCondition <- base::signalCondition
[10:20:11.228]             sys.calls <- base::sys.calls
[10:20:11.228]             `[[` <- base::`[[`
[10:20:11.228]             `+` <- base::`+`
[10:20:11.228]             `<<-` <- base::`<<-`
[10:20:11.228]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:11.228]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:11.228]                   3L)]
[10:20:11.228]             }
[10:20:11.228]             function(cond) {
[10:20:11.228]                 is_error <- inherits(cond, "error")
[10:20:11.228]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:11.228]                   NULL)
[10:20:11.228]                 if (is_error) {
[10:20:11.228]                   sessionInformation <- function() {
[10:20:11.228]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:11.228]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:11.228]                       search = base::search(), system = base::Sys.info())
[10:20:11.228]                   }
[10:20:11.228]                   ...future.conditions[[length(...future.conditions) + 
[10:20:11.228]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:11.228]                     cond$call), session = sessionInformation(), 
[10:20:11.228]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:11.228]                   signalCondition(cond)
[10:20:11.228]                 }
[10:20:11.228]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:11.228]                 "immediateCondition"))) {
[10:20:11.228]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:11.228]                   ...future.conditions[[length(...future.conditions) + 
[10:20:11.228]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:11.228]                   if (TRUE && !signal) {
[10:20:11.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:11.228]                     {
[10:20:11.228]                       inherits <- base::inherits
[10:20:11.228]                       invokeRestart <- base::invokeRestart
[10:20:11.228]                       is.null <- base::is.null
[10:20:11.228]                       muffled <- FALSE
[10:20:11.228]                       if (inherits(cond, "message")) {
[10:20:11.228]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:11.228]                         if (muffled) 
[10:20:11.228]                           invokeRestart("muffleMessage")
[10:20:11.228]                       }
[10:20:11.228]                       else if (inherits(cond, "warning")) {
[10:20:11.228]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:11.228]                         if (muffled) 
[10:20:11.228]                           invokeRestart("muffleWarning")
[10:20:11.228]                       }
[10:20:11.228]                       else if (inherits(cond, "condition")) {
[10:20:11.228]                         if (!is.null(pattern)) {
[10:20:11.228]                           computeRestarts <- base::computeRestarts
[10:20:11.228]                           grepl <- base::grepl
[10:20:11.228]                           restarts <- computeRestarts(cond)
[10:20:11.228]                           for (restart in restarts) {
[10:20:11.228]                             name <- restart$name
[10:20:11.228]                             if (is.null(name)) 
[10:20:11.228]                               next
[10:20:11.228]                             if (!grepl(pattern, name)) 
[10:20:11.228]                               next
[10:20:11.228]                             invokeRestart(restart)
[10:20:11.228]                             muffled <- TRUE
[10:20:11.228]                             break
[10:20:11.228]                           }
[10:20:11.228]                         }
[10:20:11.228]                       }
[10:20:11.228]                       invisible(muffled)
[10:20:11.228]                     }
[10:20:11.228]                     muffleCondition(cond, pattern = "^muffle")
[10:20:11.228]                   }
[10:20:11.228]                 }
[10:20:11.228]                 else {
[10:20:11.228]                   if (TRUE) {
[10:20:11.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:11.228]                     {
[10:20:11.228]                       inherits <- base::inherits
[10:20:11.228]                       invokeRestart <- base::invokeRestart
[10:20:11.228]                       is.null <- base::is.null
[10:20:11.228]                       muffled <- FALSE
[10:20:11.228]                       if (inherits(cond, "message")) {
[10:20:11.228]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:11.228]                         if (muffled) 
[10:20:11.228]                           invokeRestart("muffleMessage")
[10:20:11.228]                       }
[10:20:11.228]                       else if (inherits(cond, "warning")) {
[10:20:11.228]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:11.228]                         if (muffled) 
[10:20:11.228]                           invokeRestart("muffleWarning")
[10:20:11.228]                       }
[10:20:11.228]                       else if (inherits(cond, "condition")) {
[10:20:11.228]                         if (!is.null(pattern)) {
[10:20:11.228]                           computeRestarts <- base::computeRestarts
[10:20:11.228]                           grepl <- base::grepl
[10:20:11.228]                           restarts <- computeRestarts(cond)
[10:20:11.228]                           for (restart in restarts) {
[10:20:11.228]                             name <- restart$name
[10:20:11.228]                             if (is.null(name)) 
[10:20:11.228]                               next
[10:20:11.228]                             if (!grepl(pattern, name)) 
[10:20:11.228]                               next
[10:20:11.228]                             invokeRestart(restart)
[10:20:11.228]                             muffled <- TRUE
[10:20:11.228]                             break
[10:20:11.228]                           }
[10:20:11.228]                         }
[10:20:11.228]                       }
[10:20:11.228]                       invisible(muffled)
[10:20:11.228]                     }
[10:20:11.228]                     muffleCondition(cond, pattern = "^muffle")
[10:20:11.228]                   }
[10:20:11.228]                 }
[10:20:11.228]             }
[10:20:11.228]         }))
[10:20:11.228]     }, error = function(ex) {
[10:20:11.228]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:11.228]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:11.228]                 ...future.rng), started = ...future.startTime, 
[10:20:11.228]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:11.228]             version = "1.8"), class = "FutureResult")
[10:20:11.228]     }, finally = {
[10:20:11.228]         if (!identical(...future.workdir, getwd())) 
[10:20:11.228]             setwd(...future.workdir)
[10:20:11.228]         {
[10:20:11.228]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:11.228]                 ...future.oldOptions$nwarnings <- NULL
[10:20:11.228]             }
[10:20:11.228]             base::options(...future.oldOptions)
[10:20:11.228]             if (.Platform$OS.type == "windows") {
[10:20:11.228]                 old_names <- names(...future.oldEnvVars)
[10:20:11.228]                 envs <- base::Sys.getenv()
[10:20:11.228]                 names <- names(envs)
[10:20:11.228]                 common <- intersect(names, old_names)
[10:20:11.228]                 added <- setdiff(names, old_names)
[10:20:11.228]                 removed <- setdiff(old_names, names)
[10:20:11.228]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:11.228]                   envs[common]]
[10:20:11.228]                 NAMES <- toupper(changed)
[10:20:11.228]                 args <- list()
[10:20:11.228]                 for (kk in seq_along(NAMES)) {
[10:20:11.228]                   name <- changed[[kk]]
[10:20:11.228]                   NAME <- NAMES[[kk]]
[10:20:11.228]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:11.228]                     next
[10:20:11.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:11.228]                 }
[10:20:11.228]                 NAMES <- toupper(added)
[10:20:11.228]                 for (kk in seq_along(NAMES)) {
[10:20:11.228]                   name <- added[[kk]]
[10:20:11.228]                   NAME <- NAMES[[kk]]
[10:20:11.228]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:11.228]                     next
[10:20:11.228]                   args[[name]] <- ""
[10:20:11.228]                 }
[10:20:11.228]                 NAMES <- toupper(removed)
[10:20:11.228]                 for (kk in seq_along(NAMES)) {
[10:20:11.228]                   name <- removed[[kk]]
[10:20:11.228]                   NAME <- NAMES[[kk]]
[10:20:11.228]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:11.228]                     next
[10:20:11.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:11.228]                 }
[10:20:11.228]                 if (length(args) > 0) 
[10:20:11.228]                   base::do.call(base::Sys.setenv, args = args)
[10:20:11.228]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:11.228]             }
[10:20:11.228]             else {
[10:20:11.228]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:11.228]             }
[10:20:11.228]             {
[10:20:11.228]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:11.228]                   0L) {
[10:20:11.228]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:11.228]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:11.228]                   base::options(opts)
[10:20:11.228]                 }
[10:20:11.228]                 {
[10:20:11.228]                   {
[10:20:11.228]                     NULL
[10:20:11.228]                     RNGkind("Mersenne-Twister")
[10:20:11.228]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:11.228]                       inherits = FALSE)
[10:20:11.228]                   }
[10:20:11.228]                   options(future.plan = NULL)
[10:20:11.228]                   if (is.na(NA_character_)) 
[10:20:11.228]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:11.228]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:11.228]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:11.228]                     .init = FALSE)
[10:20:11.228]                 }
[10:20:11.228]             }
[10:20:11.228]         }
[10:20:11.228]     })
[10:20:11.228]     if (TRUE) {
[10:20:11.228]         base::sink(type = "output", split = FALSE)
[10:20:11.228]         if (TRUE) {
[10:20:11.228]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:11.228]         }
[10:20:11.228]         else {
[10:20:11.228]             ...future.result["stdout"] <- base::list(NULL)
[10:20:11.228]         }
[10:20:11.228]         base::close(...future.stdout)
[10:20:11.228]         ...future.stdout <- NULL
[10:20:11.228]     }
[10:20:11.228]     ...future.result$conditions <- ...future.conditions
[10:20:11.228]     ...future.result$finished <- base::Sys.time()
[10:20:11.228]     ...future.result
[10:20:11.228] }
[10:20:11.230] plan(): Setting new future strategy stack:
[10:20:11.230] List of future strategies:
[10:20:11.230] 1. sequential:
[10:20:11.230]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:11.230]    - tweaked: FALSE
[10:20:11.230]    - call: NULL
[10:20:11.231] plan(): nbrOfWorkers() = 1
[10:20:11.231] plan(): Setting new future strategy stack:
[10:20:11.231] List of future strategies:
[10:20:11.231] 1. multisession:
[10:20:11.231]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:20:11.231]    - tweaked: FALSE
[10:20:11.231]    - call: plan(strategy)
[10:20:11.233] plan(): nbrOfWorkers() = 1
[10:20:11.233] SequentialFuture started (and completed)
[10:20:11.233] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:20:11.235] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[10:20:11.235] future_lapply() ...
[10:20:11.237] Number of chunks: 1
[10:20:11.237] getGlobalsAndPackagesXApply() ...
[10:20:11.237]  - future.globals: TRUE
[10:20:11.237] getGlobalsAndPackages() ...
[10:20:11.237] Searching for globals...
[10:20:11.238] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:20:11.238] Searching for globals ... DONE
[10:20:11.239] Resolving globals: FALSE
[10:20:11.239] The total size of the 1 globals is 841 bytes (841 bytes)
[10:20:11.239] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[10:20:11.239] - globals: [1] ‘FUN’
[10:20:11.239] 
[10:20:11.240] getGlobalsAndPackages() ... DONE
[10:20:11.240]  - globals found/used: [n=1] ‘FUN’
[10:20:11.240]  - needed namespaces: [n=0] 
[10:20:11.240] Finding globals ... DONE
[10:20:11.240]  - use_args: TRUE
[10:20:11.240]  - Getting '...' globals ...
[10:20:11.240] resolve() on list ...
[10:20:11.240]  recursive: 0
[10:20:11.240]  length: 1
[10:20:11.269]  elements: ‘...’
[10:20:11.269]  length: 0 (resolved future 1)
[10:20:11.269] resolve() on list ... DONE
[10:20:11.269]    - '...' content: [n=0] 
[10:20:11.270] List of 1
[10:20:11.270]  $ ...: list()
[10:20:11.270]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:11.270]  - attr(*, "where")=List of 1
[10:20:11.270]   ..$ ...:<environment: 0x557fc1f83380> 
[10:20:11.270]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:11.270]  - attr(*, "resolved")= logi TRUE
[10:20:11.270]  - attr(*, "total_size")= num NA
[10:20:11.273]  - Getting '...' globals ... DONE
[10:20:11.273] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:20:11.273] List of 2
[10:20:11.273]  $ ...future.FUN:function (x)  
[10:20:11.273]  $ ...          : list()
[10:20:11.273]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:11.273]  - attr(*, "where")=List of 2
[10:20:11.273]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:11.273]   ..$ ...          :<environment: 0x557fc1f83380> 
[10:20:11.273]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:11.273]  - attr(*, "resolved")= logi FALSE
[10:20:11.273]  - attr(*, "total_size")= num 5632
[10:20:11.275] Packages to be attached in all futures: [n=0] 
[10:20:11.275] getGlobalsAndPackagesXApply() ... DONE
[10:20:11.276] Number of futures (= number of chunks): 1
[10:20:11.276] Launching 1 futures (chunks) ...
[10:20:11.276] Chunk #1 of 1 ...
[10:20:11.276]  - Finding globals in 'X' for chunk #1 ...
[10:20:11.276] getGlobalsAndPackages() ...
[10:20:11.276] Searching for globals...
[10:20:11.276] 
[10:20:11.276] Searching for globals ... DONE
[10:20:11.277] - globals: [0] <none>
[10:20:11.277] getGlobalsAndPackages() ... DONE
[10:20:11.277]    + additional globals found: [n=0] 
[10:20:11.277]    + additional namespaces needed: [n=0] 
[10:20:11.277]  - Finding globals in 'X' for chunk #1 ... DONE
[10:20:11.277]  - seeds: <none>
[10:20:11.277]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:11.277] getGlobalsAndPackages() ...
[10:20:11.277] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:11.277] Resolving globals: FALSE
[10:20:11.277] Tweak future expression to call with '...' arguments ...
[10:20:11.278] {
[10:20:11.278]     do.call(function(...) {
[10:20:11.278]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:11.278]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:11.278]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:11.278]             on.exit(options(oopts), add = TRUE)
[10:20:11.278]         }
[10:20:11.278]         {
[10:20:11.278]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:11.278]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:11.278]                 ...future.FUN(...future.X_jj, ...)
[10:20:11.278]             })
[10:20:11.278]         }
[10:20:11.278]     }, args = future.call.arguments)
[10:20:11.278] }
[10:20:11.278] Tweak future expression to call with '...' arguments ... DONE
[10:20:11.278] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:11.278] 
[10:20:11.278] getGlobalsAndPackages() ... DONE
[10:20:11.279] run() for ‘Future’ ...
[10:20:11.279] - state: ‘created’
[10:20:11.279] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:20:11.280] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:11.281] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:11.281]   - Field: ‘label’
[10:20:11.281]   - Field: ‘local’
[10:20:11.281]   - Field: ‘owner’
[10:20:11.281]   - Field: ‘envir’
[10:20:11.281]   - Field: ‘packages’
[10:20:11.281]   - Field: ‘gc’
[10:20:11.281]   - Field: ‘conditions’
[10:20:11.281]   - Field: ‘expr’
[10:20:11.281]   - Field: ‘uuid’
[10:20:11.281]   - Field: ‘seed’
[10:20:11.282]   - Field: ‘version’
[10:20:11.282]   - Field: ‘result’
[10:20:11.282]   - Field: ‘asynchronous’
[10:20:11.282]   - Field: ‘calls’
[10:20:11.282]   - Field: ‘globals’
[10:20:11.282]   - Field: ‘stdout’
[10:20:11.282]   - Field: ‘earlySignal’
[10:20:11.282]   - Field: ‘lazy’
[10:20:11.282]   - Field: ‘state’
[10:20:11.282] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:11.282] - Launch lazy future ...
[10:20:11.283] Packages needed by the future expression (n = 0): <none>
[10:20:11.283] Packages needed by future strategies (n = 0): <none>
[10:20:11.283] {
[10:20:11.283]     {
[10:20:11.283]         {
[10:20:11.283]             ...future.startTime <- base::Sys.time()
[10:20:11.283]             {
[10:20:11.283]                 {
[10:20:11.283]                   {
[10:20:11.283]                     base::local({
[10:20:11.283]                       has_future <- base::requireNamespace("future", 
[10:20:11.283]                         quietly = TRUE)
[10:20:11.283]                       if (has_future) {
[10:20:11.283]                         ns <- base::getNamespace("future")
[10:20:11.283]                         version <- ns[[".package"]][["version"]]
[10:20:11.283]                         if (is.null(version)) 
[10:20:11.283]                           version <- utils::packageVersion("future")
[10:20:11.283]                       }
[10:20:11.283]                       else {
[10:20:11.283]                         version <- NULL
[10:20:11.283]                       }
[10:20:11.283]                       if (!has_future || version < "1.8.0") {
[10:20:11.283]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:11.283]                           "", base::R.version$version.string), 
[10:20:11.283]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:11.283]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:11.283]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:11.283]                             "release", "version")], collapse = " "), 
[10:20:11.283]                           hostname = base::Sys.info()[["nodename"]])
[10:20:11.283]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:11.283]                           info)
[10:20:11.283]                         info <- base::paste(info, collapse = "; ")
[10:20:11.283]                         if (!has_future) {
[10:20:11.283]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:11.283]                             info)
[10:20:11.283]                         }
[10:20:11.283]                         else {
[10:20:11.283]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:11.283]                             info, version)
[10:20:11.283]                         }
[10:20:11.283]                         base::stop(msg)
[10:20:11.283]                       }
[10:20:11.283]                     })
[10:20:11.283]                   }
[10:20:11.283]                   ...future.strategy.old <- future::plan("list")
[10:20:11.283]                   options(future.plan = NULL)
[10:20:11.283]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:11.283]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:11.283]                 }
[10:20:11.283]                 ...future.workdir <- getwd()
[10:20:11.283]             }
[10:20:11.283]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:11.283]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:11.283]         }
[10:20:11.283]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:11.283]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:11.283]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:11.283]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:11.283]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:11.283]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:11.283]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:11.283]             base::names(...future.oldOptions))
[10:20:11.283]     }
[10:20:11.283]     if (FALSE) {
[10:20:11.283]     }
[10:20:11.283]     else {
[10:20:11.283]         if (FALSE) {
[10:20:11.283]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:11.283]                 open = "w")
[10:20:11.283]         }
[10:20:11.283]         else {
[10:20:11.283]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:11.283]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:11.283]         }
[10:20:11.283]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:11.283]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:11.283]             base::sink(type = "output", split = FALSE)
[10:20:11.283]             base::close(...future.stdout)
[10:20:11.283]         }, add = TRUE)
[10:20:11.283]     }
[10:20:11.283]     ...future.frame <- base::sys.nframe()
[10:20:11.283]     ...future.conditions <- base::list()
[10:20:11.283]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:11.283]     if (FALSE) {
[10:20:11.283]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:11.283]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:11.283]     }
[10:20:11.283]     ...future.result <- base::tryCatch({
[10:20:11.283]         base::withCallingHandlers({
[10:20:11.283]             ...future.value <- base::withVisible(base::local({
[10:20:11.283]                 do.call(function(...) {
[10:20:11.283]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:11.283]                   if (!identical(...future.globals.maxSize.org, 
[10:20:11.283]                     ...future.globals.maxSize)) {
[10:20:11.283]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:11.283]                     on.exit(options(oopts), add = TRUE)
[10:20:11.283]                   }
[10:20:11.283]                   {
[10:20:11.283]                     lapply(seq_along(...future.elements_ii), 
[10:20:11.283]                       FUN = function(jj) {
[10:20:11.283]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:11.283]                         ...future.FUN(...future.X_jj, ...)
[10:20:11.283]                       })
[10:20:11.283]                   }
[10:20:11.283]                 }, args = future.call.arguments)
[10:20:11.283]             }))
[10:20:11.283]             future::FutureResult(value = ...future.value$value, 
[10:20:11.283]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:11.283]                   ...future.rng), globalenv = if (FALSE) 
[10:20:11.283]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:11.283]                     ...future.globalenv.names))
[10:20:11.283]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:11.283]         }, condition = base::local({
[10:20:11.283]             c <- base::c
[10:20:11.283]             inherits <- base::inherits
[10:20:11.283]             invokeRestart <- base::invokeRestart
[10:20:11.283]             length <- base::length
[10:20:11.283]             list <- base::list
[10:20:11.283]             seq.int <- base::seq.int
[10:20:11.283]             signalCondition <- base::signalCondition
[10:20:11.283]             sys.calls <- base::sys.calls
[10:20:11.283]             `[[` <- base::`[[`
[10:20:11.283]             `+` <- base::`+`
[10:20:11.283]             `<<-` <- base::`<<-`
[10:20:11.283]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:11.283]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:11.283]                   3L)]
[10:20:11.283]             }
[10:20:11.283]             function(cond) {
[10:20:11.283]                 is_error <- inherits(cond, "error")
[10:20:11.283]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:11.283]                   NULL)
[10:20:11.283]                 if (is_error) {
[10:20:11.283]                   sessionInformation <- function() {
[10:20:11.283]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:11.283]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:11.283]                       search = base::search(), system = base::Sys.info())
[10:20:11.283]                   }
[10:20:11.283]                   ...future.conditions[[length(...future.conditions) + 
[10:20:11.283]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:11.283]                     cond$call), session = sessionInformation(), 
[10:20:11.283]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:11.283]                   signalCondition(cond)
[10:20:11.283]                 }
[10:20:11.283]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:11.283]                 "immediateCondition"))) {
[10:20:11.283]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:11.283]                   ...future.conditions[[length(...future.conditions) + 
[10:20:11.283]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:11.283]                   if (TRUE && !signal) {
[10:20:11.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:11.283]                     {
[10:20:11.283]                       inherits <- base::inherits
[10:20:11.283]                       invokeRestart <- base::invokeRestart
[10:20:11.283]                       is.null <- base::is.null
[10:20:11.283]                       muffled <- FALSE
[10:20:11.283]                       if (inherits(cond, "message")) {
[10:20:11.283]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:11.283]                         if (muffled) 
[10:20:11.283]                           invokeRestart("muffleMessage")
[10:20:11.283]                       }
[10:20:11.283]                       else if (inherits(cond, "warning")) {
[10:20:11.283]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:11.283]                         if (muffled) 
[10:20:11.283]                           invokeRestart("muffleWarning")
[10:20:11.283]                       }
[10:20:11.283]                       else if (inherits(cond, "condition")) {
[10:20:11.283]                         if (!is.null(pattern)) {
[10:20:11.283]                           computeRestarts <- base::computeRestarts
[10:20:11.283]                           grepl <- base::grepl
[10:20:11.283]                           restarts <- computeRestarts(cond)
[10:20:11.283]                           for (restart in restarts) {
[10:20:11.283]                             name <- restart$name
[10:20:11.283]                             if (is.null(name)) 
[10:20:11.283]                               next
[10:20:11.283]                             if (!grepl(pattern, name)) 
[10:20:11.283]                               next
[10:20:11.283]                             invokeRestart(restart)
[10:20:11.283]                             muffled <- TRUE
[10:20:11.283]                             break
[10:20:11.283]                           }
[10:20:11.283]                         }
[10:20:11.283]                       }
[10:20:11.283]                       invisible(muffled)
[10:20:11.283]                     }
[10:20:11.283]                     muffleCondition(cond, pattern = "^muffle")
[10:20:11.283]                   }
[10:20:11.283]                 }
[10:20:11.283]                 else {
[10:20:11.283]                   if (TRUE) {
[10:20:11.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:11.283]                     {
[10:20:11.283]                       inherits <- base::inherits
[10:20:11.283]                       invokeRestart <- base::invokeRestart
[10:20:11.283]                       is.null <- base::is.null
[10:20:11.283]                       muffled <- FALSE
[10:20:11.283]                       if (inherits(cond, "message")) {
[10:20:11.283]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:11.283]                         if (muffled) 
[10:20:11.283]                           invokeRestart("muffleMessage")
[10:20:11.283]                       }
[10:20:11.283]                       else if (inherits(cond, "warning")) {
[10:20:11.283]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:11.283]                         if (muffled) 
[10:20:11.283]                           invokeRestart("muffleWarning")
[10:20:11.283]                       }
[10:20:11.283]                       else if (inherits(cond, "condition")) {
[10:20:11.283]                         if (!is.null(pattern)) {
[10:20:11.283]                           computeRestarts <- base::computeRestarts
[10:20:11.283]                           grepl <- base::grepl
[10:20:11.283]                           restarts <- computeRestarts(cond)
[10:20:11.283]                           for (restart in restarts) {
[10:20:11.283]                             name <- restart$name
[10:20:11.283]                             if (is.null(name)) 
[10:20:11.283]                               next
[10:20:11.283]                             if (!grepl(pattern, name)) 
[10:20:11.283]                               next
[10:20:11.283]                             invokeRestart(restart)
[10:20:11.283]                             muffled <- TRUE
[10:20:11.283]                             break
[10:20:11.283]                           }
[10:20:11.283]                         }
[10:20:11.283]                       }
[10:20:11.283]                       invisible(muffled)
[10:20:11.283]                     }
[10:20:11.283]                     muffleCondition(cond, pattern = "^muffle")
[10:20:11.283]                   }
[10:20:11.283]                 }
[10:20:11.283]             }
[10:20:11.283]         }))
[10:20:11.283]     }, error = function(ex) {
[10:20:11.283]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:11.283]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:11.283]                 ...future.rng), started = ...future.startTime, 
[10:20:11.283]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:11.283]             version = "1.8"), class = "FutureResult")
[10:20:11.283]     }, finally = {
[10:20:11.283]         if (!identical(...future.workdir, getwd())) 
[10:20:11.283]             setwd(...future.workdir)
[10:20:11.283]         {
[10:20:11.283]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:11.283]                 ...future.oldOptions$nwarnings <- NULL
[10:20:11.283]             }
[10:20:11.283]             base::options(...future.oldOptions)
[10:20:11.283]             if (.Platform$OS.type == "windows") {
[10:20:11.283]                 old_names <- names(...future.oldEnvVars)
[10:20:11.283]                 envs <- base::Sys.getenv()
[10:20:11.283]                 names <- names(envs)
[10:20:11.283]                 common <- intersect(names, old_names)
[10:20:11.283]                 added <- setdiff(names, old_names)
[10:20:11.283]                 removed <- setdiff(old_names, names)
[10:20:11.283]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:11.283]                   envs[common]]
[10:20:11.283]                 NAMES <- toupper(changed)
[10:20:11.283]                 args <- list()
[10:20:11.283]                 for (kk in seq_along(NAMES)) {
[10:20:11.283]                   name <- changed[[kk]]
[10:20:11.283]                   NAME <- NAMES[[kk]]
[10:20:11.283]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:11.283]                     next
[10:20:11.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:11.283]                 }
[10:20:11.283]                 NAMES <- toupper(added)
[10:20:11.283]                 for (kk in seq_along(NAMES)) {
[10:20:11.283]                   name <- added[[kk]]
[10:20:11.283]                   NAME <- NAMES[[kk]]
[10:20:11.283]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:11.283]                     next
[10:20:11.283]                   args[[name]] <- ""
[10:20:11.283]                 }
[10:20:11.283]                 NAMES <- toupper(removed)
[10:20:11.283]                 for (kk in seq_along(NAMES)) {
[10:20:11.283]                   name <- removed[[kk]]
[10:20:11.283]                   NAME <- NAMES[[kk]]
[10:20:11.283]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:11.283]                     next
[10:20:11.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:11.283]                 }
[10:20:11.283]                 if (length(args) > 0) 
[10:20:11.283]                   base::do.call(base::Sys.setenv, args = args)
[10:20:11.283]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:11.283]             }
[10:20:11.283]             else {
[10:20:11.283]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:11.283]             }
[10:20:11.283]             {
[10:20:11.283]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:11.283]                   0L) {
[10:20:11.283]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:11.283]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:11.283]                   base::options(opts)
[10:20:11.283]                 }
[10:20:11.283]                 {
[10:20:11.283]                   {
[10:20:11.283]                     NULL
[10:20:11.283]                     RNGkind("Mersenne-Twister")
[10:20:11.283]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:11.283]                       inherits = FALSE)
[10:20:11.283]                   }
[10:20:11.283]                   options(future.plan = NULL)
[10:20:11.283]                   if (is.na(NA_character_)) 
[10:20:11.283]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:11.283]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:11.283]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:11.283]                     .init = FALSE)
[10:20:11.283]                 }
[10:20:11.283]             }
[10:20:11.283]         }
[10:20:11.283]     })
[10:20:11.283]     if (TRUE) {
[10:20:11.283]         base::sink(type = "output", split = FALSE)
[10:20:11.283]         if (FALSE) {
[10:20:11.283]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:11.283]         }
[10:20:11.283]         else {
[10:20:11.283]             ...future.result["stdout"] <- base::list(NULL)
[10:20:11.283]         }
[10:20:11.283]         base::close(...future.stdout)
[10:20:11.283]         ...future.stdout <- NULL
[10:20:11.283]     }
[10:20:11.283]     ...future.result$conditions <- ...future.conditions
[10:20:11.283]     ...future.result$finished <- base::Sys.time()
[10:20:11.283]     ...future.result
[10:20:11.283] }
[10:20:11.285] assign_globals() ...
[10:20:11.285] List of 5
[10:20:11.285]  $ ...future.FUN            :function (x)  
[10:20:11.285]  $ future.call.arguments    : list()
[10:20:11.285]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:11.285]  $ ...future.elements_ii    :List of 2
[10:20:11.285]   ..$ : int 1
[10:20:11.285]   ..$ : int 0
[10:20:11.285]  $ ...future.seeds_ii       : NULL
[10:20:11.285]  $ ...future.globals.maxSize: NULL
[10:20:11.285]  - attr(*, "where")=List of 5
[10:20:11.285]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:11.285]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:20:11.285]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:11.285]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:11.285]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:11.285]  - attr(*, "resolved")= logi FALSE
[10:20:11.285]  - attr(*, "total_size")= num 5632
[10:20:11.285]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:11.285]  - attr(*, "already-done")= logi TRUE
[10:20:11.290] - reassign environment for ‘...future.FUN’
[10:20:11.290] - copied ‘...future.FUN’ to environment
[10:20:11.290] - copied ‘future.call.arguments’ to environment
[10:20:11.290] - copied ‘...future.elements_ii’ to environment
[10:20:11.290] - copied ‘...future.seeds_ii’ to environment
[10:20:11.290] - copied ‘...future.globals.maxSize’ to environment
[10:20:11.290] assign_globals() ... done
[10:20:11.290] plan(): Setting new future strategy stack:
[10:20:11.290] List of future strategies:
[10:20:11.290] 1. sequential:
[10:20:11.290]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:11.290]    - tweaked: FALSE
[10:20:11.290]    - call: NULL
[10:20:11.291] plan(): nbrOfWorkers() = 1
[10:20:11.793] plan(): Setting new future strategy stack:
[10:20:11.793] List of future strategies:
[10:20:11.793] 1. multisession:
[10:20:11.793]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:20:11.793]    - tweaked: FALSE
[10:20:11.793]    - call: plan(strategy)
[10:20:11.795] plan(): nbrOfWorkers() = 1
[10:20:11.795] SequentialFuture started (and completed)
[10:20:11.795] - Launch lazy future ... done
[10:20:11.795] run() for ‘SequentialFuture’ ... done
[10:20:11.795] Created future:
[10:20:11.795] SequentialFuture:
[10:20:11.795] Label: ‘future_lapply-1’
[10:20:11.795] Expression:
[10:20:11.795] {
[10:20:11.795]     do.call(function(...) {
[10:20:11.795]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:11.795]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:11.795]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:11.795]             on.exit(options(oopts), add = TRUE)
[10:20:11.795]         }
[10:20:11.795]         {
[10:20:11.795]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:11.795]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:11.795]                 ...future.FUN(...future.X_jj, ...)
[10:20:11.795]             })
[10:20:11.795]         }
[10:20:11.795]     }, args = future.call.arguments)
[10:20:11.795] }
[10:20:11.795] Lazy evaluation: FALSE
[10:20:11.795] Asynchronous evaluation: FALSE
[10:20:11.795] Local evaluation: TRUE
[10:20:11.795] Environment: R_GlobalEnv
[10:20:11.795] Capture standard output: FALSE
[10:20:11.795] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:11.795] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:11.795] Packages: <none>
[10:20:11.795] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:11.795] Resolved: TRUE
[10:20:11.795] Value: 55 bytes of class ‘list’
[10:20:11.795] Early signaling: FALSE
[10:20:11.795] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:11.795] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:11.796] Chunk #1 of 1 ... DONE
[10:20:11.796] Launching 1 futures (chunks) ... DONE
[10:20:11.796] Resolving 1 futures (chunks) ...
[10:20:11.797] resolve() on list ...
[10:20:11.797]  recursive: 0
[10:20:11.797]  length: 1
[10:20:11.797] 
[10:20:11.797] resolved() for ‘SequentialFuture’ ...
[10:20:11.797] - state: ‘finished’
[10:20:11.797] - run: TRUE
[10:20:11.797] - result: ‘FutureResult’
[10:20:11.797] resolved() for ‘SequentialFuture’ ... done
[10:20:11.797] Future #1
[10:20:11.797] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:20:11.798] - nx: 1
[10:20:11.799] - relay: TRUE
[10:20:11.799] - stdout: TRUE
[10:20:11.799] - signal: TRUE
[10:20:11.799] - resignal: FALSE
[10:20:11.799] - force: TRUE
[10:20:11.800] - relayed: [n=1] FALSE
[10:20:11.800] - queued futures: [n=1] FALSE
[10:20:11.800]  - until=1
[10:20:11.800]  - relaying element #1
[10:20:11.800] - relayed: [n=1] TRUE
[10:20:11.800] - queued futures: [n=1] TRUE
[10:20:11.800] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:20:11.800]  length: 0 (resolved future 1)
[10:20:11.801] Relaying remaining futures
[10:20:11.801] signalConditionsASAP(NULL, pos=0) ...
[10:20:11.801] - nx: 1
[10:20:11.801] - relay: TRUE
[10:20:11.801] - stdout: TRUE
[10:20:11.801] - signal: TRUE
[10:20:11.801] - resignal: FALSE
[10:20:11.801] - force: TRUE
[10:20:11.801] - relayed: [n=1] TRUE
[10:20:11.801] - queued futures: [n=1] TRUE
 - flush all
[10:20:11.802] - relayed: [n=1] TRUE
[10:20:11.802] - queued futures: [n=1] TRUE
[10:20:11.802] signalConditionsASAP(NULL, pos=0) ... done
[10:20:11.802] resolve() on list ... DONE
[10:20:11.802]  - Number of value chunks collected: 1
[10:20:11.802] Resolving 1 futures (chunks) ... DONE
[10:20:11.802] Reducing values from 1 chunks ...
[10:20:11.802]  - Number of values collected after concatenation: 2
[10:20:11.802]  - Number of values expected: 2
[10:20:11.802] Reducing values from 1 chunks ... DONE
[10:20:11.802] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[10:20:11.803] future_lapply() ...
[10:20:11.805] Number of chunks: 1
[10:20:11.805] getGlobalsAndPackagesXApply() ...
[10:20:11.805]  - future.globals: TRUE
[10:20:11.805] getGlobalsAndPackages() ...
[10:20:11.805] Searching for globals...
[10:20:11.806] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:20:11.806] Searching for globals ... DONE
[10:20:11.807] Resolving globals: FALSE
[10:20:11.807] The total size of the 1 globals is 841 bytes (841 bytes)
[10:20:11.807] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[10:20:11.807] - globals: [1] ‘FUN’
[10:20:11.807] 
[10:20:11.807] getGlobalsAndPackages() ... DONE
[10:20:11.808]  - globals found/used: [n=1] ‘FUN’
[10:20:11.808]  - needed namespaces: [n=0] 
[10:20:11.808] Finding globals ... DONE
[10:20:11.808]  - use_args: TRUE
[10:20:11.808]  - Getting '...' globals ...
[10:20:11.808] resolve() on list ...
[10:20:11.808]  recursive: 0
[10:20:11.808]  length: 1
[10:20:11.808]  elements: ‘...’
[10:20:11.809]  length: 0 (resolved future 1)
[10:20:11.809] resolve() on list ... DONE
[10:20:11.809]    - '...' content: [n=0] 
[10:20:11.809] List of 1
[10:20:11.809]  $ ...: list()
[10:20:11.809]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:11.809]  - attr(*, "where")=List of 1
[10:20:11.809]   ..$ ...:<environment: 0x557fc143c098> 
[10:20:11.809]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:11.809]  - attr(*, "resolved")= logi TRUE
[10:20:11.809]  - attr(*, "total_size")= num NA
[10:20:11.811]  - Getting '...' globals ... DONE
[10:20:11.811] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:20:11.811] List of 2
[10:20:11.811]  $ ...future.FUN:function (x)  
[10:20:11.811]  $ ...          : list()
[10:20:11.811]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:11.811]  - attr(*, "where")=List of 2
[10:20:11.811]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:11.811]   ..$ ...          :<environment: 0x557fc143c098> 
[10:20:11.811]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:11.811]  - attr(*, "resolved")= logi FALSE
[10:20:11.811]  - attr(*, "total_size")= num 5632
[10:20:11.814] Packages to be attached in all futures: [n=0] 
[10:20:11.814] getGlobalsAndPackagesXApply() ... DONE
[10:20:11.814] Number of futures (= number of chunks): 1
[10:20:11.814] Launching 1 futures (chunks) ...
[10:20:11.814] Chunk #1 of 1 ...
[10:20:11.815]  - Finding globals in 'X' for chunk #1 ...
[10:20:11.815] getGlobalsAndPackages() ...
[10:20:11.815] Searching for globals...
[10:20:11.815] 
[10:20:11.815] Searching for globals ... DONE
[10:20:11.815] - globals: [0] <none>
[10:20:11.815] getGlobalsAndPackages() ... DONE
[10:20:11.815]    + additional globals found: [n=0] 
[10:20:11.815]    + additional namespaces needed: [n=0] 
[10:20:11.815]  - Finding globals in 'X' for chunk #1 ... DONE
[10:20:11.816]  - seeds: <none>
[10:20:11.816]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:11.816] getGlobalsAndPackages() ...
[10:20:11.816] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:11.816] Resolving globals: FALSE
[10:20:11.816] Tweak future expression to call with '...' arguments ...
[10:20:11.816] {
[10:20:11.816]     do.call(function(...) {
[10:20:11.816]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:11.816]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:11.816]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:11.816]             on.exit(options(oopts), add = TRUE)
[10:20:11.816]         }
[10:20:11.816]         {
[10:20:11.816]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:11.816]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:11.816]                 ...future.FUN(...future.X_jj, ...)
[10:20:11.816]             })
[10:20:11.816]         }
[10:20:11.816]     }, args = future.call.arguments)
[10:20:11.816] }
[10:20:11.816] Tweak future expression to call with '...' arguments ... DONE
[10:20:11.817] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:11.817] 
[10:20:11.817] getGlobalsAndPackages() ... DONE
[10:20:11.817] run() for ‘Future’ ...
[10:20:11.817] - state: ‘created’
[10:20:11.817] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:20:11.819] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:11.819] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:11.819]   - Field: ‘label’
[10:20:11.819]   - Field: ‘local’
[10:20:11.819]   - Field: ‘owner’
[10:20:11.819]   - Field: ‘envir’
[10:20:11.819]   - Field: ‘packages’
[10:20:11.819]   - Field: ‘gc’
[10:20:11.820]   - Field: ‘conditions’
[10:20:11.820]   - Field: ‘expr’
[10:20:11.820]   - Field: ‘uuid’
[10:20:11.820]   - Field: ‘seed’
[10:20:11.820]   - Field: ‘version’
[10:20:11.820]   - Field: ‘result’
[10:20:11.820]   - Field: ‘asynchronous’
[10:20:11.820]   - Field: ‘calls’
[10:20:11.820]   - Field: ‘globals’
[10:20:11.820]   - Field: ‘stdout’
[10:20:11.820]   - Field: ‘earlySignal’
[10:20:11.820]   - Field: ‘lazy’
[10:20:11.821]   - Field: ‘state’
[10:20:11.821] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:11.821] - Launch lazy future ...
[10:20:11.821] Packages needed by the future expression (n = 0): <none>
[10:20:11.821] Packages needed by future strategies (n = 0): <none>
[10:20:11.821] {
[10:20:11.821]     {
[10:20:11.821]         {
[10:20:11.821]             ...future.startTime <- base::Sys.time()
[10:20:11.821]             {
[10:20:11.821]                 {
[10:20:11.821]                   {
[10:20:11.821]                     base::local({
[10:20:11.821]                       has_future <- base::requireNamespace("future", 
[10:20:11.821]                         quietly = TRUE)
[10:20:11.821]                       if (has_future) {
[10:20:11.821]                         ns <- base::getNamespace("future")
[10:20:11.821]                         version <- ns[[".package"]][["version"]]
[10:20:11.821]                         if (is.null(version)) 
[10:20:11.821]                           version <- utils::packageVersion("future")
[10:20:11.821]                       }
[10:20:11.821]                       else {
[10:20:11.821]                         version <- NULL
[10:20:11.821]                       }
[10:20:11.821]                       if (!has_future || version < "1.8.0") {
[10:20:11.821]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:11.821]                           "", base::R.version$version.string), 
[10:20:11.821]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:11.821]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:11.821]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:11.821]                             "release", "version")], collapse = " "), 
[10:20:11.821]                           hostname = base::Sys.info()[["nodename"]])
[10:20:11.821]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:11.821]                           info)
[10:20:11.821]                         info <- base::paste(info, collapse = "; ")
[10:20:11.821]                         if (!has_future) {
[10:20:11.821]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:11.821]                             info)
[10:20:11.821]                         }
[10:20:11.821]                         else {
[10:20:11.821]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:11.821]                             info, version)
[10:20:11.821]                         }
[10:20:11.821]                         base::stop(msg)
[10:20:11.821]                       }
[10:20:11.821]                     })
[10:20:11.821]                   }
[10:20:11.821]                   ...future.strategy.old <- future::plan("list")
[10:20:11.821]                   options(future.plan = NULL)
[10:20:11.821]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:11.821]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:11.821]                 }
[10:20:11.821]                 ...future.workdir <- getwd()
[10:20:11.821]             }
[10:20:11.821]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:11.821]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:11.821]         }
[10:20:11.821]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:11.821]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:11.821]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:11.821]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:11.821]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:11.821]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:11.821]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:11.821]             base::names(...future.oldOptions))
[10:20:11.821]     }
[10:20:11.821]     if (FALSE) {
[10:20:11.821]     }
[10:20:11.821]     else {
[10:20:11.821]         if (TRUE) {
[10:20:11.821]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:11.821]                 open = "w")
[10:20:11.821]         }
[10:20:11.821]         else {
[10:20:11.821]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:11.821]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:11.821]         }
[10:20:11.821]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:11.821]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:11.821]             base::sink(type = "output", split = FALSE)
[10:20:11.821]             base::close(...future.stdout)
[10:20:11.821]         }, add = TRUE)
[10:20:11.821]     }
[10:20:11.821]     ...future.frame <- base::sys.nframe()
[10:20:11.821]     ...future.conditions <- base::list()
[10:20:11.821]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:11.821]     if (FALSE) {
[10:20:11.821]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:11.821]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:11.821]     }
[10:20:11.821]     ...future.result <- base::tryCatch({
[10:20:11.821]         base::withCallingHandlers({
[10:20:11.821]             ...future.value <- base::withVisible(base::local({
[10:20:11.821]                 do.call(function(...) {
[10:20:11.821]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:11.821]                   if (!identical(...future.globals.maxSize.org, 
[10:20:11.821]                     ...future.globals.maxSize)) {
[10:20:11.821]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:11.821]                     on.exit(options(oopts), add = TRUE)
[10:20:11.821]                   }
[10:20:11.821]                   {
[10:20:11.821]                     lapply(seq_along(...future.elements_ii), 
[10:20:11.821]                       FUN = function(jj) {
[10:20:11.821]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:11.821]                         ...future.FUN(...future.X_jj, ...)
[10:20:11.821]                       })
[10:20:11.821]                   }
[10:20:11.821]                 }, args = future.call.arguments)
[10:20:11.821]             }))
[10:20:11.821]             future::FutureResult(value = ...future.value$value, 
[10:20:11.821]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:11.821]                   ...future.rng), globalenv = if (FALSE) 
[10:20:11.821]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:11.821]                     ...future.globalenv.names))
[10:20:11.821]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:11.821]         }, condition = base::local({
[10:20:11.821]             c <- base::c
[10:20:11.821]             inherits <- base::inherits
[10:20:11.821]             invokeRestart <- base::invokeRestart
[10:20:11.821]             length <- base::length
[10:20:11.821]             list <- base::list
[10:20:11.821]             seq.int <- base::seq.int
[10:20:11.821]             signalCondition <- base::signalCondition
[10:20:11.821]             sys.calls <- base::sys.calls
[10:20:11.821]             `[[` <- base::`[[`
[10:20:11.821]             `+` <- base::`+`
[10:20:11.821]             `<<-` <- base::`<<-`
[10:20:11.821]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:11.821]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:11.821]                   3L)]
[10:20:11.821]             }
[10:20:11.821]             function(cond) {
[10:20:11.821]                 is_error <- inherits(cond, "error")
[10:20:11.821]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:11.821]                   NULL)
[10:20:11.821]                 if (is_error) {
[10:20:11.821]                   sessionInformation <- function() {
[10:20:11.821]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:11.821]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:11.821]                       search = base::search(), system = base::Sys.info())
[10:20:11.821]                   }
[10:20:11.821]                   ...future.conditions[[length(...future.conditions) + 
[10:20:11.821]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:11.821]                     cond$call), session = sessionInformation(), 
[10:20:11.821]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:11.821]                   signalCondition(cond)
[10:20:11.821]                 }
[10:20:11.821]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:11.821]                 "immediateCondition"))) {
[10:20:11.821]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:11.821]                   ...future.conditions[[length(...future.conditions) + 
[10:20:11.821]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:11.821]                   if (TRUE && !signal) {
[10:20:11.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:11.821]                     {
[10:20:11.821]                       inherits <- base::inherits
[10:20:11.821]                       invokeRestart <- base::invokeRestart
[10:20:11.821]                       is.null <- base::is.null
[10:20:11.821]                       muffled <- FALSE
[10:20:11.821]                       if (inherits(cond, "message")) {
[10:20:11.821]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:11.821]                         if (muffled) 
[10:20:11.821]                           invokeRestart("muffleMessage")
[10:20:11.821]                       }
[10:20:11.821]                       else if (inherits(cond, "warning")) {
[10:20:11.821]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:11.821]                         if (muffled) 
[10:20:11.821]                           invokeRestart("muffleWarning")
[10:20:11.821]                       }
[10:20:11.821]                       else if (inherits(cond, "condition")) {
[10:20:11.821]                         if (!is.null(pattern)) {
[10:20:11.821]                           computeRestarts <- base::computeRestarts
[10:20:11.821]                           grepl <- base::grepl
[10:20:11.821]                           restarts <- computeRestarts(cond)
[10:20:11.821]                           for (restart in restarts) {
[10:20:11.821]                             name <- restart$name
[10:20:11.821]                             if (is.null(name)) 
[10:20:11.821]                               next
[10:20:11.821]                             if (!grepl(pattern, name)) 
[10:20:11.821]                               next
[10:20:11.821]                             invokeRestart(restart)
[10:20:11.821]                             muffled <- TRUE
[10:20:11.821]                             break
[10:20:11.821]                           }
[10:20:11.821]                         }
[10:20:11.821]                       }
[10:20:11.821]                       invisible(muffled)
[10:20:11.821]                     }
[10:20:11.821]                     muffleCondition(cond, pattern = "^muffle")
[10:20:11.821]                   }
[10:20:11.821]                 }
[10:20:11.821]                 else {
[10:20:11.821]                   if (TRUE) {
[10:20:11.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:11.821]                     {
[10:20:11.821]                       inherits <- base::inherits
[10:20:11.821]                       invokeRestart <- base::invokeRestart
[10:20:11.821]                       is.null <- base::is.null
[10:20:11.821]                       muffled <- FALSE
[10:20:11.821]                       if (inherits(cond, "message")) {
[10:20:11.821]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:11.821]                         if (muffled) 
[10:20:11.821]                           invokeRestart("muffleMessage")
[10:20:11.821]                       }
[10:20:11.821]                       else if (inherits(cond, "warning")) {
[10:20:11.821]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:11.821]                         if (muffled) 
[10:20:11.821]                           invokeRestart("muffleWarning")
[10:20:11.821]                       }
[10:20:11.821]                       else if (inherits(cond, "condition")) {
[10:20:11.821]                         if (!is.null(pattern)) {
[10:20:11.821]                           computeRestarts <- base::computeRestarts
[10:20:11.821]                           grepl <- base::grepl
[10:20:11.821]                           restarts <- computeRestarts(cond)
[10:20:11.821]                           for (restart in restarts) {
[10:20:11.821]                             name <- restart$name
[10:20:11.821]                             if (is.null(name)) 
[10:20:11.821]                               next
[10:20:11.821]                             if (!grepl(pattern, name)) 
[10:20:11.821]                               next
[10:20:11.821]                             invokeRestart(restart)
[10:20:11.821]                             muffled <- TRUE
[10:20:11.821]                             break
[10:20:11.821]                           }
[10:20:11.821]                         }
[10:20:11.821]                       }
[10:20:11.821]                       invisible(muffled)
[10:20:11.821]                     }
[10:20:11.821]                     muffleCondition(cond, pattern = "^muffle")
[10:20:11.821]                   }
[10:20:11.821]                 }
[10:20:11.821]             }
[10:20:11.821]         }))
[10:20:11.821]     }, error = function(ex) {
[10:20:11.821]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:11.821]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:11.821]                 ...future.rng), started = ...future.startTime, 
[10:20:11.821]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:11.821]             version = "1.8"), class = "FutureResult")
[10:20:11.821]     }, finally = {
[10:20:11.821]         if (!identical(...future.workdir, getwd())) 
[10:20:11.821]             setwd(...future.workdir)
[10:20:11.821]         {
[10:20:11.821]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:11.821]                 ...future.oldOptions$nwarnings <- NULL
[10:20:11.821]             }
[10:20:11.821]             base::options(...future.oldOptions)
[10:20:11.821]             if (.Platform$OS.type == "windows") {
[10:20:11.821]                 old_names <- names(...future.oldEnvVars)
[10:20:11.821]                 envs <- base::Sys.getenv()
[10:20:11.821]                 names <- names(envs)
[10:20:11.821]                 common <- intersect(names, old_names)
[10:20:11.821]                 added <- setdiff(names, old_names)
[10:20:11.821]                 removed <- setdiff(old_names, names)
[10:20:11.821]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:11.821]                   envs[common]]
[10:20:11.821]                 NAMES <- toupper(changed)
[10:20:11.821]                 args <- list()
[10:20:11.821]                 for (kk in seq_along(NAMES)) {
[10:20:11.821]                   name <- changed[[kk]]
[10:20:11.821]                   NAME <- NAMES[[kk]]
[10:20:11.821]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:11.821]                     next
[10:20:11.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:11.821]                 }
[10:20:11.821]                 NAMES <- toupper(added)
[10:20:11.821]                 for (kk in seq_along(NAMES)) {
[10:20:11.821]                   name <- added[[kk]]
[10:20:11.821]                   NAME <- NAMES[[kk]]
[10:20:11.821]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:11.821]                     next
[10:20:11.821]                   args[[name]] <- ""
[10:20:11.821]                 }
[10:20:11.821]                 NAMES <- toupper(removed)
[10:20:11.821]                 for (kk in seq_along(NAMES)) {
[10:20:11.821]                   name <- removed[[kk]]
[10:20:11.821]                   NAME <- NAMES[[kk]]
[10:20:11.821]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:11.821]                     next
[10:20:11.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:11.821]                 }
[10:20:11.821]                 if (length(args) > 0) 
[10:20:11.821]                   base::do.call(base::Sys.setenv, args = args)
[10:20:11.821]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:11.821]             }
[10:20:11.821]             else {
[10:20:11.821]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:11.821]             }
[10:20:11.821]             {
[10:20:11.821]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:11.821]                   0L) {
[10:20:11.821]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:11.821]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:11.821]                   base::options(opts)
[10:20:11.821]                 }
[10:20:11.821]                 {
[10:20:11.821]                   {
[10:20:11.821]                     NULL
[10:20:11.821]                     RNGkind("Mersenne-Twister")
[10:20:11.821]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:11.821]                       inherits = FALSE)
[10:20:11.821]                   }
[10:20:11.821]                   options(future.plan = NULL)
[10:20:11.821]                   if (is.na(NA_character_)) 
[10:20:11.821]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:11.821]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:11.821]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:11.821]                     .init = FALSE)
[10:20:11.821]                 }
[10:20:11.821]             }
[10:20:11.821]         }
[10:20:11.821]     })
[10:20:11.821]     if (TRUE) {
[10:20:11.821]         base::sink(type = "output", split = FALSE)
[10:20:11.821]         if (TRUE) {
[10:20:11.821]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:11.821]         }
[10:20:11.821]         else {
[10:20:11.821]             ...future.result["stdout"] <- base::list(NULL)
[10:20:11.821]         }
[10:20:11.821]         base::close(...future.stdout)
[10:20:11.821]         ...future.stdout <- NULL
[10:20:11.821]     }
[10:20:11.821]     ...future.result$conditions <- ...future.conditions
[10:20:11.821]     ...future.result$finished <- base::Sys.time()
[10:20:11.821]     ...future.result
[10:20:11.821] }
[10:20:11.823] assign_globals() ...
[10:20:11.823] List of 5
[10:20:11.823]  $ ...future.FUN            :function (x)  
[10:20:11.823]  $ future.call.arguments    : list()
[10:20:11.823]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:11.823]  $ ...future.elements_ii    :List of 2
[10:20:11.823]   ..$ : int 1
[10:20:11.823]   ..$ : int 0
[10:20:11.823]  $ ...future.seeds_ii       : NULL
[10:20:11.823]  $ ...future.globals.maxSize: NULL
[10:20:11.823]  - attr(*, "where")=List of 5
[10:20:11.823]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:11.823]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:20:11.823]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:11.823]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:11.823]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:11.823]  - attr(*, "resolved")= logi FALSE
[10:20:11.823]  - attr(*, "total_size")= num 5632
[10:20:11.823]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:11.823]  - attr(*, "already-done")= logi TRUE
[10:20:11.829] - reassign environment for ‘...future.FUN’
[10:20:11.829] - copied ‘...future.FUN’ to environment
[10:20:11.829] - copied ‘future.call.arguments’ to environment
[10:20:11.829] - copied ‘...future.elements_ii’ to environment
[10:20:11.829] - copied ‘...future.seeds_ii’ to environment
[10:20:11.829] - copied ‘...future.globals.maxSize’ to environment
[10:20:11.829] assign_globals() ... done
[10:20:11.830] plan(): Setting new future strategy stack:
[10:20:11.830] List of future strategies:
[10:20:11.830] 1. sequential:
[10:20:11.830]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:11.830]    - tweaked: FALSE
[10:20:11.830]    - call: NULL
[10:20:11.830] plan(): nbrOfWorkers() = 1
[10:20:12.332] plan(): Setting new future strategy stack:
[10:20:12.332] List of future strategies:
[10:20:12.332] 1. multisession:
[10:20:12.332]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:20:12.332]    - tweaked: FALSE
[10:20:12.332]    - call: plan(strategy)
[10:20:12.334] plan(): nbrOfWorkers() = 1
[10:20:12.334] SequentialFuture started (and completed)
[10:20:12.334] - Launch lazy future ... done
[10:20:12.334] run() for ‘SequentialFuture’ ... done
[10:20:12.334] Created future:
[10:20:12.334] SequentialFuture:
[10:20:12.334] Label: ‘future_lapply-1’
[10:20:12.334] Expression:
[10:20:12.334] {
[10:20:12.334]     do.call(function(...) {
[10:20:12.334]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:12.334]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:12.334]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:12.334]             on.exit(options(oopts), add = TRUE)
[10:20:12.334]         }
[10:20:12.334]         {
[10:20:12.334]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:12.334]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:12.334]                 ...future.FUN(...future.X_jj, ...)
[10:20:12.334]             })
[10:20:12.334]         }
[10:20:12.334]     }, args = future.call.arguments)
[10:20:12.334] }
[10:20:12.334] Lazy evaluation: FALSE
[10:20:12.334] Asynchronous evaluation: FALSE
[10:20:12.334] Local evaluation: TRUE
[10:20:12.334] Environment: R_GlobalEnv
[10:20:12.334] Capture standard output: TRUE
[10:20:12.334] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:12.334] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:12.334] Packages: <none>
[10:20:12.334] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:12.334] Resolved: TRUE
[10:20:12.334] Value: 55 bytes of class ‘list’
[10:20:12.334] Early signaling: FALSE
[10:20:12.334] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:12.334] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:12.335] Chunk #1 of 1 ... DONE
[10:20:12.335] Launching 1 futures (chunks) ... DONE
[10:20:12.336] Resolving 1 futures (chunks) ...
[10:20:12.336] resolve() on list ...
[10:20:12.336]  recursive: 0
[10:20:12.336]  length: 1
[10:20:12.336] 
[10:20:12.336] resolved() for ‘SequentialFuture’ ...
[10:20:12.336] - state: ‘finished’
[10:20:12.336] - run: TRUE
[10:20:12.336] - result: ‘FutureResult’
[10:20:12.336] resolved() for ‘SequentialFuture’ ... done
[10:20:12.336] Future #1
[10:20:12.337] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:20:12.337] - nx: 1
[10:20:12.337] - relay: TRUE
[10:20:12.337] - stdout: TRUE
[10:20:12.337] - signal: TRUE
[10:20:12.337] - resignal: FALSE
[10:20:12.337] - force: TRUE
[10:20:12.337] - relayed: [n=1] FALSE
[10:20:12.337] - queued futures: [n=1] FALSE
[10:20:12.337]  - until=1
[10:20:12.337]  - relaying element #1
[10:20:12.338] - relayed: [n=1] TRUE
[10:20:12.338] - queued futures: [n=1] TRUE
[10:20:12.338] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:20:12.338]  length: 0 (resolved future 1)
[10:20:12.338] Relaying remaining futures
[10:20:12.338] signalConditionsASAP(NULL, pos=0) ...
[10:20:12.338] - nx: 1
[10:20:12.338] - relay: TRUE
[10:20:12.338] - stdout: TRUE
[10:20:12.338] - signal: TRUE
[10:20:12.338] - resignal: FALSE
[10:20:12.338] - force: TRUE
[10:20:12.339] - relayed: [n=1] TRUE
[10:20:12.339] - queued futures: [n=1] TRUE
 - flush all
[10:20:12.339] - relayed: [n=1] TRUE
[10:20:12.339] - queued futures: [n=1] TRUE
[10:20:12.339] signalConditionsASAP(NULL, pos=0) ... done
[10:20:12.339] resolve() on list ... DONE
[10:20:12.339]  - Number of value chunks collected: 1
[10:20:12.339] Resolving 1 futures (chunks) ... DONE
[10:20:12.339] Reducing values from 1 chunks ...
[10:20:12.339]  - Number of values collected after concatenation: 2
[10:20:12.340]  - Number of values expected: 2
[10:20:12.340] Reducing values from 1 chunks ... DONE
[10:20:12.340] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[10:20:12.340] future_lapply() ...
[10:20:12.342] Number of chunks: 1
[10:20:12.342] getGlobalsAndPackagesXApply() ...
[10:20:12.342]  - future.globals: TRUE
[10:20:12.342] getGlobalsAndPackages() ...
[10:20:12.342] Searching for globals...
[10:20:12.344] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:20:12.344] Searching for globals ... DONE
[10:20:12.344] Resolving globals: FALSE
[10:20:12.344] The total size of the 1 globals is 841 bytes (841 bytes)
[10:20:12.345] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[10:20:12.345] - globals: [1] ‘FUN’
[10:20:12.345] 
[10:20:12.345] getGlobalsAndPackages() ... DONE
[10:20:12.345]  - globals found/used: [n=1] ‘FUN’
[10:20:12.345]  - needed namespaces: [n=0] 
[10:20:12.345] Finding globals ... DONE
[10:20:12.345]  - use_args: TRUE
[10:20:12.345]  - Getting '...' globals ...
[10:20:12.346] resolve() on list ...
[10:20:12.346]  recursive: 0
[10:20:12.346]  length: 1
[10:20:12.346]  elements: ‘...’
[10:20:12.346]  length: 0 (resolved future 1)
[10:20:12.346] resolve() on list ... DONE
[10:20:12.346]    - '...' content: [n=0] 
[10:20:12.346] List of 1
[10:20:12.346]  $ ...: list()
[10:20:12.346]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:12.346]  - attr(*, "where")=List of 1
[10:20:12.346]   ..$ ...:<environment: 0x557fc18878f0> 
[10:20:12.346]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:12.346]  - attr(*, "resolved")= logi TRUE
[10:20:12.346]  - attr(*, "total_size")= num NA
[10:20:12.349]  - Getting '...' globals ... DONE
[10:20:12.349] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:20:12.349] List of 2
[10:20:12.349]  $ ...future.FUN:function (x)  
[10:20:12.349]  $ ...          : list()
[10:20:12.349]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:12.349]  - attr(*, "where")=List of 2
[10:20:12.349]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:12.349]   ..$ ...          :<environment: 0x557fc18878f0> 
[10:20:12.349]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:12.349]  - attr(*, "resolved")= logi FALSE
[10:20:12.349]  - attr(*, "total_size")= num 5632
[10:20:12.353] Packages to be attached in all futures: [n=0] 
[10:20:12.353] getGlobalsAndPackagesXApply() ... DONE
[10:20:12.354] Number of futures (= number of chunks): 1
[10:20:12.354] Launching 1 futures (chunks) ...
[10:20:12.354] Chunk #1 of 1 ...
[10:20:12.354]  - Finding globals in 'X' for chunk #1 ...
[10:20:12.354] getGlobalsAndPackages() ...
[10:20:12.354] Searching for globals...
[10:20:12.354] 
[10:20:12.355] Searching for globals ... DONE
[10:20:12.355] - globals: [0] <none>
[10:20:12.355] getGlobalsAndPackages() ... DONE
[10:20:12.355]    + additional globals found: [n=0] 
[10:20:12.355]    + additional namespaces needed: [n=0] 
[10:20:12.355]  - Finding globals in 'X' for chunk #1 ... DONE
[10:20:12.355]  - seeds: <none>
[10:20:12.355]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:12.355] getGlobalsAndPackages() ...
[10:20:12.355] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:12.356] Resolving globals: FALSE
[10:20:12.356] Tweak future expression to call with '...' arguments ...
[10:20:12.356] {
[10:20:12.356]     do.call(function(...) {
[10:20:12.356]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:12.356]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:12.356]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:12.356]             on.exit(options(oopts), add = TRUE)
[10:20:12.356]         }
[10:20:12.356]         {
[10:20:12.356]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:12.356]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:12.356]                 ...future.FUN(...future.X_jj, ...)
[10:20:12.356]             })
[10:20:12.356]         }
[10:20:12.356]     }, args = future.call.arguments)
[10:20:12.356] }
[10:20:12.356] Tweak future expression to call with '...' arguments ... DONE
[10:20:12.356] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:12.356] 
[10:20:12.356] getGlobalsAndPackages() ... DONE
[10:20:12.357] run() for ‘Future’ ...
[10:20:12.357] - state: ‘created’
[10:20:12.357] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:20:12.358] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:12.359] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:12.359]   - Field: ‘label’
[10:20:12.359]   - Field: ‘local’
[10:20:12.359]   - Field: ‘owner’
[10:20:12.359]   - Field: ‘envir’
[10:20:12.359]   - Field: ‘packages’
[10:20:12.359]   - Field: ‘gc’
[10:20:12.359]   - Field: ‘conditions’
[10:20:12.359]   - Field: ‘expr’
[10:20:12.359]   - Field: ‘uuid’
[10:20:12.359]   - Field: ‘seed’
[10:20:12.359]   - Field: ‘version’
[10:20:12.360]   - Field: ‘result’
[10:20:12.360]   - Field: ‘asynchronous’
[10:20:12.360]   - Field: ‘calls’
[10:20:12.360]   - Field: ‘globals’
[10:20:12.360]   - Field: ‘stdout’
[10:20:12.360]   - Field: ‘earlySignal’
[10:20:12.360]   - Field: ‘lazy’
[10:20:12.360]   - Field: ‘state’
[10:20:12.360] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:12.360] - Launch lazy future ...
[10:20:12.360] Packages needed by the future expression (n = 0): <none>
[10:20:12.361] Packages needed by future strategies (n = 0): <none>
[10:20:12.361] {
[10:20:12.361]     {
[10:20:12.361]         {
[10:20:12.361]             ...future.startTime <- base::Sys.time()
[10:20:12.361]             {
[10:20:12.361]                 {
[10:20:12.361]                   {
[10:20:12.361]                     base::local({
[10:20:12.361]                       has_future <- base::requireNamespace("future", 
[10:20:12.361]                         quietly = TRUE)
[10:20:12.361]                       if (has_future) {
[10:20:12.361]                         ns <- base::getNamespace("future")
[10:20:12.361]                         version <- ns[[".package"]][["version"]]
[10:20:12.361]                         if (is.null(version)) 
[10:20:12.361]                           version <- utils::packageVersion("future")
[10:20:12.361]                       }
[10:20:12.361]                       else {
[10:20:12.361]                         version <- NULL
[10:20:12.361]                       }
[10:20:12.361]                       if (!has_future || version < "1.8.0") {
[10:20:12.361]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:12.361]                           "", base::R.version$version.string), 
[10:20:12.361]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:12.361]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:12.361]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:12.361]                             "release", "version")], collapse = " "), 
[10:20:12.361]                           hostname = base::Sys.info()[["nodename"]])
[10:20:12.361]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:12.361]                           info)
[10:20:12.361]                         info <- base::paste(info, collapse = "; ")
[10:20:12.361]                         if (!has_future) {
[10:20:12.361]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:12.361]                             info)
[10:20:12.361]                         }
[10:20:12.361]                         else {
[10:20:12.361]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:12.361]                             info, version)
[10:20:12.361]                         }
[10:20:12.361]                         base::stop(msg)
[10:20:12.361]                       }
[10:20:12.361]                     })
[10:20:12.361]                   }
[10:20:12.361]                   ...future.strategy.old <- future::plan("list")
[10:20:12.361]                   options(future.plan = NULL)
[10:20:12.361]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:12.361]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:12.361]                 }
[10:20:12.361]                 ...future.workdir <- getwd()
[10:20:12.361]             }
[10:20:12.361]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:12.361]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:12.361]         }
[10:20:12.361]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:12.361]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:12.361]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:12.361]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:12.361]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:12.361]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:12.361]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:12.361]             base::names(...future.oldOptions))
[10:20:12.361]     }
[10:20:12.361]     if (TRUE) {
[10:20:12.361]     }
[10:20:12.361]     else {
[10:20:12.361]         if (NA) {
[10:20:12.361]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:12.361]                 open = "w")
[10:20:12.361]         }
[10:20:12.361]         else {
[10:20:12.361]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:12.361]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:12.361]         }
[10:20:12.361]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:12.361]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:12.361]             base::sink(type = "output", split = FALSE)
[10:20:12.361]             base::close(...future.stdout)
[10:20:12.361]         }, add = TRUE)
[10:20:12.361]     }
[10:20:12.361]     ...future.frame <- base::sys.nframe()
[10:20:12.361]     ...future.conditions <- base::list()
[10:20:12.361]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:12.361]     if (FALSE) {
[10:20:12.361]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:12.361]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:12.361]     }
[10:20:12.361]     ...future.result <- base::tryCatch({
[10:20:12.361]         base::withCallingHandlers({
[10:20:12.361]             ...future.value <- base::withVisible(base::local({
[10:20:12.361]                 do.call(function(...) {
[10:20:12.361]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:12.361]                   if (!identical(...future.globals.maxSize.org, 
[10:20:12.361]                     ...future.globals.maxSize)) {
[10:20:12.361]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:12.361]                     on.exit(options(oopts), add = TRUE)
[10:20:12.361]                   }
[10:20:12.361]                   {
[10:20:12.361]                     lapply(seq_along(...future.elements_ii), 
[10:20:12.361]                       FUN = function(jj) {
[10:20:12.361]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:12.361]                         ...future.FUN(...future.X_jj, ...)
[10:20:12.361]                       })
[10:20:12.361]                   }
[10:20:12.361]                 }, args = future.call.arguments)
[10:20:12.361]             }))
[10:20:12.361]             future::FutureResult(value = ...future.value$value, 
[10:20:12.361]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:12.361]                   ...future.rng), globalenv = if (FALSE) 
[10:20:12.361]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:12.361]                     ...future.globalenv.names))
[10:20:12.361]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:12.361]         }, condition = base::local({
[10:20:12.361]             c <- base::c
[10:20:12.361]             inherits <- base::inherits
[10:20:12.361]             invokeRestart <- base::invokeRestart
[10:20:12.361]             length <- base::length
[10:20:12.361]             list <- base::list
[10:20:12.361]             seq.int <- base::seq.int
[10:20:12.361]             signalCondition <- base::signalCondition
[10:20:12.361]             sys.calls <- base::sys.calls
[10:20:12.361]             `[[` <- base::`[[`
[10:20:12.361]             `+` <- base::`+`
[10:20:12.361]             `<<-` <- base::`<<-`
[10:20:12.361]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:12.361]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:12.361]                   3L)]
[10:20:12.361]             }
[10:20:12.361]             function(cond) {
[10:20:12.361]                 is_error <- inherits(cond, "error")
[10:20:12.361]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:12.361]                   NULL)
[10:20:12.361]                 if (is_error) {
[10:20:12.361]                   sessionInformation <- function() {
[10:20:12.361]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:12.361]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:12.361]                       search = base::search(), system = base::Sys.info())
[10:20:12.361]                   }
[10:20:12.361]                   ...future.conditions[[length(...future.conditions) + 
[10:20:12.361]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:12.361]                     cond$call), session = sessionInformation(), 
[10:20:12.361]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:12.361]                   signalCondition(cond)
[10:20:12.361]                 }
[10:20:12.361]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:12.361]                 "immediateCondition"))) {
[10:20:12.361]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:12.361]                   ...future.conditions[[length(...future.conditions) + 
[10:20:12.361]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:12.361]                   if (TRUE && !signal) {
[10:20:12.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:12.361]                     {
[10:20:12.361]                       inherits <- base::inherits
[10:20:12.361]                       invokeRestart <- base::invokeRestart
[10:20:12.361]                       is.null <- base::is.null
[10:20:12.361]                       muffled <- FALSE
[10:20:12.361]                       if (inherits(cond, "message")) {
[10:20:12.361]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:12.361]                         if (muffled) 
[10:20:12.361]                           invokeRestart("muffleMessage")
[10:20:12.361]                       }
[10:20:12.361]                       else if (inherits(cond, "warning")) {
[10:20:12.361]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:12.361]                         if (muffled) 
[10:20:12.361]                           invokeRestart("muffleWarning")
[10:20:12.361]                       }
[10:20:12.361]                       else if (inherits(cond, "condition")) {
[10:20:12.361]                         if (!is.null(pattern)) {
[10:20:12.361]                           computeRestarts <- base::computeRestarts
[10:20:12.361]                           grepl <- base::grepl
[10:20:12.361]                           restarts <- computeRestarts(cond)
[10:20:12.361]                           for (restart in restarts) {
[10:20:12.361]                             name <- restart$name
[10:20:12.361]                             if (is.null(name)) 
[10:20:12.361]                               next
[10:20:12.361]                             if (!grepl(pattern, name)) 
[10:20:12.361]                               next
[10:20:12.361]                             invokeRestart(restart)
[10:20:12.361]                             muffled <- TRUE
[10:20:12.361]                             break
[10:20:12.361]                           }
[10:20:12.361]                         }
[10:20:12.361]                       }
[10:20:12.361]                       invisible(muffled)
[10:20:12.361]                     }
[10:20:12.361]                     muffleCondition(cond, pattern = "^muffle")
[10:20:12.361]                   }
[10:20:12.361]                 }
[10:20:12.361]                 else {
[10:20:12.361]                   if (TRUE) {
[10:20:12.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:12.361]                     {
[10:20:12.361]                       inherits <- base::inherits
[10:20:12.361]                       invokeRestart <- base::invokeRestart
[10:20:12.361]                       is.null <- base::is.null
[10:20:12.361]                       muffled <- FALSE
[10:20:12.361]                       if (inherits(cond, "message")) {
[10:20:12.361]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:12.361]                         if (muffled) 
[10:20:12.361]                           invokeRestart("muffleMessage")
[10:20:12.361]                       }
[10:20:12.361]                       else if (inherits(cond, "warning")) {
[10:20:12.361]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:12.361]                         if (muffled) 
[10:20:12.361]                           invokeRestart("muffleWarning")
[10:20:12.361]                       }
[10:20:12.361]                       else if (inherits(cond, "condition")) {
[10:20:12.361]                         if (!is.null(pattern)) {
[10:20:12.361]                           computeRestarts <- base::computeRestarts
[10:20:12.361]                           grepl <- base::grepl
[10:20:12.361]                           restarts <- computeRestarts(cond)
[10:20:12.361]                           for (restart in restarts) {
[10:20:12.361]                             name <- restart$name
[10:20:12.361]                             if (is.null(name)) 
[10:20:12.361]                               next
[10:20:12.361]                             if (!grepl(pattern, name)) 
[10:20:12.361]                               next
[10:20:12.361]                             invokeRestart(restart)
[10:20:12.361]                             muffled <- TRUE
[10:20:12.361]                             break
[10:20:12.361]                           }
[10:20:12.361]                         }
[10:20:12.361]                       }
[10:20:12.361]                       invisible(muffled)
[10:20:12.361]                     }
[10:20:12.361]                     muffleCondition(cond, pattern = "^muffle")
[10:20:12.361]                   }
[10:20:12.361]                 }
[10:20:12.361]             }
[10:20:12.361]         }))
[10:20:12.361]     }, error = function(ex) {
[10:20:12.361]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:12.361]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:12.361]                 ...future.rng), started = ...future.startTime, 
[10:20:12.361]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:12.361]             version = "1.8"), class = "FutureResult")
[10:20:12.361]     }, finally = {
[10:20:12.361]         if (!identical(...future.workdir, getwd())) 
[10:20:12.361]             setwd(...future.workdir)
[10:20:12.361]         {
[10:20:12.361]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:12.361]                 ...future.oldOptions$nwarnings <- NULL
[10:20:12.361]             }
[10:20:12.361]             base::options(...future.oldOptions)
[10:20:12.361]             if (.Platform$OS.type == "windows") {
[10:20:12.361]                 old_names <- names(...future.oldEnvVars)
[10:20:12.361]                 envs <- base::Sys.getenv()
[10:20:12.361]                 names <- names(envs)
[10:20:12.361]                 common <- intersect(names, old_names)
[10:20:12.361]                 added <- setdiff(names, old_names)
[10:20:12.361]                 removed <- setdiff(old_names, names)
[10:20:12.361]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:12.361]                   envs[common]]
[10:20:12.361]                 NAMES <- toupper(changed)
[10:20:12.361]                 args <- list()
[10:20:12.361]                 for (kk in seq_along(NAMES)) {
[10:20:12.361]                   name <- changed[[kk]]
[10:20:12.361]                   NAME <- NAMES[[kk]]
[10:20:12.361]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:12.361]                     next
[10:20:12.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:12.361]                 }
[10:20:12.361]                 NAMES <- toupper(added)
[10:20:12.361]                 for (kk in seq_along(NAMES)) {
[10:20:12.361]                   name <- added[[kk]]
[10:20:12.361]                   NAME <- NAMES[[kk]]
[10:20:12.361]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:12.361]                     next
[10:20:12.361]                   args[[name]] <- ""
[10:20:12.361]                 }
[10:20:12.361]                 NAMES <- toupper(removed)
[10:20:12.361]                 for (kk in seq_along(NAMES)) {
[10:20:12.361]                   name <- removed[[kk]]
[10:20:12.361]                   NAME <- NAMES[[kk]]
[10:20:12.361]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:12.361]                     next
[10:20:12.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:12.361]                 }
[10:20:12.361]                 if (length(args) > 0) 
[10:20:12.361]                   base::do.call(base::Sys.setenv, args = args)
[10:20:12.361]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:12.361]             }
[10:20:12.361]             else {
[10:20:12.361]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:12.361]             }
[10:20:12.361]             {
[10:20:12.361]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:12.361]                   0L) {
[10:20:12.361]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:12.361]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:12.361]                   base::options(opts)
[10:20:12.361]                 }
[10:20:12.361]                 {
[10:20:12.361]                   {
[10:20:12.361]                     NULL
[10:20:12.361]                     RNGkind("Mersenne-Twister")
[10:20:12.361]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:12.361]                       inherits = FALSE)
[10:20:12.361]                   }
[10:20:12.361]                   options(future.plan = NULL)
[10:20:12.361]                   if (is.na(NA_character_)) 
[10:20:12.361]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:12.361]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:12.361]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:12.361]                     .init = FALSE)
[10:20:12.361]                 }
[10:20:12.361]             }
[10:20:12.361]         }
[10:20:12.361]     })
[10:20:12.361]     if (FALSE) {
[10:20:12.361]         base::sink(type = "output", split = FALSE)
[10:20:12.361]         if (NA) {
[10:20:12.361]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:12.361]         }
[10:20:12.361]         else {
[10:20:12.361]             ...future.result["stdout"] <- base::list(NULL)
[10:20:12.361]         }
[10:20:12.361]         base::close(...future.stdout)
[10:20:12.361]         ...future.stdout <- NULL
[10:20:12.361]     }
[10:20:12.361]     ...future.result$conditions <- ...future.conditions
[10:20:12.361]     ...future.result$finished <- base::Sys.time()
[10:20:12.361]     ...future.result
[10:20:12.361] }
[10:20:12.363] assign_globals() ...
[10:20:12.363] List of 5
[10:20:12.363]  $ ...future.FUN            :function (x)  
[10:20:12.363]  $ future.call.arguments    : list()
[10:20:12.363]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:12.363]  $ ...future.elements_ii    :List of 2
[10:20:12.363]   ..$ : int 1
[10:20:12.363]   ..$ : int 0
[10:20:12.363]  $ ...future.seeds_ii       : NULL
[10:20:12.363]  $ ...future.globals.maxSize: NULL
[10:20:12.363]  - attr(*, "where")=List of 5
[10:20:12.363]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:12.363]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:20:12.363]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:12.363]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:12.363]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:12.363]  - attr(*, "resolved")= logi FALSE
[10:20:12.363]  - attr(*, "total_size")= num 5632
[10:20:12.363]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:12.363]  - attr(*, "already-done")= logi TRUE
[10:20:12.368] - reassign environment for ‘...future.FUN’
[10:20:12.368] - copied ‘...future.FUN’ to environment
[10:20:12.368] - copied ‘future.call.arguments’ to environment
[10:20:12.368] - copied ‘...future.elements_ii’ to environment
[10:20:12.368] - copied ‘...future.seeds_ii’ to environment
[10:20:12.368] - copied ‘...future.globals.maxSize’ to environment
[10:20:12.368] assign_globals() ... done
[10:20:12.368] plan(): Setting new future strategy stack:
[10:20:12.368] List of future strategies:
[10:20:12.368] 1. sequential:
[10:20:12.368]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:12.368]    - tweaked: FALSE
[10:20:12.368]    - call: NULL
[10:20:12.369] plan(): nbrOfWorkers() = 1
[10:20:12.871] plan(): Setting new future strategy stack:
[10:20:12.871] List of future strategies:
[10:20:12.871] 1. multisession:
[10:20:12.871]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:20:12.871]    - tweaked: FALSE
[10:20:12.871]    - call: plan(strategy)
[10:20:12.873] plan(): nbrOfWorkers() = 1
[10:20:12.873] SequentialFuture started (and completed)
[10:20:12.873] - Launch lazy future ... done
[10:20:12.873] run() for ‘SequentialFuture’ ... done
[10:20:12.873] Created future:
[10:20:12.873] SequentialFuture:
[10:20:12.873] Label: ‘future_lapply-1’
[10:20:12.873] Expression:
[10:20:12.873] {
[10:20:12.873]     do.call(function(...) {
[10:20:12.873]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:12.873]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:12.873]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:12.873]             on.exit(options(oopts), add = TRUE)
[10:20:12.873]         }
[10:20:12.873]         {
[10:20:12.873]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:12.873]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:12.873]                 ...future.FUN(...future.X_jj, ...)
[10:20:12.873]             })
[10:20:12.873]         }
[10:20:12.873]     }, args = future.call.arguments)
[10:20:12.873] }
[10:20:12.873] Lazy evaluation: FALSE
[10:20:12.873] Asynchronous evaluation: FALSE
[10:20:12.873] Local evaluation: TRUE
[10:20:12.873] Environment: R_GlobalEnv
[10:20:12.873] Capture standard output: NA
[10:20:12.873] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:12.873] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:12.873] Packages: <none>
[10:20:12.873] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:12.873] Resolved: TRUE
[10:20:12.873] Value: 55 bytes of class ‘list’
[10:20:12.873] Early signaling: FALSE
[10:20:12.873] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:12.873] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:12.874] Chunk #1 of 1 ... DONE
[10:20:12.874] Launching 1 futures (chunks) ... DONE
[10:20:12.874] Resolving 1 futures (chunks) ...
[10:20:12.874] resolve() on list ...
[10:20:12.874]  recursive: 0
[10:20:12.875]  length: 1
[10:20:12.875] 
[10:20:12.875] resolved() for ‘SequentialFuture’ ...
[10:20:12.875] - state: ‘finished’
[10:20:12.875] - run: TRUE
[10:20:12.875] - result: ‘FutureResult’
[10:20:12.875] resolved() for ‘SequentialFuture’ ... done
[10:20:12.875] Future #1
[10:20:12.875] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:20:12.876] - nx: 1
[10:20:12.876] - relay: TRUE
[10:20:12.876] - stdout: TRUE
[10:20:12.876] - signal: TRUE
[10:20:12.876] - resignal: FALSE
[10:20:12.876] - force: TRUE
[10:20:12.876] - relayed: [n=1] FALSE
[10:20:12.876] - queued futures: [n=1] FALSE
[10:20:12.876]  - until=1
[10:20:12.876]  - relaying element #1
[10:20:12.876] - relayed: [n=1] TRUE
[10:20:12.876] - queued futures: [n=1] TRUE
[10:20:12.877] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:20:12.877]  length: 0 (resolved future 1)
[10:20:12.877] Relaying remaining futures
[10:20:12.877] signalConditionsASAP(NULL, pos=0) ...
[10:20:12.877] - nx: 1
[10:20:12.877] - relay: TRUE
[10:20:12.877] - stdout: TRUE
[10:20:12.877] - signal: TRUE
[10:20:12.877] - resignal: FALSE
[10:20:12.877] - force: TRUE
[10:20:12.877] - relayed: [n=1] TRUE
[10:20:12.877] - queued futures: [n=1] TRUE
 - flush all
[10:20:12.878] - relayed: [n=1] TRUE
[10:20:12.878] - queued futures: [n=1] TRUE
[10:20:12.878] signalConditionsASAP(NULL, pos=0) ... done
[10:20:12.878] resolve() on list ... DONE
[10:20:12.878]  - Number of value chunks collected: 1
[10:20:12.878] Resolving 1 futures (chunks) ... DONE
[10:20:12.878] Reducing values from 1 chunks ...
[10:20:12.878]  - Number of values collected after concatenation: 2
[10:20:12.878]  - Number of values expected: 2
[10:20:12.878] Reducing values from 1 chunks ... DONE
[10:20:12.879] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[10:20:12.879] future_mapply() ...
[10:20:12.880] Number of chunks: 1
[10:20:12.880] getGlobalsAndPackagesXApply() ...
[10:20:12.880]  - future.globals: TRUE
[10:20:12.881] getGlobalsAndPackages() ...
[10:20:12.882] Searching for globals...
[10:20:12.884] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:20:12.884] Searching for globals ... DONE
[10:20:12.884] Resolving globals: FALSE
[10:20:12.885] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[10:20:12.885] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[10:20:12.885] - globals: [1] ‘FUN’
[10:20:12.885] 
[10:20:12.885] getGlobalsAndPackages() ... DONE
[10:20:12.885]  - globals found/used: [n=1] ‘FUN’
[10:20:12.886]  - needed namespaces: [n=0] 
[10:20:12.886] Finding globals ... DONE
[10:20:12.886] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:20:12.886] List of 2
[10:20:12.886]  $ ...future.FUN:function (x, y)  
[10:20:12.886]  $ MoreArgs     : NULL
[10:20:12.886]  - attr(*, "where")=List of 2
[10:20:12.886]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:12.886]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:20:12.886]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:12.886]  - attr(*, "resolved")= logi FALSE
[10:20:12.886]  - attr(*, "total_size")= num NA
[10:20:12.888] Packages to be attached in all futures: [n=0] 
[10:20:12.888] getGlobalsAndPackagesXApply() ... DONE
[10:20:12.889] Number of futures (= number of chunks): 1
[10:20:12.889] Launching 1 futures (chunks) ...
[10:20:12.889] Chunk #1 of 1 ...
[10:20:12.889]  - Finding globals in '...' for chunk #1 ...
[10:20:12.889] getGlobalsAndPackages() ...
[10:20:12.889] Searching for globals...
[10:20:12.889] 
[10:20:12.890] Searching for globals ... DONE
[10:20:12.890] - globals: [0] <none>
[10:20:12.890] getGlobalsAndPackages() ... DONE
[10:20:12.890]    + additional globals found: [n=0] 
[10:20:12.890]    + additional namespaces needed: [n=0] 
[10:20:12.890]  - Finding globals in '...' for chunk #1 ... DONE
[10:20:12.890]  - seeds: <none>
[10:20:12.890]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:12.890] getGlobalsAndPackages() ...
[10:20:12.890] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:12.890] Resolving globals: FALSE
[10:20:12.891] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[10:20:12.891] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:20:12.891] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:12.891] 
[10:20:12.892] getGlobalsAndPackages() ... DONE
[10:20:12.892] run() for ‘Future’ ...
[10:20:12.892] - state: ‘created’
[10:20:12.892] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:20:12.893] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:12.894] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:12.894]   - Field: ‘label’
[10:20:12.894]   - Field: ‘local’
[10:20:12.894]   - Field: ‘owner’
[10:20:12.894]   - Field: ‘envir’
[10:20:12.894]   - Field: ‘packages’
[10:20:12.894]   - Field: ‘gc’
[10:20:12.894]   - Field: ‘conditions’
[10:20:12.894]   - Field: ‘expr’
[10:20:12.894]   - Field: ‘uuid’
[10:20:12.895]   - Field: ‘seed’
[10:20:12.895]   - Field: ‘version’
[10:20:12.895]   - Field: ‘result’
[10:20:12.895]   - Field: ‘asynchronous’
[10:20:12.895]   - Field: ‘calls’
[10:20:12.895]   - Field: ‘globals’
[10:20:12.895]   - Field: ‘stdout’
[10:20:12.895]   - Field: ‘earlySignal’
[10:20:12.895]   - Field: ‘lazy’
[10:20:12.895]   - Field: ‘state’
[10:20:12.895] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:12.895] - Launch lazy future ...
[10:20:12.896] Packages needed by the future expression (n = 0): <none>
[10:20:12.896] Packages needed by future strategies (n = 0): <none>
[10:20:12.896] {
[10:20:12.896]     {
[10:20:12.896]         {
[10:20:12.896]             ...future.startTime <- base::Sys.time()
[10:20:12.896]             {
[10:20:12.896]                 {
[10:20:12.896]                   {
[10:20:12.896]                     base::local({
[10:20:12.896]                       has_future <- base::requireNamespace("future", 
[10:20:12.896]                         quietly = TRUE)
[10:20:12.896]                       if (has_future) {
[10:20:12.896]                         ns <- base::getNamespace("future")
[10:20:12.896]                         version <- ns[[".package"]][["version"]]
[10:20:12.896]                         if (is.null(version)) 
[10:20:12.896]                           version <- utils::packageVersion("future")
[10:20:12.896]                       }
[10:20:12.896]                       else {
[10:20:12.896]                         version <- NULL
[10:20:12.896]                       }
[10:20:12.896]                       if (!has_future || version < "1.8.0") {
[10:20:12.896]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:12.896]                           "", base::R.version$version.string), 
[10:20:12.896]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:12.896]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:12.896]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:12.896]                             "release", "version")], collapse = " "), 
[10:20:12.896]                           hostname = base::Sys.info()[["nodename"]])
[10:20:12.896]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:12.896]                           info)
[10:20:12.896]                         info <- base::paste(info, collapse = "; ")
[10:20:12.896]                         if (!has_future) {
[10:20:12.896]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:12.896]                             info)
[10:20:12.896]                         }
[10:20:12.896]                         else {
[10:20:12.896]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:12.896]                             info, version)
[10:20:12.896]                         }
[10:20:12.896]                         base::stop(msg)
[10:20:12.896]                       }
[10:20:12.896]                     })
[10:20:12.896]                   }
[10:20:12.896]                   ...future.strategy.old <- future::plan("list")
[10:20:12.896]                   options(future.plan = NULL)
[10:20:12.896]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:12.896]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:12.896]                 }
[10:20:12.896]                 ...future.workdir <- getwd()
[10:20:12.896]             }
[10:20:12.896]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:12.896]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:12.896]         }
[10:20:12.896]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:12.896]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:12.896]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:12.896]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:12.896]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:12.896]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:12.896]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:12.896]             base::names(...future.oldOptions))
[10:20:12.896]     }
[10:20:12.896]     if (FALSE) {
[10:20:12.896]     }
[10:20:12.896]     else {
[10:20:12.896]         if (FALSE) {
[10:20:12.896]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:12.896]                 open = "w")
[10:20:12.896]         }
[10:20:12.896]         else {
[10:20:12.896]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:12.896]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:12.896]         }
[10:20:12.896]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:12.896]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:12.896]             base::sink(type = "output", split = FALSE)
[10:20:12.896]             base::close(...future.stdout)
[10:20:12.896]         }, add = TRUE)
[10:20:12.896]     }
[10:20:12.896]     ...future.frame <- base::sys.nframe()
[10:20:12.896]     ...future.conditions <- base::list()
[10:20:12.896]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:12.896]     if (FALSE) {
[10:20:12.896]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:12.896]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:12.896]     }
[10:20:12.896]     ...future.result <- base::tryCatch({
[10:20:12.896]         base::withCallingHandlers({
[10:20:12.896]             ...future.value <- base::withVisible(base::local({
[10:20:12.896]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:12.896]                 if (!identical(...future.globals.maxSize.org, 
[10:20:12.896]                   ...future.globals.maxSize)) {
[10:20:12.896]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:12.896]                   on.exit(options(oopts), add = TRUE)
[10:20:12.896]                 }
[10:20:12.896]                 {
[10:20:12.896]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:12.896]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:20:12.896]                     USE.NAMES = FALSE)
[10:20:12.896]                   do.call(mapply, args = args)
[10:20:12.896]                 }
[10:20:12.896]             }))
[10:20:12.896]             future::FutureResult(value = ...future.value$value, 
[10:20:12.896]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:12.896]                   ...future.rng), globalenv = if (FALSE) 
[10:20:12.896]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:12.896]                     ...future.globalenv.names))
[10:20:12.896]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:12.896]         }, condition = base::local({
[10:20:12.896]             c <- base::c
[10:20:12.896]             inherits <- base::inherits
[10:20:12.896]             invokeRestart <- base::invokeRestart
[10:20:12.896]             length <- base::length
[10:20:12.896]             list <- base::list
[10:20:12.896]             seq.int <- base::seq.int
[10:20:12.896]             signalCondition <- base::signalCondition
[10:20:12.896]             sys.calls <- base::sys.calls
[10:20:12.896]             `[[` <- base::`[[`
[10:20:12.896]             `+` <- base::`+`
[10:20:12.896]             `<<-` <- base::`<<-`
[10:20:12.896]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:12.896]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:12.896]                   3L)]
[10:20:12.896]             }
[10:20:12.896]             function(cond) {
[10:20:12.896]                 is_error <- inherits(cond, "error")
[10:20:12.896]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:12.896]                   NULL)
[10:20:12.896]                 if (is_error) {
[10:20:12.896]                   sessionInformation <- function() {
[10:20:12.896]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:12.896]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:12.896]                       search = base::search(), system = base::Sys.info())
[10:20:12.896]                   }
[10:20:12.896]                   ...future.conditions[[length(...future.conditions) + 
[10:20:12.896]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:12.896]                     cond$call), session = sessionInformation(), 
[10:20:12.896]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:12.896]                   signalCondition(cond)
[10:20:12.896]                 }
[10:20:12.896]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:12.896]                 "immediateCondition"))) {
[10:20:12.896]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:12.896]                   ...future.conditions[[length(...future.conditions) + 
[10:20:12.896]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:12.896]                   if (TRUE && !signal) {
[10:20:12.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:12.896]                     {
[10:20:12.896]                       inherits <- base::inherits
[10:20:12.896]                       invokeRestart <- base::invokeRestart
[10:20:12.896]                       is.null <- base::is.null
[10:20:12.896]                       muffled <- FALSE
[10:20:12.896]                       if (inherits(cond, "message")) {
[10:20:12.896]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:12.896]                         if (muffled) 
[10:20:12.896]                           invokeRestart("muffleMessage")
[10:20:12.896]                       }
[10:20:12.896]                       else if (inherits(cond, "warning")) {
[10:20:12.896]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:12.896]                         if (muffled) 
[10:20:12.896]                           invokeRestart("muffleWarning")
[10:20:12.896]                       }
[10:20:12.896]                       else if (inherits(cond, "condition")) {
[10:20:12.896]                         if (!is.null(pattern)) {
[10:20:12.896]                           computeRestarts <- base::computeRestarts
[10:20:12.896]                           grepl <- base::grepl
[10:20:12.896]                           restarts <- computeRestarts(cond)
[10:20:12.896]                           for (restart in restarts) {
[10:20:12.896]                             name <- restart$name
[10:20:12.896]                             if (is.null(name)) 
[10:20:12.896]                               next
[10:20:12.896]                             if (!grepl(pattern, name)) 
[10:20:12.896]                               next
[10:20:12.896]                             invokeRestart(restart)
[10:20:12.896]                             muffled <- TRUE
[10:20:12.896]                             break
[10:20:12.896]                           }
[10:20:12.896]                         }
[10:20:12.896]                       }
[10:20:12.896]                       invisible(muffled)
[10:20:12.896]                     }
[10:20:12.896]                     muffleCondition(cond, pattern = "^muffle")
[10:20:12.896]                   }
[10:20:12.896]                 }
[10:20:12.896]                 else {
[10:20:12.896]                   if (TRUE) {
[10:20:12.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:12.896]                     {
[10:20:12.896]                       inherits <- base::inherits
[10:20:12.896]                       invokeRestart <- base::invokeRestart
[10:20:12.896]                       is.null <- base::is.null
[10:20:12.896]                       muffled <- FALSE
[10:20:12.896]                       if (inherits(cond, "message")) {
[10:20:12.896]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:12.896]                         if (muffled) 
[10:20:12.896]                           invokeRestart("muffleMessage")
[10:20:12.896]                       }
[10:20:12.896]                       else if (inherits(cond, "warning")) {
[10:20:12.896]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:12.896]                         if (muffled) 
[10:20:12.896]                           invokeRestart("muffleWarning")
[10:20:12.896]                       }
[10:20:12.896]                       else if (inherits(cond, "condition")) {
[10:20:12.896]                         if (!is.null(pattern)) {
[10:20:12.896]                           computeRestarts <- base::computeRestarts
[10:20:12.896]                           grepl <- base::grepl
[10:20:12.896]                           restarts <- computeRestarts(cond)
[10:20:12.896]                           for (restart in restarts) {
[10:20:12.896]                             name <- restart$name
[10:20:12.896]                             if (is.null(name)) 
[10:20:12.896]                               next
[10:20:12.896]                             if (!grepl(pattern, name)) 
[10:20:12.896]                               next
[10:20:12.896]                             invokeRestart(restart)
[10:20:12.896]                             muffled <- TRUE
[10:20:12.896]                             break
[10:20:12.896]                           }
[10:20:12.896]                         }
[10:20:12.896]                       }
[10:20:12.896]                       invisible(muffled)
[10:20:12.896]                     }
[10:20:12.896]                     muffleCondition(cond, pattern = "^muffle")
[10:20:12.896]                   }
[10:20:12.896]                 }
[10:20:12.896]             }
[10:20:12.896]         }))
[10:20:12.896]     }, error = function(ex) {
[10:20:12.896]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:12.896]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:12.896]                 ...future.rng), started = ...future.startTime, 
[10:20:12.896]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:12.896]             version = "1.8"), class = "FutureResult")
[10:20:12.896]     }, finally = {
[10:20:12.896]         if (!identical(...future.workdir, getwd())) 
[10:20:12.896]             setwd(...future.workdir)
[10:20:12.896]         {
[10:20:12.896]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:12.896]                 ...future.oldOptions$nwarnings <- NULL
[10:20:12.896]             }
[10:20:12.896]             base::options(...future.oldOptions)
[10:20:12.896]             if (.Platform$OS.type == "windows") {
[10:20:12.896]                 old_names <- names(...future.oldEnvVars)
[10:20:12.896]                 envs <- base::Sys.getenv()
[10:20:12.896]                 names <- names(envs)
[10:20:12.896]                 common <- intersect(names, old_names)
[10:20:12.896]                 added <- setdiff(names, old_names)
[10:20:12.896]                 removed <- setdiff(old_names, names)
[10:20:12.896]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:12.896]                   envs[common]]
[10:20:12.896]                 NAMES <- toupper(changed)
[10:20:12.896]                 args <- list()
[10:20:12.896]                 for (kk in seq_along(NAMES)) {
[10:20:12.896]                   name <- changed[[kk]]
[10:20:12.896]                   NAME <- NAMES[[kk]]
[10:20:12.896]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:12.896]                     next
[10:20:12.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:12.896]                 }
[10:20:12.896]                 NAMES <- toupper(added)
[10:20:12.896]                 for (kk in seq_along(NAMES)) {
[10:20:12.896]                   name <- added[[kk]]
[10:20:12.896]                   NAME <- NAMES[[kk]]
[10:20:12.896]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:12.896]                     next
[10:20:12.896]                   args[[name]] <- ""
[10:20:12.896]                 }
[10:20:12.896]                 NAMES <- toupper(removed)
[10:20:12.896]                 for (kk in seq_along(NAMES)) {
[10:20:12.896]                   name <- removed[[kk]]
[10:20:12.896]                   NAME <- NAMES[[kk]]
[10:20:12.896]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:12.896]                     next
[10:20:12.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:12.896]                 }
[10:20:12.896]                 if (length(args) > 0) 
[10:20:12.896]                   base::do.call(base::Sys.setenv, args = args)
[10:20:12.896]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:12.896]             }
[10:20:12.896]             else {
[10:20:12.896]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:12.896]             }
[10:20:12.896]             {
[10:20:12.896]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:12.896]                   0L) {
[10:20:12.896]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:12.896]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:12.896]                   base::options(opts)
[10:20:12.896]                 }
[10:20:12.896]                 {
[10:20:12.896]                   {
[10:20:12.896]                     NULL
[10:20:12.896]                     RNGkind("Mersenne-Twister")
[10:20:12.896]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:12.896]                       inherits = FALSE)
[10:20:12.896]                   }
[10:20:12.896]                   options(future.plan = NULL)
[10:20:12.896]                   if (is.na(NA_character_)) 
[10:20:12.896]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:12.896]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:12.896]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:12.896]                     .init = FALSE)
[10:20:12.896]                 }
[10:20:12.896]             }
[10:20:12.896]         }
[10:20:12.896]     })
[10:20:12.896]     if (TRUE) {
[10:20:12.896]         base::sink(type = "output", split = FALSE)
[10:20:12.896]         if (FALSE) {
[10:20:12.896]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:12.896]         }
[10:20:12.896]         else {
[10:20:12.896]             ...future.result["stdout"] <- base::list(NULL)
[10:20:12.896]         }
[10:20:12.896]         base::close(...future.stdout)
[10:20:12.896]         ...future.stdout <- NULL
[10:20:12.896]     }
[10:20:12.896]     ...future.result$conditions <- ...future.conditions
[10:20:12.896]     ...future.result$finished <- base::Sys.time()
[10:20:12.896]     ...future.result
[10:20:12.896] }
[10:20:12.898] assign_globals() ...
[10:20:12.898] List of 5
[10:20:12.898]  $ ...future.FUN            :function (x, y)  
[10:20:12.898]  $ MoreArgs                 : NULL
[10:20:12.898]  $ ...future.elements_ii    :List of 2
[10:20:12.898]   ..$ :List of 2
[10:20:12.898]   .. ..$ : int 1
[10:20:12.898]   .. ..$ : int 0
[10:20:12.898]   ..$ :List of 2
[10:20:12.898]   .. ..$ : int 0
[10:20:12.898]   .. ..$ : int 1
[10:20:12.898]  $ ...future.seeds_ii       : NULL
[10:20:12.898]  $ ...future.globals.maxSize: NULL
[10:20:12.898]  - attr(*, "where")=List of 5
[10:20:12.898]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:12.898]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:20:12.898]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:12.898]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:12.898]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:12.898]  - attr(*, "resolved")= logi FALSE
[10:20:12.898]  - attr(*, "total_size")= num 1242
[10:20:12.898]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:12.898]  - attr(*, "already-done")= logi TRUE
[10:20:12.903] - reassign environment for ‘...future.FUN’
[10:20:12.904] - copied ‘...future.FUN’ to environment
[10:20:12.904] - copied ‘MoreArgs’ to environment
[10:20:12.904] - copied ‘...future.elements_ii’ to environment
[10:20:12.904] - copied ‘...future.seeds_ii’ to environment
[10:20:12.904] - copied ‘...future.globals.maxSize’ to environment
[10:20:12.904] assign_globals() ... done
[10:20:12.904] plan(): Setting new future strategy stack:
[10:20:12.904] List of future strategies:
[10:20:12.904] 1. sequential:
[10:20:12.904]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:12.904]    - tweaked: FALSE
[10:20:12.904]    - call: NULL
[10:20:12.905] plan(): nbrOfWorkers() = 1
[10:20:13.407] plan(): Setting new future strategy stack:
[10:20:13.407] List of future strategies:
[10:20:13.407] 1. multisession:
[10:20:13.407]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:20:13.407]    - tweaked: FALSE
[10:20:13.407]    - call: plan(strategy)
[10:20:13.409] plan(): nbrOfWorkers() = 1
[10:20:13.409] SequentialFuture started (and completed)
[10:20:13.409] - Launch lazy future ... done
[10:20:13.409] run() for ‘SequentialFuture’ ... done
[10:20:13.409] Created future:
[10:20:13.409] SequentialFuture:
[10:20:13.409] Label: ‘future_mapply-1’
[10:20:13.409] Expression:
[10:20:13.409] {
[10:20:13.409]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:13.409]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:13.409]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:13.409]         on.exit(options(oopts), add = TRUE)
[10:20:13.409]     }
[10:20:13.409]     {
[10:20:13.409]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:13.409]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:20:13.409]         do.call(mapply, args = args)
[10:20:13.409]     }
[10:20:13.409] }
[10:20:13.409] Lazy evaluation: FALSE
[10:20:13.409] Asynchronous evaluation: FALSE
[10:20:13.409] Local evaluation: TRUE
[10:20:13.409] Environment: R_GlobalEnv
[10:20:13.409] Capture standard output: FALSE
[10:20:13.409] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:13.409] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:13.409] Packages: <none>
[10:20:13.409] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:13.409] Resolved: TRUE
[10:20:13.409] Value: 184 bytes of class ‘list’
[10:20:13.409] Early signaling: FALSE
[10:20:13.409] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:13.409] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:13.412] Chunk #1 of 1 ... DONE
[10:20:13.412] Launching 1 futures (chunks) ... DONE
[10:20:13.412] Resolving 1 futures (chunks) ...
[10:20:13.412] resolve() on list ...
[10:20:13.413]  recursive: 0
[10:20:13.413]  length: 1
[10:20:13.413] 
[10:20:13.413] resolved() for ‘SequentialFuture’ ...
[10:20:13.413] - state: ‘finished’
[10:20:13.413] - run: TRUE
[10:20:13.413] - result: ‘FutureResult’
[10:20:13.413] resolved() for ‘SequentialFuture’ ... done
[10:20:13.413] Future #1
[10:20:13.414] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:20:13.414] - nx: 1
[10:20:13.414] - relay: TRUE
[10:20:13.414] - stdout: TRUE
[10:20:13.414] - signal: TRUE
[10:20:13.414] - resignal: FALSE
[10:20:13.414] - force: TRUE
[10:20:13.414] - relayed: [n=1] FALSE
[10:20:13.414] - queued futures: [n=1] FALSE
[10:20:13.415]  - until=1
[10:20:13.415]  - relaying element #1
[10:20:13.415] - relayed: [n=1] TRUE
[10:20:13.415] - queued futures: [n=1] TRUE
[10:20:13.415] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:20:13.415]  length: 0 (resolved future 1)
[10:20:13.415] Relaying remaining futures
[10:20:13.415] signalConditionsASAP(NULL, pos=0) ...
[10:20:13.415] - nx: 1
[10:20:13.415] - relay: TRUE
[10:20:13.415] - stdout: TRUE
[10:20:13.416] - signal: TRUE
[10:20:13.416] - resignal: FALSE
[10:20:13.416] - force: TRUE
[10:20:13.416] - relayed: [n=1] TRUE
[10:20:13.416] - queued futures: [n=1] TRUE
 - flush all
[10:20:13.416] - relayed: [n=1] TRUE
[10:20:13.416] - queued futures: [n=1] TRUE
[10:20:13.416] signalConditionsASAP(NULL, pos=0) ... done
[10:20:13.416] resolve() on list ... DONE
[10:20:13.416]  - Number of value chunks collected: 1
[10:20:13.416] Resolving 1 futures (chunks) ... DONE
[10:20:13.417] Reducing values from 1 chunks ...
[10:20:13.417]  - Number of values collected after concatenation: 2
[10:20:13.417]  - Number of values expected: 2
[10:20:13.417] Reducing values from 1 chunks ... DONE
[10:20:13.417] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[10:20:13.417] future_mapply() ...
[10:20:13.419] Number of chunks: 1
[10:20:13.419] getGlobalsAndPackagesXApply() ...
[10:20:13.419]  - future.globals: TRUE
[10:20:13.419] getGlobalsAndPackages() ...
[10:20:13.419] Searching for globals...
[10:20:13.421] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:20:13.421] Searching for globals ... DONE
[10:20:13.421] Resolving globals: FALSE
[10:20:13.421] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[10:20:13.422] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[10:20:13.422] - globals: [1] ‘FUN’
[10:20:13.422] 
[10:20:13.422] getGlobalsAndPackages() ... DONE
[10:20:13.422]  - globals found/used: [n=1] ‘FUN’
[10:20:13.422]  - needed namespaces: [n=0] 
[10:20:13.422] Finding globals ... DONE
[10:20:13.422] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:20:13.422] List of 2
[10:20:13.422]  $ ...future.FUN:function (x, y)  
[10:20:13.422]  $ MoreArgs     : NULL
[10:20:13.422]  - attr(*, "where")=List of 2
[10:20:13.422]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:13.422]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:20:13.422]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:13.422]  - attr(*, "resolved")= logi FALSE
[10:20:13.422]  - attr(*, "total_size")= num NA
[10:20:13.425] Packages to be attached in all futures: [n=0] 
[10:20:13.425] getGlobalsAndPackagesXApply() ... DONE
[10:20:13.425] Number of futures (= number of chunks): 1
[10:20:13.425] Launching 1 futures (chunks) ...
[10:20:13.425] Chunk #1 of 1 ...
[10:20:13.426]  - Finding globals in '...' for chunk #1 ...
[10:20:13.426] getGlobalsAndPackages() ...
[10:20:13.426] Searching for globals...
[10:20:13.426] 
[10:20:13.426] Searching for globals ... DONE
[10:20:13.426] - globals: [0] <none>
[10:20:13.426] getGlobalsAndPackages() ... DONE
[10:20:13.426]    + additional globals found: [n=0] 
[10:20:13.426]    + additional namespaces needed: [n=0] 
[10:20:13.427]  - Finding globals in '...' for chunk #1 ... DONE
[10:20:13.427]  - seeds: <none>
[10:20:13.427]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:13.427] getGlobalsAndPackages() ...
[10:20:13.427] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:13.427] Resolving globals: FALSE
[10:20:13.427] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[10:20:13.428] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:20:13.428] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:13.428] 
[10:20:13.428] getGlobalsAndPackages() ... DONE
[10:20:13.428] run() for ‘Future’ ...
[10:20:13.429] - state: ‘created’
[10:20:13.429] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:20:13.430] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:13.430] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:13.430]   - Field: ‘label’
[10:20:13.430]   - Field: ‘local’
[10:20:13.431]   - Field: ‘owner’
[10:20:13.431]   - Field: ‘envir’
[10:20:13.431]   - Field: ‘packages’
[10:20:13.431]   - Field: ‘gc’
[10:20:13.431]   - Field: ‘conditions’
[10:20:13.431]   - Field: ‘expr’
[10:20:13.431]   - Field: ‘uuid’
[10:20:13.431]   - Field: ‘seed’
[10:20:13.431]   - Field: ‘version’
[10:20:13.431]   - Field: ‘result’
[10:20:13.431]   - Field: ‘asynchronous’
[10:20:13.431]   - Field: ‘calls’
[10:20:13.432]   - Field: ‘globals’
[10:20:13.432]   - Field: ‘stdout’
[10:20:13.432]   - Field: ‘earlySignal’
[10:20:13.432]   - Field: ‘lazy’
[10:20:13.432]   - Field: ‘state’
[10:20:13.432] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:13.432] - Launch lazy future ...
[10:20:13.432] Packages needed by the future expression (n = 0): <none>
[10:20:13.432] Packages needed by future strategies (n = 0): <none>
[10:20:13.433] {
[10:20:13.433]     {
[10:20:13.433]         {
[10:20:13.433]             ...future.startTime <- base::Sys.time()
[10:20:13.433]             {
[10:20:13.433]                 {
[10:20:13.433]                   {
[10:20:13.433]                     base::local({
[10:20:13.433]                       has_future <- base::requireNamespace("future", 
[10:20:13.433]                         quietly = TRUE)
[10:20:13.433]                       if (has_future) {
[10:20:13.433]                         ns <- base::getNamespace("future")
[10:20:13.433]                         version <- ns[[".package"]][["version"]]
[10:20:13.433]                         if (is.null(version)) 
[10:20:13.433]                           version <- utils::packageVersion("future")
[10:20:13.433]                       }
[10:20:13.433]                       else {
[10:20:13.433]                         version <- NULL
[10:20:13.433]                       }
[10:20:13.433]                       if (!has_future || version < "1.8.0") {
[10:20:13.433]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:13.433]                           "", base::R.version$version.string), 
[10:20:13.433]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:13.433]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:13.433]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:13.433]                             "release", "version")], collapse = " "), 
[10:20:13.433]                           hostname = base::Sys.info()[["nodename"]])
[10:20:13.433]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:13.433]                           info)
[10:20:13.433]                         info <- base::paste(info, collapse = "; ")
[10:20:13.433]                         if (!has_future) {
[10:20:13.433]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:13.433]                             info)
[10:20:13.433]                         }
[10:20:13.433]                         else {
[10:20:13.433]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:13.433]                             info, version)
[10:20:13.433]                         }
[10:20:13.433]                         base::stop(msg)
[10:20:13.433]                       }
[10:20:13.433]                     })
[10:20:13.433]                   }
[10:20:13.433]                   ...future.strategy.old <- future::plan("list")
[10:20:13.433]                   options(future.plan = NULL)
[10:20:13.433]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:13.433]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:13.433]                 }
[10:20:13.433]                 ...future.workdir <- getwd()
[10:20:13.433]             }
[10:20:13.433]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:13.433]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:13.433]         }
[10:20:13.433]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:13.433]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:13.433]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:13.433]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:13.433]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:13.433]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:13.433]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:13.433]             base::names(...future.oldOptions))
[10:20:13.433]     }
[10:20:13.433]     if (FALSE) {
[10:20:13.433]     }
[10:20:13.433]     else {
[10:20:13.433]         if (TRUE) {
[10:20:13.433]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:13.433]                 open = "w")
[10:20:13.433]         }
[10:20:13.433]         else {
[10:20:13.433]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:13.433]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:13.433]         }
[10:20:13.433]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:13.433]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:13.433]             base::sink(type = "output", split = FALSE)
[10:20:13.433]             base::close(...future.stdout)
[10:20:13.433]         }, add = TRUE)
[10:20:13.433]     }
[10:20:13.433]     ...future.frame <- base::sys.nframe()
[10:20:13.433]     ...future.conditions <- base::list()
[10:20:13.433]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:13.433]     if (FALSE) {
[10:20:13.433]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:13.433]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:13.433]     }
[10:20:13.433]     ...future.result <- base::tryCatch({
[10:20:13.433]         base::withCallingHandlers({
[10:20:13.433]             ...future.value <- base::withVisible(base::local({
[10:20:13.433]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:13.433]                 if (!identical(...future.globals.maxSize.org, 
[10:20:13.433]                   ...future.globals.maxSize)) {
[10:20:13.433]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:13.433]                   on.exit(options(oopts), add = TRUE)
[10:20:13.433]                 }
[10:20:13.433]                 {
[10:20:13.433]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:13.433]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:20:13.433]                     USE.NAMES = FALSE)
[10:20:13.433]                   do.call(mapply, args = args)
[10:20:13.433]                 }
[10:20:13.433]             }))
[10:20:13.433]             future::FutureResult(value = ...future.value$value, 
[10:20:13.433]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:13.433]                   ...future.rng), globalenv = if (FALSE) 
[10:20:13.433]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:13.433]                     ...future.globalenv.names))
[10:20:13.433]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:13.433]         }, condition = base::local({
[10:20:13.433]             c <- base::c
[10:20:13.433]             inherits <- base::inherits
[10:20:13.433]             invokeRestart <- base::invokeRestart
[10:20:13.433]             length <- base::length
[10:20:13.433]             list <- base::list
[10:20:13.433]             seq.int <- base::seq.int
[10:20:13.433]             signalCondition <- base::signalCondition
[10:20:13.433]             sys.calls <- base::sys.calls
[10:20:13.433]             `[[` <- base::`[[`
[10:20:13.433]             `+` <- base::`+`
[10:20:13.433]             `<<-` <- base::`<<-`
[10:20:13.433]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:13.433]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:13.433]                   3L)]
[10:20:13.433]             }
[10:20:13.433]             function(cond) {
[10:20:13.433]                 is_error <- inherits(cond, "error")
[10:20:13.433]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:13.433]                   NULL)
[10:20:13.433]                 if (is_error) {
[10:20:13.433]                   sessionInformation <- function() {
[10:20:13.433]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:13.433]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:13.433]                       search = base::search(), system = base::Sys.info())
[10:20:13.433]                   }
[10:20:13.433]                   ...future.conditions[[length(...future.conditions) + 
[10:20:13.433]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:13.433]                     cond$call), session = sessionInformation(), 
[10:20:13.433]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:13.433]                   signalCondition(cond)
[10:20:13.433]                 }
[10:20:13.433]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:13.433]                 "immediateCondition"))) {
[10:20:13.433]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:13.433]                   ...future.conditions[[length(...future.conditions) + 
[10:20:13.433]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:13.433]                   if (TRUE && !signal) {
[10:20:13.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:13.433]                     {
[10:20:13.433]                       inherits <- base::inherits
[10:20:13.433]                       invokeRestart <- base::invokeRestart
[10:20:13.433]                       is.null <- base::is.null
[10:20:13.433]                       muffled <- FALSE
[10:20:13.433]                       if (inherits(cond, "message")) {
[10:20:13.433]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:13.433]                         if (muffled) 
[10:20:13.433]                           invokeRestart("muffleMessage")
[10:20:13.433]                       }
[10:20:13.433]                       else if (inherits(cond, "warning")) {
[10:20:13.433]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:13.433]                         if (muffled) 
[10:20:13.433]                           invokeRestart("muffleWarning")
[10:20:13.433]                       }
[10:20:13.433]                       else if (inherits(cond, "condition")) {
[10:20:13.433]                         if (!is.null(pattern)) {
[10:20:13.433]                           computeRestarts <- base::computeRestarts
[10:20:13.433]                           grepl <- base::grepl
[10:20:13.433]                           restarts <- computeRestarts(cond)
[10:20:13.433]                           for (restart in restarts) {
[10:20:13.433]                             name <- restart$name
[10:20:13.433]                             if (is.null(name)) 
[10:20:13.433]                               next
[10:20:13.433]                             if (!grepl(pattern, name)) 
[10:20:13.433]                               next
[10:20:13.433]                             invokeRestart(restart)
[10:20:13.433]                             muffled <- TRUE
[10:20:13.433]                             break
[10:20:13.433]                           }
[10:20:13.433]                         }
[10:20:13.433]                       }
[10:20:13.433]                       invisible(muffled)
[10:20:13.433]                     }
[10:20:13.433]                     muffleCondition(cond, pattern = "^muffle")
[10:20:13.433]                   }
[10:20:13.433]                 }
[10:20:13.433]                 else {
[10:20:13.433]                   if (TRUE) {
[10:20:13.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:13.433]                     {
[10:20:13.433]                       inherits <- base::inherits
[10:20:13.433]                       invokeRestart <- base::invokeRestart
[10:20:13.433]                       is.null <- base::is.null
[10:20:13.433]                       muffled <- FALSE
[10:20:13.433]                       if (inherits(cond, "message")) {
[10:20:13.433]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:13.433]                         if (muffled) 
[10:20:13.433]                           invokeRestart("muffleMessage")
[10:20:13.433]                       }
[10:20:13.433]                       else if (inherits(cond, "warning")) {
[10:20:13.433]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:13.433]                         if (muffled) 
[10:20:13.433]                           invokeRestart("muffleWarning")
[10:20:13.433]                       }
[10:20:13.433]                       else if (inherits(cond, "condition")) {
[10:20:13.433]                         if (!is.null(pattern)) {
[10:20:13.433]                           computeRestarts <- base::computeRestarts
[10:20:13.433]                           grepl <- base::grepl
[10:20:13.433]                           restarts <- computeRestarts(cond)
[10:20:13.433]                           for (restart in restarts) {
[10:20:13.433]                             name <- restart$name
[10:20:13.433]                             if (is.null(name)) 
[10:20:13.433]                               next
[10:20:13.433]                             if (!grepl(pattern, name)) 
[10:20:13.433]                               next
[10:20:13.433]                             invokeRestart(restart)
[10:20:13.433]                             muffled <- TRUE
[10:20:13.433]                             break
[10:20:13.433]                           }
[10:20:13.433]                         }
[10:20:13.433]                       }
[10:20:13.433]                       invisible(muffled)
[10:20:13.433]                     }
[10:20:13.433]                     muffleCondition(cond, pattern = "^muffle")
[10:20:13.433]                   }
[10:20:13.433]                 }
[10:20:13.433]             }
[10:20:13.433]         }))
[10:20:13.433]     }, error = function(ex) {
[10:20:13.433]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:13.433]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:13.433]                 ...future.rng), started = ...future.startTime, 
[10:20:13.433]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:13.433]             version = "1.8"), class = "FutureResult")
[10:20:13.433]     }, finally = {
[10:20:13.433]         if (!identical(...future.workdir, getwd())) 
[10:20:13.433]             setwd(...future.workdir)
[10:20:13.433]         {
[10:20:13.433]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:13.433]                 ...future.oldOptions$nwarnings <- NULL
[10:20:13.433]             }
[10:20:13.433]             base::options(...future.oldOptions)
[10:20:13.433]             if (.Platform$OS.type == "windows") {
[10:20:13.433]                 old_names <- names(...future.oldEnvVars)
[10:20:13.433]                 envs <- base::Sys.getenv()
[10:20:13.433]                 names <- names(envs)
[10:20:13.433]                 common <- intersect(names, old_names)
[10:20:13.433]                 added <- setdiff(names, old_names)
[10:20:13.433]                 removed <- setdiff(old_names, names)
[10:20:13.433]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:13.433]                   envs[common]]
[10:20:13.433]                 NAMES <- toupper(changed)
[10:20:13.433]                 args <- list()
[10:20:13.433]                 for (kk in seq_along(NAMES)) {
[10:20:13.433]                   name <- changed[[kk]]
[10:20:13.433]                   NAME <- NAMES[[kk]]
[10:20:13.433]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:13.433]                     next
[10:20:13.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:13.433]                 }
[10:20:13.433]                 NAMES <- toupper(added)
[10:20:13.433]                 for (kk in seq_along(NAMES)) {
[10:20:13.433]                   name <- added[[kk]]
[10:20:13.433]                   NAME <- NAMES[[kk]]
[10:20:13.433]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:13.433]                     next
[10:20:13.433]                   args[[name]] <- ""
[10:20:13.433]                 }
[10:20:13.433]                 NAMES <- toupper(removed)
[10:20:13.433]                 for (kk in seq_along(NAMES)) {
[10:20:13.433]                   name <- removed[[kk]]
[10:20:13.433]                   NAME <- NAMES[[kk]]
[10:20:13.433]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:13.433]                     next
[10:20:13.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:13.433]                 }
[10:20:13.433]                 if (length(args) > 0) 
[10:20:13.433]                   base::do.call(base::Sys.setenv, args = args)
[10:20:13.433]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:13.433]             }
[10:20:13.433]             else {
[10:20:13.433]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:13.433]             }
[10:20:13.433]             {
[10:20:13.433]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:13.433]                   0L) {
[10:20:13.433]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:13.433]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:13.433]                   base::options(opts)
[10:20:13.433]                 }
[10:20:13.433]                 {
[10:20:13.433]                   {
[10:20:13.433]                     NULL
[10:20:13.433]                     RNGkind("Mersenne-Twister")
[10:20:13.433]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:13.433]                       inherits = FALSE)
[10:20:13.433]                   }
[10:20:13.433]                   options(future.plan = NULL)
[10:20:13.433]                   if (is.na(NA_character_)) 
[10:20:13.433]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:13.433]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:13.433]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:13.433]                     .init = FALSE)
[10:20:13.433]                 }
[10:20:13.433]             }
[10:20:13.433]         }
[10:20:13.433]     })
[10:20:13.433]     if (TRUE) {
[10:20:13.433]         base::sink(type = "output", split = FALSE)
[10:20:13.433]         if (TRUE) {
[10:20:13.433]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:13.433]         }
[10:20:13.433]         else {
[10:20:13.433]             ...future.result["stdout"] <- base::list(NULL)
[10:20:13.433]         }
[10:20:13.433]         base::close(...future.stdout)
[10:20:13.433]         ...future.stdout <- NULL
[10:20:13.433]     }
[10:20:13.433]     ...future.result$conditions <- ...future.conditions
[10:20:13.433]     ...future.result$finished <- base::Sys.time()
[10:20:13.433]     ...future.result
[10:20:13.433] }
[10:20:13.435] assign_globals() ...
[10:20:13.435] List of 5
[10:20:13.435]  $ ...future.FUN            :function (x, y)  
[10:20:13.435]  $ MoreArgs                 : NULL
[10:20:13.435]  $ ...future.elements_ii    :List of 2
[10:20:13.435]   ..$ :List of 2
[10:20:13.435]   .. ..$ : int 1
[10:20:13.435]   .. ..$ : int 0
[10:20:13.435]   ..$ :List of 2
[10:20:13.435]   .. ..$ : int 0
[10:20:13.435]   .. ..$ : int 1
[10:20:13.435]  $ ...future.seeds_ii       : NULL
[10:20:13.435]  $ ...future.globals.maxSize: NULL
[10:20:13.435]  - attr(*, "where")=List of 5
[10:20:13.435]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:13.435]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:20:13.435]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:13.435]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:13.435]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:13.435]  - attr(*, "resolved")= logi FALSE
[10:20:13.435]  - attr(*, "total_size")= num 1242
[10:20:13.435]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:13.435]  - attr(*, "already-done")= logi TRUE
[10:20:13.442] - reassign environment for ‘...future.FUN’
[10:20:13.442] - copied ‘...future.FUN’ to environment
[10:20:13.443] - copied ‘MoreArgs’ to environment
[10:20:13.443] - copied ‘...future.elements_ii’ to environment
[10:20:13.443] - copied ‘...future.seeds_ii’ to environment
[10:20:13.443] - copied ‘...future.globals.maxSize’ to environment
[10:20:13.443] assign_globals() ... done
[10:20:13.443] plan(): Setting new future strategy stack:
[10:20:13.443] List of future strategies:
[10:20:13.443] 1. sequential:
[10:20:13.443]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:13.443]    - tweaked: FALSE
[10:20:13.443]    - call: NULL
[10:20:13.444] plan(): nbrOfWorkers() = 1
[10:20:13.945] plan(): Setting new future strategy stack:
[10:20:13.946] List of future strategies:
[10:20:13.946] 1. multisession:
[10:20:13.946]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:20:13.946]    - tweaked: FALSE
[10:20:13.946]    - call: plan(strategy)
[10:20:13.947] plan(): nbrOfWorkers() = 1
[10:20:13.948] SequentialFuture started (and completed)
[10:20:13.948] - Launch lazy future ... done
[10:20:13.948] run() for ‘SequentialFuture’ ... done
[10:20:13.948] Created future:
[10:20:13.948] SequentialFuture:
[10:20:13.948] Label: ‘future_mapply-1’
[10:20:13.948] Expression:
[10:20:13.948] {
[10:20:13.948]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:13.948]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:13.948]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:13.948]         on.exit(options(oopts), add = TRUE)
[10:20:13.948]     }
[10:20:13.948]     {
[10:20:13.948]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:13.948]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:20:13.948]         do.call(mapply, args = args)
[10:20:13.948]     }
[10:20:13.948] }
[10:20:13.948] Lazy evaluation: FALSE
[10:20:13.948] Asynchronous evaluation: FALSE
[10:20:13.948] Local evaluation: TRUE
[10:20:13.948] Environment: R_GlobalEnv
[10:20:13.948] Capture standard output: TRUE
[10:20:13.948] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:13.948] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:13.948] Packages: <none>
[10:20:13.948] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:13.948] Resolved: TRUE
[10:20:13.948] Value: 184 bytes of class ‘list’
[10:20:13.948] Early signaling: FALSE
[10:20:13.948] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:13.948] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:13.949] Chunk #1 of 1 ... DONE
[10:20:13.949] Launching 1 futures (chunks) ... DONE
[10:20:13.949] Resolving 1 futures (chunks) ...
[10:20:13.949] resolve() on list ...
[10:20:13.949]  recursive: 0
[10:20:13.949]  length: 1
[10:20:13.950] 
[10:20:13.950] resolved() for ‘SequentialFuture’ ...
[10:20:13.950] - state: ‘finished’
[10:20:13.950] - run: TRUE
[10:20:13.950] - result: ‘FutureResult’
[10:20:13.950] resolved() for ‘SequentialFuture’ ... done
[10:20:13.950] Future #1
[10:20:13.950] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:20:13.950] - nx: 1
[10:20:13.950] - relay: TRUE
[10:20:13.950] - stdout: TRUE
[10:20:13.951] - signal: TRUE
[10:20:13.951] - resignal: FALSE
[10:20:13.951] - force: TRUE
[10:20:13.951] - relayed: [n=1] FALSE
[10:20:13.951] - queued futures: [n=1] FALSE
[10:20:13.951]  - until=1
[10:20:13.951]  - relaying element #1
[10:20:13.951] - relayed: [n=1] TRUE
[10:20:13.951] - queued futures: [n=1] TRUE
[10:20:13.951] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:20:13.951]  length: 0 (resolved future 1)
[10:20:13.952] Relaying remaining futures
[10:20:13.952] signalConditionsASAP(NULL, pos=0) ...
[10:20:13.952] - nx: 1
[10:20:13.952] - relay: TRUE
[10:20:13.952] - stdout: TRUE
[10:20:13.952] - signal: TRUE
[10:20:13.952] - resignal: FALSE
[10:20:13.952] - force: TRUE
[10:20:13.952] - relayed: [n=1] TRUE
[10:20:13.952] - queued futures: [n=1] TRUE
 - flush all
[10:20:13.952] - relayed: [n=1] TRUE
[10:20:13.952] - queued futures: [n=1] TRUE
[10:20:13.953] signalConditionsASAP(NULL, pos=0) ... done
[10:20:13.953] resolve() on list ... DONE
[10:20:13.953]  - Number of value chunks collected: 1
[10:20:13.953] Resolving 1 futures (chunks) ... DONE
[10:20:13.953] Reducing values from 1 chunks ...
[10:20:13.953]  - Number of values collected after concatenation: 2
[10:20:13.953]  - Number of values expected: 2
[10:20:13.953] Reducing values from 1 chunks ... DONE
[10:20:13.953] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[10:20:13.954] future_mapply() ...
[10:20:13.955] Number of chunks: 1
[10:20:13.955] getGlobalsAndPackagesXApply() ...
[10:20:13.955]  - future.globals: TRUE
[10:20:13.955] getGlobalsAndPackages() ...
[10:20:13.955] Searching for globals...
[10:20:13.957] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:20:13.957] Searching for globals ... DONE
[10:20:13.957] Resolving globals: FALSE
[10:20:13.958] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[10:20:13.958] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[10:20:13.958] - globals: [1] ‘FUN’
[10:20:13.958] 
[10:20:13.958] getGlobalsAndPackages() ... DONE
[10:20:13.958]  - globals found/used: [n=1] ‘FUN’
[10:20:13.958]  - needed namespaces: [n=0] 
[10:20:13.958] Finding globals ... DONE
[10:20:13.959] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:20:13.959] List of 2
[10:20:13.959]  $ ...future.FUN:function (x, y)  
[10:20:13.959]  $ MoreArgs     : NULL
[10:20:13.959]  - attr(*, "where")=List of 2
[10:20:13.959]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:13.959]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:20:13.959]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:13.959]  - attr(*, "resolved")= logi FALSE
[10:20:13.959]  - attr(*, "total_size")= num NA
[10:20:13.961] Packages to be attached in all futures: [n=0] 
[10:20:13.961] getGlobalsAndPackagesXApply() ... DONE
[10:20:13.962] Number of futures (= number of chunks): 1
[10:20:13.962] Launching 1 futures (chunks) ...
[10:20:13.962] Chunk #1 of 1 ...
[10:20:13.962]  - Finding globals in '...' for chunk #1 ...
[10:20:13.962] getGlobalsAndPackages() ...
[10:20:13.962] Searching for globals...
[10:20:13.962] 
[10:20:13.962] Searching for globals ... DONE
[10:20:13.963] - globals: [0] <none>
[10:20:13.963] getGlobalsAndPackages() ... DONE
[10:20:13.963]    + additional globals found: [n=0] 
[10:20:13.963]    + additional namespaces needed: [n=0] 
[10:20:13.963]  - Finding globals in '...' for chunk #1 ... DONE
[10:20:13.963]  - seeds: <none>
[10:20:13.963]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:13.963] getGlobalsAndPackages() ...
[10:20:13.963] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:13.963] Resolving globals: FALSE
[10:20:13.964] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[10:20:13.964] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:20:13.964] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:13.964] 
[10:20:13.964] getGlobalsAndPackages() ... DONE
[10:20:13.965] run() for ‘Future’ ...
[10:20:13.965] - state: ‘created’
[10:20:13.967] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:20:13.968] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:13.969] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:20:13.969]   - Field: ‘label’
[10:20:13.969]   - Field: ‘local’
[10:20:13.969]   - Field: ‘owner’
[10:20:13.969]   - Field: ‘envir’
[10:20:13.969]   - Field: ‘packages’
[10:20:13.969]   - Field: ‘gc’
[10:20:13.969]   - Field: ‘conditions’
[10:20:13.970]   - Field: ‘expr’
[10:20:13.970]   - Field: ‘uuid’
[10:20:13.970]   - Field: ‘seed’
[10:20:13.970]   - Field: ‘version’
[10:20:13.970]   - Field: ‘result’
[10:20:13.970]   - Field: ‘asynchronous’
[10:20:13.970]   - Field: ‘calls’
[10:20:13.970]   - Field: ‘globals’
[10:20:13.970]   - Field: ‘stdout’
[10:20:13.970]   - Field: ‘earlySignal’
[10:20:13.970]   - Field: ‘lazy’
[10:20:13.971]   - Field: ‘state’
[10:20:13.971] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:20:13.971] - Launch lazy future ...
[10:20:13.971] Packages needed by the future expression (n = 0): <none>
[10:20:13.971] Packages needed by future strategies (n = 0): <none>
[10:20:13.971] {
[10:20:13.971]     {
[10:20:13.971]         {
[10:20:13.971]             ...future.startTime <- base::Sys.time()
[10:20:13.971]             {
[10:20:13.971]                 {
[10:20:13.971]                   {
[10:20:13.971]                     base::local({
[10:20:13.971]                       has_future <- base::requireNamespace("future", 
[10:20:13.971]                         quietly = TRUE)
[10:20:13.971]                       if (has_future) {
[10:20:13.971]                         ns <- base::getNamespace("future")
[10:20:13.971]                         version <- ns[[".package"]][["version"]]
[10:20:13.971]                         if (is.null(version)) 
[10:20:13.971]                           version <- utils::packageVersion("future")
[10:20:13.971]                       }
[10:20:13.971]                       else {
[10:20:13.971]                         version <- NULL
[10:20:13.971]                       }
[10:20:13.971]                       if (!has_future || version < "1.8.0") {
[10:20:13.971]                         info <- base::c(r_version = base::gsub("R version ", 
[10:20:13.971]                           "", base::R.version$version.string), 
[10:20:13.971]                           platform = base::sprintf("%s (%s-bit)", 
[10:20:13.971]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:13.971]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:13.971]                             "release", "version")], collapse = " "), 
[10:20:13.971]                           hostname = base::Sys.info()[["nodename"]])
[10:20:13.971]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:20:13.971]                           info)
[10:20:13.971]                         info <- base::paste(info, collapse = "; ")
[10:20:13.971]                         if (!has_future) {
[10:20:13.971]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:13.971]                             info)
[10:20:13.971]                         }
[10:20:13.971]                         else {
[10:20:13.971]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:13.971]                             info, version)
[10:20:13.971]                         }
[10:20:13.971]                         base::stop(msg)
[10:20:13.971]                       }
[10:20:13.971]                     })
[10:20:13.971]                   }
[10:20:13.971]                   ...future.strategy.old <- future::plan("list")
[10:20:13.971]                   options(future.plan = NULL)
[10:20:13.971]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:13.971]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:13.971]                 }
[10:20:13.971]                 ...future.workdir <- getwd()
[10:20:13.971]             }
[10:20:13.971]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:13.971]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:13.971]         }
[10:20:13.971]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:13.971]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:13.971]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:13.971]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:13.971]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:13.971]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:13.971]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:13.971]             base::names(...future.oldOptions))
[10:20:13.971]     }
[10:20:13.971]     if (TRUE) {
[10:20:13.971]     }
[10:20:13.971]     else {
[10:20:13.971]         if (NA) {
[10:20:13.971]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:13.971]                 open = "w")
[10:20:13.971]         }
[10:20:13.971]         else {
[10:20:13.971]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:13.971]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:13.971]         }
[10:20:13.971]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:13.971]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:13.971]             base::sink(type = "output", split = FALSE)
[10:20:13.971]             base::close(...future.stdout)
[10:20:13.971]         }, add = TRUE)
[10:20:13.971]     }
[10:20:13.971]     ...future.frame <- base::sys.nframe()
[10:20:13.971]     ...future.conditions <- base::list()
[10:20:13.971]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:13.971]     if (FALSE) {
[10:20:13.971]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:13.971]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:13.971]     }
[10:20:13.971]     ...future.result <- base::tryCatch({
[10:20:13.971]         base::withCallingHandlers({
[10:20:13.971]             ...future.value <- base::withVisible(base::local({
[10:20:13.971]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:13.971]                 if (!identical(...future.globals.maxSize.org, 
[10:20:13.971]                   ...future.globals.maxSize)) {
[10:20:13.971]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:13.971]                   on.exit(options(oopts), add = TRUE)
[10:20:13.971]                 }
[10:20:13.971]                 {
[10:20:13.971]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:13.971]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:20:13.971]                     USE.NAMES = FALSE)
[10:20:13.971]                   do.call(mapply, args = args)
[10:20:13.971]                 }
[10:20:13.971]             }))
[10:20:13.971]             future::FutureResult(value = ...future.value$value, 
[10:20:13.971]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:13.971]                   ...future.rng), globalenv = if (FALSE) 
[10:20:13.971]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:13.971]                     ...future.globalenv.names))
[10:20:13.971]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:13.971]         }, condition = base::local({
[10:20:13.971]             c <- base::c
[10:20:13.971]             inherits <- base::inherits
[10:20:13.971]             invokeRestart <- base::invokeRestart
[10:20:13.971]             length <- base::length
[10:20:13.971]             list <- base::list
[10:20:13.971]             seq.int <- base::seq.int
[10:20:13.971]             signalCondition <- base::signalCondition
[10:20:13.971]             sys.calls <- base::sys.calls
[10:20:13.971]             `[[` <- base::`[[`
[10:20:13.971]             `+` <- base::`+`
[10:20:13.971]             `<<-` <- base::`<<-`
[10:20:13.971]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:13.971]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:13.971]                   3L)]
[10:20:13.971]             }
[10:20:13.971]             function(cond) {
[10:20:13.971]                 is_error <- inherits(cond, "error")
[10:20:13.971]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:13.971]                   NULL)
[10:20:13.971]                 if (is_error) {
[10:20:13.971]                   sessionInformation <- function() {
[10:20:13.971]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:13.971]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:13.971]                       search = base::search(), system = base::Sys.info())
[10:20:13.971]                   }
[10:20:13.971]                   ...future.conditions[[length(...future.conditions) + 
[10:20:13.971]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:13.971]                     cond$call), session = sessionInformation(), 
[10:20:13.971]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:13.971]                   signalCondition(cond)
[10:20:13.971]                 }
[10:20:13.971]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:13.971]                 "immediateCondition"))) {
[10:20:13.971]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:13.971]                   ...future.conditions[[length(...future.conditions) + 
[10:20:13.971]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:13.971]                   if (TRUE && !signal) {
[10:20:13.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:13.971]                     {
[10:20:13.971]                       inherits <- base::inherits
[10:20:13.971]                       invokeRestart <- base::invokeRestart
[10:20:13.971]                       is.null <- base::is.null
[10:20:13.971]                       muffled <- FALSE
[10:20:13.971]                       if (inherits(cond, "message")) {
[10:20:13.971]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:13.971]                         if (muffled) 
[10:20:13.971]                           invokeRestart("muffleMessage")
[10:20:13.971]                       }
[10:20:13.971]                       else if (inherits(cond, "warning")) {
[10:20:13.971]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:13.971]                         if (muffled) 
[10:20:13.971]                           invokeRestart("muffleWarning")
[10:20:13.971]                       }
[10:20:13.971]                       else if (inherits(cond, "condition")) {
[10:20:13.971]                         if (!is.null(pattern)) {
[10:20:13.971]                           computeRestarts <- base::computeRestarts
[10:20:13.971]                           grepl <- base::grepl
[10:20:13.971]                           restarts <- computeRestarts(cond)
[10:20:13.971]                           for (restart in restarts) {
[10:20:13.971]                             name <- restart$name
[10:20:13.971]                             if (is.null(name)) 
[10:20:13.971]                               next
[10:20:13.971]                             if (!grepl(pattern, name)) 
[10:20:13.971]                               next
[10:20:13.971]                             invokeRestart(restart)
[10:20:13.971]                             muffled <- TRUE
[10:20:13.971]                             break
[10:20:13.971]                           }
[10:20:13.971]                         }
[10:20:13.971]                       }
[10:20:13.971]                       invisible(muffled)
[10:20:13.971]                     }
[10:20:13.971]                     muffleCondition(cond, pattern = "^muffle")
[10:20:13.971]                   }
[10:20:13.971]                 }
[10:20:13.971]                 else {
[10:20:13.971]                   if (TRUE) {
[10:20:13.971]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:13.971]                     {
[10:20:13.971]                       inherits <- base::inherits
[10:20:13.971]                       invokeRestart <- base::invokeRestart
[10:20:13.971]                       is.null <- base::is.null
[10:20:13.971]                       muffled <- FALSE
[10:20:13.971]                       if (inherits(cond, "message")) {
[10:20:13.971]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:13.971]                         if (muffled) 
[10:20:13.971]                           invokeRestart("muffleMessage")
[10:20:13.971]                       }
[10:20:13.971]                       else if (inherits(cond, "warning")) {
[10:20:13.971]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:13.971]                         if (muffled) 
[10:20:13.971]                           invokeRestart("muffleWarning")
[10:20:13.971]                       }
[10:20:13.971]                       else if (inherits(cond, "condition")) {
[10:20:13.971]                         if (!is.null(pattern)) {
[10:20:13.971]                           computeRestarts <- base::computeRestarts
[10:20:13.971]                           grepl <- base::grepl
[10:20:13.971]                           restarts <- computeRestarts(cond)
[10:20:13.971]                           for (restart in restarts) {
[10:20:13.971]                             name <- restart$name
[10:20:13.971]                             if (is.null(name)) 
[10:20:13.971]                               next
[10:20:13.971]                             if (!grepl(pattern, name)) 
[10:20:13.971]                               next
[10:20:13.971]                             invokeRestart(restart)
[10:20:13.971]                             muffled <- TRUE
[10:20:13.971]                             break
[10:20:13.971]                           }
[10:20:13.971]                         }
[10:20:13.971]                       }
[10:20:13.971]                       invisible(muffled)
[10:20:13.971]                     }
[10:20:13.971]                     muffleCondition(cond, pattern = "^muffle")
[10:20:13.971]                   }
[10:20:13.971]                 }
[10:20:13.971]             }
[10:20:13.971]         }))
[10:20:13.971]     }, error = function(ex) {
[10:20:13.971]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:13.971]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:13.971]                 ...future.rng), started = ...future.startTime, 
[10:20:13.971]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:13.971]             version = "1.8"), class = "FutureResult")
[10:20:13.971]     }, finally = {
[10:20:13.971]         if (!identical(...future.workdir, getwd())) 
[10:20:13.971]             setwd(...future.workdir)
[10:20:13.971]         {
[10:20:13.971]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:13.971]                 ...future.oldOptions$nwarnings <- NULL
[10:20:13.971]             }
[10:20:13.971]             base::options(...future.oldOptions)
[10:20:13.971]             if (.Platform$OS.type == "windows") {
[10:20:13.971]                 old_names <- names(...future.oldEnvVars)
[10:20:13.971]                 envs <- base::Sys.getenv()
[10:20:13.971]                 names <- names(envs)
[10:20:13.971]                 common <- intersect(names, old_names)
[10:20:13.971]                 added <- setdiff(names, old_names)
[10:20:13.971]                 removed <- setdiff(old_names, names)
[10:20:13.971]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:13.971]                   envs[common]]
[10:20:13.971]                 NAMES <- toupper(changed)
[10:20:13.971]                 args <- list()
[10:20:13.971]                 for (kk in seq_along(NAMES)) {
[10:20:13.971]                   name <- changed[[kk]]
[10:20:13.971]                   NAME <- NAMES[[kk]]
[10:20:13.971]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:13.971]                     next
[10:20:13.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:13.971]                 }
[10:20:13.971]                 NAMES <- toupper(added)
[10:20:13.971]                 for (kk in seq_along(NAMES)) {
[10:20:13.971]                   name <- added[[kk]]
[10:20:13.971]                   NAME <- NAMES[[kk]]
[10:20:13.971]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:13.971]                     next
[10:20:13.971]                   args[[name]] <- ""
[10:20:13.971]                 }
[10:20:13.971]                 NAMES <- toupper(removed)
[10:20:13.971]                 for (kk in seq_along(NAMES)) {
[10:20:13.971]                   name <- removed[[kk]]
[10:20:13.971]                   NAME <- NAMES[[kk]]
[10:20:13.971]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:13.971]                     next
[10:20:13.971]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:13.971]                 }
[10:20:13.971]                 if (length(args) > 0) 
[10:20:13.971]                   base::do.call(base::Sys.setenv, args = args)
[10:20:13.971]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:13.971]             }
[10:20:13.971]             else {
[10:20:13.971]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:13.971]             }
[10:20:13.971]             {
[10:20:13.971]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:13.971]                   0L) {
[10:20:13.971]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:13.971]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:13.971]                   base::options(opts)
[10:20:13.971]                 }
[10:20:13.971]                 {
[10:20:13.971]                   {
[10:20:13.971]                     NULL
[10:20:13.971]                     RNGkind("Mersenne-Twister")
[10:20:13.971]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:20:13.971]                       inherits = FALSE)
[10:20:13.971]                   }
[10:20:13.971]                   options(future.plan = NULL)
[10:20:13.971]                   if (is.na(NA_character_)) 
[10:20:13.971]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:13.971]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:13.971]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:13.971]                     .init = FALSE)
[10:20:13.971]                 }
[10:20:13.971]             }
[10:20:13.971]         }
[10:20:13.971]     })
[10:20:13.971]     if (FALSE) {
[10:20:13.971]         base::sink(type = "output", split = FALSE)
[10:20:13.971]         if (NA) {
[10:20:13.971]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:13.971]         }
[10:20:13.971]         else {
[10:20:13.971]             ...future.result["stdout"] <- base::list(NULL)
[10:20:13.971]         }
[10:20:13.971]         base::close(...future.stdout)
[10:20:13.971]         ...future.stdout <- NULL
[10:20:13.971]     }
[10:20:13.971]     ...future.result$conditions <- ...future.conditions
[10:20:13.971]     ...future.result$finished <- base::Sys.time()
[10:20:13.971]     ...future.result
[10:20:13.971] }
[10:20:13.973] assign_globals() ...
[10:20:13.973] List of 5
[10:20:13.973]  $ ...future.FUN            :function (x, y)  
[10:20:13.973]  $ MoreArgs                 : NULL
[10:20:13.973]  $ ...future.elements_ii    :List of 2
[10:20:13.973]   ..$ :List of 2
[10:20:13.973]   .. ..$ : int 1
[10:20:13.973]   .. ..$ : int 0
[10:20:13.973]   ..$ :List of 2
[10:20:13.973]   .. ..$ : int 0
[10:20:13.973]   .. ..$ : int 1
[10:20:13.973]  $ ...future.seeds_ii       : NULL
[10:20:13.973]  $ ...future.globals.maxSize: NULL
[10:20:13.973]  - attr(*, "where")=List of 5
[10:20:13.973]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:13.973]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:20:13.973]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:13.973]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:13.973]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:13.973]  - attr(*, "resolved")= logi FALSE
[10:20:13.973]  - attr(*, "total_size")= num 1242
[10:20:13.973]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:13.973]  - attr(*, "already-done")= logi TRUE
[10:20:13.979] - reassign environment for ‘...future.FUN’
[10:20:13.979] - copied ‘...future.FUN’ to environment
[10:20:13.979] - copied ‘MoreArgs’ to environment
[10:20:13.979] - copied ‘...future.elements_ii’ to environment
[10:20:13.979] - copied ‘...future.seeds_ii’ to environment
[10:20:13.979] - copied ‘...future.globals.maxSize’ to environment
[10:20:13.979] assign_globals() ... done
[10:20:13.980] plan(): Setting new future strategy stack:
[10:20:13.980] List of future strategies:
[10:20:13.980] 1. sequential:
[10:20:13.980]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:13.980]    - tweaked: FALSE
[10:20:13.980]    - call: NULL
[10:20:13.980] plan(): nbrOfWorkers() = 1
[10:20:14.482] plan(): Setting new future strategy stack:
[10:20:14.482] List of future strategies:
[10:20:14.482] 1. multisession:
[10:20:14.482]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:20:14.482]    - tweaked: FALSE
[10:20:14.482]    - call: plan(strategy)
[10:20:14.484] plan(): nbrOfWorkers() = 1
[10:20:14.484] SequentialFuture started (and completed)
[10:20:14.484] - Launch lazy future ... done
[10:20:14.484] run() for ‘SequentialFuture’ ... done
[10:20:14.485] Created future:
[10:20:14.485] SequentialFuture:
[10:20:14.485] Label: ‘future_mapply-1’
[10:20:14.485] Expression:
[10:20:14.485] {
[10:20:14.485]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:14.485]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:14.485]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:14.485]         on.exit(options(oopts), add = TRUE)
[10:20:14.485]     }
[10:20:14.485]     {
[10:20:14.485]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:14.485]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:20:14.485]         do.call(mapply, args = args)
[10:20:14.485]     }
[10:20:14.485] }
[10:20:14.485] Lazy evaluation: FALSE
[10:20:14.485] Asynchronous evaluation: FALSE
[10:20:14.485] Local evaluation: TRUE
[10:20:14.485] Environment: R_GlobalEnv
[10:20:14.485] Capture standard output: NA
[10:20:14.485] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:14.485] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:14.485] Packages: <none>
[10:20:14.485] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:14.485] Resolved: TRUE
[10:20:14.485] Value: 184 bytes of class ‘list’
[10:20:14.485] Early signaling: FALSE
[10:20:14.485] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:14.485] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:20:14.485] Chunk #1 of 1 ... DONE
[10:20:14.486] Launching 1 futures (chunks) ... DONE
[10:20:14.486] Resolving 1 futures (chunks) ...
[10:20:14.486] resolve() on list ...
[10:20:14.486]  recursive: 0
[10:20:14.486]  length: 1
[10:20:14.486] 
[10:20:14.486] resolved() for ‘SequentialFuture’ ...
[10:20:14.486] - state: ‘finished’
[10:20:14.486] - run: TRUE
[10:20:14.486] - result: ‘FutureResult’
[10:20:14.486] resolved() for ‘SequentialFuture’ ... done
[10:20:14.487] Future #1
[10:20:14.487] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:20:14.487] - nx: 1
[10:20:14.487] - relay: TRUE
[10:20:14.487] - stdout: TRUE
[10:20:14.487] - signal: TRUE
[10:20:14.487] - resignal: FALSE
[10:20:14.487] - force: TRUE
[10:20:14.487] - relayed: [n=1] FALSE
[10:20:14.487] - queued futures: [n=1] FALSE
[10:20:14.487]  - until=1
[10:20:14.488]  - relaying element #1
[10:20:14.488] - relayed: [n=1] TRUE
[10:20:14.488] - queued futures: [n=1] TRUE
[10:20:14.488] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:20:14.488]  length: 0 (resolved future 1)
[10:20:14.488] Relaying remaining futures
[10:20:14.488] signalConditionsASAP(NULL, pos=0) ...
[10:20:14.488] - nx: 1
[10:20:14.488] - relay: TRUE
[10:20:14.488] - stdout: TRUE
[10:20:14.488] - signal: TRUE
[10:20:14.489] - resignal: FALSE
[10:20:14.489] - force: TRUE
[10:20:14.489] - relayed: [n=1] TRUE
[10:20:14.489] - queued futures: [n=1] TRUE
 - flush all
[10:20:14.489] - relayed: [n=1] TRUE
[10:20:14.489] - queued futures: [n=1] TRUE
[10:20:14.489] signalConditionsASAP(NULL, pos=0) ... done
[10:20:14.489] resolve() on list ... DONE
[10:20:14.489]  - Number of value chunks collected: 1
[10:20:14.489] Resolving 1 futures (chunks) ... DONE
[10:20:14.489] Reducing values from 1 chunks ...
[10:20:14.490]  - Number of values collected after concatenation: 2
[10:20:14.490]  - Number of values expected: 2
[10:20:14.490] Reducing values from 1 chunks ... DONE
[10:20:14.490] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 1 cores ... DONE
  - Testing with 2 cores ...
* plan('multicore') ...
[10:20:14.495] plan(): Setting new future strategy stack:
[10:20:14.495] List of future strategies:
[10:20:14.495] 1. multicore:
[10:20:14.495]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:20:14.495]    - tweaked: FALSE
[10:20:14.495]    - call: plan(strategy)
[10:20:14.497] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[10:20:14.498] future_lapply() ...
[10:20:14.501] Number of chunks: 2
[10:20:14.501] getGlobalsAndPackagesXApply() ...
[10:20:14.501]  - future.globals: TRUE
[10:20:14.501] getGlobalsAndPackages() ...
[10:20:14.501] Searching for globals...
[10:20:14.503] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:20:14.503] Searching for globals ... DONE
[10:20:14.503] Resolving globals: FALSE
[10:20:14.503] The total size of the 1 globals is 841 bytes (841 bytes)
[10:20:14.504] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[10:20:14.504] - globals: [1] ‘FUN’
[10:20:14.504] 
[10:20:14.504] getGlobalsAndPackages() ... DONE
[10:20:14.504]  - globals found/used: [n=1] ‘FUN’
[10:20:14.504]  - needed namespaces: [n=0] 
[10:20:14.504] Finding globals ... DONE
[10:20:14.504]  - use_args: TRUE
[10:20:14.504]  - Getting '...' globals ...
[10:20:14.505] resolve() on list ...
[10:20:14.505]  recursive: 0
[10:20:14.505]  length: 1
[10:20:14.505]  elements: ‘...’
[10:20:14.505]  length: 0 (resolved future 1)
[10:20:14.505] resolve() on list ... DONE
[10:20:14.505]    - '...' content: [n=0] 
[10:20:14.505] List of 1
[10:20:14.505]  $ ...: list()
[10:20:14.505]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:14.505]  - attr(*, "where")=List of 1
[10:20:14.505]   ..$ ...:<environment: 0x557fc20deed8> 
[10:20:14.505]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:14.505]  - attr(*, "resolved")= logi TRUE
[10:20:14.505]  - attr(*, "total_size")= num NA
[10:20:14.508]  - Getting '...' globals ... DONE
[10:20:14.508] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:20:14.508] List of 2
[10:20:14.508]  $ ...future.FUN:function (x)  
[10:20:14.508]  $ ...          : list()
[10:20:14.508]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:14.508]  - attr(*, "where")=List of 2
[10:20:14.508]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:14.508]   ..$ ...          :<environment: 0x557fc20deed8> 
[10:20:14.508]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:14.508]  - attr(*, "resolved")= logi FALSE
[10:20:14.508]  - attr(*, "total_size")= num 5632
[10:20:14.510] Packages to be attached in all futures: [n=0] 
[10:20:14.510] getGlobalsAndPackagesXApply() ... DONE
[10:20:14.511] Number of futures (= number of chunks): 2
[10:20:14.511] Launching 2 futures (chunks) ...
[10:20:14.511] Chunk #1 of 2 ...
[10:20:14.511]  - Finding globals in 'X' for chunk #1 ...
[10:20:14.511] getGlobalsAndPackages() ...
[10:20:14.511] Searching for globals...
[10:20:14.511] 
[10:20:14.511] Searching for globals ... DONE
[10:20:14.512] - globals: [0] <none>
[10:20:14.512] getGlobalsAndPackages() ... DONE
[10:20:14.512]    + additional globals found: [n=0] 
[10:20:14.512]    + additional namespaces needed: [n=0] 
[10:20:14.512]  - Finding globals in 'X' for chunk #1 ... DONE
[10:20:14.512]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:14.512]  - seeds: <none>
[10:20:14.512]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:14.512] getGlobalsAndPackages() ...
[10:20:14.512] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:14.512] Resolving globals: FALSE
[10:20:14.513] Tweak future expression to call with '...' arguments ...
[10:20:14.513] {
[10:20:14.513]     do.call(function(...) {
[10:20:14.513]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:14.513]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:14.513]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:14.513]             on.exit(options(oopts), add = TRUE)
[10:20:14.513]         }
[10:20:14.513]         {
[10:20:14.513]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:14.513]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:14.513]                 ...future.FUN(...future.X_jj, ...)
[10:20:14.513]             })
[10:20:14.513]         }
[10:20:14.513]     }, args = future.call.arguments)
[10:20:14.513] }
[10:20:14.513] Tweak future expression to call with '...' arguments ... DONE
[10:20:14.513] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:14.513] 
[10:20:14.513] getGlobalsAndPackages() ... DONE
[10:20:14.514] run() for ‘Future’ ...
[10:20:14.514] - state: ‘created’
[10:20:14.514] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:20:14.516] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:14.516] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:20:14.516]   - Field: ‘label’
[10:20:14.516]   - Field: ‘local’
[10:20:14.516]   - Field: ‘owner’
[10:20:14.516]   - Field: ‘envir’
[10:20:14.516]   - Field: ‘workers’
[10:20:14.516]   - Field: ‘packages’
[10:20:14.516]   - Field: ‘gc’
[10:20:14.516]   - Field: ‘job’
[10:20:14.517]   - Field: ‘conditions’
[10:20:14.517]   - Field: ‘expr’
[10:20:14.517]   - Field: ‘uuid’
[10:20:14.517]   - Field: ‘seed’
[10:20:14.517]   - Field: ‘version’
[10:20:14.517]   - Field: ‘result’
[10:20:14.517]   - Field: ‘asynchronous’
[10:20:14.517]   - Field: ‘calls’
[10:20:14.517]   - Field: ‘globals’
[10:20:14.517]   - Field: ‘stdout’
[10:20:14.517]   - Field: ‘earlySignal’
[10:20:14.517]   - Field: ‘lazy’
[10:20:14.518]   - Field: ‘state’
[10:20:14.518] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:20:14.518] - Launch lazy future ...
[10:20:14.519] Packages needed by the future expression (n = 0): <none>
[10:20:14.519] Packages needed by future strategies (n = 0): <none>
[10:20:14.519] {
[10:20:14.519]     {
[10:20:14.519]         {
[10:20:14.519]             ...future.startTime <- base::Sys.time()
[10:20:14.519]             {
[10:20:14.519]                 {
[10:20:14.519]                   {
[10:20:14.519]                     {
[10:20:14.519]                       base::local({
[10:20:14.519]                         has_future <- base::requireNamespace("future", 
[10:20:14.519]                           quietly = TRUE)
[10:20:14.519]                         if (has_future) {
[10:20:14.519]                           ns <- base::getNamespace("future")
[10:20:14.519]                           version <- ns[[".package"]][["version"]]
[10:20:14.519]                           if (is.null(version)) 
[10:20:14.519]                             version <- utils::packageVersion("future")
[10:20:14.519]                         }
[10:20:14.519]                         else {
[10:20:14.519]                           version <- NULL
[10:20:14.519]                         }
[10:20:14.519]                         if (!has_future || version < "1.8.0") {
[10:20:14.519]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:14.519]                             "", base::R.version$version.string), 
[10:20:14.519]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:14.519]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:14.519]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:14.519]                               "release", "version")], collapse = " "), 
[10:20:14.519]                             hostname = base::Sys.info()[["nodename"]])
[10:20:14.519]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:14.519]                             info)
[10:20:14.519]                           info <- base::paste(info, collapse = "; ")
[10:20:14.519]                           if (!has_future) {
[10:20:14.519]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:14.519]                               info)
[10:20:14.519]                           }
[10:20:14.519]                           else {
[10:20:14.519]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:14.519]                               info, version)
[10:20:14.519]                           }
[10:20:14.519]                           base::stop(msg)
[10:20:14.519]                         }
[10:20:14.519]                       })
[10:20:14.519]                     }
[10:20:14.519]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:14.519]                     base::options(mc.cores = 1L)
[10:20:14.519]                   }
[10:20:14.519]                   ...future.strategy.old <- future::plan("list")
[10:20:14.519]                   options(future.plan = NULL)
[10:20:14.519]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:14.519]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:14.519]                 }
[10:20:14.519]                 ...future.workdir <- getwd()
[10:20:14.519]             }
[10:20:14.519]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:14.519]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:14.519]         }
[10:20:14.519]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:14.519]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:14.519]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:14.519]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:14.519]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:14.519]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:14.519]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:14.519]             base::names(...future.oldOptions))
[10:20:14.519]     }
[10:20:14.519]     if (FALSE) {
[10:20:14.519]     }
[10:20:14.519]     else {
[10:20:14.519]         if (FALSE) {
[10:20:14.519]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:14.519]                 open = "w")
[10:20:14.519]         }
[10:20:14.519]         else {
[10:20:14.519]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:14.519]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:14.519]         }
[10:20:14.519]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:14.519]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:14.519]             base::sink(type = "output", split = FALSE)
[10:20:14.519]             base::close(...future.stdout)
[10:20:14.519]         }, add = TRUE)
[10:20:14.519]     }
[10:20:14.519]     ...future.frame <- base::sys.nframe()
[10:20:14.519]     ...future.conditions <- base::list()
[10:20:14.519]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:14.519]     if (FALSE) {
[10:20:14.519]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:14.519]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:14.519]     }
[10:20:14.519]     ...future.result <- base::tryCatch({
[10:20:14.519]         base::withCallingHandlers({
[10:20:14.519]             ...future.value <- base::withVisible(base::local({
[10:20:14.519]                 withCallingHandlers({
[10:20:14.519]                   {
[10:20:14.519]                     do.call(function(...) {
[10:20:14.519]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:14.519]                       if (!identical(...future.globals.maxSize.org, 
[10:20:14.519]                         ...future.globals.maxSize)) {
[10:20:14.519]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:14.519]                         on.exit(options(oopts), add = TRUE)
[10:20:14.519]                       }
[10:20:14.519]                       {
[10:20:14.519]                         lapply(seq_along(...future.elements_ii), 
[10:20:14.519]                           FUN = function(jj) {
[10:20:14.519]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:14.519]                             ...future.FUN(...future.X_jj, ...)
[10:20:14.519]                           })
[10:20:14.519]                       }
[10:20:14.519]                     }, args = future.call.arguments)
[10:20:14.519]                   }
[10:20:14.519]                 }, immediateCondition = function(cond) {
[10:20:14.519]                   save_rds <- function (object, pathname, ...) 
[10:20:14.519]                   {
[10:20:14.519]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:20:14.519]                     if (file_test("-f", pathname_tmp)) {
[10:20:14.519]                       fi_tmp <- file.info(pathname_tmp)
[10:20:14.519]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:20:14.519]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:14.519]                         fi_tmp[["mtime"]])
[10:20:14.519]                     }
[10:20:14.519]                     tryCatch({
[10:20:14.519]                       saveRDS(object, file = pathname_tmp, ...)
[10:20:14.519]                     }, error = function(ex) {
[10:20:14.519]                       msg <- conditionMessage(ex)
[10:20:14.519]                       fi_tmp <- file.info(pathname_tmp)
[10:20:14.519]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:20:14.519]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:14.519]                         fi_tmp[["mtime"]], msg)
[10:20:14.519]                       ex$message <- msg
[10:20:14.519]                       stop(ex)
[10:20:14.519]                     })
[10:20:14.519]                     stopifnot(file_test("-f", pathname_tmp))
[10:20:14.519]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:20:14.519]                     if (!res || file_test("-f", pathname_tmp)) {
[10:20:14.519]                       fi_tmp <- file.info(pathname_tmp)
[10:20:14.519]                       fi <- file.info(pathname)
[10:20:14.519]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:20:14.519]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:14.519]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:20:14.519]                         fi[["size"]], fi[["mtime"]])
[10:20:14.519]                       stop(msg)
[10:20:14.519]                     }
[10:20:14.519]                     invisible(pathname)
[10:20:14.519]                   }
[10:20:14.519]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:20:14.519]                     rootPath = tempdir()) 
[10:20:14.519]                   {
[10:20:14.519]                     obj <- list(time = Sys.time(), condition = cond)
[10:20:14.519]                     file <- tempfile(pattern = class(cond)[1], 
[10:20:14.519]                       tmpdir = path, fileext = ".rds")
[10:20:14.519]                     save_rds(obj, file)
[10:20:14.519]                   }
[10:20:14.519]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8Z8Jdg/.future/immediateConditions")
[10:20:14.519]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:14.519]                   {
[10:20:14.519]                     inherits <- base::inherits
[10:20:14.519]                     invokeRestart <- base::invokeRestart
[10:20:14.519]                     is.null <- base::is.null
[10:20:14.519]                     muffled <- FALSE
[10:20:14.519]                     if (inherits(cond, "message")) {
[10:20:14.519]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:14.519]                       if (muffled) 
[10:20:14.519]                         invokeRestart("muffleMessage")
[10:20:14.519]                     }
[10:20:14.519]                     else if (inherits(cond, "warning")) {
[10:20:14.519]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:14.519]                       if (muffled) 
[10:20:14.519]                         invokeRestart("muffleWarning")
[10:20:14.519]                     }
[10:20:14.519]                     else if (inherits(cond, "condition")) {
[10:20:14.519]                       if (!is.null(pattern)) {
[10:20:14.519]                         computeRestarts <- base::computeRestarts
[10:20:14.519]                         grepl <- base::grepl
[10:20:14.519]                         restarts <- computeRestarts(cond)
[10:20:14.519]                         for (restart in restarts) {
[10:20:14.519]                           name <- restart$name
[10:20:14.519]                           if (is.null(name)) 
[10:20:14.519]                             next
[10:20:14.519]                           if (!grepl(pattern, name)) 
[10:20:14.519]                             next
[10:20:14.519]                           invokeRestart(restart)
[10:20:14.519]                           muffled <- TRUE
[10:20:14.519]                           break
[10:20:14.519]                         }
[10:20:14.519]                       }
[10:20:14.519]                     }
[10:20:14.519]                     invisible(muffled)
[10:20:14.519]                   }
[10:20:14.519]                   muffleCondition(cond)
[10:20:14.519]                 })
[10:20:14.519]             }))
[10:20:14.519]             future::FutureResult(value = ...future.value$value, 
[10:20:14.519]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:14.519]                   ...future.rng), globalenv = if (FALSE) 
[10:20:14.519]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:14.519]                     ...future.globalenv.names))
[10:20:14.519]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:14.519]         }, condition = base::local({
[10:20:14.519]             c <- base::c
[10:20:14.519]             inherits <- base::inherits
[10:20:14.519]             invokeRestart <- base::invokeRestart
[10:20:14.519]             length <- base::length
[10:20:14.519]             list <- base::list
[10:20:14.519]             seq.int <- base::seq.int
[10:20:14.519]             signalCondition <- base::signalCondition
[10:20:14.519]             sys.calls <- base::sys.calls
[10:20:14.519]             `[[` <- base::`[[`
[10:20:14.519]             `+` <- base::`+`
[10:20:14.519]             `<<-` <- base::`<<-`
[10:20:14.519]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:14.519]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:14.519]                   3L)]
[10:20:14.519]             }
[10:20:14.519]             function(cond) {
[10:20:14.519]                 is_error <- inherits(cond, "error")
[10:20:14.519]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:14.519]                   NULL)
[10:20:14.519]                 if (is_error) {
[10:20:14.519]                   sessionInformation <- function() {
[10:20:14.519]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:14.519]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:14.519]                       search = base::search(), system = base::Sys.info())
[10:20:14.519]                   }
[10:20:14.519]                   ...future.conditions[[length(...future.conditions) + 
[10:20:14.519]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:14.519]                     cond$call), session = sessionInformation(), 
[10:20:14.519]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:14.519]                   signalCondition(cond)
[10:20:14.519]                 }
[10:20:14.519]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:14.519]                 "immediateCondition"))) {
[10:20:14.519]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:14.519]                   ...future.conditions[[length(...future.conditions) + 
[10:20:14.519]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:14.519]                   if (TRUE && !signal) {
[10:20:14.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:14.519]                     {
[10:20:14.519]                       inherits <- base::inherits
[10:20:14.519]                       invokeRestart <- base::invokeRestart
[10:20:14.519]                       is.null <- base::is.null
[10:20:14.519]                       muffled <- FALSE
[10:20:14.519]                       if (inherits(cond, "message")) {
[10:20:14.519]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:14.519]                         if (muffled) 
[10:20:14.519]                           invokeRestart("muffleMessage")
[10:20:14.519]                       }
[10:20:14.519]                       else if (inherits(cond, "warning")) {
[10:20:14.519]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:14.519]                         if (muffled) 
[10:20:14.519]                           invokeRestart("muffleWarning")
[10:20:14.519]                       }
[10:20:14.519]                       else if (inherits(cond, "condition")) {
[10:20:14.519]                         if (!is.null(pattern)) {
[10:20:14.519]                           computeRestarts <- base::computeRestarts
[10:20:14.519]                           grepl <- base::grepl
[10:20:14.519]                           restarts <- computeRestarts(cond)
[10:20:14.519]                           for (restart in restarts) {
[10:20:14.519]                             name <- restart$name
[10:20:14.519]                             if (is.null(name)) 
[10:20:14.519]                               next
[10:20:14.519]                             if (!grepl(pattern, name)) 
[10:20:14.519]                               next
[10:20:14.519]                             invokeRestart(restart)
[10:20:14.519]                             muffled <- TRUE
[10:20:14.519]                             break
[10:20:14.519]                           }
[10:20:14.519]                         }
[10:20:14.519]                       }
[10:20:14.519]                       invisible(muffled)
[10:20:14.519]                     }
[10:20:14.519]                     muffleCondition(cond, pattern = "^muffle")
[10:20:14.519]                   }
[10:20:14.519]                 }
[10:20:14.519]                 else {
[10:20:14.519]                   if (TRUE) {
[10:20:14.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:14.519]                     {
[10:20:14.519]                       inherits <- base::inherits
[10:20:14.519]                       invokeRestart <- base::invokeRestart
[10:20:14.519]                       is.null <- base::is.null
[10:20:14.519]                       muffled <- FALSE
[10:20:14.519]                       if (inherits(cond, "message")) {
[10:20:14.519]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:14.519]                         if (muffled) 
[10:20:14.519]                           invokeRestart("muffleMessage")
[10:20:14.519]                       }
[10:20:14.519]                       else if (inherits(cond, "warning")) {
[10:20:14.519]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:14.519]                         if (muffled) 
[10:20:14.519]                           invokeRestart("muffleWarning")
[10:20:14.519]                       }
[10:20:14.519]                       else if (inherits(cond, "condition")) {
[10:20:14.519]                         if (!is.null(pattern)) {
[10:20:14.519]                           computeRestarts <- base::computeRestarts
[10:20:14.519]                           grepl <- base::grepl
[10:20:14.519]                           restarts <- computeRestarts(cond)
[10:20:14.519]                           for (restart in restarts) {
[10:20:14.519]                             name <- restart$name
[10:20:14.519]                             if (is.null(name)) 
[10:20:14.519]                               next
[10:20:14.519]                             if (!grepl(pattern, name)) 
[10:20:14.519]                               next
[10:20:14.519]                             invokeRestart(restart)
[10:20:14.519]                             muffled <- TRUE
[10:20:14.519]                             break
[10:20:14.519]                           }
[10:20:14.519]                         }
[10:20:14.519]                       }
[10:20:14.519]                       invisible(muffled)
[10:20:14.519]                     }
[10:20:14.519]                     muffleCondition(cond, pattern = "^muffle")
[10:20:14.519]                   }
[10:20:14.519]                 }
[10:20:14.519]             }
[10:20:14.519]         }))
[10:20:14.519]     }, error = function(ex) {
[10:20:14.519]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:14.519]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:14.519]                 ...future.rng), started = ...future.startTime, 
[10:20:14.519]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:14.519]             version = "1.8"), class = "FutureResult")
[10:20:14.519]     }, finally = {
[10:20:14.519]         if (!identical(...future.workdir, getwd())) 
[10:20:14.519]             setwd(...future.workdir)
[10:20:14.519]         {
[10:20:14.519]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:14.519]                 ...future.oldOptions$nwarnings <- NULL
[10:20:14.519]             }
[10:20:14.519]             base::options(...future.oldOptions)
[10:20:14.519]             if (.Platform$OS.type == "windows") {
[10:20:14.519]                 old_names <- names(...future.oldEnvVars)
[10:20:14.519]                 envs <- base::Sys.getenv()
[10:20:14.519]                 names <- names(envs)
[10:20:14.519]                 common <- intersect(names, old_names)
[10:20:14.519]                 added <- setdiff(names, old_names)
[10:20:14.519]                 removed <- setdiff(old_names, names)
[10:20:14.519]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:14.519]                   envs[common]]
[10:20:14.519]                 NAMES <- toupper(changed)
[10:20:14.519]                 args <- list()
[10:20:14.519]                 for (kk in seq_along(NAMES)) {
[10:20:14.519]                   name <- changed[[kk]]
[10:20:14.519]                   NAME <- NAMES[[kk]]
[10:20:14.519]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:14.519]                     next
[10:20:14.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:14.519]                 }
[10:20:14.519]                 NAMES <- toupper(added)
[10:20:14.519]                 for (kk in seq_along(NAMES)) {
[10:20:14.519]                   name <- added[[kk]]
[10:20:14.519]                   NAME <- NAMES[[kk]]
[10:20:14.519]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:14.519]                     next
[10:20:14.519]                   args[[name]] <- ""
[10:20:14.519]                 }
[10:20:14.519]                 NAMES <- toupper(removed)
[10:20:14.519]                 for (kk in seq_along(NAMES)) {
[10:20:14.519]                   name <- removed[[kk]]
[10:20:14.519]                   NAME <- NAMES[[kk]]
[10:20:14.519]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:14.519]                     next
[10:20:14.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:14.519]                 }
[10:20:14.519]                 if (length(args) > 0) 
[10:20:14.519]                   base::do.call(base::Sys.setenv, args = args)
[10:20:14.519]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:14.519]             }
[10:20:14.519]             else {
[10:20:14.519]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:14.519]             }
[10:20:14.519]             {
[10:20:14.519]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:14.519]                   0L) {
[10:20:14.519]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:14.519]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:14.519]                   base::options(opts)
[10:20:14.519]                 }
[10:20:14.519]                 {
[10:20:14.519]                   {
[10:20:14.519]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:14.519]                     NULL
[10:20:14.519]                   }
[10:20:14.519]                   options(future.plan = NULL)
[10:20:14.519]                   if (is.na(NA_character_)) 
[10:20:14.519]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:14.519]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:14.519]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:14.519]                     .init = FALSE)
[10:20:14.519]                 }
[10:20:14.519]             }
[10:20:14.519]         }
[10:20:14.519]     })
[10:20:14.519]     if (TRUE) {
[10:20:14.519]         base::sink(type = "output", split = FALSE)
[10:20:14.519]         if (FALSE) {
[10:20:14.519]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:14.519]         }
[10:20:14.519]         else {
[10:20:14.519]             ...future.result["stdout"] <- base::list(NULL)
[10:20:14.519]         }
[10:20:14.519]         base::close(...future.stdout)
[10:20:14.519]         ...future.stdout <- NULL
[10:20:14.519]     }
[10:20:14.519]     ...future.result$conditions <- ...future.conditions
[10:20:14.519]     ...future.result$finished <- base::Sys.time()
[10:20:14.519]     ...future.result
[10:20:14.519] }
[10:20:14.522] assign_globals() ...
[10:20:14.522] List of 5
[10:20:14.522]  $ ...future.FUN            :function (x)  
[10:20:14.522]  $ future.call.arguments    : list()
[10:20:14.522]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:14.522]  $ ...future.elements_ii    :List of 1
[10:20:14.522]   ..$ : int 1
[10:20:14.522]  $ ...future.seeds_ii       : NULL
[10:20:14.522]  $ ...future.globals.maxSize: NULL
[10:20:14.522]  - attr(*, "where")=List of 5
[10:20:14.522]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:14.522]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:20:14.522]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:14.522]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:14.522]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:14.522]  - attr(*, "resolved")= logi FALSE
[10:20:14.522]  - attr(*, "total_size")= num 5632
[10:20:14.522]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:14.522]  - attr(*, "already-done")= logi TRUE
[10:20:14.529] - reassign environment for ‘...future.FUN’
[10:20:14.529] - copied ‘...future.FUN’ to environment
[10:20:14.529] - copied ‘future.call.arguments’ to environment
[10:20:14.529] - copied ‘...future.elements_ii’ to environment
[10:20:14.529] - copied ‘...future.seeds_ii’ to environment
[10:20:14.529] - copied ‘...future.globals.maxSize’ to environment
[10:20:14.529] assign_globals() ... done
[10:20:14.529] requestCore(): workers = 2
[10:20:14.533] MulticoreFuture started
[10:20:14.533] - Launch lazy future ... done
[10:20:14.533] plan(): Setting new future strategy stack:
[10:20:14.533] run() for ‘MulticoreFuture’ ... done
[10:20:14.534] Created future:
[10:20:14.534] List of future strategies:
[10:20:14.534] 1. sequential:
[10:20:14.534]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:14.534]    - tweaked: FALSE
[10:20:14.534]    - call: NULL
[10:20:14.535] plan(): nbrOfWorkers() = 1
[10:20:14.534] MulticoreFuture:
[10:20:14.534] Label: ‘future_lapply-1’
[10:20:14.534] Expression:
[10:20:14.534] {
[10:20:14.534]     do.call(function(...) {
[10:20:14.534]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:14.534]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:14.534]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:14.534]             on.exit(options(oopts), add = TRUE)
[10:20:14.534]         }
[10:20:14.534]         {
[10:20:14.534]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:14.534]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:14.534]                 ...future.FUN(...future.X_jj, ...)
[10:20:14.534]             })
[10:20:14.534]         }
[10:20:14.534]     }, args = future.call.arguments)
[10:20:14.534] }
[10:20:14.534] Lazy evaluation: FALSE
[10:20:14.534] Asynchronous evaluation: TRUE
[10:20:14.534] Local evaluation: TRUE
[10:20:14.534] Environment: R_GlobalEnv
[10:20:14.534] Capture standard output: FALSE
[10:20:14.534] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:14.534] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:14.534] Packages: <none>
[10:20:14.534] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:14.534] Resolved: FALSE
[10:20:14.534] Value: <not collected>
[10:20:14.534] Conditions captured: <none>
[10:20:14.534] Early signaling: FALSE
[10:20:14.534] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:14.534] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:14.549] Chunk #1 of 2 ... DONE
[10:20:14.549] Chunk #2 of 2 ...
[10:20:14.549]  - Finding globals in 'X' for chunk #2 ...
[10:20:14.549] getGlobalsAndPackages() ...
[10:20:14.549] Searching for globals...
[10:20:14.550] 
[10:20:14.550] Searching for globals ... DONE
[10:20:14.550] - globals: [0] <none>
[10:20:14.550] getGlobalsAndPackages() ... DONE
[10:20:14.550]    + additional globals found: [n=0] 
[10:20:14.551]    + additional namespaces needed: [n=0] 
[10:20:14.551]  - Finding globals in 'X' for chunk #2 ... DONE
[10:20:14.551]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:14.551]  - seeds: <none>
[10:20:14.551]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:14.551] getGlobalsAndPackages() ...
[10:20:14.552] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:14.552] Resolving globals: FALSE
[10:20:14.552] Tweak future expression to call with '...' arguments ...
[10:20:14.552] {
[10:20:14.552]     do.call(function(...) {
[10:20:14.552]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:14.552]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:14.552]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:14.552]             on.exit(options(oopts), add = TRUE)
[10:20:14.552]         }
[10:20:14.552]         {
[10:20:14.552]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:14.552]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:14.552]                 ...future.FUN(...future.X_jj, ...)
[10:20:14.552]             })
[10:20:14.552]         }
[10:20:14.552]     }, args = future.call.arguments)
[10:20:14.552] }
[10:20:14.552] Tweak future expression to call with '...' arguments ... DONE
[10:20:14.553] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:14.553] 
[10:20:14.553] getGlobalsAndPackages() ... DONE
[10:20:14.554] run() for ‘Future’ ...
[10:20:14.554] - state: ‘created’
[10:20:14.554] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:20:14.557] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:14.557] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:20:14.558]   - Field: ‘label’
[10:20:14.558]   - Field: ‘local’
[10:20:14.558]   - Field: ‘owner’
[10:20:14.558]   - Field: ‘envir’
[10:20:14.558]   - Field: ‘workers’
[10:20:14.558]   - Field: ‘packages’
[10:20:14.559]   - Field: ‘gc’
[10:20:14.559]   - Field: ‘job’
[10:20:14.559]   - Field: ‘conditions’
[10:20:14.559]   - Field: ‘expr’
[10:20:14.559]   - Field: ‘uuid’
[10:20:14.559]   - Field: ‘seed’
[10:20:14.559]   - Field: ‘version’
[10:20:14.559]   - Field: ‘result’
[10:20:14.560]   - Field: ‘asynchronous’
[10:20:14.560]   - Field: ‘calls’
[10:20:14.560]   - Field: ‘globals’
[10:20:14.560]   - Field: ‘stdout’
[10:20:14.560]   - Field: ‘earlySignal’
[10:20:14.560]   - Field: ‘lazy’
[10:20:14.560]   - Field: ‘state’
[10:20:14.561] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:20:14.561] - Launch lazy future ...
[10:20:14.561] Packages needed by the future expression (n = 0): <none>
[10:20:14.561] Packages needed by future strategies (n = 0): <none>
[10:20:14.562] {
[10:20:14.562]     {
[10:20:14.562]         {
[10:20:14.562]             ...future.startTime <- base::Sys.time()
[10:20:14.562]             {
[10:20:14.562]                 {
[10:20:14.562]                   {
[10:20:14.562]                     {
[10:20:14.562]                       base::local({
[10:20:14.562]                         has_future <- base::requireNamespace("future", 
[10:20:14.562]                           quietly = TRUE)
[10:20:14.562]                         if (has_future) {
[10:20:14.562]                           ns <- base::getNamespace("future")
[10:20:14.562]                           version <- ns[[".package"]][["version"]]
[10:20:14.562]                           if (is.null(version)) 
[10:20:14.562]                             version <- utils::packageVersion("future")
[10:20:14.562]                         }
[10:20:14.562]                         else {
[10:20:14.562]                           version <- NULL
[10:20:14.562]                         }
[10:20:14.562]                         if (!has_future || version < "1.8.0") {
[10:20:14.562]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:14.562]                             "", base::R.version$version.string), 
[10:20:14.562]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:14.562]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:14.562]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:14.562]                               "release", "version")], collapse = " "), 
[10:20:14.562]                             hostname = base::Sys.info()[["nodename"]])
[10:20:14.562]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:14.562]                             info)
[10:20:14.562]                           info <- base::paste(info, collapse = "; ")
[10:20:14.562]                           if (!has_future) {
[10:20:14.562]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:14.562]                               info)
[10:20:14.562]                           }
[10:20:14.562]                           else {
[10:20:14.562]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:14.562]                               info, version)
[10:20:14.562]                           }
[10:20:14.562]                           base::stop(msg)
[10:20:14.562]                         }
[10:20:14.562]                       })
[10:20:14.562]                     }
[10:20:14.562]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:14.562]                     base::options(mc.cores = 1L)
[10:20:14.562]                   }
[10:20:14.562]                   ...future.strategy.old <- future::plan("list")
[10:20:14.562]                   options(future.plan = NULL)
[10:20:14.562]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:14.562]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:14.562]                 }
[10:20:14.562]                 ...future.workdir <- getwd()
[10:20:14.562]             }
[10:20:14.562]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:14.562]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:14.562]         }
[10:20:14.562]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:14.562]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:14.562]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:14.562]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:14.562]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:14.562]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:14.562]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:14.562]             base::names(...future.oldOptions))
[10:20:14.562]     }
[10:20:14.562]     if (FALSE) {
[10:20:14.562]     }
[10:20:14.562]     else {
[10:20:14.562]         if (FALSE) {
[10:20:14.562]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:14.562]                 open = "w")
[10:20:14.562]         }
[10:20:14.562]         else {
[10:20:14.562]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:14.562]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:14.562]         }
[10:20:14.562]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:14.562]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:14.562]             base::sink(type = "output", split = FALSE)
[10:20:14.562]             base::close(...future.stdout)
[10:20:14.562]         }, add = TRUE)
[10:20:14.562]     }
[10:20:14.562]     ...future.frame <- base::sys.nframe()
[10:20:14.562]     ...future.conditions <- base::list()
[10:20:14.562]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:14.562]     if (FALSE) {
[10:20:14.562]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:14.562]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:14.562]     }
[10:20:14.562]     ...future.result <- base::tryCatch({
[10:20:14.562]         base::withCallingHandlers({
[10:20:14.562]             ...future.value <- base::withVisible(base::local({
[10:20:14.562]                 withCallingHandlers({
[10:20:14.562]                   {
[10:20:14.562]                     do.call(function(...) {
[10:20:14.562]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:14.562]                       if (!identical(...future.globals.maxSize.org, 
[10:20:14.562]                         ...future.globals.maxSize)) {
[10:20:14.562]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:14.562]                         on.exit(options(oopts), add = TRUE)
[10:20:14.562]                       }
[10:20:14.562]                       {
[10:20:14.562]                         lapply(seq_along(...future.elements_ii), 
[10:20:14.562]                           FUN = function(jj) {
[10:20:14.562]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:14.562]                             ...future.FUN(...future.X_jj, ...)
[10:20:14.562]                           })
[10:20:14.562]                       }
[10:20:14.562]                     }, args = future.call.arguments)
[10:20:14.562]                   }
[10:20:14.562]                 }, immediateCondition = function(cond) {
[10:20:14.562]                   save_rds <- function (object, pathname, ...) 
[10:20:14.562]                   {
[10:20:14.562]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:20:14.562]                     if (file_test("-f", pathname_tmp)) {
[10:20:14.562]                       fi_tmp <- file.info(pathname_tmp)
[10:20:14.562]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:20:14.562]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:14.562]                         fi_tmp[["mtime"]])
[10:20:14.562]                     }
[10:20:14.562]                     tryCatch({
[10:20:14.562]                       saveRDS(object, file = pathname_tmp, ...)
[10:20:14.562]                     }, error = function(ex) {
[10:20:14.562]                       msg <- conditionMessage(ex)
[10:20:14.562]                       fi_tmp <- file.info(pathname_tmp)
[10:20:14.562]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:20:14.562]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:14.562]                         fi_tmp[["mtime"]], msg)
[10:20:14.562]                       ex$message <- msg
[10:20:14.562]                       stop(ex)
[10:20:14.562]                     })
[10:20:14.562]                     stopifnot(file_test("-f", pathname_tmp))
[10:20:14.562]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:20:14.562]                     if (!res || file_test("-f", pathname_tmp)) {
[10:20:14.562]                       fi_tmp <- file.info(pathname_tmp)
[10:20:14.562]                       fi <- file.info(pathname)
[10:20:14.562]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:20:14.562]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:14.562]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:20:14.562]                         fi[["size"]], fi[["mtime"]])
[10:20:14.562]                       stop(msg)
[10:20:14.562]                     }
[10:20:14.562]                     invisible(pathname)
[10:20:14.562]                   }
[10:20:14.562]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:20:14.562]                     rootPath = tempdir()) 
[10:20:14.562]                   {
[10:20:14.562]                     obj <- list(time = Sys.time(), condition = cond)
[10:20:14.562]                     file <- tempfile(pattern = class(cond)[1], 
[10:20:14.562]                       tmpdir = path, fileext = ".rds")
[10:20:14.562]                     save_rds(obj, file)
[10:20:14.562]                   }
[10:20:14.562]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8Z8Jdg/.future/immediateConditions")
[10:20:14.562]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:14.562]                   {
[10:20:14.562]                     inherits <- base::inherits
[10:20:14.562]                     invokeRestart <- base::invokeRestart
[10:20:14.562]                     is.null <- base::is.null
[10:20:14.562]                     muffled <- FALSE
[10:20:14.562]                     if (inherits(cond, "message")) {
[10:20:14.562]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:14.562]                       if (muffled) 
[10:20:14.562]                         invokeRestart("muffleMessage")
[10:20:14.562]                     }
[10:20:14.562]                     else if (inherits(cond, "warning")) {
[10:20:14.562]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:14.562]                       if (muffled) 
[10:20:14.562]                         invokeRestart("muffleWarning")
[10:20:14.562]                     }
[10:20:14.562]                     else if (inherits(cond, "condition")) {
[10:20:14.562]                       if (!is.null(pattern)) {
[10:20:14.562]                         computeRestarts <- base::computeRestarts
[10:20:14.562]                         grepl <- base::grepl
[10:20:14.562]                         restarts <- computeRestarts(cond)
[10:20:14.562]                         for (restart in restarts) {
[10:20:14.562]                           name <- restart$name
[10:20:14.562]                           if (is.null(name)) 
[10:20:14.562]                             next
[10:20:14.562]                           if (!grepl(pattern, name)) 
[10:20:14.562]                             next
[10:20:14.562]                           invokeRestart(restart)
[10:20:14.562]                           muffled <- TRUE
[10:20:14.562]                           break
[10:20:14.562]                         }
[10:20:14.562]                       }
[10:20:14.562]                     }
[10:20:14.562]                     invisible(muffled)
[10:20:14.562]                   }
[10:20:14.562]                   muffleCondition(cond)
[10:20:14.562]                 })
[10:20:14.562]             }))
[10:20:14.562]             future::FutureResult(value = ...future.value$value, 
[10:20:14.562]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:14.562]                   ...future.rng), globalenv = if (FALSE) 
[10:20:14.562]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:14.562]                     ...future.globalenv.names))
[10:20:14.562]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:14.562]         }, condition = base::local({
[10:20:14.562]             c <- base::c
[10:20:14.562]             inherits <- base::inherits
[10:20:14.562]             invokeRestart <- base::invokeRestart
[10:20:14.562]             length <- base::length
[10:20:14.562]             list <- base::list
[10:20:14.562]             seq.int <- base::seq.int
[10:20:14.562]             signalCondition <- base::signalCondition
[10:20:14.562]             sys.calls <- base::sys.calls
[10:20:14.562]             `[[` <- base::`[[`
[10:20:14.562]             `+` <- base::`+`
[10:20:14.562]             `<<-` <- base::`<<-`
[10:20:14.562]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:14.562]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:14.562]                   3L)]
[10:20:14.562]             }
[10:20:14.562]             function(cond) {
[10:20:14.562]                 is_error <- inherits(cond, "error")
[10:20:14.562]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:14.562]                   NULL)
[10:20:14.562]                 if (is_error) {
[10:20:14.562]                   sessionInformation <- function() {
[10:20:14.562]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:14.562]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:14.562]                       search = base::search(), system = base::Sys.info())
[10:20:14.562]                   }
[10:20:14.562]                   ...future.conditions[[length(...future.conditions) + 
[10:20:14.562]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:14.562]                     cond$call), session = sessionInformation(), 
[10:20:14.562]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:14.562]                   signalCondition(cond)
[10:20:14.562]                 }
[10:20:14.562]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:14.562]                 "immediateCondition"))) {
[10:20:14.562]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:14.562]                   ...future.conditions[[length(...future.conditions) + 
[10:20:14.562]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:14.562]                   if (TRUE && !signal) {
[10:20:14.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:14.562]                     {
[10:20:14.562]                       inherits <- base::inherits
[10:20:14.562]                       invokeRestart <- base::invokeRestart
[10:20:14.562]                       is.null <- base::is.null
[10:20:14.562]                       muffled <- FALSE
[10:20:14.562]                       if (inherits(cond, "message")) {
[10:20:14.562]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:14.562]                         if (muffled) 
[10:20:14.562]                           invokeRestart("muffleMessage")
[10:20:14.562]                       }
[10:20:14.562]                       else if (inherits(cond, "warning")) {
[10:20:14.562]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:14.562]                         if (muffled) 
[10:20:14.562]                           invokeRestart("muffleWarning")
[10:20:14.562]                       }
[10:20:14.562]                       else if (inherits(cond, "condition")) {
[10:20:14.562]                         if (!is.null(pattern)) {
[10:20:14.562]                           computeRestarts <- base::computeRestarts
[10:20:14.562]                           grepl <- base::grepl
[10:20:14.562]                           restarts <- computeRestarts(cond)
[10:20:14.562]                           for (restart in restarts) {
[10:20:14.562]                             name <- restart$name
[10:20:14.562]                             if (is.null(name)) 
[10:20:14.562]                               next
[10:20:14.562]                             if (!grepl(pattern, name)) 
[10:20:14.562]                               next
[10:20:14.562]                             invokeRestart(restart)
[10:20:14.562]                             muffled <- TRUE
[10:20:14.562]                             break
[10:20:14.562]                           }
[10:20:14.562]                         }
[10:20:14.562]                       }
[10:20:14.562]                       invisible(muffled)
[10:20:14.562]                     }
[10:20:14.562]                     muffleCondition(cond, pattern = "^muffle")
[10:20:14.562]                   }
[10:20:14.562]                 }
[10:20:14.562]                 else {
[10:20:14.562]                   if (TRUE) {
[10:20:14.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:14.562]                     {
[10:20:14.562]                       inherits <- base::inherits
[10:20:14.562]                       invokeRestart <- base::invokeRestart
[10:20:14.562]                       is.null <- base::is.null
[10:20:14.562]                       muffled <- FALSE
[10:20:14.562]                       if (inherits(cond, "message")) {
[10:20:14.562]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:14.562]                         if (muffled) 
[10:20:14.562]                           invokeRestart("muffleMessage")
[10:20:14.562]                       }
[10:20:14.562]                       else if (inherits(cond, "warning")) {
[10:20:14.562]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:14.562]                         if (muffled) 
[10:20:14.562]                           invokeRestart("muffleWarning")
[10:20:14.562]                       }
[10:20:14.562]                       else if (inherits(cond, "condition")) {
[10:20:14.562]                         if (!is.null(pattern)) {
[10:20:14.562]                           computeRestarts <- base::computeRestarts
[10:20:14.562]                           grepl <- base::grepl
[10:20:14.562]                           restarts <- computeRestarts(cond)
[10:20:14.562]                           for (restart in restarts) {
[10:20:14.562]                             name <- restart$name
[10:20:14.562]                             if (is.null(name)) 
[10:20:14.562]                               next
[10:20:14.562]                             if (!grepl(pattern, name)) 
[10:20:14.562]                               next
[10:20:14.562]                             invokeRestart(restart)
[10:20:14.562]                             muffled <- TRUE
[10:20:14.562]                             break
[10:20:14.562]                           }
[10:20:14.562]                         }
[10:20:14.562]                       }
[10:20:14.562]                       invisible(muffled)
[10:20:14.562]                     }
[10:20:14.562]                     muffleCondition(cond, pattern = "^muffle")
[10:20:14.562]                   }
[10:20:14.562]                 }
[10:20:14.562]             }
[10:20:14.562]         }))
[10:20:14.562]     }, error = function(ex) {
[10:20:14.562]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:14.562]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:14.562]                 ...future.rng), started = ...future.startTime, 
[10:20:14.562]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:14.562]             version = "1.8"), class = "FutureResult")
[10:20:14.562]     }, finally = {
[10:20:14.562]         if (!identical(...future.workdir, getwd())) 
[10:20:14.562]             setwd(...future.workdir)
[10:20:14.562]         {
[10:20:14.562]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:14.562]                 ...future.oldOptions$nwarnings <- NULL
[10:20:14.562]             }
[10:20:14.562]             base::options(...future.oldOptions)
[10:20:14.562]             if (.Platform$OS.type == "windows") {
[10:20:14.562]                 old_names <- names(...future.oldEnvVars)
[10:20:14.562]                 envs <- base::Sys.getenv()
[10:20:14.562]                 names <- names(envs)
[10:20:14.562]                 common <- intersect(names, old_names)
[10:20:14.562]                 added <- setdiff(names, old_names)
[10:20:14.562]                 removed <- setdiff(old_names, names)
[10:20:14.562]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:14.562]                   envs[common]]
[10:20:14.562]                 NAMES <- toupper(changed)
[10:20:14.562]                 args <- list()
[10:20:14.562]                 for (kk in seq_along(NAMES)) {
[10:20:14.562]                   name <- changed[[kk]]
[10:20:14.562]                   NAME <- NAMES[[kk]]
[10:20:14.562]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:14.562]                     next
[10:20:14.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:14.562]                 }
[10:20:14.562]                 NAMES <- toupper(added)
[10:20:14.562]                 for (kk in seq_along(NAMES)) {
[10:20:14.562]                   name <- added[[kk]]
[10:20:14.562]                   NAME <- NAMES[[kk]]
[10:20:14.562]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:14.562]                     next
[10:20:14.562]                   args[[name]] <- ""
[10:20:14.562]                 }
[10:20:14.562]                 NAMES <- toupper(removed)
[10:20:14.562]                 for (kk in seq_along(NAMES)) {
[10:20:14.562]                   name <- removed[[kk]]
[10:20:14.562]                   NAME <- NAMES[[kk]]
[10:20:14.562]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:14.562]                     next
[10:20:14.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:14.562]                 }
[10:20:14.562]                 if (length(args) > 0) 
[10:20:14.562]                   base::do.call(base::Sys.setenv, args = args)
[10:20:14.562]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:14.562]             }
[10:20:14.562]             else {
[10:20:14.562]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:14.562]             }
[10:20:14.562]             {
[10:20:14.562]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:14.562]                   0L) {
[10:20:14.562]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:14.562]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:14.562]                   base::options(opts)
[10:20:14.562]                 }
[10:20:14.562]                 {
[10:20:14.562]                   {
[10:20:14.562]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:14.562]                     NULL
[10:20:14.562]                   }
[10:20:14.562]                   options(future.plan = NULL)
[10:20:14.562]                   if (is.na(NA_character_)) 
[10:20:14.562]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:14.562]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:14.562]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:14.562]                     .init = FALSE)
[10:20:14.562]                 }
[10:20:14.562]             }
[10:20:14.562]         }
[10:20:14.562]     })
[10:20:14.562]     if (TRUE) {
[10:20:14.562]         base::sink(type = "output", split = FALSE)
[10:20:14.562]         if (FALSE) {
[10:20:14.562]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:14.562]         }
[10:20:14.562]         else {
[10:20:14.562]             ...future.result["stdout"] <- base::list(NULL)
[10:20:14.562]         }
[10:20:14.562]         base::close(...future.stdout)
[10:20:14.562]         ...future.stdout <- NULL
[10:20:14.562]     }
[10:20:14.562]     ...future.result$conditions <- ...future.conditions
[10:20:14.562]     ...future.result$finished <- base::Sys.time()
[10:20:14.562]     ...future.result
[10:20:14.562] }
[10:20:14.565] assign_globals() ...
[10:20:14.566] List of 5
[10:20:14.566]  $ ...future.FUN            :function (x)  
[10:20:14.566]  $ future.call.arguments    : list()
[10:20:14.566]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:14.566]  $ ...future.elements_ii    :List of 1
[10:20:14.566]   ..$ : int 0
[10:20:14.566]  $ ...future.seeds_ii       : NULL
[10:20:14.566]  $ ...future.globals.maxSize: NULL
[10:20:14.566]  - attr(*, "where")=List of 5
[10:20:14.566]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:14.566]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:20:14.566]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:14.566]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:14.566]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:14.566]  - attr(*, "resolved")= logi FALSE
[10:20:14.566]  - attr(*, "total_size")= num 5632
[10:20:14.566]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:14.566]  - attr(*, "already-done")= logi TRUE
[10:20:14.573] - reassign environment for ‘...future.FUN’
[10:20:14.573] - copied ‘...future.FUN’ to environment
[10:20:14.573] - copied ‘future.call.arguments’ to environment
[10:20:14.574] - copied ‘...future.elements_ii’ to environment
[10:20:14.574] - copied ‘...future.seeds_ii’ to environment
[10:20:14.574] - copied ‘...future.globals.maxSize’ to environment
[10:20:14.574] assign_globals() ... done
[10:20:14.574] requestCore(): workers = 2
[10:20:14.584] MulticoreFuture started
[10:20:14.585] - Launch lazy future ... done
[10:20:14.586] plan(): Setting new future strategy stack:
[10:20:14.586] run() for ‘MulticoreFuture’ ... done
[10:20:14.586] Created future:
[10:20:14.586] List of future strategies:
[10:20:14.586] 1. sequential:
[10:20:14.586]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:14.586]    - tweaked: FALSE
[10:20:14.586]    - call: NULL
[10:20:14.587] plan(): nbrOfWorkers() = 1
[10:20:14.590] plan(): Setting new future strategy stack:
[10:20:14.590] List of future strategies:
[10:20:14.590] 1. multicore:
[10:20:14.590]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:20:14.590]    - tweaked: FALSE
[10:20:14.590]    - call: plan(strategy)
[10:20:14.594] plan(): nbrOfWorkers() = 2
[10:20:14.586] MulticoreFuture:
[10:20:14.586] Label: ‘future_lapply-2’
[10:20:14.586] Expression:
[10:20:14.586] {
[10:20:14.586]     do.call(function(...) {
[10:20:14.586]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:14.586]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:14.586]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:14.586]             on.exit(options(oopts), add = TRUE)
[10:20:14.586]         }
[10:20:14.586]         {
[10:20:14.586]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:14.586]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:14.586]                 ...future.FUN(...future.X_jj, ...)
[10:20:14.586]             })
[10:20:14.586]         }
[10:20:14.586]     }, args = future.call.arguments)
[10:20:14.586] }
[10:20:14.586] Lazy evaluation: FALSE
[10:20:14.586] Asynchronous evaluation: TRUE
[10:20:14.586] Local evaluation: TRUE
[10:20:14.586] Environment: R_GlobalEnv
[10:20:14.586] Capture standard output: FALSE
[10:20:14.586] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:14.586] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:14.586] Packages: <none>
[10:20:14.586] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:14.586] Resolved: TRUE
[10:20:14.586] Value: <not collected>
[10:20:14.586] Conditions captured: <none>
[10:20:14.586] Early signaling: FALSE
[10:20:14.586] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:14.586] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:14.595] Chunk #2 of 2 ... DONE
[10:20:14.595] Launching 2 futures (chunks) ... DONE
[10:20:14.595] Resolving 2 futures (chunks) ...
[10:20:14.595] resolve() on list ...
[10:20:14.596]  recursive: 0
[10:20:14.596]  length: 2
[10:20:14.596] 
[10:20:14.607] Future #2
[10:20:14.607] result() for MulticoreFuture ...
[10:20:14.610] result() for MulticoreFuture ...
[10:20:14.610] result() for MulticoreFuture ... done
[10:20:14.610] result() for MulticoreFuture ... done
[10:20:14.610] result() for MulticoreFuture ...
[10:20:14.610] result() for MulticoreFuture ... done
[10:20:14.610] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:20:14.611] - nx: 2
[10:20:14.611] - relay: TRUE
[10:20:14.611] - stdout: TRUE
[10:20:14.611] - signal: TRUE
[10:20:14.611] - resignal: FALSE
[10:20:14.611] - force: TRUE
[10:20:14.611] - relayed: [n=2] FALSE, FALSE
[10:20:14.612] - queued futures: [n=2] FALSE, FALSE
[10:20:14.612]  - until=1
[10:20:14.612]  - relaying element #1
[10:20:14.612] - relayed: [n=2] FALSE, FALSE
[10:20:14.612] - queued futures: [n=2] FALSE, TRUE
[10:20:14.612] signalConditionsASAP(NULL, pos=2) ... done
[10:20:14.612]  length: 1 (resolved future 2)
[10:20:15.038] plan(): Setting new future strategy stack:
[10:20:15.038] List of future strategies:
[10:20:15.038] 1. multicore:
[10:20:15.038]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:20:15.038]    - tweaked: FALSE
[10:20:15.038]    - call: plan(strategy)
[10:20:15.041] plan(): nbrOfWorkers() = 2
[10:20:15.051] Future #1
[10:20:15.051] result() for MulticoreFuture ...
[10:20:15.052] result() for MulticoreFuture ...
[10:20:15.052] result() for MulticoreFuture ... done
[10:20:15.052] result() for MulticoreFuture ... done
[10:20:15.052] result() for MulticoreFuture ...
[10:20:15.052] result() for MulticoreFuture ... done
[10:20:15.052] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:20:15.053] - nx: 2
[10:20:15.053] - relay: TRUE
[10:20:15.053] - stdout: TRUE
[10:20:15.053] - signal: TRUE
[10:20:15.053] - resignal: FALSE
[10:20:15.053] - force: TRUE
[10:20:15.053] - relayed: [n=2] FALSE, FALSE
[10:20:15.053] - queued futures: [n=2] FALSE, TRUE
[10:20:15.053]  - until=1
[10:20:15.053]  - relaying element #1
[10:20:15.054] result() for MulticoreFuture ...
[10:20:15.054] result() for MulticoreFuture ... done
[10:20:15.054] result() for MulticoreFuture ...
[10:20:15.054] result() for MulticoreFuture ... done
[10:20:15.054] result() for MulticoreFuture ...
[10:20:15.054] result() for MulticoreFuture ... done
[10:20:15.054] result() for MulticoreFuture ...
[10:20:15.054] result() for MulticoreFuture ... done
[10:20:15.054] - relayed: [n=2] TRUE, FALSE
[10:20:15.055] - queued futures: [n=2] TRUE, TRUE
[10:20:15.055] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:20:15.055]  length: 0 (resolved future 1)
[10:20:15.055] Relaying remaining futures
[10:20:15.055] signalConditionsASAP(NULL, pos=0) ...
[10:20:15.055] - nx: 2
[10:20:15.055] - relay: TRUE
[10:20:15.055] - stdout: TRUE
[10:20:15.055] - signal: TRUE
[10:20:15.055] - resignal: FALSE
[10:20:15.056] - force: TRUE
[10:20:15.056] - relayed: [n=2] TRUE, FALSE
[10:20:15.056] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:20:15.056]  - relaying element #2
[10:20:15.056] result() for MulticoreFuture ...
[10:20:15.056] result() for MulticoreFuture ... done
[10:20:15.056] result() for MulticoreFuture ...
[10:20:15.056] result() for MulticoreFuture ... done
[10:20:15.057] result() for MulticoreFuture ...
[10:20:15.057] result() for MulticoreFuture ... done
[10:20:15.057] result() for MulticoreFuture ...
[10:20:15.057] result() for MulticoreFuture ... done
[10:20:15.057] - relayed: [n=2] TRUE, TRUE
[10:20:15.057] - queued futures: [n=2] TRUE, TRUE
[10:20:15.057] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[10:20:15.057] resolve() on list ... DONE
[10:20:15.057] result() for MulticoreFuture ...
[10:20:15.058] result() for MulticoreFuture ... done
[10:20:15.058] result() for MulticoreFuture ...
[10:20:15.058] result() for MulticoreFuture ... done
[10:20:15.058] result() for MulticoreFuture ...
[10:20:15.058] result() for MulticoreFuture ... done
[10:20:15.058] result() for MulticoreFuture ...
[10:20:15.058] result() for MulticoreFuture ... done
[10:20:15.058]  - Number of value chunks collected: 2
[10:20:15.058] Resolving 2 futures (chunks) ... DONE
[10:20:15.059] Reducing values from 2 chunks ...
[10:20:15.059]  - Number of values collected after concatenation: 2
[10:20:15.059]  - Number of values expected: 2
[10:20:15.059] Reducing values from 2 chunks ... DONE
[10:20:15.059] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[10:20:15.059] future_lapply() ...
[10:20:15.062] Number of chunks: 2
[10:20:15.063] getGlobalsAndPackagesXApply() ...
[10:20:15.063]  - future.globals: TRUE
[10:20:15.063] getGlobalsAndPackages() ...
[10:20:15.063] Searching for globals...
[10:20:15.065] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:20:15.065] Searching for globals ... DONE
[10:20:15.065] Resolving globals: FALSE
[10:20:15.065] The total size of the 1 globals is 841 bytes (841 bytes)
[10:20:15.066] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[10:20:15.066] - globals: [1] ‘FUN’
[10:20:15.066] 
[10:20:15.066] getGlobalsAndPackages() ... DONE
[10:20:15.066]  - globals found/used: [n=1] ‘FUN’
[10:20:15.066]  - needed namespaces: [n=0] 
[10:20:15.067] Finding globals ... DONE
[10:20:15.067]  - use_args: TRUE
[10:20:15.067]  - Getting '...' globals ...
[10:20:15.067] resolve() on list ...
[10:20:15.067]  recursive: 0
[10:20:15.067]  length: 1
[10:20:15.067]  elements: ‘...’
[10:20:15.068]  length: 0 (resolved future 1)
[10:20:15.068] resolve() on list ... DONE
[10:20:15.068]    - '...' content: [n=0] 
[10:20:15.070] List of 1
[10:20:15.070]  $ ...: list()
[10:20:15.070]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:15.070]  - attr(*, "where")=List of 1
[10:20:15.070]   ..$ ...:<environment: 0x557fc1eb0790> 
[10:20:15.070]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:15.070]  - attr(*, "resolved")= logi TRUE
[10:20:15.070]  - attr(*, "total_size")= num NA
[10:20:15.073]  - Getting '...' globals ... DONE
[10:20:15.073] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:20:15.073] List of 2
[10:20:15.073]  $ ...future.FUN:function (x)  
[10:20:15.073]  $ ...          : list()
[10:20:15.073]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:15.073]  - attr(*, "where")=List of 2
[10:20:15.073]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:15.073]   ..$ ...          :<environment: 0x557fc1eb0790> 
[10:20:15.073]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:15.073]  - attr(*, "resolved")= logi FALSE
[10:20:15.073]  - attr(*, "total_size")= num 5632
[10:20:15.076] Packages to be attached in all futures: [n=0] 
[10:20:15.076] getGlobalsAndPackagesXApply() ... DONE
[10:20:15.076] Number of futures (= number of chunks): 2
[10:20:15.077] Launching 2 futures (chunks) ...
[10:20:15.077] Chunk #1 of 2 ...
[10:20:15.077]  - Finding globals in 'X' for chunk #1 ...
[10:20:15.077] getGlobalsAndPackages() ...
[10:20:15.077] Searching for globals...
[10:20:15.077] 
[10:20:15.077] Searching for globals ... DONE
[10:20:15.077] - globals: [0] <none>
[10:20:15.077] getGlobalsAndPackages() ... DONE
[10:20:15.078]    + additional globals found: [n=0] 
[10:20:15.078]    + additional namespaces needed: [n=0] 
[10:20:15.078]  - Finding globals in 'X' for chunk #1 ... DONE
[10:20:15.078]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:15.078]  - seeds: <none>
[10:20:15.078]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:15.078] getGlobalsAndPackages() ...
[10:20:15.078] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:15.078] Resolving globals: FALSE
[10:20:15.078] Tweak future expression to call with '...' arguments ...
[10:20:15.079] {
[10:20:15.079]     do.call(function(...) {
[10:20:15.079]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:15.079]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:15.079]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:15.079]             on.exit(options(oopts), add = TRUE)
[10:20:15.079]         }
[10:20:15.079]         {
[10:20:15.079]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:15.079]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:15.079]                 ...future.FUN(...future.X_jj, ...)
[10:20:15.079]             })
[10:20:15.079]         }
[10:20:15.079]     }, args = future.call.arguments)
[10:20:15.079] }
[10:20:15.079] Tweak future expression to call with '...' arguments ... DONE
[10:20:15.079] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:15.079] 
[10:20:15.079] getGlobalsAndPackages() ... DONE
[10:20:15.080] run() for ‘Future’ ...
[10:20:15.080] - state: ‘created’
[10:20:15.080] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:20:15.082] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:15.082] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:20:15.082]   - Field: ‘label’
[10:20:15.082]   - Field: ‘local’
[10:20:15.082]   - Field: ‘owner’
[10:20:15.082]   - Field: ‘envir’
[10:20:15.082]   - Field: ‘workers’
[10:20:15.082]   - Field: ‘packages’
[10:20:15.082]   - Field: ‘gc’
[10:20:15.083]   - Field: ‘job’
[10:20:15.083]   - Field: ‘conditions’
[10:20:15.083]   - Field: ‘expr’
[10:20:15.083]   - Field: ‘uuid’
[10:20:15.083]   - Field: ‘seed’
[10:20:15.083]   - Field: ‘version’
[10:20:15.083]   - Field: ‘result’
[10:20:15.083]   - Field: ‘asynchronous’
[10:20:15.083]   - Field: ‘calls’
[10:20:15.083]   - Field: ‘globals’
[10:20:15.083]   - Field: ‘stdout’
[10:20:15.083]   - Field: ‘earlySignal’
[10:20:15.084]   - Field: ‘lazy’
[10:20:15.084]   - Field: ‘state’
[10:20:15.084] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:20:15.084] - Launch lazy future ...
[10:20:15.084] Packages needed by the future expression (n = 0): <none>
[10:20:15.084] Packages needed by future strategies (n = 0): <none>
[10:20:15.085] {
[10:20:15.085]     {
[10:20:15.085]         {
[10:20:15.085]             ...future.startTime <- base::Sys.time()
[10:20:15.085]             {
[10:20:15.085]                 {
[10:20:15.085]                   {
[10:20:15.085]                     {
[10:20:15.085]                       base::local({
[10:20:15.085]                         has_future <- base::requireNamespace("future", 
[10:20:15.085]                           quietly = TRUE)
[10:20:15.085]                         if (has_future) {
[10:20:15.085]                           ns <- base::getNamespace("future")
[10:20:15.085]                           version <- ns[[".package"]][["version"]]
[10:20:15.085]                           if (is.null(version)) 
[10:20:15.085]                             version <- utils::packageVersion("future")
[10:20:15.085]                         }
[10:20:15.085]                         else {
[10:20:15.085]                           version <- NULL
[10:20:15.085]                         }
[10:20:15.085]                         if (!has_future || version < "1.8.0") {
[10:20:15.085]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:15.085]                             "", base::R.version$version.string), 
[10:20:15.085]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:15.085]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:15.085]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:15.085]                               "release", "version")], collapse = " "), 
[10:20:15.085]                             hostname = base::Sys.info()[["nodename"]])
[10:20:15.085]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:15.085]                             info)
[10:20:15.085]                           info <- base::paste(info, collapse = "; ")
[10:20:15.085]                           if (!has_future) {
[10:20:15.085]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:15.085]                               info)
[10:20:15.085]                           }
[10:20:15.085]                           else {
[10:20:15.085]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:15.085]                               info, version)
[10:20:15.085]                           }
[10:20:15.085]                           base::stop(msg)
[10:20:15.085]                         }
[10:20:15.085]                       })
[10:20:15.085]                     }
[10:20:15.085]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:15.085]                     base::options(mc.cores = 1L)
[10:20:15.085]                   }
[10:20:15.085]                   ...future.strategy.old <- future::plan("list")
[10:20:15.085]                   options(future.plan = NULL)
[10:20:15.085]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:15.085]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:15.085]                 }
[10:20:15.085]                 ...future.workdir <- getwd()
[10:20:15.085]             }
[10:20:15.085]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:15.085]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:15.085]         }
[10:20:15.085]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:15.085]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:15.085]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:15.085]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:15.085]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:15.085]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:15.085]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:15.085]             base::names(...future.oldOptions))
[10:20:15.085]     }
[10:20:15.085]     if (FALSE) {
[10:20:15.085]     }
[10:20:15.085]     else {
[10:20:15.085]         if (TRUE) {
[10:20:15.085]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:15.085]                 open = "w")
[10:20:15.085]         }
[10:20:15.085]         else {
[10:20:15.085]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:15.085]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:15.085]         }
[10:20:15.085]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:15.085]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:15.085]             base::sink(type = "output", split = FALSE)
[10:20:15.085]             base::close(...future.stdout)
[10:20:15.085]         }, add = TRUE)
[10:20:15.085]     }
[10:20:15.085]     ...future.frame <- base::sys.nframe()
[10:20:15.085]     ...future.conditions <- base::list()
[10:20:15.085]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:15.085]     if (FALSE) {
[10:20:15.085]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:15.085]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:15.085]     }
[10:20:15.085]     ...future.result <- base::tryCatch({
[10:20:15.085]         base::withCallingHandlers({
[10:20:15.085]             ...future.value <- base::withVisible(base::local({
[10:20:15.085]                 withCallingHandlers({
[10:20:15.085]                   {
[10:20:15.085]                     do.call(function(...) {
[10:20:15.085]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:15.085]                       if (!identical(...future.globals.maxSize.org, 
[10:20:15.085]                         ...future.globals.maxSize)) {
[10:20:15.085]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:15.085]                         on.exit(options(oopts), add = TRUE)
[10:20:15.085]                       }
[10:20:15.085]                       {
[10:20:15.085]                         lapply(seq_along(...future.elements_ii), 
[10:20:15.085]                           FUN = function(jj) {
[10:20:15.085]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:15.085]                             ...future.FUN(...future.X_jj, ...)
[10:20:15.085]                           })
[10:20:15.085]                       }
[10:20:15.085]                     }, args = future.call.arguments)
[10:20:15.085]                   }
[10:20:15.085]                 }, immediateCondition = function(cond) {
[10:20:15.085]                   save_rds <- function (object, pathname, ...) 
[10:20:15.085]                   {
[10:20:15.085]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:20:15.085]                     if (file_test("-f", pathname_tmp)) {
[10:20:15.085]                       fi_tmp <- file.info(pathname_tmp)
[10:20:15.085]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:20:15.085]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:15.085]                         fi_tmp[["mtime"]])
[10:20:15.085]                     }
[10:20:15.085]                     tryCatch({
[10:20:15.085]                       saveRDS(object, file = pathname_tmp, ...)
[10:20:15.085]                     }, error = function(ex) {
[10:20:15.085]                       msg <- conditionMessage(ex)
[10:20:15.085]                       fi_tmp <- file.info(pathname_tmp)
[10:20:15.085]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:20:15.085]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:15.085]                         fi_tmp[["mtime"]], msg)
[10:20:15.085]                       ex$message <- msg
[10:20:15.085]                       stop(ex)
[10:20:15.085]                     })
[10:20:15.085]                     stopifnot(file_test("-f", pathname_tmp))
[10:20:15.085]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:20:15.085]                     if (!res || file_test("-f", pathname_tmp)) {
[10:20:15.085]                       fi_tmp <- file.info(pathname_tmp)
[10:20:15.085]                       fi <- file.info(pathname)
[10:20:15.085]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:20:15.085]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:15.085]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:20:15.085]                         fi[["size"]], fi[["mtime"]])
[10:20:15.085]                       stop(msg)
[10:20:15.085]                     }
[10:20:15.085]                     invisible(pathname)
[10:20:15.085]                   }
[10:20:15.085]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:20:15.085]                     rootPath = tempdir()) 
[10:20:15.085]                   {
[10:20:15.085]                     obj <- list(time = Sys.time(), condition = cond)
[10:20:15.085]                     file <- tempfile(pattern = class(cond)[1], 
[10:20:15.085]                       tmpdir = path, fileext = ".rds")
[10:20:15.085]                     save_rds(obj, file)
[10:20:15.085]                   }
[10:20:15.085]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8Z8Jdg/.future/immediateConditions")
[10:20:15.085]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:15.085]                   {
[10:20:15.085]                     inherits <- base::inherits
[10:20:15.085]                     invokeRestart <- base::invokeRestart
[10:20:15.085]                     is.null <- base::is.null
[10:20:15.085]                     muffled <- FALSE
[10:20:15.085]                     if (inherits(cond, "message")) {
[10:20:15.085]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:15.085]                       if (muffled) 
[10:20:15.085]                         invokeRestart("muffleMessage")
[10:20:15.085]                     }
[10:20:15.085]                     else if (inherits(cond, "warning")) {
[10:20:15.085]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:15.085]                       if (muffled) 
[10:20:15.085]                         invokeRestart("muffleWarning")
[10:20:15.085]                     }
[10:20:15.085]                     else if (inherits(cond, "condition")) {
[10:20:15.085]                       if (!is.null(pattern)) {
[10:20:15.085]                         computeRestarts <- base::computeRestarts
[10:20:15.085]                         grepl <- base::grepl
[10:20:15.085]                         restarts <- computeRestarts(cond)
[10:20:15.085]                         for (restart in restarts) {
[10:20:15.085]                           name <- restart$name
[10:20:15.085]                           if (is.null(name)) 
[10:20:15.085]                             next
[10:20:15.085]                           if (!grepl(pattern, name)) 
[10:20:15.085]                             next
[10:20:15.085]                           invokeRestart(restart)
[10:20:15.085]                           muffled <- TRUE
[10:20:15.085]                           break
[10:20:15.085]                         }
[10:20:15.085]                       }
[10:20:15.085]                     }
[10:20:15.085]                     invisible(muffled)
[10:20:15.085]                   }
[10:20:15.085]                   muffleCondition(cond)
[10:20:15.085]                 })
[10:20:15.085]             }))
[10:20:15.085]             future::FutureResult(value = ...future.value$value, 
[10:20:15.085]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:15.085]                   ...future.rng), globalenv = if (FALSE) 
[10:20:15.085]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:15.085]                     ...future.globalenv.names))
[10:20:15.085]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:15.085]         }, condition = base::local({
[10:20:15.085]             c <- base::c
[10:20:15.085]             inherits <- base::inherits
[10:20:15.085]             invokeRestart <- base::invokeRestart
[10:20:15.085]             length <- base::length
[10:20:15.085]             list <- base::list
[10:20:15.085]             seq.int <- base::seq.int
[10:20:15.085]             signalCondition <- base::signalCondition
[10:20:15.085]             sys.calls <- base::sys.calls
[10:20:15.085]             `[[` <- base::`[[`
[10:20:15.085]             `+` <- base::`+`
[10:20:15.085]             `<<-` <- base::`<<-`
[10:20:15.085]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:15.085]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:15.085]                   3L)]
[10:20:15.085]             }
[10:20:15.085]             function(cond) {
[10:20:15.085]                 is_error <- inherits(cond, "error")
[10:20:15.085]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:15.085]                   NULL)
[10:20:15.085]                 if (is_error) {
[10:20:15.085]                   sessionInformation <- function() {
[10:20:15.085]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:15.085]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:15.085]                       search = base::search(), system = base::Sys.info())
[10:20:15.085]                   }
[10:20:15.085]                   ...future.conditions[[length(...future.conditions) + 
[10:20:15.085]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:15.085]                     cond$call), session = sessionInformation(), 
[10:20:15.085]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:15.085]                   signalCondition(cond)
[10:20:15.085]                 }
[10:20:15.085]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:15.085]                 "immediateCondition"))) {
[10:20:15.085]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:15.085]                   ...future.conditions[[length(...future.conditions) + 
[10:20:15.085]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:15.085]                   if (TRUE && !signal) {
[10:20:15.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:15.085]                     {
[10:20:15.085]                       inherits <- base::inherits
[10:20:15.085]                       invokeRestart <- base::invokeRestart
[10:20:15.085]                       is.null <- base::is.null
[10:20:15.085]                       muffled <- FALSE
[10:20:15.085]                       if (inherits(cond, "message")) {
[10:20:15.085]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:15.085]                         if (muffled) 
[10:20:15.085]                           invokeRestart("muffleMessage")
[10:20:15.085]                       }
[10:20:15.085]                       else if (inherits(cond, "warning")) {
[10:20:15.085]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:15.085]                         if (muffled) 
[10:20:15.085]                           invokeRestart("muffleWarning")
[10:20:15.085]                       }
[10:20:15.085]                       else if (inherits(cond, "condition")) {
[10:20:15.085]                         if (!is.null(pattern)) {
[10:20:15.085]                           computeRestarts <- base::computeRestarts
[10:20:15.085]                           grepl <- base::grepl
[10:20:15.085]                           restarts <- computeRestarts(cond)
[10:20:15.085]                           for (restart in restarts) {
[10:20:15.085]                             name <- restart$name
[10:20:15.085]                             if (is.null(name)) 
[10:20:15.085]                               next
[10:20:15.085]                             if (!grepl(pattern, name)) 
[10:20:15.085]                               next
[10:20:15.085]                             invokeRestart(restart)
[10:20:15.085]                             muffled <- TRUE
[10:20:15.085]                             break
[10:20:15.085]                           }
[10:20:15.085]                         }
[10:20:15.085]                       }
[10:20:15.085]                       invisible(muffled)
[10:20:15.085]                     }
[10:20:15.085]                     muffleCondition(cond, pattern = "^muffle")
[10:20:15.085]                   }
[10:20:15.085]                 }
[10:20:15.085]                 else {
[10:20:15.085]                   if (TRUE) {
[10:20:15.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:15.085]                     {
[10:20:15.085]                       inherits <- base::inherits
[10:20:15.085]                       invokeRestart <- base::invokeRestart
[10:20:15.085]                       is.null <- base::is.null
[10:20:15.085]                       muffled <- FALSE
[10:20:15.085]                       if (inherits(cond, "message")) {
[10:20:15.085]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:15.085]                         if (muffled) 
[10:20:15.085]                           invokeRestart("muffleMessage")
[10:20:15.085]                       }
[10:20:15.085]                       else if (inherits(cond, "warning")) {
[10:20:15.085]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:15.085]                         if (muffled) 
[10:20:15.085]                           invokeRestart("muffleWarning")
[10:20:15.085]                       }
[10:20:15.085]                       else if (inherits(cond, "condition")) {
[10:20:15.085]                         if (!is.null(pattern)) {
[10:20:15.085]                           computeRestarts <- base::computeRestarts
[10:20:15.085]                           grepl <- base::grepl
[10:20:15.085]                           restarts <- computeRestarts(cond)
[10:20:15.085]                           for (restart in restarts) {
[10:20:15.085]                             name <- restart$name
[10:20:15.085]                             if (is.null(name)) 
[10:20:15.085]                               next
[10:20:15.085]                             if (!grepl(pattern, name)) 
[10:20:15.085]                               next
[10:20:15.085]                             invokeRestart(restart)
[10:20:15.085]                             muffled <- TRUE
[10:20:15.085]                             break
[10:20:15.085]                           }
[10:20:15.085]                         }
[10:20:15.085]                       }
[10:20:15.085]                       invisible(muffled)
[10:20:15.085]                     }
[10:20:15.085]                     muffleCondition(cond, pattern = "^muffle")
[10:20:15.085]                   }
[10:20:15.085]                 }
[10:20:15.085]             }
[10:20:15.085]         }))
[10:20:15.085]     }, error = function(ex) {
[10:20:15.085]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:15.085]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:15.085]                 ...future.rng), started = ...future.startTime, 
[10:20:15.085]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:15.085]             version = "1.8"), class = "FutureResult")
[10:20:15.085]     }, finally = {
[10:20:15.085]         if (!identical(...future.workdir, getwd())) 
[10:20:15.085]             setwd(...future.workdir)
[10:20:15.085]         {
[10:20:15.085]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:15.085]                 ...future.oldOptions$nwarnings <- NULL
[10:20:15.085]             }
[10:20:15.085]             base::options(...future.oldOptions)
[10:20:15.085]             if (.Platform$OS.type == "windows") {
[10:20:15.085]                 old_names <- names(...future.oldEnvVars)
[10:20:15.085]                 envs <- base::Sys.getenv()
[10:20:15.085]                 names <- names(envs)
[10:20:15.085]                 common <- intersect(names, old_names)
[10:20:15.085]                 added <- setdiff(names, old_names)
[10:20:15.085]                 removed <- setdiff(old_names, names)
[10:20:15.085]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:15.085]                   envs[common]]
[10:20:15.085]                 NAMES <- toupper(changed)
[10:20:15.085]                 args <- list()
[10:20:15.085]                 for (kk in seq_along(NAMES)) {
[10:20:15.085]                   name <- changed[[kk]]
[10:20:15.085]                   NAME <- NAMES[[kk]]
[10:20:15.085]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:15.085]                     next
[10:20:15.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:15.085]                 }
[10:20:15.085]                 NAMES <- toupper(added)
[10:20:15.085]                 for (kk in seq_along(NAMES)) {
[10:20:15.085]                   name <- added[[kk]]
[10:20:15.085]                   NAME <- NAMES[[kk]]
[10:20:15.085]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:15.085]                     next
[10:20:15.085]                   args[[name]] <- ""
[10:20:15.085]                 }
[10:20:15.085]                 NAMES <- toupper(removed)
[10:20:15.085]                 for (kk in seq_along(NAMES)) {
[10:20:15.085]                   name <- removed[[kk]]
[10:20:15.085]                   NAME <- NAMES[[kk]]
[10:20:15.085]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:15.085]                     next
[10:20:15.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:15.085]                 }
[10:20:15.085]                 if (length(args) > 0) 
[10:20:15.085]                   base::do.call(base::Sys.setenv, args = args)
[10:20:15.085]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:15.085]             }
[10:20:15.085]             else {
[10:20:15.085]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:15.085]             }
[10:20:15.085]             {
[10:20:15.085]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:15.085]                   0L) {
[10:20:15.085]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:15.085]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:15.085]                   base::options(opts)
[10:20:15.085]                 }
[10:20:15.085]                 {
[10:20:15.085]                   {
[10:20:15.085]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:15.085]                     NULL
[10:20:15.085]                   }
[10:20:15.085]                   options(future.plan = NULL)
[10:20:15.085]                   if (is.na(NA_character_)) 
[10:20:15.085]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:15.085]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:15.085]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:15.085]                     .init = FALSE)
[10:20:15.085]                 }
[10:20:15.085]             }
[10:20:15.085]         }
[10:20:15.085]     })
[10:20:15.085]     if (TRUE) {
[10:20:15.085]         base::sink(type = "output", split = FALSE)
[10:20:15.085]         if (TRUE) {
[10:20:15.085]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:15.085]         }
[10:20:15.085]         else {
[10:20:15.085]             ...future.result["stdout"] <- base::list(NULL)
[10:20:15.085]         }
[10:20:15.085]         base::close(...future.stdout)
[10:20:15.085]         ...future.stdout <- NULL
[10:20:15.085]     }
[10:20:15.085]     ...future.result$conditions <- ...future.conditions
[10:20:15.085]     ...future.result$finished <- base::Sys.time()
[10:20:15.085]     ...future.result
[10:20:15.085] }
[10:20:15.087] assign_globals() ...
[10:20:15.087] List of 5
[10:20:15.087]  $ ...future.FUN            :function (x)  
[10:20:15.087]  $ future.call.arguments    : list()
[10:20:15.087]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:15.087]  $ ...future.elements_ii    :List of 1
[10:20:15.087]   ..$ : int 1
[10:20:15.087]  $ ...future.seeds_ii       : NULL
[10:20:15.087]  $ ...future.globals.maxSize: NULL
[10:20:15.087]  - attr(*, "where")=List of 5
[10:20:15.087]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:15.087]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:20:15.087]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:15.087]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:15.087]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:15.087]  - attr(*, "resolved")= logi FALSE
[10:20:15.087]  - attr(*, "total_size")= num 5632
[10:20:15.087]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:15.087]  - attr(*, "already-done")= logi TRUE
[10:20:15.092] - reassign environment for ‘...future.FUN’
[10:20:15.092] - copied ‘...future.FUN’ to environment
[10:20:15.092] - copied ‘future.call.arguments’ to environment
[10:20:15.092] - copied ‘...future.elements_ii’ to environment
[10:20:15.092] - copied ‘...future.seeds_ii’ to environment
[10:20:15.092] - copied ‘...future.globals.maxSize’ to environment
[10:20:15.093] assign_globals() ... done
[10:20:15.093] requestCore(): workers = 2
[10:20:15.095] MulticoreFuture started
[10:20:15.095] - Launch lazy future ... done
[10:20:15.096] run() for ‘MulticoreFuture’ ... done
[10:20:15.096] Created future:
[10:20:15.096] plan(): Setting new future strategy stack:
[10:20:15.096] List of future strategies:
[10:20:15.096] 1. sequential:
[10:20:15.096]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:15.096]    - tweaked: FALSE
[10:20:15.096]    - call: NULL
[10:20:15.097] plan(): nbrOfWorkers() = 1
[10:20:15.096] MulticoreFuture:
[10:20:15.096] Label: ‘future_lapply-1’
[10:20:15.096] Expression:
[10:20:15.096] {
[10:20:15.096]     do.call(function(...) {
[10:20:15.096]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:15.096]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:15.096]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:15.096]             on.exit(options(oopts), add = TRUE)
[10:20:15.096]         }
[10:20:15.096]         {
[10:20:15.096]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:15.096]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:15.096]                 ...future.FUN(...future.X_jj, ...)
[10:20:15.096]             })
[10:20:15.096]         }
[10:20:15.096]     }, args = future.call.arguments)
[10:20:15.096] }
[10:20:15.096] Lazy evaluation: FALSE
[10:20:15.096] Asynchronous evaluation: TRUE
[10:20:15.096] Local evaluation: TRUE
[10:20:15.096] Environment: R_GlobalEnv
[10:20:15.096] Capture standard output: TRUE
[10:20:15.096] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:15.096] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:15.096] Packages: <none>
[10:20:15.096] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:15.096] Resolved: FALSE
[10:20:15.096] Value: <not collected>
[10:20:15.096] Conditions captured: <none>
[10:20:15.096] Early signaling: FALSE
[10:20:15.096] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:15.096] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:15.109] Chunk #1 of 2 ... DONE
[10:20:15.109] Chunk #2 of 2 ...
[10:20:15.109]  - Finding globals in 'X' for chunk #2 ...
[10:20:15.113] getGlobalsAndPackages() ...
[10:20:15.113] Searching for globals...
[10:20:15.115] 
[10:20:15.115] Searching for globals ... DONE
[10:20:15.115] - globals: [0] <none>
[10:20:15.116] getGlobalsAndPackages() ... DONE
[10:20:15.116]    + additional globals found: [n=0] 
[10:20:15.116]    + additional namespaces needed: [n=0] 
[10:20:15.117]  - Finding globals in 'X' for chunk #2 ... DONE
[10:20:15.117]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:15.117]  - seeds: <none>
[10:20:15.118]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:15.118] getGlobalsAndPackages() ...
[10:20:15.118] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:15.119] Resolving globals: FALSE
[10:20:15.119] Tweak future expression to call with '...' arguments ...
[10:20:15.119] {
[10:20:15.119]     do.call(function(...) {
[10:20:15.119]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:15.119]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:15.119]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:15.119]             on.exit(options(oopts), add = TRUE)
[10:20:15.119]         }
[10:20:15.119]         {
[10:20:15.119]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:15.119]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:15.119]                 ...future.FUN(...future.X_jj, ...)
[10:20:15.119]             })
[10:20:15.119]         }
[10:20:15.119]     }, args = future.call.arguments)
[10:20:15.119] }
[10:20:15.120] Tweak future expression to call with '...' arguments ... DONE
[10:20:15.121] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:15.121] 
[10:20:15.121] getGlobalsAndPackages() ... DONE
[10:20:15.122] run() for ‘Future’ ...
[10:20:15.122] - state: ‘created’
[10:20:15.122] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:20:15.125] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:15.125] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:20:15.126]   - Field: ‘label’
[10:20:15.126]   - Field: ‘local’
[10:20:15.126]   - Field: ‘owner’
[10:20:15.126]   - Field: ‘envir’
[10:20:15.126]   - Field: ‘workers’
[10:20:15.126]   - Field: ‘packages’
[10:20:15.127]   - Field: ‘gc’
[10:20:15.127]   - Field: ‘job’
[10:20:15.127]   - Field: ‘conditions’
[10:20:15.127]   - Field: ‘expr’
[10:20:15.127]   - Field: ‘uuid’
[10:20:15.127]   - Field: ‘seed’
[10:20:15.127]   - Field: ‘version’
[10:20:15.127]   - Field: ‘result’
[10:20:15.128]   - Field: ‘asynchronous’
[10:20:15.128]   - Field: ‘calls’
[10:20:15.128]   - Field: ‘globals’
[10:20:15.128]   - Field: ‘stdout’
[10:20:15.128]   - Field: ‘earlySignal’
[10:20:15.128]   - Field: ‘lazy’
[10:20:15.128]   - Field: ‘state’
[10:20:15.128] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:20:15.129] - Launch lazy future ...
[10:20:15.129] Packages needed by the future expression (n = 0): <none>
[10:20:15.129] Packages needed by future strategies (n = 0): <none>
[10:20:15.130] {
[10:20:15.130]     {
[10:20:15.130]         {
[10:20:15.130]             ...future.startTime <- base::Sys.time()
[10:20:15.130]             {
[10:20:15.130]                 {
[10:20:15.130]                   {
[10:20:15.130]                     {
[10:20:15.130]                       base::local({
[10:20:15.130]                         has_future <- base::requireNamespace("future", 
[10:20:15.130]                           quietly = TRUE)
[10:20:15.130]                         if (has_future) {
[10:20:15.130]                           ns <- base::getNamespace("future")
[10:20:15.130]                           version <- ns[[".package"]][["version"]]
[10:20:15.130]                           if (is.null(version)) 
[10:20:15.130]                             version <- utils::packageVersion("future")
[10:20:15.130]                         }
[10:20:15.130]                         else {
[10:20:15.130]                           version <- NULL
[10:20:15.130]                         }
[10:20:15.130]                         if (!has_future || version < "1.8.0") {
[10:20:15.130]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:15.130]                             "", base::R.version$version.string), 
[10:20:15.130]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:15.130]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:15.130]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:15.130]                               "release", "version")], collapse = " "), 
[10:20:15.130]                             hostname = base::Sys.info()[["nodename"]])
[10:20:15.130]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:15.130]                             info)
[10:20:15.130]                           info <- base::paste(info, collapse = "; ")
[10:20:15.130]                           if (!has_future) {
[10:20:15.130]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:15.130]                               info)
[10:20:15.130]                           }
[10:20:15.130]                           else {
[10:20:15.130]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:15.130]                               info, version)
[10:20:15.130]                           }
[10:20:15.130]                           base::stop(msg)
[10:20:15.130]                         }
[10:20:15.130]                       })
[10:20:15.130]                     }
[10:20:15.130]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:15.130]                     base::options(mc.cores = 1L)
[10:20:15.130]                   }
[10:20:15.130]                   ...future.strategy.old <- future::plan("list")
[10:20:15.130]                   options(future.plan = NULL)
[10:20:15.130]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:15.130]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:15.130]                 }
[10:20:15.130]                 ...future.workdir <- getwd()
[10:20:15.130]             }
[10:20:15.130]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:15.130]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:15.130]         }
[10:20:15.130]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:15.130]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:15.130]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:15.130]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:15.130]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:15.130]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:15.130]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:15.130]             base::names(...future.oldOptions))
[10:20:15.130]     }
[10:20:15.130]     if (FALSE) {
[10:20:15.130]     }
[10:20:15.130]     else {
[10:20:15.130]         if (TRUE) {
[10:20:15.130]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:15.130]                 open = "w")
[10:20:15.130]         }
[10:20:15.130]         else {
[10:20:15.130]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:15.130]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:15.130]         }
[10:20:15.130]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:15.130]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:15.130]             base::sink(type = "output", split = FALSE)
[10:20:15.130]             base::close(...future.stdout)
[10:20:15.130]         }, add = TRUE)
[10:20:15.130]     }
[10:20:15.130]     ...future.frame <- base::sys.nframe()
[10:20:15.130]     ...future.conditions <- base::list()
[10:20:15.130]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:15.130]     if (FALSE) {
[10:20:15.130]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:15.130]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:15.130]     }
[10:20:15.130]     ...future.result <- base::tryCatch({
[10:20:15.130]         base::withCallingHandlers({
[10:20:15.130]             ...future.value <- base::withVisible(base::local({
[10:20:15.130]                 withCallingHandlers({
[10:20:15.130]                   {
[10:20:15.130]                     do.call(function(...) {
[10:20:15.130]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:15.130]                       if (!identical(...future.globals.maxSize.org, 
[10:20:15.130]                         ...future.globals.maxSize)) {
[10:20:15.130]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:15.130]                         on.exit(options(oopts), add = TRUE)
[10:20:15.130]                       }
[10:20:15.130]                       {
[10:20:15.130]                         lapply(seq_along(...future.elements_ii), 
[10:20:15.130]                           FUN = function(jj) {
[10:20:15.130]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:15.130]                             ...future.FUN(...future.X_jj, ...)
[10:20:15.130]                           })
[10:20:15.130]                       }
[10:20:15.130]                     }, args = future.call.arguments)
[10:20:15.130]                   }
[10:20:15.130]                 }, immediateCondition = function(cond) {
[10:20:15.130]                   save_rds <- function (object, pathname, ...) 
[10:20:15.130]                   {
[10:20:15.130]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:20:15.130]                     if (file_test("-f", pathname_tmp)) {
[10:20:15.130]                       fi_tmp <- file.info(pathname_tmp)
[10:20:15.130]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:20:15.130]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:15.130]                         fi_tmp[["mtime"]])
[10:20:15.130]                     }
[10:20:15.130]                     tryCatch({
[10:20:15.130]                       saveRDS(object, file = pathname_tmp, ...)
[10:20:15.130]                     }, error = function(ex) {
[10:20:15.130]                       msg <- conditionMessage(ex)
[10:20:15.130]                       fi_tmp <- file.info(pathname_tmp)
[10:20:15.130]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:20:15.130]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:15.130]                         fi_tmp[["mtime"]], msg)
[10:20:15.130]                       ex$message <- msg
[10:20:15.130]                       stop(ex)
[10:20:15.130]                     })
[10:20:15.130]                     stopifnot(file_test("-f", pathname_tmp))
[10:20:15.130]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:20:15.130]                     if (!res || file_test("-f", pathname_tmp)) {
[10:20:15.130]                       fi_tmp <- file.info(pathname_tmp)
[10:20:15.130]                       fi <- file.info(pathname)
[10:20:15.130]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:20:15.130]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:15.130]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:20:15.130]                         fi[["size"]], fi[["mtime"]])
[10:20:15.130]                       stop(msg)
[10:20:15.130]                     }
[10:20:15.130]                     invisible(pathname)
[10:20:15.130]                   }
[10:20:15.130]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:20:15.130]                     rootPath = tempdir()) 
[10:20:15.130]                   {
[10:20:15.130]                     obj <- list(time = Sys.time(), condition = cond)
[10:20:15.130]                     file <- tempfile(pattern = class(cond)[1], 
[10:20:15.130]                       tmpdir = path, fileext = ".rds")
[10:20:15.130]                     save_rds(obj, file)
[10:20:15.130]                   }
[10:20:15.130]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8Z8Jdg/.future/immediateConditions")
[10:20:15.130]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:15.130]                   {
[10:20:15.130]                     inherits <- base::inherits
[10:20:15.130]                     invokeRestart <- base::invokeRestart
[10:20:15.130]                     is.null <- base::is.null
[10:20:15.130]                     muffled <- FALSE
[10:20:15.130]                     if (inherits(cond, "message")) {
[10:20:15.130]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:15.130]                       if (muffled) 
[10:20:15.130]                         invokeRestart("muffleMessage")
[10:20:15.130]                     }
[10:20:15.130]                     else if (inherits(cond, "warning")) {
[10:20:15.130]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:15.130]                       if (muffled) 
[10:20:15.130]                         invokeRestart("muffleWarning")
[10:20:15.130]                     }
[10:20:15.130]                     else if (inherits(cond, "condition")) {
[10:20:15.130]                       if (!is.null(pattern)) {
[10:20:15.130]                         computeRestarts <- base::computeRestarts
[10:20:15.130]                         grepl <- base::grepl
[10:20:15.130]                         restarts <- computeRestarts(cond)
[10:20:15.130]                         for (restart in restarts) {
[10:20:15.130]                           name <- restart$name
[10:20:15.130]                           if (is.null(name)) 
[10:20:15.130]                             next
[10:20:15.130]                           if (!grepl(pattern, name)) 
[10:20:15.130]                             next
[10:20:15.130]                           invokeRestart(restart)
[10:20:15.130]                           muffled <- TRUE
[10:20:15.130]                           break
[10:20:15.130]                         }
[10:20:15.130]                       }
[10:20:15.130]                     }
[10:20:15.130]                     invisible(muffled)
[10:20:15.130]                   }
[10:20:15.130]                   muffleCondition(cond)
[10:20:15.130]                 })
[10:20:15.130]             }))
[10:20:15.130]             future::FutureResult(value = ...future.value$value, 
[10:20:15.130]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:15.130]                   ...future.rng), globalenv = if (FALSE) 
[10:20:15.130]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:15.130]                     ...future.globalenv.names))
[10:20:15.130]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:15.130]         }, condition = base::local({
[10:20:15.130]             c <- base::c
[10:20:15.130]             inherits <- base::inherits
[10:20:15.130]             invokeRestart <- base::invokeRestart
[10:20:15.130]             length <- base::length
[10:20:15.130]             list <- base::list
[10:20:15.130]             seq.int <- base::seq.int
[10:20:15.130]             signalCondition <- base::signalCondition
[10:20:15.130]             sys.calls <- base::sys.calls
[10:20:15.130]             `[[` <- base::`[[`
[10:20:15.130]             `+` <- base::`+`
[10:20:15.130]             `<<-` <- base::`<<-`
[10:20:15.130]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:15.130]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:15.130]                   3L)]
[10:20:15.130]             }
[10:20:15.130]             function(cond) {
[10:20:15.130]                 is_error <- inherits(cond, "error")
[10:20:15.130]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:15.130]                   NULL)
[10:20:15.130]                 if (is_error) {
[10:20:15.130]                   sessionInformation <- function() {
[10:20:15.130]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:15.130]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:15.130]                       search = base::search(), system = base::Sys.info())
[10:20:15.130]                   }
[10:20:15.130]                   ...future.conditions[[length(...future.conditions) + 
[10:20:15.130]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:15.130]                     cond$call), session = sessionInformation(), 
[10:20:15.130]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:15.130]                   signalCondition(cond)
[10:20:15.130]                 }
[10:20:15.130]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:15.130]                 "immediateCondition"))) {
[10:20:15.130]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:15.130]                   ...future.conditions[[length(...future.conditions) + 
[10:20:15.130]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:15.130]                   if (TRUE && !signal) {
[10:20:15.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:15.130]                     {
[10:20:15.130]                       inherits <- base::inherits
[10:20:15.130]                       invokeRestart <- base::invokeRestart
[10:20:15.130]                       is.null <- base::is.null
[10:20:15.130]                       muffled <- FALSE
[10:20:15.130]                       if (inherits(cond, "message")) {
[10:20:15.130]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:15.130]                         if (muffled) 
[10:20:15.130]                           invokeRestart("muffleMessage")
[10:20:15.130]                       }
[10:20:15.130]                       else if (inherits(cond, "warning")) {
[10:20:15.130]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:15.130]                         if (muffled) 
[10:20:15.130]                           invokeRestart("muffleWarning")
[10:20:15.130]                       }
[10:20:15.130]                       else if (inherits(cond, "condition")) {
[10:20:15.130]                         if (!is.null(pattern)) {
[10:20:15.130]                           computeRestarts <- base::computeRestarts
[10:20:15.130]                           grepl <- base::grepl
[10:20:15.130]                           restarts <- computeRestarts(cond)
[10:20:15.130]                           for (restart in restarts) {
[10:20:15.130]                             name <- restart$name
[10:20:15.130]                             if (is.null(name)) 
[10:20:15.130]                               next
[10:20:15.130]                             if (!grepl(pattern, name)) 
[10:20:15.130]                               next
[10:20:15.130]                             invokeRestart(restart)
[10:20:15.130]                             muffled <- TRUE
[10:20:15.130]                             break
[10:20:15.130]                           }
[10:20:15.130]                         }
[10:20:15.130]                       }
[10:20:15.130]                       invisible(muffled)
[10:20:15.130]                     }
[10:20:15.130]                     muffleCondition(cond, pattern = "^muffle")
[10:20:15.130]                   }
[10:20:15.130]                 }
[10:20:15.130]                 else {
[10:20:15.130]                   if (TRUE) {
[10:20:15.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:15.130]                     {
[10:20:15.130]                       inherits <- base::inherits
[10:20:15.130]                       invokeRestart <- base::invokeRestart
[10:20:15.130]                       is.null <- base::is.null
[10:20:15.130]                       muffled <- FALSE
[10:20:15.130]                       if (inherits(cond, "message")) {
[10:20:15.130]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:15.130]                         if (muffled) 
[10:20:15.130]                           invokeRestart("muffleMessage")
[10:20:15.130]                       }
[10:20:15.130]                       else if (inherits(cond, "warning")) {
[10:20:15.130]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:15.130]                         if (muffled) 
[10:20:15.130]                           invokeRestart("muffleWarning")
[10:20:15.130]                       }
[10:20:15.130]                       else if (inherits(cond, "condition")) {
[10:20:15.130]                         if (!is.null(pattern)) {
[10:20:15.130]                           computeRestarts <- base::computeRestarts
[10:20:15.130]                           grepl <- base::grepl
[10:20:15.130]                           restarts <- computeRestarts(cond)
[10:20:15.130]                           for (restart in restarts) {
[10:20:15.130]                             name <- restart$name
[10:20:15.130]                             if (is.null(name)) 
[10:20:15.130]                               next
[10:20:15.130]                             if (!grepl(pattern, name)) 
[10:20:15.130]                               next
[10:20:15.130]                             invokeRestart(restart)
[10:20:15.130]                             muffled <- TRUE
[10:20:15.130]                             break
[10:20:15.130]                           }
[10:20:15.130]                         }
[10:20:15.130]                       }
[10:20:15.130]                       invisible(muffled)
[10:20:15.130]                     }
[10:20:15.130]                     muffleCondition(cond, pattern = "^muffle")
[10:20:15.130]                   }
[10:20:15.130]                 }
[10:20:15.130]             }
[10:20:15.130]         }))
[10:20:15.130]     }, error = function(ex) {
[10:20:15.130]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:15.130]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:15.130]                 ...future.rng), started = ...future.startTime, 
[10:20:15.130]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:15.130]             version = "1.8"), class = "FutureResult")
[10:20:15.130]     }, finally = {
[10:20:15.130]         if (!identical(...future.workdir, getwd())) 
[10:20:15.130]             setwd(...future.workdir)
[10:20:15.130]         {
[10:20:15.130]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:15.130]                 ...future.oldOptions$nwarnings <- NULL
[10:20:15.130]             }
[10:20:15.130]             base::options(...future.oldOptions)
[10:20:15.130]             if (.Platform$OS.type == "windows") {
[10:20:15.130]                 old_names <- names(...future.oldEnvVars)
[10:20:15.130]                 envs <- base::Sys.getenv()
[10:20:15.130]                 names <- names(envs)
[10:20:15.130]                 common <- intersect(names, old_names)
[10:20:15.130]                 added <- setdiff(names, old_names)
[10:20:15.130]                 removed <- setdiff(old_names, names)
[10:20:15.130]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:15.130]                   envs[common]]
[10:20:15.130]                 NAMES <- toupper(changed)
[10:20:15.130]                 args <- list()
[10:20:15.130]                 for (kk in seq_along(NAMES)) {
[10:20:15.130]                   name <- changed[[kk]]
[10:20:15.130]                   NAME <- NAMES[[kk]]
[10:20:15.130]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:15.130]                     next
[10:20:15.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:15.130]                 }
[10:20:15.130]                 NAMES <- toupper(added)
[10:20:15.130]                 for (kk in seq_along(NAMES)) {
[10:20:15.130]                   name <- added[[kk]]
[10:20:15.130]                   NAME <- NAMES[[kk]]
[10:20:15.130]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:15.130]                     next
[10:20:15.130]                   args[[name]] <- ""
[10:20:15.130]                 }
[10:20:15.130]                 NAMES <- toupper(removed)
[10:20:15.130]                 for (kk in seq_along(NAMES)) {
[10:20:15.130]                   name <- removed[[kk]]
[10:20:15.130]                   NAME <- NAMES[[kk]]
[10:20:15.130]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:15.130]                     next
[10:20:15.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:15.130]                 }
[10:20:15.130]                 if (length(args) > 0) 
[10:20:15.130]                   base::do.call(base::Sys.setenv, args = args)
[10:20:15.130]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:15.130]             }
[10:20:15.130]             else {
[10:20:15.130]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:15.130]             }
[10:20:15.130]             {
[10:20:15.130]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:15.130]                   0L) {
[10:20:15.130]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:15.130]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:15.130]                   base::options(opts)
[10:20:15.130]                 }
[10:20:15.130]                 {
[10:20:15.130]                   {
[10:20:15.130]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:15.130]                     NULL
[10:20:15.130]                   }
[10:20:15.130]                   options(future.plan = NULL)
[10:20:15.130]                   if (is.na(NA_character_)) 
[10:20:15.130]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:15.130]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:15.130]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:15.130]                     .init = FALSE)
[10:20:15.130]                 }
[10:20:15.130]             }
[10:20:15.130]         }
[10:20:15.130]     })
[10:20:15.130]     if (TRUE) {
[10:20:15.130]         base::sink(type = "output", split = FALSE)
[10:20:15.130]         if (TRUE) {
[10:20:15.130]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:15.130]         }
[10:20:15.130]         else {
[10:20:15.130]             ...future.result["stdout"] <- base::list(NULL)
[10:20:15.130]         }
[10:20:15.130]         base::close(...future.stdout)
[10:20:15.130]         ...future.stdout <- NULL
[10:20:15.130]     }
[10:20:15.130]     ...future.result$conditions <- ...future.conditions
[10:20:15.130]     ...future.result$finished <- base::Sys.time()
[10:20:15.130]     ...future.result
[10:20:15.130] }
[10:20:15.133] assign_globals() ...
[10:20:15.133] List of 5
[10:20:15.133]  $ ...future.FUN            :function (x)  
[10:20:15.133]  $ future.call.arguments    : list()
[10:20:15.133]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:15.133]  $ ...future.elements_ii    :List of 1
[10:20:15.133]   ..$ : int 0
[10:20:15.133]  $ ...future.seeds_ii       : NULL
[10:20:15.133]  $ ...future.globals.maxSize: NULL
[10:20:15.133]  - attr(*, "where")=List of 5
[10:20:15.133]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:15.133]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:20:15.133]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:15.133]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:15.133]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:15.133]  - attr(*, "resolved")= logi FALSE
[10:20:15.133]  - attr(*, "total_size")= num 5632
[10:20:15.133]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:15.133]  - attr(*, "already-done")= logi TRUE
[10:20:15.139] - reassign environment for ‘...future.FUN’
[10:20:15.139] - copied ‘...future.FUN’ to environment
[10:20:15.139] - copied ‘future.call.arguments’ to environment
[10:20:15.140] - copied ‘...future.elements_ii’ to environment
[10:20:15.140] - copied ‘...future.seeds_ii’ to environment
[10:20:15.140] - copied ‘...future.globals.maxSize’ to environment
[10:20:15.140] assign_globals() ... done
[10:20:15.140] requestCore(): workers = 2
[10:20:15.143] MulticoreFuture started
[10:20:15.143] - Launch lazy future ... done
[10:20:15.143] run() for ‘MulticoreFuture’ ... done
[10:20:15.144] Created future:
[10:20:15.144] plan(): Setting new future strategy stack:
[10:20:15.144] List of future strategies:
[10:20:15.144] 1. sequential:
[10:20:15.144]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:15.144]    - tweaked: FALSE
[10:20:15.144]    - call: NULL
[10:20:15.145] plan(): nbrOfWorkers() = 1
[10:20:15.147] plan(): Setting new future strategy stack:
[10:20:15.147] List of future strategies:
[10:20:15.147] 1. multicore:
[10:20:15.147]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:20:15.147]    - tweaked: FALSE
[10:20:15.147]    - call: plan(strategy)
[10:20:15.151] plan(): nbrOfWorkers() = 2
[10:20:15.144] MulticoreFuture:
[10:20:15.144] Label: ‘future_lapply-2’
[10:20:15.144] Expression:
[10:20:15.144] {
[10:20:15.144]     do.call(function(...) {
[10:20:15.144]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:15.144]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:15.144]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:15.144]             on.exit(options(oopts), add = TRUE)
[10:20:15.144]         }
[10:20:15.144]         {
[10:20:15.144]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:15.144]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:15.144]                 ...future.FUN(...future.X_jj, ...)
[10:20:15.144]             })
[10:20:15.144]         }
[10:20:15.144]     }, args = future.call.arguments)
[10:20:15.144] }
[10:20:15.144] Lazy evaluation: FALSE
[10:20:15.144] Asynchronous evaluation: TRUE
[10:20:15.144] Local evaluation: TRUE
[10:20:15.144] Environment: R_GlobalEnv
[10:20:15.144] Capture standard output: TRUE
[10:20:15.144] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:15.144] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:15.144] Packages: <none>
[10:20:15.144] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:15.144] Resolved: TRUE
[10:20:15.144] Value: <not collected>
[10:20:15.144] Conditions captured: <none>
[10:20:15.144] Early signaling: FALSE
[10:20:15.144] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:15.144] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:15.152] Chunk #2 of 2 ... DONE
[10:20:15.152] Launching 2 futures (chunks) ... DONE
[10:20:15.152] Resolving 2 futures (chunks) ...
[10:20:15.153] resolve() on list ...
[10:20:15.153]  recursive: 0
[10:20:15.153]  length: 2
[10:20:15.153] 
[10:20:15.164] Future #2
[10:20:15.164] result() for MulticoreFuture ...
[10:20:15.165] result() for MulticoreFuture ...
[10:20:15.166] result() for MulticoreFuture ... done
[10:20:15.166] result() for MulticoreFuture ... done
[10:20:15.166] result() for MulticoreFuture ...
[10:20:15.166] result() for MulticoreFuture ... done
[10:20:15.166] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:20:15.166] - nx: 2
[10:20:15.166] - relay: TRUE
[10:20:15.167] - stdout: TRUE
[10:20:15.167] - signal: TRUE
[10:20:15.167] - resignal: FALSE
[10:20:15.167] - force: TRUE
[10:20:15.167] - relayed: [n=2] FALSE, FALSE
[10:20:15.167] - queued futures: [n=2] FALSE, FALSE
[10:20:15.167]  - until=1
[10:20:15.168]  - relaying element #1
[10:20:15.168] - relayed: [n=2] FALSE, FALSE
[10:20:15.168] - queued futures: [n=2] FALSE, TRUE
[10:20:15.168] signalConditionsASAP(NULL, pos=2) ... done
[10:20:15.168]  length: 1 (resolved future 2)
[10:20:15.600] plan(): Setting new future strategy stack:
[10:20:15.604] List of future strategies:
[10:20:15.604] 1. multicore:
[10:20:15.604]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:20:15.604]    - tweaked: FALSE
[10:20:15.604]    - call: plan(strategy)
[10:20:15.607] plan(): nbrOfWorkers() = 2
[10:20:15.607] Future #1
[10:20:15.608] result() for MulticoreFuture ...
[10:20:15.608] result() for MulticoreFuture ...
[10:20:15.609] result() for MulticoreFuture ... done
[10:20:15.609] result() for MulticoreFuture ... done
[10:20:15.609] result() for MulticoreFuture ...
[10:20:15.609] result() for MulticoreFuture ... done
[10:20:15.609] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:20:15.609] - nx: 2
[10:20:15.609] - relay: TRUE
[10:20:15.610] - stdout: TRUE
[10:20:15.610] - signal: TRUE
[10:20:15.610] - resignal: FALSE
[10:20:15.610] - force: TRUE
[10:20:15.610] - relayed: [n=2] FALSE, FALSE
[10:20:15.610] - queued futures: [n=2] FALSE, TRUE
[10:20:15.610]  - until=1
[10:20:15.613]  - relaying element #1
[10:20:15.613] result() for MulticoreFuture ...
[10:20:15.613] result() for MulticoreFuture ... done
[10:20:15.613] result() for MulticoreFuture ...
[10:20:15.613] result() for MulticoreFuture ... done
[10:20:15.614] result() for MulticoreFuture ...
[10:20:15.614] result() for MulticoreFuture ... done
[10:20:15.614] result() for MulticoreFuture ...
[10:20:15.614] result() for MulticoreFuture ... done
[10:20:15.614] - relayed: [n=2] TRUE, FALSE
[10:20:15.615] - queued futures: [n=2] TRUE, TRUE
[10:20:15.615] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:20:15.615]  length: 0 (resolved future 1)
[10:20:15.615] Relaying remaining futures
[10:20:15.615] signalConditionsASAP(NULL, pos=0) ...
[10:20:15.615] - nx: 2
[10:20:15.615] - relay: TRUE
[10:20:15.616] - stdout: TRUE
[10:20:15.616] - signal: TRUE
[10:20:15.616] - resignal: FALSE
[10:20:15.616] - force: TRUE
[10:20:15.616] - relayed: [n=2] TRUE, FALSE
[10:20:15.616] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:20:15.616]  - relaying element #2
[10:20:15.617] result() for MulticoreFuture ...
[10:20:15.617] result() for MulticoreFuture ... done
[10:20:15.617] result() for MulticoreFuture ...
[10:20:15.617] result() for MulticoreFuture ... done
[10:20:15.617] result() for MulticoreFuture ...
[10:20:15.617] result() for MulticoreFuture ... done
[10:20:15.617] result() for MulticoreFuture ...
[10:20:15.617] result() for MulticoreFuture ... done
[10:20:15.618] - relayed: [n=2] TRUE, TRUE
[10:20:15.618] - queued futures: [n=2] TRUE, TRUE
[10:20:15.618] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[10:20:15.618] resolve() on list ... DONE
[10:20:15.618] result() for MulticoreFuture ...
[10:20:15.618] result() for MulticoreFuture ... done
[10:20:15.618] result() for MulticoreFuture ...
[10:20:15.618] result() for MulticoreFuture ... done
[10:20:15.618] result() for MulticoreFuture ...
[10:20:15.619] result() for MulticoreFuture ... done
[10:20:15.619] result() for MulticoreFuture ...
[10:20:15.619] result() for MulticoreFuture ... done
[10:20:15.619]  - Number of value chunks collected: 2
[10:20:15.619] Resolving 2 futures (chunks) ... DONE
[10:20:15.619] Reducing values from 2 chunks ...
[10:20:15.619]  - Number of values collected after concatenation: 2
[10:20:15.619]  - Number of values expected: 2
[10:20:15.619] Reducing values from 2 chunks ... DONE
[10:20:15.620] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[10:20:15.620] future_lapply() ...
[10:20:15.623] Number of chunks: 2
[10:20:15.623] getGlobalsAndPackagesXApply() ...
[10:20:15.623]  - future.globals: TRUE
[10:20:15.623] getGlobalsAndPackages() ...
[10:20:15.623] Searching for globals...
[10:20:15.625] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:20:15.625] Searching for globals ... DONE
[10:20:15.625] Resolving globals: FALSE
[10:20:15.626] The total size of the 1 globals is 841 bytes (841 bytes)
[10:20:15.626] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[10:20:15.626] - globals: [1] ‘FUN’
[10:20:15.626] 
[10:20:15.626] getGlobalsAndPackages() ... DONE
[10:20:15.627]  - globals found/used: [n=1] ‘FUN’
[10:20:15.627]  - needed namespaces: [n=0] 
[10:20:15.627] Finding globals ... DONE
[10:20:15.627]  - use_args: TRUE
[10:20:15.627]  - Getting '...' globals ...
[10:20:15.627] resolve() on list ...
[10:20:15.627]  recursive: 0
[10:20:15.628]  length: 1
[10:20:15.628]  elements: ‘...’
[10:20:15.628]  length: 0 (resolved future 1)
[10:20:15.628] resolve() on list ... DONE
[10:20:15.628]    - '...' content: [n=0] 
[10:20:15.628] List of 1
[10:20:15.628]  $ ...: list()
[10:20:15.628]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:15.628]  - attr(*, "where")=List of 1
[10:20:15.628]   ..$ ...:<environment: 0x557fc0435570> 
[10:20:15.628]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:15.628]  - attr(*, "resolved")= logi TRUE
[10:20:15.628]  - attr(*, "total_size")= num NA
[10:20:15.631]  - Getting '...' globals ... DONE
[10:20:15.631] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:20:15.631] List of 2
[10:20:15.631]  $ ...future.FUN:function (x)  
[10:20:15.631]  $ ...          : list()
[10:20:15.631]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:15.631]  - attr(*, "where")=List of 2
[10:20:15.631]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:15.631]   ..$ ...          :<environment: 0x557fc0435570> 
[10:20:15.631]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:15.631]  - attr(*, "resolved")= logi FALSE
[10:20:15.631]  - attr(*, "total_size")= num 5632
[10:20:15.634] Packages to be attached in all futures: [n=0] 
[10:20:15.634] getGlobalsAndPackagesXApply() ... DONE
[10:20:15.634] Number of futures (= number of chunks): 2
[10:20:15.634] Launching 2 futures (chunks) ...
[10:20:15.634] Chunk #1 of 2 ...
[10:20:15.635]  - Finding globals in 'X' for chunk #1 ...
[10:20:15.635] getGlobalsAndPackages() ...
[10:20:15.635] Searching for globals...
[10:20:15.635] 
[10:20:15.635] Searching for globals ... DONE
[10:20:15.635] - globals: [0] <none>
[10:20:15.635] getGlobalsAndPackages() ... DONE
[10:20:15.635]    + additional globals found: [n=0] 
[10:20:15.635]    + additional namespaces needed: [n=0] 
[10:20:15.636]  - Finding globals in 'X' for chunk #1 ... DONE
[10:20:15.636]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:15.636]  - seeds: <none>
[10:20:15.636]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:15.636] getGlobalsAndPackages() ...
[10:20:15.636] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:15.636] Resolving globals: FALSE
[10:20:15.636] Tweak future expression to call with '...' arguments ...
[10:20:15.636] {
[10:20:15.636]     do.call(function(...) {
[10:20:15.636]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:15.636]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:15.636]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:15.636]             on.exit(options(oopts), add = TRUE)
[10:20:15.636]         }
[10:20:15.636]         {
[10:20:15.636]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:15.636]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:15.636]                 ...future.FUN(...future.X_jj, ...)
[10:20:15.636]             })
[10:20:15.636]         }
[10:20:15.636]     }, args = future.call.arguments)
[10:20:15.636] }
[10:20:15.637] Tweak future expression to call with '...' arguments ... DONE
[10:20:15.637] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:15.637] 
[10:20:15.637] getGlobalsAndPackages() ... DONE
[10:20:15.637] run() for ‘Future’ ...
[10:20:15.638] - state: ‘created’
[10:20:15.638] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:20:15.641] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:15.641] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:20:15.641]   - Field: ‘label’
[10:20:15.641]   - Field: ‘local’
[10:20:15.641]   - Field: ‘owner’
[10:20:15.642]   - Field: ‘envir’
[10:20:15.642]   - Field: ‘workers’
[10:20:15.642]   - Field: ‘packages’
[10:20:15.642]   - Field: ‘gc’
[10:20:15.642]   - Field: ‘job’
[10:20:15.642]   - Field: ‘conditions’
[10:20:15.642]   - Field: ‘expr’
[10:20:15.642]   - Field: ‘uuid’
[10:20:15.642]   - Field: ‘seed’
[10:20:15.642]   - Field: ‘version’
[10:20:15.643]   - Field: ‘result’
[10:20:15.643]   - Field: ‘asynchronous’
[10:20:15.643]   - Field: ‘calls’
[10:20:15.643]   - Field: ‘globals’
[10:20:15.643]   - Field: ‘stdout’
[10:20:15.643]   - Field: ‘earlySignal’
[10:20:15.643]   - Field: ‘lazy’
[10:20:15.643]   - Field: ‘state’
[10:20:15.643] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:20:15.643] - Launch lazy future ...
[10:20:15.644] Packages needed by the future expression (n = 0): <none>
[10:20:15.644] Packages needed by future strategies (n = 0): <none>
[10:20:15.644] {
[10:20:15.644]     {
[10:20:15.644]         {
[10:20:15.644]             ...future.startTime <- base::Sys.time()
[10:20:15.644]             {
[10:20:15.644]                 {
[10:20:15.644]                   {
[10:20:15.644]                     {
[10:20:15.644]                       base::local({
[10:20:15.644]                         has_future <- base::requireNamespace("future", 
[10:20:15.644]                           quietly = TRUE)
[10:20:15.644]                         if (has_future) {
[10:20:15.644]                           ns <- base::getNamespace("future")
[10:20:15.644]                           version <- ns[[".package"]][["version"]]
[10:20:15.644]                           if (is.null(version)) 
[10:20:15.644]                             version <- utils::packageVersion("future")
[10:20:15.644]                         }
[10:20:15.644]                         else {
[10:20:15.644]                           version <- NULL
[10:20:15.644]                         }
[10:20:15.644]                         if (!has_future || version < "1.8.0") {
[10:20:15.644]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:15.644]                             "", base::R.version$version.string), 
[10:20:15.644]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:15.644]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:15.644]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:15.644]                               "release", "version")], collapse = " "), 
[10:20:15.644]                             hostname = base::Sys.info()[["nodename"]])
[10:20:15.644]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:15.644]                             info)
[10:20:15.644]                           info <- base::paste(info, collapse = "; ")
[10:20:15.644]                           if (!has_future) {
[10:20:15.644]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:15.644]                               info)
[10:20:15.644]                           }
[10:20:15.644]                           else {
[10:20:15.644]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:15.644]                               info, version)
[10:20:15.644]                           }
[10:20:15.644]                           base::stop(msg)
[10:20:15.644]                         }
[10:20:15.644]                       })
[10:20:15.644]                     }
[10:20:15.644]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:15.644]                     base::options(mc.cores = 1L)
[10:20:15.644]                   }
[10:20:15.644]                   ...future.strategy.old <- future::plan("list")
[10:20:15.644]                   options(future.plan = NULL)
[10:20:15.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:15.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:15.644]                 }
[10:20:15.644]                 ...future.workdir <- getwd()
[10:20:15.644]             }
[10:20:15.644]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:15.644]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:15.644]         }
[10:20:15.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:15.644]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:15.644]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:15.644]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:15.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:15.644]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:15.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:15.644]             base::names(...future.oldOptions))
[10:20:15.644]     }
[10:20:15.644]     if (TRUE) {
[10:20:15.644]     }
[10:20:15.644]     else {
[10:20:15.644]         if (NA) {
[10:20:15.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:15.644]                 open = "w")
[10:20:15.644]         }
[10:20:15.644]         else {
[10:20:15.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:15.644]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:15.644]         }
[10:20:15.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:15.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:15.644]             base::sink(type = "output", split = FALSE)
[10:20:15.644]             base::close(...future.stdout)
[10:20:15.644]         }, add = TRUE)
[10:20:15.644]     }
[10:20:15.644]     ...future.frame <- base::sys.nframe()
[10:20:15.644]     ...future.conditions <- base::list()
[10:20:15.644]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:15.644]     if (FALSE) {
[10:20:15.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:15.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:15.644]     }
[10:20:15.644]     ...future.result <- base::tryCatch({
[10:20:15.644]         base::withCallingHandlers({
[10:20:15.644]             ...future.value <- base::withVisible(base::local({
[10:20:15.644]                 withCallingHandlers({
[10:20:15.644]                   {
[10:20:15.644]                     do.call(function(...) {
[10:20:15.644]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:15.644]                       if (!identical(...future.globals.maxSize.org, 
[10:20:15.644]                         ...future.globals.maxSize)) {
[10:20:15.644]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:15.644]                         on.exit(options(oopts), add = TRUE)
[10:20:15.644]                       }
[10:20:15.644]                       {
[10:20:15.644]                         lapply(seq_along(...future.elements_ii), 
[10:20:15.644]                           FUN = function(jj) {
[10:20:15.644]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:15.644]                             ...future.FUN(...future.X_jj, ...)
[10:20:15.644]                           })
[10:20:15.644]                       }
[10:20:15.644]                     }, args = future.call.arguments)
[10:20:15.644]                   }
[10:20:15.644]                 }, immediateCondition = function(cond) {
[10:20:15.644]                   save_rds <- function (object, pathname, ...) 
[10:20:15.644]                   {
[10:20:15.644]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:20:15.644]                     if (file_test("-f", pathname_tmp)) {
[10:20:15.644]                       fi_tmp <- file.info(pathname_tmp)
[10:20:15.644]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:20:15.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:15.644]                         fi_tmp[["mtime"]])
[10:20:15.644]                     }
[10:20:15.644]                     tryCatch({
[10:20:15.644]                       saveRDS(object, file = pathname_tmp, ...)
[10:20:15.644]                     }, error = function(ex) {
[10:20:15.644]                       msg <- conditionMessage(ex)
[10:20:15.644]                       fi_tmp <- file.info(pathname_tmp)
[10:20:15.644]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:20:15.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:15.644]                         fi_tmp[["mtime"]], msg)
[10:20:15.644]                       ex$message <- msg
[10:20:15.644]                       stop(ex)
[10:20:15.644]                     })
[10:20:15.644]                     stopifnot(file_test("-f", pathname_tmp))
[10:20:15.644]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:20:15.644]                     if (!res || file_test("-f", pathname_tmp)) {
[10:20:15.644]                       fi_tmp <- file.info(pathname_tmp)
[10:20:15.644]                       fi <- file.info(pathname)
[10:20:15.644]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:20:15.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:15.644]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:20:15.644]                         fi[["size"]], fi[["mtime"]])
[10:20:15.644]                       stop(msg)
[10:20:15.644]                     }
[10:20:15.644]                     invisible(pathname)
[10:20:15.644]                   }
[10:20:15.644]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:20:15.644]                     rootPath = tempdir()) 
[10:20:15.644]                   {
[10:20:15.644]                     obj <- list(time = Sys.time(), condition = cond)
[10:20:15.644]                     file <- tempfile(pattern = class(cond)[1], 
[10:20:15.644]                       tmpdir = path, fileext = ".rds")
[10:20:15.644]                     save_rds(obj, file)
[10:20:15.644]                   }
[10:20:15.644]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8Z8Jdg/.future/immediateConditions")
[10:20:15.644]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:15.644]                   {
[10:20:15.644]                     inherits <- base::inherits
[10:20:15.644]                     invokeRestart <- base::invokeRestart
[10:20:15.644]                     is.null <- base::is.null
[10:20:15.644]                     muffled <- FALSE
[10:20:15.644]                     if (inherits(cond, "message")) {
[10:20:15.644]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:15.644]                       if (muffled) 
[10:20:15.644]                         invokeRestart("muffleMessage")
[10:20:15.644]                     }
[10:20:15.644]                     else if (inherits(cond, "warning")) {
[10:20:15.644]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:15.644]                       if (muffled) 
[10:20:15.644]                         invokeRestart("muffleWarning")
[10:20:15.644]                     }
[10:20:15.644]                     else if (inherits(cond, "condition")) {
[10:20:15.644]                       if (!is.null(pattern)) {
[10:20:15.644]                         computeRestarts <- base::computeRestarts
[10:20:15.644]                         grepl <- base::grepl
[10:20:15.644]                         restarts <- computeRestarts(cond)
[10:20:15.644]                         for (restart in restarts) {
[10:20:15.644]                           name <- restart$name
[10:20:15.644]                           if (is.null(name)) 
[10:20:15.644]                             next
[10:20:15.644]                           if (!grepl(pattern, name)) 
[10:20:15.644]                             next
[10:20:15.644]                           invokeRestart(restart)
[10:20:15.644]                           muffled <- TRUE
[10:20:15.644]                           break
[10:20:15.644]                         }
[10:20:15.644]                       }
[10:20:15.644]                     }
[10:20:15.644]                     invisible(muffled)
[10:20:15.644]                   }
[10:20:15.644]                   muffleCondition(cond)
[10:20:15.644]                 })
[10:20:15.644]             }))
[10:20:15.644]             future::FutureResult(value = ...future.value$value, 
[10:20:15.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:15.644]                   ...future.rng), globalenv = if (FALSE) 
[10:20:15.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:15.644]                     ...future.globalenv.names))
[10:20:15.644]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:15.644]         }, condition = base::local({
[10:20:15.644]             c <- base::c
[10:20:15.644]             inherits <- base::inherits
[10:20:15.644]             invokeRestart <- base::invokeRestart
[10:20:15.644]             length <- base::length
[10:20:15.644]             list <- base::list
[10:20:15.644]             seq.int <- base::seq.int
[10:20:15.644]             signalCondition <- base::signalCondition
[10:20:15.644]             sys.calls <- base::sys.calls
[10:20:15.644]             `[[` <- base::`[[`
[10:20:15.644]             `+` <- base::`+`
[10:20:15.644]             `<<-` <- base::`<<-`
[10:20:15.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:15.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:15.644]                   3L)]
[10:20:15.644]             }
[10:20:15.644]             function(cond) {
[10:20:15.644]                 is_error <- inherits(cond, "error")
[10:20:15.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:15.644]                   NULL)
[10:20:15.644]                 if (is_error) {
[10:20:15.644]                   sessionInformation <- function() {
[10:20:15.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:15.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:15.644]                       search = base::search(), system = base::Sys.info())
[10:20:15.644]                   }
[10:20:15.644]                   ...future.conditions[[length(...future.conditions) + 
[10:20:15.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:15.644]                     cond$call), session = sessionInformation(), 
[10:20:15.644]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:15.644]                   signalCondition(cond)
[10:20:15.644]                 }
[10:20:15.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:15.644]                 "immediateCondition"))) {
[10:20:15.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:15.644]                   ...future.conditions[[length(...future.conditions) + 
[10:20:15.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:15.644]                   if (TRUE && !signal) {
[10:20:15.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:15.644]                     {
[10:20:15.644]                       inherits <- base::inherits
[10:20:15.644]                       invokeRestart <- base::invokeRestart
[10:20:15.644]                       is.null <- base::is.null
[10:20:15.644]                       muffled <- FALSE
[10:20:15.644]                       if (inherits(cond, "message")) {
[10:20:15.644]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:15.644]                         if (muffled) 
[10:20:15.644]                           invokeRestart("muffleMessage")
[10:20:15.644]                       }
[10:20:15.644]                       else if (inherits(cond, "warning")) {
[10:20:15.644]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:15.644]                         if (muffled) 
[10:20:15.644]                           invokeRestart("muffleWarning")
[10:20:15.644]                       }
[10:20:15.644]                       else if (inherits(cond, "condition")) {
[10:20:15.644]                         if (!is.null(pattern)) {
[10:20:15.644]                           computeRestarts <- base::computeRestarts
[10:20:15.644]                           grepl <- base::grepl
[10:20:15.644]                           restarts <- computeRestarts(cond)
[10:20:15.644]                           for (restart in restarts) {
[10:20:15.644]                             name <- restart$name
[10:20:15.644]                             if (is.null(name)) 
[10:20:15.644]                               next
[10:20:15.644]                             if (!grepl(pattern, name)) 
[10:20:15.644]                               next
[10:20:15.644]                             invokeRestart(restart)
[10:20:15.644]                             muffled <- TRUE
[10:20:15.644]                             break
[10:20:15.644]                           }
[10:20:15.644]                         }
[10:20:15.644]                       }
[10:20:15.644]                       invisible(muffled)
[10:20:15.644]                     }
[10:20:15.644]                     muffleCondition(cond, pattern = "^muffle")
[10:20:15.644]                   }
[10:20:15.644]                 }
[10:20:15.644]                 else {
[10:20:15.644]                   if (TRUE) {
[10:20:15.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:15.644]                     {
[10:20:15.644]                       inherits <- base::inherits
[10:20:15.644]                       invokeRestart <- base::invokeRestart
[10:20:15.644]                       is.null <- base::is.null
[10:20:15.644]                       muffled <- FALSE
[10:20:15.644]                       if (inherits(cond, "message")) {
[10:20:15.644]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:15.644]                         if (muffled) 
[10:20:15.644]                           invokeRestart("muffleMessage")
[10:20:15.644]                       }
[10:20:15.644]                       else if (inherits(cond, "warning")) {
[10:20:15.644]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:15.644]                         if (muffled) 
[10:20:15.644]                           invokeRestart("muffleWarning")
[10:20:15.644]                       }
[10:20:15.644]                       else if (inherits(cond, "condition")) {
[10:20:15.644]                         if (!is.null(pattern)) {
[10:20:15.644]                           computeRestarts <- base::computeRestarts
[10:20:15.644]                           grepl <- base::grepl
[10:20:15.644]                           restarts <- computeRestarts(cond)
[10:20:15.644]                           for (restart in restarts) {
[10:20:15.644]                             name <- restart$name
[10:20:15.644]                             if (is.null(name)) 
[10:20:15.644]                               next
[10:20:15.644]                             if (!grepl(pattern, name)) 
[10:20:15.644]                               next
[10:20:15.644]                             invokeRestart(restart)
[10:20:15.644]                             muffled <- TRUE
[10:20:15.644]                             break
[10:20:15.644]                           }
[10:20:15.644]                         }
[10:20:15.644]                       }
[10:20:15.644]                       invisible(muffled)
[10:20:15.644]                     }
[10:20:15.644]                     muffleCondition(cond, pattern = "^muffle")
[10:20:15.644]                   }
[10:20:15.644]                 }
[10:20:15.644]             }
[10:20:15.644]         }))
[10:20:15.644]     }, error = function(ex) {
[10:20:15.644]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:15.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:15.644]                 ...future.rng), started = ...future.startTime, 
[10:20:15.644]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:15.644]             version = "1.8"), class = "FutureResult")
[10:20:15.644]     }, finally = {
[10:20:15.644]         if (!identical(...future.workdir, getwd())) 
[10:20:15.644]             setwd(...future.workdir)
[10:20:15.644]         {
[10:20:15.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:15.644]                 ...future.oldOptions$nwarnings <- NULL
[10:20:15.644]             }
[10:20:15.644]             base::options(...future.oldOptions)
[10:20:15.644]             if (.Platform$OS.type == "windows") {
[10:20:15.644]                 old_names <- names(...future.oldEnvVars)
[10:20:15.644]                 envs <- base::Sys.getenv()
[10:20:15.644]                 names <- names(envs)
[10:20:15.644]                 common <- intersect(names, old_names)
[10:20:15.644]                 added <- setdiff(names, old_names)
[10:20:15.644]                 removed <- setdiff(old_names, names)
[10:20:15.644]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:15.644]                   envs[common]]
[10:20:15.644]                 NAMES <- toupper(changed)
[10:20:15.644]                 args <- list()
[10:20:15.644]                 for (kk in seq_along(NAMES)) {
[10:20:15.644]                   name <- changed[[kk]]
[10:20:15.644]                   NAME <- NAMES[[kk]]
[10:20:15.644]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:15.644]                     next
[10:20:15.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:15.644]                 }
[10:20:15.644]                 NAMES <- toupper(added)
[10:20:15.644]                 for (kk in seq_along(NAMES)) {
[10:20:15.644]                   name <- added[[kk]]
[10:20:15.644]                   NAME <- NAMES[[kk]]
[10:20:15.644]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:15.644]                     next
[10:20:15.644]                   args[[name]] <- ""
[10:20:15.644]                 }
[10:20:15.644]                 NAMES <- toupper(removed)
[10:20:15.644]                 for (kk in seq_along(NAMES)) {
[10:20:15.644]                   name <- removed[[kk]]
[10:20:15.644]                   NAME <- NAMES[[kk]]
[10:20:15.644]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:15.644]                     next
[10:20:15.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:15.644]                 }
[10:20:15.644]                 if (length(args) > 0) 
[10:20:15.644]                   base::do.call(base::Sys.setenv, args = args)
[10:20:15.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:15.644]             }
[10:20:15.644]             else {
[10:20:15.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:15.644]             }
[10:20:15.644]             {
[10:20:15.644]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:15.644]                   0L) {
[10:20:15.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:15.644]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:15.644]                   base::options(opts)
[10:20:15.644]                 }
[10:20:15.644]                 {
[10:20:15.644]                   {
[10:20:15.644]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:15.644]                     NULL
[10:20:15.644]                   }
[10:20:15.644]                   options(future.plan = NULL)
[10:20:15.644]                   if (is.na(NA_character_)) 
[10:20:15.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:15.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:15.644]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:15.644]                     .init = FALSE)
[10:20:15.644]                 }
[10:20:15.644]             }
[10:20:15.644]         }
[10:20:15.644]     })
[10:20:15.644]     if (FALSE) {
[10:20:15.644]         base::sink(type = "output", split = FALSE)
[10:20:15.644]         if (NA) {
[10:20:15.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:15.644]         }
[10:20:15.644]         else {
[10:20:15.644]             ...future.result["stdout"] <- base::list(NULL)
[10:20:15.644]         }
[10:20:15.644]         base::close(...future.stdout)
[10:20:15.644]         ...future.stdout <- NULL
[10:20:15.644]     }
[10:20:15.644]     ...future.result$conditions <- ...future.conditions
[10:20:15.644]     ...future.result$finished <- base::Sys.time()
[10:20:15.644]     ...future.result
[10:20:15.644] }
[10:20:15.646] assign_globals() ...
[10:20:15.647] List of 5
[10:20:15.647]  $ ...future.FUN            :function (x)  
[10:20:15.647]  $ future.call.arguments    : list()
[10:20:15.647]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:15.647]  $ ...future.elements_ii    :List of 1
[10:20:15.647]   ..$ : int 1
[10:20:15.647]  $ ...future.seeds_ii       : NULL
[10:20:15.647]  $ ...future.globals.maxSize: NULL
[10:20:15.647]  - attr(*, "where")=List of 5
[10:20:15.647]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:15.647]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:20:15.647]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:15.647]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:15.647]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:15.647]  - attr(*, "resolved")= logi FALSE
[10:20:15.647]  - attr(*, "total_size")= num 5632
[10:20:15.647]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:15.647]  - attr(*, "already-done")= logi TRUE
[10:20:15.651] - reassign environment for ‘...future.FUN’
[10:20:15.651] - copied ‘...future.FUN’ to environment
[10:20:15.651] - copied ‘future.call.arguments’ to environment
[10:20:15.651] - copied ‘...future.elements_ii’ to environment
[10:20:15.651] - copied ‘...future.seeds_ii’ to environment
[10:20:15.651] - copied ‘...future.globals.maxSize’ to environment
[10:20:15.652] assign_globals() ... done
[10:20:15.652] requestCore(): workers = 2
[10:20:15.654] MulticoreFuture started
[10:20:15.654] - Launch lazy future ... done
[10:20:15.654] run() for ‘MulticoreFuture’ ... done
[10:20:15.655] Created future:
[10:20:15.655] plan(): Setting new future strategy stack:
[10:20:15.655] List of future strategies:
[10:20:15.655] 1. sequential:
[10:20:15.655]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:15.655]    - tweaked: FALSE
[10:20:15.655]    - call: NULL
[10:20:15.656] plan(): nbrOfWorkers() = 1
[10:20:15.655] MulticoreFuture:
[10:20:15.655] Label: ‘future_lapply-1’
[10:20:15.655] Expression:
[10:20:15.655] {
[10:20:15.655]     do.call(function(...) {
[10:20:15.655]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:15.655]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:15.655]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:15.655]             on.exit(options(oopts), add = TRUE)
[10:20:15.655]         }
[10:20:15.655]         {
[10:20:15.655]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:15.655]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:15.655]                 ...future.FUN(...future.X_jj, ...)
[10:20:15.655]             })
[10:20:15.655]         }
[10:20:15.655]     }, args = future.call.arguments)
[10:20:15.655] }
[10:20:15.655] Lazy evaluation: FALSE
[10:20:15.655] Asynchronous evaluation: TRUE
[10:20:15.655] Local evaluation: TRUE
[10:20:15.655] Environment: R_GlobalEnv
[10:20:15.655] Capture standard output: NA
[10:20:15.655] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:15.655] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:15.655] Packages: <none>
[10:20:15.655] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:15.655] Resolved: FALSE
[10:20:15.655] Value: <not collected>
[10:20:15.655] Conditions captured: <none>
[10:20:15.655] Early signaling: FALSE
[10:20:15.655] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:15.655] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:15.667] Chunk #1 of 2 ... DONE
[10:20:15.668] Chunk #2 of 2 ...
[10:20:15.668]  - Finding globals in 'X' for chunk #2 ...
[10:20:15.668] getGlobalsAndPackages() ...
[10:20:15.668] Searching for globals...
[10:20:15.669] 
[10:20:15.669] Searching for globals ... DONE
[10:20:15.669] - globals: [0] <none>
[10:20:15.669] getGlobalsAndPackages() ... DONE
[10:20:15.669]    + additional globals found: [n=0] 
[10:20:15.670]    + additional namespaces needed: [n=0] 
[10:20:15.670]  - Finding globals in 'X' for chunk #2 ... DONE
[10:20:15.670]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:15.670]  - seeds: <none>
[10:20:15.670]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:15.670] getGlobalsAndPackages() ...
[10:20:15.671] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:15.671] Resolving globals: FALSE
[10:20:15.671] Tweak future expression to call with '...' arguments ...
[10:20:15.671] {
[10:20:15.671]     do.call(function(...) {
[10:20:15.671]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:15.671]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:15.671]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:15.671]             on.exit(options(oopts), add = TRUE)
[10:20:15.671]         }
[10:20:15.671]         {
[10:20:15.671]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:15.671]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:15.671]                 ...future.FUN(...future.X_jj, ...)
[10:20:15.671]             })
[10:20:15.671]         }
[10:20:15.671]     }, args = future.call.arguments)
[10:20:15.671] }
[10:20:15.671] Tweak future expression to call with '...' arguments ... DONE
[10:20:15.672] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:15.672] 
[10:20:15.672] getGlobalsAndPackages() ... DONE
[10:20:15.673] run() for ‘Future’ ...
[10:20:15.673] - state: ‘created’
[10:20:15.673] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:20:15.677] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:15.677] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:20:15.677]   - Field: ‘label’
[10:20:15.677]   - Field: ‘local’
[10:20:15.677]   - Field: ‘owner’
[10:20:15.677]   - Field: ‘envir’
[10:20:15.678]   - Field: ‘workers’
[10:20:15.678]   - Field: ‘packages’
[10:20:15.678]   - Field: ‘gc’
[10:20:15.678]   - Field: ‘job’
[10:20:15.678]   - Field: ‘conditions’
[10:20:15.678]   - Field: ‘expr’
[10:20:15.678]   - Field: ‘uuid’
[10:20:15.679]   - Field: ‘seed’
[10:20:15.679]   - Field: ‘version’
[10:20:15.679]   - Field: ‘result’
[10:20:15.679]   - Field: ‘asynchronous’
[10:20:15.679]   - Field: ‘calls’
[10:20:15.679]   - Field: ‘globals’
[10:20:15.680]   - Field: ‘stdout’
[10:20:15.680]   - Field: ‘earlySignal’
[10:20:15.680]   - Field: ‘lazy’
[10:20:15.680]   - Field: ‘state’
[10:20:15.680] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:20:15.680] - Launch lazy future ...
[10:20:15.681] Packages needed by the future expression (n = 0): <none>
[10:20:15.681] Packages needed by future strategies (n = 0): <none>
[10:20:15.682] {
[10:20:15.682]     {
[10:20:15.682]         {
[10:20:15.682]             ...future.startTime <- base::Sys.time()
[10:20:15.682]             {
[10:20:15.682]                 {
[10:20:15.682]                   {
[10:20:15.682]                     {
[10:20:15.682]                       base::local({
[10:20:15.682]                         has_future <- base::requireNamespace("future", 
[10:20:15.682]                           quietly = TRUE)
[10:20:15.682]                         if (has_future) {
[10:20:15.682]                           ns <- base::getNamespace("future")
[10:20:15.682]                           version <- ns[[".package"]][["version"]]
[10:20:15.682]                           if (is.null(version)) 
[10:20:15.682]                             version <- utils::packageVersion("future")
[10:20:15.682]                         }
[10:20:15.682]                         else {
[10:20:15.682]                           version <- NULL
[10:20:15.682]                         }
[10:20:15.682]                         if (!has_future || version < "1.8.0") {
[10:20:15.682]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:15.682]                             "", base::R.version$version.string), 
[10:20:15.682]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:15.682]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:15.682]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:15.682]                               "release", "version")], collapse = " "), 
[10:20:15.682]                             hostname = base::Sys.info()[["nodename"]])
[10:20:15.682]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:15.682]                             info)
[10:20:15.682]                           info <- base::paste(info, collapse = "; ")
[10:20:15.682]                           if (!has_future) {
[10:20:15.682]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:15.682]                               info)
[10:20:15.682]                           }
[10:20:15.682]                           else {
[10:20:15.682]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:15.682]                               info, version)
[10:20:15.682]                           }
[10:20:15.682]                           base::stop(msg)
[10:20:15.682]                         }
[10:20:15.682]                       })
[10:20:15.682]                     }
[10:20:15.682]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:15.682]                     base::options(mc.cores = 1L)
[10:20:15.682]                   }
[10:20:15.682]                   ...future.strategy.old <- future::plan("list")
[10:20:15.682]                   options(future.plan = NULL)
[10:20:15.682]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:15.682]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:15.682]                 }
[10:20:15.682]                 ...future.workdir <- getwd()
[10:20:15.682]             }
[10:20:15.682]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:15.682]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:15.682]         }
[10:20:15.682]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:15.682]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:15.682]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:15.682]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:15.682]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:15.682]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:15.682]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:15.682]             base::names(...future.oldOptions))
[10:20:15.682]     }
[10:20:15.682]     if (TRUE) {
[10:20:15.682]     }
[10:20:15.682]     else {
[10:20:15.682]         if (NA) {
[10:20:15.682]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:15.682]                 open = "w")
[10:20:15.682]         }
[10:20:15.682]         else {
[10:20:15.682]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:15.682]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:15.682]         }
[10:20:15.682]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:15.682]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:15.682]             base::sink(type = "output", split = FALSE)
[10:20:15.682]             base::close(...future.stdout)
[10:20:15.682]         }, add = TRUE)
[10:20:15.682]     }
[10:20:15.682]     ...future.frame <- base::sys.nframe()
[10:20:15.682]     ...future.conditions <- base::list()
[10:20:15.682]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:15.682]     if (FALSE) {
[10:20:15.682]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:15.682]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:15.682]     }
[10:20:15.682]     ...future.result <- base::tryCatch({
[10:20:15.682]         base::withCallingHandlers({
[10:20:15.682]             ...future.value <- base::withVisible(base::local({
[10:20:15.682]                 withCallingHandlers({
[10:20:15.682]                   {
[10:20:15.682]                     do.call(function(...) {
[10:20:15.682]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:15.682]                       if (!identical(...future.globals.maxSize.org, 
[10:20:15.682]                         ...future.globals.maxSize)) {
[10:20:15.682]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:15.682]                         on.exit(options(oopts), add = TRUE)
[10:20:15.682]                       }
[10:20:15.682]                       {
[10:20:15.682]                         lapply(seq_along(...future.elements_ii), 
[10:20:15.682]                           FUN = function(jj) {
[10:20:15.682]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:15.682]                             ...future.FUN(...future.X_jj, ...)
[10:20:15.682]                           })
[10:20:15.682]                       }
[10:20:15.682]                     }, args = future.call.arguments)
[10:20:15.682]                   }
[10:20:15.682]                 }, immediateCondition = function(cond) {
[10:20:15.682]                   save_rds <- function (object, pathname, ...) 
[10:20:15.682]                   {
[10:20:15.682]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:20:15.682]                     if (file_test("-f", pathname_tmp)) {
[10:20:15.682]                       fi_tmp <- file.info(pathname_tmp)
[10:20:15.682]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:20:15.682]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:15.682]                         fi_tmp[["mtime"]])
[10:20:15.682]                     }
[10:20:15.682]                     tryCatch({
[10:20:15.682]                       saveRDS(object, file = pathname_tmp, ...)
[10:20:15.682]                     }, error = function(ex) {
[10:20:15.682]                       msg <- conditionMessage(ex)
[10:20:15.682]                       fi_tmp <- file.info(pathname_tmp)
[10:20:15.682]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:20:15.682]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:15.682]                         fi_tmp[["mtime"]], msg)
[10:20:15.682]                       ex$message <- msg
[10:20:15.682]                       stop(ex)
[10:20:15.682]                     })
[10:20:15.682]                     stopifnot(file_test("-f", pathname_tmp))
[10:20:15.682]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:20:15.682]                     if (!res || file_test("-f", pathname_tmp)) {
[10:20:15.682]                       fi_tmp <- file.info(pathname_tmp)
[10:20:15.682]                       fi <- file.info(pathname)
[10:20:15.682]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:20:15.682]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:15.682]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:20:15.682]                         fi[["size"]], fi[["mtime"]])
[10:20:15.682]                       stop(msg)
[10:20:15.682]                     }
[10:20:15.682]                     invisible(pathname)
[10:20:15.682]                   }
[10:20:15.682]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:20:15.682]                     rootPath = tempdir()) 
[10:20:15.682]                   {
[10:20:15.682]                     obj <- list(time = Sys.time(), condition = cond)
[10:20:15.682]                     file <- tempfile(pattern = class(cond)[1], 
[10:20:15.682]                       tmpdir = path, fileext = ".rds")
[10:20:15.682]                     save_rds(obj, file)
[10:20:15.682]                   }
[10:20:15.682]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8Z8Jdg/.future/immediateConditions")
[10:20:15.682]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:15.682]                   {
[10:20:15.682]                     inherits <- base::inherits
[10:20:15.682]                     invokeRestart <- base::invokeRestart
[10:20:15.682]                     is.null <- base::is.null
[10:20:15.682]                     muffled <- FALSE
[10:20:15.682]                     if (inherits(cond, "message")) {
[10:20:15.682]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:15.682]                       if (muffled) 
[10:20:15.682]                         invokeRestart("muffleMessage")
[10:20:15.682]                     }
[10:20:15.682]                     else if (inherits(cond, "warning")) {
[10:20:15.682]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:15.682]                       if (muffled) 
[10:20:15.682]                         invokeRestart("muffleWarning")
[10:20:15.682]                     }
[10:20:15.682]                     else if (inherits(cond, "condition")) {
[10:20:15.682]                       if (!is.null(pattern)) {
[10:20:15.682]                         computeRestarts <- base::computeRestarts
[10:20:15.682]                         grepl <- base::grepl
[10:20:15.682]                         restarts <- computeRestarts(cond)
[10:20:15.682]                         for (restart in restarts) {
[10:20:15.682]                           name <- restart$name
[10:20:15.682]                           if (is.null(name)) 
[10:20:15.682]                             next
[10:20:15.682]                           if (!grepl(pattern, name)) 
[10:20:15.682]                             next
[10:20:15.682]                           invokeRestart(restart)
[10:20:15.682]                           muffled <- TRUE
[10:20:15.682]                           break
[10:20:15.682]                         }
[10:20:15.682]                       }
[10:20:15.682]                     }
[10:20:15.682]                     invisible(muffled)
[10:20:15.682]                   }
[10:20:15.682]                   muffleCondition(cond)
[10:20:15.682]                 })
[10:20:15.682]             }))
[10:20:15.682]             future::FutureResult(value = ...future.value$value, 
[10:20:15.682]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:15.682]                   ...future.rng), globalenv = if (FALSE) 
[10:20:15.682]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:15.682]                     ...future.globalenv.names))
[10:20:15.682]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:15.682]         }, condition = base::local({
[10:20:15.682]             c <- base::c
[10:20:15.682]             inherits <- base::inherits
[10:20:15.682]             invokeRestart <- base::invokeRestart
[10:20:15.682]             length <- base::length
[10:20:15.682]             list <- base::list
[10:20:15.682]             seq.int <- base::seq.int
[10:20:15.682]             signalCondition <- base::signalCondition
[10:20:15.682]             sys.calls <- base::sys.calls
[10:20:15.682]             `[[` <- base::`[[`
[10:20:15.682]             `+` <- base::`+`
[10:20:15.682]             `<<-` <- base::`<<-`
[10:20:15.682]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:15.682]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:15.682]                   3L)]
[10:20:15.682]             }
[10:20:15.682]             function(cond) {
[10:20:15.682]                 is_error <- inherits(cond, "error")
[10:20:15.682]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:15.682]                   NULL)
[10:20:15.682]                 if (is_error) {
[10:20:15.682]                   sessionInformation <- function() {
[10:20:15.682]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:15.682]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:15.682]                       search = base::search(), system = base::Sys.info())
[10:20:15.682]                   }
[10:20:15.682]                   ...future.conditions[[length(...future.conditions) + 
[10:20:15.682]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:15.682]                     cond$call), session = sessionInformation(), 
[10:20:15.682]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:15.682]                   signalCondition(cond)
[10:20:15.682]                 }
[10:20:15.682]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:15.682]                 "immediateCondition"))) {
[10:20:15.682]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:15.682]                   ...future.conditions[[length(...future.conditions) + 
[10:20:15.682]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:15.682]                   if (TRUE && !signal) {
[10:20:15.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:15.682]                     {
[10:20:15.682]                       inherits <- base::inherits
[10:20:15.682]                       invokeRestart <- base::invokeRestart
[10:20:15.682]                       is.null <- base::is.null
[10:20:15.682]                       muffled <- FALSE
[10:20:15.682]                       if (inherits(cond, "message")) {
[10:20:15.682]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:15.682]                         if (muffled) 
[10:20:15.682]                           invokeRestart("muffleMessage")
[10:20:15.682]                       }
[10:20:15.682]                       else if (inherits(cond, "warning")) {
[10:20:15.682]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:15.682]                         if (muffled) 
[10:20:15.682]                           invokeRestart("muffleWarning")
[10:20:15.682]                       }
[10:20:15.682]                       else if (inherits(cond, "condition")) {
[10:20:15.682]                         if (!is.null(pattern)) {
[10:20:15.682]                           computeRestarts <- base::computeRestarts
[10:20:15.682]                           grepl <- base::grepl
[10:20:15.682]                           restarts <- computeRestarts(cond)
[10:20:15.682]                           for (restart in restarts) {
[10:20:15.682]                             name <- restart$name
[10:20:15.682]                             if (is.null(name)) 
[10:20:15.682]                               next
[10:20:15.682]                             if (!grepl(pattern, name)) 
[10:20:15.682]                               next
[10:20:15.682]                             invokeRestart(restart)
[10:20:15.682]                             muffled <- TRUE
[10:20:15.682]                             break
[10:20:15.682]                           }
[10:20:15.682]                         }
[10:20:15.682]                       }
[10:20:15.682]                       invisible(muffled)
[10:20:15.682]                     }
[10:20:15.682]                     muffleCondition(cond, pattern = "^muffle")
[10:20:15.682]                   }
[10:20:15.682]                 }
[10:20:15.682]                 else {
[10:20:15.682]                   if (TRUE) {
[10:20:15.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:15.682]                     {
[10:20:15.682]                       inherits <- base::inherits
[10:20:15.682]                       invokeRestart <- base::invokeRestart
[10:20:15.682]                       is.null <- base::is.null
[10:20:15.682]                       muffled <- FALSE
[10:20:15.682]                       if (inherits(cond, "message")) {
[10:20:15.682]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:15.682]                         if (muffled) 
[10:20:15.682]                           invokeRestart("muffleMessage")
[10:20:15.682]                       }
[10:20:15.682]                       else if (inherits(cond, "warning")) {
[10:20:15.682]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:15.682]                         if (muffled) 
[10:20:15.682]                           invokeRestart("muffleWarning")
[10:20:15.682]                       }
[10:20:15.682]                       else if (inherits(cond, "condition")) {
[10:20:15.682]                         if (!is.null(pattern)) {
[10:20:15.682]                           computeRestarts <- base::computeRestarts
[10:20:15.682]                           grepl <- base::grepl
[10:20:15.682]                           restarts <- computeRestarts(cond)
[10:20:15.682]                           for (restart in restarts) {
[10:20:15.682]                             name <- restart$name
[10:20:15.682]                             if (is.null(name)) 
[10:20:15.682]                               next
[10:20:15.682]                             if (!grepl(pattern, name)) 
[10:20:15.682]                               next
[10:20:15.682]                             invokeRestart(restart)
[10:20:15.682]                             muffled <- TRUE
[10:20:15.682]                             break
[10:20:15.682]                           }
[10:20:15.682]                         }
[10:20:15.682]                       }
[10:20:15.682]                       invisible(muffled)
[10:20:15.682]                     }
[10:20:15.682]                     muffleCondition(cond, pattern = "^muffle")
[10:20:15.682]                   }
[10:20:15.682]                 }
[10:20:15.682]             }
[10:20:15.682]         }))
[10:20:15.682]     }, error = function(ex) {
[10:20:15.682]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:15.682]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:15.682]                 ...future.rng), started = ...future.startTime, 
[10:20:15.682]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:15.682]             version = "1.8"), class = "FutureResult")
[10:20:15.682]     }, finally = {
[10:20:15.682]         if (!identical(...future.workdir, getwd())) 
[10:20:15.682]             setwd(...future.workdir)
[10:20:15.682]         {
[10:20:15.682]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:15.682]                 ...future.oldOptions$nwarnings <- NULL
[10:20:15.682]             }
[10:20:15.682]             base::options(...future.oldOptions)
[10:20:15.682]             if (.Platform$OS.type == "windows") {
[10:20:15.682]                 old_names <- names(...future.oldEnvVars)
[10:20:15.682]                 envs <- base::Sys.getenv()
[10:20:15.682]                 names <- names(envs)
[10:20:15.682]                 common <- intersect(names, old_names)
[10:20:15.682]                 added <- setdiff(names, old_names)
[10:20:15.682]                 removed <- setdiff(old_names, names)
[10:20:15.682]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:15.682]                   envs[common]]
[10:20:15.682]                 NAMES <- toupper(changed)
[10:20:15.682]                 args <- list()
[10:20:15.682]                 for (kk in seq_along(NAMES)) {
[10:20:15.682]                   name <- changed[[kk]]
[10:20:15.682]                   NAME <- NAMES[[kk]]
[10:20:15.682]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:15.682]                     next
[10:20:15.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:15.682]                 }
[10:20:15.682]                 NAMES <- toupper(added)
[10:20:15.682]                 for (kk in seq_along(NAMES)) {
[10:20:15.682]                   name <- added[[kk]]
[10:20:15.682]                   NAME <- NAMES[[kk]]
[10:20:15.682]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:15.682]                     next
[10:20:15.682]                   args[[name]] <- ""
[10:20:15.682]                 }
[10:20:15.682]                 NAMES <- toupper(removed)
[10:20:15.682]                 for (kk in seq_along(NAMES)) {
[10:20:15.682]                   name <- removed[[kk]]
[10:20:15.682]                   NAME <- NAMES[[kk]]
[10:20:15.682]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:15.682]                     next
[10:20:15.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:15.682]                 }
[10:20:15.682]                 if (length(args) > 0) 
[10:20:15.682]                   base::do.call(base::Sys.setenv, args = args)
[10:20:15.682]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:15.682]             }
[10:20:15.682]             else {
[10:20:15.682]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:15.682]             }
[10:20:15.682]             {
[10:20:15.682]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:15.682]                   0L) {
[10:20:15.682]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:15.682]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:15.682]                   base::options(opts)
[10:20:15.682]                 }
[10:20:15.682]                 {
[10:20:15.682]                   {
[10:20:15.682]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:15.682]                     NULL
[10:20:15.682]                   }
[10:20:15.682]                   options(future.plan = NULL)
[10:20:15.682]                   if (is.na(NA_character_)) 
[10:20:15.682]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:15.682]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:15.682]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:15.682]                     .init = FALSE)
[10:20:15.682]                 }
[10:20:15.682]             }
[10:20:15.682]         }
[10:20:15.682]     })
[10:20:15.682]     if (FALSE) {
[10:20:15.682]         base::sink(type = "output", split = FALSE)
[10:20:15.682]         if (NA) {
[10:20:15.682]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:15.682]         }
[10:20:15.682]         else {
[10:20:15.682]             ...future.result["stdout"] <- base::list(NULL)
[10:20:15.682]         }
[10:20:15.682]         base::close(...future.stdout)
[10:20:15.682]         ...future.stdout <- NULL
[10:20:15.682]     }
[10:20:15.682]     ...future.result$conditions <- ...future.conditions
[10:20:15.682]     ...future.result$finished <- base::Sys.time()
[10:20:15.682]     ...future.result
[10:20:15.682] }
[10:20:15.685] assign_globals() ...
[10:20:15.685] List of 5
[10:20:15.685]  $ ...future.FUN            :function (x)  
[10:20:15.685]  $ future.call.arguments    : list()
[10:20:15.685]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:15.685]  $ ...future.elements_ii    :List of 1
[10:20:15.685]   ..$ : int 0
[10:20:15.685]  $ ...future.seeds_ii       : NULL
[10:20:15.685]  $ ...future.globals.maxSize: NULL
[10:20:15.685]  - attr(*, "where")=List of 5
[10:20:15.685]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:15.685]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:20:15.685]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:15.685]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:15.685]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:15.685]  - attr(*, "resolved")= logi FALSE
[10:20:15.685]  - attr(*, "total_size")= num 5632
[10:20:15.685]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:15.685]  - attr(*, "already-done")= logi TRUE
[10:20:15.698] - reassign environment for ‘...future.FUN’
[10:20:15.698] - copied ‘...future.FUN’ to environment
[10:20:15.699] - copied ‘future.call.arguments’ to environment
[10:20:15.699] - copied ‘...future.elements_ii’ to environment
[10:20:15.699] - copied ‘...future.seeds_ii’ to environment
[10:20:15.699] - copied ‘...future.globals.maxSize’ to environment
[10:20:15.699] assign_globals() ... done
[10:20:15.699] requestCore(): workers = 2
[10:20:15.702] MulticoreFuture started
[10:20:15.702] - Launch lazy future ... done
[10:20:15.702] run() for ‘MulticoreFuture’ ... done
[10:20:15.703] Created future:
[10:20:15.703] plan(): Setting new future strategy stack:
[10:20:15.703] List of future strategies:
[10:20:15.703] 1. sequential:
[10:20:15.703]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:15.703]    - tweaked: FALSE
[10:20:15.703]    - call: NULL
[10:20:15.704] plan(): nbrOfWorkers() = 1
[10:20:15.707] plan(): Setting new future strategy stack:
[10:20:15.707] List of future strategies:
[10:20:15.707] 1. multicore:
[10:20:15.707]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:20:15.707]    - tweaked: FALSE
[10:20:15.707]    - call: plan(strategy)
[10:20:15.710] plan(): nbrOfWorkers() = 2
[10:20:15.703] MulticoreFuture:
[10:20:15.703] Label: ‘future_lapply-2’
[10:20:15.703] Expression:
[10:20:15.703] {
[10:20:15.703]     do.call(function(...) {
[10:20:15.703]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:15.703]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:15.703]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:15.703]             on.exit(options(oopts), add = TRUE)
[10:20:15.703]         }
[10:20:15.703]         {
[10:20:15.703]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:15.703]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:15.703]                 ...future.FUN(...future.X_jj, ...)
[10:20:15.703]             })
[10:20:15.703]         }
[10:20:15.703]     }, args = future.call.arguments)
[10:20:15.703] }
[10:20:15.703] Lazy evaluation: FALSE
[10:20:15.703] Asynchronous evaluation: TRUE
[10:20:15.703] Local evaluation: TRUE
[10:20:15.703] Environment: R_GlobalEnv
[10:20:15.703] Capture standard output: NA
[10:20:15.703] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:15.703] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:15.703] Packages: <none>
[10:20:15.703] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:15.703] Resolved: TRUE
[10:20:15.703] Value: <not collected>
[10:20:15.703] Conditions captured: <none>
[10:20:15.703] Early signaling: FALSE
[10:20:15.703] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:15.703] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:15.711] Chunk #2 of 2 ... DONE
[10:20:15.712] Launching 2 futures (chunks) ... DONE
[10:20:15.712] Resolving 2 futures (chunks) ...
[10:20:15.712] resolve() on list ...
[10:20:15.712]  recursive: 0
[10:20:15.713]  length: 2
[10:20:15.713] 
[10:20:15.723] Future #2
[10:20:15.724] result() for MulticoreFuture ...
[10:20:15.725] result() for MulticoreFuture ...
[10:20:15.725] result() for MulticoreFuture ... done
[10:20:15.725] result() for MulticoreFuture ... done
[10:20:15.725] result() for MulticoreFuture ...
[10:20:15.725] result() for MulticoreFuture ... done
[10:20:15.726] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:20:15.726] - nx: 2
[10:20:15.726] - relay: TRUE
[10:20:15.726] - stdout: TRUE
[10:20:15.726] - signal: TRUE
[10:20:15.726] - resignal: FALSE
[10:20:15.726] - force: TRUE
[10:20:15.727] - relayed: [n=2] FALSE, FALSE
[10:20:15.727] - queued futures: [n=2] FALSE, FALSE
[10:20:15.727]  - until=1
[10:20:15.727]  - relaying element #1
[10:20:15.727] - relayed: [n=2] FALSE, FALSE
[10:20:15.727] - queued futures: [n=2] FALSE, TRUE
[10:20:15.727] signalConditionsASAP(NULL, pos=2) ... done
[10:20:15.728]  length: 1 (resolved future 2)
[10:20:16.159] plan(): Setting new future strategy stack:
[10:20:16.159] List of future strategies:
[10:20:16.159] 1. multicore:
[10:20:16.159]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:20:16.159]    - tweaked: FALSE
[10:20:16.159]    - call: plan(strategy)
[10:20:16.162] plan(): nbrOfWorkers() = 2
[10:20:16.166] Future #1
[10:20:16.167] result() for MulticoreFuture ...
[10:20:16.168] result() for MulticoreFuture ...
[10:20:16.168] result() for MulticoreFuture ... done
[10:20:16.168] result() for MulticoreFuture ... done
[10:20:16.168] result() for MulticoreFuture ...
[10:20:16.168] result() for MulticoreFuture ... done
[10:20:16.169] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:20:16.169] - nx: 2
[10:20:16.169] - relay: TRUE
[10:20:16.169] - stdout: TRUE
[10:20:16.169] - signal: TRUE
[10:20:16.169] - resignal: FALSE
[10:20:16.169] - force: TRUE
[10:20:16.169] - relayed: [n=2] FALSE, FALSE
[10:20:16.169] - queued futures: [n=2] FALSE, TRUE
[10:20:16.170]  - until=1
[10:20:16.170]  - relaying element #1
[10:20:16.170] result() for MulticoreFuture ...
[10:20:16.170] result() for MulticoreFuture ... done
[10:20:16.170] result() for MulticoreFuture ...
[10:20:16.170] result() for MulticoreFuture ... done
[10:20:16.170] result() for MulticoreFuture ...
[10:20:16.170] result() for MulticoreFuture ... done
[10:20:16.170] result() for MulticoreFuture ...
[10:20:16.171] result() for MulticoreFuture ... done
[10:20:16.171] - relayed: [n=2] TRUE, FALSE
[10:20:16.171] - queued futures: [n=2] TRUE, TRUE
[10:20:16.171] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:20:16.171]  length: 0 (resolved future 1)
[10:20:16.171] Relaying remaining futures
[10:20:16.171] signalConditionsASAP(NULL, pos=0) ...
[10:20:16.171] - nx: 2
[10:20:16.171] - relay: TRUE
[10:20:16.172] - stdout: TRUE
[10:20:16.172] - signal: TRUE
[10:20:16.172] - resignal: FALSE
[10:20:16.172] - force: TRUE
[10:20:16.172] - relayed: [n=2] TRUE, FALSE
[10:20:16.172] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:20:16.172]  - relaying element #2
[10:20:16.172] result() for MulticoreFuture ...
[10:20:16.172] result() for MulticoreFuture ... done
[10:20:16.173] result() for MulticoreFuture ...
[10:20:16.173] result() for MulticoreFuture ... done
[10:20:16.173] result() for MulticoreFuture ...
[10:20:16.173] result() for MulticoreFuture ... done
[10:20:16.173] result() for MulticoreFuture ...
[10:20:16.173] result() for MulticoreFuture ... done
[10:20:16.173] - relayed: [n=2] TRUE, TRUE
[10:20:16.173] - queued futures: [n=2] TRUE, TRUE
[10:20:16.174] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[10:20:16.174] resolve() on list ... DONE
[10:20:16.174] result() for MulticoreFuture ...
[10:20:16.174] result() for MulticoreFuture ... done
[10:20:16.174] result() for MulticoreFuture ...
[10:20:16.174] result() for MulticoreFuture ... done
[10:20:16.174] result() for MulticoreFuture ...
[10:20:16.174] result() for MulticoreFuture ... done
[10:20:16.174] result() for MulticoreFuture ...
[10:20:16.174] result() for MulticoreFuture ... done
[10:20:16.175]  - Number of value chunks collected: 2
[10:20:16.175] Resolving 2 futures (chunks) ... DONE
[10:20:16.175] Reducing values from 2 chunks ...
[10:20:16.175]  - Number of values collected after concatenation: 2
[10:20:16.175]  - Number of values expected: 2
[10:20:16.175] Reducing values from 2 chunks ... DONE
[10:20:16.175] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[10:20:16.176] future_mapply() ...
[10:20:16.178] Number of chunks: 2
[10:20:16.178] getGlobalsAndPackagesXApply() ...
[10:20:16.178]  - future.globals: TRUE
[10:20:16.179] getGlobalsAndPackages() ...
[10:20:16.179] Searching for globals...
[10:20:16.183] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:20:16.183] Searching for globals ... DONE
[10:20:16.183] Resolving globals: FALSE
[10:20:16.184] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[10:20:16.184] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[10:20:16.185] - globals: [1] ‘FUN’
[10:20:16.185] 
[10:20:16.185] getGlobalsAndPackages() ... DONE
[10:20:16.185]  - globals found/used: [n=1] ‘FUN’
[10:20:16.185]  - needed namespaces: [n=0] 
[10:20:16.185] Finding globals ... DONE
[10:20:16.186] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:20:16.186] List of 2
[10:20:16.186]  $ ...future.FUN:function (x, y)  
[10:20:16.186]  $ MoreArgs     : NULL
[10:20:16.186]  - attr(*, "where")=List of 2
[10:20:16.186]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:16.186]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:20:16.186]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:16.186]  - attr(*, "resolved")= logi FALSE
[10:20:16.186]  - attr(*, "total_size")= num NA
[10:20:16.189] Packages to be attached in all futures: [n=0] 
[10:20:16.189] getGlobalsAndPackagesXApply() ... DONE
[10:20:16.189] Number of futures (= number of chunks): 2
[10:20:16.189] Launching 2 futures (chunks) ...
[10:20:16.189] Chunk #1 of 2 ...
[10:20:16.189]  - Finding globals in '...' for chunk #1 ...
[10:20:16.190] getGlobalsAndPackages() ...
[10:20:16.190] Searching for globals...
[10:20:16.190] 
[10:20:16.190] Searching for globals ... DONE
[10:20:16.190] - globals: [0] <none>
[10:20:16.190] getGlobalsAndPackages() ... DONE
[10:20:16.190]    + additional globals found: [n=0] 
[10:20:16.190]    + additional namespaces needed: [n=0] 
[10:20:16.190]  - Finding globals in '...' for chunk #1 ... DONE
[10:20:16.191]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:16.191]  - seeds: <none>
[10:20:16.191]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:16.191] getGlobalsAndPackages() ...
[10:20:16.191] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:16.191] Resolving globals: FALSE
[10:20:16.191] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[10:20:16.192] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:20:16.192] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:16.192] 
[10:20:16.192] getGlobalsAndPackages() ... DONE
[10:20:16.193] run() for ‘Future’ ...
[10:20:16.193] - state: ‘created’
[10:20:16.193] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:20:16.194] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:16.195] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:20:16.195]   - Field: ‘label’
[10:20:16.195]   - Field: ‘local’
[10:20:16.195]   - Field: ‘owner’
[10:20:16.195]   - Field: ‘envir’
[10:20:16.195]   - Field: ‘workers’
[10:20:16.195]   - Field: ‘packages’
[10:20:16.195]   - Field: ‘gc’
[10:20:16.195]   - Field: ‘job’
[10:20:16.195]   - Field: ‘conditions’
[10:20:16.195]   - Field: ‘expr’
[10:20:16.196]   - Field: ‘uuid’
[10:20:16.196]   - Field: ‘seed’
[10:20:16.196]   - Field: ‘version’
[10:20:16.196]   - Field: ‘result’
[10:20:16.196]   - Field: ‘asynchronous’
[10:20:16.196]   - Field: ‘calls’
[10:20:16.196]   - Field: ‘globals’
[10:20:16.196]   - Field: ‘stdout’
[10:20:16.196]   - Field: ‘earlySignal’
[10:20:16.196]   - Field: ‘lazy’
[10:20:16.196]   - Field: ‘state’
[10:20:16.197] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:20:16.197] - Launch lazy future ...
[10:20:16.197] Packages needed by the future expression (n = 0): <none>
[10:20:16.197] Packages needed by future strategies (n = 0): <none>
[10:20:16.197] {
[10:20:16.197]     {
[10:20:16.197]         {
[10:20:16.197]             ...future.startTime <- base::Sys.time()
[10:20:16.197]             {
[10:20:16.197]                 {
[10:20:16.197]                   {
[10:20:16.197]                     {
[10:20:16.197]                       base::local({
[10:20:16.197]                         has_future <- base::requireNamespace("future", 
[10:20:16.197]                           quietly = TRUE)
[10:20:16.197]                         if (has_future) {
[10:20:16.197]                           ns <- base::getNamespace("future")
[10:20:16.197]                           version <- ns[[".package"]][["version"]]
[10:20:16.197]                           if (is.null(version)) 
[10:20:16.197]                             version <- utils::packageVersion("future")
[10:20:16.197]                         }
[10:20:16.197]                         else {
[10:20:16.197]                           version <- NULL
[10:20:16.197]                         }
[10:20:16.197]                         if (!has_future || version < "1.8.0") {
[10:20:16.197]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:16.197]                             "", base::R.version$version.string), 
[10:20:16.197]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:16.197]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:16.197]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:16.197]                               "release", "version")], collapse = " "), 
[10:20:16.197]                             hostname = base::Sys.info()[["nodename"]])
[10:20:16.197]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:16.197]                             info)
[10:20:16.197]                           info <- base::paste(info, collapse = "; ")
[10:20:16.197]                           if (!has_future) {
[10:20:16.197]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:16.197]                               info)
[10:20:16.197]                           }
[10:20:16.197]                           else {
[10:20:16.197]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:16.197]                               info, version)
[10:20:16.197]                           }
[10:20:16.197]                           base::stop(msg)
[10:20:16.197]                         }
[10:20:16.197]                       })
[10:20:16.197]                     }
[10:20:16.197]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:16.197]                     base::options(mc.cores = 1L)
[10:20:16.197]                   }
[10:20:16.197]                   ...future.strategy.old <- future::plan("list")
[10:20:16.197]                   options(future.plan = NULL)
[10:20:16.197]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:16.197]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:16.197]                 }
[10:20:16.197]                 ...future.workdir <- getwd()
[10:20:16.197]             }
[10:20:16.197]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:16.197]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:16.197]         }
[10:20:16.197]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:16.197]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:16.197]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:16.197]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:16.197]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:16.197]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:16.197]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:16.197]             base::names(...future.oldOptions))
[10:20:16.197]     }
[10:20:16.197]     if (FALSE) {
[10:20:16.197]     }
[10:20:16.197]     else {
[10:20:16.197]         if (FALSE) {
[10:20:16.197]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:16.197]                 open = "w")
[10:20:16.197]         }
[10:20:16.197]         else {
[10:20:16.197]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:16.197]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:16.197]         }
[10:20:16.197]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:16.197]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:16.197]             base::sink(type = "output", split = FALSE)
[10:20:16.197]             base::close(...future.stdout)
[10:20:16.197]         }, add = TRUE)
[10:20:16.197]     }
[10:20:16.197]     ...future.frame <- base::sys.nframe()
[10:20:16.197]     ...future.conditions <- base::list()
[10:20:16.197]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:16.197]     if (FALSE) {
[10:20:16.197]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:16.197]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:16.197]     }
[10:20:16.197]     ...future.result <- base::tryCatch({
[10:20:16.197]         base::withCallingHandlers({
[10:20:16.197]             ...future.value <- base::withVisible(base::local({
[10:20:16.197]                 withCallingHandlers({
[10:20:16.197]                   {
[10:20:16.197]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:16.197]                     if (!identical(...future.globals.maxSize.org, 
[10:20:16.197]                       ...future.globals.maxSize)) {
[10:20:16.197]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:16.197]                       on.exit(options(oopts), add = TRUE)
[10:20:16.197]                     }
[10:20:16.197]                     {
[10:20:16.197]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:16.197]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:20:16.197]                         USE.NAMES = FALSE)
[10:20:16.197]                       do.call(mapply, args = args)
[10:20:16.197]                     }
[10:20:16.197]                   }
[10:20:16.197]                 }, immediateCondition = function(cond) {
[10:20:16.197]                   save_rds <- function (object, pathname, ...) 
[10:20:16.197]                   {
[10:20:16.197]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:20:16.197]                     if (file_test("-f", pathname_tmp)) {
[10:20:16.197]                       fi_tmp <- file.info(pathname_tmp)
[10:20:16.197]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:20:16.197]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:16.197]                         fi_tmp[["mtime"]])
[10:20:16.197]                     }
[10:20:16.197]                     tryCatch({
[10:20:16.197]                       saveRDS(object, file = pathname_tmp, ...)
[10:20:16.197]                     }, error = function(ex) {
[10:20:16.197]                       msg <- conditionMessage(ex)
[10:20:16.197]                       fi_tmp <- file.info(pathname_tmp)
[10:20:16.197]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:20:16.197]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:16.197]                         fi_tmp[["mtime"]], msg)
[10:20:16.197]                       ex$message <- msg
[10:20:16.197]                       stop(ex)
[10:20:16.197]                     })
[10:20:16.197]                     stopifnot(file_test("-f", pathname_tmp))
[10:20:16.197]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:20:16.197]                     if (!res || file_test("-f", pathname_tmp)) {
[10:20:16.197]                       fi_tmp <- file.info(pathname_tmp)
[10:20:16.197]                       fi <- file.info(pathname)
[10:20:16.197]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:20:16.197]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:16.197]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:20:16.197]                         fi[["size"]], fi[["mtime"]])
[10:20:16.197]                       stop(msg)
[10:20:16.197]                     }
[10:20:16.197]                     invisible(pathname)
[10:20:16.197]                   }
[10:20:16.197]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:20:16.197]                     rootPath = tempdir()) 
[10:20:16.197]                   {
[10:20:16.197]                     obj <- list(time = Sys.time(), condition = cond)
[10:20:16.197]                     file <- tempfile(pattern = class(cond)[1], 
[10:20:16.197]                       tmpdir = path, fileext = ".rds")
[10:20:16.197]                     save_rds(obj, file)
[10:20:16.197]                   }
[10:20:16.197]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8Z8Jdg/.future/immediateConditions")
[10:20:16.197]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:16.197]                   {
[10:20:16.197]                     inherits <- base::inherits
[10:20:16.197]                     invokeRestart <- base::invokeRestart
[10:20:16.197]                     is.null <- base::is.null
[10:20:16.197]                     muffled <- FALSE
[10:20:16.197]                     if (inherits(cond, "message")) {
[10:20:16.197]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:16.197]                       if (muffled) 
[10:20:16.197]                         invokeRestart("muffleMessage")
[10:20:16.197]                     }
[10:20:16.197]                     else if (inherits(cond, "warning")) {
[10:20:16.197]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:16.197]                       if (muffled) 
[10:20:16.197]                         invokeRestart("muffleWarning")
[10:20:16.197]                     }
[10:20:16.197]                     else if (inherits(cond, "condition")) {
[10:20:16.197]                       if (!is.null(pattern)) {
[10:20:16.197]                         computeRestarts <- base::computeRestarts
[10:20:16.197]                         grepl <- base::grepl
[10:20:16.197]                         restarts <- computeRestarts(cond)
[10:20:16.197]                         for (restart in restarts) {
[10:20:16.197]                           name <- restart$name
[10:20:16.197]                           if (is.null(name)) 
[10:20:16.197]                             next
[10:20:16.197]                           if (!grepl(pattern, name)) 
[10:20:16.197]                             next
[10:20:16.197]                           invokeRestart(restart)
[10:20:16.197]                           muffled <- TRUE
[10:20:16.197]                           break
[10:20:16.197]                         }
[10:20:16.197]                       }
[10:20:16.197]                     }
[10:20:16.197]                     invisible(muffled)
[10:20:16.197]                   }
[10:20:16.197]                   muffleCondition(cond)
[10:20:16.197]                 })
[10:20:16.197]             }))
[10:20:16.197]             future::FutureResult(value = ...future.value$value, 
[10:20:16.197]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:16.197]                   ...future.rng), globalenv = if (FALSE) 
[10:20:16.197]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:16.197]                     ...future.globalenv.names))
[10:20:16.197]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:16.197]         }, condition = base::local({
[10:20:16.197]             c <- base::c
[10:20:16.197]             inherits <- base::inherits
[10:20:16.197]             invokeRestart <- base::invokeRestart
[10:20:16.197]             length <- base::length
[10:20:16.197]             list <- base::list
[10:20:16.197]             seq.int <- base::seq.int
[10:20:16.197]             signalCondition <- base::signalCondition
[10:20:16.197]             sys.calls <- base::sys.calls
[10:20:16.197]             `[[` <- base::`[[`
[10:20:16.197]             `+` <- base::`+`
[10:20:16.197]             `<<-` <- base::`<<-`
[10:20:16.197]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:16.197]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:16.197]                   3L)]
[10:20:16.197]             }
[10:20:16.197]             function(cond) {
[10:20:16.197]                 is_error <- inherits(cond, "error")
[10:20:16.197]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:16.197]                   NULL)
[10:20:16.197]                 if (is_error) {
[10:20:16.197]                   sessionInformation <- function() {
[10:20:16.197]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:16.197]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:16.197]                       search = base::search(), system = base::Sys.info())
[10:20:16.197]                   }
[10:20:16.197]                   ...future.conditions[[length(...future.conditions) + 
[10:20:16.197]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:16.197]                     cond$call), session = sessionInformation(), 
[10:20:16.197]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:16.197]                   signalCondition(cond)
[10:20:16.197]                 }
[10:20:16.197]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:16.197]                 "immediateCondition"))) {
[10:20:16.197]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:16.197]                   ...future.conditions[[length(...future.conditions) + 
[10:20:16.197]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:16.197]                   if (TRUE && !signal) {
[10:20:16.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:16.197]                     {
[10:20:16.197]                       inherits <- base::inherits
[10:20:16.197]                       invokeRestart <- base::invokeRestart
[10:20:16.197]                       is.null <- base::is.null
[10:20:16.197]                       muffled <- FALSE
[10:20:16.197]                       if (inherits(cond, "message")) {
[10:20:16.197]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:16.197]                         if (muffled) 
[10:20:16.197]                           invokeRestart("muffleMessage")
[10:20:16.197]                       }
[10:20:16.197]                       else if (inherits(cond, "warning")) {
[10:20:16.197]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:16.197]                         if (muffled) 
[10:20:16.197]                           invokeRestart("muffleWarning")
[10:20:16.197]                       }
[10:20:16.197]                       else if (inherits(cond, "condition")) {
[10:20:16.197]                         if (!is.null(pattern)) {
[10:20:16.197]                           computeRestarts <- base::computeRestarts
[10:20:16.197]                           grepl <- base::grepl
[10:20:16.197]                           restarts <- computeRestarts(cond)
[10:20:16.197]                           for (restart in restarts) {
[10:20:16.197]                             name <- restart$name
[10:20:16.197]                             if (is.null(name)) 
[10:20:16.197]                               next
[10:20:16.197]                             if (!grepl(pattern, name)) 
[10:20:16.197]                               next
[10:20:16.197]                             invokeRestart(restart)
[10:20:16.197]                             muffled <- TRUE
[10:20:16.197]                             break
[10:20:16.197]                           }
[10:20:16.197]                         }
[10:20:16.197]                       }
[10:20:16.197]                       invisible(muffled)
[10:20:16.197]                     }
[10:20:16.197]                     muffleCondition(cond, pattern = "^muffle")
[10:20:16.197]                   }
[10:20:16.197]                 }
[10:20:16.197]                 else {
[10:20:16.197]                   if (TRUE) {
[10:20:16.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:16.197]                     {
[10:20:16.197]                       inherits <- base::inherits
[10:20:16.197]                       invokeRestart <- base::invokeRestart
[10:20:16.197]                       is.null <- base::is.null
[10:20:16.197]                       muffled <- FALSE
[10:20:16.197]                       if (inherits(cond, "message")) {
[10:20:16.197]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:16.197]                         if (muffled) 
[10:20:16.197]                           invokeRestart("muffleMessage")
[10:20:16.197]                       }
[10:20:16.197]                       else if (inherits(cond, "warning")) {
[10:20:16.197]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:16.197]                         if (muffled) 
[10:20:16.197]                           invokeRestart("muffleWarning")
[10:20:16.197]                       }
[10:20:16.197]                       else if (inherits(cond, "condition")) {
[10:20:16.197]                         if (!is.null(pattern)) {
[10:20:16.197]                           computeRestarts <- base::computeRestarts
[10:20:16.197]                           grepl <- base::grepl
[10:20:16.197]                           restarts <- computeRestarts(cond)
[10:20:16.197]                           for (restart in restarts) {
[10:20:16.197]                             name <- restart$name
[10:20:16.197]                             if (is.null(name)) 
[10:20:16.197]                               next
[10:20:16.197]                             if (!grepl(pattern, name)) 
[10:20:16.197]                               next
[10:20:16.197]                             invokeRestart(restart)
[10:20:16.197]                             muffled <- TRUE
[10:20:16.197]                             break
[10:20:16.197]                           }
[10:20:16.197]                         }
[10:20:16.197]                       }
[10:20:16.197]                       invisible(muffled)
[10:20:16.197]                     }
[10:20:16.197]                     muffleCondition(cond, pattern = "^muffle")
[10:20:16.197]                   }
[10:20:16.197]                 }
[10:20:16.197]             }
[10:20:16.197]         }))
[10:20:16.197]     }, error = function(ex) {
[10:20:16.197]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:16.197]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:16.197]                 ...future.rng), started = ...future.startTime, 
[10:20:16.197]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:16.197]             version = "1.8"), class = "FutureResult")
[10:20:16.197]     }, finally = {
[10:20:16.197]         if (!identical(...future.workdir, getwd())) 
[10:20:16.197]             setwd(...future.workdir)
[10:20:16.197]         {
[10:20:16.197]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:16.197]                 ...future.oldOptions$nwarnings <- NULL
[10:20:16.197]             }
[10:20:16.197]             base::options(...future.oldOptions)
[10:20:16.197]             if (.Platform$OS.type == "windows") {
[10:20:16.197]                 old_names <- names(...future.oldEnvVars)
[10:20:16.197]                 envs <- base::Sys.getenv()
[10:20:16.197]                 names <- names(envs)
[10:20:16.197]                 common <- intersect(names, old_names)
[10:20:16.197]                 added <- setdiff(names, old_names)
[10:20:16.197]                 removed <- setdiff(old_names, names)
[10:20:16.197]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:16.197]                   envs[common]]
[10:20:16.197]                 NAMES <- toupper(changed)
[10:20:16.197]                 args <- list()
[10:20:16.197]                 for (kk in seq_along(NAMES)) {
[10:20:16.197]                   name <- changed[[kk]]
[10:20:16.197]                   NAME <- NAMES[[kk]]
[10:20:16.197]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:16.197]                     next
[10:20:16.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:16.197]                 }
[10:20:16.197]                 NAMES <- toupper(added)
[10:20:16.197]                 for (kk in seq_along(NAMES)) {
[10:20:16.197]                   name <- added[[kk]]
[10:20:16.197]                   NAME <- NAMES[[kk]]
[10:20:16.197]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:16.197]                     next
[10:20:16.197]                   args[[name]] <- ""
[10:20:16.197]                 }
[10:20:16.197]                 NAMES <- toupper(removed)
[10:20:16.197]                 for (kk in seq_along(NAMES)) {
[10:20:16.197]                   name <- removed[[kk]]
[10:20:16.197]                   NAME <- NAMES[[kk]]
[10:20:16.197]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:16.197]                     next
[10:20:16.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:16.197]                 }
[10:20:16.197]                 if (length(args) > 0) 
[10:20:16.197]                   base::do.call(base::Sys.setenv, args = args)
[10:20:16.197]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:16.197]             }
[10:20:16.197]             else {
[10:20:16.197]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:16.197]             }
[10:20:16.197]             {
[10:20:16.197]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:16.197]                   0L) {
[10:20:16.197]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:16.197]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:16.197]                   base::options(opts)
[10:20:16.197]                 }
[10:20:16.197]                 {
[10:20:16.197]                   {
[10:20:16.197]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:16.197]                     NULL
[10:20:16.197]                   }
[10:20:16.197]                   options(future.plan = NULL)
[10:20:16.197]                   if (is.na(NA_character_)) 
[10:20:16.197]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:16.197]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:16.197]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:16.197]                     .init = FALSE)
[10:20:16.197]                 }
[10:20:16.197]             }
[10:20:16.197]         }
[10:20:16.197]     })
[10:20:16.197]     if (TRUE) {
[10:20:16.197]         base::sink(type = "output", split = FALSE)
[10:20:16.197]         if (FALSE) {
[10:20:16.197]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:16.197]         }
[10:20:16.197]         else {
[10:20:16.197]             ...future.result["stdout"] <- base::list(NULL)
[10:20:16.197]         }
[10:20:16.197]         base::close(...future.stdout)
[10:20:16.197]         ...future.stdout <- NULL
[10:20:16.197]     }
[10:20:16.197]     ...future.result$conditions <- ...future.conditions
[10:20:16.197]     ...future.result$finished <- base::Sys.time()
[10:20:16.197]     ...future.result
[10:20:16.197] }
[10:20:16.200] assign_globals() ...
[10:20:16.200] List of 5
[10:20:16.200]  $ ...future.FUN            :function (x, y)  
[10:20:16.200]  $ MoreArgs                 : NULL
[10:20:16.200]  $ ...future.elements_ii    :List of 2
[10:20:16.200]   ..$ :List of 1
[10:20:16.200]   .. ..$ : int 1
[10:20:16.200]   ..$ :List of 1
[10:20:16.200]   .. ..$ : int 0
[10:20:16.200]  $ ...future.seeds_ii       : NULL
[10:20:16.200]  $ ...future.globals.maxSize: NULL
[10:20:16.200]  - attr(*, "where")=List of 5
[10:20:16.200]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:16.200]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:20:16.200]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:16.200]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:16.200]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:16.200]  - attr(*, "resolved")= logi FALSE
[10:20:16.200]  - attr(*, "total_size")= num 1218
[10:20:16.200]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:16.200]  - attr(*, "already-done")= logi TRUE
[10:20:16.205] - reassign environment for ‘...future.FUN’
[10:20:16.205] - copied ‘...future.FUN’ to environment
[10:20:16.205] - copied ‘MoreArgs’ to environment
[10:20:16.205] - copied ‘...future.elements_ii’ to environment
[10:20:16.205] - copied ‘...future.seeds_ii’ to environment
[10:20:16.206] - copied ‘...future.globals.maxSize’ to environment
[10:20:16.206] assign_globals() ... done
[10:20:16.206] requestCore(): workers = 2
[10:20:16.208] MulticoreFuture started
[10:20:16.208] - Launch lazy future ... done
[10:20:16.208] run() for ‘MulticoreFuture’ ... done
[10:20:16.209] Created future:
[10:20:16.209] plan(): Setting new future strategy stack:
[10:20:16.209] List of future strategies:
[10:20:16.209] 1. sequential:
[10:20:16.209]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:16.209]    - tweaked: FALSE
[10:20:16.209]    - call: NULL
[10:20:16.210] plan(): nbrOfWorkers() = 1
[10:20:16.209] MulticoreFuture:
[10:20:16.209] Label: ‘future_mapply-1’
[10:20:16.209] Expression:
[10:20:16.209] {
[10:20:16.209]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:16.209]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:16.209]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:16.209]         on.exit(options(oopts), add = TRUE)
[10:20:16.209]     }
[10:20:16.209]     {
[10:20:16.209]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:16.209]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:20:16.209]         do.call(mapply, args = args)
[10:20:16.209]     }
[10:20:16.209] }
[10:20:16.209] Lazy evaluation: FALSE
[10:20:16.209] Asynchronous evaluation: TRUE
[10:20:16.209] Local evaluation: TRUE
[10:20:16.209] Environment: R_GlobalEnv
[10:20:16.209] Capture standard output: FALSE
[10:20:16.209] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:16.209] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:16.209] Packages: <none>
[10:20:16.209] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:16.209] Resolved: FALSE
[10:20:16.209] Value: <not collected>
[10:20:16.209] Conditions captured: <none>
[10:20:16.209] Early signaling: FALSE
[10:20:16.209] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:16.209] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:16.225] Chunk #1 of 2 ... DONE
[10:20:16.226] Chunk #2 of 2 ...
[10:20:16.226]  - Finding globals in '...' for chunk #2 ...
[10:20:16.226] getGlobalsAndPackages() ...
[10:20:16.227] Searching for globals...
[10:20:16.228] 
[10:20:16.229] Searching for globals ... DONE
[10:20:16.229] - globals: [0] <none>
[10:20:16.229] getGlobalsAndPackages() ... DONE
[10:20:16.230]    + additional globals found: [n=0] 
[10:20:16.230]    + additional namespaces needed: [n=0] 
[10:20:16.230]  - Finding globals in '...' for chunk #2 ... DONE
[10:20:16.231]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:16.231]  - seeds: <none>
[10:20:16.231]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:16.232] getGlobalsAndPackages() ...
[10:20:16.232] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:16.232] Resolving globals: FALSE
[10:20:16.233] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[10:20:16.234] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:20:16.234] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:16.235] 
[10:20:16.235] getGlobalsAndPackages() ... DONE
[10:20:16.235] run() for ‘Future’ ...
[10:20:16.235] - state: ‘created’
[10:20:16.236] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:20:16.239] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:16.239] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:20:16.239]   - Field: ‘label’
[10:20:16.239]   - Field: ‘local’
[10:20:16.239]   - Field: ‘owner’
[10:20:16.239]   - Field: ‘envir’
[10:20:16.239]   - Field: ‘workers’
[10:20:16.240]   - Field: ‘packages’
[10:20:16.240]   - Field: ‘gc’
[10:20:16.240]   - Field: ‘job’
[10:20:16.240]   - Field: ‘conditions’
[10:20:16.240]   - Field: ‘expr’
[10:20:16.240]   - Field: ‘uuid’
[10:20:16.240]   - Field: ‘seed’
[10:20:16.240]   - Field: ‘version’
[10:20:16.241]   - Field: ‘result’
[10:20:16.241]   - Field: ‘asynchronous’
[10:20:16.241]   - Field: ‘calls’
[10:20:16.241]   - Field: ‘globals’
[10:20:16.241]   - Field: ‘stdout’
[10:20:16.241]   - Field: ‘earlySignal’
[10:20:16.241]   - Field: ‘lazy’
[10:20:16.242]   - Field: ‘state’
[10:20:16.242] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:20:16.242] - Launch lazy future ...
[10:20:16.242] Packages needed by the future expression (n = 0): <none>
[10:20:16.242] Packages needed by future strategies (n = 0): <none>
[10:20:16.243] {
[10:20:16.243]     {
[10:20:16.243]         {
[10:20:16.243]             ...future.startTime <- base::Sys.time()
[10:20:16.243]             {
[10:20:16.243]                 {
[10:20:16.243]                   {
[10:20:16.243]                     {
[10:20:16.243]                       base::local({
[10:20:16.243]                         has_future <- base::requireNamespace("future", 
[10:20:16.243]                           quietly = TRUE)
[10:20:16.243]                         if (has_future) {
[10:20:16.243]                           ns <- base::getNamespace("future")
[10:20:16.243]                           version <- ns[[".package"]][["version"]]
[10:20:16.243]                           if (is.null(version)) 
[10:20:16.243]                             version <- utils::packageVersion("future")
[10:20:16.243]                         }
[10:20:16.243]                         else {
[10:20:16.243]                           version <- NULL
[10:20:16.243]                         }
[10:20:16.243]                         if (!has_future || version < "1.8.0") {
[10:20:16.243]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:16.243]                             "", base::R.version$version.string), 
[10:20:16.243]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:16.243]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:16.243]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:16.243]                               "release", "version")], collapse = " "), 
[10:20:16.243]                             hostname = base::Sys.info()[["nodename"]])
[10:20:16.243]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:16.243]                             info)
[10:20:16.243]                           info <- base::paste(info, collapse = "; ")
[10:20:16.243]                           if (!has_future) {
[10:20:16.243]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:16.243]                               info)
[10:20:16.243]                           }
[10:20:16.243]                           else {
[10:20:16.243]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:16.243]                               info, version)
[10:20:16.243]                           }
[10:20:16.243]                           base::stop(msg)
[10:20:16.243]                         }
[10:20:16.243]                       })
[10:20:16.243]                     }
[10:20:16.243]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:16.243]                     base::options(mc.cores = 1L)
[10:20:16.243]                   }
[10:20:16.243]                   ...future.strategy.old <- future::plan("list")
[10:20:16.243]                   options(future.plan = NULL)
[10:20:16.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:16.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:16.243]                 }
[10:20:16.243]                 ...future.workdir <- getwd()
[10:20:16.243]             }
[10:20:16.243]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:16.243]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:16.243]         }
[10:20:16.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:16.243]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:16.243]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:16.243]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:16.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:16.243]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:16.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:16.243]             base::names(...future.oldOptions))
[10:20:16.243]     }
[10:20:16.243]     if (FALSE) {
[10:20:16.243]     }
[10:20:16.243]     else {
[10:20:16.243]         if (FALSE) {
[10:20:16.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:16.243]                 open = "w")
[10:20:16.243]         }
[10:20:16.243]         else {
[10:20:16.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:16.243]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:16.243]         }
[10:20:16.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:16.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:16.243]             base::sink(type = "output", split = FALSE)
[10:20:16.243]             base::close(...future.stdout)
[10:20:16.243]         }, add = TRUE)
[10:20:16.243]     }
[10:20:16.243]     ...future.frame <- base::sys.nframe()
[10:20:16.243]     ...future.conditions <- base::list()
[10:20:16.243]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:16.243]     if (FALSE) {
[10:20:16.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:16.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:16.243]     }
[10:20:16.243]     ...future.result <- base::tryCatch({
[10:20:16.243]         base::withCallingHandlers({
[10:20:16.243]             ...future.value <- base::withVisible(base::local({
[10:20:16.243]                 withCallingHandlers({
[10:20:16.243]                   {
[10:20:16.243]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:16.243]                     if (!identical(...future.globals.maxSize.org, 
[10:20:16.243]                       ...future.globals.maxSize)) {
[10:20:16.243]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:16.243]                       on.exit(options(oopts), add = TRUE)
[10:20:16.243]                     }
[10:20:16.243]                     {
[10:20:16.243]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:16.243]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:20:16.243]                         USE.NAMES = FALSE)
[10:20:16.243]                       do.call(mapply, args = args)
[10:20:16.243]                     }
[10:20:16.243]                   }
[10:20:16.243]                 }, immediateCondition = function(cond) {
[10:20:16.243]                   save_rds <- function (object, pathname, ...) 
[10:20:16.243]                   {
[10:20:16.243]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:20:16.243]                     if (file_test("-f", pathname_tmp)) {
[10:20:16.243]                       fi_tmp <- file.info(pathname_tmp)
[10:20:16.243]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:20:16.243]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:16.243]                         fi_tmp[["mtime"]])
[10:20:16.243]                     }
[10:20:16.243]                     tryCatch({
[10:20:16.243]                       saveRDS(object, file = pathname_tmp, ...)
[10:20:16.243]                     }, error = function(ex) {
[10:20:16.243]                       msg <- conditionMessage(ex)
[10:20:16.243]                       fi_tmp <- file.info(pathname_tmp)
[10:20:16.243]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:20:16.243]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:16.243]                         fi_tmp[["mtime"]], msg)
[10:20:16.243]                       ex$message <- msg
[10:20:16.243]                       stop(ex)
[10:20:16.243]                     })
[10:20:16.243]                     stopifnot(file_test("-f", pathname_tmp))
[10:20:16.243]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:20:16.243]                     if (!res || file_test("-f", pathname_tmp)) {
[10:20:16.243]                       fi_tmp <- file.info(pathname_tmp)
[10:20:16.243]                       fi <- file.info(pathname)
[10:20:16.243]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:20:16.243]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:16.243]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:20:16.243]                         fi[["size"]], fi[["mtime"]])
[10:20:16.243]                       stop(msg)
[10:20:16.243]                     }
[10:20:16.243]                     invisible(pathname)
[10:20:16.243]                   }
[10:20:16.243]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:20:16.243]                     rootPath = tempdir()) 
[10:20:16.243]                   {
[10:20:16.243]                     obj <- list(time = Sys.time(), condition = cond)
[10:20:16.243]                     file <- tempfile(pattern = class(cond)[1], 
[10:20:16.243]                       tmpdir = path, fileext = ".rds")
[10:20:16.243]                     save_rds(obj, file)
[10:20:16.243]                   }
[10:20:16.243]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8Z8Jdg/.future/immediateConditions")
[10:20:16.243]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:16.243]                   {
[10:20:16.243]                     inherits <- base::inherits
[10:20:16.243]                     invokeRestart <- base::invokeRestart
[10:20:16.243]                     is.null <- base::is.null
[10:20:16.243]                     muffled <- FALSE
[10:20:16.243]                     if (inherits(cond, "message")) {
[10:20:16.243]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:16.243]                       if (muffled) 
[10:20:16.243]                         invokeRestart("muffleMessage")
[10:20:16.243]                     }
[10:20:16.243]                     else if (inherits(cond, "warning")) {
[10:20:16.243]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:16.243]                       if (muffled) 
[10:20:16.243]                         invokeRestart("muffleWarning")
[10:20:16.243]                     }
[10:20:16.243]                     else if (inherits(cond, "condition")) {
[10:20:16.243]                       if (!is.null(pattern)) {
[10:20:16.243]                         computeRestarts <- base::computeRestarts
[10:20:16.243]                         grepl <- base::grepl
[10:20:16.243]                         restarts <- computeRestarts(cond)
[10:20:16.243]                         for (restart in restarts) {
[10:20:16.243]                           name <- restart$name
[10:20:16.243]                           if (is.null(name)) 
[10:20:16.243]                             next
[10:20:16.243]                           if (!grepl(pattern, name)) 
[10:20:16.243]                             next
[10:20:16.243]                           invokeRestart(restart)
[10:20:16.243]                           muffled <- TRUE
[10:20:16.243]                           break
[10:20:16.243]                         }
[10:20:16.243]                       }
[10:20:16.243]                     }
[10:20:16.243]                     invisible(muffled)
[10:20:16.243]                   }
[10:20:16.243]                   muffleCondition(cond)
[10:20:16.243]                 })
[10:20:16.243]             }))
[10:20:16.243]             future::FutureResult(value = ...future.value$value, 
[10:20:16.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:16.243]                   ...future.rng), globalenv = if (FALSE) 
[10:20:16.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:16.243]                     ...future.globalenv.names))
[10:20:16.243]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:16.243]         }, condition = base::local({
[10:20:16.243]             c <- base::c
[10:20:16.243]             inherits <- base::inherits
[10:20:16.243]             invokeRestart <- base::invokeRestart
[10:20:16.243]             length <- base::length
[10:20:16.243]             list <- base::list
[10:20:16.243]             seq.int <- base::seq.int
[10:20:16.243]             signalCondition <- base::signalCondition
[10:20:16.243]             sys.calls <- base::sys.calls
[10:20:16.243]             `[[` <- base::`[[`
[10:20:16.243]             `+` <- base::`+`
[10:20:16.243]             `<<-` <- base::`<<-`
[10:20:16.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:16.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:16.243]                   3L)]
[10:20:16.243]             }
[10:20:16.243]             function(cond) {
[10:20:16.243]                 is_error <- inherits(cond, "error")
[10:20:16.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:16.243]                   NULL)
[10:20:16.243]                 if (is_error) {
[10:20:16.243]                   sessionInformation <- function() {
[10:20:16.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:16.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:16.243]                       search = base::search(), system = base::Sys.info())
[10:20:16.243]                   }
[10:20:16.243]                   ...future.conditions[[length(...future.conditions) + 
[10:20:16.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:16.243]                     cond$call), session = sessionInformation(), 
[10:20:16.243]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:16.243]                   signalCondition(cond)
[10:20:16.243]                 }
[10:20:16.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:16.243]                 "immediateCondition"))) {
[10:20:16.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:16.243]                   ...future.conditions[[length(...future.conditions) + 
[10:20:16.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:16.243]                   if (TRUE && !signal) {
[10:20:16.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:16.243]                     {
[10:20:16.243]                       inherits <- base::inherits
[10:20:16.243]                       invokeRestart <- base::invokeRestart
[10:20:16.243]                       is.null <- base::is.null
[10:20:16.243]                       muffled <- FALSE
[10:20:16.243]                       if (inherits(cond, "message")) {
[10:20:16.243]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:16.243]                         if (muffled) 
[10:20:16.243]                           invokeRestart("muffleMessage")
[10:20:16.243]                       }
[10:20:16.243]                       else if (inherits(cond, "warning")) {
[10:20:16.243]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:16.243]                         if (muffled) 
[10:20:16.243]                           invokeRestart("muffleWarning")
[10:20:16.243]                       }
[10:20:16.243]                       else if (inherits(cond, "condition")) {
[10:20:16.243]                         if (!is.null(pattern)) {
[10:20:16.243]                           computeRestarts <- base::computeRestarts
[10:20:16.243]                           grepl <- base::grepl
[10:20:16.243]                           restarts <- computeRestarts(cond)
[10:20:16.243]                           for (restart in restarts) {
[10:20:16.243]                             name <- restart$name
[10:20:16.243]                             if (is.null(name)) 
[10:20:16.243]                               next
[10:20:16.243]                             if (!grepl(pattern, name)) 
[10:20:16.243]                               next
[10:20:16.243]                             invokeRestart(restart)
[10:20:16.243]                             muffled <- TRUE
[10:20:16.243]                             break
[10:20:16.243]                           }
[10:20:16.243]                         }
[10:20:16.243]                       }
[10:20:16.243]                       invisible(muffled)
[10:20:16.243]                     }
[10:20:16.243]                     muffleCondition(cond, pattern = "^muffle")
[10:20:16.243]                   }
[10:20:16.243]                 }
[10:20:16.243]                 else {
[10:20:16.243]                   if (TRUE) {
[10:20:16.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:16.243]                     {
[10:20:16.243]                       inherits <- base::inherits
[10:20:16.243]                       invokeRestart <- base::invokeRestart
[10:20:16.243]                       is.null <- base::is.null
[10:20:16.243]                       muffled <- FALSE
[10:20:16.243]                       if (inherits(cond, "message")) {
[10:20:16.243]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:16.243]                         if (muffled) 
[10:20:16.243]                           invokeRestart("muffleMessage")
[10:20:16.243]                       }
[10:20:16.243]                       else if (inherits(cond, "warning")) {
[10:20:16.243]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:16.243]                         if (muffled) 
[10:20:16.243]                           invokeRestart("muffleWarning")
[10:20:16.243]                       }
[10:20:16.243]                       else if (inherits(cond, "condition")) {
[10:20:16.243]                         if (!is.null(pattern)) {
[10:20:16.243]                           computeRestarts <- base::computeRestarts
[10:20:16.243]                           grepl <- base::grepl
[10:20:16.243]                           restarts <- computeRestarts(cond)
[10:20:16.243]                           for (restart in restarts) {
[10:20:16.243]                             name <- restart$name
[10:20:16.243]                             if (is.null(name)) 
[10:20:16.243]                               next
[10:20:16.243]                             if (!grepl(pattern, name)) 
[10:20:16.243]                               next
[10:20:16.243]                             invokeRestart(restart)
[10:20:16.243]                             muffled <- TRUE
[10:20:16.243]                             break
[10:20:16.243]                           }
[10:20:16.243]                         }
[10:20:16.243]                       }
[10:20:16.243]                       invisible(muffled)
[10:20:16.243]                     }
[10:20:16.243]                     muffleCondition(cond, pattern = "^muffle")
[10:20:16.243]                   }
[10:20:16.243]                 }
[10:20:16.243]             }
[10:20:16.243]         }))
[10:20:16.243]     }, error = function(ex) {
[10:20:16.243]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:16.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:16.243]                 ...future.rng), started = ...future.startTime, 
[10:20:16.243]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:16.243]             version = "1.8"), class = "FutureResult")
[10:20:16.243]     }, finally = {
[10:20:16.243]         if (!identical(...future.workdir, getwd())) 
[10:20:16.243]             setwd(...future.workdir)
[10:20:16.243]         {
[10:20:16.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:16.243]                 ...future.oldOptions$nwarnings <- NULL
[10:20:16.243]             }
[10:20:16.243]             base::options(...future.oldOptions)
[10:20:16.243]             if (.Platform$OS.type == "windows") {
[10:20:16.243]                 old_names <- names(...future.oldEnvVars)
[10:20:16.243]                 envs <- base::Sys.getenv()
[10:20:16.243]                 names <- names(envs)
[10:20:16.243]                 common <- intersect(names, old_names)
[10:20:16.243]                 added <- setdiff(names, old_names)
[10:20:16.243]                 removed <- setdiff(old_names, names)
[10:20:16.243]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:16.243]                   envs[common]]
[10:20:16.243]                 NAMES <- toupper(changed)
[10:20:16.243]                 args <- list()
[10:20:16.243]                 for (kk in seq_along(NAMES)) {
[10:20:16.243]                   name <- changed[[kk]]
[10:20:16.243]                   NAME <- NAMES[[kk]]
[10:20:16.243]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:16.243]                     next
[10:20:16.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:16.243]                 }
[10:20:16.243]                 NAMES <- toupper(added)
[10:20:16.243]                 for (kk in seq_along(NAMES)) {
[10:20:16.243]                   name <- added[[kk]]
[10:20:16.243]                   NAME <- NAMES[[kk]]
[10:20:16.243]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:16.243]                     next
[10:20:16.243]                   args[[name]] <- ""
[10:20:16.243]                 }
[10:20:16.243]                 NAMES <- toupper(removed)
[10:20:16.243]                 for (kk in seq_along(NAMES)) {
[10:20:16.243]                   name <- removed[[kk]]
[10:20:16.243]                   NAME <- NAMES[[kk]]
[10:20:16.243]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:16.243]                     next
[10:20:16.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:16.243]                 }
[10:20:16.243]                 if (length(args) > 0) 
[10:20:16.243]                   base::do.call(base::Sys.setenv, args = args)
[10:20:16.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:16.243]             }
[10:20:16.243]             else {
[10:20:16.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:16.243]             }
[10:20:16.243]             {
[10:20:16.243]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:16.243]                   0L) {
[10:20:16.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:16.243]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:16.243]                   base::options(opts)
[10:20:16.243]                 }
[10:20:16.243]                 {
[10:20:16.243]                   {
[10:20:16.243]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:16.243]                     NULL
[10:20:16.243]                   }
[10:20:16.243]                   options(future.plan = NULL)
[10:20:16.243]                   if (is.na(NA_character_)) 
[10:20:16.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:16.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:16.243]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:16.243]                     .init = FALSE)
[10:20:16.243]                 }
[10:20:16.243]             }
[10:20:16.243]         }
[10:20:16.243]     })
[10:20:16.243]     if (TRUE) {
[10:20:16.243]         base::sink(type = "output", split = FALSE)
[10:20:16.243]         if (FALSE) {
[10:20:16.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:16.243]         }
[10:20:16.243]         else {
[10:20:16.243]             ...future.result["stdout"] <- base::list(NULL)
[10:20:16.243]         }
[10:20:16.243]         base::close(...future.stdout)
[10:20:16.243]         ...future.stdout <- NULL
[10:20:16.243]     }
[10:20:16.243]     ...future.result$conditions <- ...future.conditions
[10:20:16.243]     ...future.result$finished <- base::Sys.time()
[10:20:16.243]     ...future.result
[10:20:16.243] }
[10:20:16.246] assign_globals() ...
[10:20:16.246] List of 5
[10:20:16.246]  $ ...future.FUN            :function (x, y)  
[10:20:16.246]  $ MoreArgs                 : NULL
[10:20:16.246]  $ ...future.elements_ii    :List of 2
[10:20:16.246]   ..$ :List of 1
[10:20:16.246]   .. ..$ : int 0
[10:20:16.246]   ..$ :List of 1
[10:20:16.246]   .. ..$ : int 1
[10:20:16.246]  $ ...future.seeds_ii       : NULL
[10:20:16.246]  $ ...future.globals.maxSize: NULL
[10:20:16.246]  - attr(*, "where")=List of 5
[10:20:16.246]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:16.246]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:20:16.246]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:16.246]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:16.246]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:16.246]  - attr(*, "resolved")= logi FALSE
[10:20:16.246]  - attr(*, "total_size")= num 1218
[10:20:16.246]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:16.246]  - attr(*, "already-done")= logi TRUE
[10:20:16.253] - reassign environment for ‘...future.FUN’
[10:20:16.253] - copied ‘...future.FUN’ to environment
[10:20:16.253] - copied ‘MoreArgs’ to environment
[10:20:16.253] - copied ‘...future.elements_ii’ to environment
[10:20:16.254] - copied ‘...future.seeds_ii’ to environment
[10:20:16.254] - copied ‘...future.globals.maxSize’ to environment
[10:20:16.254] assign_globals() ... done
[10:20:16.254] requestCore(): workers = 2
[10:20:16.256] MulticoreFuture started
[10:20:16.257] - Launch lazy future ... done
[10:20:16.257] run() for ‘MulticoreFuture’ ... done
[10:20:16.257] Created future:
[10:20:16.257] plan(): Setting new future strategy stack:
[10:20:16.258] List of future strategies:
[10:20:16.258] 1. sequential:
[10:20:16.258]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:16.258]    - tweaked: FALSE
[10:20:16.258]    - call: NULL
[10:20:16.259] plan(): nbrOfWorkers() = 1
[10:20:16.261] plan(): Setting new future strategy stack:
[10:20:16.261] List of future strategies:
[10:20:16.261] 1. multicore:
[10:20:16.261]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:20:16.261]    - tweaked: FALSE
[10:20:16.261]    - call: plan(strategy)
[10:20:16.264] plan(): nbrOfWorkers() = 2
[10:20:16.257] MulticoreFuture:
[10:20:16.257] Label: ‘future_mapply-2’
[10:20:16.257] Expression:
[10:20:16.257] {
[10:20:16.257]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:16.257]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:16.257]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:16.257]         on.exit(options(oopts), add = TRUE)
[10:20:16.257]     }
[10:20:16.257]     {
[10:20:16.257]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:16.257]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:20:16.257]         do.call(mapply, args = args)
[10:20:16.257]     }
[10:20:16.257] }
[10:20:16.257] Lazy evaluation: FALSE
[10:20:16.257] Asynchronous evaluation: TRUE
[10:20:16.257] Local evaluation: TRUE
[10:20:16.257] Environment: R_GlobalEnv
[10:20:16.257] Capture standard output: FALSE
[10:20:16.257] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:16.257] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:16.257] Packages: <none>
[10:20:16.257] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:16.257] Resolved: TRUE
[10:20:16.257] Value: <not collected>
[10:20:16.257] Conditions captured: <none>
[10:20:16.257] Early signaling: FALSE
[10:20:16.257] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:16.257] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:16.265] Chunk #2 of 2 ... DONE
[10:20:16.265] Launching 2 futures (chunks) ... DONE
[10:20:16.266] Resolving 2 futures (chunks) ...
[10:20:16.266] resolve() on list ...
[10:20:16.266]  recursive: 0
[10:20:16.266]  length: 2
[10:20:16.266] 
[10:20:16.277] Future #2
[10:20:16.277] result() for MulticoreFuture ...
[10:20:16.278] result() for MulticoreFuture ...
[10:20:16.278] result() for MulticoreFuture ... done
[10:20:16.278] result() for MulticoreFuture ... done
[10:20:16.278] result() for MulticoreFuture ...
[10:20:16.279] result() for MulticoreFuture ... done
[10:20:16.279] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:20:16.279] - nx: 2
[10:20:16.279] - relay: TRUE
[10:20:16.279] - stdout: TRUE
[10:20:16.279] - signal: TRUE
[10:20:16.279] - resignal: FALSE
[10:20:16.280] - force: TRUE
[10:20:16.280] - relayed: [n=2] FALSE, FALSE
[10:20:16.280] - queued futures: [n=2] FALSE, FALSE
[10:20:16.280]  - until=1
[10:20:16.280]  - relaying element #1
[10:20:16.280] - relayed: [n=2] FALSE, FALSE
[10:20:16.280] - queued futures: [n=2] FALSE, TRUE
[10:20:16.281] signalConditionsASAP(NULL, pos=2) ... done
[10:20:16.281]  length: 1 (resolved future 2)
[10:20:16.716] plan(): Setting new future strategy stack:
[10:20:16.717] List of future strategies:
[10:20:16.717] 1. multicore:
[10:20:16.717]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:20:16.717]    - tweaked: FALSE
[10:20:16.717]    - call: plan(strategy)
[10:20:16.720] plan(): nbrOfWorkers() = 2
[10:20:16.720] Future #1
[10:20:16.723] result() for MulticoreFuture ...
[10:20:16.724] result() for MulticoreFuture ...
[10:20:16.724] result() for MulticoreFuture ... done
[10:20:16.724] result() for MulticoreFuture ... done
[10:20:16.725] result() for MulticoreFuture ...
[10:20:16.725] result() for MulticoreFuture ... done
[10:20:16.725] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:20:16.725] - nx: 2
[10:20:16.725] - relay: TRUE
[10:20:16.726] - stdout: TRUE
[10:20:16.726] - signal: TRUE
[10:20:16.726] - resignal: FALSE
[10:20:16.726] - force: TRUE
[10:20:16.726] - relayed: [n=2] FALSE, FALSE
[10:20:16.726] - queued futures: [n=2] FALSE, TRUE
[10:20:16.726]  - until=1
[10:20:16.727]  - relaying element #1
[10:20:16.727] result() for MulticoreFuture ...
[10:20:16.727] result() for MulticoreFuture ... done
[10:20:16.727] result() for MulticoreFuture ...
[10:20:16.727] result() for MulticoreFuture ... done
[10:20:16.727] result() for MulticoreFuture ...
[10:20:16.728] result() for MulticoreFuture ... done
[10:20:16.728] result() for MulticoreFuture ...
[10:20:16.728] result() for MulticoreFuture ... done
[10:20:16.728] - relayed: [n=2] TRUE, FALSE
[10:20:16.728] - queued futures: [n=2] TRUE, TRUE
[10:20:16.728] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:20:16.728]  length: 0 (resolved future 1)
[10:20:16.728] Relaying remaining futures
[10:20:16.728] signalConditionsASAP(NULL, pos=0) ...
[10:20:16.729] - nx: 2
[10:20:16.729] - relay: TRUE
[10:20:16.729] - stdout: TRUE
[10:20:16.729] - signal: TRUE
[10:20:16.729] - resignal: FALSE
[10:20:16.729] - force: TRUE
[10:20:16.729] - relayed: [n=2] TRUE, FALSE
[10:20:16.729] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:20:16.729]  - relaying element #2
[10:20:16.730] result() for MulticoreFuture ...
[10:20:16.730] result() for MulticoreFuture ... done
[10:20:16.730] result() for MulticoreFuture ...
[10:20:16.730] result() for MulticoreFuture ... done
[10:20:16.730] result() for MulticoreFuture ...
[10:20:16.730] result() for MulticoreFuture ... done
[10:20:16.730] result() for MulticoreFuture ...
[10:20:16.730] result() for MulticoreFuture ... done
[10:20:16.730] - relayed: [n=2] TRUE, TRUE
[10:20:16.730] - queued futures: [n=2] TRUE, TRUE
[10:20:16.731] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[10:20:16.731] resolve() on list ... DONE
[10:20:16.731] result() for MulticoreFuture ...
[10:20:16.731] result() for MulticoreFuture ... done
[10:20:16.731] result() for MulticoreFuture ...
[10:20:16.731] result() for MulticoreFuture ... done
[10:20:16.731] result() for MulticoreFuture ...
[10:20:16.731] result() for MulticoreFuture ... done
[10:20:16.731] result() for MulticoreFuture ...
[10:20:16.732] result() for MulticoreFuture ... done
[10:20:16.732]  - Number of value chunks collected: 2
[10:20:16.732] Resolving 2 futures (chunks) ... DONE
[10:20:16.732] Reducing values from 2 chunks ...
[10:20:16.732]  - Number of values collected after concatenation: 2
[10:20:16.732]  - Number of values expected: 2
[10:20:16.732] Reducing values from 2 chunks ... DONE
[10:20:16.732] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[10:20:16.733] future_mapply() ...
[10:20:16.735] Number of chunks: 2
[10:20:16.735] getGlobalsAndPackagesXApply() ...
[10:20:16.735]  - future.globals: TRUE
[10:20:16.735] getGlobalsAndPackages() ...
[10:20:16.736] Searching for globals...
[10:20:16.739] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:20:16.739] Searching for globals ... DONE
[10:20:16.739] Resolving globals: FALSE
[10:20:16.739] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[10:20:16.740] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[10:20:16.740] - globals: [1] ‘FUN’
[10:20:16.740] 
[10:20:16.740] getGlobalsAndPackages() ... DONE
[10:20:16.740]  - globals found/used: [n=1] ‘FUN’
[10:20:16.740]  - needed namespaces: [n=0] 
[10:20:16.740] Finding globals ... DONE
[10:20:16.741] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:20:16.741] List of 2
[10:20:16.741]  $ ...future.FUN:function (x, y)  
[10:20:16.741]  $ MoreArgs     : NULL
[10:20:16.741]  - attr(*, "where")=List of 2
[10:20:16.741]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:16.741]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:20:16.741]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:16.741]  - attr(*, "resolved")= logi FALSE
[10:20:16.741]  - attr(*, "total_size")= num NA
[10:20:16.744] Packages to be attached in all futures: [n=0] 
[10:20:16.744] getGlobalsAndPackagesXApply() ... DONE
[10:20:16.744] Number of futures (= number of chunks): 2
[10:20:16.744] Launching 2 futures (chunks) ...
[10:20:16.744] Chunk #1 of 2 ...
[10:20:16.744]  - Finding globals in '...' for chunk #1 ...
[10:20:16.744] getGlobalsAndPackages() ...
[10:20:16.744] Searching for globals...
[10:20:16.745] 
[10:20:16.745] Searching for globals ... DONE
[10:20:16.745] - globals: [0] <none>
[10:20:16.745] getGlobalsAndPackages() ... DONE
[10:20:16.745]    + additional globals found: [n=0] 
[10:20:16.745]    + additional namespaces needed: [n=0] 
[10:20:16.745]  - Finding globals in '...' for chunk #1 ... DONE
[10:20:16.745]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:16.745]  - seeds: <none>
[10:20:16.746]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:16.746] getGlobalsAndPackages() ...
[10:20:16.746] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:16.746] Resolving globals: FALSE
[10:20:16.746] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[10:20:16.747] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:20:16.747] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:16.747] 
[10:20:16.747] getGlobalsAndPackages() ... DONE
[10:20:16.747] run() for ‘Future’ ...
[10:20:16.747] - state: ‘created’
[10:20:16.748] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:20:16.749] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:16.749] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:20:16.750]   - Field: ‘label’
[10:20:16.750]   - Field: ‘local’
[10:20:16.750]   - Field: ‘owner’
[10:20:16.750]   - Field: ‘envir’
[10:20:16.750]   - Field: ‘workers’
[10:20:16.752]   - Field: ‘packages’
[10:20:16.752]   - Field: ‘gc’
[10:20:16.752]   - Field: ‘job’
[10:20:16.752]   - Field: ‘conditions’
[10:20:16.752]   - Field: ‘expr’
[10:20:16.752]   - Field: ‘uuid’
[10:20:16.752]   - Field: ‘seed’
[10:20:16.752]   - Field: ‘version’
[10:20:16.753]   - Field: ‘result’
[10:20:16.753]   - Field: ‘asynchronous’
[10:20:16.753]   - Field: ‘calls’
[10:20:16.753]   - Field: ‘globals’
[10:20:16.753]   - Field: ‘stdout’
[10:20:16.753]   - Field: ‘earlySignal’
[10:20:16.753]   - Field: ‘lazy’
[10:20:16.753]   - Field: ‘state’
[10:20:16.753] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:20:16.753] - Launch lazy future ...
[10:20:16.754] Packages needed by the future expression (n = 0): <none>
[10:20:16.754] Packages needed by future strategies (n = 0): <none>
[10:20:16.754] {
[10:20:16.754]     {
[10:20:16.754]         {
[10:20:16.754]             ...future.startTime <- base::Sys.time()
[10:20:16.754]             {
[10:20:16.754]                 {
[10:20:16.754]                   {
[10:20:16.754]                     {
[10:20:16.754]                       base::local({
[10:20:16.754]                         has_future <- base::requireNamespace("future", 
[10:20:16.754]                           quietly = TRUE)
[10:20:16.754]                         if (has_future) {
[10:20:16.754]                           ns <- base::getNamespace("future")
[10:20:16.754]                           version <- ns[[".package"]][["version"]]
[10:20:16.754]                           if (is.null(version)) 
[10:20:16.754]                             version <- utils::packageVersion("future")
[10:20:16.754]                         }
[10:20:16.754]                         else {
[10:20:16.754]                           version <- NULL
[10:20:16.754]                         }
[10:20:16.754]                         if (!has_future || version < "1.8.0") {
[10:20:16.754]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:16.754]                             "", base::R.version$version.string), 
[10:20:16.754]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:16.754]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:16.754]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:16.754]                               "release", "version")], collapse = " "), 
[10:20:16.754]                             hostname = base::Sys.info()[["nodename"]])
[10:20:16.754]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:16.754]                             info)
[10:20:16.754]                           info <- base::paste(info, collapse = "; ")
[10:20:16.754]                           if (!has_future) {
[10:20:16.754]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:16.754]                               info)
[10:20:16.754]                           }
[10:20:16.754]                           else {
[10:20:16.754]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:16.754]                               info, version)
[10:20:16.754]                           }
[10:20:16.754]                           base::stop(msg)
[10:20:16.754]                         }
[10:20:16.754]                       })
[10:20:16.754]                     }
[10:20:16.754]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:16.754]                     base::options(mc.cores = 1L)
[10:20:16.754]                   }
[10:20:16.754]                   ...future.strategy.old <- future::plan("list")
[10:20:16.754]                   options(future.plan = NULL)
[10:20:16.754]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:16.754]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:16.754]                 }
[10:20:16.754]                 ...future.workdir <- getwd()
[10:20:16.754]             }
[10:20:16.754]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:16.754]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:16.754]         }
[10:20:16.754]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:16.754]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:16.754]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:16.754]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:16.754]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:16.754]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:16.754]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:16.754]             base::names(...future.oldOptions))
[10:20:16.754]     }
[10:20:16.754]     if (FALSE) {
[10:20:16.754]     }
[10:20:16.754]     else {
[10:20:16.754]         if (TRUE) {
[10:20:16.754]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:16.754]                 open = "w")
[10:20:16.754]         }
[10:20:16.754]         else {
[10:20:16.754]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:16.754]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:16.754]         }
[10:20:16.754]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:16.754]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:16.754]             base::sink(type = "output", split = FALSE)
[10:20:16.754]             base::close(...future.stdout)
[10:20:16.754]         }, add = TRUE)
[10:20:16.754]     }
[10:20:16.754]     ...future.frame <- base::sys.nframe()
[10:20:16.754]     ...future.conditions <- base::list()
[10:20:16.754]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:16.754]     if (FALSE) {
[10:20:16.754]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:16.754]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:16.754]     }
[10:20:16.754]     ...future.result <- base::tryCatch({
[10:20:16.754]         base::withCallingHandlers({
[10:20:16.754]             ...future.value <- base::withVisible(base::local({
[10:20:16.754]                 withCallingHandlers({
[10:20:16.754]                   {
[10:20:16.754]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:16.754]                     if (!identical(...future.globals.maxSize.org, 
[10:20:16.754]                       ...future.globals.maxSize)) {
[10:20:16.754]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:16.754]                       on.exit(options(oopts), add = TRUE)
[10:20:16.754]                     }
[10:20:16.754]                     {
[10:20:16.754]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:16.754]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:20:16.754]                         USE.NAMES = FALSE)
[10:20:16.754]                       do.call(mapply, args = args)
[10:20:16.754]                     }
[10:20:16.754]                   }
[10:20:16.754]                 }, immediateCondition = function(cond) {
[10:20:16.754]                   save_rds <- function (object, pathname, ...) 
[10:20:16.754]                   {
[10:20:16.754]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:20:16.754]                     if (file_test("-f", pathname_tmp)) {
[10:20:16.754]                       fi_tmp <- file.info(pathname_tmp)
[10:20:16.754]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:20:16.754]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:16.754]                         fi_tmp[["mtime"]])
[10:20:16.754]                     }
[10:20:16.754]                     tryCatch({
[10:20:16.754]                       saveRDS(object, file = pathname_tmp, ...)
[10:20:16.754]                     }, error = function(ex) {
[10:20:16.754]                       msg <- conditionMessage(ex)
[10:20:16.754]                       fi_tmp <- file.info(pathname_tmp)
[10:20:16.754]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:20:16.754]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:16.754]                         fi_tmp[["mtime"]], msg)
[10:20:16.754]                       ex$message <- msg
[10:20:16.754]                       stop(ex)
[10:20:16.754]                     })
[10:20:16.754]                     stopifnot(file_test("-f", pathname_tmp))
[10:20:16.754]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:20:16.754]                     if (!res || file_test("-f", pathname_tmp)) {
[10:20:16.754]                       fi_tmp <- file.info(pathname_tmp)
[10:20:16.754]                       fi <- file.info(pathname)
[10:20:16.754]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:20:16.754]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:16.754]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:20:16.754]                         fi[["size"]], fi[["mtime"]])
[10:20:16.754]                       stop(msg)
[10:20:16.754]                     }
[10:20:16.754]                     invisible(pathname)
[10:20:16.754]                   }
[10:20:16.754]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:20:16.754]                     rootPath = tempdir()) 
[10:20:16.754]                   {
[10:20:16.754]                     obj <- list(time = Sys.time(), condition = cond)
[10:20:16.754]                     file <- tempfile(pattern = class(cond)[1], 
[10:20:16.754]                       tmpdir = path, fileext = ".rds")
[10:20:16.754]                     save_rds(obj, file)
[10:20:16.754]                   }
[10:20:16.754]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8Z8Jdg/.future/immediateConditions")
[10:20:16.754]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:16.754]                   {
[10:20:16.754]                     inherits <- base::inherits
[10:20:16.754]                     invokeRestart <- base::invokeRestart
[10:20:16.754]                     is.null <- base::is.null
[10:20:16.754]                     muffled <- FALSE
[10:20:16.754]                     if (inherits(cond, "message")) {
[10:20:16.754]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:16.754]                       if (muffled) 
[10:20:16.754]                         invokeRestart("muffleMessage")
[10:20:16.754]                     }
[10:20:16.754]                     else if (inherits(cond, "warning")) {
[10:20:16.754]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:16.754]                       if (muffled) 
[10:20:16.754]                         invokeRestart("muffleWarning")
[10:20:16.754]                     }
[10:20:16.754]                     else if (inherits(cond, "condition")) {
[10:20:16.754]                       if (!is.null(pattern)) {
[10:20:16.754]                         computeRestarts <- base::computeRestarts
[10:20:16.754]                         grepl <- base::grepl
[10:20:16.754]                         restarts <- computeRestarts(cond)
[10:20:16.754]                         for (restart in restarts) {
[10:20:16.754]                           name <- restart$name
[10:20:16.754]                           if (is.null(name)) 
[10:20:16.754]                             next
[10:20:16.754]                           if (!grepl(pattern, name)) 
[10:20:16.754]                             next
[10:20:16.754]                           invokeRestart(restart)
[10:20:16.754]                           muffled <- TRUE
[10:20:16.754]                           break
[10:20:16.754]                         }
[10:20:16.754]                       }
[10:20:16.754]                     }
[10:20:16.754]                     invisible(muffled)
[10:20:16.754]                   }
[10:20:16.754]                   muffleCondition(cond)
[10:20:16.754]                 })
[10:20:16.754]             }))
[10:20:16.754]             future::FutureResult(value = ...future.value$value, 
[10:20:16.754]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:16.754]                   ...future.rng), globalenv = if (FALSE) 
[10:20:16.754]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:16.754]                     ...future.globalenv.names))
[10:20:16.754]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:16.754]         }, condition = base::local({
[10:20:16.754]             c <- base::c
[10:20:16.754]             inherits <- base::inherits
[10:20:16.754]             invokeRestart <- base::invokeRestart
[10:20:16.754]             length <- base::length
[10:20:16.754]             list <- base::list
[10:20:16.754]             seq.int <- base::seq.int
[10:20:16.754]             signalCondition <- base::signalCondition
[10:20:16.754]             sys.calls <- base::sys.calls
[10:20:16.754]             `[[` <- base::`[[`
[10:20:16.754]             `+` <- base::`+`
[10:20:16.754]             `<<-` <- base::`<<-`
[10:20:16.754]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:16.754]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:16.754]                   3L)]
[10:20:16.754]             }
[10:20:16.754]             function(cond) {
[10:20:16.754]                 is_error <- inherits(cond, "error")
[10:20:16.754]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:16.754]                   NULL)
[10:20:16.754]                 if (is_error) {
[10:20:16.754]                   sessionInformation <- function() {
[10:20:16.754]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:16.754]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:16.754]                       search = base::search(), system = base::Sys.info())
[10:20:16.754]                   }
[10:20:16.754]                   ...future.conditions[[length(...future.conditions) + 
[10:20:16.754]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:16.754]                     cond$call), session = sessionInformation(), 
[10:20:16.754]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:16.754]                   signalCondition(cond)
[10:20:16.754]                 }
[10:20:16.754]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:16.754]                 "immediateCondition"))) {
[10:20:16.754]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:16.754]                   ...future.conditions[[length(...future.conditions) + 
[10:20:16.754]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:16.754]                   if (TRUE && !signal) {
[10:20:16.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:16.754]                     {
[10:20:16.754]                       inherits <- base::inherits
[10:20:16.754]                       invokeRestart <- base::invokeRestart
[10:20:16.754]                       is.null <- base::is.null
[10:20:16.754]                       muffled <- FALSE
[10:20:16.754]                       if (inherits(cond, "message")) {
[10:20:16.754]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:16.754]                         if (muffled) 
[10:20:16.754]                           invokeRestart("muffleMessage")
[10:20:16.754]                       }
[10:20:16.754]                       else if (inherits(cond, "warning")) {
[10:20:16.754]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:16.754]                         if (muffled) 
[10:20:16.754]                           invokeRestart("muffleWarning")
[10:20:16.754]                       }
[10:20:16.754]                       else if (inherits(cond, "condition")) {
[10:20:16.754]                         if (!is.null(pattern)) {
[10:20:16.754]                           computeRestarts <- base::computeRestarts
[10:20:16.754]                           grepl <- base::grepl
[10:20:16.754]                           restarts <- computeRestarts(cond)
[10:20:16.754]                           for (restart in restarts) {
[10:20:16.754]                             name <- restart$name
[10:20:16.754]                             if (is.null(name)) 
[10:20:16.754]                               next
[10:20:16.754]                             if (!grepl(pattern, name)) 
[10:20:16.754]                               next
[10:20:16.754]                             invokeRestart(restart)
[10:20:16.754]                             muffled <- TRUE
[10:20:16.754]                             break
[10:20:16.754]                           }
[10:20:16.754]                         }
[10:20:16.754]                       }
[10:20:16.754]                       invisible(muffled)
[10:20:16.754]                     }
[10:20:16.754]                     muffleCondition(cond, pattern = "^muffle")
[10:20:16.754]                   }
[10:20:16.754]                 }
[10:20:16.754]                 else {
[10:20:16.754]                   if (TRUE) {
[10:20:16.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:16.754]                     {
[10:20:16.754]                       inherits <- base::inherits
[10:20:16.754]                       invokeRestart <- base::invokeRestart
[10:20:16.754]                       is.null <- base::is.null
[10:20:16.754]                       muffled <- FALSE
[10:20:16.754]                       if (inherits(cond, "message")) {
[10:20:16.754]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:16.754]                         if (muffled) 
[10:20:16.754]                           invokeRestart("muffleMessage")
[10:20:16.754]                       }
[10:20:16.754]                       else if (inherits(cond, "warning")) {
[10:20:16.754]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:16.754]                         if (muffled) 
[10:20:16.754]                           invokeRestart("muffleWarning")
[10:20:16.754]                       }
[10:20:16.754]                       else if (inherits(cond, "condition")) {
[10:20:16.754]                         if (!is.null(pattern)) {
[10:20:16.754]                           computeRestarts <- base::computeRestarts
[10:20:16.754]                           grepl <- base::grepl
[10:20:16.754]                           restarts <- computeRestarts(cond)
[10:20:16.754]                           for (restart in restarts) {
[10:20:16.754]                             name <- restart$name
[10:20:16.754]                             if (is.null(name)) 
[10:20:16.754]                               next
[10:20:16.754]                             if (!grepl(pattern, name)) 
[10:20:16.754]                               next
[10:20:16.754]                             invokeRestart(restart)
[10:20:16.754]                             muffled <- TRUE
[10:20:16.754]                             break
[10:20:16.754]                           }
[10:20:16.754]                         }
[10:20:16.754]                       }
[10:20:16.754]                       invisible(muffled)
[10:20:16.754]                     }
[10:20:16.754]                     muffleCondition(cond, pattern = "^muffle")
[10:20:16.754]                   }
[10:20:16.754]                 }
[10:20:16.754]             }
[10:20:16.754]         }))
[10:20:16.754]     }, error = function(ex) {
[10:20:16.754]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:16.754]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:16.754]                 ...future.rng), started = ...future.startTime, 
[10:20:16.754]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:16.754]             version = "1.8"), class = "FutureResult")
[10:20:16.754]     }, finally = {
[10:20:16.754]         if (!identical(...future.workdir, getwd())) 
[10:20:16.754]             setwd(...future.workdir)
[10:20:16.754]         {
[10:20:16.754]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:16.754]                 ...future.oldOptions$nwarnings <- NULL
[10:20:16.754]             }
[10:20:16.754]             base::options(...future.oldOptions)
[10:20:16.754]             if (.Platform$OS.type == "windows") {
[10:20:16.754]                 old_names <- names(...future.oldEnvVars)
[10:20:16.754]                 envs <- base::Sys.getenv()
[10:20:16.754]                 names <- names(envs)
[10:20:16.754]                 common <- intersect(names, old_names)
[10:20:16.754]                 added <- setdiff(names, old_names)
[10:20:16.754]                 removed <- setdiff(old_names, names)
[10:20:16.754]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:16.754]                   envs[common]]
[10:20:16.754]                 NAMES <- toupper(changed)
[10:20:16.754]                 args <- list()
[10:20:16.754]                 for (kk in seq_along(NAMES)) {
[10:20:16.754]                   name <- changed[[kk]]
[10:20:16.754]                   NAME <- NAMES[[kk]]
[10:20:16.754]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:16.754]                     next
[10:20:16.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:16.754]                 }
[10:20:16.754]                 NAMES <- toupper(added)
[10:20:16.754]                 for (kk in seq_along(NAMES)) {
[10:20:16.754]                   name <- added[[kk]]
[10:20:16.754]                   NAME <- NAMES[[kk]]
[10:20:16.754]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:16.754]                     next
[10:20:16.754]                   args[[name]] <- ""
[10:20:16.754]                 }
[10:20:16.754]                 NAMES <- toupper(removed)
[10:20:16.754]                 for (kk in seq_along(NAMES)) {
[10:20:16.754]                   name <- removed[[kk]]
[10:20:16.754]                   NAME <- NAMES[[kk]]
[10:20:16.754]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:16.754]                     next
[10:20:16.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:16.754]                 }
[10:20:16.754]                 if (length(args) > 0) 
[10:20:16.754]                   base::do.call(base::Sys.setenv, args = args)
[10:20:16.754]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:16.754]             }
[10:20:16.754]             else {
[10:20:16.754]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:16.754]             }
[10:20:16.754]             {
[10:20:16.754]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:16.754]                   0L) {
[10:20:16.754]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:16.754]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:16.754]                   base::options(opts)
[10:20:16.754]                 }
[10:20:16.754]                 {
[10:20:16.754]                   {
[10:20:16.754]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:16.754]                     NULL
[10:20:16.754]                   }
[10:20:16.754]                   options(future.plan = NULL)
[10:20:16.754]                   if (is.na(NA_character_)) 
[10:20:16.754]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:16.754]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:16.754]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:16.754]                     .init = FALSE)
[10:20:16.754]                 }
[10:20:16.754]             }
[10:20:16.754]         }
[10:20:16.754]     })
[10:20:16.754]     if (TRUE) {
[10:20:16.754]         base::sink(type = "output", split = FALSE)
[10:20:16.754]         if (TRUE) {
[10:20:16.754]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:16.754]         }
[10:20:16.754]         else {
[10:20:16.754]             ...future.result["stdout"] <- base::list(NULL)
[10:20:16.754]         }
[10:20:16.754]         base::close(...future.stdout)
[10:20:16.754]         ...future.stdout <- NULL
[10:20:16.754]     }
[10:20:16.754]     ...future.result$conditions <- ...future.conditions
[10:20:16.754]     ...future.result$finished <- base::Sys.time()
[10:20:16.754]     ...future.result
[10:20:16.754] }
[10:20:16.757] assign_globals() ...
[10:20:16.757] List of 5
[10:20:16.757]  $ ...future.FUN            :function (x, y)  
[10:20:16.757]  $ MoreArgs                 : NULL
[10:20:16.757]  $ ...future.elements_ii    :List of 2
[10:20:16.757]   ..$ :List of 1
[10:20:16.757]   .. ..$ : int 1
[10:20:16.757]   ..$ :List of 1
[10:20:16.757]   .. ..$ : int 0
[10:20:16.757]  $ ...future.seeds_ii       : NULL
[10:20:16.757]  $ ...future.globals.maxSize: NULL
[10:20:16.757]  - attr(*, "where")=List of 5
[10:20:16.757]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:16.757]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:20:16.757]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:16.757]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:16.757]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:16.757]  - attr(*, "resolved")= logi FALSE
[10:20:16.757]  - attr(*, "total_size")= num 1218
[10:20:16.757]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:16.757]  - attr(*, "already-done")= logi TRUE
[10:20:16.762] - reassign environment for ‘...future.FUN’
[10:20:16.762] - copied ‘...future.FUN’ to environment
[10:20:16.762] - copied ‘MoreArgs’ to environment
[10:20:16.762] - copied ‘...future.elements_ii’ to environment
[10:20:16.762] - copied ‘...future.seeds_ii’ to environment
[10:20:16.762] - copied ‘...future.globals.maxSize’ to environment
[10:20:16.762] assign_globals() ... done
[10:20:16.762] requestCore(): workers = 2
[10:20:16.765] MulticoreFuture started
[10:20:16.765] - Launch lazy future ... done
[10:20:16.765] run() for ‘MulticoreFuture’ ... done
[10:20:16.766] Created future:
[10:20:16.766] plan(): Setting new future strategy stack:
[10:20:16.766] List of future strategies:
[10:20:16.766] 1. sequential:
[10:20:16.766]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:16.766]    - tweaked: FALSE
[10:20:16.766]    - call: NULL
[10:20:16.767] plan(): nbrOfWorkers() = 1
[10:20:16.766] MulticoreFuture:
[10:20:16.766] Label: ‘future_mapply-1’
[10:20:16.766] Expression:
[10:20:16.766] {
[10:20:16.766]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:16.766]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:16.766]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:16.766]         on.exit(options(oopts), add = TRUE)
[10:20:16.766]     }
[10:20:16.766]     {
[10:20:16.766]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:16.766]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:20:16.766]         do.call(mapply, args = args)
[10:20:16.766]     }
[10:20:16.766] }
[10:20:16.766] Lazy evaluation: FALSE
[10:20:16.766] Asynchronous evaluation: TRUE
[10:20:16.766] Local evaluation: TRUE
[10:20:16.766] Environment: R_GlobalEnv
[10:20:16.766] Capture standard output: TRUE
[10:20:16.766] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:16.766] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:16.766] Packages: <none>
[10:20:16.766] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:16.766] Resolved: FALSE
[10:20:16.766] Value: <not collected>
[10:20:16.766] Conditions captured: <none>
[10:20:16.766] Early signaling: FALSE
[10:20:16.766] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:16.766] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:16.778] Chunk #1 of 2 ... DONE
[10:20:16.778] Chunk #2 of 2 ...
[10:20:16.779]  - Finding globals in '...' for chunk #2 ...
[10:20:16.779] getGlobalsAndPackages() ...
[10:20:16.779] Searching for globals...
[10:20:16.780] 
[10:20:16.780] Searching for globals ... DONE
[10:20:16.780] - globals: [0] <none>
[10:20:16.780] getGlobalsAndPackages() ... DONE
[10:20:16.780]    + additional globals found: [n=0] 
[10:20:16.781]    + additional namespaces needed: [n=0] 
[10:20:16.781]  - Finding globals in '...' for chunk #2 ... DONE
[10:20:16.781]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:16.781]  - seeds: <none>
[10:20:16.781]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:16.781] getGlobalsAndPackages() ...
[10:20:16.781] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:16.782] Resolving globals: FALSE
[10:20:16.782] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[10:20:16.783] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:20:16.783] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:16.784] 
[10:20:16.784] getGlobalsAndPackages() ... DONE
[10:20:16.784] run() for ‘Future’ ...
[10:20:16.784] - state: ‘created’
[10:20:16.785] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:20:16.788] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:16.788] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:20:16.788]   - Field: ‘label’
[10:20:16.789]   - Field: ‘local’
[10:20:16.789]   - Field: ‘owner’
[10:20:16.789]   - Field: ‘envir’
[10:20:16.789]   - Field: ‘workers’
[10:20:16.789]   - Field: ‘packages’
[10:20:16.789]   - Field: ‘gc’
[10:20:16.789]   - Field: ‘job’
[10:20:16.790]   - Field: ‘conditions’
[10:20:16.790]   - Field: ‘expr’
[10:20:16.790]   - Field: ‘uuid’
[10:20:16.790]   - Field: ‘seed’
[10:20:16.790]   - Field: ‘version’
[10:20:16.790]   - Field: ‘result’
[10:20:16.790]   - Field: ‘asynchronous’
[10:20:16.790]   - Field: ‘calls’
[10:20:16.791]   - Field: ‘globals’
[10:20:16.791]   - Field: ‘stdout’
[10:20:16.791]   - Field: ‘earlySignal’
[10:20:16.791]   - Field: ‘lazy’
[10:20:16.791]   - Field: ‘state’
[10:20:16.791] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:20:16.791] - Launch lazy future ...
[10:20:16.792] Packages needed by the future expression (n = 0): <none>
[10:20:16.792] Packages needed by future strategies (n = 0): <none>
[10:20:16.793] {
[10:20:16.793]     {
[10:20:16.793]         {
[10:20:16.793]             ...future.startTime <- base::Sys.time()
[10:20:16.793]             {
[10:20:16.793]                 {
[10:20:16.793]                   {
[10:20:16.793]                     {
[10:20:16.793]                       base::local({
[10:20:16.793]                         has_future <- base::requireNamespace("future", 
[10:20:16.793]                           quietly = TRUE)
[10:20:16.793]                         if (has_future) {
[10:20:16.793]                           ns <- base::getNamespace("future")
[10:20:16.793]                           version <- ns[[".package"]][["version"]]
[10:20:16.793]                           if (is.null(version)) 
[10:20:16.793]                             version <- utils::packageVersion("future")
[10:20:16.793]                         }
[10:20:16.793]                         else {
[10:20:16.793]                           version <- NULL
[10:20:16.793]                         }
[10:20:16.793]                         if (!has_future || version < "1.8.0") {
[10:20:16.793]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:16.793]                             "", base::R.version$version.string), 
[10:20:16.793]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:16.793]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:16.793]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:16.793]                               "release", "version")], collapse = " "), 
[10:20:16.793]                             hostname = base::Sys.info()[["nodename"]])
[10:20:16.793]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:16.793]                             info)
[10:20:16.793]                           info <- base::paste(info, collapse = "; ")
[10:20:16.793]                           if (!has_future) {
[10:20:16.793]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:16.793]                               info)
[10:20:16.793]                           }
[10:20:16.793]                           else {
[10:20:16.793]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:16.793]                               info, version)
[10:20:16.793]                           }
[10:20:16.793]                           base::stop(msg)
[10:20:16.793]                         }
[10:20:16.793]                       })
[10:20:16.793]                     }
[10:20:16.793]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:16.793]                     base::options(mc.cores = 1L)
[10:20:16.793]                   }
[10:20:16.793]                   ...future.strategy.old <- future::plan("list")
[10:20:16.793]                   options(future.plan = NULL)
[10:20:16.793]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:16.793]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:16.793]                 }
[10:20:16.793]                 ...future.workdir <- getwd()
[10:20:16.793]             }
[10:20:16.793]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:16.793]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:16.793]         }
[10:20:16.793]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:16.793]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:16.793]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:16.793]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:16.793]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:16.793]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:16.793]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:16.793]             base::names(...future.oldOptions))
[10:20:16.793]     }
[10:20:16.793]     if (FALSE) {
[10:20:16.793]     }
[10:20:16.793]     else {
[10:20:16.793]         if (TRUE) {
[10:20:16.793]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:16.793]                 open = "w")
[10:20:16.793]         }
[10:20:16.793]         else {
[10:20:16.793]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:16.793]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:16.793]         }
[10:20:16.793]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:16.793]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:16.793]             base::sink(type = "output", split = FALSE)
[10:20:16.793]             base::close(...future.stdout)
[10:20:16.793]         }, add = TRUE)
[10:20:16.793]     }
[10:20:16.793]     ...future.frame <- base::sys.nframe()
[10:20:16.793]     ...future.conditions <- base::list()
[10:20:16.793]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:16.793]     if (FALSE) {
[10:20:16.793]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:16.793]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:16.793]     }
[10:20:16.793]     ...future.result <- base::tryCatch({
[10:20:16.793]         base::withCallingHandlers({
[10:20:16.793]             ...future.value <- base::withVisible(base::local({
[10:20:16.793]                 withCallingHandlers({
[10:20:16.793]                   {
[10:20:16.793]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:16.793]                     if (!identical(...future.globals.maxSize.org, 
[10:20:16.793]                       ...future.globals.maxSize)) {
[10:20:16.793]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:16.793]                       on.exit(options(oopts), add = TRUE)
[10:20:16.793]                     }
[10:20:16.793]                     {
[10:20:16.793]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:16.793]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:20:16.793]                         USE.NAMES = FALSE)
[10:20:16.793]                       do.call(mapply, args = args)
[10:20:16.793]                     }
[10:20:16.793]                   }
[10:20:16.793]                 }, immediateCondition = function(cond) {
[10:20:16.793]                   save_rds <- function (object, pathname, ...) 
[10:20:16.793]                   {
[10:20:16.793]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:20:16.793]                     if (file_test("-f", pathname_tmp)) {
[10:20:16.793]                       fi_tmp <- file.info(pathname_tmp)
[10:20:16.793]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:20:16.793]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:16.793]                         fi_tmp[["mtime"]])
[10:20:16.793]                     }
[10:20:16.793]                     tryCatch({
[10:20:16.793]                       saveRDS(object, file = pathname_tmp, ...)
[10:20:16.793]                     }, error = function(ex) {
[10:20:16.793]                       msg <- conditionMessage(ex)
[10:20:16.793]                       fi_tmp <- file.info(pathname_tmp)
[10:20:16.793]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:20:16.793]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:16.793]                         fi_tmp[["mtime"]], msg)
[10:20:16.793]                       ex$message <- msg
[10:20:16.793]                       stop(ex)
[10:20:16.793]                     })
[10:20:16.793]                     stopifnot(file_test("-f", pathname_tmp))
[10:20:16.793]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:20:16.793]                     if (!res || file_test("-f", pathname_tmp)) {
[10:20:16.793]                       fi_tmp <- file.info(pathname_tmp)
[10:20:16.793]                       fi <- file.info(pathname)
[10:20:16.793]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:20:16.793]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:16.793]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:20:16.793]                         fi[["size"]], fi[["mtime"]])
[10:20:16.793]                       stop(msg)
[10:20:16.793]                     }
[10:20:16.793]                     invisible(pathname)
[10:20:16.793]                   }
[10:20:16.793]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:20:16.793]                     rootPath = tempdir()) 
[10:20:16.793]                   {
[10:20:16.793]                     obj <- list(time = Sys.time(), condition = cond)
[10:20:16.793]                     file <- tempfile(pattern = class(cond)[1], 
[10:20:16.793]                       tmpdir = path, fileext = ".rds")
[10:20:16.793]                     save_rds(obj, file)
[10:20:16.793]                   }
[10:20:16.793]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8Z8Jdg/.future/immediateConditions")
[10:20:16.793]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:16.793]                   {
[10:20:16.793]                     inherits <- base::inherits
[10:20:16.793]                     invokeRestart <- base::invokeRestart
[10:20:16.793]                     is.null <- base::is.null
[10:20:16.793]                     muffled <- FALSE
[10:20:16.793]                     if (inherits(cond, "message")) {
[10:20:16.793]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:16.793]                       if (muffled) 
[10:20:16.793]                         invokeRestart("muffleMessage")
[10:20:16.793]                     }
[10:20:16.793]                     else if (inherits(cond, "warning")) {
[10:20:16.793]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:16.793]                       if (muffled) 
[10:20:16.793]                         invokeRestart("muffleWarning")
[10:20:16.793]                     }
[10:20:16.793]                     else if (inherits(cond, "condition")) {
[10:20:16.793]                       if (!is.null(pattern)) {
[10:20:16.793]                         computeRestarts <- base::computeRestarts
[10:20:16.793]                         grepl <- base::grepl
[10:20:16.793]                         restarts <- computeRestarts(cond)
[10:20:16.793]                         for (restart in restarts) {
[10:20:16.793]                           name <- restart$name
[10:20:16.793]                           if (is.null(name)) 
[10:20:16.793]                             next
[10:20:16.793]                           if (!grepl(pattern, name)) 
[10:20:16.793]                             next
[10:20:16.793]                           invokeRestart(restart)
[10:20:16.793]                           muffled <- TRUE
[10:20:16.793]                           break
[10:20:16.793]                         }
[10:20:16.793]                       }
[10:20:16.793]                     }
[10:20:16.793]                     invisible(muffled)
[10:20:16.793]                   }
[10:20:16.793]                   muffleCondition(cond)
[10:20:16.793]                 })
[10:20:16.793]             }))
[10:20:16.793]             future::FutureResult(value = ...future.value$value, 
[10:20:16.793]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:16.793]                   ...future.rng), globalenv = if (FALSE) 
[10:20:16.793]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:16.793]                     ...future.globalenv.names))
[10:20:16.793]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:16.793]         }, condition = base::local({
[10:20:16.793]             c <- base::c
[10:20:16.793]             inherits <- base::inherits
[10:20:16.793]             invokeRestart <- base::invokeRestart
[10:20:16.793]             length <- base::length
[10:20:16.793]             list <- base::list
[10:20:16.793]             seq.int <- base::seq.int
[10:20:16.793]             signalCondition <- base::signalCondition
[10:20:16.793]             sys.calls <- base::sys.calls
[10:20:16.793]             `[[` <- base::`[[`
[10:20:16.793]             `+` <- base::`+`
[10:20:16.793]             `<<-` <- base::`<<-`
[10:20:16.793]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:16.793]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:16.793]                   3L)]
[10:20:16.793]             }
[10:20:16.793]             function(cond) {
[10:20:16.793]                 is_error <- inherits(cond, "error")
[10:20:16.793]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:16.793]                   NULL)
[10:20:16.793]                 if (is_error) {
[10:20:16.793]                   sessionInformation <- function() {
[10:20:16.793]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:16.793]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:16.793]                       search = base::search(), system = base::Sys.info())
[10:20:16.793]                   }
[10:20:16.793]                   ...future.conditions[[length(...future.conditions) + 
[10:20:16.793]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:16.793]                     cond$call), session = sessionInformation(), 
[10:20:16.793]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:16.793]                   signalCondition(cond)
[10:20:16.793]                 }
[10:20:16.793]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:16.793]                 "immediateCondition"))) {
[10:20:16.793]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:16.793]                   ...future.conditions[[length(...future.conditions) + 
[10:20:16.793]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:16.793]                   if (TRUE && !signal) {
[10:20:16.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:16.793]                     {
[10:20:16.793]                       inherits <- base::inherits
[10:20:16.793]                       invokeRestart <- base::invokeRestart
[10:20:16.793]                       is.null <- base::is.null
[10:20:16.793]                       muffled <- FALSE
[10:20:16.793]                       if (inherits(cond, "message")) {
[10:20:16.793]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:16.793]                         if (muffled) 
[10:20:16.793]                           invokeRestart("muffleMessage")
[10:20:16.793]                       }
[10:20:16.793]                       else if (inherits(cond, "warning")) {
[10:20:16.793]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:16.793]                         if (muffled) 
[10:20:16.793]                           invokeRestart("muffleWarning")
[10:20:16.793]                       }
[10:20:16.793]                       else if (inherits(cond, "condition")) {
[10:20:16.793]                         if (!is.null(pattern)) {
[10:20:16.793]                           computeRestarts <- base::computeRestarts
[10:20:16.793]                           grepl <- base::grepl
[10:20:16.793]                           restarts <- computeRestarts(cond)
[10:20:16.793]                           for (restart in restarts) {
[10:20:16.793]                             name <- restart$name
[10:20:16.793]                             if (is.null(name)) 
[10:20:16.793]                               next
[10:20:16.793]                             if (!grepl(pattern, name)) 
[10:20:16.793]                               next
[10:20:16.793]                             invokeRestart(restart)
[10:20:16.793]                             muffled <- TRUE
[10:20:16.793]                             break
[10:20:16.793]                           }
[10:20:16.793]                         }
[10:20:16.793]                       }
[10:20:16.793]                       invisible(muffled)
[10:20:16.793]                     }
[10:20:16.793]                     muffleCondition(cond, pattern = "^muffle")
[10:20:16.793]                   }
[10:20:16.793]                 }
[10:20:16.793]                 else {
[10:20:16.793]                   if (TRUE) {
[10:20:16.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:16.793]                     {
[10:20:16.793]                       inherits <- base::inherits
[10:20:16.793]                       invokeRestart <- base::invokeRestart
[10:20:16.793]                       is.null <- base::is.null
[10:20:16.793]                       muffled <- FALSE
[10:20:16.793]                       if (inherits(cond, "message")) {
[10:20:16.793]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:16.793]                         if (muffled) 
[10:20:16.793]                           invokeRestart("muffleMessage")
[10:20:16.793]                       }
[10:20:16.793]                       else if (inherits(cond, "warning")) {
[10:20:16.793]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:16.793]                         if (muffled) 
[10:20:16.793]                           invokeRestart("muffleWarning")
[10:20:16.793]                       }
[10:20:16.793]                       else if (inherits(cond, "condition")) {
[10:20:16.793]                         if (!is.null(pattern)) {
[10:20:16.793]                           computeRestarts <- base::computeRestarts
[10:20:16.793]                           grepl <- base::grepl
[10:20:16.793]                           restarts <- computeRestarts(cond)
[10:20:16.793]                           for (restart in restarts) {
[10:20:16.793]                             name <- restart$name
[10:20:16.793]                             if (is.null(name)) 
[10:20:16.793]                               next
[10:20:16.793]                             if (!grepl(pattern, name)) 
[10:20:16.793]                               next
[10:20:16.793]                             invokeRestart(restart)
[10:20:16.793]                             muffled <- TRUE
[10:20:16.793]                             break
[10:20:16.793]                           }
[10:20:16.793]                         }
[10:20:16.793]                       }
[10:20:16.793]                       invisible(muffled)
[10:20:16.793]                     }
[10:20:16.793]                     muffleCondition(cond, pattern = "^muffle")
[10:20:16.793]                   }
[10:20:16.793]                 }
[10:20:16.793]             }
[10:20:16.793]         }))
[10:20:16.793]     }, error = function(ex) {
[10:20:16.793]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:16.793]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:16.793]                 ...future.rng), started = ...future.startTime, 
[10:20:16.793]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:16.793]             version = "1.8"), class = "FutureResult")
[10:20:16.793]     }, finally = {
[10:20:16.793]         if (!identical(...future.workdir, getwd())) 
[10:20:16.793]             setwd(...future.workdir)
[10:20:16.793]         {
[10:20:16.793]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:16.793]                 ...future.oldOptions$nwarnings <- NULL
[10:20:16.793]             }
[10:20:16.793]             base::options(...future.oldOptions)
[10:20:16.793]             if (.Platform$OS.type == "windows") {
[10:20:16.793]                 old_names <- names(...future.oldEnvVars)
[10:20:16.793]                 envs <- base::Sys.getenv()
[10:20:16.793]                 names <- names(envs)
[10:20:16.793]                 common <- intersect(names, old_names)
[10:20:16.793]                 added <- setdiff(names, old_names)
[10:20:16.793]                 removed <- setdiff(old_names, names)
[10:20:16.793]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:16.793]                   envs[common]]
[10:20:16.793]                 NAMES <- toupper(changed)
[10:20:16.793]                 args <- list()
[10:20:16.793]                 for (kk in seq_along(NAMES)) {
[10:20:16.793]                   name <- changed[[kk]]
[10:20:16.793]                   NAME <- NAMES[[kk]]
[10:20:16.793]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:16.793]                     next
[10:20:16.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:16.793]                 }
[10:20:16.793]                 NAMES <- toupper(added)
[10:20:16.793]                 for (kk in seq_along(NAMES)) {
[10:20:16.793]                   name <- added[[kk]]
[10:20:16.793]                   NAME <- NAMES[[kk]]
[10:20:16.793]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:16.793]                     next
[10:20:16.793]                   args[[name]] <- ""
[10:20:16.793]                 }
[10:20:16.793]                 NAMES <- toupper(removed)
[10:20:16.793]                 for (kk in seq_along(NAMES)) {
[10:20:16.793]                   name <- removed[[kk]]
[10:20:16.793]                   NAME <- NAMES[[kk]]
[10:20:16.793]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:16.793]                     next
[10:20:16.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:16.793]                 }
[10:20:16.793]                 if (length(args) > 0) 
[10:20:16.793]                   base::do.call(base::Sys.setenv, args = args)
[10:20:16.793]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:16.793]             }
[10:20:16.793]             else {
[10:20:16.793]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:16.793]             }
[10:20:16.793]             {
[10:20:16.793]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:16.793]                   0L) {
[10:20:16.793]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:16.793]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:16.793]                   base::options(opts)
[10:20:16.793]                 }
[10:20:16.793]                 {
[10:20:16.793]                   {
[10:20:16.793]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:16.793]                     NULL
[10:20:16.793]                   }
[10:20:16.793]                   options(future.plan = NULL)
[10:20:16.793]                   if (is.na(NA_character_)) 
[10:20:16.793]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:16.793]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:16.793]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:16.793]                     .init = FALSE)
[10:20:16.793]                 }
[10:20:16.793]             }
[10:20:16.793]         }
[10:20:16.793]     })
[10:20:16.793]     if (TRUE) {
[10:20:16.793]         base::sink(type = "output", split = FALSE)
[10:20:16.793]         if (TRUE) {
[10:20:16.793]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:16.793]         }
[10:20:16.793]         else {
[10:20:16.793]             ...future.result["stdout"] <- base::list(NULL)
[10:20:16.793]         }
[10:20:16.793]         base::close(...future.stdout)
[10:20:16.793]         ...future.stdout <- NULL
[10:20:16.793]     }
[10:20:16.793]     ...future.result$conditions <- ...future.conditions
[10:20:16.793]     ...future.result$finished <- base::Sys.time()
[10:20:16.793]     ...future.result
[10:20:16.793] }
[10:20:16.796] assign_globals() ...
[10:20:16.796] List of 5
[10:20:16.796]  $ ...future.FUN            :function (x, y)  
[10:20:16.796]  $ MoreArgs                 : NULL
[10:20:16.796]  $ ...future.elements_ii    :List of 2
[10:20:16.796]   ..$ :List of 1
[10:20:16.796]   .. ..$ : int 0
[10:20:16.796]   ..$ :List of 1
[10:20:16.796]   .. ..$ : int 1
[10:20:16.796]  $ ...future.seeds_ii       : NULL
[10:20:16.796]  $ ...future.globals.maxSize: NULL
[10:20:16.796]  - attr(*, "where")=List of 5
[10:20:16.796]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:16.796]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:20:16.796]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:16.796]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:16.796]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:16.796]  - attr(*, "resolved")= logi FALSE
[10:20:16.796]  - attr(*, "total_size")= num 1218
[10:20:16.796]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:16.796]  - attr(*, "already-done")= logi TRUE
[10:20:16.809] - reassign environment for ‘...future.FUN’
[10:20:16.810] - copied ‘...future.FUN’ to environment
[10:20:16.810] - copied ‘MoreArgs’ to environment
[10:20:16.810] - copied ‘...future.elements_ii’ to environment
[10:20:16.810] - copied ‘...future.seeds_ii’ to environment
[10:20:16.810] - copied ‘...future.globals.maxSize’ to environment
[10:20:16.810] assign_globals() ... done
[10:20:16.810] requestCore(): workers = 2
[10:20:16.813] MulticoreFuture started
[10:20:16.814] - Launch lazy future ... done
[10:20:16.814] run() for ‘MulticoreFuture’ ... done
[10:20:16.814] Created future:
[10:20:16.814] plan(): Setting new future strategy stack:
[10:20:16.814] List of future strategies:
[10:20:16.814] 1. sequential:
[10:20:16.814]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:16.814]    - tweaked: FALSE
[10:20:16.814]    - call: NULL
[10:20:16.815] plan(): nbrOfWorkers() = 1
[10:20:16.818] plan(): Setting new future strategy stack:
[10:20:16.818] List of future strategies:
[10:20:16.818] 1. multicore:
[10:20:16.818]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:20:16.818]    - tweaked: FALSE
[10:20:16.818]    - call: plan(strategy)
[10:20:16.821] plan(): nbrOfWorkers() = 2
[10:20:16.814] MulticoreFuture:
[10:20:16.814] Label: ‘future_mapply-2’
[10:20:16.814] Expression:
[10:20:16.814] {
[10:20:16.814]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:16.814]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:16.814]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:16.814]         on.exit(options(oopts), add = TRUE)
[10:20:16.814]     }
[10:20:16.814]     {
[10:20:16.814]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:16.814]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:20:16.814]         do.call(mapply, args = args)
[10:20:16.814]     }
[10:20:16.814] }
[10:20:16.814] Lazy evaluation: FALSE
[10:20:16.814] Asynchronous evaluation: TRUE
[10:20:16.814] Local evaluation: TRUE
[10:20:16.814] Environment: R_GlobalEnv
[10:20:16.814] Capture standard output: TRUE
[10:20:16.814] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:16.814] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:16.814] Packages: <none>
[10:20:16.814] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:16.814] Resolved: TRUE
[10:20:16.814] Value: <not collected>
[10:20:16.814] Conditions captured: <none>
[10:20:16.814] Early signaling: FALSE
[10:20:16.814] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:16.814] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:16.822] Chunk #2 of 2 ... DONE
[10:20:16.823] Launching 2 futures (chunks) ... DONE
[10:20:16.823] Resolving 2 futures (chunks) ...
[10:20:16.823] resolve() on list ...
[10:20:16.823]  recursive: 0
[10:20:16.823]  length: 2
[10:20:16.823] 
[10:20:16.834] Future #2
[10:20:16.834] result() for MulticoreFuture ...
[10:20:16.835] result() for MulticoreFuture ...
[10:20:16.835] result() for MulticoreFuture ... done
[10:20:16.836] result() for MulticoreFuture ... done
[10:20:16.836] result() for MulticoreFuture ...
[10:20:16.836] result() for MulticoreFuture ... done
[10:20:16.836] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:20:16.836] - nx: 2
[10:20:16.836] - relay: TRUE
[10:20:16.837] - stdout: TRUE
[10:20:16.837] - signal: TRUE
[10:20:16.837] - resignal: FALSE
[10:20:16.837] - force: TRUE
[10:20:16.837] - relayed: [n=2] FALSE, FALSE
[10:20:16.837] - queued futures: [n=2] FALSE, FALSE
[10:20:16.837]  - until=1
[10:20:16.837]  - relaying element #1
[10:20:16.838] - relayed: [n=2] FALSE, FALSE
[10:20:16.838] - queued futures: [n=2] FALSE, TRUE
[10:20:16.838] signalConditionsASAP(NULL, pos=2) ... done
[10:20:16.838]  length: 1 (resolved future 2)
[10:20:17.270] plan(): Setting new future strategy stack:
[10:20:17.270] List of future strategies:
[10:20:17.270] 1. multicore:
[10:20:17.270]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:20:17.270]    - tweaked: FALSE
[10:20:17.270]    - call: plan(strategy)
[10:20:17.273] plan(): nbrOfWorkers() = 2
[10:20:17.276] Future #1
[10:20:17.276] result() for MulticoreFuture ...
[10:20:17.277] result() for MulticoreFuture ...
[10:20:17.277] result() for MulticoreFuture ... done
[10:20:17.277] result() for MulticoreFuture ... done
[10:20:17.278] result() for MulticoreFuture ...
[10:20:17.278] result() for MulticoreFuture ... done
[10:20:17.278] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:20:17.278] - nx: 2
[10:20:17.278] - relay: TRUE
[10:20:17.278] - stdout: TRUE
[10:20:17.278] - signal: TRUE
[10:20:17.278] - resignal: FALSE
[10:20:17.278] - force: TRUE
[10:20:17.278] - relayed: [n=2] FALSE, FALSE
[10:20:17.279] - queued futures: [n=2] FALSE, TRUE
[10:20:17.279]  - until=1
[10:20:17.279]  - relaying element #1
[10:20:17.279] result() for MulticoreFuture ...
[10:20:17.279] result() for MulticoreFuture ... done
[10:20:17.279] result() for MulticoreFuture ...
[10:20:17.279] result() for MulticoreFuture ... done
[10:20:17.279] result() for MulticoreFuture ...
[10:20:17.280] result() for MulticoreFuture ... done
[10:20:17.280] result() for MulticoreFuture ...
[10:20:17.280] result() for MulticoreFuture ... done
[10:20:17.280] - relayed: [n=2] TRUE, FALSE
[10:20:17.280] - queued futures: [n=2] TRUE, TRUE
[10:20:17.280] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:20:17.280]  length: 0 (resolved future 1)
[10:20:17.280] Relaying remaining futures
[10:20:17.280] signalConditionsASAP(NULL, pos=0) ...
[10:20:17.281] - nx: 2
[10:20:17.281] - relay: TRUE
[10:20:17.281] - stdout: TRUE
[10:20:17.281] - signal: TRUE
[10:20:17.281] - resignal: FALSE
[10:20:17.281] - force: TRUE
[10:20:17.281] - relayed: [n=2] TRUE, FALSE
[10:20:17.281] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:20:17.282]  - relaying element #2
[10:20:17.282] result() for MulticoreFuture ...
[10:20:17.282] result() for MulticoreFuture ... done
[10:20:17.282] result() for MulticoreFuture ...
[10:20:17.282] result() for MulticoreFuture ... done
[10:20:17.282] result() for MulticoreFuture ...
[10:20:17.282] result() for MulticoreFuture ... done
[10:20:17.282] result() for MulticoreFuture ...
[10:20:17.283] result() for MulticoreFuture ... done
[10:20:17.283] - relayed: [n=2] TRUE, TRUE
[10:20:17.283] - queued futures: [n=2] TRUE, TRUE
[10:20:17.283] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[10:20:17.283] resolve() on list ... DONE
[10:20:17.283] result() for MulticoreFuture ...
[10:20:17.283] result() for MulticoreFuture ... done
[10:20:17.283] result() for MulticoreFuture ...
[10:20:17.283] result() for MulticoreFuture ... done
[10:20:17.284] result() for MulticoreFuture ...
[10:20:17.284] result() for MulticoreFuture ... done
[10:20:17.284] result() for MulticoreFuture ...
[10:20:17.284] result() for MulticoreFuture ... done
[10:20:17.284]  - Number of value chunks collected: 2
[10:20:17.284] Resolving 2 futures (chunks) ... DONE
[10:20:17.284] Reducing values from 2 chunks ...
[10:20:17.284]  - Number of values collected after concatenation: 2
[10:20:17.284]  - Number of values expected: 2
[10:20:17.285] Reducing values from 2 chunks ... DONE
[10:20:17.285] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[10:20:17.285] future_mapply() ...
[10:20:17.288] Number of chunks: 2
[10:20:17.288] getGlobalsAndPackagesXApply() ...
[10:20:17.288]  - future.globals: TRUE
[10:20:17.288] getGlobalsAndPackages() ...
[10:20:17.288] Searching for globals...
[10:20:17.296] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:20:17.296] Searching for globals ... DONE
[10:20:17.296] Resolving globals: FALSE
[10:20:17.297] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[10:20:17.297] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[10:20:17.297] - globals: [1] ‘FUN’
[10:20:17.298] 
[10:20:17.298] getGlobalsAndPackages() ... DONE
[10:20:17.298]  - globals found/used: [n=1] ‘FUN’
[10:20:17.298]  - needed namespaces: [n=0] 
[10:20:17.298] Finding globals ... DONE
[10:20:17.298] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:20:17.298] List of 2
[10:20:17.298]  $ ...future.FUN:function (x, y)  
[10:20:17.298]  $ MoreArgs     : NULL
[10:20:17.298]  - attr(*, "where")=List of 2
[10:20:17.298]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:17.298]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:20:17.298]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:17.298]  - attr(*, "resolved")= logi FALSE
[10:20:17.298]  - attr(*, "total_size")= num NA
[10:20:17.301] Packages to be attached in all futures: [n=0] 
[10:20:17.301] getGlobalsAndPackagesXApply() ... DONE
[10:20:17.302] Number of futures (= number of chunks): 2
[10:20:17.302] Launching 2 futures (chunks) ...
[10:20:17.302] Chunk #1 of 2 ...
[10:20:17.302]  - Finding globals in '...' for chunk #1 ...
[10:20:17.302] getGlobalsAndPackages() ...
[10:20:17.302] Searching for globals...
[10:20:17.303] 
[10:20:17.303] Searching for globals ... DONE
[10:20:17.303] - globals: [0] <none>
[10:20:17.303] getGlobalsAndPackages() ... DONE
[10:20:17.303]    + additional globals found: [n=0] 
[10:20:17.303]    + additional namespaces needed: [n=0] 
[10:20:17.303]  - Finding globals in '...' for chunk #1 ... DONE
[10:20:17.303]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:17.303]  - seeds: <none>
[10:20:17.303]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:17.303] getGlobalsAndPackages() ...
[10:20:17.303] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:17.304] Resolving globals: FALSE
[10:20:17.304] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[10:20:17.304] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:20:17.305] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:17.305] 
[10:20:17.305] getGlobalsAndPackages() ... DONE
[10:20:17.305] run() for ‘Future’ ...
[10:20:17.305] - state: ‘created’
[10:20:17.305] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:20:17.307] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:17.307] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:20:17.307]   - Field: ‘label’
[10:20:17.307]   - Field: ‘local’
[10:20:17.307]   - Field: ‘owner’
[10:20:17.308]   - Field: ‘envir’
[10:20:17.308]   - Field: ‘workers’
[10:20:17.308]   - Field: ‘packages’
[10:20:17.308]   - Field: ‘gc’
[10:20:17.308]   - Field: ‘job’
[10:20:17.308]   - Field: ‘conditions’
[10:20:17.308]   - Field: ‘expr’
[10:20:17.308]   - Field: ‘uuid’
[10:20:17.308]   - Field: ‘seed’
[10:20:17.308]   - Field: ‘version’
[10:20:17.308]   - Field: ‘result’
[10:20:17.308]   - Field: ‘asynchronous’
[10:20:17.309]   - Field: ‘calls’
[10:20:17.309]   - Field: ‘globals’
[10:20:17.309]   - Field: ‘stdout’
[10:20:17.309]   - Field: ‘earlySignal’
[10:20:17.309]   - Field: ‘lazy’
[10:20:17.309]   - Field: ‘state’
[10:20:17.309] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:20:17.309] - Launch lazy future ...
[10:20:17.309] Packages needed by the future expression (n = 0): <none>
[10:20:17.310] Packages needed by future strategies (n = 0): <none>
[10:20:17.310] {
[10:20:17.310]     {
[10:20:17.310]         {
[10:20:17.310]             ...future.startTime <- base::Sys.time()
[10:20:17.310]             {
[10:20:17.310]                 {
[10:20:17.310]                   {
[10:20:17.310]                     {
[10:20:17.310]                       base::local({
[10:20:17.310]                         has_future <- base::requireNamespace("future", 
[10:20:17.310]                           quietly = TRUE)
[10:20:17.310]                         if (has_future) {
[10:20:17.310]                           ns <- base::getNamespace("future")
[10:20:17.310]                           version <- ns[[".package"]][["version"]]
[10:20:17.310]                           if (is.null(version)) 
[10:20:17.310]                             version <- utils::packageVersion("future")
[10:20:17.310]                         }
[10:20:17.310]                         else {
[10:20:17.310]                           version <- NULL
[10:20:17.310]                         }
[10:20:17.310]                         if (!has_future || version < "1.8.0") {
[10:20:17.310]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:17.310]                             "", base::R.version$version.string), 
[10:20:17.310]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:17.310]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:17.310]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:17.310]                               "release", "version")], collapse = " "), 
[10:20:17.310]                             hostname = base::Sys.info()[["nodename"]])
[10:20:17.310]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:17.310]                             info)
[10:20:17.310]                           info <- base::paste(info, collapse = "; ")
[10:20:17.310]                           if (!has_future) {
[10:20:17.310]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:17.310]                               info)
[10:20:17.310]                           }
[10:20:17.310]                           else {
[10:20:17.310]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:17.310]                               info, version)
[10:20:17.310]                           }
[10:20:17.310]                           base::stop(msg)
[10:20:17.310]                         }
[10:20:17.310]                       })
[10:20:17.310]                     }
[10:20:17.310]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:17.310]                     base::options(mc.cores = 1L)
[10:20:17.310]                   }
[10:20:17.310]                   ...future.strategy.old <- future::plan("list")
[10:20:17.310]                   options(future.plan = NULL)
[10:20:17.310]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:17.310]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:17.310]                 }
[10:20:17.310]                 ...future.workdir <- getwd()
[10:20:17.310]             }
[10:20:17.310]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:17.310]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:17.310]         }
[10:20:17.310]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:17.310]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:17.310]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:17.310]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:17.310]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:17.310]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:17.310]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:17.310]             base::names(...future.oldOptions))
[10:20:17.310]     }
[10:20:17.310]     if (TRUE) {
[10:20:17.310]     }
[10:20:17.310]     else {
[10:20:17.310]         if (NA) {
[10:20:17.310]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:17.310]                 open = "w")
[10:20:17.310]         }
[10:20:17.310]         else {
[10:20:17.310]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:17.310]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:17.310]         }
[10:20:17.310]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:17.310]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:17.310]             base::sink(type = "output", split = FALSE)
[10:20:17.310]             base::close(...future.stdout)
[10:20:17.310]         }, add = TRUE)
[10:20:17.310]     }
[10:20:17.310]     ...future.frame <- base::sys.nframe()
[10:20:17.310]     ...future.conditions <- base::list()
[10:20:17.310]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:17.310]     if (FALSE) {
[10:20:17.310]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:17.310]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:17.310]     }
[10:20:17.310]     ...future.result <- base::tryCatch({
[10:20:17.310]         base::withCallingHandlers({
[10:20:17.310]             ...future.value <- base::withVisible(base::local({
[10:20:17.310]                 withCallingHandlers({
[10:20:17.310]                   {
[10:20:17.310]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:17.310]                     if (!identical(...future.globals.maxSize.org, 
[10:20:17.310]                       ...future.globals.maxSize)) {
[10:20:17.310]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:17.310]                       on.exit(options(oopts), add = TRUE)
[10:20:17.310]                     }
[10:20:17.310]                     {
[10:20:17.310]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:17.310]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:20:17.310]                         USE.NAMES = FALSE)
[10:20:17.310]                       do.call(mapply, args = args)
[10:20:17.310]                     }
[10:20:17.310]                   }
[10:20:17.310]                 }, immediateCondition = function(cond) {
[10:20:17.310]                   save_rds <- function (object, pathname, ...) 
[10:20:17.310]                   {
[10:20:17.310]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:20:17.310]                     if (file_test("-f", pathname_tmp)) {
[10:20:17.310]                       fi_tmp <- file.info(pathname_tmp)
[10:20:17.310]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:20:17.310]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:17.310]                         fi_tmp[["mtime"]])
[10:20:17.310]                     }
[10:20:17.310]                     tryCatch({
[10:20:17.310]                       saveRDS(object, file = pathname_tmp, ...)
[10:20:17.310]                     }, error = function(ex) {
[10:20:17.310]                       msg <- conditionMessage(ex)
[10:20:17.310]                       fi_tmp <- file.info(pathname_tmp)
[10:20:17.310]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:20:17.310]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:17.310]                         fi_tmp[["mtime"]], msg)
[10:20:17.310]                       ex$message <- msg
[10:20:17.310]                       stop(ex)
[10:20:17.310]                     })
[10:20:17.310]                     stopifnot(file_test("-f", pathname_tmp))
[10:20:17.310]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:20:17.310]                     if (!res || file_test("-f", pathname_tmp)) {
[10:20:17.310]                       fi_tmp <- file.info(pathname_tmp)
[10:20:17.310]                       fi <- file.info(pathname)
[10:20:17.310]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:20:17.310]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:17.310]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:20:17.310]                         fi[["size"]], fi[["mtime"]])
[10:20:17.310]                       stop(msg)
[10:20:17.310]                     }
[10:20:17.310]                     invisible(pathname)
[10:20:17.310]                   }
[10:20:17.310]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:20:17.310]                     rootPath = tempdir()) 
[10:20:17.310]                   {
[10:20:17.310]                     obj <- list(time = Sys.time(), condition = cond)
[10:20:17.310]                     file <- tempfile(pattern = class(cond)[1], 
[10:20:17.310]                       tmpdir = path, fileext = ".rds")
[10:20:17.310]                     save_rds(obj, file)
[10:20:17.310]                   }
[10:20:17.310]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8Z8Jdg/.future/immediateConditions")
[10:20:17.310]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:17.310]                   {
[10:20:17.310]                     inherits <- base::inherits
[10:20:17.310]                     invokeRestart <- base::invokeRestart
[10:20:17.310]                     is.null <- base::is.null
[10:20:17.310]                     muffled <- FALSE
[10:20:17.310]                     if (inherits(cond, "message")) {
[10:20:17.310]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:17.310]                       if (muffled) 
[10:20:17.310]                         invokeRestart("muffleMessage")
[10:20:17.310]                     }
[10:20:17.310]                     else if (inherits(cond, "warning")) {
[10:20:17.310]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:17.310]                       if (muffled) 
[10:20:17.310]                         invokeRestart("muffleWarning")
[10:20:17.310]                     }
[10:20:17.310]                     else if (inherits(cond, "condition")) {
[10:20:17.310]                       if (!is.null(pattern)) {
[10:20:17.310]                         computeRestarts <- base::computeRestarts
[10:20:17.310]                         grepl <- base::grepl
[10:20:17.310]                         restarts <- computeRestarts(cond)
[10:20:17.310]                         for (restart in restarts) {
[10:20:17.310]                           name <- restart$name
[10:20:17.310]                           if (is.null(name)) 
[10:20:17.310]                             next
[10:20:17.310]                           if (!grepl(pattern, name)) 
[10:20:17.310]                             next
[10:20:17.310]                           invokeRestart(restart)
[10:20:17.310]                           muffled <- TRUE
[10:20:17.310]                           break
[10:20:17.310]                         }
[10:20:17.310]                       }
[10:20:17.310]                     }
[10:20:17.310]                     invisible(muffled)
[10:20:17.310]                   }
[10:20:17.310]                   muffleCondition(cond)
[10:20:17.310]                 })
[10:20:17.310]             }))
[10:20:17.310]             future::FutureResult(value = ...future.value$value, 
[10:20:17.310]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:17.310]                   ...future.rng), globalenv = if (FALSE) 
[10:20:17.310]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:17.310]                     ...future.globalenv.names))
[10:20:17.310]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:17.310]         }, condition = base::local({
[10:20:17.310]             c <- base::c
[10:20:17.310]             inherits <- base::inherits
[10:20:17.310]             invokeRestart <- base::invokeRestart
[10:20:17.310]             length <- base::length
[10:20:17.310]             list <- base::list
[10:20:17.310]             seq.int <- base::seq.int
[10:20:17.310]             signalCondition <- base::signalCondition
[10:20:17.310]             sys.calls <- base::sys.calls
[10:20:17.310]             `[[` <- base::`[[`
[10:20:17.310]             `+` <- base::`+`
[10:20:17.310]             `<<-` <- base::`<<-`
[10:20:17.310]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:17.310]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:17.310]                   3L)]
[10:20:17.310]             }
[10:20:17.310]             function(cond) {
[10:20:17.310]                 is_error <- inherits(cond, "error")
[10:20:17.310]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:17.310]                   NULL)
[10:20:17.310]                 if (is_error) {
[10:20:17.310]                   sessionInformation <- function() {
[10:20:17.310]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:17.310]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:17.310]                       search = base::search(), system = base::Sys.info())
[10:20:17.310]                   }
[10:20:17.310]                   ...future.conditions[[length(...future.conditions) + 
[10:20:17.310]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:17.310]                     cond$call), session = sessionInformation(), 
[10:20:17.310]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:17.310]                   signalCondition(cond)
[10:20:17.310]                 }
[10:20:17.310]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:17.310]                 "immediateCondition"))) {
[10:20:17.310]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:17.310]                   ...future.conditions[[length(...future.conditions) + 
[10:20:17.310]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:17.310]                   if (TRUE && !signal) {
[10:20:17.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:17.310]                     {
[10:20:17.310]                       inherits <- base::inherits
[10:20:17.310]                       invokeRestart <- base::invokeRestart
[10:20:17.310]                       is.null <- base::is.null
[10:20:17.310]                       muffled <- FALSE
[10:20:17.310]                       if (inherits(cond, "message")) {
[10:20:17.310]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:17.310]                         if (muffled) 
[10:20:17.310]                           invokeRestart("muffleMessage")
[10:20:17.310]                       }
[10:20:17.310]                       else if (inherits(cond, "warning")) {
[10:20:17.310]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:17.310]                         if (muffled) 
[10:20:17.310]                           invokeRestart("muffleWarning")
[10:20:17.310]                       }
[10:20:17.310]                       else if (inherits(cond, "condition")) {
[10:20:17.310]                         if (!is.null(pattern)) {
[10:20:17.310]                           computeRestarts <- base::computeRestarts
[10:20:17.310]                           grepl <- base::grepl
[10:20:17.310]                           restarts <- computeRestarts(cond)
[10:20:17.310]                           for (restart in restarts) {
[10:20:17.310]                             name <- restart$name
[10:20:17.310]                             if (is.null(name)) 
[10:20:17.310]                               next
[10:20:17.310]                             if (!grepl(pattern, name)) 
[10:20:17.310]                               next
[10:20:17.310]                             invokeRestart(restart)
[10:20:17.310]                             muffled <- TRUE
[10:20:17.310]                             break
[10:20:17.310]                           }
[10:20:17.310]                         }
[10:20:17.310]                       }
[10:20:17.310]                       invisible(muffled)
[10:20:17.310]                     }
[10:20:17.310]                     muffleCondition(cond, pattern = "^muffle")
[10:20:17.310]                   }
[10:20:17.310]                 }
[10:20:17.310]                 else {
[10:20:17.310]                   if (TRUE) {
[10:20:17.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:17.310]                     {
[10:20:17.310]                       inherits <- base::inherits
[10:20:17.310]                       invokeRestart <- base::invokeRestart
[10:20:17.310]                       is.null <- base::is.null
[10:20:17.310]                       muffled <- FALSE
[10:20:17.310]                       if (inherits(cond, "message")) {
[10:20:17.310]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:17.310]                         if (muffled) 
[10:20:17.310]                           invokeRestart("muffleMessage")
[10:20:17.310]                       }
[10:20:17.310]                       else if (inherits(cond, "warning")) {
[10:20:17.310]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:17.310]                         if (muffled) 
[10:20:17.310]                           invokeRestart("muffleWarning")
[10:20:17.310]                       }
[10:20:17.310]                       else if (inherits(cond, "condition")) {
[10:20:17.310]                         if (!is.null(pattern)) {
[10:20:17.310]                           computeRestarts <- base::computeRestarts
[10:20:17.310]                           grepl <- base::grepl
[10:20:17.310]                           restarts <- computeRestarts(cond)
[10:20:17.310]                           for (restart in restarts) {
[10:20:17.310]                             name <- restart$name
[10:20:17.310]                             if (is.null(name)) 
[10:20:17.310]                               next
[10:20:17.310]                             if (!grepl(pattern, name)) 
[10:20:17.310]                               next
[10:20:17.310]                             invokeRestart(restart)
[10:20:17.310]                             muffled <- TRUE
[10:20:17.310]                             break
[10:20:17.310]                           }
[10:20:17.310]                         }
[10:20:17.310]                       }
[10:20:17.310]                       invisible(muffled)
[10:20:17.310]                     }
[10:20:17.310]                     muffleCondition(cond, pattern = "^muffle")
[10:20:17.310]                   }
[10:20:17.310]                 }
[10:20:17.310]             }
[10:20:17.310]         }))
[10:20:17.310]     }, error = function(ex) {
[10:20:17.310]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:17.310]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:17.310]                 ...future.rng), started = ...future.startTime, 
[10:20:17.310]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:17.310]             version = "1.8"), class = "FutureResult")
[10:20:17.310]     }, finally = {
[10:20:17.310]         if (!identical(...future.workdir, getwd())) 
[10:20:17.310]             setwd(...future.workdir)
[10:20:17.310]         {
[10:20:17.310]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:17.310]                 ...future.oldOptions$nwarnings <- NULL
[10:20:17.310]             }
[10:20:17.310]             base::options(...future.oldOptions)
[10:20:17.310]             if (.Platform$OS.type == "windows") {
[10:20:17.310]                 old_names <- names(...future.oldEnvVars)
[10:20:17.310]                 envs <- base::Sys.getenv()
[10:20:17.310]                 names <- names(envs)
[10:20:17.310]                 common <- intersect(names, old_names)
[10:20:17.310]                 added <- setdiff(names, old_names)
[10:20:17.310]                 removed <- setdiff(old_names, names)
[10:20:17.310]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:17.310]                   envs[common]]
[10:20:17.310]                 NAMES <- toupper(changed)
[10:20:17.310]                 args <- list()
[10:20:17.310]                 for (kk in seq_along(NAMES)) {
[10:20:17.310]                   name <- changed[[kk]]
[10:20:17.310]                   NAME <- NAMES[[kk]]
[10:20:17.310]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:17.310]                     next
[10:20:17.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:17.310]                 }
[10:20:17.310]                 NAMES <- toupper(added)
[10:20:17.310]                 for (kk in seq_along(NAMES)) {
[10:20:17.310]                   name <- added[[kk]]
[10:20:17.310]                   NAME <- NAMES[[kk]]
[10:20:17.310]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:17.310]                     next
[10:20:17.310]                   args[[name]] <- ""
[10:20:17.310]                 }
[10:20:17.310]                 NAMES <- toupper(removed)
[10:20:17.310]                 for (kk in seq_along(NAMES)) {
[10:20:17.310]                   name <- removed[[kk]]
[10:20:17.310]                   NAME <- NAMES[[kk]]
[10:20:17.310]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:17.310]                     next
[10:20:17.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:17.310]                 }
[10:20:17.310]                 if (length(args) > 0) 
[10:20:17.310]                   base::do.call(base::Sys.setenv, args = args)
[10:20:17.310]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:17.310]             }
[10:20:17.310]             else {
[10:20:17.310]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:17.310]             }
[10:20:17.310]             {
[10:20:17.310]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:17.310]                   0L) {
[10:20:17.310]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:17.310]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:17.310]                   base::options(opts)
[10:20:17.310]                 }
[10:20:17.310]                 {
[10:20:17.310]                   {
[10:20:17.310]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:17.310]                     NULL
[10:20:17.310]                   }
[10:20:17.310]                   options(future.plan = NULL)
[10:20:17.310]                   if (is.na(NA_character_)) 
[10:20:17.310]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:17.310]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:17.310]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:17.310]                     .init = FALSE)
[10:20:17.310]                 }
[10:20:17.310]             }
[10:20:17.310]         }
[10:20:17.310]     })
[10:20:17.310]     if (FALSE) {
[10:20:17.310]         base::sink(type = "output", split = FALSE)
[10:20:17.310]         if (NA) {
[10:20:17.310]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:17.310]         }
[10:20:17.310]         else {
[10:20:17.310]             ...future.result["stdout"] <- base::list(NULL)
[10:20:17.310]         }
[10:20:17.310]         base::close(...future.stdout)
[10:20:17.310]         ...future.stdout <- NULL
[10:20:17.310]     }
[10:20:17.310]     ...future.result$conditions <- ...future.conditions
[10:20:17.310]     ...future.result$finished <- base::Sys.time()
[10:20:17.310]     ...future.result
[10:20:17.310] }
[10:20:17.312] assign_globals() ...
[10:20:17.313] List of 5
[10:20:17.313]  $ ...future.FUN            :function (x, y)  
[10:20:17.313]  $ MoreArgs                 : NULL
[10:20:17.313]  $ ...future.elements_ii    :List of 2
[10:20:17.313]   ..$ :List of 1
[10:20:17.313]   .. ..$ : int 1
[10:20:17.313]   ..$ :List of 1
[10:20:17.313]   .. ..$ : int 0
[10:20:17.313]  $ ...future.seeds_ii       : NULL
[10:20:17.313]  $ ...future.globals.maxSize: NULL
[10:20:17.313]  - attr(*, "where")=List of 5
[10:20:17.313]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:17.313]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:20:17.313]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:17.313]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:17.313]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:17.313]  - attr(*, "resolved")= logi FALSE
[10:20:17.313]  - attr(*, "total_size")= num 1218
[10:20:17.313]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:17.313]  - attr(*, "already-done")= logi TRUE
[10:20:17.317] - reassign environment for ‘...future.FUN’
[10:20:17.318] - copied ‘...future.FUN’ to environment
[10:20:17.318] - copied ‘MoreArgs’ to environment
[10:20:17.318] - copied ‘...future.elements_ii’ to environment
[10:20:17.318] - copied ‘...future.seeds_ii’ to environment
[10:20:17.318] - copied ‘...future.globals.maxSize’ to environment
[10:20:17.318] assign_globals() ... done
[10:20:17.318] requestCore(): workers = 2
[10:20:17.320] MulticoreFuture started
[10:20:17.321] - Launch lazy future ... done
[10:20:17.321] run() for ‘MulticoreFuture’ ... done
[10:20:17.321] Created future:
[10:20:17.321] plan(): Setting new future strategy stack:
[10:20:17.322] List of future strategies:
[10:20:17.322] 1. sequential:
[10:20:17.322]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:17.322]    - tweaked: FALSE
[10:20:17.322]    - call: NULL
[10:20:17.323] plan(): nbrOfWorkers() = 1
[10:20:17.321] MulticoreFuture:
[10:20:17.321] Label: ‘future_mapply-1’
[10:20:17.321] Expression:
[10:20:17.321] {
[10:20:17.321]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:17.321]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:17.321]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:17.321]         on.exit(options(oopts), add = TRUE)
[10:20:17.321]     }
[10:20:17.321]     {
[10:20:17.321]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:17.321]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:20:17.321]         do.call(mapply, args = args)
[10:20:17.321]     }
[10:20:17.321] }
[10:20:17.321] Lazy evaluation: FALSE
[10:20:17.321] Asynchronous evaluation: TRUE
[10:20:17.321] Local evaluation: TRUE
[10:20:17.321] Environment: R_GlobalEnv
[10:20:17.321] Capture standard output: NA
[10:20:17.321] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:17.321] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:17.321] Packages: <none>
[10:20:17.321] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:17.321] Resolved: FALSE
[10:20:17.321] Value: <not collected>
[10:20:17.321] Conditions captured: <none>
[10:20:17.321] Early signaling: FALSE
[10:20:17.321] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:17.321] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:17.334] Chunk #1 of 2 ... DONE
[10:20:17.334] Chunk #2 of 2 ...
[10:20:17.335]  - Finding globals in '...' for chunk #2 ...
[10:20:17.339] getGlobalsAndPackages() ...
[10:20:17.339] Searching for globals...
[10:20:17.341] 
[10:20:17.341] Searching for globals ... DONE
[10:20:17.342] - globals: [0] <none>
[10:20:17.342] getGlobalsAndPackages() ... DONE
[10:20:17.342]    + additional globals found: [n=0] 
[10:20:17.343]    + additional namespaces needed: [n=0] 
[10:20:17.343]  - Finding globals in '...' for chunk #2 ... DONE
[10:20:17.343]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:17.344]  - seeds: <none>
[10:20:17.344]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:17.344] getGlobalsAndPackages() ...
[10:20:17.345] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:17.345] Resolving globals: FALSE
[10:20:17.346] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[10:20:17.347] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:20:17.348] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:17.348] 
[10:20:17.348] getGlobalsAndPackages() ... DONE
[10:20:17.349] run() for ‘Future’ ...
[10:20:17.349] - state: ‘created’
[10:20:17.349] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:20:17.353] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:17.353] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:20:17.353]   - Field: ‘label’
[10:20:17.353]   - Field: ‘local’
[10:20:17.353]   - Field: ‘owner’
[10:20:17.353]   - Field: ‘envir’
[10:20:17.354]   - Field: ‘workers’
[10:20:17.354]   - Field: ‘packages’
[10:20:17.354]   - Field: ‘gc’
[10:20:17.354]   - Field: ‘job’
[10:20:17.354]   - Field: ‘conditions’
[10:20:17.354]   - Field: ‘expr’
[10:20:17.354]   - Field: ‘uuid’
[10:20:17.354]   - Field: ‘seed’
[10:20:17.355]   - Field: ‘version’
[10:20:17.355]   - Field: ‘result’
[10:20:17.355]   - Field: ‘asynchronous’
[10:20:17.355]   - Field: ‘calls’
[10:20:17.355]   - Field: ‘globals’
[10:20:17.355]   - Field: ‘stdout’
[10:20:17.355]   - Field: ‘earlySignal’
[10:20:17.356]   - Field: ‘lazy’
[10:20:17.356]   - Field: ‘state’
[10:20:17.356] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:20:17.356] - Launch lazy future ...
[10:20:17.356] Packages needed by the future expression (n = 0): <none>
[10:20:17.356] Packages needed by future strategies (n = 0): <none>
[10:20:17.357] {
[10:20:17.357]     {
[10:20:17.357]         {
[10:20:17.357]             ...future.startTime <- base::Sys.time()
[10:20:17.357]             {
[10:20:17.357]                 {
[10:20:17.357]                   {
[10:20:17.357]                     {
[10:20:17.357]                       base::local({
[10:20:17.357]                         has_future <- base::requireNamespace("future", 
[10:20:17.357]                           quietly = TRUE)
[10:20:17.357]                         if (has_future) {
[10:20:17.357]                           ns <- base::getNamespace("future")
[10:20:17.357]                           version <- ns[[".package"]][["version"]]
[10:20:17.357]                           if (is.null(version)) 
[10:20:17.357]                             version <- utils::packageVersion("future")
[10:20:17.357]                         }
[10:20:17.357]                         else {
[10:20:17.357]                           version <- NULL
[10:20:17.357]                         }
[10:20:17.357]                         if (!has_future || version < "1.8.0") {
[10:20:17.357]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:17.357]                             "", base::R.version$version.string), 
[10:20:17.357]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:17.357]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:17.357]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:17.357]                               "release", "version")], collapse = " "), 
[10:20:17.357]                             hostname = base::Sys.info()[["nodename"]])
[10:20:17.357]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:17.357]                             info)
[10:20:17.357]                           info <- base::paste(info, collapse = "; ")
[10:20:17.357]                           if (!has_future) {
[10:20:17.357]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:17.357]                               info)
[10:20:17.357]                           }
[10:20:17.357]                           else {
[10:20:17.357]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:17.357]                               info, version)
[10:20:17.357]                           }
[10:20:17.357]                           base::stop(msg)
[10:20:17.357]                         }
[10:20:17.357]                       })
[10:20:17.357]                     }
[10:20:17.357]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:17.357]                     base::options(mc.cores = 1L)
[10:20:17.357]                   }
[10:20:17.357]                   ...future.strategy.old <- future::plan("list")
[10:20:17.357]                   options(future.plan = NULL)
[10:20:17.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:17.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:17.357]                 }
[10:20:17.357]                 ...future.workdir <- getwd()
[10:20:17.357]             }
[10:20:17.357]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:17.357]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:17.357]         }
[10:20:17.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:17.357]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:17.357]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:17.357]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:17.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:17.357]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:17.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:17.357]             base::names(...future.oldOptions))
[10:20:17.357]     }
[10:20:17.357]     if (TRUE) {
[10:20:17.357]     }
[10:20:17.357]     else {
[10:20:17.357]         if (NA) {
[10:20:17.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:17.357]                 open = "w")
[10:20:17.357]         }
[10:20:17.357]         else {
[10:20:17.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:17.357]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:17.357]         }
[10:20:17.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:17.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:17.357]             base::sink(type = "output", split = FALSE)
[10:20:17.357]             base::close(...future.stdout)
[10:20:17.357]         }, add = TRUE)
[10:20:17.357]     }
[10:20:17.357]     ...future.frame <- base::sys.nframe()
[10:20:17.357]     ...future.conditions <- base::list()
[10:20:17.357]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:17.357]     if (FALSE) {
[10:20:17.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:17.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:17.357]     }
[10:20:17.357]     ...future.result <- base::tryCatch({
[10:20:17.357]         base::withCallingHandlers({
[10:20:17.357]             ...future.value <- base::withVisible(base::local({
[10:20:17.357]                 withCallingHandlers({
[10:20:17.357]                   {
[10:20:17.357]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:17.357]                     if (!identical(...future.globals.maxSize.org, 
[10:20:17.357]                       ...future.globals.maxSize)) {
[10:20:17.357]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:17.357]                       on.exit(options(oopts), add = TRUE)
[10:20:17.357]                     }
[10:20:17.357]                     {
[10:20:17.357]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:17.357]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:20:17.357]                         USE.NAMES = FALSE)
[10:20:17.357]                       do.call(mapply, args = args)
[10:20:17.357]                     }
[10:20:17.357]                   }
[10:20:17.357]                 }, immediateCondition = function(cond) {
[10:20:17.357]                   save_rds <- function (object, pathname, ...) 
[10:20:17.357]                   {
[10:20:17.357]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:20:17.357]                     if (file_test("-f", pathname_tmp)) {
[10:20:17.357]                       fi_tmp <- file.info(pathname_tmp)
[10:20:17.357]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:20:17.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:17.357]                         fi_tmp[["mtime"]])
[10:20:17.357]                     }
[10:20:17.357]                     tryCatch({
[10:20:17.357]                       saveRDS(object, file = pathname_tmp, ...)
[10:20:17.357]                     }, error = function(ex) {
[10:20:17.357]                       msg <- conditionMessage(ex)
[10:20:17.357]                       fi_tmp <- file.info(pathname_tmp)
[10:20:17.357]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:20:17.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:17.357]                         fi_tmp[["mtime"]], msg)
[10:20:17.357]                       ex$message <- msg
[10:20:17.357]                       stop(ex)
[10:20:17.357]                     })
[10:20:17.357]                     stopifnot(file_test("-f", pathname_tmp))
[10:20:17.357]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:20:17.357]                     if (!res || file_test("-f", pathname_tmp)) {
[10:20:17.357]                       fi_tmp <- file.info(pathname_tmp)
[10:20:17.357]                       fi <- file.info(pathname)
[10:20:17.357]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:20:17.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:20:17.357]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:20:17.357]                         fi[["size"]], fi[["mtime"]])
[10:20:17.357]                       stop(msg)
[10:20:17.357]                     }
[10:20:17.357]                     invisible(pathname)
[10:20:17.357]                   }
[10:20:17.357]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:20:17.357]                     rootPath = tempdir()) 
[10:20:17.357]                   {
[10:20:17.357]                     obj <- list(time = Sys.time(), condition = cond)
[10:20:17.357]                     file <- tempfile(pattern = class(cond)[1], 
[10:20:17.357]                       tmpdir = path, fileext = ".rds")
[10:20:17.357]                     save_rds(obj, file)
[10:20:17.357]                   }
[10:20:17.357]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8Z8Jdg/.future/immediateConditions")
[10:20:17.357]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:17.357]                   {
[10:20:17.357]                     inherits <- base::inherits
[10:20:17.357]                     invokeRestart <- base::invokeRestart
[10:20:17.357]                     is.null <- base::is.null
[10:20:17.357]                     muffled <- FALSE
[10:20:17.357]                     if (inherits(cond, "message")) {
[10:20:17.357]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:17.357]                       if (muffled) 
[10:20:17.357]                         invokeRestart("muffleMessage")
[10:20:17.357]                     }
[10:20:17.357]                     else if (inherits(cond, "warning")) {
[10:20:17.357]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:17.357]                       if (muffled) 
[10:20:17.357]                         invokeRestart("muffleWarning")
[10:20:17.357]                     }
[10:20:17.357]                     else if (inherits(cond, "condition")) {
[10:20:17.357]                       if (!is.null(pattern)) {
[10:20:17.357]                         computeRestarts <- base::computeRestarts
[10:20:17.357]                         grepl <- base::grepl
[10:20:17.357]                         restarts <- computeRestarts(cond)
[10:20:17.357]                         for (restart in restarts) {
[10:20:17.357]                           name <- restart$name
[10:20:17.357]                           if (is.null(name)) 
[10:20:17.357]                             next
[10:20:17.357]                           if (!grepl(pattern, name)) 
[10:20:17.357]                             next
[10:20:17.357]                           invokeRestart(restart)
[10:20:17.357]                           muffled <- TRUE
[10:20:17.357]                           break
[10:20:17.357]                         }
[10:20:17.357]                       }
[10:20:17.357]                     }
[10:20:17.357]                     invisible(muffled)
[10:20:17.357]                   }
[10:20:17.357]                   muffleCondition(cond)
[10:20:17.357]                 })
[10:20:17.357]             }))
[10:20:17.357]             future::FutureResult(value = ...future.value$value, 
[10:20:17.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:17.357]                   ...future.rng), globalenv = if (FALSE) 
[10:20:17.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:17.357]                     ...future.globalenv.names))
[10:20:17.357]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:17.357]         }, condition = base::local({
[10:20:17.357]             c <- base::c
[10:20:17.357]             inherits <- base::inherits
[10:20:17.357]             invokeRestart <- base::invokeRestart
[10:20:17.357]             length <- base::length
[10:20:17.357]             list <- base::list
[10:20:17.357]             seq.int <- base::seq.int
[10:20:17.357]             signalCondition <- base::signalCondition
[10:20:17.357]             sys.calls <- base::sys.calls
[10:20:17.357]             `[[` <- base::`[[`
[10:20:17.357]             `+` <- base::`+`
[10:20:17.357]             `<<-` <- base::`<<-`
[10:20:17.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:17.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:17.357]                   3L)]
[10:20:17.357]             }
[10:20:17.357]             function(cond) {
[10:20:17.357]                 is_error <- inherits(cond, "error")
[10:20:17.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:17.357]                   NULL)
[10:20:17.357]                 if (is_error) {
[10:20:17.357]                   sessionInformation <- function() {
[10:20:17.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:17.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:17.357]                       search = base::search(), system = base::Sys.info())
[10:20:17.357]                   }
[10:20:17.357]                   ...future.conditions[[length(...future.conditions) + 
[10:20:17.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:17.357]                     cond$call), session = sessionInformation(), 
[10:20:17.357]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:17.357]                   signalCondition(cond)
[10:20:17.357]                 }
[10:20:17.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:17.357]                 "immediateCondition"))) {
[10:20:17.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:17.357]                   ...future.conditions[[length(...future.conditions) + 
[10:20:17.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:17.357]                   if (TRUE && !signal) {
[10:20:17.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:17.357]                     {
[10:20:17.357]                       inherits <- base::inherits
[10:20:17.357]                       invokeRestart <- base::invokeRestart
[10:20:17.357]                       is.null <- base::is.null
[10:20:17.357]                       muffled <- FALSE
[10:20:17.357]                       if (inherits(cond, "message")) {
[10:20:17.357]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:17.357]                         if (muffled) 
[10:20:17.357]                           invokeRestart("muffleMessage")
[10:20:17.357]                       }
[10:20:17.357]                       else if (inherits(cond, "warning")) {
[10:20:17.357]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:17.357]                         if (muffled) 
[10:20:17.357]                           invokeRestart("muffleWarning")
[10:20:17.357]                       }
[10:20:17.357]                       else if (inherits(cond, "condition")) {
[10:20:17.357]                         if (!is.null(pattern)) {
[10:20:17.357]                           computeRestarts <- base::computeRestarts
[10:20:17.357]                           grepl <- base::grepl
[10:20:17.357]                           restarts <- computeRestarts(cond)
[10:20:17.357]                           for (restart in restarts) {
[10:20:17.357]                             name <- restart$name
[10:20:17.357]                             if (is.null(name)) 
[10:20:17.357]                               next
[10:20:17.357]                             if (!grepl(pattern, name)) 
[10:20:17.357]                               next
[10:20:17.357]                             invokeRestart(restart)
[10:20:17.357]                             muffled <- TRUE
[10:20:17.357]                             break
[10:20:17.357]                           }
[10:20:17.357]                         }
[10:20:17.357]                       }
[10:20:17.357]                       invisible(muffled)
[10:20:17.357]                     }
[10:20:17.357]                     muffleCondition(cond, pattern = "^muffle")
[10:20:17.357]                   }
[10:20:17.357]                 }
[10:20:17.357]                 else {
[10:20:17.357]                   if (TRUE) {
[10:20:17.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:17.357]                     {
[10:20:17.357]                       inherits <- base::inherits
[10:20:17.357]                       invokeRestart <- base::invokeRestart
[10:20:17.357]                       is.null <- base::is.null
[10:20:17.357]                       muffled <- FALSE
[10:20:17.357]                       if (inherits(cond, "message")) {
[10:20:17.357]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:17.357]                         if (muffled) 
[10:20:17.357]                           invokeRestart("muffleMessage")
[10:20:17.357]                       }
[10:20:17.357]                       else if (inherits(cond, "warning")) {
[10:20:17.357]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:17.357]                         if (muffled) 
[10:20:17.357]                           invokeRestart("muffleWarning")
[10:20:17.357]                       }
[10:20:17.357]                       else if (inherits(cond, "condition")) {
[10:20:17.357]                         if (!is.null(pattern)) {
[10:20:17.357]                           computeRestarts <- base::computeRestarts
[10:20:17.357]                           grepl <- base::grepl
[10:20:17.357]                           restarts <- computeRestarts(cond)
[10:20:17.357]                           for (restart in restarts) {
[10:20:17.357]                             name <- restart$name
[10:20:17.357]                             if (is.null(name)) 
[10:20:17.357]                               next
[10:20:17.357]                             if (!grepl(pattern, name)) 
[10:20:17.357]                               next
[10:20:17.357]                             invokeRestart(restart)
[10:20:17.357]                             muffled <- TRUE
[10:20:17.357]                             break
[10:20:17.357]                           }
[10:20:17.357]                         }
[10:20:17.357]                       }
[10:20:17.357]                       invisible(muffled)
[10:20:17.357]                     }
[10:20:17.357]                     muffleCondition(cond, pattern = "^muffle")
[10:20:17.357]                   }
[10:20:17.357]                 }
[10:20:17.357]             }
[10:20:17.357]         }))
[10:20:17.357]     }, error = function(ex) {
[10:20:17.357]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:17.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:17.357]                 ...future.rng), started = ...future.startTime, 
[10:20:17.357]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:17.357]             version = "1.8"), class = "FutureResult")
[10:20:17.357]     }, finally = {
[10:20:17.357]         if (!identical(...future.workdir, getwd())) 
[10:20:17.357]             setwd(...future.workdir)
[10:20:17.357]         {
[10:20:17.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:17.357]                 ...future.oldOptions$nwarnings <- NULL
[10:20:17.357]             }
[10:20:17.357]             base::options(...future.oldOptions)
[10:20:17.357]             if (.Platform$OS.type == "windows") {
[10:20:17.357]                 old_names <- names(...future.oldEnvVars)
[10:20:17.357]                 envs <- base::Sys.getenv()
[10:20:17.357]                 names <- names(envs)
[10:20:17.357]                 common <- intersect(names, old_names)
[10:20:17.357]                 added <- setdiff(names, old_names)
[10:20:17.357]                 removed <- setdiff(old_names, names)
[10:20:17.357]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:17.357]                   envs[common]]
[10:20:17.357]                 NAMES <- toupper(changed)
[10:20:17.357]                 args <- list()
[10:20:17.357]                 for (kk in seq_along(NAMES)) {
[10:20:17.357]                   name <- changed[[kk]]
[10:20:17.357]                   NAME <- NAMES[[kk]]
[10:20:17.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:17.357]                     next
[10:20:17.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:17.357]                 }
[10:20:17.357]                 NAMES <- toupper(added)
[10:20:17.357]                 for (kk in seq_along(NAMES)) {
[10:20:17.357]                   name <- added[[kk]]
[10:20:17.357]                   NAME <- NAMES[[kk]]
[10:20:17.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:17.357]                     next
[10:20:17.357]                   args[[name]] <- ""
[10:20:17.357]                 }
[10:20:17.357]                 NAMES <- toupper(removed)
[10:20:17.357]                 for (kk in seq_along(NAMES)) {
[10:20:17.357]                   name <- removed[[kk]]
[10:20:17.357]                   NAME <- NAMES[[kk]]
[10:20:17.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:17.357]                     next
[10:20:17.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:17.357]                 }
[10:20:17.357]                 if (length(args) > 0) 
[10:20:17.357]                   base::do.call(base::Sys.setenv, args = args)
[10:20:17.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:17.357]             }
[10:20:17.357]             else {
[10:20:17.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:17.357]             }
[10:20:17.357]             {
[10:20:17.357]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:17.357]                   0L) {
[10:20:17.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:17.357]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:17.357]                   base::options(opts)
[10:20:17.357]                 }
[10:20:17.357]                 {
[10:20:17.357]                   {
[10:20:17.357]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:17.357]                     NULL
[10:20:17.357]                   }
[10:20:17.357]                   options(future.plan = NULL)
[10:20:17.357]                   if (is.na(NA_character_)) 
[10:20:17.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:17.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:17.357]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:17.357]                     .init = FALSE)
[10:20:17.357]                 }
[10:20:17.357]             }
[10:20:17.357]         }
[10:20:17.357]     })
[10:20:17.357]     if (FALSE) {
[10:20:17.357]         base::sink(type = "output", split = FALSE)
[10:20:17.357]         if (NA) {
[10:20:17.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:17.357]         }
[10:20:17.357]         else {
[10:20:17.357]             ...future.result["stdout"] <- base::list(NULL)
[10:20:17.357]         }
[10:20:17.357]         base::close(...future.stdout)
[10:20:17.357]         ...future.stdout <- NULL
[10:20:17.357]     }
[10:20:17.357]     ...future.result$conditions <- ...future.conditions
[10:20:17.357]     ...future.result$finished <- base::Sys.time()
[10:20:17.357]     ...future.result
[10:20:17.357] }
[10:20:17.360] assign_globals() ...
[10:20:17.360] List of 5
[10:20:17.360]  $ ...future.FUN            :function (x, y)  
[10:20:17.360]  $ MoreArgs                 : NULL
[10:20:17.360]  $ ...future.elements_ii    :List of 2
[10:20:17.360]   ..$ :List of 1
[10:20:17.360]   .. ..$ : int 0
[10:20:17.360]   ..$ :List of 1
[10:20:17.360]   .. ..$ : int 1
[10:20:17.360]  $ ...future.seeds_ii       : NULL
[10:20:17.360]  $ ...future.globals.maxSize: NULL
[10:20:17.360]  - attr(*, "where")=List of 5
[10:20:17.360]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:20:17.360]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:20:17.360]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:20:17.360]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:20:17.360]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:20:17.360]  - attr(*, "resolved")= logi FALSE
[10:20:17.360]  - attr(*, "total_size")= num 1218
[10:20:17.360]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:17.360]  - attr(*, "already-done")= logi TRUE
[10:20:17.366] - reassign environment for ‘...future.FUN’
[10:20:17.367] - copied ‘...future.FUN’ to environment
[10:20:17.367] - copied ‘MoreArgs’ to environment
[10:20:17.367] - copied ‘...future.elements_ii’ to environment
[10:20:17.367] - copied ‘...future.seeds_ii’ to environment
[10:20:17.367] - copied ‘...future.globals.maxSize’ to environment
[10:20:17.367] assign_globals() ... done
[10:20:17.367] requestCore(): workers = 2
[10:20:17.370] MulticoreFuture started
[10:20:17.370] - Launch lazy future ... done
[10:20:17.370] run() for ‘MulticoreFuture’ ... done
[10:20:17.371] Created future:
[10:20:17.371] plan(): Setting new future strategy stack:
[10:20:17.371] List of future strategies:
[10:20:17.371] 1. sequential:
[10:20:17.371]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:17.371]    - tweaked: FALSE
[10:20:17.371]    - call: NULL
[10:20:17.372] plan(): nbrOfWorkers() = 1
[10:20:17.374] plan(): Setting new future strategy stack:
[10:20:17.374] List of future strategies:
[10:20:17.374] 1. multicore:
[10:20:17.374]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:20:17.374]    - tweaked: FALSE
[10:20:17.374]    - call: plan(strategy)
[10:20:17.378] plan(): nbrOfWorkers() = 2
[10:20:17.371] MulticoreFuture:
[10:20:17.371] Label: ‘future_mapply-2’
[10:20:17.371] Expression:
[10:20:17.371] {
[10:20:17.371]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:17.371]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:17.371]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:17.371]         on.exit(options(oopts), add = TRUE)
[10:20:17.371]     }
[10:20:17.371]     {
[10:20:17.371]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:17.371]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:20:17.371]         do.call(mapply, args = args)
[10:20:17.371]     }
[10:20:17.371] }
[10:20:17.371] Lazy evaluation: FALSE
[10:20:17.371] Asynchronous evaluation: TRUE
[10:20:17.371] Local evaluation: TRUE
[10:20:17.371] Environment: R_GlobalEnv
[10:20:17.371] Capture standard output: NA
[10:20:17.371] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:17.371] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:17.371] Packages: <none>
[10:20:17.371] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:17.371] Resolved: TRUE
[10:20:17.371] Value: <not collected>
[10:20:17.371] Conditions captured: <none>
[10:20:17.371] Early signaling: FALSE
[10:20:17.371] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:17.371] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:17.379] Chunk #2 of 2 ... DONE
[10:20:17.379] Launching 2 futures (chunks) ... DONE
[10:20:17.379] Resolving 2 futures (chunks) ...
[10:20:17.379] resolve() on list ...
[10:20:17.379]  recursive: 0
[10:20:17.380]  length: 2
[10:20:17.380] 
[10:20:17.390] Future #2
[10:20:17.391] result() for MulticoreFuture ...
[10:20:17.391] result() for MulticoreFuture ...
[10:20:17.392] result() for MulticoreFuture ... done
[10:20:17.392] result() for MulticoreFuture ... done
[10:20:17.392] result() for MulticoreFuture ...
[10:20:17.392] result() for MulticoreFuture ... done
[10:20:17.392] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:20:17.392] - nx: 2
[10:20:17.393] - relay: TRUE
[10:20:17.393] - stdout: TRUE
[10:20:17.393] - signal: TRUE
[10:20:17.393] - resignal: FALSE
[10:20:17.393] - force: TRUE
[10:20:17.393] - relayed: [n=2] FALSE, FALSE
[10:20:17.393] - queued futures: [n=2] FALSE, FALSE
[10:20:17.393]  - until=1
[10:20:17.393]  - relaying element #1
[10:20:17.394] - relayed: [n=2] FALSE, FALSE
[10:20:17.394] - queued futures: [n=2] FALSE, TRUE
[10:20:17.394] signalConditionsASAP(NULL, pos=2) ... done
[10:20:17.394]  length: 1 (resolved future 2)
[10:20:17.826] plan(): Setting new future strategy stack:
[10:20:17.826] List of future strategies:
[10:20:17.826] 1. multicore:
[10:20:17.826]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:20:17.826]    - tweaked: FALSE
[10:20:17.826]    - call: plan(strategy)
[10:20:17.832] plan(): nbrOfWorkers() = 2
[10:20:17.833] Future #1
[10:20:17.833] result() for MulticoreFuture ...
[10:20:17.834] result() for MulticoreFuture ...
[10:20:17.834] result() for MulticoreFuture ... done
[10:20:17.834] result() for MulticoreFuture ... done
[10:20:17.834] result() for MulticoreFuture ...
[10:20:17.834] result() for MulticoreFuture ... done
[10:20:17.835] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:20:17.835] - nx: 2
[10:20:17.835] - relay: TRUE
[10:20:17.835] - stdout: TRUE
[10:20:17.835] - signal: TRUE
[10:20:17.835] - resignal: FALSE
[10:20:17.835] - force: TRUE
[10:20:17.835] - relayed: [n=2] FALSE, FALSE
[10:20:17.836] - queued futures: [n=2] FALSE, TRUE
[10:20:17.836]  - until=1
[10:20:17.838]  - relaying element #1
[10:20:17.838] result() for MulticoreFuture ...
[10:20:17.839] result() for MulticoreFuture ... done
[10:20:17.839] result() for MulticoreFuture ...
[10:20:17.839] result() for MulticoreFuture ... done
[10:20:17.839] result() for MulticoreFuture ...
[10:20:17.839] result() for MulticoreFuture ... done
[10:20:17.840] result() for MulticoreFuture ...
[10:20:17.840] result() for MulticoreFuture ... done
[10:20:17.840] - relayed: [n=2] TRUE, FALSE
[10:20:17.840] - queued futures: [n=2] TRUE, TRUE
[10:20:17.840] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:20:17.840]  length: 0 (resolved future 1)
[10:20:17.841] Relaying remaining futures
[10:20:17.841] signalConditionsASAP(NULL, pos=0) ...
[10:20:17.841] - nx: 2
[10:20:17.841] - relay: TRUE
[10:20:17.841] - stdout: TRUE
[10:20:17.841] - signal: TRUE
[10:20:17.841] - resignal: FALSE
[10:20:17.842] - force: TRUE
[10:20:17.842] - relayed: [n=2] TRUE, FALSE
[10:20:17.842] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:20:17.842]  - relaying element #2
[10:20:17.842] result() for MulticoreFuture ...
[10:20:17.842] result() for MulticoreFuture ... done
[10:20:17.843] result() for MulticoreFuture ...
[10:20:17.843] result() for MulticoreFuture ... done
[10:20:17.843] result() for MulticoreFuture ...
[10:20:17.843] result() for MulticoreFuture ... done
[10:20:17.843] result() for MulticoreFuture ...
[10:20:17.843] result() for MulticoreFuture ... done
[10:20:17.844] - relayed: [n=2] TRUE, TRUE
[10:20:17.844] - queued futures: [n=2] TRUE, TRUE
[10:20:17.844] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[10:20:17.844] resolve() on list ... DONE
[10:20:17.844] result() for MulticoreFuture ...
[10:20:17.844] result() for MulticoreFuture ... done
[10:20:17.844] result() for MulticoreFuture ...
[10:20:17.844] result() for MulticoreFuture ... done
[10:20:17.845] result() for MulticoreFuture ...
[10:20:17.845] result() for MulticoreFuture ... done
[10:20:17.845] result() for MulticoreFuture ...
[10:20:17.845] result() for MulticoreFuture ... done
[10:20:17.845]  - Number of value chunks collected: 2
[10:20:17.845] Resolving 2 futures (chunks) ... DONE
[10:20:17.845] Reducing values from 2 chunks ...
[10:20:17.845]  - Number of values collected after concatenation: 2
[10:20:17.845]  - Number of values expected: 2
[10:20:17.845] Reducing values from 2 chunks ... DONE
[10:20:17.846] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[10:20:17.846] plan(): Setting new future strategy stack:
[10:20:17.846] List of future strategies:
[10:20:17.846] 1. multisession:
[10:20:17.846]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:20:17.846]    - tweaked: FALSE
[10:20:17.846]    - call: plan(strategy)
[10:20:17.847] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:20:17.847] multisession:
[10:20:17.847] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:20:17.847] - tweaked: FALSE
[10:20:17.847] - call: plan(strategy)
[10:20:17.851] getGlobalsAndPackages() ...
[10:20:17.851] Not searching for globals
[10:20:17.851] - globals: [0] <none>
[10:20:17.851] getGlobalsAndPackages() ... DONE
[10:20:18.338] Packages needed by the future expression (n = 0): <none>
[10:20:18.338] Packages needed by future strategies (n = 0): <none>
[10:20:18.338] {
[10:20:18.338]     {
[10:20:18.338]         {
[10:20:18.338]             ...future.startTime <- base::Sys.time()
[10:20:18.338]             {
[10:20:18.338]                 {
[10:20:18.338]                   {
[10:20:18.338]                     {
[10:20:18.338]                       base::local({
[10:20:18.338]                         has_future <- base::requireNamespace("future", 
[10:20:18.338]                           quietly = TRUE)
[10:20:18.338]                         if (has_future) {
[10:20:18.338]                           ns <- base::getNamespace("future")
[10:20:18.338]                           version <- ns[[".package"]][["version"]]
[10:20:18.338]                           if (is.null(version)) 
[10:20:18.338]                             version <- utils::packageVersion("future")
[10:20:18.338]                         }
[10:20:18.338]                         else {
[10:20:18.338]                           version <- NULL
[10:20:18.338]                         }
[10:20:18.338]                         if (!has_future || version < "1.8.0") {
[10:20:18.338]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:18.338]                             "", base::R.version$version.string), 
[10:20:18.338]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:18.338]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:18.338]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:18.338]                               "release", "version")], collapse = " "), 
[10:20:18.338]                             hostname = base::Sys.info()[["nodename"]])
[10:20:18.338]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:18.338]                             info)
[10:20:18.338]                           info <- base::paste(info, collapse = "; ")
[10:20:18.338]                           if (!has_future) {
[10:20:18.338]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:18.338]                               info)
[10:20:18.338]                           }
[10:20:18.338]                           else {
[10:20:18.338]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:18.338]                               info, version)
[10:20:18.338]                           }
[10:20:18.338]                           base::stop(msg)
[10:20:18.338]                         }
[10:20:18.338]                       })
[10:20:18.338]                     }
[10:20:18.338]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:18.338]                     base::options(mc.cores = 1L)
[10:20:18.338]                   }
[10:20:18.338]                   ...future.strategy.old <- future::plan("list")
[10:20:18.338]                   options(future.plan = NULL)
[10:20:18.338]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:18.338]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:18.338]                 }
[10:20:18.338]                 ...future.workdir <- getwd()
[10:20:18.338]             }
[10:20:18.338]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:18.338]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:18.338]         }
[10:20:18.338]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:18.338]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:20:18.338]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:18.338]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:18.338]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:18.338]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:18.338]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:18.338]             base::names(...future.oldOptions))
[10:20:18.338]     }
[10:20:18.338]     if (FALSE) {
[10:20:18.338]     }
[10:20:18.338]     else {
[10:20:18.338]         if (TRUE) {
[10:20:18.338]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:18.338]                 open = "w")
[10:20:18.338]         }
[10:20:18.338]         else {
[10:20:18.338]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:18.338]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:18.338]         }
[10:20:18.338]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:18.338]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:18.338]             base::sink(type = "output", split = FALSE)
[10:20:18.338]             base::close(...future.stdout)
[10:20:18.338]         }, add = TRUE)
[10:20:18.338]     }
[10:20:18.338]     ...future.frame <- base::sys.nframe()
[10:20:18.338]     ...future.conditions <- base::list()
[10:20:18.338]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:18.338]     if (FALSE) {
[10:20:18.338]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:18.338]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:18.338]     }
[10:20:18.338]     ...future.result <- base::tryCatch({
[10:20:18.338]         base::withCallingHandlers({
[10:20:18.338]             ...future.value <- base::withVisible(base::local({
[10:20:18.338]                 ...future.makeSendCondition <- base::local({
[10:20:18.338]                   sendCondition <- NULL
[10:20:18.338]                   function(frame = 1L) {
[10:20:18.338]                     if (is.function(sendCondition)) 
[10:20:18.338]                       return(sendCondition)
[10:20:18.338]                     ns <- getNamespace("parallel")
[10:20:18.338]                     if (exists("sendData", mode = "function", 
[10:20:18.338]                       envir = ns)) {
[10:20:18.338]                       parallel_sendData <- get("sendData", mode = "function", 
[10:20:18.338]                         envir = ns)
[10:20:18.338]                       envir <- sys.frame(frame)
[10:20:18.338]                       master <- NULL
[10:20:18.338]                       while (!identical(envir, .GlobalEnv) && 
[10:20:18.338]                         !identical(envir, emptyenv())) {
[10:20:18.338]                         if (exists("master", mode = "list", envir = envir, 
[10:20:18.338]                           inherits = FALSE)) {
[10:20:18.338]                           master <- get("master", mode = "list", 
[10:20:18.338]                             envir = envir, inherits = FALSE)
[10:20:18.338]                           if (inherits(master, c("SOCKnode", 
[10:20:18.338]                             "SOCK0node"))) {
[10:20:18.338]                             sendCondition <<- function(cond) {
[10:20:18.338]                               data <- list(type = "VALUE", value = cond, 
[10:20:18.338]                                 success = TRUE)
[10:20:18.338]                               parallel_sendData(master, data)
[10:20:18.338]                             }
[10:20:18.338]                             return(sendCondition)
[10:20:18.338]                           }
[10:20:18.338]                         }
[10:20:18.338]                         frame <- frame + 1L
[10:20:18.338]                         envir <- sys.frame(frame)
[10:20:18.338]                       }
[10:20:18.338]                     }
[10:20:18.338]                     sendCondition <<- function(cond) NULL
[10:20:18.338]                   }
[10:20:18.338]                 })
[10:20:18.338]                 withCallingHandlers({
[10:20:18.338]                   NA
[10:20:18.338]                 }, immediateCondition = function(cond) {
[10:20:18.338]                   sendCondition <- ...future.makeSendCondition()
[10:20:18.338]                   sendCondition(cond)
[10:20:18.338]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:18.338]                   {
[10:20:18.338]                     inherits <- base::inherits
[10:20:18.338]                     invokeRestart <- base::invokeRestart
[10:20:18.338]                     is.null <- base::is.null
[10:20:18.338]                     muffled <- FALSE
[10:20:18.338]                     if (inherits(cond, "message")) {
[10:20:18.338]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:18.338]                       if (muffled) 
[10:20:18.338]                         invokeRestart("muffleMessage")
[10:20:18.338]                     }
[10:20:18.338]                     else if (inherits(cond, "warning")) {
[10:20:18.338]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:18.338]                       if (muffled) 
[10:20:18.338]                         invokeRestart("muffleWarning")
[10:20:18.338]                     }
[10:20:18.338]                     else if (inherits(cond, "condition")) {
[10:20:18.338]                       if (!is.null(pattern)) {
[10:20:18.338]                         computeRestarts <- base::computeRestarts
[10:20:18.338]                         grepl <- base::grepl
[10:20:18.338]                         restarts <- computeRestarts(cond)
[10:20:18.338]                         for (restart in restarts) {
[10:20:18.338]                           name <- restart$name
[10:20:18.338]                           if (is.null(name)) 
[10:20:18.338]                             next
[10:20:18.338]                           if (!grepl(pattern, name)) 
[10:20:18.338]                             next
[10:20:18.338]                           invokeRestart(restart)
[10:20:18.338]                           muffled <- TRUE
[10:20:18.338]                           break
[10:20:18.338]                         }
[10:20:18.338]                       }
[10:20:18.338]                     }
[10:20:18.338]                     invisible(muffled)
[10:20:18.338]                   }
[10:20:18.338]                   muffleCondition(cond)
[10:20:18.338]                 })
[10:20:18.338]             }))
[10:20:18.338]             future::FutureResult(value = ...future.value$value, 
[10:20:18.338]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:18.338]                   ...future.rng), globalenv = if (FALSE) 
[10:20:18.338]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:18.338]                     ...future.globalenv.names))
[10:20:18.338]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:18.338]         }, condition = base::local({
[10:20:18.338]             c <- base::c
[10:20:18.338]             inherits <- base::inherits
[10:20:18.338]             invokeRestart <- base::invokeRestart
[10:20:18.338]             length <- base::length
[10:20:18.338]             list <- base::list
[10:20:18.338]             seq.int <- base::seq.int
[10:20:18.338]             signalCondition <- base::signalCondition
[10:20:18.338]             sys.calls <- base::sys.calls
[10:20:18.338]             `[[` <- base::`[[`
[10:20:18.338]             `+` <- base::`+`
[10:20:18.338]             `<<-` <- base::`<<-`
[10:20:18.338]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:18.338]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:18.338]                   3L)]
[10:20:18.338]             }
[10:20:18.338]             function(cond) {
[10:20:18.338]                 is_error <- inherits(cond, "error")
[10:20:18.338]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:18.338]                   NULL)
[10:20:18.338]                 if (is_error) {
[10:20:18.338]                   sessionInformation <- function() {
[10:20:18.338]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:18.338]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:18.338]                       search = base::search(), system = base::Sys.info())
[10:20:18.338]                   }
[10:20:18.338]                   ...future.conditions[[length(...future.conditions) + 
[10:20:18.338]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:18.338]                     cond$call), session = sessionInformation(), 
[10:20:18.338]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:18.338]                   signalCondition(cond)
[10:20:18.338]                 }
[10:20:18.338]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:18.338]                 "immediateCondition"))) {
[10:20:18.338]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:18.338]                   ...future.conditions[[length(...future.conditions) + 
[10:20:18.338]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:18.338]                   if (TRUE && !signal) {
[10:20:18.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:18.338]                     {
[10:20:18.338]                       inherits <- base::inherits
[10:20:18.338]                       invokeRestart <- base::invokeRestart
[10:20:18.338]                       is.null <- base::is.null
[10:20:18.338]                       muffled <- FALSE
[10:20:18.338]                       if (inherits(cond, "message")) {
[10:20:18.338]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:18.338]                         if (muffled) 
[10:20:18.338]                           invokeRestart("muffleMessage")
[10:20:18.338]                       }
[10:20:18.338]                       else if (inherits(cond, "warning")) {
[10:20:18.338]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:18.338]                         if (muffled) 
[10:20:18.338]                           invokeRestart("muffleWarning")
[10:20:18.338]                       }
[10:20:18.338]                       else if (inherits(cond, "condition")) {
[10:20:18.338]                         if (!is.null(pattern)) {
[10:20:18.338]                           computeRestarts <- base::computeRestarts
[10:20:18.338]                           grepl <- base::grepl
[10:20:18.338]                           restarts <- computeRestarts(cond)
[10:20:18.338]                           for (restart in restarts) {
[10:20:18.338]                             name <- restart$name
[10:20:18.338]                             if (is.null(name)) 
[10:20:18.338]                               next
[10:20:18.338]                             if (!grepl(pattern, name)) 
[10:20:18.338]                               next
[10:20:18.338]                             invokeRestart(restart)
[10:20:18.338]                             muffled <- TRUE
[10:20:18.338]                             break
[10:20:18.338]                           }
[10:20:18.338]                         }
[10:20:18.338]                       }
[10:20:18.338]                       invisible(muffled)
[10:20:18.338]                     }
[10:20:18.338]                     muffleCondition(cond, pattern = "^muffle")
[10:20:18.338]                   }
[10:20:18.338]                 }
[10:20:18.338]                 else {
[10:20:18.338]                   if (TRUE) {
[10:20:18.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:18.338]                     {
[10:20:18.338]                       inherits <- base::inherits
[10:20:18.338]                       invokeRestart <- base::invokeRestart
[10:20:18.338]                       is.null <- base::is.null
[10:20:18.338]                       muffled <- FALSE
[10:20:18.338]                       if (inherits(cond, "message")) {
[10:20:18.338]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:18.338]                         if (muffled) 
[10:20:18.338]                           invokeRestart("muffleMessage")
[10:20:18.338]                       }
[10:20:18.338]                       else if (inherits(cond, "warning")) {
[10:20:18.338]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:18.338]                         if (muffled) 
[10:20:18.338]                           invokeRestart("muffleWarning")
[10:20:18.338]                       }
[10:20:18.338]                       else if (inherits(cond, "condition")) {
[10:20:18.338]                         if (!is.null(pattern)) {
[10:20:18.338]                           computeRestarts <- base::computeRestarts
[10:20:18.338]                           grepl <- base::grepl
[10:20:18.338]                           restarts <- computeRestarts(cond)
[10:20:18.338]                           for (restart in restarts) {
[10:20:18.338]                             name <- restart$name
[10:20:18.338]                             if (is.null(name)) 
[10:20:18.338]                               next
[10:20:18.338]                             if (!grepl(pattern, name)) 
[10:20:18.338]                               next
[10:20:18.338]                             invokeRestart(restart)
[10:20:18.338]                             muffled <- TRUE
[10:20:18.338]                             break
[10:20:18.338]                           }
[10:20:18.338]                         }
[10:20:18.338]                       }
[10:20:18.338]                       invisible(muffled)
[10:20:18.338]                     }
[10:20:18.338]                     muffleCondition(cond, pattern = "^muffle")
[10:20:18.338]                   }
[10:20:18.338]                 }
[10:20:18.338]             }
[10:20:18.338]         }))
[10:20:18.338]     }, error = function(ex) {
[10:20:18.338]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:18.338]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:18.338]                 ...future.rng), started = ...future.startTime, 
[10:20:18.338]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:18.338]             version = "1.8"), class = "FutureResult")
[10:20:18.338]     }, finally = {
[10:20:18.338]         if (!identical(...future.workdir, getwd())) 
[10:20:18.338]             setwd(...future.workdir)
[10:20:18.338]         {
[10:20:18.338]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:18.338]                 ...future.oldOptions$nwarnings <- NULL
[10:20:18.338]             }
[10:20:18.338]             base::options(...future.oldOptions)
[10:20:18.338]             if (.Platform$OS.type == "windows") {
[10:20:18.338]                 old_names <- names(...future.oldEnvVars)
[10:20:18.338]                 envs <- base::Sys.getenv()
[10:20:18.338]                 names <- names(envs)
[10:20:18.338]                 common <- intersect(names, old_names)
[10:20:18.338]                 added <- setdiff(names, old_names)
[10:20:18.338]                 removed <- setdiff(old_names, names)
[10:20:18.338]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:18.338]                   envs[common]]
[10:20:18.338]                 NAMES <- toupper(changed)
[10:20:18.338]                 args <- list()
[10:20:18.338]                 for (kk in seq_along(NAMES)) {
[10:20:18.338]                   name <- changed[[kk]]
[10:20:18.338]                   NAME <- NAMES[[kk]]
[10:20:18.338]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:18.338]                     next
[10:20:18.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:18.338]                 }
[10:20:18.338]                 NAMES <- toupper(added)
[10:20:18.338]                 for (kk in seq_along(NAMES)) {
[10:20:18.338]                   name <- added[[kk]]
[10:20:18.338]                   NAME <- NAMES[[kk]]
[10:20:18.338]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:18.338]                     next
[10:20:18.338]                   args[[name]] <- ""
[10:20:18.338]                 }
[10:20:18.338]                 NAMES <- toupper(removed)
[10:20:18.338]                 for (kk in seq_along(NAMES)) {
[10:20:18.338]                   name <- removed[[kk]]
[10:20:18.338]                   NAME <- NAMES[[kk]]
[10:20:18.338]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:18.338]                     next
[10:20:18.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:18.338]                 }
[10:20:18.338]                 if (length(args) > 0) 
[10:20:18.338]                   base::do.call(base::Sys.setenv, args = args)
[10:20:18.338]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:18.338]             }
[10:20:18.338]             else {
[10:20:18.338]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:18.338]             }
[10:20:18.338]             {
[10:20:18.338]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:18.338]                   0L) {
[10:20:18.338]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:18.338]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:18.338]                   base::options(opts)
[10:20:18.338]                 }
[10:20:18.338]                 {
[10:20:18.338]                   {
[10:20:18.338]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:18.338]                     NULL
[10:20:18.338]                   }
[10:20:18.338]                   options(future.plan = NULL)
[10:20:18.338]                   if (is.na(NA_character_)) 
[10:20:18.338]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:18.338]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:18.338]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:18.338]                     .init = FALSE)
[10:20:18.338]                 }
[10:20:18.338]             }
[10:20:18.338]         }
[10:20:18.338]     })
[10:20:18.338]     if (TRUE) {
[10:20:18.338]         base::sink(type = "output", split = FALSE)
[10:20:18.338]         if (TRUE) {
[10:20:18.338]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:18.338]         }
[10:20:18.338]         else {
[10:20:18.338]             ...future.result["stdout"] <- base::list(NULL)
[10:20:18.338]         }
[10:20:18.338]         base::close(...future.stdout)
[10:20:18.338]         ...future.stdout <- NULL
[10:20:18.338]     }
[10:20:18.338]     ...future.result$conditions <- ...future.conditions
[10:20:18.338]     ...future.result$finished <- base::Sys.time()
[10:20:18.338]     ...future.result
[10:20:18.338] }
[10:20:18.390] MultisessionFuture started
[10:20:18.391] result() for ClusterFuture ...
[10:20:18.391] receiveMessageFromWorker() for ClusterFuture ...
[10:20:18.392] - Validating connection of MultisessionFuture
[10:20:18.423] - received message: FutureResult
[10:20:18.423] - Received FutureResult
[10:20:18.423] - Erased future from FutureRegistry
[10:20:18.423] result() for ClusterFuture ...
[10:20:18.424] - result already collected: FutureResult
[10:20:18.424] result() for ClusterFuture ... done
[10:20:18.424] receiveMessageFromWorker() for ClusterFuture ... done
[10:20:18.424] result() for ClusterFuture ... done
[10:20:18.424] result() for ClusterFuture ...
[10:20:18.424] - result already collected: FutureResult
[10:20:18.424] result() for ClusterFuture ... done
[10:20:18.424] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:20:18.426] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[10:20:18.426] future_lapply() ...
[10:20:18.428] Number of chunks: 2
[10:20:18.428] getGlobalsAndPackagesXApply() ...
[10:20:18.428]  - future.globals: TRUE
[10:20:18.429] getGlobalsAndPackages() ...
[10:20:18.429] Searching for globals...
[10:20:18.430] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:20:18.430] Searching for globals ... DONE
[10:20:18.430] Resolving globals: FALSE
[10:20:18.431] The total size of the 1 globals is 841 bytes (841 bytes)
[10:20:18.431] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[10:20:18.431] - globals: [1] ‘FUN’
[10:20:18.431] 
[10:20:18.431] getGlobalsAndPackages() ... DONE
[10:20:18.431]  - globals found/used: [n=1] ‘FUN’
[10:20:18.432]  - needed namespaces: [n=0] 
[10:20:18.432] Finding globals ... DONE
[10:20:18.432]  - use_args: TRUE
[10:20:18.432]  - Getting '...' globals ...
[10:20:18.432] resolve() on list ...
[10:20:18.432]  recursive: 0
[10:20:18.432]  length: 1
[10:20:18.432]  elements: ‘...’
[10:20:18.432]  length: 0 (resolved future 1)
[10:20:18.433] resolve() on list ... DONE
[10:20:18.433]    - '...' content: [n=0] 
[10:20:18.433] List of 1
[10:20:18.433]  $ ...: list()
[10:20:18.433]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:18.433]  - attr(*, "where")=List of 1
[10:20:18.433]   ..$ ...:<environment: 0x557fc1f425c0> 
[10:20:18.433]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:18.433]  - attr(*, "resolved")= logi TRUE
[10:20:18.433]  - attr(*, "total_size")= num NA
[10:20:18.435]  - Getting '...' globals ... DONE
[10:20:18.435] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:20:18.435] List of 2
[10:20:18.435]  $ ...future.FUN:function (x)  
[10:20:18.435]  $ ...          : list()
[10:20:18.435]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:18.435]  - attr(*, "where")=List of 2
[10:20:18.435]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:18.435]   ..$ ...          :<environment: 0x557fc1f425c0> 
[10:20:18.435]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:18.435]  - attr(*, "resolved")= logi FALSE
[10:20:18.435]  - attr(*, "total_size")= num 5632
[10:20:18.438] Packages to be attached in all futures: [n=0] 
[10:20:18.438] getGlobalsAndPackagesXApply() ... DONE
[10:20:18.438] Number of futures (= number of chunks): 2
[10:20:18.439] Launching 2 futures (chunks) ...
[10:20:18.439] Chunk #1 of 2 ...
[10:20:18.439]  - Finding globals in 'X' for chunk #1 ...
[10:20:18.439] getGlobalsAndPackages() ...
[10:20:18.439] Searching for globals...
[10:20:18.439] 
[10:20:18.439] Searching for globals ... DONE
[10:20:18.439] - globals: [0] <none>
[10:20:18.439] getGlobalsAndPackages() ... DONE
[10:20:18.440]    + additional globals found: [n=0] 
[10:20:18.440]    + additional namespaces needed: [n=0] 
[10:20:18.440]  - Finding globals in 'X' for chunk #1 ... DONE
[10:20:18.440]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:18.440]  - seeds: <none>
[10:20:18.440]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:18.440] getGlobalsAndPackages() ...
[10:20:18.440] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:18.440] Resolving globals: FALSE
[10:20:18.440] Tweak future expression to call with '...' arguments ...
[10:20:18.441] {
[10:20:18.441]     do.call(function(...) {
[10:20:18.441]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:18.441]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:18.441]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:18.441]             on.exit(options(oopts), add = TRUE)
[10:20:18.441]         }
[10:20:18.441]         {
[10:20:18.441]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:18.441]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:18.441]                 ...future.FUN(...future.X_jj, ...)
[10:20:18.441]             })
[10:20:18.441]         }
[10:20:18.441]     }, args = future.call.arguments)
[10:20:18.441] }
[10:20:18.441] Tweak future expression to call with '...' arguments ... DONE
[10:20:18.441] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:18.441] 
[10:20:18.441] getGlobalsAndPackages() ... DONE
[10:20:18.442] run() for ‘Future’ ...
[10:20:18.442] - state: ‘created’
[10:20:18.442] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:20:18.457] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:18.457] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:20:18.457]   - Field: ‘node’
[10:20:18.457]   - Field: ‘label’
[10:20:18.457]   - Field: ‘local’
[10:20:18.458]   - Field: ‘owner’
[10:20:18.458]   - Field: ‘envir’
[10:20:18.458]   - Field: ‘workers’
[10:20:18.458]   - Field: ‘packages’
[10:20:18.458]   - Field: ‘gc’
[10:20:18.458]   - Field: ‘conditions’
[10:20:18.458]   - Field: ‘persistent’
[10:20:18.458]   - Field: ‘expr’
[10:20:18.458]   - Field: ‘uuid’
[10:20:18.458]   - Field: ‘seed’
[10:20:18.459]   - Field: ‘version’
[10:20:18.459]   - Field: ‘result’
[10:20:18.459]   - Field: ‘asynchronous’
[10:20:18.459]   - Field: ‘calls’
[10:20:18.459]   - Field: ‘globals’
[10:20:18.459]   - Field: ‘stdout’
[10:20:18.459]   - Field: ‘earlySignal’
[10:20:18.459]   - Field: ‘lazy’
[10:20:18.459]   - Field: ‘state’
[10:20:18.459] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:20:18.460] - Launch lazy future ...
[10:20:18.460] Packages needed by the future expression (n = 0): <none>
[10:20:18.460] Packages needed by future strategies (n = 0): <none>
[10:20:18.461] {
[10:20:18.461]     {
[10:20:18.461]         {
[10:20:18.461]             ...future.startTime <- base::Sys.time()
[10:20:18.461]             {
[10:20:18.461]                 {
[10:20:18.461]                   {
[10:20:18.461]                     {
[10:20:18.461]                       base::local({
[10:20:18.461]                         has_future <- base::requireNamespace("future", 
[10:20:18.461]                           quietly = TRUE)
[10:20:18.461]                         if (has_future) {
[10:20:18.461]                           ns <- base::getNamespace("future")
[10:20:18.461]                           version <- ns[[".package"]][["version"]]
[10:20:18.461]                           if (is.null(version)) 
[10:20:18.461]                             version <- utils::packageVersion("future")
[10:20:18.461]                         }
[10:20:18.461]                         else {
[10:20:18.461]                           version <- NULL
[10:20:18.461]                         }
[10:20:18.461]                         if (!has_future || version < "1.8.0") {
[10:20:18.461]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:18.461]                             "", base::R.version$version.string), 
[10:20:18.461]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:18.461]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:18.461]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:18.461]                               "release", "version")], collapse = " "), 
[10:20:18.461]                             hostname = base::Sys.info()[["nodename"]])
[10:20:18.461]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:18.461]                             info)
[10:20:18.461]                           info <- base::paste(info, collapse = "; ")
[10:20:18.461]                           if (!has_future) {
[10:20:18.461]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:18.461]                               info)
[10:20:18.461]                           }
[10:20:18.461]                           else {
[10:20:18.461]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:18.461]                               info, version)
[10:20:18.461]                           }
[10:20:18.461]                           base::stop(msg)
[10:20:18.461]                         }
[10:20:18.461]                       })
[10:20:18.461]                     }
[10:20:18.461]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:18.461]                     base::options(mc.cores = 1L)
[10:20:18.461]                   }
[10:20:18.461]                   ...future.strategy.old <- future::plan("list")
[10:20:18.461]                   options(future.plan = NULL)
[10:20:18.461]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:18.461]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:18.461]                 }
[10:20:18.461]                 ...future.workdir <- getwd()
[10:20:18.461]             }
[10:20:18.461]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:18.461]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:18.461]         }
[10:20:18.461]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:18.461]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:18.461]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:18.461]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:18.461]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:18.461]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:18.461]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:18.461]             base::names(...future.oldOptions))
[10:20:18.461]     }
[10:20:18.461]     if (FALSE) {
[10:20:18.461]     }
[10:20:18.461]     else {
[10:20:18.461]         if (FALSE) {
[10:20:18.461]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:18.461]                 open = "w")
[10:20:18.461]         }
[10:20:18.461]         else {
[10:20:18.461]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:18.461]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:18.461]         }
[10:20:18.461]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:18.461]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:18.461]             base::sink(type = "output", split = FALSE)
[10:20:18.461]             base::close(...future.stdout)
[10:20:18.461]         }, add = TRUE)
[10:20:18.461]     }
[10:20:18.461]     ...future.frame <- base::sys.nframe()
[10:20:18.461]     ...future.conditions <- base::list()
[10:20:18.461]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:18.461]     if (FALSE) {
[10:20:18.461]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:18.461]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:18.461]     }
[10:20:18.461]     ...future.result <- base::tryCatch({
[10:20:18.461]         base::withCallingHandlers({
[10:20:18.461]             ...future.value <- base::withVisible(base::local({
[10:20:18.461]                 ...future.makeSendCondition <- base::local({
[10:20:18.461]                   sendCondition <- NULL
[10:20:18.461]                   function(frame = 1L) {
[10:20:18.461]                     if (is.function(sendCondition)) 
[10:20:18.461]                       return(sendCondition)
[10:20:18.461]                     ns <- getNamespace("parallel")
[10:20:18.461]                     if (exists("sendData", mode = "function", 
[10:20:18.461]                       envir = ns)) {
[10:20:18.461]                       parallel_sendData <- get("sendData", mode = "function", 
[10:20:18.461]                         envir = ns)
[10:20:18.461]                       envir <- sys.frame(frame)
[10:20:18.461]                       master <- NULL
[10:20:18.461]                       while (!identical(envir, .GlobalEnv) && 
[10:20:18.461]                         !identical(envir, emptyenv())) {
[10:20:18.461]                         if (exists("master", mode = "list", envir = envir, 
[10:20:18.461]                           inherits = FALSE)) {
[10:20:18.461]                           master <- get("master", mode = "list", 
[10:20:18.461]                             envir = envir, inherits = FALSE)
[10:20:18.461]                           if (inherits(master, c("SOCKnode", 
[10:20:18.461]                             "SOCK0node"))) {
[10:20:18.461]                             sendCondition <<- function(cond) {
[10:20:18.461]                               data <- list(type = "VALUE", value = cond, 
[10:20:18.461]                                 success = TRUE)
[10:20:18.461]                               parallel_sendData(master, data)
[10:20:18.461]                             }
[10:20:18.461]                             return(sendCondition)
[10:20:18.461]                           }
[10:20:18.461]                         }
[10:20:18.461]                         frame <- frame + 1L
[10:20:18.461]                         envir <- sys.frame(frame)
[10:20:18.461]                       }
[10:20:18.461]                     }
[10:20:18.461]                     sendCondition <<- function(cond) NULL
[10:20:18.461]                   }
[10:20:18.461]                 })
[10:20:18.461]                 withCallingHandlers({
[10:20:18.461]                   {
[10:20:18.461]                     do.call(function(...) {
[10:20:18.461]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:18.461]                       if (!identical(...future.globals.maxSize.org, 
[10:20:18.461]                         ...future.globals.maxSize)) {
[10:20:18.461]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:18.461]                         on.exit(options(oopts), add = TRUE)
[10:20:18.461]                       }
[10:20:18.461]                       {
[10:20:18.461]                         lapply(seq_along(...future.elements_ii), 
[10:20:18.461]                           FUN = function(jj) {
[10:20:18.461]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:18.461]                             ...future.FUN(...future.X_jj, ...)
[10:20:18.461]                           })
[10:20:18.461]                       }
[10:20:18.461]                     }, args = future.call.arguments)
[10:20:18.461]                   }
[10:20:18.461]                 }, immediateCondition = function(cond) {
[10:20:18.461]                   sendCondition <- ...future.makeSendCondition()
[10:20:18.461]                   sendCondition(cond)
[10:20:18.461]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:18.461]                   {
[10:20:18.461]                     inherits <- base::inherits
[10:20:18.461]                     invokeRestart <- base::invokeRestart
[10:20:18.461]                     is.null <- base::is.null
[10:20:18.461]                     muffled <- FALSE
[10:20:18.461]                     if (inherits(cond, "message")) {
[10:20:18.461]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:18.461]                       if (muffled) 
[10:20:18.461]                         invokeRestart("muffleMessage")
[10:20:18.461]                     }
[10:20:18.461]                     else if (inherits(cond, "warning")) {
[10:20:18.461]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:18.461]                       if (muffled) 
[10:20:18.461]                         invokeRestart("muffleWarning")
[10:20:18.461]                     }
[10:20:18.461]                     else if (inherits(cond, "condition")) {
[10:20:18.461]                       if (!is.null(pattern)) {
[10:20:18.461]                         computeRestarts <- base::computeRestarts
[10:20:18.461]                         grepl <- base::grepl
[10:20:18.461]                         restarts <- computeRestarts(cond)
[10:20:18.461]                         for (restart in restarts) {
[10:20:18.461]                           name <- restart$name
[10:20:18.461]                           if (is.null(name)) 
[10:20:18.461]                             next
[10:20:18.461]                           if (!grepl(pattern, name)) 
[10:20:18.461]                             next
[10:20:18.461]                           invokeRestart(restart)
[10:20:18.461]                           muffled <- TRUE
[10:20:18.461]                           break
[10:20:18.461]                         }
[10:20:18.461]                       }
[10:20:18.461]                     }
[10:20:18.461]                     invisible(muffled)
[10:20:18.461]                   }
[10:20:18.461]                   muffleCondition(cond)
[10:20:18.461]                 })
[10:20:18.461]             }))
[10:20:18.461]             future::FutureResult(value = ...future.value$value, 
[10:20:18.461]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:18.461]                   ...future.rng), globalenv = if (FALSE) 
[10:20:18.461]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:18.461]                     ...future.globalenv.names))
[10:20:18.461]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:18.461]         }, condition = base::local({
[10:20:18.461]             c <- base::c
[10:20:18.461]             inherits <- base::inherits
[10:20:18.461]             invokeRestart <- base::invokeRestart
[10:20:18.461]             length <- base::length
[10:20:18.461]             list <- base::list
[10:20:18.461]             seq.int <- base::seq.int
[10:20:18.461]             signalCondition <- base::signalCondition
[10:20:18.461]             sys.calls <- base::sys.calls
[10:20:18.461]             `[[` <- base::`[[`
[10:20:18.461]             `+` <- base::`+`
[10:20:18.461]             `<<-` <- base::`<<-`
[10:20:18.461]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:18.461]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:18.461]                   3L)]
[10:20:18.461]             }
[10:20:18.461]             function(cond) {
[10:20:18.461]                 is_error <- inherits(cond, "error")
[10:20:18.461]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:18.461]                   NULL)
[10:20:18.461]                 if (is_error) {
[10:20:18.461]                   sessionInformation <- function() {
[10:20:18.461]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:18.461]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:18.461]                       search = base::search(), system = base::Sys.info())
[10:20:18.461]                   }
[10:20:18.461]                   ...future.conditions[[length(...future.conditions) + 
[10:20:18.461]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:18.461]                     cond$call), session = sessionInformation(), 
[10:20:18.461]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:18.461]                   signalCondition(cond)
[10:20:18.461]                 }
[10:20:18.461]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:18.461]                 "immediateCondition"))) {
[10:20:18.461]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:18.461]                   ...future.conditions[[length(...future.conditions) + 
[10:20:18.461]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:18.461]                   if (TRUE && !signal) {
[10:20:18.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:18.461]                     {
[10:20:18.461]                       inherits <- base::inherits
[10:20:18.461]                       invokeRestart <- base::invokeRestart
[10:20:18.461]                       is.null <- base::is.null
[10:20:18.461]                       muffled <- FALSE
[10:20:18.461]                       if (inherits(cond, "message")) {
[10:20:18.461]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:18.461]                         if (muffled) 
[10:20:18.461]                           invokeRestart("muffleMessage")
[10:20:18.461]                       }
[10:20:18.461]                       else if (inherits(cond, "warning")) {
[10:20:18.461]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:18.461]                         if (muffled) 
[10:20:18.461]                           invokeRestart("muffleWarning")
[10:20:18.461]                       }
[10:20:18.461]                       else if (inherits(cond, "condition")) {
[10:20:18.461]                         if (!is.null(pattern)) {
[10:20:18.461]                           computeRestarts <- base::computeRestarts
[10:20:18.461]                           grepl <- base::grepl
[10:20:18.461]                           restarts <- computeRestarts(cond)
[10:20:18.461]                           for (restart in restarts) {
[10:20:18.461]                             name <- restart$name
[10:20:18.461]                             if (is.null(name)) 
[10:20:18.461]                               next
[10:20:18.461]                             if (!grepl(pattern, name)) 
[10:20:18.461]                               next
[10:20:18.461]                             invokeRestart(restart)
[10:20:18.461]                             muffled <- TRUE
[10:20:18.461]                             break
[10:20:18.461]                           }
[10:20:18.461]                         }
[10:20:18.461]                       }
[10:20:18.461]                       invisible(muffled)
[10:20:18.461]                     }
[10:20:18.461]                     muffleCondition(cond, pattern = "^muffle")
[10:20:18.461]                   }
[10:20:18.461]                 }
[10:20:18.461]                 else {
[10:20:18.461]                   if (TRUE) {
[10:20:18.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:18.461]                     {
[10:20:18.461]                       inherits <- base::inherits
[10:20:18.461]                       invokeRestart <- base::invokeRestart
[10:20:18.461]                       is.null <- base::is.null
[10:20:18.461]                       muffled <- FALSE
[10:20:18.461]                       if (inherits(cond, "message")) {
[10:20:18.461]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:18.461]                         if (muffled) 
[10:20:18.461]                           invokeRestart("muffleMessage")
[10:20:18.461]                       }
[10:20:18.461]                       else if (inherits(cond, "warning")) {
[10:20:18.461]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:18.461]                         if (muffled) 
[10:20:18.461]                           invokeRestart("muffleWarning")
[10:20:18.461]                       }
[10:20:18.461]                       else if (inherits(cond, "condition")) {
[10:20:18.461]                         if (!is.null(pattern)) {
[10:20:18.461]                           computeRestarts <- base::computeRestarts
[10:20:18.461]                           grepl <- base::grepl
[10:20:18.461]                           restarts <- computeRestarts(cond)
[10:20:18.461]                           for (restart in restarts) {
[10:20:18.461]                             name <- restart$name
[10:20:18.461]                             if (is.null(name)) 
[10:20:18.461]                               next
[10:20:18.461]                             if (!grepl(pattern, name)) 
[10:20:18.461]                               next
[10:20:18.461]                             invokeRestart(restart)
[10:20:18.461]                             muffled <- TRUE
[10:20:18.461]                             break
[10:20:18.461]                           }
[10:20:18.461]                         }
[10:20:18.461]                       }
[10:20:18.461]                       invisible(muffled)
[10:20:18.461]                     }
[10:20:18.461]                     muffleCondition(cond, pattern = "^muffle")
[10:20:18.461]                   }
[10:20:18.461]                 }
[10:20:18.461]             }
[10:20:18.461]         }))
[10:20:18.461]     }, error = function(ex) {
[10:20:18.461]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:18.461]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:18.461]                 ...future.rng), started = ...future.startTime, 
[10:20:18.461]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:18.461]             version = "1.8"), class = "FutureResult")
[10:20:18.461]     }, finally = {
[10:20:18.461]         if (!identical(...future.workdir, getwd())) 
[10:20:18.461]             setwd(...future.workdir)
[10:20:18.461]         {
[10:20:18.461]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:18.461]                 ...future.oldOptions$nwarnings <- NULL
[10:20:18.461]             }
[10:20:18.461]             base::options(...future.oldOptions)
[10:20:18.461]             if (.Platform$OS.type == "windows") {
[10:20:18.461]                 old_names <- names(...future.oldEnvVars)
[10:20:18.461]                 envs <- base::Sys.getenv()
[10:20:18.461]                 names <- names(envs)
[10:20:18.461]                 common <- intersect(names, old_names)
[10:20:18.461]                 added <- setdiff(names, old_names)
[10:20:18.461]                 removed <- setdiff(old_names, names)
[10:20:18.461]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:18.461]                   envs[common]]
[10:20:18.461]                 NAMES <- toupper(changed)
[10:20:18.461]                 args <- list()
[10:20:18.461]                 for (kk in seq_along(NAMES)) {
[10:20:18.461]                   name <- changed[[kk]]
[10:20:18.461]                   NAME <- NAMES[[kk]]
[10:20:18.461]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:18.461]                     next
[10:20:18.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:18.461]                 }
[10:20:18.461]                 NAMES <- toupper(added)
[10:20:18.461]                 for (kk in seq_along(NAMES)) {
[10:20:18.461]                   name <- added[[kk]]
[10:20:18.461]                   NAME <- NAMES[[kk]]
[10:20:18.461]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:18.461]                     next
[10:20:18.461]                   args[[name]] <- ""
[10:20:18.461]                 }
[10:20:18.461]                 NAMES <- toupper(removed)
[10:20:18.461]                 for (kk in seq_along(NAMES)) {
[10:20:18.461]                   name <- removed[[kk]]
[10:20:18.461]                   NAME <- NAMES[[kk]]
[10:20:18.461]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:18.461]                     next
[10:20:18.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:18.461]                 }
[10:20:18.461]                 if (length(args) > 0) 
[10:20:18.461]                   base::do.call(base::Sys.setenv, args = args)
[10:20:18.461]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:18.461]             }
[10:20:18.461]             else {
[10:20:18.461]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:18.461]             }
[10:20:18.461]             {
[10:20:18.461]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:18.461]                   0L) {
[10:20:18.461]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:18.461]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:18.461]                   base::options(opts)
[10:20:18.461]                 }
[10:20:18.461]                 {
[10:20:18.461]                   {
[10:20:18.461]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:18.461]                     NULL
[10:20:18.461]                   }
[10:20:18.461]                   options(future.plan = NULL)
[10:20:18.461]                   if (is.na(NA_character_)) 
[10:20:18.461]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:18.461]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:18.461]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:18.461]                     .init = FALSE)
[10:20:18.461]                 }
[10:20:18.461]             }
[10:20:18.461]         }
[10:20:18.461]     })
[10:20:18.461]     if (TRUE) {
[10:20:18.461]         base::sink(type = "output", split = FALSE)
[10:20:18.461]         if (FALSE) {
[10:20:18.461]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:18.461]         }
[10:20:18.461]         else {
[10:20:18.461]             ...future.result["stdout"] <- base::list(NULL)
[10:20:18.461]         }
[10:20:18.461]         base::close(...future.stdout)
[10:20:18.461]         ...future.stdout <- NULL
[10:20:18.461]     }
[10:20:18.461]     ...future.result$conditions <- ...future.conditions
[10:20:18.461]     ...future.result$finished <- base::Sys.time()
[10:20:18.461]     ...future.result
[10:20:18.461] }
[10:20:18.464] Exporting 5 global objects (1.46 KiB) to cluster node #1 ...
[10:20:18.464] Exporting ‘...future.FUN’ (841 bytes) to cluster node #1 ...
[10:20:18.465] Exporting ‘...future.FUN’ (841 bytes) to cluster node #1 ... DONE
[10:20:18.465] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:20:18.465] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:20:18.465] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ...
[10:20:18.466] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ... DONE
[10:20:18.466] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:20:18.466] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:20:18.466] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:20:18.467] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:20:18.467] Exporting 5 global objects (1.46 KiB) to cluster node #1 ... DONE
[10:20:18.468] MultisessionFuture started
[10:20:18.468] - Launch lazy future ... done
[10:20:18.468] run() for ‘MultisessionFuture’ ... done
[10:20:18.468] Created future:
[10:20:18.468] MultisessionFuture:
[10:20:18.468] Label: ‘future_lapply-1’
[10:20:18.468] Expression:
[10:20:18.468] {
[10:20:18.468]     do.call(function(...) {
[10:20:18.468]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:18.468]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:18.468]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:18.468]             on.exit(options(oopts), add = TRUE)
[10:20:18.468]         }
[10:20:18.468]         {
[10:20:18.468]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:18.468]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:18.468]                 ...future.FUN(...future.X_jj, ...)
[10:20:18.468]             })
[10:20:18.468]         }
[10:20:18.468]     }, args = future.call.arguments)
[10:20:18.468] }
[10:20:18.468] Lazy evaluation: FALSE
[10:20:18.468] Asynchronous evaluation: TRUE
[10:20:18.468] Local evaluation: TRUE
[10:20:18.468] Environment: R_GlobalEnv
[10:20:18.468] Capture standard output: FALSE
[10:20:18.468] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:18.468] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:18.468] Packages: <none>
[10:20:18.468] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:18.468] Resolved: FALSE
[10:20:18.468] Value: <not collected>
[10:20:18.468] Conditions captured: <none>
[10:20:18.468] Early signaling: FALSE
[10:20:18.468] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:18.468] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:18.480] Chunk #1 of 2 ... DONE
[10:20:18.480] Chunk #2 of 2 ...
[10:20:18.480]  - Finding globals in 'X' for chunk #2 ...
[10:20:18.481] getGlobalsAndPackages() ...
[10:20:18.481] Searching for globals...
[10:20:18.481] 
[10:20:18.481] Searching for globals ... DONE
[10:20:18.481] - globals: [0] <none>
[10:20:18.481] getGlobalsAndPackages() ... DONE
[10:20:18.481]    + additional globals found: [n=0] 
[10:20:18.482]    + additional namespaces needed: [n=0] 
[10:20:18.482]  - Finding globals in 'X' for chunk #2 ... DONE
[10:20:18.482]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:18.482]  - seeds: <none>
[10:20:18.482]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:18.482] getGlobalsAndPackages() ...
[10:20:18.482] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:18.482] Resolving globals: FALSE
[10:20:18.482] Tweak future expression to call with '...' arguments ...
[10:20:18.483] {
[10:20:18.483]     do.call(function(...) {
[10:20:18.483]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:18.483]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:18.483]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:18.483]             on.exit(options(oopts), add = TRUE)
[10:20:18.483]         }
[10:20:18.483]         {
[10:20:18.483]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:18.483]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:18.483]                 ...future.FUN(...future.X_jj, ...)
[10:20:18.483]             })
[10:20:18.483]         }
[10:20:18.483]     }, args = future.call.arguments)
[10:20:18.483] }
[10:20:18.483] Tweak future expression to call with '...' arguments ... DONE
[10:20:18.483] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:18.483] 
[10:20:18.484] getGlobalsAndPackages() ... DONE
[10:20:18.484] run() for ‘Future’ ...
[10:20:18.484] - state: ‘created’
[10:20:18.484] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:20:18.499] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:18.499] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:20:18.499]   - Field: ‘node’
[10:20:18.499]   - Field: ‘label’
[10:20:18.500]   - Field: ‘local’
[10:20:18.500]   - Field: ‘owner’
[10:20:18.500]   - Field: ‘envir’
[10:20:18.500]   - Field: ‘workers’
[10:20:18.500]   - Field: ‘packages’
[10:20:18.500]   - Field: ‘gc’
[10:20:18.500]   - Field: ‘conditions’
[10:20:18.500]   - Field: ‘persistent’
[10:20:18.500]   - Field: ‘expr’
[10:20:18.500]   - Field: ‘uuid’
[10:20:18.501]   - Field: ‘seed’
[10:20:18.501]   - Field: ‘version’
[10:20:18.501]   - Field: ‘result’
[10:20:18.501]   - Field: ‘asynchronous’
[10:20:18.501]   - Field: ‘calls’
[10:20:18.501]   - Field: ‘globals’
[10:20:18.501]   - Field: ‘stdout’
[10:20:18.501]   - Field: ‘earlySignal’
[10:20:18.501]   - Field: ‘lazy’
[10:20:18.501]   - Field: ‘state’
[10:20:18.502] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:20:18.502] - Launch lazy future ...
[10:20:18.502] Packages needed by the future expression (n = 0): <none>
[10:20:18.502] Packages needed by future strategies (n = 0): <none>
[10:20:18.503] {
[10:20:18.503]     {
[10:20:18.503]         {
[10:20:18.503]             ...future.startTime <- base::Sys.time()
[10:20:18.503]             {
[10:20:18.503]                 {
[10:20:18.503]                   {
[10:20:18.503]                     {
[10:20:18.503]                       base::local({
[10:20:18.503]                         has_future <- base::requireNamespace("future", 
[10:20:18.503]                           quietly = TRUE)
[10:20:18.503]                         if (has_future) {
[10:20:18.503]                           ns <- base::getNamespace("future")
[10:20:18.503]                           version <- ns[[".package"]][["version"]]
[10:20:18.503]                           if (is.null(version)) 
[10:20:18.503]                             version <- utils::packageVersion("future")
[10:20:18.503]                         }
[10:20:18.503]                         else {
[10:20:18.503]                           version <- NULL
[10:20:18.503]                         }
[10:20:18.503]                         if (!has_future || version < "1.8.0") {
[10:20:18.503]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:18.503]                             "", base::R.version$version.string), 
[10:20:18.503]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:18.503]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:18.503]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:18.503]                               "release", "version")], collapse = " "), 
[10:20:18.503]                             hostname = base::Sys.info()[["nodename"]])
[10:20:18.503]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:18.503]                             info)
[10:20:18.503]                           info <- base::paste(info, collapse = "; ")
[10:20:18.503]                           if (!has_future) {
[10:20:18.503]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:18.503]                               info)
[10:20:18.503]                           }
[10:20:18.503]                           else {
[10:20:18.503]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:18.503]                               info, version)
[10:20:18.503]                           }
[10:20:18.503]                           base::stop(msg)
[10:20:18.503]                         }
[10:20:18.503]                       })
[10:20:18.503]                     }
[10:20:18.503]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:18.503]                     base::options(mc.cores = 1L)
[10:20:18.503]                   }
[10:20:18.503]                   ...future.strategy.old <- future::plan("list")
[10:20:18.503]                   options(future.plan = NULL)
[10:20:18.503]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:18.503]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:18.503]                 }
[10:20:18.503]                 ...future.workdir <- getwd()
[10:20:18.503]             }
[10:20:18.503]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:18.503]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:18.503]         }
[10:20:18.503]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:18.503]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:18.503]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:18.503]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:18.503]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:18.503]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:18.503]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:18.503]             base::names(...future.oldOptions))
[10:20:18.503]     }
[10:20:18.503]     if (FALSE) {
[10:20:18.503]     }
[10:20:18.503]     else {
[10:20:18.503]         if (FALSE) {
[10:20:18.503]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:18.503]                 open = "w")
[10:20:18.503]         }
[10:20:18.503]         else {
[10:20:18.503]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:18.503]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:18.503]         }
[10:20:18.503]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:18.503]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:18.503]             base::sink(type = "output", split = FALSE)
[10:20:18.503]             base::close(...future.stdout)
[10:20:18.503]         }, add = TRUE)
[10:20:18.503]     }
[10:20:18.503]     ...future.frame <- base::sys.nframe()
[10:20:18.503]     ...future.conditions <- base::list()
[10:20:18.503]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:18.503]     if (FALSE) {
[10:20:18.503]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:18.503]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:18.503]     }
[10:20:18.503]     ...future.result <- base::tryCatch({
[10:20:18.503]         base::withCallingHandlers({
[10:20:18.503]             ...future.value <- base::withVisible(base::local({
[10:20:18.503]                 ...future.makeSendCondition <- base::local({
[10:20:18.503]                   sendCondition <- NULL
[10:20:18.503]                   function(frame = 1L) {
[10:20:18.503]                     if (is.function(sendCondition)) 
[10:20:18.503]                       return(sendCondition)
[10:20:18.503]                     ns <- getNamespace("parallel")
[10:20:18.503]                     if (exists("sendData", mode = "function", 
[10:20:18.503]                       envir = ns)) {
[10:20:18.503]                       parallel_sendData <- get("sendData", mode = "function", 
[10:20:18.503]                         envir = ns)
[10:20:18.503]                       envir <- sys.frame(frame)
[10:20:18.503]                       master <- NULL
[10:20:18.503]                       while (!identical(envir, .GlobalEnv) && 
[10:20:18.503]                         !identical(envir, emptyenv())) {
[10:20:18.503]                         if (exists("master", mode = "list", envir = envir, 
[10:20:18.503]                           inherits = FALSE)) {
[10:20:18.503]                           master <- get("master", mode = "list", 
[10:20:18.503]                             envir = envir, inherits = FALSE)
[10:20:18.503]                           if (inherits(master, c("SOCKnode", 
[10:20:18.503]                             "SOCK0node"))) {
[10:20:18.503]                             sendCondition <<- function(cond) {
[10:20:18.503]                               data <- list(type = "VALUE", value = cond, 
[10:20:18.503]                                 success = TRUE)
[10:20:18.503]                               parallel_sendData(master, data)
[10:20:18.503]                             }
[10:20:18.503]                             return(sendCondition)
[10:20:18.503]                           }
[10:20:18.503]                         }
[10:20:18.503]                         frame <- frame + 1L
[10:20:18.503]                         envir <- sys.frame(frame)
[10:20:18.503]                       }
[10:20:18.503]                     }
[10:20:18.503]                     sendCondition <<- function(cond) NULL
[10:20:18.503]                   }
[10:20:18.503]                 })
[10:20:18.503]                 withCallingHandlers({
[10:20:18.503]                   {
[10:20:18.503]                     do.call(function(...) {
[10:20:18.503]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:18.503]                       if (!identical(...future.globals.maxSize.org, 
[10:20:18.503]                         ...future.globals.maxSize)) {
[10:20:18.503]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:18.503]                         on.exit(options(oopts), add = TRUE)
[10:20:18.503]                       }
[10:20:18.503]                       {
[10:20:18.503]                         lapply(seq_along(...future.elements_ii), 
[10:20:18.503]                           FUN = function(jj) {
[10:20:18.503]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:18.503]                             ...future.FUN(...future.X_jj, ...)
[10:20:18.503]                           })
[10:20:18.503]                       }
[10:20:18.503]                     }, args = future.call.arguments)
[10:20:18.503]                   }
[10:20:18.503]                 }, immediateCondition = function(cond) {
[10:20:18.503]                   sendCondition <- ...future.makeSendCondition()
[10:20:18.503]                   sendCondition(cond)
[10:20:18.503]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:18.503]                   {
[10:20:18.503]                     inherits <- base::inherits
[10:20:18.503]                     invokeRestart <- base::invokeRestart
[10:20:18.503]                     is.null <- base::is.null
[10:20:18.503]                     muffled <- FALSE
[10:20:18.503]                     if (inherits(cond, "message")) {
[10:20:18.503]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:18.503]                       if (muffled) 
[10:20:18.503]                         invokeRestart("muffleMessage")
[10:20:18.503]                     }
[10:20:18.503]                     else if (inherits(cond, "warning")) {
[10:20:18.503]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:18.503]                       if (muffled) 
[10:20:18.503]                         invokeRestart("muffleWarning")
[10:20:18.503]                     }
[10:20:18.503]                     else if (inherits(cond, "condition")) {
[10:20:18.503]                       if (!is.null(pattern)) {
[10:20:18.503]                         computeRestarts <- base::computeRestarts
[10:20:18.503]                         grepl <- base::grepl
[10:20:18.503]                         restarts <- computeRestarts(cond)
[10:20:18.503]                         for (restart in restarts) {
[10:20:18.503]                           name <- restart$name
[10:20:18.503]                           if (is.null(name)) 
[10:20:18.503]                             next
[10:20:18.503]                           if (!grepl(pattern, name)) 
[10:20:18.503]                             next
[10:20:18.503]                           invokeRestart(restart)
[10:20:18.503]                           muffled <- TRUE
[10:20:18.503]                           break
[10:20:18.503]                         }
[10:20:18.503]                       }
[10:20:18.503]                     }
[10:20:18.503]                     invisible(muffled)
[10:20:18.503]                   }
[10:20:18.503]                   muffleCondition(cond)
[10:20:18.503]                 })
[10:20:18.503]             }))
[10:20:18.503]             future::FutureResult(value = ...future.value$value, 
[10:20:18.503]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:18.503]                   ...future.rng), globalenv = if (FALSE) 
[10:20:18.503]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:18.503]                     ...future.globalenv.names))
[10:20:18.503]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:18.503]         }, condition = base::local({
[10:20:18.503]             c <- base::c
[10:20:18.503]             inherits <- base::inherits
[10:20:18.503]             invokeRestart <- base::invokeRestart
[10:20:18.503]             length <- base::length
[10:20:18.503]             list <- base::list
[10:20:18.503]             seq.int <- base::seq.int
[10:20:18.503]             signalCondition <- base::signalCondition
[10:20:18.503]             sys.calls <- base::sys.calls
[10:20:18.503]             `[[` <- base::`[[`
[10:20:18.503]             `+` <- base::`+`
[10:20:18.503]             `<<-` <- base::`<<-`
[10:20:18.503]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:18.503]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:18.503]                   3L)]
[10:20:18.503]             }
[10:20:18.503]             function(cond) {
[10:20:18.503]                 is_error <- inherits(cond, "error")
[10:20:18.503]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:18.503]                   NULL)
[10:20:18.503]                 if (is_error) {
[10:20:18.503]                   sessionInformation <- function() {
[10:20:18.503]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:18.503]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:18.503]                       search = base::search(), system = base::Sys.info())
[10:20:18.503]                   }
[10:20:18.503]                   ...future.conditions[[length(...future.conditions) + 
[10:20:18.503]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:18.503]                     cond$call), session = sessionInformation(), 
[10:20:18.503]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:18.503]                   signalCondition(cond)
[10:20:18.503]                 }
[10:20:18.503]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:18.503]                 "immediateCondition"))) {
[10:20:18.503]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:18.503]                   ...future.conditions[[length(...future.conditions) + 
[10:20:18.503]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:18.503]                   if (TRUE && !signal) {
[10:20:18.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:18.503]                     {
[10:20:18.503]                       inherits <- base::inherits
[10:20:18.503]                       invokeRestart <- base::invokeRestart
[10:20:18.503]                       is.null <- base::is.null
[10:20:18.503]                       muffled <- FALSE
[10:20:18.503]                       if (inherits(cond, "message")) {
[10:20:18.503]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:18.503]                         if (muffled) 
[10:20:18.503]                           invokeRestart("muffleMessage")
[10:20:18.503]                       }
[10:20:18.503]                       else if (inherits(cond, "warning")) {
[10:20:18.503]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:18.503]                         if (muffled) 
[10:20:18.503]                           invokeRestart("muffleWarning")
[10:20:18.503]                       }
[10:20:18.503]                       else if (inherits(cond, "condition")) {
[10:20:18.503]                         if (!is.null(pattern)) {
[10:20:18.503]                           computeRestarts <- base::computeRestarts
[10:20:18.503]                           grepl <- base::grepl
[10:20:18.503]                           restarts <- computeRestarts(cond)
[10:20:18.503]                           for (restart in restarts) {
[10:20:18.503]                             name <- restart$name
[10:20:18.503]                             if (is.null(name)) 
[10:20:18.503]                               next
[10:20:18.503]                             if (!grepl(pattern, name)) 
[10:20:18.503]                               next
[10:20:18.503]                             invokeRestart(restart)
[10:20:18.503]                             muffled <- TRUE
[10:20:18.503]                             break
[10:20:18.503]                           }
[10:20:18.503]                         }
[10:20:18.503]                       }
[10:20:18.503]                       invisible(muffled)
[10:20:18.503]                     }
[10:20:18.503]                     muffleCondition(cond, pattern = "^muffle")
[10:20:18.503]                   }
[10:20:18.503]                 }
[10:20:18.503]                 else {
[10:20:18.503]                   if (TRUE) {
[10:20:18.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:18.503]                     {
[10:20:18.503]                       inherits <- base::inherits
[10:20:18.503]                       invokeRestart <- base::invokeRestart
[10:20:18.503]                       is.null <- base::is.null
[10:20:18.503]                       muffled <- FALSE
[10:20:18.503]                       if (inherits(cond, "message")) {
[10:20:18.503]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:18.503]                         if (muffled) 
[10:20:18.503]                           invokeRestart("muffleMessage")
[10:20:18.503]                       }
[10:20:18.503]                       else if (inherits(cond, "warning")) {
[10:20:18.503]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:18.503]                         if (muffled) 
[10:20:18.503]                           invokeRestart("muffleWarning")
[10:20:18.503]                       }
[10:20:18.503]                       else if (inherits(cond, "condition")) {
[10:20:18.503]                         if (!is.null(pattern)) {
[10:20:18.503]                           computeRestarts <- base::computeRestarts
[10:20:18.503]                           grepl <- base::grepl
[10:20:18.503]                           restarts <- computeRestarts(cond)
[10:20:18.503]                           for (restart in restarts) {
[10:20:18.503]                             name <- restart$name
[10:20:18.503]                             if (is.null(name)) 
[10:20:18.503]                               next
[10:20:18.503]                             if (!grepl(pattern, name)) 
[10:20:18.503]                               next
[10:20:18.503]                             invokeRestart(restart)
[10:20:18.503]                             muffled <- TRUE
[10:20:18.503]                             break
[10:20:18.503]                           }
[10:20:18.503]                         }
[10:20:18.503]                       }
[10:20:18.503]                       invisible(muffled)
[10:20:18.503]                     }
[10:20:18.503]                     muffleCondition(cond, pattern = "^muffle")
[10:20:18.503]                   }
[10:20:18.503]                 }
[10:20:18.503]             }
[10:20:18.503]         }))
[10:20:18.503]     }, error = function(ex) {
[10:20:18.503]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:18.503]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:18.503]                 ...future.rng), started = ...future.startTime, 
[10:20:18.503]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:18.503]             version = "1.8"), class = "FutureResult")
[10:20:18.503]     }, finally = {
[10:20:18.503]         if (!identical(...future.workdir, getwd())) 
[10:20:18.503]             setwd(...future.workdir)
[10:20:18.503]         {
[10:20:18.503]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:18.503]                 ...future.oldOptions$nwarnings <- NULL
[10:20:18.503]             }
[10:20:18.503]             base::options(...future.oldOptions)
[10:20:18.503]             if (.Platform$OS.type == "windows") {
[10:20:18.503]                 old_names <- names(...future.oldEnvVars)
[10:20:18.503]                 envs <- base::Sys.getenv()
[10:20:18.503]                 names <- names(envs)
[10:20:18.503]                 common <- intersect(names, old_names)
[10:20:18.503]                 added <- setdiff(names, old_names)
[10:20:18.503]                 removed <- setdiff(old_names, names)
[10:20:18.503]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:18.503]                   envs[common]]
[10:20:18.503]                 NAMES <- toupper(changed)
[10:20:18.503]                 args <- list()
[10:20:18.503]                 for (kk in seq_along(NAMES)) {
[10:20:18.503]                   name <- changed[[kk]]
[10:20:18.503]                   NAME <- NAMES[[kk]]
[10:20:18.503]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:18.503]                     next
[10:20:18.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:18.503]                 }
[10:20:18.503]                 NAMES <- toupper(added)
[10:20:18.503]                 for (kk in seq_along(NAMES)) {
[10:20:18.503]                   name <- added[[kk]]
[10:20:18.503]                   NAME <- NAMES[[kk]]
[10:20:18.503]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:18.503]                     next
[10:20:18.503]                   args[[name]] <- ""
[10:20:18.503]                 }
[10:20:18.503]                 NAMES <- toupper(removed)
[10:20:18.503]                 for (kk in seq_along(NAMES)) {
[10:20:18.503]                   name <- removed[[kk]]
[10:20:18.503]                   NAME <- NAMES[[kk]]
[10:20:18.503]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:18.503]                     next
[10:20:18.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:18.503]                 }
[10:20:18.503]                 if (length(args) > 0) 
[10:20:18.503]                   base::do.call(base::Sys.setenv, args = args)
[10:20:18.503]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:18.503]             }
[10:20:18.503]             else {
[10:20:18.503]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:18.503]             }
[10:20:18.503]             {
[10:20:18.503]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:18.503]                   0L) {
[10:20:18.503]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:18.503]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:18.503]                   base::options(opts)
[10:20:18.503]                 }
[10:20:18.503]                 {
[10:20:18.503]                   {
[10:20:18.503]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:18.503]                     NULL
[10:20:18.503]                   }
[10:20:18.503]                   options(future.plan = NULL)
[10:20:18.503]                   if (is.na(NA_character_)) 
[10:20:18.503]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:18.503]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:18.503]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:18.503]                     .init = FALSE)
[10:20:18.503]                 }
[10:20:18.503]             }
[10:20:18.503]         }
[10:20:18.503]     })
[10:20:18.503]     if (TRUE) {
[10:20:18.503]         base::sink(type = "output", split = FALSE)
[10:20:18.503]         if (FALSE) {
[10:20:18.503]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:18.503]         }
[10:20:18.503]         else {
[10:20:18.503]             ...future.result["stdout"] <- base::list(NULL)
[10:20:18.503]         }
[10:20:18.503]         base::close(...future.stdout)
[10:20:18.503]         ...future.stdout <- NULL
[10:20:18.503]     }
[10:20:18.503]     ...future.result$conditions <- ...future.conditions
[10:20:18.503]     ...future.result$finished <- base::Sys.time()
[10:20:18.503]     ...future.result
[10:20:18.503] }
[10:20:18.555] Exporting 5 global objects (1.46 KiB) to cluster node #2 ...
[10:20:18.556] Exporting ‘...future.FUN’ (841 bytes) to cluster node #2 ...
[10:20:18.556] Exporting ‘...future.FUN’ (841 bytes) to cluster node #2 ... DONE
[10:20:18.556] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:20:18.557] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:20:18.557] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ...
[10:20:18.557] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ... DONE
[10:20:18.557] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:20:18.558] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:20:18.558] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:20:18.558] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:20:18.558] Exporting 5 global objects (1.46 KiB) to cluster node #2 ... DONE
[10:20:18.559] MultisessionFuture started
[10:20:18.559] - Launch lazy future ... done
[10:20:18.559] run() for ‘MultisessionFuture’ ... done
[10:20:18.559] Created future:
[10:20:18.559] MultisessionFuture:
[10:20:18.559] Label: ‘future_lapply-2’
[10:20:18.559] Expression:
[10:20:18.559] {
[10:20:18.559]     do.call(function(...) {
[10:20:18.559]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:18.559]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:18.559]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:18.559]             on.exit(options(oopts), add = TRUE)
[10:20:18.559]         }
[10:20:18.559]         {
[10:20:18.559]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:18.559]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:18.559]                 ...future.FUN(...future.X_jj, ...)
[10:20:18.559]             })
[10:20:18.559]         }
[10:20:18.559]     }, args = future.call.arguments)
[10:20:18.559] }
[10:20:18.559] Lazy evaluation: FALSE
[10:20:18.559] Asynchronous evaluation: TRUE
[10:20:18.559] Local evaluation: TRUE
[10:20:18.559] Environment: R_GlobalEnv
[10:20:18.559] Capture standard output: FALSE
[10:20:18.559] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:18.559] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:18.559] Packages: <none>
[10:20:18.559] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:18.559] Resolved: FALSE
[10:20:18.559] Value: <not collected>
[10:20:18.559] Conditions captured: <none>
[10:20:18.559] Early signaling: FALSE
[10:20:18.559] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:18.559] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:18.571] Chunk #2 of 2 ... DONE
[10:20:18.571] Launching 2 futures (chunks) ... DONE
[10:20:18.571] Resolving 2 futures (chunks) ...
[10:20:18.572] resolve() on list ...
[10:20:18.572]  recursive: 0
[10:20:18.572]  length: 2
[10:20:18.572] 
[10:20:18.646] receiveMessageFromWorker() for ClusterFuture ...
[10:20:18.646] - Validating connection of MultisessionFuture
[10:20:18.646] - received message: FutureResult
[10:20:18.646] - Received FutureResult
[10:20:18.646] - Erased future from FutureRegistry
[10:20:18.646] result() for ClusterFuture ...
[10:20:18.647] - result already collected: FutureResult
[10:20:18.647] result() for ClusterFuture ... done
[10:20:18.647] receiveMessageFromWorker() for ClusterFuture ... done
[10:20:18.647] Future #2
[10:20:18.647] result() for ClusterFuture ...
[10:20:18.647] - result already collected: FutureResult
[10:20:18.647] result() for ClusterFuture ... done
[10:20:18.647] result() for ClusterFuture ...
[10:20:18.647] - result already collected: FutureResult
[10:20:18.647] result() for ClusterFuture ... done
[10:20:18.648] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:20:18.648] - nx: 2
[10:20:18.648] - relay: TRUE
[10:20:18.648] - stdout: TRUE
[10:20:18.648] - signal: TRUE
[10:20:18.648] - resignal: FALSE
[10:20:18.648] - force: TRUE
[10:20:18.648] - relayed: [n=2] FALSE, FALSE
[10:20:18.648] - queued futures: [n=2] FALSE, FALSE
[10:20:18.649]  - until=1
[10:20:18.649]  - relaying element #1
[10:20:18.649] - relayed: [n=2] FALSE, FALSE
[10:20:18.649] - queued futures: [n=2] FALSE, TRUE
[10:20:18.649] signalConditionsASAP(NULL, pos=2) ... done
[10:20:18.649]  length: 1 (resolved future 2)
[10:20:19.015] receiveMessageFromWorker() for ClusterFuture ...
[10:20:19.015] - Validating connection of MultisessionFuture
[10:20:19.015] - received message: FutureResult
[10:20:19.015] - Received FutureResult
[10:20:19.015] - Erased future from FutureRegistry
[10:20:19.016] result() for ClusterFuture ...
[10:20:19.016] - result already collected: FutureResult
[10:20:19.016] result() for ClusterFuture ... done
[10:20:19.016] receiveMessageFromWorker() for ClusterFuture ... done
[10:20:19.016] Future #1
[10:20:19.016] result() for ClusterFuture ...
[10:20:19.016] - result already collected: FutureResult
[10:20:19.016] result() for ClusterFuture ... done
[10:20:19.016] result() for ClusterFuture ...
[10:20:19.016] - result already collected: FutureResult
[10:20:19.017] result() for ClusterFuture ... done
[10:20:19.017] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:20:19.017] - nx: 2
[10:20:19.017] - relay: TRUE
[10:20:19.017] - stdout: TRUE
[10:20:19.017] - signal: TRUE
[10:20:19.017] - resignal: FALSE
[10:20:19.017] - force: TRUE
[10:20:19.017] - relayed: [n=2] FALSE, FALSE
[10:20:19.017] - queued futures: [n=2] FALSE, TRUE
[10:20:19.018]  - until=1
[10:20:19.018]  - relaying element #1
[10:20:19.018] result() for ClusterFuture ...
[10:20:19.018] - result already collected: FutureResult
[10:20:19.018] result() for ClusterFuture ... done
[10:20:19.018] result() for ClusterFuture ...
[10:20:19.018] - result already collected: FutureResult
[10:20:19.018] result() for ClusterFuture ... done
[10:20:19.018] result() for ClusterFuture ...
[10:20:19.019] - result already collected: FutureResult
[10:20:19.019] result() for ClusterFuture ... done
[10:20:19.019] result() for ClusterFuture ...
[10:20:19.019] - result already collected: FutureResult
[10:20:19.019] result() for ClusterFuture ... done
[10:20:19.019] - relayed: [n=2] TRUE, FALSE
[10:20:19.019] - queued futures: [n=2] TRUE, TRUE
[10:20:19.019] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:20:19.019]  length: 0 (resolved future 1)
[10:20:19.019] Relaying remaining futures
[10:20:19.020] signalConditionsASAP(NULL, pos=0) ...
[10:20:19.020] - nx: 2
[10:20:19.020] - relay: TRUE
[10:20:19.020] - stdout: TRUE
[10:20:19.020] - signal: TRUE
[10:20:19.020] - resignal: FALSE
[10:20:19.020] - force: TRUE
[10:20:19.020] - relayed: [n=2] TRUE, FALSE
[10:20:19.020] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:20:19.021]  - relaying element #2
[10:20:19.021] result() for ClusterFuture ...
[10:20:19.021] - result already collected: FutureResult
[10:20:19.021] result() for ClusterFuture ... done
[10:20:19.021] result() for ClusterFuture ...
[10:20:19.021] - result already collected: FutureResult
[10:20:19.021] result() for ClusterFuture ... done
[10:20:19.021] result() for ClusterFuture ...
[10:20:19.021] - result already collected: FutureResult
[10:20:19.021] result() for ClusterFuture ... done
[10:20:19.022] result() for ClusterFuture ...
[10:20:19.022] - result already collected: FutureResult
[10:20:19.022] result() for ClusterFuture ... done
[10:20:19.022] - relayed: [n=2] TRUE, TRUE
[10:20:19.022] - queued futures: [n=2] TRUE, TRUE
[10:20:19.022] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[10:20:19.022] resolve() on list ... DONE
[10:20:19.022] result() for ClusterFuture ...
[10:20:19.022] - result already collected: FutureResult
[10:20:19.022] result() for ClusterFuture ... done
[10:20:19.023] result() for ClusterFuture ...
[10:20:19.023] - result already collected: FutureResult
[10:20:19.023] result() for ClusterFuture ... done
[10:20:19.023] result() for ClusterFuture ...
[10:20:19.023] - result already collected: FutureResult
[10:20:19.023] result() for ClusterFuture ... done
[10:20:19.023] result() for ClusterFuture ...
[10:20:19.023] - result already collected: FutureResult
[10:20:19.023] result() for ClusterFuture ... done
[10:20:19.023]  - Number of value chunks collected: 2
[10:20:19.024] Resolving 2 futures (chunks) ... DONE
[10:20:19.024] Reducing values from 2 chunks ...
[10:20:19.024]  - Number of values collected after concatenation: 2
[10:20:19.024]  - Number of values expected: 2
[10:20:19.024] Reducing values from 2 chunks ... DONE
[10:20:19.024] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[10:20:19.025] future_lapply() ...
[10:20:19.027] Number of chunks: 2
[10:20:19.027] getGlobalsAndPackagesXApply() ...
[10:20:19.027]  - future.globals: TRUE
[10:20:19.028] getGlobalsAndPackages() ...
[10:20:19.028] Searching for globals...
[10:20:19.029] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:20:19.030] Searching for globals ... DONE
[10:20:19.030] Resolving globals: FALSE
[10:20:19.030] The total size of the 1 globals is 841 bytes (841 bytes)
[10:20:19.031] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[10:20:19.031] - globals: [1] ‘FUN’
[10:20:19.031] 
[10:20:19.031] getGlobalsAndPackages() ... DONE
[10:20:19.031]  - globals found/used: [n=1] ‘FUN’
[10:20:19.031]  - needed namespaces: [n=0] 
[10:20:19.031] Finding globals ... DONE
[10:20:19.031]  - use_args: TRUE
[10:20:19.032]  - Getting '...' globals ...
[10:20:19.032] resolve() on list ...
[10:20:19.032]  recursive: 0
[10:20:19.032]  length: 1
[10:20:19.032]  elements: ‘...’
[10:20:19.032]  length: 0 (resolved future 1)
[10:20:19.033] resolve() on list ... DONE
[10:20:19.033]    - '...' content: [n=0] 
[10:20:19.033] List of 1
[10:20:19.033]  $ ...: list()
[10:20:19.033]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:19.033]  - attr(*, "where")=List of 1
[10:20:19.033]   ..$ ...:<environment: 0x557fc45ca098> 
[10:20:19.033]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:19.033]  - attr(*, "resolved")= logi TRUE
[10:20:19.033]  - attr(*, "total_size")= num NA
[10:20:19.038]  - Getting '...' globals ... DONE
[10:20:19.038] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:20:19.038] List of 2
[10:20:19.038]  $ ...future.FUN:function (x)  
[10:20:19.038]  $ ...          : list()
[10:20:19.038]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:19.038]  - attr(*, "where")=List of 2
[10:20:19.038]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:19.038]   ..$ ...          :<environment: 0x557fc45ca098> 
[10:20:19.038]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:19.038]  - attr(*, "resolved")= logi FALSE
[10:20:19.038]  - attr(*, "total_size")= num 5632
[10:20:19.041] Packages to be attached in all futures: [n=0] 
[10:20:19.041] getGlobalsAndPackagesXApply() ... DONE
[10:20:19.041] Number of futures (= number of chunks): 2
[10:20:19.041] Launching 2 futures (chunks) ...
[10:20:19.041] Chunk #1 of 2 ...
[10:20:19.042]  - Finding globals in 'X' for chunk #1 ...
[10:20:19.042] getGlobalsAndPackages() ...
[10:20:19.042] Searching for globals...
[10:20:19.042] 
[10:20:19.042] Searching for globals ... DONE
[10:20:19.042] - globals: [0] <none>
[10:20:19.042] getGlobalsAndPackages() ... DONE
[10:20:19.042]    + additional globals found: [n=0] 
[10:20:19.042]    + additional namespaces needed: [n=0] 
[10:20:19.042]  - Finding globals in 'X' for chunk #1 ... DONE
[10:20:19.042]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:19.043]  - seeds: <none>
[10:20:19.043]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:19.043] getGlobalsAndPackages() ...
[10:20:19.043] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:19.043] Resolving globals: FALSE
[10:20:19.043] Tweak future expression to call with '...' arguments ...
[10:20:19.043] {
[10:20:19.043]     do.call(function(...) {
[10:20:19.043]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:19.043]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:19.043]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:19.043]             on.exit(options(oopts), add = TRUE)
[10:20:19.043]         }
[10:20:19.043]         {
[10:20:19.043]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:19.043]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:19.043]                 ...future.FUN(...future.X_jj, ...)
[10:20:19.043]             })
[10:20:19.043]         }
[10:20:19.043]     }, args = future.call.arguments)
[10:20:19.043] }
[10:20:19.043] Tweak future expression to call with '...' arguments ... DONE
[10:20:19.044] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:19.044] 
[10:20:19.044] getGlobalsAndPackages() ... DONE
[10:20:19.044] run() for ‘Future’ ...
[10:20:19.044] - state: ‘created’
[10:20:19.044] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:20:19.058] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:19.058] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:20:19.059]   - Field: ‘node’
[10:20:19.059]   - Field: ‘label’
[10:20:19.059]   - Field: ‘local’
[10:20:19.059]   - Field: ‘owner’
[10:20:19.059]   - Field: ‘envir’
[10:20:19.059]   - Field: ‘workers’
[10:20:19.059]   - Field: ‘packages’
[10:20:19.059]   - Field: ‘gc’
[10:20:19.059]   - Field: ‘conditions’
[10:20:19.059]   - Field: ‘persistent’
[10:20:19.059]   - Field: ‘expr’
[10:20:19.059]   - Field: ‘uuid’
[10:20:19.060]   - Field: ‘seed’
[10:20:19.060]   - Field: ‘version’
[10:20:19.060]   - Field: ‘result’
[10:20:19.060]   - Field: ‘asynchronous’
[10:20:19.060]   - Field: ‘calls’
[10:20:19.060]   - Field: ‘globals’
[10:20:19.060]   - Field: ‘stdout’
[10:20:19.060]   - Field: ‘earlySignal’
[10:20:19.060]   - Field: ‘lazy’
[10:20:19.060]   - Field: ‘state’
[10:20:19.060] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:20:19.060] - Launch lazy future ...
[10:20:19.061] Packages needed by the future expression (n = 0): <none>
[10:20:19.061] Packages needed by future strategies (n = 0): <none>
[10:20:19.061] {
[10:20:19.061]     {
[10:20:19.061]         {
[10:20:19.061]             ...future.startTime <- base::Sys.time()
[10:20:19.061]             {
[10:20:19.061]                 {
[10:20:19.061]                   {
[10:20:19.061]                     {
[10:20:19.061]                       base::local({
[10:20:19.061]                         has_future <- base::requireNamespace("future", 
[10:20:19.061]                           quietly = TRUE)
[10:20:19.061]                         if (has_future) {
[10:20:19.061]                           ns <- base::getNamespace("future")
[10:20:19.061]                           version <- ns[[".package"]][["version"]]
[10:20:19.061]                           if (is.null(version)) 
[10:20:19.061]                             version <- utils::packageVersion("future")
[10:20:19.061]                         }
[10:20:19.061]                         else {
[10:20:19.061]                           version <- NULL
[10:20:19.061]                         }
[10:20:19.061]                         if (!has_future || version < "1.8.0") {
[10:20:19.061]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:19.061]                             "", base::R.version$version.string), 
[10:20:19.061]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:19.061]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:19.061]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:19.061]                               "release", "version")], collapse = " "), 
[10:20:19.061]                             hostname = base::Sys.info()[["nodename"]])
[10:20:19.061]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:19.061]                             info)
[10:20:19.061]                           info <- base::paste(info, collapse = "; ")
[10:20:19.061]                           if (!has_future) {
[10:20:19.061]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:19.061]                               info)
[10:20:19.061]                           }
[10:20:19.061]                           else {
[10:20:19.061]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:19.061]                               info, version)
[10:20:19.061]                           }
[10:20:19.061]                           base::stop(msg)
[10:20:19.061]                         }
[10:20:19.061]                       })
[10:20:19.061]                     }
[10:20:19.061]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:19.061]                     base::options(mc.cores = 1L)
[10:20:19.061]                   }
[10:20:19.061]                   ...future.strategy.old <- future::plan("list")
[10:20:19.061]                   options(future.plan = NULL)
[10:20:19.061]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:19.061]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:19.061]                 }
[10:20:19.061]                 ...future.workdir <- getwd()
[10:20:19.061]             }
[10:20:19.061]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:19.061]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:19.061]         }
[10:20:19.061]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:19.061]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:19.061]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:19.061]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:19.061]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:19.061]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:19.061]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:19.061]             base::names(...future.oldOptions))
[10:20:19.061]     }
[10:20:19.061]     if (FALSE) {
[10:20:19.061]     }
[10:20:19.061]     else {
[10:20:19.061]         if (TRUE) {
[10:20:19.061]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:19.061]                 open = "w")
[10:20:19.061]         }
[10:20:19.061]         else {
[10:20:19.061]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:19.061]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:19.061]         }
[10:20:19.061]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:19.061]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:19.061]             base::sink(type = "output", split = FALSE)
[10:20:19.061]             base::close(...future.stdout)
[10:20:19.061]         }, add = TRUE)
[10:20:19.061]     }
[10:20:19.061]     ...future.frame <- base::sys.nframe()
[10:20:19.061]     ...future.conditions <- base::list()
[10:20:19.061]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:19.061]     if (FALSE) {
[10:20:19.061]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:19.061]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:19.061]     }
[10:20:19.061]     ...future.result <- base::tryCatch({
[10:20:19.061]         base::withCallingHandlers({
[10:20:19.061]             ...future.value <- base::withVisible(base::local({
[10:20:19.061]                 ...future.makeSendCondition <- base::local({
[10:20:19.061]                   sendCondition <- NULL
[10:20:19.061]                   function(frame = 1L) {
[10:20:19.061]                     if (is.function(sendCondition)) 
[10:20:19.061]                       return(sendCondition)
[10:20:19.061]                     ns <- getNamespace("parallel")
[10:20:19.061]                     if (exists("sendData", mode = "function", 
[10:20:19.061]                       envir = ns)) {
[10:20:19.061]                       parallel_sendData <- get("sendData", mode = "function", 
[10:20:19.061]                         envir = ns)
[10:20:19.061]                       envir <- sys.frame(frame)
[10:20:19.061]                       master <- NULL
[10:20:19.061]                       while (!identical(envir, .GlobalEnv) && 
[10:20:19.061]                         !identical(envir, emptyenv())) {
[10:20:19.061]                         if (exists("master", mode = "list", envir = envir, 
[10:20:19.061]                           inherits = FALSE)) {
[10:20:19.061]                           master <- get("master", mode = "list", 
[10:20:19.061]                             envir = envir, inherits = FALSE)
[10:20:19.061]                           if (inherits(master, c("SOCKnode", 
[10:20:19.061]                             "SOCK0node"))) {
[10:20:19.061]                             sendCondition <<- function(cond) {
[10:20:19.061]                               data <- list(type = "VALUE", value = cond, 
[10:20:19.061]                                 success = TRUE)
[10:20:19.061]                               parallel_sendData(master, data)
[10:20:19.061]                             }
[10:20:19.061]                             return(sendCondition)
[10:20:19.061]                           }
[10:20:19.061]                         }
[10:20:19.061]                         frame <- frame + 1L
[10:20:19.061]                         envir <- sys.frame(frame)
[10:20:19.061]                       }
[10:20:19.061]                     }
[10:20:19.061]                     sendCondition <<- function(cond) NULL
[10:20:19.061]                   }
[10:20:19.061]                 })
[10:20:19.061]                 withCallingHandlers({
[10:20:19.061]                   {
[10:20:19.061]                     do.call(function(...) {
[10:20:19.061]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:19.061]                       if (!identical(...future.globals.maxSize.org, 
[10:20:19.061]                         ...future.globals.maxSize)) {
[10:20:19.061]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:19.061]                         on.exit(options(oopts), add = TRUE)
[10:20:19.061]                       }
[10:20:19.061]                       {
[10:20:19.061]                         lapply(seq_along(...future.elements_ii), 
[10:20:19.061]                           FUN = function(jj) {
[10:20:19.061]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:19.061]                             ...future.FUN(...future.X_jj, ...)
[10:20:19.061]                           })
[10:20:19.061]                       }
[10:20:19.061]                     }, args = future.call.arguments)
[10:20:19.061]                   }
[10:20:19.061]                 }, immediateCondition = function(cond) {
[10:20:19.061]                   sendCondition <- ...future.makeSendCondition()
[10:20:19.061]                   sendCondition(cond)
[10:20:19.061]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:19.061]                   {
[10:20:19.061]                     inherits <- base::inherits
[10:20:19.061]                     invokeRestart <- base::invokeRestart
[10:20:19.061]                     is.null <- base::is.null
[10:20:19.061]                     muffled <- FALSE
[10:20:19.061]                     if (inherits(cond, "message")) {
[10:20:19.061]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:19.061]                       if (muffled) 
[10:20:19.061]                         invokeRestart("muffleMessage")
[10:20:19.061]                     }
[10:20:19.061]                     else if (inherits(cond, "warning")) {
[10:20:19.061]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:19.061]                       if (muffled) 
[10:20:19.061]                         invokeRestart("muffleWarning")
[10:20:19.061]                     }
[10:20:19.061]                     else if (inherits(cond, "condition")) {
[10:20:19.061]                       if (!is.null(pattern)) {
[10:20:19.061]                         computeRestarts <- base::computeRestarts
[10:20:19.061]                         grepl <- base::grepl
[10:20:19.061]                         restarts <- computeRestarts(cond)
[10:20:19.061]                         for (restart in restarts) {
[10:20:19.061]                           name <- restart$name
[10:20:19.061]                           if (is.null(name)) 
[10:20:19.061]                             next
[10:20:19.061]                           if (!grepl(pattern, name)) 
[10:20:19.061]                             next
[10:20:19.061]                           invokeRestart(restart)
[10:20:19.061]                           muffled <- TRUE
[10:20:19.061]                           break
[10:20:19.061]                         }
[10:20:19.061]                       }
[10:20:19.061]                     }
[10:20:19.061]                     invisible(muffled)
[10:20:19.061]                   }
[10:20:19.061]                   muffleCondition(cond)
[10:20:19.061]                 })
[10:20:19.061]             }))
[10:20:19.061]             future::FutureResult(value = ...future.value$value, 
[10:20:19.061]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:19.061]                   ...future.rng), globalenv = if (FALSE) 
[10:20:19.061]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:19.061]                     ...future.globalenv.names))
[10:20:19.061]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:19.061]         }, condition = base::local({
[10:20:19.061]             c <- base::c
[10:20:19.061]             inherits <- base::inherits
[10:20:19.061]             invokeRestart <- base::invokeRestart
[10:20:19.061]             length <- base::length
[10:20:19.061]             list <- base::list
[10:20:19.061]             seq.int <- base::seq.int
[10:20:19.061]             signalCondition <- base::signalCondition
[10:20:19.061]             sys.calls <- base::sys.calls
[10:20:19.061]             `[[` <- base::`[[`
[10:20:19.061]             `+` <- base::`+`
[10:20:19.061]             `<<-` <- base::`<<-`
[10:20:19.061]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:19.061]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:19.061]                   3L)]
[10:20:19.061]             }
[10:20:19.061]             function(cond) {
[10:20:19.061]                 is_error <- inherits(cond, "error")
[10:20:19.061]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:19.061]                   NULL)
[10:20:19.061]                 if (is_error) {
[10:20:19.061]                   sessionInformation <- function() {
[10:20:19.061]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:19.061]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:19.061]                       search = base::search(), system = base::Sys.info())
[10:20:19.061]                   }
[10:20:19.061]                   ...future.conditions[[length(...future.conditions) + 
[10:20:19.061]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:19.061]                     cond$call), session = sessionInformation(), 
[10:20:19.061]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:19.061]                   signalCondition(cond)
[10:20:19.061]                 }
[10:20:19.061]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:19.061]                 "immediateCondition"))) {
[10:20:19.061]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:19.061]                   ...future.conditions[[length(...future.conditions) + 
[10:20:19.061]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:19.061]                   if (TRUE && !signal) {
[10:20:19.061]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:19.061]                     {
[10:20:19.061]                       inherits <- base::inherits
[10:20:19.061]                       invokeRestart <- base::invokeRestart
[10:20:19.061]                       is.null <- base::is.null
[10:20:19.061]                       muffled <- FALSE
[10:20:19.061]                       if (inherits(cond, "message")) {
[10:20:19.061]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:19.061]                         if (muffled) 
[10:20:19.061]                           invokeRestart("muffleMessage")
[10:20:19.061]                       }
[10:20:19.061]                       else if (inherits(cond, "warning")) {
[10:20:19.061]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:19.061]                         if (muffled) 
[10:20:19.061]                           invokeRestart("muffleWarning")
[10:20:19.061]                       }
[10:20:19.061]                       else if (inherits(cond, "condition")) {
[10:20:19.061]                         if (!is.null(pattern)) {
[10:20:19.061]                           computeRestarts <- base::computeRestarts
[10:20:19.061]                           grepl <- base::grepl
[10:20:19.061]                           restarts <- computeRestarts(cond)
[10:20:19.061]                           for (restart in restarts) {
[10:20:19.061]                             name <- restart$name
[10:20:19.061]                             if (is.null(name)) 
[10:20:19.061]                               next
[10:20:19.061]                             if (!grepl(pattern, name)) 
[10:20:19.061]                               next
[10:20:19.061]                             invokeRestart(restart)
[10:20:19.061]                             muffled <- TRUE
[10:20:19.061]                             break
[10:20:19.061]                           }
[10:20:19.061]                         }
[10:20:19.061]                       }
[10:20:19.061]                       invisible(muffled)
[10:20:19.061]                     }
[10:20:19.061]                     muffleCondition(cond, pattern = "^muffle")
[10:20:19.061]                   }
[10:20:19.061]                 }
[10:20:19.061]                 else {
[10:20:19.061]                   if (TRUE) {
[10:20:19.061]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:19.061]                     {
[10:20:19.061]                       inherits <- base::inherits
[10:20:19.061]                       invokeRestart <- base::invokeRestart
[10:20:19.061]                       is.null <- base::is.null
[10:20:19.061]                       muffled <- FALSE
[10:20:19.061]                       if (inherits(cond, "message")) {
[10:20:19.061]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:19.061]                         if (muffled) 
[10:20:19.061]                           invokeRestart("muffleMessage")
[10:20:19.061]                       }
[10:20:19.061]                       else if (inherits(cond, "warning")) {
[10:20:19.061]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:19.061]                         if (muffled) 
[10:20:19.061]                           invokeRestart("muffleWarning")
[10:20:19.061]                       }
[10:20:19.061]                       else if (inherits(cond, "condition")) {
[10:20:19.061]                         if (!is.null(pattern)) {
[10:20:19.061]                           computeRestarts <- base::computeRestarts
[10:20:19.061]                           grepl <- base::grepl
[10:20:19.061]                           restarts <- computeRestarts(cond)
[10:20:19.061]                           for (restart in restarts) {
[10:20:19.061]                             name <- restart$name
[10:20:19.061]                             if (is.null(name)) 
[10:20:19.061]                               next
[10:20:19.061]                             if (!grepl(pattern, name)) 
[10:20:19.061]                               next
[10:20:19.061]                             invokeRestart(restart)
[10:20:19.061]                             muffled <- TRUE
[10:20:19.061]                             break
[10:20:19.061]                           }
[10:20:19.061]                         }
[10:20:19.061]                       }
[10:20:19.061]                       invisible(muffled)
[10:20:19.061]                     }
[10:20:19.061]                     muffleCondition(cond, pattern = "^muffle")
[10:20:19.061]                   }
[10:20:19.061]                 }
[10:20:19.061]             }
[10:20:19.061]         }))
[10:20:19.061]     }, error = function(ex) {
[10:20:19.061]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:19.061]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:19.061]                 ...future.rng), started = ...future.startTime, 
[10:20:19.061]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:19.061]             version = "1.8"), class = "FutureResult")
[10:20:19.061]     }, finally = {
[10:20:19.061]         if (!identical(...future.workdir, getwd())) 
[10:20:19.061]             setwd(...future.workdir)
[10:20:19.061]         {
[10:20:19.061]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:19.061]                 ...future.oldOptions$nwarnings <- NULL
[10:20:19.061]             }
[10:20:19.061]             base::options(...future.oldOptions)
[10:20:19.061]             if (.Platform$OS.type == "windows") {
[10:20:19.061]                 old_names <- names(...future.oldEnvVars)
[10:20:19.061]                 envs <- base::Sys.getenv()
[10:20:19.061]                 names <- names(envs)
[10:20:19.061]                 common <- intersect(names, old_names)
[10:20:19.061]                 added <- setdiff(names, old_names)
[10:20:19.061]                 removed <- setdiff(old_names, names)
[10:20:19.061]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:19.061]                   envs[common]]
[10:20:19.061]                 NAMES <- toupper(changed)
[10:20:19.061]                 args <- list()
[10:20:19.061]                 for (kk in seq_along(NAMES)) {
[10:20:19.061]                   name <- changed[[kk]]
[10:20:19.061]                   NAME <- NAMES[[kk]]
[10:20:19.061]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:19.061]                     next
[10:20:19.061]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:19.061]                 }
[10:20:19.061]                 NAMES <- toupper(added)
[10:20:19.061]                 for (kk in seq_along(NAMES)) {
[10:20:19.061]                   name <- added[[kk]]
[10:20:19.061]                   NAME <- NAMES[[kk]]
[10:20:19.061]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:19.061]                     next
[10:20:19.061]                   args[[name]] <- ""
[10:20:19.061]                 }
[10:20:19.061]                 NAMES <- toupper(removed)
[10:20:19.061]                 for (kk in seq_along(NAMES)) {
[10:20:19.061]                   name <- removed[[kk]]
[10:20:19.061]                   NAME <- NAMES[[kk]]
[10:20:19.061]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:19.061]                     next
[10:20:19.061]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:19.061]                 }
[10:20:19.061]                 if (length(args) > 0) 
[10:20:19.061]                   base::do.call(base::Sys.setenv, args = args)
[10:20:19.061]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:19.061]             }
[10:20:19.061]             else {
[10:20:19.061]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:19.061]             }
[10:20:19.061]             {
[10:20:19.061]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:19.061]                   0L) {
[10:20:19.061]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:19.061]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:19.061]                   base::options(opts)
[10:20:19.061]                 }
[10:20:19.061]                 {
[10:20:19.061]                   {
[10:20:19.061]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:19.061]                     NULL
[10:20:19.061]                   }
[10:20:19.061]                   options(future.plan = NULL)
[10:20:19.061]                   if (is.na(NA_character_)) 
[10:20:19.061]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:19.061]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:19.061]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:19.061]                     .init = FALSE)
[10:20:19.061]                 }
[10:20:19.061]             }
[10:20:19.061]         }
[10:20:19.061]     })
[10:20:19.061]     if (TRUE) {
[10:20:19.061]         base::sink(type = "output", split = FALSE)
[10:20:19.061]         if (TRUE) {
[10:20:19.061]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:19.061]         }
[10:20:19.061]         else {
[10:20:19.061]             ...future.result["stdout"] <- base::list(NULL)
[10:20:19.061]         }
[10:20:19.061]         base::close(...future.stdout)
[10:20:19.061]         ...future.stdout <- NULL
[10:20:19.061]     }
[10:20:19.061]     ...future.result$conditions <- ...future.conditions
[10:20:19.061]     ...future.result$finished <- base::Sys.time()
[10:20:19.061]     ...future.result
[10:20:19.061] }
[10:20:19.064] Exporting 5 global objects (1.46 KiB) to cluster node #1 ...
[10:20:19.064] Exporting ‘...future.FUN’ (841 bytes) to cluster node #1 ...
[10:20:19.065] Exporting ‘...future.FUN’ (841 bytes) to cluster node #1 ... DONE
[10:20:19.065] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:20:19.065] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:20:19.065] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ...
[10:20:19.066] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ... DONE
[10:20:19.066] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:20:19.066] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:20:19.066] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:20:19.067] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:20:19.067] Exporting 5 global objects (1.46 KiB) to cluster node #1 ... DONE
[10:20:19.067] MultisessionFuture started
[10:20:19.068] - Launch lazy future ... done
[10:20:19.068] run() for ‘MultisessionFuture’ ... done
[10:20:19.068] Created future:
[10:20:19.068] MultisessionFuture:
[10:20:19.068] Label: ‘future_lapply-1’
[10:20:19.068] Expression:
[10:20:19.068] {
[10:20:19.068]     do.call(function(...) {
[10:20:19.068]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:19.068]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:19.068]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:19.068]             on.exit(options(oopts), add = TRUE)
[10:20:19.068]         }
[10:20:19.068]         {
[10:20:19.068]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:19.068]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:19.068]                 ...future.FUN(...future.X_jj, ...)
[10:20:19.068]             })
[10:20:19.068]         }
[10:20:19.068]     }, args = future.call.arguments)
[10:20:19.068] }
[10:20:19.068] Lazy evaluation: FALSE
[10:20:19.068] Asynchronous evaluation: TRUE
[10:20:19.068] Local evaluation: TRUE
[10:20:19.068] Environment: R_GlobalEnv
[10:20:19.068] Capture standard output: TRUE
[10:20:19.068] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:19.068] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:19.068] Packages: <none>
[10:20:19.068] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:19.068] Resolved: FALSE
[10:20:19.068] Value: <not collected>
[10:20:19.068] Conditions captured: <none>
[10:20:19.068] Early signaling: FALSE
[10:20:19.068] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:19.068] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:19.079] Chunk #1 of 2 ... DONE
[10:20:19.079] Chunk #2 of 2 ...
[10:20:19.079]  - Finding globals in 'X' for chunk #2 ...
[10:20:19.080] getGlobalsAndPackages() ...
[10:20:19.080] Searching for globals...
[10:20:19.080] 
[10:20:19.080] Searching for globals ... DONE
[10:20:19.080] - globals: [0] <none>
[10:20:19.080] getGlobalsAndPackages() ... DONE
[10:20:19.080]    + additional globals found: [n=0] 
[10:20:19.080]    + additional namespaces needed: [n=0] 
[10:20:19.080]  - Finding globals in 'X' for chunk #2 ... DONE
[10:20:19.081]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:19.081]  - seeds: <none>
[10:20:19.081]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:19.081] getGlobalsAndPackages() ...
[10:20:19.081] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:19.081] Resolving globals: FALSE
[10:20:19.081] Tweak future expression to call with '...' arguments ...
[10:20:19.081] {
[10:20:19.081]     do.call(function(...) {
[10:20:19.081]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:19.081]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:19.081]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:19.081]             on.exit(options(oopts), add = TRUE)
[10:20:19.081]         }
[10:20:19.081]         {
[10:20:19.081]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:19.081]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:19.081]                 ...future.FUN(...future.X_jj, ...)
[10:20:19.081]             })
[10:20:19.081]         }
[10:20:19.081]     }, args = future.call.arguments)
[10:20:19.081] }
[10:20:19.081] Tweak future expression to call with '...' arguments ... DONE
[10:20:19.082] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:19.082] 
[10:20:19.082] getGlobalsAndPackages() ... DONE
[10:20:19.082] run() for ‘Future’ ...
[10:20:19.082] - state: ‘created’
[10:20:19.082] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:20:19.098] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:19.098] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:20:19.098]   - Field: ‘node’
[10:20:19.099]   - Field: ‘label’
[10:20:19.099]   - Field: ‘local’
[10:20:19.099]   - Field: ‘owner’
[10:20:19.099]   - Field: ‘envir’
[10:20:19.099]   - Field: ‘workers’
[10:20:19.099]   - Field: ‘packages’
[10:20:19.099]   - Field: ‘gc’
[10:20:19.099]   - Field: ‘conditions’
[10:20:19.099]   - Field: ‘persistent’
[10:20:19.099]   - Field: ‘expr’
[10:20:19.099]   - Field: ‘uuid’
[10:20:19.099]   - Field: ‘seed’
[10:20:19.100]   - Field: ‘version’
[10:20:19.100]   - Field: ‘result’
[10:20:19.100]   - Field: ‘asynchronous’
[10:20:19.100]   - Field: ‘calls’
[10:20:19.100]   - Field: ‘globals’
[10:20:19.100]   - Field: ‘stdout’
[10:20:19.100]   - Field: ‘earlySignal’
[10:20:19.100]   - Field: ‘lazy’
[10:20:19.100]   - Field: ‘state’
[10:20:19.100] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:20:19.100] - Launch lazy future ...
[10:20:19.101] Packages needed by the future expression (n = 0): <none>
[10:20:19.101] Packages needed by future strategies (n = 0): <none>
[10:20:19.101] {
[10:20:19.101]     {
[10:20:19.101]         {
[10:20:19.101]             ...future.startTime <- base::Sys.time()
[10:20:19.101]             {
[10:20:19.101]                 {
[10:20:19.101]                   {
[10:20:19.101]                     {
[10:20:19.101]                       base::local({
[10:20:19.101]                         has_future <- base::requireNamespace("future", 
[10:20:19.101]                           quietly = TRUE)
[10:20:19.101]                         if (has_future) {
[10:20:19.101]                           ns <- base::getNamespace("future")
[10:20:19.101]                           version <- ns[[".package"]][["version"]]
[10:20:19.101]                           if (is.null(version)) 
[10:20:19.101]                             version <- utils::packageVersion("future")
[10:20:19.101]                         }
[10:20:19.101]                         else {
[10:20:19.101]                           version <- NULL
[10:20:19.101]                         }
[10:20:19.101]                         if (!has_future || version < "1.8.0") {
[10:20:19.101]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:19.101]                             "", base::R.version$version.string), 
[10:20:19.101]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:19.101]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:19.101]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:19.101]                               "release", "version")], collapse = " "), 
[10:20:19.101]                             hostname = base::Sys.info()[["nodename"]])
[10:20:19.101]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:19.101]                             info)
[10:20:19.101]                           info <- base::paste(info, collapse = "; ")
[10:20:19.101]                           if (!has_future) {
[10:20:19.101]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:19.101]                               info)
[10:20:19.101]                           }
[10:20:19.101]                           else {
[10:20:19.101]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:19.101]                               info, version)
[10:20:19.101]                           }
[10:20:19.101]                           base::stop(msg)
[10:20:19.101]                         }
[10:20:19.101]                       })
[10:20:19.101]                     }
[10:20:19.101]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:19.101]                     base::options(mc.cores = 1L)
[10:20:19.101]                   }
[10:20:19.101]                   ...future.strategy.old <- future::plan("list")
[10:20:19.101]                   options(future.plan = NULL)
[10:20:19.101]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:19.101]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:19.101]                 }
[10:20:19.101]                 ...future.workdir <- getwd()
[10:20:19.101]             }
[10:20:19.101]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:19.101]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:19.101]         }
[10:20:19.101]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:19.101]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:19.101]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:19.101]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:19.101]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:19.101]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:19.101]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:19.101]             base::names(...future.oldOptions))
[10:20:19.101]     }
[10:20:19.101]     if (FALSE) {
[10:20:19.101]     }
[10:20:19.101]     else {
[10:20:19.101]         if (TRUE) {
[10:20:19.101]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:19.101]                 open = "w")
[10:20:19.101]         }
[10:20:19.101]         else {
[10:20:19.101]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:19.101]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:19.101]         }
[10:20:19.101]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:19.101]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:19.101]             base::sink(type = "output", split = FALSE)
[10:20:19.101]             base::close(...future.stdout)
[10:20:19.101]         }, add = TRUE)
[10:20:19.101]     }
[10:20:19.101]     ...future.frame <- base::sys.nframe()
[10:20:19.101]     ...future.conditions <- base::list()
[10:20:19.101]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:19.101]     if (FALSE) {
[10:20:19.101]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:19.101]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:19.101]     }
[10:20:19.101]     ...future.result <- base::tryCatch({
[10:20:19.101]         base::withCallingHandlers({
[10:20:19.101]             ...future.value <- base::withVisible(base::local({
[10:20:19.101]                 ...future.makeSendCondition <- base::local({
[10:20:19.101]                   sendCondition <- NULL
[10:20:19.101]                   function(frame = 1L) {
[10:20:19.101]                     if (is.function(sendCondition)) 
[10:20:19.101]                       return(sendCondition)
[10:20:19.101]                     ns <- getNamespace("parallel")
[10:20:19.101]                     if (exists("sendData", mode = "function", 
[10:20:19.101]                       envir = ns)) {
[10:20:19.101]                       parallel_sendData <- get("sendData", mode = "function", 
[10:20:19.101]                         envir = ns)
[10:20:19.101]                       envir <- sys.frame(frame)
[10:20:19.101]                       master <- NULL
[10:20:19.101]                       while (!identical(envir, .GlobalEnv) && 
[10:20:19.101]                         !identical(envir, emptyenv())) {
[10:20:19.101]                         if (exists("master", mode = "list", envir = envir, 
[10:20:19.101]                           inherits = FALSE)) {
[10:20:19.101]                           master <- get("master", mode = "list", 
[10:20:19.101]                             envir = envir, inherits = FALSE)
[10:20:19.101]                           if (inherits(master, c("SOCKnode", 
[10:20:19.101]                             "SOCK0node"))) {
[10:20:19.101]                             sendCondition <<- function(cond) {
[10:20:19.101]                               data <- list(type = "VALUE", value = cond, 
[10:20:19.101]                                 success = TRUE)
[10:20:19.101]                               parallel_sendData(master, data)
[10:20:19.101]                             }
[10:20:19.101]                             return(sendCondition)
[10:20:19.101]                           }
[10:20:19.101]                         }
[10:20:19.101]                         frame <- frame + 1L
[10:20:19.101]                         envir <- sys.frame(frame)
[10:20:19.101]                       }
[10:20:19.101]                     }
[10:20:19.101]                     sendCondition <<- function(cond) NULL
[10:20:19.101]                   }
[10:20:19.101]                 })
[10:20:19.101]                 withCallingHandlers({
[10:20:19.101]                   {
[10:20:19.101]                     do.call(function(...) {
[10:20:19.101]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:19.101]                       if (!identical(...future.globals.maxSize.org, 
[10:20:19.101]                         ...future.globals.maxSize)) {
[10:20:19.101]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:19.101]                         on.exit(options(oopts), add = TRUE)
[10:20:19.101]                       }
[10:20:19.101]                       {
[10:20:19.101]                         lapply(seq_along(...future.elements_ii), 
[10:20:19.101]                           FUN = function(jj) {
[10:20:19.101]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:19.101]                             ...future.FUN(...future.X_jj, ...)
[10:20:19.101]                           })
[10:20:19.101]                       }
[10:20:19.101]                     }, args = future.call.arguments)
[10:20:19.101]                   }
[10:20:19.101]                 }, immediateCondition = function(cond) {
[10:20:19.101]                   sendCondition <- ...future.makeSendCondition()
[10:20:19.101]                   sendCondition(cond)
[10:20:19.101]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:19.101]                   {
[10:20:19.101]                     inherits <- base::inherits
[10:20:19.101]                     invokeRestart <- base::invokeRestart
[10:20:19.101]                     is.null <- base::is.null
[10:20:19.101]                     muffled <- FALSE
[10:20:19.101]                     if (inherits(cond, "message")) {
[10:20:19.101]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:19.101]                       if (muffled) 
[10:20:19.101]                         invokeRestart("muffleMessage")
[10:20:19.101]                     }
[10:20:19.101]                     else if (inherits(cond, "warning")) {
[10:20:19.101]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:19.101]                       if (muffled) 
[10:20:19.101]                         invokeRestart("muffleWarning")
[10:20:19.101]                     }
[10:20:19.101]                     else if (inherits(cond, "condition")) {
[10:20:19.101]                       if (!is.null(pattern)) {
[10:20:19.101]                         computeRestarts <- base::computeRestarts
[10:20:19.101]                         grepl <- base::grepl
[10:20:19.101]                         restarts <- computeRestarts(cond)
[10:20:19.101]                         for (restart in restarts) {
[10:20:19.101]                           name <- restart$name
[10:20:19.101]                           if (is.null(name)) 
[10:20:19.101]                             next
[10:20:19.101]                           if (!grepl(pattern, name)) 
[10:20:19.101]                             next
[10:20:19.101]                           invokeRestart(restart)
[10:20:19.101]                           muffled <- TRUE
[10:20:19.101]                           break
[10:20:19.101]                         }
[10:20:19.101]                       }
[10:20:19.101]                     }
[10:20:19.101]                     invisible(muffled)
[10:20:19.101]                   }
[10:20:19.101]                   muffleCondition(cond)
[10:20:19.101]                 })
[10:20:19.101]             }))
[10:20:19.101]             future::FutureResult(value = ...future.value$value, 
[10:20:19.101]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:19.101]                   ...future.rng), globalenv = if (FALSE) 
[10:20:19.101]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:19.101]                     ...future.globalenv.names))
[10:20:19.101]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:19.101]         }, condition = base::local({
[10:20:19.101]             c <- base::c
[10:20:19.101]             inherits <- base::inherits
[10:20:19.101]             invokeRestart <- base::invokeRestart
[10:20:19.101]             length <- base::length
[10:20:19.101]             list <- base::list
[10:20:19.101]             seq.int <- base::seq.int
[10:20:19.101]             signalCondition <- base::signalCondition
[10:20:19.101]             sys.calls <- base::sys.calls
[10:20:19.101]             `[[` <- base::`[[`
[10:20:19.101]             `+` <- base::`+`
[10:20:19.101]             `<<-` <- base::`<<-`
[10:20:19.101]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:19.101]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:19.101]                   3L)]
[10:20:19.101]             }
[10:20:19.101]             function(cond) {
[10:20:19.101]                 is_error <- inherits(cond, "error")
[10:20:19.101]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:19.101]                   NULL)
[10:20:19.101]                 if (is_error) {
[10:20:19.101]                   sessionInformation <- function() {
[10:20:19.101]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:19.101]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:19.101]                       search = base::search(), system = base::Sys.info())
[10:20:19.101]                   }
[10:20:19.101]                   ...future.conditions[[length(...future.conditions) + 
[10:20:19.101]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:19.101]                     cond$call), session = sessionInformation(), 
[10:20:19.101]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:19.101]                   signalCondition(cond)
[10:20:19.101]                 }
[10:20:19.101]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:19.101]                 "immediateCondition"))) {
[10:20:19.101]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:19.101]                   ...future.conditions[[length(...future.conditions) + 
[10:20:19.101]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:19.101]                   if (TRUE && !signal) {
[10:20:19.101]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:19.101]                     {
[10:20:19.101]                       inherits <- base::inherits
[10:20:19.101]                       invokeRestart <- base::invokeRestart
[10:20:19.101]                       is.null <- base::is.null
[10:20:19.101]                       muffled <- FALSE
[10:20:19.101]                       if (inherits(cond, "message")) {
[10:20:19.101]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:19.101]                         if (muffled) 
[10:20:19.101]                           invokeRestart("muffleMessage")
[10:20:19.101]                       }
[10:20:19.101]                       else if (inherits(cond, "warning")) {
[10:20:19.101]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:19.101]                         if (muffled) 
[10:20:19.101]                           invokeRestart("muffleWarning")
[10:20:19.101]                       }
[10:20:19.101]                       else if (inherits(cond, "condition")) {
[10:20:19.101]                         if (!is.null(pattern)) {
[10:20:19.101]                           computeRestarts <- base::computeRestarts
[10:20:19.101]                           grepl <- base::grepl
[10:20:19.101]                           restarts <- computeRestarts(cond)
[10:20:19.101]                           for (restart in restarts) {
[10:20:19.101]                             name <- restart$name
[10:20:19.101]                             if (is.null(name)) 
[10:20:19.101]                               next
[10:20:19.101]                             if (!grepl(pattern, name)) 
[10:20:19.101]                               next
[10:20:19.101]                             invokeRestart(restart)
[10:20:19.101]                             muffled <- TRUE
[10:20:19.101]                             break
[10:20:19.101]                           }
[10:20:19.101]                         }
[10:20:19.101]                       }
[10:20:19.101]                       invisible(muffled)
[10:20:19.101]                     }
[10:20:19.101]                     muffleCondition(cond, pattern = "^muffle")
[10:20:19.101]                   }
[10:20:19.101]                 }
[10:20:19.101]                 else {
[10:20:19.101]                   if (TRUE) {
[10:20:19.101]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:19.101]                     {
[10:20:19.101]                       inherits <- base::inherits
[10:20:19.101]                       invokeRestart <- base::invokeRestart
[10:20:19.101]                       is.null <- base::is.null
[10:20:19.101]                       muffled <- FALSE
[10:20:19.101]                       if (inherits(cond, "message")) {
[10:20:19.101]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:19.101]                         if (muffled) 
[10:20:19.101]                           invokeRestart("muffleMessage")
[10:20:19.101]                       }
[10:20:19.101]                       else if (inherits(cond, "warning")) {
[10:20:19.101]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:19.101]                         if (muffled) 
[10:20:19.101]                           invokeRestart("muffleWarning")
[10:20:19.101]                       }
[10:20:19.101]                       else if (inherits(cond, "condition")) {
[10:20:19.101]                         if (!is.null(pattern)) {
[10:20:19.101]                           computeRestarts <- base::computeRestarts
[10:20:19.101]                           grepl <- base::grepl
[10:20:19.101]                           restarts <- computeRestarts(cond)
[10:20:19.101]                           for (restart in restarts) {
[10:20:19.101]                             name <- restart$name
[10:20:19.101]                             if (is.null(name)) 
[10:20:19.101]                               next
[10:20:19.101]                             if (!grepl(pattern, name)) 
[10:20:19.101]                               next
[10:20:19.101]                             invokeRestart(restart)
[10:20:19.101]                             muffled <- TRUE
[10:20:19.101]                             break
[10:20:19.101]                           }
[10:20:19.101]                         }
[10:20:19.101]                       }
[10:20:19.101]                       invisible(muffled)
[10:20:19.101]                     }
[10:20:19.101]                     muffleCondition(cond, pattern = "^muffle")
[10:20:19.101]                   }
[10:20:19.101]                 }
[10:20:19.101]             }
[10:20:19.101]         }))
[10:20:19.101]     }, error = function(ex) {
[10:20:19.101]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:19.101]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:19.101]                 ...future.rng), started = ...future.startTime, 
[10:20:19.101]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:19.101]             version = "1.8"), class = "FutureResult")
[10:20:19.101]     }, finally = {
[10:20:19.101]         if (!identical(...future.workdir, getwd())) 
[10:20:19.101]             setwd(...future.workdir)
[10:20:19.101]         {
[10:20:19.101]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:19.101]                 ...future.oldOptions$nwarnings <- NULL
[10:20:19.101]             }
[10:20:19.101]             base::options(...future.oldOptions)
[10:20:19.101]             if (.Platform$OS.type == "windows") {
[10:20:19.101]                 old_names <- names(...future.oldEnvVars)
[10:20:19.101]                 envs <- base::Sys.getenv()
[10:20:19.101]                 names <- names(envs)
[10:20:19.101]                 common <- intersect(names, old_names)
[10:20:19.101]                 added <- setdiff(names, old_names)
[10:20:19.101]                 removed <- setdiff(old_names, names)
[10:20:19.101]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:19.101]                   envs[common]]
[10:20:19.101]                 NAMES <- toupper(changed)
[10:20:19.101]                 args <- list()
[10:20:19.101]                 for (kk in seq_along(NAMES)) {
[10:20:19.101]                   name <- changed[[kk]]
[10:20:19.101]                   NAME <- NAMES[[kk]]
[10:20:19.101]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:19.101]                     next
[10:20:19.101]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:19.101]                 }
[10:20:19.101]                 NAMES <- toupper(added)
[10:20:19.101]                 for (kk in seq_along(NAMES)) {
[10:20:19.101]                   name <- added[[kk]]
[10:20:19.101]                   NAME <- NAMES[[kk]]
[10:20:19.101]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:19.101]                     next
[10:20:19.101]                   args[[name]] <- ""
[10:20:19.101]                 }
[10:20:19.101]                 NAMES <- toupper(removed)
[10:20:19.101]                 for (kk in seq_along(NAMES)) {
[10:20:19.101]                   name <- removed[[kk]]
[10:20:19.101]                   NAME <- NAMES[[kk]]
[10:20:19.101]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:19.101]                     next
[10:20:19.101]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:19.101]                 }
[10:20:19.101]                 if (length(args) > 0) 
[10:20:19.101]                   base::do.call(base::Sys.setenv, args = args)
[10:20:19.101]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:19.101]             }
[10:20:19.101]             else {
[10:20:19.101]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:19.101]             }
[10:20:19.101]             {
[10:20:19.101]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:19.101]                   0L) {
[10:20:19.101]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:19.101]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:19.101]                   base::options(opts)
[10:20:19.101]                 }
[10:20:19.101]                 {
[10:20:19.101]                   {
[10:20:19.101]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:19.101]                     NULL
[10:20:19.101]                   }
[10:20:19.101]                   options(future.plan = NULL)
[10:20:19.101]                   if (is.na(NA_character_)) 
[10:20:19.101]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:19.101]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:19.101]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:19.101]                     .init = FALSE)
[10:20:19.101]                 }
[10:20:19.101]             }
[10:20:19.101]         }
[10:20:19.101]     })
[10:20:19.101]     if (TRUE) {
[10:20:19.101]         base::sink(type = "output", split = FALSE)
[10:20:19.101]         if (TRUE) {
[10:20:19.101]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:19.101]         }
[10:20:19.101]         else {
[10:20:19.101]             ...future.result["stdout"] <- base::list(NULL)
[10:20:19.101]         }
[10:20:19.101]         base::close(...future.stdout)
[10:20:19.101]         ...future.stdout <- NULL
[10:20:19.101]     }
[10:20:19.101]     ...future.result$conditions <- ...future.conditions
[10:20:19.101]     ...future.result$finished <- base::Sys.time()
[10:20:19.101]     ...future.result
[10:20:19.101] }
[10:20:19.104] Exporting 5 global objects (1.46 KiB) to cluster node #2 ...
[10:20:19.104] Exporting ‘...future.FUN’ (841 bytes) to cluster node #2 ...
[10:20:19.105] Exporting ‘...future.FUN’ (841 bytes) to cluster node #2 ... DONE
[10:20:19.105] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:20:19.105] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:20:19.105] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ...
[10:20:19.105] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ... DONE
[10:20:19.106] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:20:19.106] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:20:19.106] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:20:19.106] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:20:19.107] Exporting 5 global objects (1.46 KiB) to cluster node #2 ... DONE
[10:20:19.107] MultisessionFuture started
[10:20:19.107] - Launch lazy future ... done
[10:20:19.107] run() for ‘MultisessionFuture’ ... done
[10:20:19.107] Created future:
[10:20:19.107] MultisessionFuture:
[10:20:19.107] Label: ‘future_lapply-2’
[10:20:19.107] Expression:
[10:20:19.107] {
[10:20:19.107]     do.call(function(...) {
[10:20:19.107]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:19.107]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:19.107]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:19.107]             on.exit(options(oopts), add = TRUE)
[10:20:19.107]         }
[10:20:19.107]         {
[10:20:19.107]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:19.107]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:19.107]                 ...future.FUN(...future.X_jj, ...)
[10:20:19.107]             })
[10:20:19.107]         }
[10:20:19.107]     }, args = future.call.arguments)
[10:20:19.107] }
[10:20:19.107] Lazy evaluation: FALSE
[10:20:19.107] Asynchronous evaluation: TRUE
[10:20:19.107] Local evaluation: TRUE
[10:20:19.107] Environment: R_GlobalEnv
[10:20:19.107] Capture standard output: TRUE
[10:20:19.107] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:19.107] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:19.107] Packages: <none>
[10:20:19.107] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:19.107] Resolved: FALSE
[10:20:19.107] Value: <not collected>
[10:20:19.107] Conditions captured: <none>
[10:20:19.107] Early signaling: FALSE
[10:20:19.107] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:19.107] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:19.119] Chunk #2 of 2 ... DONE
[10:20:19.119] Launching 2 futures (chunks) ... DONE
[10:20:19.119] Resolving 2 futures (chunks) ...
[10:20:19.119] resolve() on list ...
[10:20:19.119]  recursive: 0
[10:20:19.120]  length: 2
[10:20:19.120] 
[10:20:19.162] receiveMessageFromWorker() for ClusterFuture ...
[10:20:19.162] - Validating connection of MultisessionFuture
[10:20:19.162] - received message: FutureResult
[10:20:19.162] - Received FutureResult
[10:20:19.162] - Erased future from FutureRegistry
[10:20:19.162] result() for ClusterFuture ...
[10:20:19.162] - result already collected: FutureResult
[10:20:19.162] result() for ClusterFuture ... done
[10:20:19.163] receiveMessageFromWorker() for ClusterFuture ... done
[10:20:19.163] Future #2
[10:20:19.163] result() for ClusterFuture ...
[10:20:19.163] - result already collected: FutureResult
[10:20:19.163] result() for ClusterFuture ... done
[10:20:19.163] result() for ClusterFuture ...
[10:20:19.163] - result already collected: FutureResult
[10:20:19.163] result() for ClusterFuture ... done
[10:20:19.163] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:20:19.163] - nx: 2
[10:20:19.163] - relay: TRUE
[10:20:19.163] - stdout: TRUE
[10:20:19.164] - signal: TRUE
[10:20:19.164] - resignal: FALSE
[10:20:19.164] - force: TRUE
[10:20:19.164] - relayed: [n=2] FALSE, FALSE
[10:20:19.164] - queued futures: [n=2] FALSE, FALSE
[10:20:19.164]  - until=1
[10:20:19.164]  - relaying element #1
[10:20:19.164] - relayed: [n=2] FALSE, FALSE
[10:20:19.164] - queued futures: [n=2] FALSE, TRUE
[10:20:19.164] signalConditionsASAP(NULL, pos=2) ... done
[10:20:19.164]  length: 1 (resolved future 2)
[10:20:19.611] receiveMessageFromWorker() for ClusterFuture ...
[10:20:19.611] - Validating connection of MultisessionFuture
[10:20:19.611] - received message: FutureResult
[10:20:19.611] - Received FutureResult
[10:20:19.612] - Erased future from FutureRegistry
[10:20:19.612] result() for ClusterFuture ...
[10:20:19.612] - result already collected: FutureResult
[10:20:19.612] result() for ClusterFuture ... done
[10:20:19.612] receiveMessageFromWorker() for ClusterFuture ... done
[10:20:19.612] Future #1
[10:20:19.612] result() for ClusterFuture ...
[10:20:19.612] - result already collected: FutureResult
[10:20:19.612] result() for ClusterFuture ... done
[10:20:19.612] result() for ClusterFuture ...
[10:20:19.612] - result already collected: FutureResult
[10:20:19.612] result() for ClusterFuture ... done
[10:20:19.613] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:20:19.613] - nx: 2
[10:20:19.613] - relay: TRUE
[10:20:19.613] - stdout: TRUE
[10:20:19.613] - signal: TRUE
[10:20:19.613] - resignal: FALSE
[10:20:19.613] - force: TRUE
[10:20:19.613] - relayed: [n=2] FALSE, FALSE
[10:20:19.613] - queued futures: [n=2] FALSE, TRUE
[10:20:19.613]  - until=1
[10:20:19.613]  - relaying element #1
[10:20:19.613] result() for ClusterFuture ...
[10:20:19.614] - result already collected: FutureResult
[10:20:19.614] result() for ClusterFuture ... done
[10:20:19.614] result() for ClusterFuture ...
[10:20:19.614] - result already collected: FutureResult
[10:20:19.614] result() for ClusterFuture ... done
[10:20:19.614] result() for ClusterFuture ...
[10:20:19.614] - result already collected: FutureResult
[10:20:19.614] result() for ClusterFuture ... done
[10:20:19.614] result() for ClusterFuture ...
[10:20:19.614] - result already collected: FutureResult
[10:20:19.614] result() for ClusterFuture ... done
[10:20:19.614] - relayed: [n=2] TRUE, FALSE
[10:20:19.615] - queued futures: [n=2] TRUE, TRUE
[10:20:19.615] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:20:19.615]  length: 0 (resolved future 1)
[10:20:19.615] Relaying remaining futures
[10:20:19.615] signalConditionsASAP(NULL, pos=0) ...
[10:20:19.615] - nx: 2
[10:20:19.615] - relay: TRUE
[10:20:19.615] - stdout: TRUE
[10:20:19.615] - signal: TRUE
[10:20:19.615] - resignal: FALSE
[10:20:19.615] - force: TRUE
[10:20:19.615] - relayed: [n=2] TRUE, FALSE
[10:20:19.615] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:20:19.616]  - relaying element #2
[10:20:19.616] result() for ClusterFuture ...
[10:20:19.616] - result already collected: FutureResult
[10:20:19.616] result() for ClusterFuture ... done
[10:20:19.616] result() for ClusterFuture ...
[10:20:19.616] - result already collected: FutureResult
[10:20:19.616] result() for ClusterFuture ... done
[10:20:19.616] result() for ClusterFuture ...
[10:20:19.616] - result already collected: FutureResult
[10:20:19.616] result() for ClusterFuture ... done
[10:20:19.616] result() for ClusterFuture ...
[10:20:19.616] - result already collected: FutureResult
[10:20:19.617] result() for ClusterFuture ... done
[10:20:19.617] - relayed: [n=2] TRUE, TRUE
[10:20:19.617] - queued futures: [n=2] TRUE, TRUE
[10:20:19.617] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[10:20:19.617] resolve() on list ... DONE
[10:20:19.617] result() for ClusterFuture ...
[10:20:19.617] - result already collected: FutureResult
[10:20:19.617] result() for ClusterFuture ... done
[10:20:19.617] result() for ClusterFuture ...
[10:20:19.617] - result already collected: FutureResult
[10:20:19.617] result() for ClusterFuture ... done
[10:20:19.617] result() for ClusterFuture ...
[10:20:19.618] - result already collected: FutureResult
[10:20:19.618] result() for ClusterFuture ... done
[10:20:19.618] result() for ClusterFuture ...
[10:20:19.618] - result already collected: FutureResult
[10:20:19.618] result() for ClusterFuture ... done
[10:20:19.618]  - Number of value chunks collected: 2
[10:20:19.618] Resolving 2 futures (chunks) ... DONE
[10:20:19.618] Reducing values from 2 chunks ...
[10:20:19.618]  - Number of values collected after concatenation: 2
[10:20:19.618]  - Number of values expected: 2
[10:20:19.618] Reducing values from 2 chunks ... DONE
[10:20:19.618] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[10:20:19.619] future_lapply() ...
[10:20:19.621] Number of chunks: 2
[10:20:19.621] getGlobalsAndPackagesXApply() ...
[10:20:19.621]  - future.globals: TRUE
[10:20:19.621] getGlobalsAndPackages() ...
[10:20:19.621] Searching for globals...
[10:20:19.623] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:20:19.623] Searching for globals ... DONE
[10:20:19.623] Resolving globals: FALSE
[10:20:19.623] The total size of the 1 globals is 841 bytes (841 bytes)
[10:20:19.624] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[10:20:19.624] - globals: [1] ‘FUN’
[10:20:19.624] 
[10:20:19.624] getGlobalsAndPackages() ... DONE
[10:20:19.624]  - globals found/used: [n=1] ‘FUN’
[10:20:19.624]  - needed namespaces: [n=0] 
[10:20:19.624] Finding globals ... DONE
[10:20:19.624]  - use_args: TRUE
[10:20:19.624]  - Getting '...' globals ...
[10:20:19.625] resolve() on list ...
[10:20:19.625]  recursive: 0
[10:20:19.625]  length: 1
[10:20:19.625]  elements: ‘...’
[10:20:19.625]  length: 0 (resolved future 1)
[10:20:19.625] resolve() on list ... DONE
[10:20:19.625]    - '...' content: [n=0] 
[10:20:19.625] List of 1
[10:20:19.625]  $ ...: list()
[10:20:19.625]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:19.625]  - attr(*, "where")=List of 1
[10:20:19.625]   ..$ ...:<environment: 0x557fc3e24800> 
[10:20:19.625]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:19.625]  - attr(*, "resolved")= logi TRUE
[10:20:19.625]  - attr(*, "total_size")= num NA
[10:20:19.628]  - Getting '...' globals ... DONE
[10:20:19.628] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:20:19.628] List of 2
[10:20:19.628]  $ ...future.FUN:function (x)  
[10:20:19.628]  $ ...          : list()
[10:20:19.628]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:20:19.628]  - attr(*, "where")=List of 2
[10:20:19.628]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:19.628]   ..$ ...          :<environment: 0x557fc3e24800> 
[10:20:19.628]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:19.628]  - attr(*, "resolved")= logi FALSE
[10:20:19.628]  - attr(*, "total_size")= num 5632
[10:20:19.631] Packages to be attached in all futures: [n=0] 
[10:20:19.631] getGlobalsAndPackagesXApply() ... DONE
[10:20:19.631] Number of futures (= number of chunks): 2
[10:20:19.631] Launching 2 futures (chunks) ...
[10:20:19.631] Chunk #1 of 2 ...
[10:20:19.631]  - Finding globals in 'X' for chunk #1 ...
[10:20:19.631] getGlobalsAndPackages() ...
[10:20:19.631] Searching for globals...
[10:20:19.631] 
[10:20:19.632] Searching for globals ... DONE
[10:20:19.632] - globals: [0] <none>
[10:20:19.632] getGlobalsAndPackages() ... DONE
[10:20:19.632]    + additional globals found: [n=0] 
[10:20:19.632]    + additional namespaces needed: [n=0] 
[10:20:19.632]  - Finding globals in 'X' for chunk #1 ... DONE
[10:20:19.632]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:19.632]  - seeds: <none>
[10:20:19.632]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:19.632] getGlobalsAndPackages() ...
[10:20:19.632] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:19.633] Resolving globals: FALSE
[10:20:19.633] Tweak future expression to call with '...' arguments ...
[10:20:19.633] {
[10:20:19.633]     do.call(function(...) {
[10:20:19.633]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:19.633]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:19.633]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:19.633]             on.exit(options(oopts), add = TRUE)
[10:20:19.633]         }
[10:20:19.633]         {
[10:20:19.633]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:19.633]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:19.633]                 ...future.FUN(...future.X_jj, ...)
[10:20:19.633]             })
[10:20:19.633]         }
[10:20:19.633]     }, args = future.call.arguments)
[10:20:19.633] }
[10:20:19.633] Tweak future expression to call with '...' arguments ... DONE
[10:20:19.633] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:19.633] 
[10:20:19.634] getGlobalsAndPackages() ... DONE
[10:20:19.634] run() for ‘Future’ ...
[10:20:19.634] - state: ‘created’
[10:20:19.634] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:20:19.648] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:19.648] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:20:19.648]   - Field: ‘node’
[10:20:19.648]   - Field: ‘label’
[10:20:19.648]   - Field: ‘local’
[10:20:19.648]   - Field: ‘owner’
[10:20:19.648]   - Field: ‘envir’
[10:20:19.648]   - Field: ‘workers’
[10:20:19.648]   - Field: ‘packages’
[10:20:19.649]   - Field: ‘gc’
[10:20:19.649]   - Field: ‘conditions’
[10:20:19.649]   - Field: ‘persistent’
[10:20:19.649]   - Field: ‘expr’
[10:20:19.649]   - Field: ‘uuid’
[10:20:19.649]   - Field: ‘seed’
[10:20:19.649]   - Field: ‘version’
[10:20:19.649]   - Field: ‘result’
[10:20:19.649]   - Field: ‘asynchronous’
[10:20:19.649]   - Field: ‘calls’
[10:20:19.649]   - Field: ‘globals’
[10:20:19.649]   - Field: ‘stdout’
[10:20:19.650]   - Field: ‘earlySignal’
[10:20:19.650]   - Field: ‘lazy’
[10:20:19.650]   - Field: ‘state’
[10:20:19.650] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:20:19.650] - Launch lazy future ...
[10:20:19.650] Packages needed by the future expression (n = 0): <none>
[10:20:19.650] Packages needed by future strategies (n = 0): <none>
[10:20:19.651] {
[10:20:19.651]     {
[10:20:19.651]         {
[10:20:19.651]             ...future.startTime <- base::Sys.time()
[10:20:19.651]             {
[10:20:19.651]                 {
[10:20:19.651]                   {
[10:20:19.651]                     {
[10:20:19.651]                       base::local({
[10:20:19.651]                         has_future <- base::requireNamespace("future", 
[10:20:19.651]                           quietly = TRUE)
[10:20:19.651]                         if (has_future) {
[10:20:19.651]                           ns <- base::getNamespace("future")
[10:20:19.651]                           version <- ns[[".package"]][["version"]]
[10:20:19.651]                           if (is.null(version)) 
[10:20:19.651]                             version <- utils::packageVersion("future")
[10:20:19.651]                         }
[10:20:19.651]                         else {
[10:20:19.651]                           version <- NULL
[10:20:19.651]                         }
[10:20:19.651]                         if (!has_future || version < "1.8.0") {
[10:20:19.651]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:19.651]                             "", base::R.version$version.string), 
[10:20:19.651]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:19.651]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:19.651]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:19.651]                               "release", "version")], collapse = " "), 
[10:20:19.651]                             hostname = base::Sys.info()[["nodename"]])
[10:20:19.651]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:19.651]                             info)
[10:20:19.651]                           info <- base::paste(info, collapse = "; ")
[10:20:19.651]                           if (!has_future) {
[10:20:19.651]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:19.651]                               info)
[10:20:19.651]                           }
[10:20:19.651]                           else {
[10:20:19.651]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:19.651]                               info, version)
[10:20:19.651]                           }
[10:20:19.651]                           base::stop(msg)
[10:20:19.651]                         }
[10:20:19.651]                       })
[10:20:19.651]                     }
[10:20:19.651]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:19.651]                     base::options(mc.cores = 1L)
[10:20:19.651]                   }
[10:20:19.651]                   ...future.strategy.old <- future::plan("list")
[10:20:19.651]                   options(future.plan = NULL)
[10:20:19.651]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:19.651]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:19.651]                 }
[10:20:19.651]                 ...future.workdir <- getwd()
[10:20:19.651]             }
[10:20:19.651]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:19.651]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:19.651]         }
[10:20:19.651]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:19.651]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:19.651]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:19.651]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:19.651]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:19.651]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:19.651]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:19.651]             base::names(...future.oldOptions))
[10:20:19.651]     }
[10:20:19.651]     if (TRUE) {
[10:20:19.651]     }
[10:20:19.651]     else {
[10:20:19.651]         if (NA) {
[10:20:19.651]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:19.651]                 open = "w")
[10:20:19.651]         }
[10:20:19.651]         else {
[10:20:19.651]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:19.651]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:19.651]         }
[10:20:19.651]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:19.651]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:19.651]             base::sink(type = "output", split = FALSE)
[10:20:19.651]             base::close(...future.stdout)
[10:20:19.651]         }, add = TRUE)
[10:20:19.651]     }
[10:20:19.651]     ...future.frame <- base::sys.nframe()
[10:20:19.651]     ...future.conditions <- base::list()
[10:20:19.651]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:19.651]     if (FALSE) {
[10:20:19.651]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:19.651]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:19.651]     }
[10:20:19.651]     ...future.result <- base::tryCatch({
[10:20:19.651]         base::withCallingHandlers({
[10:20:19.651]             ...future.value <- base::withVisible(base::local({
[10:20:19.651]                 ...future.makeSendCondition <- base::local({
[10:20:19.651]                   sendCondition <- NULL
[10:20:19.651]                   function(frame = 1L) {
[10:20:19.651]                     if (is.function(sendCondition)) 
[10:20:19.651]                       return(sendCondition)
[10:20:19.651]                     ns <- getNamespace("parallel")
[10:20:19.651]                     if (exists("sendData", mode = "function", 
[10:20:19.651]                       envir = ns)) {
[10:20:19.651]                       parallel_sendData <- get("sendData", mode = "function", 
[10:20:19.651]                         envir = ns)
[10:20:19.651]                       envir <- sys.frame(frame)
[10:20:19.651]                       master <- NULL
[10:20:19.651]                       while (!identical(envir, .GlobalEnv) && 
[10:20:19.651]                         !identical(envir, emptyenv())) {
[10:20:19.651]                         if (exists("master", mode = "list", envir = envir, 
[10:20:19.651]                           inherits = FALSE)) {
[10:20:19.651]                           master <- get("master", mode = "list", 
[10:20:19.651]                             envir = envir, inherits = FALSE)
[10:20:19.651]                           if (inherits(master, c("SOCKnode", 
[10:20:19.651]                             "SOCK0node"))) {
[10:20:19.651]                             sendCondition <<- function(cond) {
[10:20:19.651]                               data <- list(type = "VALUE", value = cond, 
[10:20:19.651]                                 success = TRUE)
[10:20:19.651]                               parallel_sendData(master, data)
[10:20:19.651]                             }
[10:20:19.651]                             return(sendCondition)
[10:20:19.651]                           }
[10:20:19.651]                         }
[10:20:19.651]                         frame <- frame + 1L
[10:20:19.651]                         envir <- sys.frame(frame)
[10:20:19.651]                       }
[10:20:19.651]                     }
[10:20:19.651]                     sendCondition <<- function(cond) NULL
[10:20:19.651]                   }
[10:20:19.651]                 })
[10:20:19.651]                 withCallingHandlers({
[10:20:19.651]                   {
[10:20:19.651]                     do.call(function(...) {
[10:20:19.651]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:19.651]                       if (!identical(...future.globals.maxSize.org, 
[10:20:19.651]                         ...future.globals.maxSize)) {
[10:20:19.651]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:19.651]                         on.exit(options(oopts), add = TRUE)
[10:20:19.651]                       }
[10:20:19.651]                       {
[10:20:19.651]                         lapply(seq_along(...future.elements_ii), 
[10:20:19.651]                           FUN = function(jj) {
[10:20:19.651]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:19.651]                             ...future.FUN(...future.X_jj, ...)
[10:20:19.651]                           })
[10:20:19.651]                       }
[10:20:19.651]                     }, args = future.call.arguments)
[10:20:19.651]                   }
[10:20:19.651]                 }, immediateCondition = function(cond) {
[10:20:19.651]                   sendCondition <- ...future.makeSendCondition()
[10:20:19.651]                   sendCondition(cond)
[10:20:19.651]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:19.651]                   {
[10:20:19.651]                     inherits <- base::inherits
[10:20:19.651]                     invokeRestart <- base::invokeRestart
[10:20:19.651]                     is.null <- base::is.null
[10:20:19.651]                     muffled <- FALSE
[10:20:19.651]                     if (inherits(cond, "message")) {
[10:20:19.651]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:19.651]                       if (muffled) 
[10:20:19.651]                         invokeRestart("muffleMessage")
[10:20:19.651]                     }
[10:20:19.651]                     else if (inherits(cond, "warning")) {
[10:20:19.651]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:19.651]                       if (muffled) 
[10:20:19.651]                         invokeRestart("muffleWarning")
[10:20:19.651]                     }
[10:20:19.651]                     else if (inherits(cond, "condition")) {
[10:20:19.651]                       if (!is.null(pattern)) {
[10:20:19.651]                         computeRestarts <- base::computeRestarts
[10:20:19.651]                         grepl <- base::grepl
[10:20:19.651]                         restarts <- computeRestarts(cond)
[10:20:19.651]                         for (restart in restarts) {
[10:20:19.651]                           name <- restart$name
[10:20:19.651]                           if (is.null(name)) 
[10:20:19.651]                             next
[10:20:19.651]                           if (!grepl(pattern, name)) 
[10:20:19.651]                             next
[10:20:19.651]                           invokeRestart(restart)
[10:20:19.651]                           muffled <- TRUE
[10:20:19.651]                           break
[10:20:19.651]                         }
[10:20:19.651]                       }
[10:20:19.651]                     }
[10:20:19.651]                     invisible(muffled)
[10:20:19.651]                   }
[10:20:19.651]                   muffleCondition(cond)
[10:20:19.651]                 })
[10:20:19.651]             }))
[10:20:19.651]             future::FutureResult(value = ...future.value$value, 
[10:20:19.651]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:19.651]                   ...future.rng), globalenv = if (FALSE) 
[10:20:19.651]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:19.651]                     ...future.globalenv.names))
[10:20:19.651]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:19.651]         }, condition = base::local({
[10:20:19.651]             c <- base::c
[10:20:19.651]             inherits <- base::inherits
[10:20:19.651]             invokeRestart <- base::invokeRestart
[10:20:19.651]             length <- base::length
[10:20:19.651]             list <- base::list
[10:20:19.651]             seq.int <- base::seq.int
[10:20:19.651]             signalCondition <- base::signalCondition
[10:20:19.651]             sys.calls <- base::sys.calls
[10:20:19.651]             `[[` <- base::`[[`
[10:20:19.651]             `+` <- base::`+`
[10:20:19.651]             `<<-` <- base::`<<-`
[10:20:19.651]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:19.651]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:19.651]                   3L)]
[10:20:19.651]             }
[10:20:19.651]             function(cond) {
[10:20:19.651]                 is_error <- inherits(cond, "error")
[10:20:19.651]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:19.651]                   NULL)
[10:20:19.651]                 if (is_error) {
[10:20:19.651]                   sessionInformation <- function() {
[10:20:19.651]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:19.651]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:19.651]                       search = base::search(), system = base::Sys.info())
[10:20:19.651]                   }
[10:20:19.651]                   ...future.conditions[[length(...future.conditions) + 
[10:20:19.651]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:19.651]                     cond$call), session = sessionInformation(), 
[10:20:19.651]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:19.651]                   signalCondition(cond)
[10:20:19.651]                 }
[10:20:19.651]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:19.651]                 "immediateCondition"))) {
[10:20:19.651]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:19.651]                   ...future.conditions[[length(...future.conditions) + 
[10:20:19.651]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:19.651]                   if (TRUE && !signal) {
[10:20:19.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:19.651]                     {
[10:20:19.651]                       inherits <- base::inherits
[10:20:19.651]                       invokeRestart <- base::invokeRestart
[10:20:19.651]                       is.null <- base::is.null
[10:20:19.651]                       muffled <- FALSE
[10:20:19.651]                       if (inherits(cond, "message")) {
[10:20:19.651]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:19.651]                         if (muffled) 
[10:20:19.651]                           invokeRestart("muffleMessage")
[10:20:19.651]                       }
[10:20:19.651]                       else if (inherits(cond, "warning")) {
[10:20:19.651]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:19.651]                         if (muffled) 
[10:20:19.651]                           invokeRestart("muffleWarning")
[10:20:19.651]                       }
[10:20:19.651]                       else if (inherits(cond, "condition")) {
[10:20:19.651]                         if (!is.null(pattern)) {
[10:20:19.651]                           computeRestarts <- base::computeRestarts
[10:20:19.651]                           grepl <- base::grepl
[10:20:19.651]                           restarts <- computeRestarts(cond)
[10:20:19.651]                           for (restart in restarts) {
[10:20:19.651]                             name <- restart$name
[10:20:19.651]                             if (is.null(name)) 
[10:20:19.651]                               next
[10:20:19.651]                             if (!grepl(pattern, name)) 
[10:20:19.651]                               next
[10:20:19.651]                             invokeRestart(restart)
[10:20:19.651]                             muffled <- TRUE
[10:20:19.651]                             break
[10:20:19.651]                           }
[10:20:19.651]                         }
[10:20:19.651]                       }
[10:20:19.651]                       invisible(muffled)
[10:20:19.651]                     }
[10:20:19.651]                     muffleCondition(cond, pattern = "^muffle")
[10:20:19.651]                   }
[10:20:19.651]                 }
[10:20:19.651]                 else {
[10:20:19.651]                   if (TRUE) {
[10:20:19.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:19.651]                     {
[10:20:19.651]                       inherits <- base::inherits
[10:20:19.651]                       invokeRestart <- base::invokeRestart
[10:20:19.651]                       is.null <- base::is.null
[10:20:19.651]                       muffled <- FALSE
[10:20:19.651]                       if (inherits(cond, "message")) {
[10:20:19.651]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:19.651]                         if (muffled) 
[10:20:19.651]                           invokeRestart("muffleMessage")
[10:20:19.651]                       }
[10:20:19.651]                       else if (inherits(cond, "warning")) {
[10:20:19.651]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:19.651]                         if (muffled) 
[10:20:19.651]                           invokeRestart("muffleWarning")
[10:20:19.651]                       }
[10:20:19.651]                       else if (inherits(cond, "condition")) {
[10:20:19.651]                         if (!is.null(pattern)) {
[10:20:19.651]                           computeRestarts <- base::computeRestarts
[10:20:19.651]                           grepl <- base::grepl
[10:20:19.651]                           restarts <- computeRestarts(cond)
[10:20:19.651]                           for (restart in restarts) {
[10:20:19.651]                             name <- restart$name
[10:20:19.651]                             if (is.null(name)) 
[10:20:19.651]                               next
[10:20:19.651]                             if (!grepl(pattern, name)) 
[10:20:19.651]                               next
[10:20:19.651]                             invokeRestart(restart)
[10:20:19.651]                             muffled <- TRUE
[10:20:19.651]                             break
[10:20:19.651]                           }
[10:20:19.651]                         }
[10:20:19.651]                       }
[10:20:19.651]                       invisible(muffled)
[10:20:19.651]                     }
[10:20:19.651]                     muffleCondition(cond, pattern = "^muffle")
[10:20:19.651]                   }
[10:20:19.651]                 }
[10:20:19.651]             }
[10:20:19.651]         }))
[10:20:19.651]     }, error = function(ex) {
[10:20:19.651]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:19.651]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:19.651]                 ...future.rng), started = ...future.startTime, 
[10:20:19.651]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:19.651]             version = "1.8"), class = "FutureResult")
[10:20:19.651]     }, finally = {
[10:20:19.651]         if (!identical(...future.workdir, getwd())) 
[10:20:19.651]             setwd(...future.workdir)
[10:20:19.651]         {
[10:20:19.651]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:19.651]                 ...future.oldOptions$nwarnings <- NULL
[10:20:19.651]             }
[10:20:19.651]             base::options(...future.oldOptions)
[10:20:19.651]             if (.Platform$OS.type == "windows") {
[10:20:19.651]                 old_names <- names(...future.oldEnvVars)
[10:20:19.651]                 envs <- base::Sys.getenv()
[10:20:19.651]                 names <- names(envs)
[10:20:19.651]                 common <- intersect(names, old_names)
[10:20:19.651]                 added <- setdiff(names, old_names)
[10:20:19.651]                 removed <- setdiff(old_names, names)
[10:20:19.651]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:19.651]                   envs[common]]
[10:20:19.651]                 NAMES <- toupper(changed)
[10:20:19.651]                 args <- list()
[10:20:19.651]                 for (kk in seq_along(NAMES)) {
[10:20:19.651]                   name <- changed[[kk]]
[10:20:19.651]                   NAME <- NAMES[[kk]]
[10:20:19.651]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:19.651]                     next
[10:20:19.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:19.651]                 }
[10:20:19.651]                 NAMES <- toupper(added)
[10:20:19.651]                 for (kk in seq_along(NAMES)) {
[10:20:19.651]                   name <- added[[kk]]
[10:20:19.651]                   NAME <- NAMES[[kk]]
[10:20:19.651]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:19.651]                     next
[10:20:19.651]                   args[[name]] <- ""
[10:20:19.651]                 }
[10:20:19.651]                 NAMES <- toupper(removed)
[10:20:19.651]                 for (kk in seq_along(NAMES)) {
[10:20:19.651]                   name <- removed[[kk]]
[10:20:19.651]                   NAME <- NAMES[[kk]]
[10:20:19.651]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:19.651]                     next
[10:20:19.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:19.651]                 }
[10:20:19.651]                 if (length(args) > 0) 
[10:20:19.651]                   base::do.call(base::Sys.setenv, args = args)
[10:20:19.651]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:19.651]             }
[10:20:19.651]             else {
[10:20:19.651]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:19.651]             }
[10:20:19.651]             {
[10:20:19.651]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:19.651]                   0L) {
[10:20:19.651]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:19.651]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:19.651]                   base::options(opts)
[10:20:19.651]                 }
[10:20:19.651]                 {
[10:20:19.651]                   {
[10:20:19.651]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:19.651]                     NULL
[10:20:19.651]                   }
[10:20:19.651]                   options(future.plan = NULL)
[10:20:19.651]                   if (is.na(NA_character_)) 
[10:20:19.651]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:19.651]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:19.651]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:19.651]                     .init = FALSE)
[10:20:19.651]                 }
[10:20:19.651]             }
[10:20:19.651]         }
[10:20:19.651]     })
[10:20:19.651]     if (FALSE) {
[10:20:19.651]         base::sink(type = "output", split = FALSE)
[10:20:19.651]         if (NA) {
[10:20:19.651]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:19.651]         }
[10:20:19.651]         else {
[10:20:19.651]             ...future.result["stdout"] <- base::list(NULL)
[10:20:19.651]         }
[10:20:19.651]         base::close(...future.stdout)
[10:20:19.651]         ...future.stdout <- NULL
[10:20:19.651]     }
[10:20:19.651]     ...future.result$conditions <- ...future.conditions
[10:20:19.651]     ...future.result$finished <- base::Sys.time()
[10:20:19.651]     ...future.result
[10:20:19.651] }
[10:20:19.653] Exporting 5 global objects (1.46 KiB) to cluster node #1 ...
[10:20:19.654] Exporting ‘...future.FUN’ (841 bytes) to cluster node #1 ...
[10:20:19.654] Exporting ‘...future.FUN’ (841 bytes) to cluster node #1 ... DONE
[10:20:19.654] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:20:19.655] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:20:19.655] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ...
[10:20:19.655] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ... DONE
[10:20:19.655] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:20:19.656] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:20:19.656] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:20:19.656] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:20:19.656] Exporting 5 global objects (1.46 KiB) to cluster node #1 ... DONE
[10:20:19.657] MultisessionFuture started
[10:20:19.657] - Launch lazy future ... done
[10:20:19.657] run() for ‘MultisessionFuture’ ... done
[10:20:19.657] Created future:
[10:20:19.657] MultisessionFuture:
[10:20:19.657] Label: ‘future_lapply-1’
[10:20:19.657] Expression:
[10:20:19.657] {
[10:20:19.657]     do.call(function(...) {
[10:20:19.657]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:19.657]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:19.657]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:19.657]             on.exit(options(oopts), add = TRUE)
[10:20:19.657]         }
[10:20:19.657]         {
[10:20:19.657]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:19.657]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:19.657]                 ...future.FUN(...future.X_jj, ...)
[10:20:19.657]             })
[10:20:19.657]         }
[10:20:19.657]     }, args = future.call.arguments)
[10:20:19.657] }
[10:20:19.657] Lazy evaluation: FALSE
[10:20:19.657] Asynchronous evaluation: TRUE
[10:20:19.657] Local evaluation: TRUE
[10:20:19.657] Environment: R_GlobalEnv
[10:20:19.657] Capture standard output: NA
[10:20:19.657] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:19.657] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:19.657] Packages: <none>
[10:20:19.657] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:19.657] Resolved: FALSE
[10:20:19.657] Value: <not collected>
[10:20:19.657] Conditions captured: <none>
[10:20:19.657] Early signaling: FALSE
[10:20:19.657] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:19.657] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:19.668] Chunk #1 of 2 ... DONE
[10:20:19.668] Chunk #2 of 2 ...
[10:20:19.669]  - Finding globals in 'X' for chunk #2 ...
[10:20:19.669] getGlobalsAndPackages() ...
[10:20:19.669] Searching for globals...
[10:20:19.671] 
[10:20:19.671] Searching for globals ... DONE
[10:20:19.671] - globals: [0] <none>
[10:20:19.671] getGlobalsAndPackages() ... DONE
[10:20:19.672]    + additional globals found: [n=0] 
[10:20:19.672]    + additional namespaces needed: [n=0] 
[10:20:19.672]  - Finding globals in 'X' for chunk #2 ... DONE
[10:20:19.672]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:19.672]  - seeds: <none>
[10:20:19.672]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:19.672] getGlobalsAndPackages() ...
[10:20:19.672] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:19.672] Resolving globals: FALSE
[10:20:19.672] Tweak future expression to call with '...' arguments ...
[10:20:19.672] {
[10:20:19.672]     do.call(function(...) {
[10:20:19.672]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:19.672]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:19.672]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:19.672]             on.exit(options(oopts), add = TRUE)
[10:20:19.672]         }
[10:20:19.672]         {
[10:20:19.672]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:19.672]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:19.672]                 ...future.FUN(...future.X_jj, ...)
[10:20:19.672]             })
[10:20:19.672]         }
[10:20:19.672]     }, args = future.call.arguments)
[10:20:19.672] }
[10:20:19.673] Tweak future expression to call with '...' arguments ... DONE
[10:20:19.673] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:19.673] 
[10:20:19.673] getGlobalsAndPackages() ... DONE
[10:20:19.673] run() for ‘Future’ ...
[10:20:19.674] - state: ‘created’
[10:20:19.674] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:20:19.688] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:19.688] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:20:19.688]   - Field: ‘node’
[10:20:19.688]   - Field: ‘label’
[10:20:19.688]   - Field: ‘local’
[10:20:19.688]   - Field: ‘owner’
[10:20:19.689]   - Field: ‘envir’
[10:20:19.689]   - Field: ‘workers’
[10:20:19.689]   - Field: ‘packages’
[10:20:19.689]   - Field: ‘gc’
[10:20:19.689]   - Field: ‘conditions’
[10:20:19.689]   - Field: ‘persistent’
[10:20:19.689]   - Field: ‘expr’
[10:20:19.689]   - Field: ‘uuid’
[10:20:19.689]   - Field: ‘seed’
[10:20:19.689]   - Field: ‘version’
[10:20:19.689]   - Field: ‘result’
[10:20:19.689]   - Field: ‘asynchronous’
[10:20:19.690]   - Field: ‘calls’
[10:20:19.690]   - Field: ‘globals’
[10:20:19.690]   - Field: ‘stdout’
[10:20:19.690]   - Field: ‘earlySignal’
[10:20:19.690]   - Field: ‘lazy’
[10:20:19.690]   - Field: ‘state’
[10:20:19.690] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:20:19.690] - Launch lazy future ...
[10:20:19.690] Packages needed by the future expression (n = 0): <none>
[10:20:19.690] Packages needed by future strategies (n = 0): <none>
[10:20:19.691] {
[10:20:19.691]     {
[10:20:19.691]         {
[10:20:19.691]             ...future.startTime <- base::Sys.time()
[10:20:19.691]             {
[10:20:19.691]                 {
[10:20:19.691]                   {
[10:20:19.691]                     {
[10:20:19.691]                       base::local({
[10:20:19.691]                         has_future <- base::requireNamespace("future", 
[10:20:19.691]                           quietly = TRUE)
[10:20:19.691]                         if (has_future) {
[10:20:19.691]                           ns <- base::getNamespace("future")
[10:20:19.691]                           version <- ns[[".package"]][["version"]]
[10:20:19.691]                           if (is.null(version)) 
[10:20:19.691]                             version <- utils::packageVersion("future")
[10:20:19.691]                         }
[10:20:19.691]                         else {
[10:20:19.691]                           version <- NULL
[10:20:19.691]                         }
[10:20:19.691]                         if (!has_future || version < "1.8.0") {
[10:20:19.691]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:19.691]                             "", base::R.version$version.string), 
[10:20:19.691]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:19.691]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:19.691]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:19.691]                               "release", "version")], collapse = " "), 
[10:20:19.691]                             hostname = base::Sys.info()[["nodename"]])
[10:20:19.691]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:19.691]                             info)
[10:20:19.691]                           info <- base::paste(info, collapse = "; ")
[10:20:19.691]                           if (!has_future) {
[10:20:19.691]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:19.691]                               info)
[10:20:19.691]                           }
[10:20:19.691]                           else {
[10:20:19.691]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:19.691]                               info, version)
[10:20:19.691]                           }
[10:20:19.691]                           base::stop(msg)
[10:20:19.691]                         }
[10:20:19.691]                       })
[10:20:19.691]                     }
[10:20:19.691]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:19.691]                     base::options(mc.cores = 1L)
[10:20:19.691]                   }
[10:20:19.691]                   ...future.strategy.old <- future::plan("list")
[10:20:19.691]                   options(future.plan = NULL)
[10:20:19.691]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:19.691]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:19.691]                 }
[10:20:19.691]                 ...future.workdir <- getwd()
[10:20:19.691]             }
[10:20:19.691]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:19.691]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:19.691]         }
[10:20:19.691]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:19.691]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:19.691]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:19.691]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:19.691]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:19.691]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:19.691]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:19.691]             base::names(...future.oldOptions))
[10:20:19.691]     }
[10:20:19.691]     if (TRUE) {
[10:20:19.691]     }
[10:20:19.691]     else {
[10:20:19.691]         if (NA) {
[10:20:19.691]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:19.691]                 open = "w")
[10:20:19.691]         }
[10:20:19.691]         else {
[10:20:19.691]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:19.691]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:19.691]         }
[10:20:19.691]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:19.691]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:19.691]             base::sink(type = "output", split = FALSE)
[10:20:19.691]             base::close(...future.stdout)
[10:20:19.691]         }, add = TRUE)
[10:20:19.691]     }
[10:20:19.691]     ...future.frame <- base::sys.nframe()
[10:20:19.691]     ...future.conditions <- base::list()
[10:20:19.691]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:19.691]     if (FALSE) {
[10:20:19.691]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:19.691]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:19.691]     }
[10:20:19.691]     ...future.result <- base::tryCatch({
[10:20:19.691]         base::withCallingHandlers({
[10:20:19.691]             ...future.value <- base::withVisible(base::local({
[10:20:19.691]                 ...future.makeSendCondition <- base::local({
[10:20:19.691]                   sendCondition <- NULL
[10:20:19.691]                   function(frame = 1L) {
[10:20:19.691]                     if (is.function(sendCondition)) 
[10:20:19.691]                       return(sendCondition)
[10:20:19.691]                     ns <- getNamespace("parallel")
[10:20:19.691]                     if (exists("sendData", mode = "function", 
[10:20:19.691]                       envir = ns)) {
[10:20:19.691]                       parallel_sendData <- get("sendData", mode = "function", 
[10:20:19.691]                         envir = ns)
[10:20:19.691]                       envir <- sys.frame(frame)
[10:20:19.691]                       master <- NULL
[10:20:19.691]                       while (!identical(envir, .GlobalEnv) && 
[10:20:19.691]                         !identical(envir, emptyenv())) {
[10:20:19.691]                         if (exists("master", mode = "list", envir = envir, 
[10:20:19.691]                           inherits = FALSE)) {
[10:20:19.691]                           master <- get("master", mode = "list", 
[10:20:19.691]                             envir = envir, inherits = FALSE)
[10:20:19.691]                           if (inherits(master, c("SOCKnode", 
[10:20:19.691]                             "SOCK0node"))) {
[10:20:19.691]                             sendCondition <<- function(cond) {
[10:20:19.691]                               data <- list(type = "VALUE", value = cond, 
[10:20:19.691]                                 success = TRUE)
[10:20:19.691]                               parallel_sendData(master, data)
[10:20:19.691]                             }
[10:20:19.691]                             return(sendCondition)
[10:20:19.691]                           }
[10:20:19.691]                         }
[10:20:19.691]                         frame <- frame + 1L
[10:20:19.691]                         envir <- sys.frame(frame)
[10:20:19.691]                       }
[10:20:19.691]                     }
[10:20:19.691]                     sendCondition <<- function(cond) NULL
[10:20:19.691]                   }
[10:20:19.691]                 })
[10:20:19.691]                 withCallingHandlers({
[10:20:19.691]                   {
[10:20:19.691]                     do.call(function(...) {
[10:20:19.691]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:19.691]                       if (!identical(...future.globals.maxSize.org, 
[10:20:19.691]                         ...future.globals.maxSize)) {
[10:20:19.691]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:19.691]                         on.exit(options(oopts), add = TRUE)
[10:20:19.691]                       }
[10:20:19.691]                       {
[10:20:19.691]                         lapply(seq_along(...future.elements_ii), 
[10:20:19.691]                           FUN = function(jj) {
[10:20:19.691]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:19.691]                             ...future.FUN(...future.X_jj, ...)
[10:20:19.691]                           })
[10:20:19.691]                       }
[10:20:19.691]                     }, args = future.call.arguments)
[10:20:19.691]                   }
[10:20:19.691]                 }, immediateCondition = function(cond) {
[10:20:19.691]                   sendCondition <- ...future.makeSendCondition()
[10:20:19.691]                   sendCondition(cond)
[10:20:19.691]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:19.691]                   {
[10:20:19.691]                     inherits <- base::inherits
[10:20:19.691]                     invokeRestart <- base::invokeRestart
[10:20:19.691]                     is.null <- base::is.null
[10:20:19.691]                     muffled <- FALSE
[10:20:19.691]                     if (inherits(cond, "message")) {
[10:20:19.691]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:19.691]                       if (muffled) 
[10:20:19.691]                         invokeRestart("muffleMessage")
[10:20:19.691]                     }
[10:20:19.691]                     else if (inherits(cond, "warning")) {
[10:20:19.691]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:19.691]                       if (muffled) 
[10:20:19.691]                         invokeRestart("muffleWarning")
[10:20:19.691]                     }
[10:20:19.691]                     else if (inherits(cond, "condition")) {
[10:20:19.691]                       if (!is.null(pattern)) {
[10:20:19.691]                         computeRestarts <- base::computeRestarts
[10:20:19.691]                         grepl <- base::grepl
[10:20:19.691]                         restarts <- computeRestarts(cond)
[10:20:19.691]                         for (restart in restarts) {
[10:20:19.691]                           name <- restart$name
[10:20:19.691]                           if (is.null(name)) 
[10:20:19.691]                             next
[10:20:19.691]                           if (!grepl(pattern, name)) 
[10:20:19.691]                             next
[10:20:19.691]                           invokeRestart(restart)
[10:20:19.691]                           muffled <- TRUE
[10:20:19.691]                           break
[10:20:19.691]                         }
[10:20:19.691]                       }
[10:20:19.691]                     }
[10:20:19.691]                     invisible(muffled)
[10:20:19.691]                   }
[10:20:19.691]                   muffleCondition(cond)
[10:20:19.691]                 })
[10:20:19.691]             }))
[10:20:19.691]             future::FutureResult(value = ...future.value$value, 
[10:20:19.691]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:19.691]                   ...future.rng), globalenv = if (FALSE) 
[10:20:19.691]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:19.691]                     ...future.globalenv.names))
[10:20:19.691]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:19.691]         }, condition = base::local({
[10:20:19.691]             c <- base::c
[10:20:19.691]             inherits <- base::inherits
[10:20:19.691]             invokeRestart <- base::invokeRestart
[10:20:19.691]             length <- base::length
[10:20:19.691]             list <- base::list
[10:20:19.691]             seq.int <- base::seq.int
[10:20:19.691]             signalCondition <- base::signalCondition
[10:20:19.691]             sys.calls <- base::sys.calls
[10:20:19.691]             `[[` <- base::`[[`
[10:20:19.691]             `+` <- base::`+`
[10:20:19.691]             `<<-` <- base::`<<-`
[10:20:19.691]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:19.691]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:19.691]                   3L)]
[10:20:19.691]             }
[10:20:19.691]             function(cond) {
[10:20:19.691]                 is_error <- inherits(cond, "error")
[10:20:19.691]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:19.691]                   NULL)
[10:20:19.691]                 if (is_error) {
[10:20:19.691]                   sessionInformation <- function() {
[10:20:19.691]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:19.691]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:19.691]                       search = base::search(), system = base::Sys.info())
[10:20:19.691]                   }
[10:20:19.691]                   ...future.conditions[[length(...future.conditions) + 
[10:20:19.691]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:19.691]                     cond$call), session = sessionInformation(), 
[10:20:19.691]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:19.691]                   signalCondition(cond)
[10:20:19.691]                 }
[10:20:19.691]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:19.691]                 "immediateCondition"))) {
[10:20:19.691]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:19.691]                   ...future.conditions[[length(...future.conditions) + 
[10:20:19.691]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:19.691]                   if (TRUE && !signal) {
[10:20:19.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:19.691]                     {
[10:20:19.691]                       inherits <- base::inherits
[10:20:19.691]                       invokeRestart <- base::invokeRestart
[10:20:19.691]                       is.null <- base::is.null
[10:20:19.691]                       muffled <- FALSE
[10:20:19.691]                       if (inherits(cond, "message")) {
[10:20:19.691]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:19.691]                         if (muffled) 
[10:20:19.691]                           invokeRestart("muffleMessage")
[10:20:19.691]                       }
[10:20:19.691]                       else if (inherits(cond, "warning")) {
[10:20:19.691]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:19.691]                         if (muffled) 
[10:20:19.691]                           invokeRestart("muffleWarning")
[10:20:19.691]                       }
[10:20:19.691]                       else if (inherits(cond, "condition")) {
[10:20:19.691]                         if (!is.null(pattern)) {
[10:20:19.691]                           computeRestarts <- base::computeRestarts
[10:20:19.691]                           grepl <- base::grepl
[10:20:19.691]                           restarts <- computeRestarts(cond)
[10:20:19.691]                           for (restart in restarts) {
[10:20:19.691]                             name <- restart$name
[10:20:19.691]                             if (is.null(name)) 
[10:20:19.691]                               next
[10:20:19.691]                             if (!grepl(pattern, name)) 
[10:20:19.691]                               next
[10:20:19.691]                             invokeRestart(restart)
[10:20:19.691]                             muffled <- TRUE
[10:20:19.691]                             break
[10:20:19.691]                           }
[10:20:19.691]                         }
[10:20:19.691]                       }
[10:20:19.691]                       invisible(muffled)
[10:20:19.691]                     }
[10:20:19.691]                     muffleCondition(cond, pattern = "^muffle")
[10:20:19.691]                   }
[10:20:19.691]                 }
[10:20:19.691]                 else {
[10:20:19.691]                   if (TRUE) {
[10:20:19.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:19.691]                     {
[10:20:19.691]                       inherits <- base::inherits
[10:20:19.691]                       invokeRestart <- base::invokeRestart
[10:20:19.691]                       is.null <- base::is.null
[10:20:19.691]                       muffled <- FALSE
[10:20:19.691]                       if (inherits(cond, "message")) {
[10:20:19.691]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:19.691]                         if (muffled) 
[10:20:19.691]                           invokeRestart("muffleMessage")
[10:20:19.691]                       }
[10:20:19.691]                       else if (inherits(cond, "warning")) {
[10:20:19.691]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:19.691]                         if (muffled) 
[10:20:19.691]                           invokeRestart("muffleWarning")
[10:20:19.691]                       }
[10:20:19.691]                       else if (inherits(cond, "condition")) {
[10:20:19.691]                         if (!is.null(pattern)) {
[10:20:19.691]                           computeRestarts <- base::computeRestarts
[10:20:19.691]                           grepl <- base::grepl
[10:20:19.691]                           restarts <- computeRestarts(cond)
[10:20:19.691]                           for (restart in restarts) {
[10:20:19.691]                             name <- restart$name
[10:20:19.691]                             if (is.null(name)) 
[10:20:19.691]                               next
[10:20:19.691]                             if (!grepl(pattern, name)) 
[10:20:19.691]                               next
[10:20:19.691]                             invokeRestart(restart)
[10:20:19.691]                             muffled <- TRUE
[10:20:19.691]                             break
[10:20:19.691]                           }
[10:20:19.691]                         }
[10:20:19.691]                       }
[10:20:19.691]                       invisible(muffled)
[10:20:19.691]                     }
[10:20:19.691]                     muffleCondition(cond, pattern = "^muffle")
[10:20:19.691]                   }
[10:20:19.691]                 }
[10:20:19.691]             }
[10:20:19.691]         }))
[10:20:19.691]     }, error = function(ex) {
[10:20:19.691]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:19.691]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:19.691]                 ...future.rng), started = ...future.startTime, 
[10:20:19.691]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:19.691]             version = "1.8"), class = "FutureResult")
[10:20:19.691]     }, finally = {
[10:20:19.691]         if (!identical(...future.workdir, getwd())) 
[10:20:19.691]             setwd(...future.workdir)
[10:20:19.691]         {
[10:20:19.691]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:19.691]                 ...future.oldOptions$nwarnings <- NULL
[10:20:19.691]             }
[10:20:19.691]             base::options(...future.oldOptions)
[10:20:19.691]             if (.Platform$OS.type == "windows") {
[10:20:19.691]                 old_names <- names(...future.oldEnvVars)
[10:20:19.691]                 envs <- base::Sys.getenv()
[10:20:19.691]                 names <- names(envs)
[10:20:19.691]                 common <- intersect(names, old_names)
[10:20:19.691]                 added <- setdiff(names, old_names)
[10:20:19.691]                 removed <- setdiff(old_names, names)
[10:20:19.691]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:19.691]                   envs[common]]
[10:20:19.691]                 NAMES <- toupper(changed)
[10:20:19.691]                 args <- list()
[10:20:19.691]                 for (kk in seq_along(NAMES)) {
[10:20:19.691]                   name <- changed[[kk]]
[10:20:19.691]                   NAME <- NAMES[[kk]]
[10:20:19.691]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:19.691]                     next
[10:20:19.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:19.691]                 }
[10:20:19.691]                 NAMES <- toupper(added)
[10:20:19.691]                 for (kk in seq_along(NAMES)) {
[10:20:19.691]                   name <- added[[kk]]
[10:20:19.691]                   NAME <- NAMES[[kk]]
[10:20:19.691]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:19.691]                     next
[10:20:19.691]                   args[[name]] <- ""
[10:20:19.691]                 }
[10:20:19.691]                 NAMES <- toupper(removed)
[10:20:19.691]                 for (kk in seq_along(NAMES)) {
[10:20:19.691]                   name <- removed[[kk]]
[10:20:19.691]                   NAME <- NAMES[[kk]]
[10:20:19.691]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:19.691]                     next
[10:20:19.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:19.691]                 }
[10:20:19.691]                 if (length(args) > 0) 
[10:20:19.691]                   base::do.call(base::Sys.setenv, args = args)
[10:20:19.691]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:19.691]             }
[10:20:19.691]             else {
[10:20:19.691]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:19.691]             }
[10:20:19.691]             {
[10:20:19.691]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:19.691]                   0L) {
[10:20:19.691]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:19.691]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:19.691]                   base::options(opts)
[10:20:19.691]                 }
[10:20:19.691]                 {
[10:20:19.691]                   {
[10:20:19.691]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:19.691]                     NULL
[10:20:19.691]                   }
[10:20:19.691]                   options(future.plan = NULL)
[10:20:19.691]                   if (is.na(NA_character_)) 
[10:20:19.691]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:19.691]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:19.691]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:19.691]                     .init = FALSE)
[10:20:19.691]                 }
[10:20:19.691]             }
[10:20:19.691]         }
[10:20:19.691]     })
[10:20:19.691]     if (FALSE) {
[10:20:19.691]         base::sink(type = "output", split = FALSE)
[10:20:19.691]         if (NA) {
[10:20:19.691]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:19.691]         }
[10:20:19.691]         else {
[10:20:19.691]             ...future.result["stdout"] <- base::list(NULL)
[10:20:19.691]         }
[10:20:19.691]         base::close(...future.stdout)
[10:20:19.691]         ...future.stdout <- NULL
[10:20:19.691]     }
[10:20:19.691]     ...future.result$conditions <- ...future.conditions
[10:20:19.691]     ...future.result$finished <- base::Sys.time()
[10:20:19.691]     ...future.result
[10:20:19.691] }
[10:20:19.694] Exporting 5 global objects (1.46 KiB) to cluster node #2 ...
[10:20:19.694] Exporting ‘...future.FUN’ (841 bytes) to cluster node #2 ...
[10:20:19.694] Exporting ‘...future.FUN’ (841 bytes) to cluster node #2 ... DONE
[10:20:19.694] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:20:19.695] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:20:19.695] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ...
[10:20:19.695] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ... DONE
[10:20:19.695] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:20:19.695] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:20:19.696] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:20:19.696] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:20:19.696] Exporting 5 global objects (1.46 KiB) to cluster node #2 ... DONE
[10:20:19.696] MultisessionFuture started
[10:20:19.697] - Launch lazy future ... done
[10:20:19.697] run() for ‘MultisessionFuture’ ... done
[10:20:19.697] Created future:
[10:20:19.697] MultisessionFuture:
[10:20:19.697] Label: ‘future_lapply-2’
[10:20:19.697] Expression:
[10:20:19.697] {
[10:20:19.697]     do.call(function(...) {
[10:20:19.697]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:19.697]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:19.697]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:19.697]             on.exit(options(oopts), add = TRUE)
[10:20:19.697]         }
[10:20:19.697]         {
[10:20:19.697]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:20:19.697]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:20:19.697]                 ...future.FUN(...future.X_jj, ...)
[10:20:19.697]             })
[10:20:19.697]         }
[10:20:19.697]     }, args = future.call.arguments)
[10:20:19.697] }
[10:20:19.697] Lazy evaluation: FALSE
[10:20:19.697] Asynchronous evaluation: TRUE
[10:20:19.697] Local evaluation: TRUE
[10:20:19.697] Environment: R_GlobalEnv
[10:20:19.697] Capture standard output: NA
[10:20:19.697] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:19.697] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:19.697] Packages: <none>
[10:20:19.697] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:19.697] Resolved: FALSE
[10:20:19.697] Value: <not collected>
[10:20:19.697] Conditions captured: <none>
[10:20:19.697] Early signaling: FALSE
[10:20:19.697] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:19.697] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:19.709] Chunk #2 of 2 ... DONE
[10:20:19.709] Launching 2 futures (chunks) ... DONE
[10:20:19.709] Resolving 2 futures (chunks) ...
[10:20:19.709] resolve() on list ...
[10:20:19.709]  recursive: 0
[10:20:19.709]  length: 2
[10:20:19.709] 
[10:20:19.751] receiveMessageFromWorker() for ClusterFuture ...
[10:20:19.751] - Validating connection of MultisessionFuture
[10:20:19.751] - received message: FutureResult
[10:20:19.752] - Received FutureResult
[10:20:19.752] - Erased future from FutureRegistry
[10:20:19.752] result() for ClusterFuture ...
[10:20:19.752] - result already collected: FutureResult
[10:20:19.752] result() for ClusterFuture ... done
[10:20:19.752] receiveMessageFromWorker() for ClusterFuture ... done
[10:20:19.752] Future #2
[10:20:19.752] result() for ClusterFuture ...
[10:20:19.752] - result already collected: FutureResult
[10:20:19.752] result() for ClusterFuture ... done
[10:20:19.752] result() for ClusterFuture ...
[10:20:19.753] - result already collected: FutureResult
[10:20:19.753] result() for ClusterFuture ... done
[10:20:19.753] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:20:19.753] - nx: 2
[10:20:19.753] - relay: TRUE
[10:20:19.753] - stdout: TRUE
[10:20:19.753] - signal: TRUE
[10:20:19.753] - resignal: FALSE
[10:20:19.753] - force: TRUE
[10:20:19.753] - relayed: [n=2] FALSE, FALSE
[10:20:19.753] - queued futures: [n=2] FALSE, FALSE
[10:20:19.753]  - until=1
[10:20:19.754]  - relaying element #1
[10:20:19.754] - relayed: [n=2] FALSE, FALSE
[10:20:19.754] - queued futures: [n=2] FALSE, TRUE
[10:20:19.754] signalConditionsASAP(NULL, pos=2) ... done
[10:20:19.754]  length: 1 (resolved future 2)
[10:20:20.200] receiveMessageFromWorker() for ClusterFuture ...
[10:20:20.200] - Validating connection of MultisessionFuture
[10:20:20.200] - received message: FutureResult
[10:20:20.201] - Received FutureResult
[10:20:20.201] - Erased future from FutureRegistry
[10:20:20.201] result() for ClusterFuture ...
[10:20:20.201] - result already collected: FutureResult
[10:20:20.201] result() for ClusterFuture ... done
[10:20:20.201] receiveMessageFromWorker() for ClusterFuture ... done
[10:20:20.201] Future #1
[10:20:20.201] result() for ClusterFuture ...
[10:20:20.201] - result already collected: FutureResult
[10:20:20.201] result() for ClusterFuture ... done
[10:20:20.201] result() for ClusterFuture ...
[10:20:20.202] - result already collected: FutureResult
[10:20:20.202] result() for ClusterFuture ... done
[10:20:20.202] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:20:20.202] - nx: 2
[10:20:20.202] - relay: TRUE
[10:20:20.202] - stdout: TRUE
[10:20:20.202] - signal: TRUE
[10:20:20.202] - resignal: FALSE
[10:20:20.202] - force: TRUE
[10:20:20.202] - relayed: [n=2] FALSE, FALSE
[10:20:20.202] - queued futures: [n=2] FALSE, TRUE
[10:20:20.202]  - until=1
[10:20:20.203]  - relaying element #1
[10:20:20.203] result() for ClusterFuture ...
[10:20:20.203] - result already collected: FutureResult
[10:20:20.203] result() for ClusterFuture ... done
[10:20:20.203] result() for ClusterFuture ...
[10:20:20.203] - result already collected: FutureResult
[10:20:20.203] result() for ClusterFuture ... done
[10:20:20.203] result() for ClusterFuture ...
[10:20:20.203] - result already collected: FutureResult
[10:20:20.203] result() for ClusterFuture ... done
[10:20:20.203] result() for ClusterFuture ...
[10:20:20.203] - result already collected: FutureResult
[10:20:20.204] result() for ClusterFuture ... done
[10:20:20.204] - relayed: [n=2] TRUE, FALSE
[10:20:20.204] - queued futures: [n=2] TRUE, TRUE
[10:20:20.204] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:20:20.204]  length: 0 (resolved future 1)
[10:20:20.204] Relaying remaining futures
[10:20:20.204] signalConditionsASAP(NULL, pos=0) ...
[10:20:20.204] - nx: 2
[10:20:20.204] - relay: TRUE
[10:20:20.204] - stdout: TRUE
[10:20:20.204] - signal: TRUE
[10:20:20.204] - resignal: FALSE
[10:20:20.205] - force: TRUE
[10:20:20.205] - relayed: [n=2] TRUE, FALSE
[10:20:20.205] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:20:20.205]  - relaying element #2
[10:20:20.205] result() for ClusterFuture ...
[10:20:20.205] - result already collected: FutureResult
[10:20:20.205] result() for ClusterFuture ... done
[10:20:20.205] result() for ClusterFuture ...
[10:20:20.205] - result already collected: FutureResult
[10:20:20.205] result() for ClusterFuture ... done
[10:20:20.205] result() for ClusterFuture ...
[10:20:20.205] - result already collected: FutureResult
[10:20:20.206] result() for ClusterFuture ... done
[10:20:20.206] result() for ClusterFuture ...
[10:20:20.206] - result already collected: FutureResult
[10:20:20.206] result() for ClusterFuture ... done
[10:20:20.206] - relayed: [n=2] TRUE, TRUE
[10:20:20.206] - queued futures: [n=2] TRUE, TRUE
[10:20:20.206] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[10:20:20.206] resolve() on list ... DONE
[10:20:20.206] result() for ClusterFuture ...
[10:20:20.206] - result already collected: FutureResult
[10:20:20.206] result() for ClusterFuture ... done
[10:20:20.206] result() for ClusterFuture ...
[10:20:20.207] - result already collected: FutureResult
[10:20:20.207] result() for ClusterFuture ... done
[10:20:20.207] result() for ClusterFuture ...
[10:20:20.207] - result already collected: FutureResult
[10:20:20.207] result() for ClusterFuture ... done
[10:20:20.207] result() for ClusterFuture ...
[10:20:20.207] - result already collected: FutureResult
[10:20:20.207] result() for ClusterFuture ... done
[10:20:20.207]  - Number of value chunks collected: 2
[10:20:20.207] Resolving 2 futures (chunks) ... DONE
[10:20:20.207] Reducing values from 2 chunks ...
[10:20:20.207]  - Number of values collected after concatenation: 2
[10:20:20.208]  - Number of values expected: 2
[10:20:20.208] Reducing values from 2 chunks ... DONE
[10:20:20.208] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[10:20:20.208] future_mapply() ...
[10:20:20.210] Number of chunks: 2
[10:20:20.210] getGlobalsAndPackagesXApply() ...
[10:20:20.210]  - future.globals: TRUE
[10:20:20.210] getGlobalsAndPackages() ...
[10:20:20.210] Searching for globals...
[10:20:20.212] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:20:20.212] Searching for globals ... DONE
[10:20:20.212] Resolving globals: FALSE
[10:20:20.212] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[10:20:20.213] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[10:20:20.213] - globals: [1] ‘FUN’
[10:20:20.213] 
[10:20:20.213] getGlobalsAndPackages() ... DONE
[10:20:20.213]  - globals found/used: [n=1] ‘FUN’
[10:20:20.213]  - needed namespaces: [n=0] 
[10:20:20.213] Finding globals ... DONE
[10:20:20.213] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:20:20.213] List of 2
[10:20:20.213]  $ ...future.FUN:function (x, y)  
[10:20:20.213]  $ MoreArgs     : NULL
[10:20:20.213]  - attr(*, "where")=List of 2
[10:20:20.213]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:20.213]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:20:20.213]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:20.213]  - attr(*, "resolved")= logi FALSE
[10:20:20.213]  - attr(*, "total_size")= num NA
[10:20:20.216] Packages to be attached in all futures: [n=0] 
[10:20:20.216] getGlobalsAndPackagesXApply() ... DONE
[10:20:20.216] Number of futures (= number of chunks): 2
[10:20:20.216] Launching 2 futures (chunks) ...
[10:20:20.216] Chunk #1 of 2 ...
[10:20:20.216]  - Finding globals in '...' for chunk #1 ...
[10:20:20.217] getGlobalsAndPackages() ...
[10:20:20.217] Searching for globals...
[10:20:20.217] 
[10:20:20.217] Searching for globals ... DONE
[10:20:20.217] - globals: [0] <none>
[10:20:20.217] getGlobalsAndPackages() ... DONE
[10:20:20.217]    + additional globals found: [n=0] 
[10:20:20.217]    + additional namespaces needed: [n=0] 
[10:20:20.217]  - Finding globals in '...' for chunk #1 ... DONE
[10:20:20.218]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:20.218]  - seeds: <none>
[10:20:20.218]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:20.218] getGlobalsAndPackages() ...
[10:20:20.218] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:20.218] Resolving globals: FALSE
[10:20:20.218] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[10:20:20.219] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:20:20.219] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:20.219] 
[10:20:20.219] getGlobalsAndPackages() ... DONE
[10:20:20.219] run() for ‘Future’ ...
[10:20:20.220] - state: ‘created’
[10:20:20.220] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:20:20.234] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:20.234] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:20:20.234]   - Field: ‘node’
[10:20:20.234]   - Field: ‘label’
[10:20:20.234]   - Field: ‘local’
[10:20:20.234]   - Field: ‘owner’
[10:20:20.234]   - Field: ‘envir’
[10:20:20.234]   - Field: ‘workers’
[10:20:20.234]   - Field: ‘packages’
[10:20:20.234]   - Field: ‘gc’
[10:20:20.234]   - Field: ‘conditions’
[10:20:20.235]   - Field: ‘persistent’
[10:20:20.235]   - Field: ‘expr’
[10:20:20.235]   - Field: ‘uuid’
[10:20:20.235]   - Field: ‘seed’
[10:20:20.235]   - Field: ‘version’
[10:20:20.235]   - Field: ‘result’
[10:20:20.235]   - Field: ‘asynchronous’
[10:20:20.235]   - Field: ‘calls’
[10:20:20.235]   - Field: ‘globals’
[10:20:20.235]   - Field: ‘stdout’
[10:20:20.235]   - Field: ‘earlySignal’
[10:20:20.235]   - Field: ‘lazy’
[10:20:20.236]   - Field: ‘state’
[10:20:20.236] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:20:20.236] - Launch lazy future ...
[10:20:20.236] Packages needed by the future expression (n = 0): <none>
[10:20:20.236] Packages needed by future strategies (n = 0): <none>
[10:20:20.236] {
[10:20:20.236]     {
[10:20:20.236]         {
[10:20:20.236]             ...future.startTime <- base::Sys.time()
[10:20:20.236]             {
[10:20:20.236]                 {
[10:20:20.236]                   {
[10:20:20.236]                     {
[10:20:20.236]                       base::local({
[10:20:20.236]                         has_future <- base::requireNamespace("future", 
[10:20:20.236]                           quietly = TRUE)
[10:20:20.236]                         if (has_future) {
[10:20:20.236]                           ns <- base::getNamespace("future")
[10:20:20.236]                           version <- ns[[".package"]][["version"]]
[10:20:20.236]                           if (is.null(version)) 
[10:20:20.236]                             version <- utils::packageVersion("future")
[10:20:20.236]                         }
[10:20:20.236]                         else {
[10:20:20.236]                           version <- NULL
[10:20:20.236]                         }
[10:20:20.236]                         if (!has_future || version < "1.8.0") {
[10:20:20.236]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:20.236]                             "", base::R.version$version.string), 
[10:20:20.236]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:20.236]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:20.236]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:20.236]                               "release", "version")], collapse = " "), 
[10:20:20.236]                             hostname = base::Sys.info()[["nodename"]])
[10:20:20.236]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:20.236]                             info)
[10:20:20.236]                           info <- base::paste(info, collapse = "; ")
[10:20:20.236]                           if (!has_future) {
[10:20:20.236]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:20.236]                               info)
[10:20:20.236]                           }
[10:20:20.236]                           else {
[10:20:20.236]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:20.236]                               info, version)
[10:20:20.236]                           }
[10:20:20.236]                           base::stop(msg)
[10:20:20.236]                         }
[10:20:20.236]                       })
[10:20:20.236]                     }
[10:20:20.236]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:20.236]                     base::options(mc.cores = 1L)
[10:20:20.236]                   }
[10:20:20.236]                   ...future.strategy.old <- future::plan("list")
[10:20:20.236]                   options(future.plan = NULL)
[10:20:20.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:20.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:20.236]                 }
[10:20:20.236]                 ...future.workdir <- getwd()
[10:20:20.236]             }
[10:20:20.236]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:20.236]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:20.236]         }
[10:20:20.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:20.236]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:20.236]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:20.236]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:20.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:20.236]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:20.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:20.236]             base::names(...future.oldOptions))
[10:20:20.236]     }
[10:20:20.236]     if (FALSE) {
[10:20:20.236]     }
[10:20:20.236]     else {
[10:20:20.236]         if (FALSE) {
[10:20:20.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:20.236]                 open = "w")
[10:20:20.236]         }
[10:20:20.236]         else {
[10:20:20.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:20.236]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:20.236]         }
[10:20:20.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:20.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:20.236]             base::sink(type = "output", split = FALSE)
[10:20:20.236]             base::close(...future.stdout)
[10:20:20.236]         }, add = TRUE)
[10:20:20.236]     }
[10:20:20.236]     ...future.frame <- base::sys.nframe()
[10:20:20.236]     ...future.conditions <- base::list()
[10:20:20.236]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:20.236]     if (FALSE) {
[10:20:20.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:20.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:20.236]     }
[10:20:20.236]     ...future.result <- base::tryCatch({
[10:20:20.236]         base::withCallingHandlers({
[10:20:20.236]             ...future.value <- base::withVisible(base::local({
[10:20:20.236]                 ...future.makeSendCondition <- base::local({
[10:20:20.236]                   sendCondition <- NULL
[10:20:20.236]                   function(frame = 1L) {
[10:20:20.236]                     if (is.function(sendCondition)) 
[10:20:20.236]                       return(sendCondition)
[10:20:20.236]                     ns <- getNamespace("parallel")
[10:20:20.236]                     if (exists("sendData", mode = "function", 
[10:20:20.236]                       envir = ns)) {
[10:20:20.236]                       parallel_sendData <- get("sendData", mode = "function", 
[10:20:20.236]                         envir = ns)
[10:20:20.236]                       envir <- sys.frame(frame)
[10:20:20.236]                       master <- NULL
[10:20:20.236]                       while (!identical(envir, .GlobalEnv) && 
[10:20:20.236]                         !identical(envir, emptyenv())) {
[10:20:20.236]                         if (exists("master", mode = "list", envir = envir, 
[10:20:20.236]                           inherits = FALSE)) {
[10:20:20.236]                           master <- get("master", mode = "list", 
[10:20:20.236]                             envir = envir, inherits = FALSE)
[10:20:20.236]                           if (inherits(master, c("SOCKnode", 
[10:20:20.236]                             "SOCK0node"))) {
[10:20:20.236]                             sendCondition <<- function(cond) {
[10:20:20.236]                               data <- list(type = "VALUE", value = cond, 
[10:20:20.236]                                 success = TRUE)
[10:20:20.236]                               parallel_sendData(master, data)
[10:20:20.236]                             }
[10:20:20.236]                             return(sendCondition)
[10:20:20.236]                           }
[10:20:20.236]                         }
[10:20:20.236]                         frame <- frame + 1L
[10:20:20.236]                         envir <- sys.frame(frame)
[10:20:20.236]                       }
[10:20:20.236]                     }
[10:20:20.236]                     sendCondition <<- function(cond) NULL
[10:20:20.236]                   }
[10:20:20.236]                 })
[10:20:20.236]                 withCallingHandlers({
[10:20:20.236]                   {
[10:20:20.236]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:20.236]                     if (!identical(...future.globals.maxSize.org, 
[10:20:20.236]                       ...future.globals.maxSize)) {
[10:20:20.236]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:20.236]                       on.exit(options(oopts), add = TRUE)
[10:20:20.236]                     }
[10:20:20.236]                     {
[10:20:20.236]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:20.236]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:20:20.236]                         USE.NAMES = FALSE)
[10:20:20.236]                       do.call(mapply, args = args)
[10:20:20.236]                     }
[10:20:20.236]                   }
[10:20:20.236]                 }, immediateCondition = function(cond) {
[10:20:20.236]                   sendCondition <- ...future.makeSendCondition()
[10:20:20.236]                   sendCondition(cond)
[10:20:20.236]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:20.236]                   {
[10:20:20.236]                     inherits <- base::inherits
[10:20:20.236]                     invokeRestart <- base::invokeRestart
[10:20:20.236]                     is.null <- base::is.null
[10:20:20.236]                     muffled <- FALSE
[10:20:20.236]                     if (inherits(cond, "message")) {
[10:20:20.236]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:20.236]                       if (muffled) 
[10:20:20.236]                         invokeRestart("muffleMessage")
[10:20:20.236]                     }
[10:20:20.236]                     else if (inherits(cond, "warning")) {
[10:20:20.236]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:20.236]                       if (muffled) 
[10:20:20.236]                         invokeRestart("muffleWarning")
[10:20:20.236]                     }
[10:20:20.236]                     else if (inherits(cond, "condition")) {
[10:20:20.236]                       if (!is.null(pattern)) {
[10:20:20.236]                         computeRestarts <- base::computeRestarts
[10:20:20.236]                         grepl <- base::grepl
[10:20:20.236]                         restarts <- computeRestarts(cond)
[10:20:20.236]                         for (restart in restarts) {
[10:20:20.236]                           name <- restart$name
[10:20:20.236]                           if (is.null(name)) 
[10:20:20.236]                             next
[10:20:20.236]                           if (!grepl(pattern, name)) 
[10:20:20.236]                             next
[10:20:20.236]                           invokeRestart(restart)
[10:20:20.236]                           muffled <- TRUE
[10:20:20.236]                           break
[10:20:20.236]                         }
[10:20:20.236]                       }
[10:20:20.236]                     }
[10:20:20.236]                     invisible(muffled)
[10:20:20.236]                   }
[10:20:20.236]                   muffleCondition(cond)
[10:20:20.236]                 })
[10:20:20.236]             }))
[10:20:20.236]             future::FutureResult(value = ...future.value$value, 
[10:20:20.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:20.236]                   ...future.rng), globalenv = if (FALSE) 
[10:20:20.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:20.236]                     ...future.globalenv.names))
[10:20:20.236]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:20.236]         }, condition = base::local({
[10:20:20.236]             c <- base::c
[10:20:20.236]             inherits <- base::inherits
[10:20:20.236]             invokeRestart <- base::invokeRestart
[10:20:20.236]             length <- base::length
[10:20:20.236]             list <- base::list
[10:20:20.236]             seq.int <- base::seq.int
[10:20:20.236]             signalCondition <- base::signalCondition
[10:20:20.236]             sys.calls <- base::sys.calls
[10:20:20.236]             `[[` <- base::`[[`
[10:20:20.236]             `+` <- base::`+`
[10:20:20.236]             `<<-` <- base::`<<-`
[10:20:20.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:20.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:20.236]                   3L)]
[10:20:20.236]             }
[10:20:20.236]             function(cond) {
[10:20:20.236]                 is_error <- inherits(cond, "error")
[10:20:20.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:20.236]                   NULL)
[10:20:20.236]                 if (is_error) {
[10:20:20.236]                   sessionInformation <- function() {
[10:20:20.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:20.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:20.236]                       search = base::search(), system = base::Sys.info())
[10:20:20.236]                   }
[10:20:20.236]                   ...future.conditions[[length(...future.conditions) + 
[10:20:20.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:20.236]                     cond$call), session = sessionInformation(), 
[10:20:20.236]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:20.236]                   signalCondition(cond)
[10:20:20.236]                 }
[10:20:20.236]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:20.236]                 "immediateCondition"))) {
[10:20:20.236]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:20.236]                   ...future.conditions[[length(...future.conditions) + 
[10:20:20.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:20.236]                   if (TRUE && !signal) {
[10:20:20.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:20.236]                     {
[10:20:20.236]                       inherits <- base::inherits
[10:20:20.236]                       invokeRestart <- base::invokeRestart
[10:20:20.236]                       is.null <- base::is.null
[10:20:20.236]                       muffled <- FALSE
[10:20:20.236]                       if (inherits(cond, "message")) {
[10:20:20.236]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:20.236]                         if (muffled) 
[10:20:20.236]                           invokeRestart("muffleMessage")
[10:20:20.236]                       }
[10:20:20.236]                       else if (inherits(cond, "warning")) {
[10:20:20.236]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:20.236]                         if (muffled) 
[10:20:20.236]                           invokeRestart("muffleWarning")
[10:20:20.236]                       }
[10:20:20.236]                       else if (inherits(cond, "condition")) {
[10:20:20.236]                         if (!is.null(pattern)) {
[10:20:20.236]                           computeRestarts <- base::computeRestarts
[10:20:20.236]                           grepl <- base::grepl
[10:20:20.236]                           restarts <- computeRestarts(cond)
[10:20:20.236]                           for (restart in restarts) {
[10:20:20.236]                             name <- restart$name
[10:20:20.236]                             if (is.null(name)) 
[10:20:20.236]                               next
[10:20:20.236]                             if (!grepl(pattern, name)) 
[10:20:20.236]                               next
[10:20:20.236]                             invokeRestart(restart)
[10:20:20.236]                             muffled <- TRUE
[10:20:20.236]                             break
[10:20:20.236]                           }
[10:20:20.236]                         }
[10:20:20.236]                       }
[10:20:20.236]                       invisible(muffled)
[10:20:20.236]                     }
[10:20:20.236]                     muffleCondition(cond, pattern = "^muffle")
[10:20:20.236]                   }
[10:20:20.236]                 }
[10:20:20.236]                 else {
[10:20:20.236]                   if (TRUE) {
[10:20:20.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:20.236]                     {
[10:20:20.236]                       inherits <- base::inherits
[10:20:20.236]                       invokeRestart <- base::invokeRestart
[10:20:20.236]                       is.null <- base::is.null
[10:20:20.236]                       muffled <- FALSE
[10:20:20.236]                       if (inherits(cond, "message")) {
[10:20:20.236]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:20.236]                         if (muffled) 
[10:20:20.236]                           invokeRestart("muffleMessage")
[10:20:20.236]                       }
[10:20:20.236]                       else if (inherits(cond, "warning")) {
[10:20:20.236]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:20.236]                         if (muffled) 
[10:20:20.236]                           invokeRestart("muffleWarning")
[10:20:20.236]                       }
[10:20:20.236]                       else if (inherits(cond, "condition")) {
[10:20:20.236]                         if (!is.null(pattern)) {
[10:20:20.236]                           computeRestarts <- base::computeRestarts
[10:20:20.236]                           grepl <- base::grepl
[10:20:20.236]                           restarts <- computeRestarts(cond)
[10:20:20.236]                           for (restart in restarts) {
[10:20:20.236]                             name <- restart$name
[10:20:20.236]                             if (is.null(name)) 
[10:20:20.236]                               next
[10:20:20.236]                             if (!grepl(pattern, name)) 
[10:20:20.236]                               next
[10:20:20.236]                             invokeRestart(restart)
[10:20:20.236]                             muffled <- TRUE
[10:20:20.236]                             break
[10:20:20.236]                           }
[10:20:20.236]                         }
[10:20:20.236]                       }
[10:20:20.236]                       invisible(muffled)
[10:20:20.236]                     }
[10:20:20.236]                     muffleCondition(cond, pattern = "^muffle")
[10:20:20.236]                   }
[10:20:20.236]                 }
[10:20:20.236]             }
[10:20:20.236]         }))
[10:20:20.236]     }, error = function(ex) {
[10:20:20.236]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:20.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:20.236]                 ...future.rng), started = ...future.startTime, 
[10:20:20.236]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:20.236]             version = "1.8"), class = "FutureResult")
[10:20:20.236]     }, finally = {
[10:20:20.236]         if (!identical(...future.workdir, getwd())) 
[10:20:20.236]             setwd(...future.workdir)
[10:20:20.236]         {
[10:20:20.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:20.236]                 ...future.oldOptions$nwarnings <- NULL
[10:20:20.236]             }
[10:20:20.236]             base::options(...future.oldOptions)
[10:20:20.236]             if (.Platform$OS.type == "windows") {
[10:20:20.236]                 old_names <- names(...future.oldEnvVars)
[10:20:20.236]                 envs <- base::Sys.getenv()
[10:20:20.236]                 names <- names(envs)
[10:20:20.236]                 common <- intersect(names, old_names)
[10:20:20.236]                 added <- setdiff(names, old_names)
[10:20:20.236]                 removed <- setdiff(old_names, names)
[10:20:20.236]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:20.236]                   envs[common]]
[10:20:20.236]                 NAMES <- toupper(changed)
[10:20:20.236]                 args <- list()
[10:20:20.236]                 for (kk in seq_along(NAMES)) {
[10:20:20.236]                   name <- changed[[kk]]
[10:20:20.236]                   NAME <- NAMES[[kk]]
[10:20:20.236]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:20.236]                     next
[10:20:20.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:20.236]                 }
[10:20:20.236]                 NAMES <- toupper(added)
[10:20:20.236]                 for (kk in seq_along(NAMES)) {
[10:20:20.236]                   name <- added[[kk]]
[10:20:20.236]                   NAME <- NAMES[[kk]]
[10:20:20.236]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:20.236]                     next
[10:20:20.236]                   args[[name]] <- ""
[10:20:20.236]                 }
[10:20:20.236]                 NAMES <- toupper(removed)
[10:20:20.236]                 for (kk in seq_along(NAMES)) {
[10:20:20.236]                   name <- removed[[kk]]
[10:20:20.236]                   NAME <- NAMES[[kk]]
[10:20:20.236]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:20.236]                     next
[10:20:20.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:20.236]                 }
[10:20:20.236]                 if (length(args) > 0) 
[10:20:20.236]                   base::do.call(base::Sys.setenv, args = args)
[10:20:20.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:20.236]             }
[10:20:20.236]             else {
[10:20:20.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:20.236]             }
[10:20:20.236]             {
[10:20:20.236]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:20.236]                   0L) {
[10:20:20.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:20.236]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:20.236]                   base::options(opts)
[10:20:20.236]                 }
[10:20:20.236]                 {
[10:20:20.236]                   {
[10:20:20.236]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:20.236]                     NULL
[10:20:20.236]                   }
[10:20:20.236]                   options(future.plan = NULL)
[10:20:20.236]                   if (is.na(NA_character_)) 
[10:20:20.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:20.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:20.236]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:20.236]                     .init = FALSE)
[10:20:20.236]                 }
[10:20:20.236]             }
[10:20:20.236]         }
[10:20:20.236]     })
[10:20:20.236]     if (TRUE) {
[10:20:20.236]         base::sink(type = "output", split = FALSE)
[10:20:20.236]         if (FALSE) {
[10:20:20.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:20.236]         }
[10:20:20.236]         else {
[10:20:20.236]             ...future.result["stdout"] <- base::list(NULL)
[10:20:20.236]         }
[10:20:20.236]         base::close(...future.stdout)
[10:20:20.236]         ...future.stdout <- NULL
[10:20:20.236]     }
[10:20:20.236]     ...future.result$conditions <- ...future.conditions
[10:20:20.236]     ...future.result$finished <- base::Sys.time()
[10:20:20.236]     ...future.result
[10:20:20.236] }
[10:20:20.239] Exporting 5 global objects (1.63 KiB) to cluster node #1 ...
[10:20:20.239] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[10:20:20.240] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[10:20:20.240] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:20:20.240] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:20:20.241] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ...
[10:20:20.241] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ... DONE
[10:20:20.241] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:20:20.241] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:20:20.242] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:20:20.242] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:20:20.242] Exporting 5 global objects (1.63 KiB) to cluster node #1 ... DONE
[10:20:20.242] MultisessionFuture started
[10:20:20.243] - Launch lazy future ... done
[10:20:20.243] run() for ‘MultisessionFuture’ ... done
[10:20:20.243] Created future:
[10:20:20.243] MultisessionFuture:
[10:20:20.243] Label: ‘future_mapply-1’
[10:20:20.243] Expression:
[10:20:20.243] {
[10:20:20.243]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:20.243]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:20.243]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:20.243]         on.exit(options(oopts), add = TRUE)
[10:20:20.243]     }
[10:20:20.243]     {
[10:20:20.243]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:20.243]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:20:20.243]         do.call(mapply, args = args)
[10:20:20.243]     }
[10:20:20.243] }
[10:20:20.243] Lazy evaluation: FALSE
[10:20:20.243] Asynchronous evaluation: TRUE
[10:20:20.243] Local evaluation: TRUE
[10:20:20.243] Environment: R_GlobalEnv
[10:20:20.243] Capture standard output: FALSE
[10:20:20.243] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:20.243] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:20.243] Packages: <none>
[10:20:20.243] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:20.243] Resolved: FALSE
[10:20:20.243] Value: <not collected>
[10:20:20.243] Conditions captured: <none>
[10:20:20.243] Early signaling: FALSE
[10:20:20.243] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:20.243] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:20.254] Chunk #1 of 2 ... DONE
[10:20:20.254] Chunk #2 of 2 ...
[10:20:20.254]  - Finding globals in '...' for chunk #2 ...
[10:20:20.255] getGlobalsAndPackages() ...
[10:20:20.255] Searching for globals...
[10:20:20.255] 
[10:20:20.255] Searching for globals ... DONE
[10:20:20.255] - globals: [0] <none>
[10:20:20.255] getGlobalsAndPackages() ... DONE
[10:20:20.255]    + additional globals found: [n=0] 
[10:20:20.255]    + additional namespaces needed: [n=0] 
[10:20:20.256]  - Finding globals in '...' for chunk #2 ... DONE
[10:20:20.256]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:20.256]  - seeds: <none>
[10:20:20.256]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:20.256] getGlobalsAndPackages() ...
[10:20:20.256] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:20.256] Resolving globals: FALSE
[10:20:20.256] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[10:20:20.257] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:20:20.257] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:20.257] 
[10:20:20.257] getGlobalsAndPackages() ... DONE
[10:20:20.257] run() for ‘Future’ ...
[10:20:20.258] - state: ‘created’
[10:20:20.258] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:20:20.271] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:20.272] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:20:20.272]   - Field: ‘node’
[10:20:20.272]   - Field: ‘label’
[10:20:20.272]   - Field: ‘local’
[10:20:20.272]   - Field: ‘owner’
[10:20:20.272]   - Field: ‘envir’
[10:20:20.272]   - Field: ‘workers’
[10:20:20.272]   - Field: ‘packages’
[10:20:20.272]   - Field: ‘gc’
[10:20:20.272]   - Field: ‘conditions’
[10:20:20.272]   - Field: ‘persistent’
[10:20:20.272]   - Field: ‘expr’
[10:20:20.273]   - Field: ‘uuid’
[10:20:20.273]   - Field: ‘seed’
[10:20:20.273]   - Field: ‘version’
[10:20:20.273]   - Field: ‘result’
[10:20:20.273]   - Field: ‘asynchronous’
[10:20:20.273]   - Field: ‘calls’
[10:20:20.273]   - Field: ‘globals’
[10:20:20.273]   - Field: ‘stdout’
[10:20:20.273]   - Field: ‘earlySignal’
[10:20:20.273]   - Field: ‘lazy’
[10:20:20.273]   - Field: ‘state’
[10:20:20.273] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:20:20.274] - Launch lazy future ...
[10:20:20.274] Packages needed by the future expression (n = 0): <none>
[10:20:20.274] Packages needed by future strategies (n = 0): <none>
[10:20:20.274] {
[10:20:20.274]     {
[10:20:20.274]         {
[10:20:20.274]             ...future.startTime <- base::Sys.time()
[10:20:20.274]             {
[10:20:20.274]                 {
[10:20:20.274]                   {
[10:20:20.274]                     {
[10:20:20.274]                       base::local({
[10:20:20.274]                         has_future <- base::requireNamespace("future", 
[10:20:20.274]                           quietly = TRUE)
[10:20:20.274]                         if (has_future) {
[10:20:20.274]                           ns <- base::getNamespace("future")
[10:20:20.274]                           version <- ns[[".package"]][["version"]]
[10:20:20.274]                           if (is.null(version)) 
[10:20:20.274]                             version <- utils::packageVersion("future")
[10:20:20.274]                         }
[10:20:20.274]                         else {
[10:20:20.274]                           version <- NULL
[10:20:20.274]                         }
[10:20:20.274]                         if (!has_future || version < "1.8.0") {
[10:20:20.274]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:20.274]                             "", base::R.version$version.string), 
[10:20:20.274]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:20.274]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:20.274]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:20.274]                               "release", "version")], collapse = " "), 
[10:20:20.274]                             hostname = base::Sys.info()[["nodename"]])
[10:20:20.274]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:20.274]                             info)
[10:20:20.274]                           info <- base::paste(info, collapse = "; ")
[10:20:20.274]                           if (!has_future) {
[10:20:20.274]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:20.274]                               info)
[10:20:20.274]                           }
[10:20:20.274]                           else {
[10:20:20.274]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:20.274]                               info, version)
[10:20:20.274]                           }
[10:20:20.274]                           base::stop(msg)
[10:20:20.274]                         }
[10:20:20.274]                       })
[10:20:20.274]                     }
[10:20:20.274]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:20.274]                     base::options(mc.cores = 1L)
[10:20:20.274]                   }
[10:20:20.274]                   ...future.strategy.old <- future::plan("list")
[10:20:20.274]                   options(future.plan = NULL)
[10:20:20.274]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:20.274]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:20.274]                 }
[10:20:20.274]                 ...future.workdir <- getwd()
[10:20:20.274]             }
[10:20:20.274]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:20.274]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:20.274]         }
[10:20:20.274]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:20.274]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:20.274]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:20.274]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:20.274]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:20.274]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:20.274]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:20.274]             base::names(...future.oldOptions))
[10:20:20.274]     }
[10:20:20.274]     if (FALSE) {
[10:20:20.274]     }
[10:20:20.274]     else {
[10:20:20.274]         if (FALSE) {
[10:20:20.274]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:20.274]                 open = "w")
[10:20:20.274]         }
[10:20:20.274]         else {
[10:20:20.274]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:20.274]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:20.274]         }
[10:20:20.274]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:20.274]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:20.274]             base::sink(type = "output", split = FALSE)
[10:20:20.274]             base::close(...future.stdout)
[10:20:20.274]         }, add = TRUE)
[10:20:20.274]     }
[10:20:20.274]     ...future.frame <- base::sys.nframe()
[10:20:20.274]     ...future.conditions <- base::list()
[10:20:20.274]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:20.274]     if (FALSE) {
[10:20:20.274]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:20.274]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:20.274]     }
[10:20:20.274]     ...future.result <- base::tryCatch({
[10:20:20.274]         base::withCallingHandlers({
[10:20:20.274]             ...future.value <- base::withVisible(base::local({
[10:20:20.274]                 ...future.makeSendCondition <- base::local({
[10:20:20.274]                   sendCondition <- NULL
[10:20:20.274]                   function(frame = 1L) {
[10:20:20.274]                     if (is.function(sendCondition)) 
[10:20:20.274]                       return(sendCondition)
[10:20:20.274]                     ns <- getNamespace("parallel")
[10:20:20.274]                     if (exists("sendData", mode = "function", 
[10:20:20.274]                       envir = ns)) {
[10:20:20.274]                       parallel_sendData <- get("sendData", mode = "function", 
[10:20:20.274]                         envir = ns)
[10:20:20.274]                       envir <- sys.frame(frame)
[10:20:20.274]                       master <- NULL
[10:20:20.274]                       while (!identical(envir, .GlobalEnv) && 
[10:20:20.274]                         !identical(envir, emptyenv())) {
[10:20:20.274]                         if (exists("master", mode = "list", envir = envir, 
[10:20:20.274]                           inherits = FALSE)) {
[10:20:20.274]                           master <- get("master", mode = "list", 
[10:20:20.274]                             envir = envir, inherits = FALSE)
[10:20:20.274]                           if (inherits(master, c("SOCKnode", 
[10:20:20.274]                             "SOCK0node"))) {
[10:20:20.274]                             sendCondition <<- function(cond) {
[10:20:20.274]                               data <- list(type = "VALUE", value = cond, 
[10:20:20.274]                                 success = TRUE)
[10:20:20.274]                               parallel_sendData(master, data)
[10:20:20.274]                             }
[10:20:20.274]                             return(sendCondition)
[10:20:20.274]                           }
[10:20:20.274]                         }
[10:20:20.274]                         frame <- frame + 1L
[10:20:20.274]                         envir <- sys.frame(frame)
[10:20:20.274]                       }
[10:20:20.274]                     }
[10:20:20.274]                     sendCondition <<- function(cond) NULL
[10:20:20.274]                   }
[10:20:20.274]                 })
[10:20:20.274]                 withCallingHandlers({
[10:20:20.274]                   {
[10:20:20.274]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:20.274]                     if (!identical(...future.globals.maxSize.org, 
[10:20:20.274]                       ...future.globals.maxSize)) {
[10:20:20.274]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:20.274]                       on.exit(options(oopts), add = TRUE)
[10:20:20.274]                     }
[10:20:20.274]                     {
[10:20:20.274]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:20.274]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:20:20.274]                         USE.NAMES = FALSE)
[10:20:20.274]                       do.call(mapply, args = args)
[10:20:20.274]                     }
[10:20:20.274]                   }
[10:20:20.274]                 }, immediateCondition = function(cond) {
[10:20:20.274]                   sendCondition <- ...future.makeSendCondition()
[10:20:20.274]                   sendCondition(cond)
[10:20:20.274]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:20.274]                   {
[10:20:20.274]                     inherits <- base::inherits
[10:20:20.274]                     invokeRestart <- base::invokeRestart
[10:20:20.274]                     is.null <- base::is.null
[10:20:20.274]                     muffled <- FALSE
[10:20:20.274]                     if (inherits(cond, "message")) {
[10:20:20.274]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:20.274]                       if (muffled) 
[10:20:20.274]                         invokeRestart("muffleMessage")
[10:20:20.274]                     }
[10:20:20.274]                     else if (inherits(cond, "warning")) {
[10:20:20.274]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:20.274]                       if (muffled) 
[10:20:20.274]                         invokeRestart("muffleWarning")
[10:20:20.274]                     }
[10:20:20.274]                     else if (inherits(cond, "condition")) {
[10:20:20.274]                       if (!is.null(pattern)) {
[10:20:20.274]                         computeRestarts <- base::computeRestarts
[10:20:20.274]                         grepl <- base::grepl
[10:20:20.274]                         restarts <- computeRestarts(cond)
[10:20:20.274]                         for (restart in restarts) {
[10:20:20.274]                           name <- restart$name
[10:20:20.274]                           if (is.null(name)) 
[10:20:20.274]                             next
[10:20:20.274]                           if (!grepl(pattern, name)) 
[10:20:20.274]                             next
[10:20:20.274]                           invokeRestart(restart)
[10:20:20.274]                           muffled <- TRUE
[10:20:20.274]                           break
[10:20:20.274]                         }
[10:20:20.274]                       }
[10:20:20.274]                     }
[10:20:20.274]                     invisible(muffled)
[10:20:20.274]                   }
[10:20:20.274]                   muffleCondition(cond)
[10:20:20.274]                 })
[10:20:20.274]             }))
[10:20:20.274]             future::FutureResult(value = ...future.value$value, 
[10:20:20.274]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:20.274]                   ...future.rng), globalenv = if (FALSE) 
[10:20:20.274]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:20.274]                     ...future.globalenv.names))
[10:20:20.274]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:20.274]         }, condition = base::local({
[10:20:20.274]             c <- base::c
[10:20:20.274]             inherits <- base::inherits
[10:20:20.274]             invokeRestart <- base::invokeRestart
[10:20:20.274]             length <- base::length
[10:20:20.274]             list <- base::list
[10:20:20.274]             seq.int <- base::seq.int
[10:20:20.274]             signalCondition <- base::signalCondition
[10:20:20.274]             sys.calls <- base::sys.calls
[10:20:20.274]             `[[` <- base::`[[`
[10:20:20.274]             `+` <- base::`+`
[10:20:20.274]             `<<-` <- base::`<<-`
[10:20:20.274]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:20.274]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:20.274]                   3L)]
[10:20:20.274]             }
[10:20:20.274]             function(cond) {
[10:20:20.274]                 is_error <- inherits(cond, "error")
[10:20:20.274]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:20.274]                   NULL)
[10:20:20.274]                 if (is_error) {
[10:20:20.274]                   sessionInformation <- function() {
[10:20:20.274]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:20.274]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:20.274]                       search = base::search(), system = base::Sys.info())
[10:20:20.274]                   }
[10:20:20.274]                   ...future.conditions[[length(...future.conditions) + 
[10:20:20.274]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:20.274]                     cond$call), session = sessionInformation(), 
[10:20:20.274]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:20.274]                   signalCondition(cond)
[10:20:20.274]                 }
[10:20:20.274]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:20.274]                 "immediateCondition"))) {
[10:20:20.274]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:20.274]                   ...future.conditions[[length(...future.conditions) + 
[10:20:20.274]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:20.274]                   if (TRUE && !signal) {
[10:20:20.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:20.274]                     {
[10:20:20.274]                       inherits <- base::inherits
[10:20:20.274]                       invokeRestart <- base::invokeRestart
[10:20:20.274]                       is.null <- base::is.null
[10:20:20.274]                       muffled <- FALSE
[10:20:20.274]                       if (inherits(cond, "message")) {
[10:20:20.274]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:20.274]                         if (muffled) 
[10:20:20.274]                           invokeRestart("muffleMessage")
[10:20:20.274]                       }
[10:20:20.274]                       else if (inherits(cond, "warning")) {
[10:20:20.274]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:20.274]                         if (muffled) 
[10:20:20.274]                           invokeRestart("muffleWarning")
[10:20:20.274]                       }
[10:20:20.274]                       else if (inherits(cond, "condition")) {
[10:20:20.274]                         if (!is.null(pattern)) {
[10:20:20.274]                           computeRestarts <- base::computeRestarts
[10:20:20.274]                           grepl <- base::grepl
[10:20:20.274]                           restarts <- computeRestarts(cond)
[10:20:20.274]                           for (restart in restarts) {
[10:20:20.274]                             name <- restart$name
[10:20:20.274]                             if (is.null(name)) 
[10:20:20.274]                               next
[10:20:20.274]                             if (!grepl(pattern, name)) 
[10:20:20.274]                               next
[10:20:20.274]                             invokeRestart(restart)
[10:20:20.274]                             muffled <- TRUE
[10:20:20.274]                             break
[10:20:20.274]                           }
[10:20:20.274]                         }
[10:20:20.274]                       }
[10:20:20.274]                       invisible(muffled)
[10:20:20.274]                     }
[10:20:20.274]                     muffleCondition(cond, pattern = "^muffle")
[10:20:20.274]                   }
[10:20:20.274]                 }
[10:20:20.274]                 else {
[10:20:20.274]                   if (TRUE) {
[10:20:20.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:20.274]                     {
[10:20:20.274]                       inherits <- base::inherits
[10:20:20.274]                       invokeRestart <- base::invokeRestart
[10:20:20.274]                       is.null <- base::is.null
[10:20:20.274]                       muffled <- FALSE
[10:20:20.274]                       if (inherits(cond, "message")) {
[10:20:20.274]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:20.274]                         if (muffled) 
[10:20:20.274]                           invokeRestart("muffleMessage")
[10:20:20.274]                       }
[10:20:20.274]                       else if (inherits(cond, "warning")) {
[10:20:20.274]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:20.274]                         if (muffled) 
[10:20:20.274]                           invokeRestart("muffleWarning")
[10:20:20.274]                       }
[10:20:20.274]                       else if (inherits(cond, "condition")) {
[10:20:20.274]                         if (!is.null(pattern)) {
[10:20:20.274]                           computeRestarts <- base::computeRestarts
[10:20:20.274]                           grepl <- base::grepl
[10:20:20.274]                           restarts <- computeRestarts(cond)
[10:20:20.274]                           for (restart in restarts) {
[10:20:20.274]                             name <- restart$name
[10:20:20.274]                             if (is.null(name)) 
[10:20:20.274]                               next
[10:20:20.274]                             if (!grepl(pattern, name)) 
[10:20:20.274]                               next
[10:20:20.274]                             invokeRestart(restart)
[10:20:20.274]                             muffled <- TRUE
[10:20:20.274]                             break
[10:20:20.274]                           }
[10:20:20.274]                         }
[10:20:20.274]                       }
[10:20:20.274]                       invisible(muffled)
[10:20:20.274]                     }
[10:20:20.274]                     muffleCondition(cond, pattern = "^muffle")
[10:20:20.274]                   }
[10:20:20.274]                 }
[10:20:20.274]             }
[10:20:20.274]         }))
[10:20:20.274]     }, error = function(ex) {
[10:20:20.274]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:20.274]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:20.274]                 ...future.rng), started = ...future.startTime, 
[10:20:20.274]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:20.274]             version = "1.8"), class = "FutureResult")
[10:20:20.274]     }, finally = {
[10:20:20.274]         if (!identical(...future.workdir, getwd())) 
[10:20:20.274]             setwd(...future.workdir)
[10:20:20.274]         {
[10:20:20.274]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:20.274]                 ...future.oldOptions$nwarnings <- NULL
[10:20:20.274]             }
[10:20:20.274]             base::options(...future.oldOptions)
[10:20:20.274]             if (.Platform$OS.type == "windows") {
[10:20:20.274]                 old_names <- names(...future.oldEnvVars)
[10:20:20.274]                 envs <- base::Sys.getenv()
[10:20:20.274]                 names <- names(envs)
[10:20:20.274]                 common <- intersect(names, old_names)
[10:20:20.274]                 added <- setdiff(names, old_names)
[10:20:20.274]                 removed <- setdiff(old_names, names)
[10:20:20.274]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:20.274]                   envs[common]]
[10:20:20.274]                 NAMES <- toupper(changed)
[10:20:20.274]                 args <- list()
[10:20:20.274]                 for (kk in seq_along(NAMES)) {
[10:20:20.274]                   name <- changed[[kk]]
[10:20:20.274]                   NAME <- NAMES[[kk]]
[10:20:20.274]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:20.274]                     next
[10:20:20.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:20.274]                 }
[10:20:20.274]                 NAMES <- toupper(added)
[10:20:20.274]                 for (kk in seq_along(NAMES)) {
[10:20:20.274]                   name <- added[[kk]]
[10:20:20.274]                   NAME <- NAMES[[kk]]
[10:20:20.274]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:20.274]                     next
[10:20:20.274]                   args[[name]] <- ""
[10:20:20.274]                 }
[10:20:20.274]                 NAMES <- toupper(removed)
[10:20:20.274]                 for (kk in seq_along(NAMES)) {
[10:20:20.274]                   name <- removed[[kk]]
[10:20:20.274]                   NAME <- NAMES[[kk]]
[10:20:20.274]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:20.274]                     next
[10:20:20.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:20.274]                 }
[10:20:20.274]                 if (length(args) > 0) 
[10:20:20.274]                   base::do.call(base::Sys.setenv, args = args)
[10:20:20.274]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:20.274]             }
[10:20:20.274]             else {
[10:20:20.274]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:20.274]             }
[10:20:20.274]             {
[10:20:20.274]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:20.274]                   0L) {
[10:20:20.274]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:20.274]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:20.274]                   base::options(opts)
[10:20:20.274]                 }
[10:20:20.274]                 {
[10:20:20.274]                   {
[10:20:20.274]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:20.274]                     NULL
[10:20:20.274]                   }
[10:20:20.274]                   options(future.plan = NULL)
[10:20:20.274]                   if (is.na(NA_character_)) 
[10:20:20.274]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:20.274]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:20.274]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:20.274]                     .init = FALSE)
[10:20:20.274]                 }
[10:20:20.274]             }
[10:20:20.274]         }
[10:20:20.274]     })
[10:20:20.274]     if (TRUE) {
[10:20:20.274]         base::sink(type = "output", split = FALSE)
[10:20:20.274]         if (FALSE) {
[10:20:20.274]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:20.274]         }
[10:20:20.274]         else {
[10:20:20.274]             ...future.result["stdout"] <- base::list(NULL)
[10:20:20.274]         }
[10:20:20.274]         base::close(...future.stdout)
[10:20:20.274]         ...future.stdout <- NULL
[10:20:20.274]     }
[10:20:20.274]     ...future.result$conditions <- ...future.conditions
[10:20:20.274]     ...future.result$finished <- base::Sys.time()
[10:20:20.274]     ...future.result
[10:20:20.274] }
[10:20:20.277] Exporting 5 global objects (1.63 KiB) to cluster node #2 ...
[10:20:20.277] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[10:20:20.278] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[10:20:20.278] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:20:20.278] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:20:20.278] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ...
[10:20:20.279] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ... DONE
[10:20:20.279] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:20:20.279] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:20:20.279] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:20:20.280] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:20:20.280] Exporting 5 global objects (1.63 KiB) to cluster node #2 ... DONE
[10:20:20.280] MultisessionFuture started
[10:20:20.280] - Launch lazy future ... done
[10:20:20.280] run() for ‘MultisessionFuture’ ... done
[10:20:20.280] Created future:
[10:20:20.280] MultisessionFuture:
[10:20:20.280] Label: ‘future_mapply-2’
[10:20:20.280] Expression:
[10:20:20.280] {
[10:20:20.280]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:20.280]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:20.280]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:20.280]         on.exit(options(oopts), add = TRUE)
[10:20:20.280]     }
[10:20:20.280]     {
[10:20:20.280]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:20.280]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:20:20.280]         do.call(mapply, args = args)
[10:20:20.280]     }
[10:20:20.280] }
[10:20:20.280] Lazy evaluation: FALSE
[10:20:20.280] Asynchronous evaluation: TRUE
[10:20:20.280] Local evaluation: TRUE
[10:20:20.280] Environment: R_GlobalEnv
[10:20:20.280] Capture standard output: FALSE
[10:20:20.280] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:20.280] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:20.280] Packages: <none>
[10:20:20.280] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:20.280] Resolved: FALSE
[10:20:20.280] Value: <not collected>
[10:20:20.280] Conditions captured: <none>
[10:20:20.280] Early signaling: FALSE
[10:20:20.280] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:20.280] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:20.292] Chunk #2 of 2 ... DONE
[10:20:20.292] Launching 2 futures (chunks) ... DONE
[10:20:20.292] Resolving 2 futures (chunks) ...
[10:20:20.292] resolve() on list ...
[10:20:20.292]  recursive: 0
[10:20:20.292]  length: 2
[10:20:20.292] 
[10:20:20.334] receiveMessageFromWorker() for ClusterFuture ...
[10:20:20.335] - Validating connection of MultisessionFuture
[10:20:20.335] - received message: FutureResult
[10:20:20.335] - Received FutureResult
[10:20:20.335] - Erased future from FutureRegistry
[10:20:20.335] result() for ClusterFuture ...
[10:20:20.335] - result already collected: FutureResult
[10:20:20.335] result() for ClusterFuture ... done
[10:20:20.335] receiveMessageFromWorker() for ClusterFuture ... done
[10:20:20.335] Future #2
[10:20:20.336] result() for ClusterFuture ...
[10:20:20.336] - result already collected: FutureResult
[10:20:20.336] result() for ClusterFuture ... done
[10:20:20.336] result() for ClusterFuture ...
[10:20:20.336] - result already collected: FutureResult
[10:20:20.336] result() for ClusterFuture ... done
[10:20:20.336] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:20:20.336] - nx: 2
[10:20:20.336] - relay: TRUE
[10:20:20.336] - stdout: TRUE
[10:20:20.336] - signal: TRUE
[10:20:20.336] - resignal: FALSE
[10:20:20.336] - force: TRUE
[10:20:20.337] - relayed: [n=2] FALSE, FALSE
[10:20:20.337] - queued futures: [n=2] FALSE, FALSE
[10:20:20.337]  - until=1
[10:20:20.337]  - relaying element #1
[10:20:20.337] - relayed: [n=2] FALSE, FALSE
[10:20:20.337] - queued futures: [n=2] FALSE, TRUE
[10:20:20.337] signalConditionsASAP(NULL, pos=2) ... done
[10:20:20.337]  length: 1 (resolved future 2)
[10:20:20.786] receiveMessageFromWorker() for ClusterFuture ...
[10:20:20.786] - Validating connection of MultisessionFuture
[10:20:20.786] - received message: FutureResult
[10:20:20.786] - Received FutureResult
[10:20:20.787] - Erased future from FutureRegistry
[10:20:20.787] result() for ClusterFuture ...
[10:20:20.787] - result already collected: FutureResult
[10:20:20.787] result() for ClusterFuture ... done
[10:20:20.787] receiveMessageFromWorker() for ClusterFuture ... done
[10:20:20.787] Future #1
[10:20:20.787] result() for ClusterFuture ...
[10:20:20.787] - result already collected: FutureResult
[10:20:20.787] result() for ClusterFuture ... done
[10:20:20.787] result() for ClusterFuture ...
[10:20:20.787] - result already collected: FutureResult
[10:20:20.787] result() for ClusterFuture ... done
[10:20:20.788] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:20:20.788] - nx: 2
[10:20:20.788] - relay: TRUE
[10:20:20.788] - stdout: TRUE
[10:20:20.788] - signal: TRUE
[10:20:20.788] - resignal: FALSE
[10:20:20.788] - force: TRUE
[10:20:20.788] - relayed: [n=2] FALSE, FALSE
[10:20:20.788] - queued futures: [n=2] FALSE, TRUE
[10:20:20.788]  - until=1
[10:20:20.788]  - relaying element #1
[10:20:20.788] result() for ClusterFuture ...
[10:20:20.789] - result already collected: FutureResult
[10:20:20.789] result() for ClusterFuture ... done
[10:20:20.789] result() for ClusterFuture ...
[10:20:20.789] - result already collected: FutureResult
[10:20:20.789] result() for ClusterFuture ... done
[10:20:20.789] result() for ClusterFuture ...
[10:20:20.789] - result already collected: FutureResult
[10:20:20.789] result() for ClusterFuture ... done
[10:20:20.789] result() for ClusterFuture ...
[10:20:20.789] - result already collected: FutureResult
[10:20:20.789] result() for ClusterFuture ... done
[10:20:20.789] - relayed: [n=2] TRUE, FALSE
[10:20:20.789] - queued futures: [n=2] TRUE, TRUE
[10:20:20.790] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:20:20.790]  length: 0 (resolved future 1)
[10:20:20.790] Relaying remaining futures
[10:20:20.790] signalConditionsASAP(NULL, pos=0) ...
[10:20:20.790] - nx: 2
[10:20:20.790] - relay: TRUE
[10:20:20.790] - stdout: TRUE
[10:20:20.790] - signal: TRUE
[10:20:20.790] - resignal: FALSE
[10:20:20.790] - force: TRUE
[10:20:20.790] - relayed: [n=2] TRUE, FALSE
[10:20:20.790] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:20:20.791]  - relaying element #2
[10:20:20.791] result() for ClusterFuture ...
[10:20:20.791] - result already collected: FutureResult
[10:20:20.791] result() for ClusterFuture ... done
[10:20:20.791] result() for ClusterFuture ...
[10:20:20.791] - result already collected: FutureResult
[10:20:20.791] result() for ClusterFuture ... done
[10:20:20.791] result() for ClusterFuture ...
[10:20:20.791] - result already collected: FutureResult
[10:20:20.791] result() for ClusterFuture ... done
[10:20:20.791] result() for ClusterFuture ...
[10:20:20.791] - result already collected: FutureResult
[10:20:20.792] result() for ClusterFuture ... done
[10:20:20.792] - relayed: [n=2] TRUE, TRUE
[10:20:20.792] - queued futures: [n=2] TRUE, TRUE
[10:20:20.792] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[10:20:20.792] resolve() on list ... DONE
[10:20:20.792] result() for ClusterFuture ...
[10:20:20.792] - result already collected: FutureResult
[10:20:20.792] result() for ClusterFuture ... done
[10:20:20.792] result() for ClusterFuture ...
[10:20:20.792] - result already collected: FutureResult
[10:20:20.792] result() for ClusterFuture ... done
[10:20:20.792] result() for ClusterFuture ...
[10:20:20.792] - result already collected: FutureResult
[10:20:20.793] result() for ClusterFuture ... done
[10:20:20.793] result() for ClusterFuture ...
[10:20:20.793] - result already collected: FutureResult
[10:20:20.793] result() for ClusterFuture ... done
[10:20:20.793]  - Number of value chunks collected: 2
[10:20:20.793] Resolving 2 futures (chunks) ... DONE
[10:20:20.793] Reducing values from 2 chunks ...
[10:20:20.793]  - Number of values collected after concatenation: 2
[10:20:20.793]  - Number of values expected: 2
[10:20:20.793] Reducing values from 2 chunks ... DONE
[10:20:20.793] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[10:20:20.794] future_mapply() ...
[10:20:20.795] Number of chunks: 2
[10:20:20.796] getGlobalsAndPackagesXApply() ...
[10:20:20.796]  - future.globals: TRUE
[10:20:20.796] getGlobalsAndPackages() ...
[10:20:20.796] Searching for globals...
[10:20:20.797] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:20:20.797] Searching for globals ... DONE
[10:20:20.797] Resolving globals: FALSE
[10:20:20.798] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[10:20:20.798] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[10:20:20.798] - globals: [1] ‘FUN’
[10:20:20.798] 
[10:20:20.798] getGlobalsAndPackages() ... DONE
[10:20:20.799]  - globals found/used: [n=1] ‘FUN’
[10:20:20.799]  - needed namespaces: [n=0] 
[10:20:20.799] Finding globals ... DONE
[10:20:20.799] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:20:20.799] List of 2
[10:20:20.799]  $ ...future.FUN:function (x, y)  
[10:20:20.799]  $ MoreArgs     : NULL
[10:20:20.799]  - attr(*, "where")=List of 2
[10:20:20.799]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:20.799]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:20:20.799]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:20.799]  - attr(*, "resolved")= logi FALSE
[10:20:20.799]  - attr(*, "total_size")= num NA
[10:20:20.801] Packages to be attached in all futures: [n=0] 
[10:20:20.802] getGlobalsAndPackagesXApply() ... DONE
[10:20:20.802] Number of futures (= number of chunks): 2
[10:20:20.802] Launching 2 futures (chunks) ...
[10:20:20.802] Chunk #1 of 2 ...
[10:20:20.802]  - Finding globals in '...' for chunk #1 ...
[10:20:20.802] getGlobalsAndPackages() ...
[10:20:20.802] Searching for globals...
[10:20:20.802] 
[10:20:20.803] Searching for globals ... DONE
[10:20:20.803] - globals: [0] <none>
[10:20:20.803] getGlobalsAndPackages() ... DONE
[10:20:20.803]    + additional globals found: [n=0] 
[10:20:20.803]    + additional namespaces needed: [n=0] 
[10:20:20.803]  - Finding globals in '...' for chunk #1 ... DONE
[10:20:20.803]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:20.803]  - seeds: <none>
[10:20:20.803]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:20.803] getGlobalsAndPackages() ...
[10:20:20.803] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:20.804] Resolving globals: FALSE
[10:20:20.804] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[10:20:20.804] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:20:20.804] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:20.805] 
[10:20:20.805] getGlobalsAndPackages() ... DONE
[10:20:20.805] run() for ‘Future’ ...
[10:20:20.805] - state: ‘created’
[10:20:20.805] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:20:20.820] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:20.820] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:20:20.820]   - Field: ‘node’
[10:20:20.820]   - Field: ‘label’
[10:20:20.820]   - Field: ‘local’
[10:20:20.820]   - Field: ‘owner’
[10:20:20.821]   - Field: ‘envir’
[10:20:20.821]   - Field: ‘workers’
[10:20:20.821]   - Field: ‘packages’
[10:20:20.821]   - Field: ‘gc’
[10:20:20.821]   - Field: ‘conditions’
[10:20:20.821]   - Field: ‘persistent’
[10:20:20.821]   - Field: ‘expr’
[10:20:20.821]   - Field: ‘uuid’
[10:20:20.821]   - Field: ‘seed’
[10:20:20.821]   - Field: ‘version’
[10:20:20.821]   - Field: ‘result’
[10:20:20.822]   - Field: ‘asynchronous’
[10:20:20.822]   - Field: ‘calls’
[10:20:20.822]   - Field: ‘globals’
[10:20:20.822]   - Field: ‘stdout’
[10:20:20.822]   - Field: ‘earlySignal’
[10:20:20.822]   - Field: ‘lazy’
[10:20:20.822]   - Field: ‘state’
[10:20:20.822] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:20:20.822] - Launch lazy future ...
[10:20:20.822] Packages needed by the future expression (n = 0): <none>
[10:20:20.823] Packages needed by future strategies (n = 0): <none>
[10:20:20.823] {
[10:20:20.823]     {
[10:20:20.823]         {
[10:20:20.823]             ...future.startTime <- base::Sys.time()
[10:20:20.823]             {
[10:20:20.823]                 {
[10:20:20.823]                   {
[10:20:20.823]                     {
[10:20:20.823]                       base::local({
[10:20:20.823]                         has_future <- base::requireNamespace("future", 
[10:20:20.823]                           quietly = TRUE)
[10:20:20.823]                         if (has_future) {
[10:20:20.823]                           ns <- base::getNamespace("future")
[10:20:20.823]                           version <- ns[[".package"]][["version"]]
[10:20:20.823]                           if (is.null(version)) 
[10:20:20.823]                             version <- utils::packageVersion("future")
[10:20:20.823]                         }
[10:20:20.823]                         else {
[10:20:20.823]                           version <- NULL
[10:20:20.823]                         }
[10:20:20.823]                         if (!has_future || version < "1.8.0") {
[10:20:20.823]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:20.823]                             "", base::R.version$version.string), 
[10:20:20.823]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:20.823]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:20.823]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:20.823]                               "release", "version")], collapse = " "), 
[10:20:20.823]                             hostname = base::Sys.info()[["nodename"]])
[10:20:20.823]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:20.823]                             info)
[10:20:20.823]                           info <- base::paste(info, collapse = "; ")
[10:20:20.823]                           if (!has_future) {
[10:20:20.823]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:20.823]                               info)
[10:20:20.823]                           }
[10:20:20.823]                           else {
[10:20:20.823]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:20.823]                               info, version)
[10:20:20.823]                           }
[10:20:20.823]                           base::stop(msg)
[10:20:20.823]                         }
[10:20:20.823]                       })
[10:20:20.823]                     }
[10:20:20.823]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:20.823]                     base::options(mc.cores = 1L)
[10:20:20.823]                   }
[10:20:20.823]                   ...future.strategy.old <- future::plan("list")
[10:20:20.823]                   options(future.plan = NULL)
[10:20:20.823]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:20.823]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:20.823]                 }
[10:20:20.823]                 ...future.workdir <- getwd()
[10:20:20.823]             }
[10:20:20.823]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:20.823]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:20.823]         }
[10:20:20.823]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:20.823]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:20.823]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:20.823]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:20.823]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:20.823]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:20.823]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:20.823]             base::names(...future.oldOptions))
[10:20:20.823]     }
[10:20:20.823]     if (FALSE) {
[10:20:20.823]     }
[10:20:20.823]     else {
[10:20:20.823]         if (TRUE) {
[10:20:20.823]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:20.823]                 open = "w")
[10:20:20.823]         }
[10:20:20.823]         else {
[10:20:20.823]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:20.823]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:20.823]         }
[10:20:20.823]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:20.823]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:20.823]             base::sink(type = "output", split = FALSE)
[10:20:20.823]             base::close(...future.stdout)
[10:20:20.823]         }, add = TRUE)
[10:20:20.823]     }
[10:20:20.823]     ...future.frame <- base::sys.nframe()
[10:20:20.823]     ...future.conditions <- base::list()
[10:20:20.823]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:20.823]     if (FALSE) {
[10:20:20.823]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:20.823]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:20.823]     }
[10:20:20.823]     ...future.result <- base::tryCatch({
[10:20:20.823]         base::withCallingHandlers({
[10:20:20.823]             ...future.value <- base::withVisible(base::local({
[10:20:20.823]                 ...future.makeSendCondition <- base::local({
[10:20:20.823]                   sendCondition <- NULL
[10:20:20.823]                   function(frame = 1L) {
[10:20:20.823]                     if (is.function(sendCondition)) 
[10:20:20.823]                       return(sendCondition)
[10:20:20.823]                     ns <- getNamespace("parallel")
[10:20:20.823]                     if (exists("sendData", mode = "function", 
[10:20:20.823]                       envir = ns)) {
[10:20:20.823]                       parallel_sendData <- get("sendData", mode = "function", 
[10:20:20.823]                         envir = ns)
[10:20:20.823]                       envir <- sys.frame(frame)
[10:20:20.823]                       master <- NULL
[10:20:20.823]                       while (!identical(envir, .GlobalEnv) && 
[10:20:20.823]                         !identical(envir, emptyenv())) {
[10:20:20.823]                         if (exists("master", mode = "list", envir = envir, 
[10:20:20.823]                           inherits = FALSE)) {
[10:20:20.823]                           master <- get("master", mode = "list", 
[10:20:20.823]                             envir = envir, inherits = FALSE)
[10:20:20.823]                           if (inherits(master, c("SOCKnode", 
[10:20:20.823]                             "SOCK0node"))) {
[10:20:20.823]                             sendCondition <<- function(cond) {
[10:20:20.823]                               data <- list(type = "VALUE", value = cond, 
[10:20:20.823]                                 success = TRUE)
[10:20:20.823]                               parallel_sendData(master, data)
[10:20:20.823]                             }
[10:20:20.823]                             return(sendCondition)
[10:20:20.823]                           }
[10:20:20.823]                         }
[10:20:20.823]                         frame <- frame + 1L
[10:20:20.823]                         envir <- sys.frame(frame)
[10:20:20.823]                       }
[10:20:20.823]                     }
[10:20:20.823]                     sendCondition <<- function(cond) NULL
[10:20:20.823]                   }
[10:20:20.823]                 })
[10:20:20.823]                 withCallingHandlers({
[10:20:20.823]                   {
[10:20:20.823]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:20.823]                     if (!identical(...future.globals.maxSize.org, 
[10:20:20.823]                       ...future.globals.maxSize)) {
[10:20:20.823]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:20.823]                       on.exit(options(oopts), add = TRUE)
[10:20:20.823]                     }
[10:20:20.823]                     {
[10:20:20.823]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:20.823]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:20:20.823]                         USE.NAMES = FALSE)
[10:20:20.823]                       do.call(mapply, args = args)
[10:20:20.823]                     }
[10:20:20.823]                   }
[10:20:20.823]                 }, immediateCondition = function(cond) {
[10:20:20.823]                   sendCondition <- ...future.makeSendCondition()
[10:20:20.823]                   sendCondition(cond)
[10:20:20.823]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:20.823]                   {
[10:20:20.823]                     inherits <- base::inherits
[10:20:20.823]                     invokeRestart <- base::invokeRestart
[10:20:20.823]                     is.null <- base::is.null
[10:20:20.823]                     muffled <- FALSE
[10:20:20.823]                     if (inherits(cond, "message")) {
[10:20:20.823]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:20.823]                       if (muffled) 
[10:20:20.823]                         invokeRestart("muffleMessage")
[10:20:20.823]                     }
[10:20:20.823]                     else if (inherits(cond, "warning")) {
[10:20:20.823]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:20.823]                       if (muffled) 
[10:20:20.823]                         invokeRestart("muffleWarning")
[10:20:20.823]                     }
[10:20:20.823]                     else if (inherits(cond, "condition")) {
[10:20:20.823]                       if (!is.null(pattern)) {
[10:20:20.823]                         computeRestarts <- base::computeRestarts
[10:20:20.823]                         grepl <- base::grepl
[10:20:20.823]                         restarts <- computeRestarts(cond)
[10:20:20.823]                         for (restart in restarts) {
[10:20:20.823]                           name <- restart$name
[10:20:20.823]                           if (is.null(name)) 
[10:20:20.823]                             next
[10:20:20.823]                           if (!grepl(pattern, name)) 
[10:20:20.823]                             next
[10:20:20.823]                           invokeRestart(restart)
[10:20:20.823]                           muffled <- TRUE
[10:20:20.823]                           break
[10:20:20.823]                         }
[10:20:20.823]                       }
[10:20:20.823]                     }
[10:20:20.823]                     invisible(muffled)
[10:20:20.823]                   }
[10:20:20.823]                   muffleCondition(cond)
[10:20:20.823]                 })
[10:20:20.823]             }))
[10:20:20.823]             future::FutureResult(value = ...future.value$value, 
[10:20:20.823]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:20.823]                   ...future.rng), globalenv = if (FALSE) 
[10:20:20.823]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:20.823]                     ...future.globalenv.names))
[10:20:20.823]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:20.823]         }, condition = base::local({
[10:20:20.823]             c <- base::c
[10:20:20.823]             inherits <- base::inherits
[10:20:20.823]             invokeRestart <- base::invokeRestart
[10:20:20.823]             length <- base::length
[10:20:20.823]             list <- base::list
[10:20:20.823]             seq.int <- base::seq.int
[10:20:20.823]             signalCondition <- base::signalCondition
[10:20:20.823]             sys.calls <- base::sys.calls
[10:20:20.823]             `[[` <- base::`[[`
[10:20:20.823]             `+` <- base::`+`
[10:20:20.823]             `<<-` <- base::`<<-`
[10:20:20.823]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:20.823]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:20.823]                   3L)]
[10:20:20.823]             }
[10:20:20.823]             function(cond) {
[10:20:20.823]                 is_error <- inherits(cond, "error")
[10:20:20.823]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:20.823]                   NULL)
[10:20:20.823]                 if (is_error) {
[10:20:20.823]                   sessionInformation <- function() {
[10:20:20.823]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:20.823]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:20.823]                       search = base::search(), system = base::Sys.info())
[10:20:20.823]                   }
[10:20:20.823]                   ...future.conditions[[length(...future.conditions) + 
[10:20:20.823]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:20.823]                     cond$call), session = sessionInformation(), 
[10:20:20.823]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:20.823]                   signalCondition(cond)
[10:20:20.823]                 }
[10:20:20.823]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:20.823]                 "immediateCondition"))) {
[10:20:20.823]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:20.823]                   ...future.conditions[[length(...future.conditions) + 
[10:20:20.823]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:20.823]                   if (TRUE && !signal) {
[10:20:20.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:20.823]                     {
[10:20:20.823]                       inherits <- base::inherits
[10:20:20.823]                       invokeRestart <- base::invokeRestart
[10:20:20.823]                       is.null <- base::is.null
[10:20:20.823]                       muffled <- FALSE
[10:20:20.823]                       if (inherits(cond, "message")) {
[10:20:20.823]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:20.823]                         if (muffled) 
[10:20:20.823]                           invokeRestart("muffleMessage")
[10:20:20.823]                       }
[10:20:20.823]                       else if (inherits(cond, "warning")) {
[10:20:20.823]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:20.823]                         if (muffled) 
[10:20:20.823]                           invokeRestart("muffleWarning")
[10:20:20.823]                       }
[10:20:20.823]                       else if (inherits(cond, "condition")) {
[10:20:20.823]                         if (!is.null(pattern)) {
[10:20:20.823]                           computeRestarts <- base::computeRestarts
[10:20:20.823]                           grepl <- base::grepl
[10:20:20.823]                           restarts <- computeRestarts(cond)
[10:20:20.823]                           for (restart in restarts) {
[10:20:20.823]                             name <- restart$name
[10:20:20.823]                             if (is.null(name)) 
[10:20:20.823]                               next
[10:20:20.823]                             if (!grepl(pattern, name)) 
[10:20:20.823]                               next
[10:20:20.823]                             invokeRestart(restart)
[10:20:20.823]                             muffled <- TRUE
[10:20:20.823]                             break
[10:20:20.823]                           }
[10:20:20.823]                         }
[10:20:20.823]                       }
[10:20:20.823]                       invisible(muffled)
[10:20:20.823]                     }
[10:20:20.823]                     muffleCondition(cond, pattern = "^muffle")
[10:20:20.823]                   }
[10:20:20.823]                 }
[10:20:20.823]                 else {
[10:20:20.823]                   if (TRUE) {
[10:20:20.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:20.823]                     {
[10:20:20.823]                       inherits <- base::inherits
[10:20:20.823]                       invokeRestart <- base::invokeRestart
[10:20:20.823]                       is.null <- base::is.null
[10:20:20.823]                       muffled <- FALSE
[10:20:20.823]                       if (inherits(cond, "message")) {
[10:20:20.823]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:20.823]                         if (muffled) 
[10:20:20.823]                           invokeRestart("muffleMessage")
[10:20:20.823]                       }
[10:20:20.823]                       else if (inherits(cond, "warning")) {
[10:20:20.823]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:20.823]                         if (muffled) 
[10:20:20.823]                           invokeRestart("muffleWarning")
[10:20:20.823]                       }
[10:20:20.823]                       else if (inherits(cond, "condition")) {
[10:20:20.823]                         if (!is.null(pattern)) {
[10:20:20.823]                           computeRestarts <- base::computeRestarts
[10:20:20.823]                           grepl <- base::grepl
[10:20:20.823]                           restarts <- computeRestarts(cond)
[10:20:20.823]                           for (restart in restarts) {
[10:20:20.823]                             name <- restart$name
[10:20:20.823]                             if (is.null(name)) 
[10:20:20.823]                               next
[10:20:20.823]                             if (!grepl(pattern, name)) 
[10:20:20.823]                               next
[10:20:20.823]                             invokeRestart(restart)
[10:20:20.823]                             muffled <- TRUE
[10:20:20.823]                             break
[10:20:20.823]                           }
[10:20:20.823]                         }
[10:20:20.823]                       }
[10:20:20.823]                       invisible(muffled)
[10:20:20.823]                     }
[10:20:20.823]                     muffleCondition(cond, pattern = "^muffle")
[10:20:20.823]                   }
[10:20:20.823]                 }
[10:20:20.823]             }
[10:20:20.823]         }))
[10:20:20.823]     }, error = function(ex) {
[10:20:20.823]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:20.823]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:20.823]                 ...future.rng), started = ...future.startTime, 
[10:20:20.823]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:20.823]             version = "1.8"), class = "FutureResult")
[10:20:20.823]     }, finally = {
[10:20:20.823]         if (!identical(...future.workdir, getwd())) 
[10:20:20.823]             setwd(...future.workdir)
[10:20:20.823]         {
[10:20:20.823]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:20.823]                 ...future.oldOptions$nwarnings <- NULL
[10:20:20.823]             }
[10:20:20.823]             base::options(...future.oldOptions)
[10:20:20.823]             if (.Platform$OS.type == "windows") {
[10:20:20.823]                 old_names <- names(...future.oldEnvVars)
[10:20:20.823]                 envs <- base::Sys.getenv()
[10:20:20.823]                 names <- names(envs)
[10:20:20.823]                 common <- intersect(names, old_names)
[10:20:20.823]                 added <- setdiff(names, old_names)
[10:20:20.823]                 removed <- setdiff(old_names, names)
[10:20:20.823]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:20.823]                   envs[common]]
[10:20:20.823]                 NAMES <- toupper(changed)
[10:20:20.823]                 args <- list()
[10:20:20.823]                 for (kk in seq_along(NAMES)) {
[10:20:20.823]                   name <- changed[[kk]]
[10:20:20.823]                   NAME <- NAMES[[kk]]
[10:20:20.823]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:20.823]                     next
[10:20:20.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:20.823]                 }
[10:20:20.823]                 NAMES <- toupper(added)
[10:20:20.823]                 for (kk in seq_along(NAMES)) {
[10:20:20.823]                   name <- added[[kk]]
[10:20:20.823]                   NAME <- NAMES[[kk]]
[10:20:20.823]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:20.823]                     next
[10:20:20.823]                   args[[name]] <- ""
[10:20:20.823]                 }
[10:20:20.823]                 NAMES <- toupper(removed)
[10:20:20.823]                 for (kk in seq_along(NAMES)) {
[10:20:20.823]                   name <- removed[[kk]]
[10:20:20.823]                   NAME <- NAMES[[kk]]
[10:20:20.823]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:20.823]                     next
[10:20:20.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:20.823]                 }
[10:20:20.823]                 if (length(args) > 0) 
[10:20:20.823]                   base::do.call(base::Sys.setenv, args = args)
[10:20:20.823]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:20.823]             }
[10:20:20.823]             else {
[10:20:20.823]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:20.823]             }
[10:20:20.823]             {
[10:20:20.823]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:20.823]                   0L) {
[10:20:20.823]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:20.823]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:20.823]                   base::options(opts)
[10:20:20.823]                 }
[10:20:20.823]                 {
[10:20:20.823]                   {
[10:20:20.823]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:20.823]                     NULL
[10:20:20.823]                   }
[10:20:20.823]                   options(future.plan = NULL)
[10:20:20.823]                   if (is.na(NA_character_)) 
[10:20:20.823]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:20.823]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:20.823]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:20.823]                     .init = FALSE)
[10:20:20.823]                 }
[10:20:20.823]             }
[10:20:20.823]         }
[10:20:20.823]     })
[10:20:20.823]     if (TRUE) {
[10:20:20.823]         base::sink(type = "output", split = FALSE)
[10:20:20.823]         if (TRUE) {
[10:20:20.823]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:20.823]         }
[10:20:20.823]         else {
[10:20:20.823]             ...future.result["stdout"] <- base::list(NULL)
[10:20:20.823]         }
[10:20:20.823]         base::close(...future.stdout)
[10:20:20.823]         ...future.stdout <- NULL
[10:20:20.823]     }
[10:20:20.823]     ...future.result$conditions <- ...future.conditions
[10:20:20.823]     ...future.result$finished <- base::Sys.time()
[10:20:20.823]     ...future.result
[10:20:20.823] }
[10:20:20.826] Exporting 5 global objects (1.63 KiB) to cluster node #1 ...
[10:20:20.826] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[10:20:20.826] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[10:20:20.826] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:20:20.827] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:20:20.827] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ...
[10:20:20.827] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ... DONE
[10:20:20.827] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:20:20.828] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:20:20.828] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:20:20.828] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:20:20.828] Exporting 5 global objects (1.63 KiB) to cluster node #1 ... DONE
[10:20:20.829] MultisessionFuture started
[10:20:20.829] - Launch lazy future ... done
[10:20:20.829] run() for ‘MultisessionFuture’ ... done
[10:20:20.829] Created future:
[10:20:20.829] MultisessionFuture:
[10:20:20.829] Label: ‘future_mapply-1’
[10:20:20.829] Expression:
[10:20:20.829] {
[10:20:20.829]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:20.829]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:20.829]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:20.829]         on.exit(options(oopts), add = TRUE)
[10:20:20.829]     }
[10:20:20.829]     {
[10:20:20.829]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:20.829]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:20:20.829]         do.call(mapply, args = args)
[10:20:20.829]     }
[10:20:20.829] }
[10:20:20.829] Lazy evaluation: FALSE
[10:20:20.829] Asynchronous evaluation: TRUE
[10:20:20.829] Local evaluation: TRUE
[10:20:20.829] Environment: R_GlobalEnv
[10:20:20.829] Capture standard output: TRUE
[10:20:20.829] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:20.829] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:20.829] Packages: <none>
[10:20:20.829] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:20.829] Resolved: FALSE
[10:20:20.829] Value: <not collected>
[10:20:20.829] Conditions captured: <none>
[10:20:20.829] Early signaling: FALSE
[10:20:20.829] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:20.829] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:20.841] Chunk #1 of 2 ... DONE
[10:20:20.841] Chunk #2 of 2 ...
[10:20:20.841]  - Finding globals in '...' for chunk #2 ...
[10:20:20.841] getGlobalsAndPackages() ...
[10:20:20.841] Searching for globals...
[10:20:20.841] 
[10:20:20.841] Searching for globals ... DONE
[10:20:20.842] - globals: [0] <none>
[10:20:20.842] getGlobalsAndPackages() ... DONE
[10:20:20.842]    + additional globals found: [n=0] 
[10:20:20.842]    + additional namespaces needed: [n=0] 
[10:20:20.842]  - Finding globals in '...' for chunk #2 ... DONE
[10:20:20.842]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:20.842]  - seeds: <none>
[10:20:20.842]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:20.842] getGlobalsAndPackages() ...
[10:20:20.842] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:20.842] Resolving globals: FALSE
[10:20:20.843] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[10:20:20.843] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:20:20.843] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:20.843] 
[10:20:20.844] getGlobalsAndPackages() ... DONE
[10:20:20.844] run() for ‘Future’ ...
[10:20:20.844] - state: ‘created’
[10:20:20.844] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:20:20.858] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:20.858] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:20:20.858]   - Field: ‘node’
[10:20:20.858]   - Field: ‘label’
[10:20:20.858]   - Field: ‘local’
[10:20:20.858]   - Field: ‘owner’
[10:20:20.858]   - Field: ‘envir’
[10:20:20.858]   - Field: ‘workers’
[10:20:20.859]   - Field: ‘packages’
[10:20:20.859]   - Field: ‘gc’
[10:20:20.859]   - Field: ‘conditions’
[10:20:20.859]   - Field: ‘persistent’
[10:20:20.859]   - Field: ‘expr’
[10:20:20.859]   - Field: ‘uuid’
[10:20:20.859]   - Field: ‘seed’
[10:20:20.859]   - Field: ‘version’
[10:20:20.859]   - Field: ‘result’
[10:20:20.859]   - Field: ‘asynchronous’
[10:20:20.859]   - Field: ‘calls’
[10:20:20.859]   - Field: ‘globals’
[10:20:20.860]   - Field: ‘stdout’
[10:20:20.860]   - Field: ‘earlySignal’
[10:20:20.860]   - Field: ‘lazy’
[10:20:20.860]   - Field: ‘state’
[10:20:20.860] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:20:20.860] - Launch lazy future ...
[10:20:20.860] Packages needed by the future expression (n = 0): <none>
[10:20:20.860] Packages needed by future strategies (n = 0): <none>
[10:20:20.861] {
[10:20:20.861]     {
[10:20:20.861]         {
[10:20:20.861]             ...future.startTime <- base::Sys.time()
[10:20:20.861]             {
[10:20:20.861]                 {
[10:20:20.861]                   {
[10:20:20.861]                     {
[10:20:20.861]                       base::local({
[10:20:20.861]                         has_future <- base::requireNamespace("future", 
[10:20:20.861]                           quietly = TRUE)
[10:20:20.861]                         if (has_future) {
[10:20:20.861]                           ns <- base::getNamespace("future")
[10:20:20.861]                           version <- ns[[".package"]][["version"]]
[10:20:20.861]                           if (is.null(version)) 
[10:20:20.861]                             version <- utils::packageVersion("future")
[10:20:20.861]                         }
[10:20:20.861]                         else {
[10:20:20.861]                           version <- NULL
[10:20:20.861]                         }
[10:20:20.861]                         if (!has_future || version < "1.8.0") {
[10:20:20.861]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:20.861]                             "", base::R.version$version.string), 
[10:20:20.861]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:20.861]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:20.861]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:20.861]                               "release", "version")], collapse = " "), 
[10:20:20.861]                             hostname = base::Sys.info()[["nodename"]])
[10:20:20.861]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:20.861]                             info)
[10:20:20.861]                           info <- base::paste(info, collapse = "; ")
[10:20:20.861]                           if (!has_future) {
[10:20:20.861]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:20.861]                               info)
[10:20:20.861]                           }
[10:20:20.861]                           else {
[10:20:20.861]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:20.861]                               info, version)
[10:20:20.861]                           }
[10:20:20.861]                           base::stop(msg)
[10:20:20.861]                         }
[10:20:20.861]                       })
[10:20:20.861]                     }
[10:20:20.861]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:20.861]                     base::options(mc.cores = 1L)
[10:20:20.861]                   }
[10:20:20.861]                   ...future.strategy.old <- future::plan("list")
[10:20:20.861]                   options(future.plan = NULL)
[10:20:20.861]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:20.861]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:20.861]                 }
[10:20:20.861]                 ...future.workdir <- getwd()
[10:20:20.861]             }
[10:20:20.861]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:20.861]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:20.861]         }
[10:20:20.861]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:20.861]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:20.861]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:20.861]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:20.861]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:20.861]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:20.861]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:20.861]             base::names(...future.oldOptions))
[10:20:20.861]     }
[10:20:20.861]     if (FALSE) {
[10:20:20.861]     }
[10:20:20.861]     else {
[10:20:20.861]         if (TRUE) {
[10:20:20.861]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:20.861]                 open = "w")
[10:20:20.861]         }
[10:20:20.861]         else {
[10:20:20.861]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:20.861]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:20.861]         }
[10:20:20.861]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:20.861]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:20.861]             base::sink(type = "output", split = FALSE)
[10:20:20.861]             base::close(...future.stdout)
[10:20:20.861]         }, add = TRUE)
[10:20:20.861]     }
[10:20:20.861]     ...future.frame <- base::sys.nframe()
[10:20:20.861]     ...future.conditions <- base::list()
[10:20:20.861]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:20.861]     if (FALSE) {
[10:20:20.861]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:20.861]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:20.861]     }
[10:20:20.861]     ...future.result <- base::tryCatch({
[10:20:20.861]         base::withCallingHandlers({
[10:20:20.861]             ...future.value <- base::withVisible(base::local({
[10:20:20.861]                 ...future.makeSendCondition <- base::local({
[10:20:20.861]                   sendCondition <- NULL
[10:20:20.861]                   function(frame = 1L) {
[10:20:20.861]                     if (is.function(sendCondition)) 
[10:20:20.861]                       return(sendCondition)
[10:20:20.861]                     ns <- getNamespace("parallel")
[10:20:20.861]                     if (exists("sendData", mode = "function", 
[10:20:20.861]                       envir = ns)) {
[10:20:20.861]                       parallel_sendData <- get("sendData", mode = "function", 
[10:20:20.861]                         envir = ns)
[10:20:20.861]                       envir <- sys.frame(frame)
[10:20:20.861]                       master <- NULL
[10:20:20.861]                       while (!identical(envir, .GlobalEnv) && 
[10:20:20.861]                         !identical(envir, emptyenv())) {
[10:20:20.861]                         if (exists("master", mode = "list", envir = envir, 
[10:20:20.861]                           inherits = FALSE)) {
[10:20:20.861]                           master <- get("master", mode = "list", 
[10:20:20.861]                             envir = envir, inherits = FALSE)
[10:20:20.861]                           if (inherits(master, c("SOCKnode", 
[10:20:20.861]                             "SOCK0node"))) {
[10:20:20.861]                             sendCondition <<- function(cond) {
[10:20:20.861]                               data <- list(type = "VALUE", value = cond, 
[10:20:20.861]                                 success = TRUE)
[10:20:20.861]                               parallel_sendData(master, data)
[10:20:20.861]                             }
[10:20:20.861]                             return(sendCondition)
[10:20:20.861]                           }
[10:20:20.861]                         }
[10:20:20.861]                         frame <- frame + 1L
[10:20:20.861]                         envir <- sys.frame(frame)
[10:20:20.861]                       }
[10:20:20.861]                     }
[10:20:20.861]                     sendCondition <<- function(cond) NULL
[10:20:20.861]                   }
[10:20:20.861]                 })
[10:20:20.861]                 withCallingHandlers({
[10:20:20.861]                   {
[10:20:20.861]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:20.861]                     if (!identical(...future.globals.maxSize.org, 
[10:20:20.861]                       ...future.globals.maxSize)) {
[10:20:20.861]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:20.861]                       on.exit(options(oopts), add = TRUE)
[10:20:20.861]                     }
[10:20:20.861]                     {
[10:20:20.861]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:20.861]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:20:20.861]                         USE.NAMES = FALSE)
[10:20:20.861]                       do.call(mapply, args = args)
[10:20:20.861]                     }
[10:20:20.861]                   }
[10:20:20.861]                 }, immediateCondition = function(cond) {
[10:20:20.861]                   sendCondition <- ...future.makeSendCondition()
[10:20:20.861]                   sendCondition(cond)
[10:20:20.861]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:20.861]                   {
[10:20:20.861]                     inherits <- base::inherits
[10:20:20.861]                     invokeRestart <- base::invokeRestart
[10:20:20.861]                     is.null <- base::is.null
[10:20:20.861]                     muffled <- FALSE
[10:20:20.861]                     if (inherits(cond, "message")) {
[10:20:20.861]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:20.861]                       if (muffled) 
[10:20:20.861]                         invokeRestart("muffleMessage")
[10:20:20.861]                     }
[10:20:20.861]                     else if (inherits(cond, "warning")) {
[10:20:20.861]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:20.861]                       if (muffled) 
[10:20:20.861]                         invokeRestart("muffleWarning")
[10:20:20.861]                     }
[10:20:20.861]                     else if (inherits(cond, "condition")) {
[10:20:20.861]                       if (!is.null(pattern)) {
[10:20:20.861]                         computeRestarts <- base::computeRestarts
[10:20:20.861]                         grepl <- base::grepl
[10:20:20.861]                         restarts <- computeRestarts(cond)
[10:20:20.861]                         for (restart in restarts) {
[10:20:20.861]                           name <- restart$name
[10:20:20.861]                           if (is.null(name)) 
[10:20:20.861]                             next
[10:20:20.861]                           if (!grepl(pattern, name)) 
[10:20:20.861]                             next
[10:20:20.861]                           invokeRestart(restart)
[10:20:20.861]                           muffled <- TRUE
[10:20:20.861]                           break
[10:20:20.861]                         }
[10:20:20.861]                       }
[10:20:20.861]                     }
[10:20:20.861]                     invisible(muffled)
[10:20:20.861]                   }
[10:20:20.861]                   muffleCondition(cond)
[10:20:20.861]                 })
[10:20:20.861]             }))
[10:20:20.861]             future::FutureResult(value = ...future.value$value, 
[10:20:20.861]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:20.861]                   ...future.rng), globalenv = if (FALSE) 
[10:20:20.861]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:20.861]                     ...future.globalenv.names))
[10:20:20.861]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:20.861]         }, condition = base::local({
[10:20:20.861]             c <- base::c
[10:20:20.861]             inherits <- base::inherits
[10:20:20.861]             invokeRestart <- base::invokeRestart
[10:20:20.861]             length <- base::length
[10:20:20.861]             list <- base::list
[10:20:20.861]             seq.int <- base::seq.int
[10:20:20.861]             signalCondition <- base::signalCondition
[10:20:20.861]             sys.calls <- base::sys.calls
[10:20:20.861]             `[[` <- base::`[[`
[10:20:20.861]             `+` <- base::`+`
[10:20:20.861]             `<<-` <- base::`<<-`
[10:20:20.861]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:20.861]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:20.861]                   3L)]
[10:20:20.861]             }
[10:20:20.861]             function(cond) {
[10:20:20.861]                 is_error <- inherits(cond, "error")
[10:20:20.861]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:20.861]                   NULL)
[10:20:20.861]                 if (is_error) {
[10:20:20.861]                   sessionInformation <- function() {
[10:20:20.861]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:20.861]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:20.861]                       search = base::search(), system = base::Sys.info())
[10:20:20.861]                   }
[10:20:20.861]                   ...future.conditions[[length(...future.conditions) + 
[10:20:20.861]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:20.861]                     cond$call), session = sessionInformation(), 
[10:20:20.861]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:20.861]                   signalCondition(cond)
[10:20:20.861]                 }
[10:20:20.861]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:20.861]                 "immediateCondition"))) {
[10:20:20.861]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:20.861]                   ...future.conditions[[length(...future.conditions) + 
[10:20:20.861]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:20.861]                   if (TRUE && !signal) {
[10:20:20.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:20.861]                     {
[10:20:20.861]                       inherits <- base::inherits
[10:20:20.861]                       invokeRestart <- base::invokeRestart
[10:20:20.861]                       is.null <- base::is.null
[10:20:20.861]                       muffled <- FALSE
[10:20:20.861]                       if (inherits(cond, "message")) {
[10:20:20.861]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:20.861]                         if (muffled) 
[10:20:20.861]                           invokeRestart("muffleMessage")
[10:20:20.861]                       }
[10:20:20.861]                       else if (inherits(cond, "warning")) {
[10:20:20.861]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:20.861]                         if (muffled) 
[10:20:20.861]                           invokeRestart("muffleWarning")
[10:20:20.861]                       }
[10:20:20.861]                       else if (inherits(cond, "condition")) {
[10:20:20.861]                         if (!is.null(pattern)) {
[10:20:20.861]                           computeRestarts <- base::computeRestarts
[10:20:20.861]                           grepl <- base::grepl
[10:20:20.861]                           restarts <- computeRestarts(cond)
[10:20:20.861]                           for (restart in restarts) {
[10:20:20.861]                             name <- restart$name
[10:20:20.861]                             if (is.null(name)) 
[10:20:20.861]                               next
[10:20:20.861]                             if (!grepl(pattern, name)) 
[10:20:20.861]                               next
[10:20:20.861]                             invokeRestart(restart)
[10:20:20.861]                             muffled <- TRUE
[10:20:20.861]                             break
[10:20:20.861]                           }
[10:20:20.861]                         }
[10:20:20.861]                       }
[10:20:20.861]                       invisible(muffled)
[10:20:20.861]                     }
[10:20:20.861]                     muffleCondition(cond, pattern = "^muffle")
[10:20:20.861]                   }
[10:20:20.861]                 }
[10:20:20.861]                 else {
[10:20:20.861]                   if (TRUE) {
[10:20:20.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:20.861]                     {
[10:20:20.861]                       inherits <- base::inherits
[10:20:20.861]                       invokeRestart <- base::invokeRestart
[10:20:20.861]                       is.null <- base::is.null
[10:20:20.861]                       muffled <- FALSE
[10:20:20.861]                       if (inherits(cond, "message")) {
[10:20:20.861]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:20.861]                         if (muffled) 
[10:20:20.861]                           invokeRestart("muffleMessage")
[10:20:20.861]                       }
[10:20:20.861]                       else if (inherits(cond, "warning")) {
[10:20:20.861]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:20.861]                         if (muffled) 
[10:20:20.861]                           invokeRestart("muffleWarning")
[10:20:20.861]                       }
[10:20:20.861]                       else if (inherits(cond, "condition")) {
[10:20:20.861]                         if (!is.null(pattern)) {
[10:20:20.861]                           computeRestarts <- base::computeRestarts
[10:20:20.861]                           grepl <- base::grepl
[10:20:20.861]                           restarts <- computeRestarts(cond)
[10:20:20.861]                           for (restart in restarts) {
[10:20:20.861]                             name <- restart$name
[10:20:20.861]                             if (is.null(name)) 
[10:20:20.861]                               next
[10:20:20.861]                             if (!grepl(pattern, name)) 
[10:20:20.861]                               next
[10:20:20.861]                             invokeRestart(restart)
[10:20:20.861]                             muffled <- TRUE
[10:20:20.861]                             break
[10:20:20.861]                           }
[10:20:20.861]                         }
[10:20:20.861]                       }
[10:20:20.861]                       invisible(muffled)
[10:20:20.861]                     }
[10:20:20.861]                     muffleCondition(cond, pattern = "^muffle")
[10:20:20.861]                   }
[10:20:20.861]                 }
[10:20:20.861]             }
[10:20:20.861]         }))
[10:20:20.861]     }, error = function(ex) {
[10:20:20.861]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:20.861]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:20.861]                 ...future.rng), started = ...future.startTime, 
[10:20:20.861]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:20.861]             version = "1.8"), class = "FutureResult")
[10:20:20.861]     }, finally = {
[10:20:20.861]         if (!identical(...future.workdir, getwd())) 
[10:20:20.861]             setwd(...future.workdir)
[10:20:20.861]         {
[10:20:20.861]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:20.861]                 ...future.oldOptions$nwarnings <- NULL
[10:20:20.861]             }
[10:20:20.861]             base::options(...future.oldOptions)
[10:20:20.861]             if (.Platform$OS.type == "windows") {
[10:20:20.861]                 old_names <- names(...future.oldEnvVars)
[10:20:20.861]                 envs <- base::Sys.getenv()
[10:20:20.861]                 names <- names(envs)
[10:20:20.861]                 common <- intersect(names, old_names)
[10:20:20.861]                 added <- setdiff(names, old_names)
[10:20:20.861]                 removed <- setdiff(old_names, names)
[10:20:20.861]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:20.861]                   envs[common]]
[10:20:20.861]                 NAMES <- toupper(changed)
[10:20:20.861]                 args <- list()
[10:20:20.861]                 for (kk in seq_along(NAMES)) {
[10:20:20.861]                   name <- changed[[kk]]
[10:20:20.861]                   NAME <- NAMES[[kk]]
[10:20:20.861]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:20.861]                     next
[10:20:20.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:20.861]                 }
[10:20:20.861]                 NAMES <- toupper(added)
[10:20:20.861]                 for (kk in seq_along(NAMES)) {
[10:20:20.861]                   name <- added[[kk]]
[10:20:20.861]                   NAME <- NAMES[[kk]]
[10:20:20.861]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:20.861]                     next
[10:20:20.861]                   args[[name]] <- ""
[10:20:20.861]                 }
[10:20:20.861]                 NAMES <- toupper(removed)
[10:20:20.861]                 for (kk in seq_along(NAMES)) {
[10:20:20.861]                   name <- removed[[kk]]
[10:20:20.861]                   NAME <- NAMES[[kk]]
[10:20:20.861]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:20.861]                     next
[10:20:20.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:20.861]                 }
[10:20:20.861]                 if (length(args) > 0) 
[10:20:20.861]                   base::do.call(base::Sys.setenv, args = args)
[10:20:20.861]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:20.861]             }
[10:20:20.861]             else {
[10:20:20.861]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:20.861]             }
[10:20:20.861]             {
[10:20:20.861]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:20.861]                   0L) {
[10:20:20.861]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:20.861]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:20.861]                   base::options(opts)
[10:20:20.861]                 }
[10:20:20.861]                 {
[10:20:20.861]                   {
[10:20:20.861]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:20.861]                     NULL
[10:20:20.861]                   }
[10:20:20.861]                   options(future.plan = NULL)
[10:20:20.861]                   if (is.na(NA_character_)) 
[10:20:20.861]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:20.861]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:20.861]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:20.861]                     .init = FALSE)
[10:20:20.861]                 }
[10:20:20.861]             }
[10:20:20.861]         }
[10:20:20.861]     })
[10:20:20.861]     if (TRUE) {
[10:20:20.861]         base::sink(type = "output", split = FALSE)
[10:20:20.861]         if (TRUE) {
[10:20:20.861]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:20.861]         }
[10:20:20.861]         else {
[10:20:20.861]             ...future.result["stdout"] <- base::list(NULL)
[10:20:20.861]         }
[10:20:20.861]         base::close(...future.stdout)
[10:20:20.861]         ...future.stdout <- NULL
[10:20:20.861]     }
[10:20:20.861]     ...future.result$conditions <- ...future.conditions
[10:20:20.861]     ...future.result$finished <- base::Sys.time()
[10:20:20.861]     ...future.result
[10:20:20.861] }
[10:20:20.864] Exporting 5 global objects (1.63 KiB) to cluster node #2 ...
[10:20:20.864] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[10:20:20.864] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[10:20:20.864] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:20:20.865] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:20:20.865] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ...
[10:20:20.865] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ... DONE
[10:20:20.865] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:20:20.866] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:20:20.866] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:20:20.866] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:20:20.866] Exporting 5 global objects (1.63 KiB) to cluster node #2 ... DONE
[10:20:20.867] MultisessionFuture started
[10:20:20.867] - Launch lazy future ... done
[10:20:20.867] run() for ‘MultisessionFuture’ ... done
[10:20:20.867] Created future:
[10:20:20.867] MultisessionFuture:
[10:20:20.867] Label: ‘future_mapply-2’
[10:20:20.867] Expression:
[10:20:20.867] {
[10:20:20.867]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:20.867]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:20.867]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:20.867]         on.exit(options(oopts), add = TRUE)
[10:20:20.867]     }
[10:20:20.867]     {
[10:20:20.867]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:20.867]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:20:20.867]         do.call(mapply, args = args)
[10:20:20.867]     }
[10:20:20.867] }
[10:20:20.867] Lazy evaluation: FALSE
[10:20:20.867] Asynchronous evaluation: TRUE
[10:20:20.867] Local evaluation: TRUE
[10:20:20.867] Environment: R_GlobalEnv
[10:20:20.867] Capture standard output: TRUE
[10:20:20.867] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:20.867] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:20.867] Packages: <none>
[10:20:20.867] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:20.867] Resolved: FALSE
[10:20:20.867] Value: <not collected>
[10:20:20.867] Conditions captured: <none>
[10:20:20.867] Early signaling: FALSE
[10:20:20.867] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:20.867] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:20.878] Chunk #2 of 2 ... DONE
[10:20:20.878] Launching 2 futures (chunks) ... DONE
[10:20:20.879] Resolving 2 futures (chunks) ...
[10:20:20.879] resolve() on list ...
[10:20:20.879]  recursive: 0
[10:20:20.879]  length: 2
[10:20:20.879] 
[10:20:20.921] receiveMessageFromWorker() for ClusterFuture ...
[10:20:20.921] - Validating connection of MultisessionFuture
[10:20:20.921] - received message: FutureResult
[10:20:20.921] - Received FutureResult
[10:20:20.921] - Erased future from FutureRegistry
[10:20:20.922] result() for ClusterFuture ...
[10:20:20.922] - result already collected: FutureResult
[10:20:20.922] result() for ClusterFuture ... done
[10:20:20.922] receiveMessageFromWorker() for ClusterFuture ... done
[10:20:20.922] Future #2
[10:20:20.922] result() for ClusterFuture ...
[10:20:20.922] - result already collected: FutureResult
[10:20:20.922] result() for ClusterFuture ... done
[10:20:20.922] result() for ClusterFuture ...
[10:20:20.922] - result already collected: FutureResult
[10:20:20.922] result() for ClusterFuture ... done
[10:20:20.923] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:20:20.923] - nx: 2
[10:20:20.923] - relay: TRUE
[10:20:20.923] - stdout: TRUE
[10:20:20.923] - signal: TRUE
[10:20:20.923] - resignal: FALSE
[10:20:20.923] - force: TRUE
[10:20:20.923] - relayed: [n=2] FALSE, FALSE
[10:20:20.923] - queued futures: [n=2] FALSE, FALSE
[10:20:20.923]  - until=1
[10:20:20.923]  - relaying element #1
[10:20:20.923] - relayed: [n=2] FALSE, FALSE
[10:20:20.923] - queued futures: [n=2] FALSE, TRUE
[10:20:20.924] signalConditionsASAP(NULL, pos=2) ... done
[10:20:20.924]  length: 1 (resolved future 2)
[10:20:21.372] receiveMessageFromWorker() for ClusterFuture ...
[10:20:21.372] - Validating connection of MultisessionFuture
[10:20:21.372] - received message: FutureResult
[10:20:21.372] - Received FutureResult
[10:20:21.373] - Erased future from FutureRegistry
[10:20:21.373] result() for ClusterFuture ...
[10:20:21.373] - result already collected: FutureResult
[10:20:21.373] result() for ClusterFuture ... done
[10:20:21.373] receiveMessageFromWorker() for ClusterFuture ... done
[10:20:21.373] Future #1
[10:20:21.373] result() for ClusterFuture ...
[10:20:21.373] - result already collected: FutureResult
[10:20:21.373] result() for ClusterFuture ... done
[10:20:21.373] result() for ClusterFuture ...
[10:20:21.373] - result already collected: FutureResult
[10:20:21.373] result() for ClusterFuture ... done
[10:20:21.374] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:20:21.374] - nx: 2
[10:20:21.374] - relay: TRUE
[10:20:21.374] - stdout: TRUE
[10:20:21.374] - signal: TRUE
[10:20:21.374] - resignal: FALSE
[10:20:21.374] - force: TRUE
[10:20:21.374] - relayed: [n=2] FALSE, FALSE
[10:20:21.374] - queued futures: [n=2] FALSE, TRUE
[10:20:21.374]  - until=1
[10:20:21.374]  - relaying element #1
[10:20:21.374] result() for ClusterFuture ...
[10:20:21.375] - result already collected: FutureResult
[10:20:21.375] result() for ClusterFuture ... done
[10:20:21.375] result() for ClusterFuture ...
[10:20:21.375] - result already collected: FutureResult
[10:20:21.375] result() for ClusterFuture ... done
[10:20:21.375] result() for ClusterFuture ...
[10:20:21.375] - result already collected: FutureResult
[10:20:21.375] result() for ClusterFuture ... done
[10:20:21.375] result() for ClusterFuture ...
[10:20:21.375] - result already collected: FutureResult
[10:20:21.375] result() for ClusterFuture ... done
[10:20:21.375] - relayed: [n=2] TRUE, FALSE
[10:20:21.376] - queued futures: [n=2] TRUE, TRUE
[10:20:21.376] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:20:21.376]  length: 0 (resolved future 1)
[10:20:21.376] Relaying remaining futures
[10:20:21.376] signalConditionsASAP(NULL, pos=0) ...
[10:20:21.376] - nx: 2
[10:20:21.376] - relay: TRUE
[10:20:21.376] - stdout: TRUE
[10:20:21.376] - signal: TRUE
[10:20:21.376] - resignal: FALSE
[10:20:21.376] - force: TRUE
[10:20:21.376] - relayed: [n=2] TRUE, FALSE
[10:20:21.376] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:20:21.377]  - relaying element #2
[10:20:21.377] result() for ClusterFuture ...
[10:20:21.377] - result already collected: FutureResult
[10:20:21.377] result() for ClusterFuture ... done
[10:20:21.377] result() for ClusterFuture ...
[10:20:21.377] - result already collected: FutureResult
[10:20:21.377] result() for ClusterFuture ... done
[10:20:21.377] result() for ClusterFuture ...
[10:20:21.377] - result already collected: FutureResult
[10:20:21.377] result() for ClusterFuture ... done
[10:20:21.377] result() for ClusterFuture ...
[10:20:21.378] - result already collected: FutureResult
[10:20:21.378] result() for ClusterFuture ... done
[10:20:21.378] - relayed: [n=2] TRUE, TRUE
[10:20:21.378] - queued futures: [n=2] TRUE, TRUE
[10:20:21.378] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[10:20:21.378] resolve() on list ... DONE
[10:20:21.378] result() for ClusterFuture ...
[10:20:21.378] - result already collected: FutureResult
[10:20:21.378] result() for ClusterFuture ... done
[10:20:21.378] result() for ClusterFuture ...
[10:20:21.378] - result already collected: FutureResult
[10:20:21.378] result() for ClusterFuture ... done
[10:20:21.379] result() for ClusterFuture ...
[10:20:21.379] - result already collected: FutureResult
[10:20:21.379] result() for ClusterFuture ... done
[10:20:21.379] result() for ClusterFuture ...
[10:20:21.379] - result already collected: FutureResult
[10:20:21.379] result() for ClusterFuture ... done
[10:20:21.379]  - Number of value chunks collected: 2
[10:20:21.379] Resolving 2 futures (chunks) ... DONE
[10:20:21.379] Reducing values from 2 chunks ...
[10:20:21.379]  - Number of values collected after concatenation: 2
[10:20:21.379]  - Number of values expected: 2
[10:20:21.379] Reducing values from 2 chunks ... DONE
[10:20:21.380] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[10:20:21.380] future_mapply() ...
[10:20:21.382] Number of chunks: 2
[10:20:21.382] getGlobalsAndPackagesXApply() ...
[10:20:21.382]  - future.globals: TRUE
[10:20:21.382] getGlobalsAndPackages() ...
[10:20:21.382] Searching for globals...
[10:20:21.383] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:20:21.384] Searching for globals ... DONE
[10:20:21.384] Resolving globals: FALSE
[10:20:21.384] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[10:20:21.384] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[10:20:21.385] - globals: [1] ‘FUN’
[10:20:21.385] 
[10:20:21.385] getGlobalsAndPackages() ... DONE
[10:20:21.385]  - globals found/used: [n=1] ‘FUN’
[10:20:21.385]  - needed namespaces: [n=0] 
[10:20:21.385] Finding globals ... DONE
[10:20:21.385] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:20:21.385] List of 2
[10:20:21.385]  $ ...future.FUN:function (x, y)  
[10:20:21.385]  $ MoreArgs     : NULL
[10:20:21.385]  - attr(*, "where")=List of 2
[10:20:21.385]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:20:21.385]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:20:21.385]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:20:21.385]  - attr(*, "resolved")= logi FALSE
[10:20:21.385]  - attr(*, "total_size")= num NA
[10:20:21.388] Packages to be attached in all futures: [n=0] 
[10:20:21.388] getGlobalsAndPackagesXApply() ... DONE
[10:20:21.388] Number of futures (= number of chunks): 2
[10:20:21.388] Launching 2 futures (chunks) ...
[10:20:21.388] Chunk #1 of 2 ...
[10:20:21.388]  - Finding globals in '...' for chunk #1 ...
[10:20:21.388] getGlobalsAndPackages() ...
[10:20:21.388] Searching for globals...
[10:20:21.389] 
[10:20:21.389] Searching for globals ... DONE
[10:20:21.389] - globals: [0] <none>
[10:20:21.389] getGlobalsAndPackages() ... DONE
[10:20:21.389]    + additional globals found: [n=0] 
[10:20:21.389]    + additional namespaces needed: [n=0] 
[10:20:21.389]  - Finding globals in '...' for chunk #1 ... DONE
[10:20:21.389]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:21.389]  - seeds: <none>
[10:20:21.390]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:21.390] getGlobalsAndPackages() ...
[10:20:21.390] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:21.390] Resolving globals: FALSE
[10:20:21.390] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[10:20:21.391] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:20:21.393] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:21.393] 
[10:20:21.393] getGlobalsAndPackages() ... DONE
[10:20:21.393] run() for ‘Future’ ...
[10:20:21.394] - state: ‘created’
[10:20:21.394] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:20:21.408] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:21.408] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:20:21.408]   - Field: ‘node’
[10:20:21.409]   - Field: ‘label’
[10:20:21.409]   - Field: ‘local’
[10:20:21.409]   - Field: ‘owner’
[10:20:21.409]   - Field: ‘envir’
[10:20:21.409]   - Field: ‘workers’
[10:20:21.409]   - Field: ‘packages’
[10:20:21.409]   - Field: ‘gc’
[10:20:21.409]   - Field: ‘conditions’
[10:20:21.409]   - Field: ‘persistent’
[10:20:21.409]   - Field: ‘expr’
[10:20:21.409]   - Field: ‘uuid’
[10:20:21.410]   - Field: ‘seed’
[10:20:21.410]   - Field: ‘version’
[10:20:21.410]   - Field: ‘result’
[10:20:21.410]   - Field: ‘asynchronous’
[10:20:21.410]   - Field: ‘calls’
[10:20:21.410]   - Field: ‘globals’
[10:20:21.410]   - Field: ‘stdout’
[10:20:21.410]   - Field: ‘earlySignal’
[10:20:21.410]   - Field: ‘lazy’
[10:20:21.410]   - Field: ‘state’
[10:20:21.410] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:20:21.410] - Launch lazy future ...
[10:20:21.411] Packages needed by the future expression (n = 0): <none>
[10:20:21.411] Packages needed by future strategies (n = 0): <none>
[10:20:21.411] {
[10:20:21.411]     {
[10:20:21.411]         {
[10:20:21.411]             ...future.startTime <- base::Sys.time()
[10:20:21.411]             {
[10:20:21.411]                 {
[10:20:21.411]                   {
[10:20:21.411]                     {
[10:20:21.411]                       base::local({
[10:20:21.411]                         has_future <- base::requireNamespace("future", 
[10:20:21.411]                           quietly = TRUE)
[10:20:21.411]                         if (has_future) {
[10:20:21.411]                           ns <- base::getNamespace("future")
[10:20:21.411]                           version <- ns[[".package"]][["version"]]
[10:20:21.411]                           if (is.null(version)) 
[10:20:21.411]                             version <- utils::packageVersion("future")
[10:20:21.411]                         }
[10:20:21.411]                         else {
[10:20:21.411]                           version <- NULL
[10:20:21.411]                         }
[10:20:21.411]                         if (!has_future || version < "1.8.0") {
[10:20:21.411]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:21.411]                             "", base::R.version$version.string), 
[10:20:21.411]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:21.411]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:21.411]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:21.411]                               "release", "version")], collapse = " "), 
[10:20:21.411]                             hostname = base::Sys.info()[["nodename"]])
[10:20:21.411]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:21.411]                             info)
[10:20:21.411]                           info <- base::paste(info, collapse = "; ")
[10:20:21.411]                           if (!has_future) {
[10:20:21.411]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:21.411]                               info)
[10:20:21.411]                           }
[10:20:21.411]                           else {
[10:20:21.411]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:21.411]                               info, version)
[10:20:21.411]                           }
[10:20:21.411]                           base::stop(msg)
[10:20:21.411]                         }
[10:20:21.411]                       })
[10:20:21.411]                     }
[10:20:21.411]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:21.411]                     base::options(mc.cores = 1L)
[10:20:21.411]                   }
[10:20:21.411]                   ...future.strategy.old <- future::plan("list")
[10:20:21.411]                   options(future.plan = NULL)
[10:20:21.411]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:21.411]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:21.411]                 }
[10:20:21.411]                 ...future.workdir <- getwd()
[10:20:21.411]             }
[10:20:21.411]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:21.411]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:21.411]         }
[10:20:21.411]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:21.411]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:21.411]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:21.411]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:21.411]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:21.411]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:21.411]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:21.411]             base::names(...future.oldOptions))
[10:20:21.411]     }
[10:20:21.411]     if (TRUE) {
[10:20:21.411]     }
[10:20:21.411]     else {
[10:20:21.411]         if (NA) {
[10:20:21.411]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:21.411]                 open = "w")
[10:20:21.411]         }
[10:20:21.411]         else {
[10:20:21.411]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:21.411]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:21.411]         }
[10:20:21.411]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:21.411]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:21.411]             base::sink(type = "output", split = FALSE)
[10:20:21.411]             base::close(...future.stdout)
[10:20:21.411]         }, add = TRUE)
[10:20:21.411]     }
[10:20:21.411]     ...future.frame <- base::sys.nframe()
[10:20:21.411]     ...future.conditions <- base::list()
[10:20:21.411]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:21.411]     if (FALSE) {
[10:20:21.411]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:21.411]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:21.411]     }
[10:20:21.411]     ...future.result <- base::tryCatch({
[10:20:21.411]         base::withCallingHandlers({
[10:20:21.411]             ...future.value <- base::withVisible(base::local({
[10:20:21.411]                 ...future.makeSendCondition <- base::local({
[10:20:21.411]                   sendCondition <- NULL
[10:20:21.411]                   function(frame = 1L) {
[10:20:21.411]                     if (is.function(sendCondition)) 
[10:20:21.411]                       return(sendCondition)
[10:20:21.411]                     ns <- getNamespace("parallel")
[10:20:21.411]                     if (exists("sendData", mode = "function", 
[10:20:21.411]                       envir = ns)) {
[10:20:21.411]                       parallel_sendData <- get("sendData", mode = "function", 
[10:20:21.411]                         envir = ns)
[10:20:21.411]                       envir <- sys.frame(frame)
[10:20:21.411]                       master <- NULL
[10:20:21.411]                       while (!identical(envir, .GlobalEnv) && 
[10:20:21.411]                         !identical(envir, emptyenv())) {
[10:20:21.411]                         if (exists("master", mode = "list", envir = envir, 
[10:20:21.411]                           inherits = FALSE)) {
[10:20:21.411]                           master <- get("master", mode = "list", 
[10:20:21.411]                             envir = envir, inherits = FALSE)
[10:20:21.411]                           if (inherits(master, c("SOCKnode", 
[10:20:21.411]                             "SOCK0node"))) {
[10:20:21.411]                             sendCondition <<- function(cond) {
[10:20:21.411]                               data <- list(type = "VALUE", value = cond, 
[10:20:21.411]                                 success = TRUE)
[10:20:21.411]                               parallel_sendData(master, data)
[10:20:21.411]                             }
[10:20:21.411]                             return(sendCondition)
[10:20:21.411]                           }
[10:20:21.411]                         }
[10:20:21.411]                         frame <- frame + 1L
[10:20:21.411]                         envir <- sys.frame(frame)
[10:20:21.411]                       }
[10:20:21.411]                     }
[10:20:21.411]                     sendCondition <<- function(cond) NULL
[10:20:21.411]                   }
[10:20:21.411]                 })
[10:20:21.411]                 withCallingHandlers({
[10:20:21.411]                   {
[10:20:21.411]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:21.411]                     if (!identical(...future.globals.maxSize.org, 
[10:20:21.411]                       ...future.globals.maxSize)) {
[10:20:21.411]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:21.411]                       on.exit(options(oopts), add = TRUE)
[10:20:21.411]                     }
[10:20:21.411]                     {
[10:20:21.411]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:21.411]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:20:21.411]                         USE.NAMES = FALSE)
[10:20:21.411]                       do.call(mapply, args = args)
[10:20:21.411]                     }
[10:20:21.411]                   }
[10:20:21.411]                 }, immediateCondition = function(cond) {
[10:20:21.411]                   sendCondition <- ...future.makeSendCondition()
[10:20:21.411]                   sendCondition(cond)
[10:20:21.411]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:21.411]                   {
[10:20:21.411]                     inherits <- base::inherits
[10:20:21.411]                     invokeRestart <- base::invokeRestart
[10:20:21.411]                     is.null <- base::is.null
[10:20:21.411]                     muffled <- FALSE
[10:20:21.411]                     if (inherits(cond, "message")) {
[10:20:21.411]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:21.411]                       if (muffled) 
[10:20:21.411]                         invokeRestart("muffleMessage")
[10:20:21.411]                     }
[10:20:21.411]                     else if (inherits(cond, "warning")) {
[10:20:21.411]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:21.411]                       if (muffled) 
[10:20:21.411]                         invokeRestart("muffleWarning")
[10:20:21.411]                     }
[10:20:21.411]                     else if (inherits(cond, "condition")) {
[10:20:21.411]                       if (!is.null(pattern)) {
[10:20:21.411]                         computeRestarts <- base::computeRestarts
[10:20:21.411]                         grepl <- base::grepl
[10:20:21.411]                         restarts <- computeRestarts(cond)
[10:20:21.411]                         for (restart in restarts) {
[10:20:21.411]                           name <- restart$name
[10:20:21.411]                           if (is.null(name)) 
[10:20:21.411]                             next
[10:20:21.411]                           if (!grepl(pattern, name)) 
[10:20:21.411]                             next
[10:20:21.411]                           invokeRestart(restart)
[10:20:21.411]                           muffled <- TRUE
[10:20:21.411]                           break
[10:20:21.411]                         }
[10:20:21.411]                       }
[10:20:21.411]                     }
[10:20:21.411]                     invisible(muffled)
[10:20:21.411]                   }
[10:20:21.411]                   muffleCondition(cond)
[10:20:21.411]                 })
[10:20:21.411]             }))
[10:20:21.411]             future::FutureResult(value = ...future.value$value, 
[10:20:21.411]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:21.411]                   ...future.rng), globalenv = if (FALSE) 
[10:20:21.411]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:21.411]                     ...future.globalenv.names))
[10:20:21.411]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:21.411]         }, condition = base::local({
[10:20:21.411]             c <- base::c
[10:20:21.411]             inherits <- base::inherits
[10:20:21.411]             invokeRestart <- base::invokeRestart
[10:20:21.411]             length <- base::length
[10:20:21.411]             list <- base::list
[10:20:21.411]             seq.int <- base::seq.int
[10:20:21.411]             signalCondition <- base::signalCondition
[10:20:21.411]             sys.calls <- base::sys.calls
[10:20:21.411]             `[[` <- base::`[[`
[10:20:21.411]             `+` <- base::`+`
[10:20:21.411]             `<<-` <- base::`<<-`
[10:20:21.411]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:21.411]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:21.411]                   3L)]
[10:20:21.411]             }
[10:20:21.411]             function(cond) {
[10:20:21.411]                 is_error <- inherits(cond, "error")
[10:20:21.411]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:21.411]                   NULL)
[10:20:21.411]                 if (is_error) {
[10:20:21.411]                   sessionInformation <- function() {
[10:20:21.411]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:21.411]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:21.411]                       search = base::search(), system = base::Sys.info())
[10:20:21.411]                   }
[10:20:21.411]                   ...future.conditions[[length(...future.conditions) + 
[10:20:21.411]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:21.411]                     cond$call), session = sessionInformation(), 
[10:20:21.411]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:21.411]                   signalCondition(cond)
[10:20:21.411]                 }
[10:20:21.411]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:21.411]                 "immediateCondition"))) {
[10:20:21.411]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:21.411]                   ...future.conditions[[length(...future.conditions) + 
[10:20:21.411]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:21.411]                   if (TRUE && !signal) {
[10:20:21.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:21.411]                     {
[10:20:21.411]                       inherits <- base::inherits
[10:20:21.411]                       invokeRestart <- base::invokeRestart
[10:20:21.411]                       is.null <- base::is.null
[10:20:21.411]                       muffled <- FALSE
[10:20:21.411]                       if (inherits(cond, "message")) {
[10:20:21.411]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:21.411]                         if (muffled) 
[10:20:21.411]                           invokeRestart("muffleMessage")
[10:20:21.411]                       }
[10:20:21.411]                       else if (inherits(cond, "warning")) {
[10:20:21.411]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:21.411]                         if (muffled) 
[10:20:21.411]                           invokeRestart("muffleWarning")
[10:20:21.411]                       }
[10:20:21.411]                       else if (inherits(cond, "condition")) {
[10:20:21.411]                         if (!is.null(pattern)) {
[10:20:21.411]                           computeRestarts <- base::computeRestarts
[10:20:21.411]                           grepl <- base::grepl
[10:20:21.411]                           restarts <- computeRestarts(cond)
[10:20:21.411]                           for (restart in restarts) {
[10:20:21.411]                             name <- restart$name
[10:20:21.411]                             if (is.null(name)) 
[10:20:21.411]                               next
[10:20:21.411]                             if (!grepl(pattern, name)) 
[10:20:21.411]                               next
[10:20:21.411]                             invokeRestart(restart)
[10:20:21.411]                             muffled <- TRUE
[10:20:21.411]                             break
[10:20:21.411]                           }
[10:20:21.411]                         }
[10:20:21.411]                       }
[10:20:21.411]                       invisible(muffled)
[10:20:21.411]                     }
[10:20:21.411]                     muffleCondition(cond, pattern = "^muffle")
[10:20:21.411]                   }
[10:20:21.411]                 }
[10:20:21.411]                 else {
[10:20:21.411]                   if (TRUE) {
[10:20:21.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:21.411]                     {
[10:20:21.411]                       inherits <- base::inherits
[10:20:21.411]                       invokeRestart <- base::invokeRestart
[10:20:21.411]                       is.null <- base::is.null
[10:20:21.411]                       muffled <- FALSE
[10:20:21.411]                       if (inherits(cond, "message")) {
[10:20:21.411]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:21.411]                         if (muffled) 
[10:20:21.411]                           invokeRestart("muffleMessage")
[10:20:21.411]                       }
[10:20:21.411]                       else if (inherits(cond, "warning")) {
[10:20:21.411]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:21.411]                         if (muffled) 
[10:20:21.411]                           invokeRestart("muffleWarning")
[10:20:21.411]                       }
[10:20:21.411]                       else if (inherits(cond, "condition")) {
[10:20:21.411]                         if (!is.null(pattern)) {
[10:20:21.411]                           computeRestarts <- base::computeRestarts
[10:20:21.411]                           grepl <- base::grepl
[10:20:21.411]                           restarts <- computeRestarts(cond)
[10:20:21.411]                           for (restart in restarts) {
[10:20:21.411]                             name <- restart$name
[10:20:21.411]                             if (is.null(name)) 
[10:20:21.411]                               next
[10:20:21.411]                             if (!grepl(pattern, name)) 
[10:20:21.411]                               next
[10:20:21.411]                             invokeRestart(restart)
[10:20:21.411]                             muffled <- TRUE
[10:20:21.411]                             break
[10:20:21.411]                           }
[10:20:21.411]                         }
[10:20:21.411]                       }
[10:20:21.411]                       invisible(muffled)
[10:20:21.411]                     }
[10:20:21.411]                     muffleCondition(cond, pattern = "^muffle")
[10:20:21.411]                   }
[10:20:21.411]                 }
[10:20:21.411]             }
[10:20:21.411]         }))
[10:20:21.411]     }, error = function(ex) {
[10:20:21.411]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:21.411]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:21.411]                 ...future.rng), started = ...future.startTime, 
[10:20:21.411]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:21.411]             version = "1.8"), class = "FutureResult")
[10:20:21.411]     }, finally = {
[10:20:21.411]         if (!identical(...future.workdir, getwd())) 
[10:20:21.411]             setwd(...future.workdir)
[10:20:21.411]         {
[10:20:21.411]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:21.411]                 ...future.oldOptions$nwarnings <- NULL
[10:20:21.411]             }
[10:20:21.411]             base::options(...future.oldOptions)
[10:20:21.411]             if (.Platform$OS.type == "windows") {
[10:20:21.411]                 old_names <- names(...future.oldEnvVars)
[10:20:21.411]                 envs <- base::Sys.getenv()
[10:20:21.411]                 names <- names(envs)
[10:20:21.411]                 common <- intersect(names, old_names)
[10:20:21.411]                 added <- setdiff(names, old_names)
[10:20:21.411]                 removed <- setdiff(old_names, names)
[10:20:21.411]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:21.411]                   envs[common]]
[10:20:21.411]                 NAMES <- toupper(changed)
[10:20:21.411]                 args <- list()
[10:20:21.411]                 for (kk in seq_along(NAMES)) {
[10:20:21.411]                   name <- changed[[kk]]
[10:20:21.411]                   NAME <- NAMES[[kk]]
[10:20:21.411]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:21.411]                     next
[10:20:21.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:21.411]                 }
[10:20:21.411]                 NAMES <- toupper(added)
[10:20:21.411]                 for (kk in seq_along(NAMES)) {
[10:20:21.411]                   name <- added[[kk]]
[10:20:21.411]                   NAME <- NAMES[[kk]]
[10:20:21.411]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:21.411]                     next
[10:20:21.411]                   args[[name]] <- ""
[10:20:21.411]                 }
[10:20:21.411]                 NAMES <- toupper(removed)
[10:20:21.411]                 for (kk in seq_along(NAMES)) {
[10:20:21.411]                   name <- removed[[kk]]
[10:20:21.411]                   NAME <- NAMES[[kk]]
[10:20:21.411]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:21.411]                     next
[10:20:21.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:21.411]                 }
[10:20:21.411]                 if (length(args) > 0) 
[10:20:21.411]                   base::do.call(base::Sys.setenv, args = args)
[10:20:21.411]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:21.411]             }
[10:20:21.411]             else {
[10:20:21.411]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:21.411]             }
[10:20:21.411]             {
[10:20:21.411]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:21.411]                   0L) {
[10:20:21.411]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:21.411]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:21.411]                   base::options(opts)
[10:20:21.411]                 }
[10:20:21.411]                 {
[10:20:21.411]                   {
[10:20:21.411]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:21.411]                     NULL
[10:20:21.411]                   }
[10:20:21.411]                   options(future.plan = NULL)
[10:20:21.411]                   if (is.na(NA_character_)) 
[10:20:21.411]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:21.411]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:21.411]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:21.411]                     .init = FALSE)
[10:20:21.411]                 }
[10:20:21.411]             }
[10:20:21.411]         }
[10:20:21.411]     })
[10:20:21.411]     if (FALSE) {
[10:20:21.411]         base::sink(type = "output", split = FALSE)
[10:20:21.411]         if (NA) {
[10:20:21.411]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:21.411]         }
[10:20:21.411]         else {
[10:20:21.411]             ...future.result["stdout"] <- base::list(NULL)
[10:20:21.411]         }
[10:20:21.411]         base::close(...future.stdout)
[10:20:21.411]         ...future.stdout <- NULL
[10:20:21.411]     }
[10:20:21.411]     ...future.result$conditions <- ...future.conditions
[10:20:21.411]     ...future.result$finished <- base::Sys.time()
[10:20:21.411]     ...future.result
[10:20:21.411] }
[10:20:21.414] Exporting 5 global objects (1.63 KiB) to cluster node #1 ...
[10:20:21.414] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[10:20:21.415] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[10:20:21.415] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[10:20:21.415] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[10:20:21.415] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ...
[10:20:21.416] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ... DONE
[10:20:21.416] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:20:21.416] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:20:21.416] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[10:20:21.416] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[10:20:21.417] Exporting 5 global objects (1.63 KiB) to cluster node #1 ... DONE
[10:20:21.417] MultisessionFuture started
[10:20:21.417] - Launch lazy future ... done
[10:20:21.417] run() for ‘MultisessionFuture’ ... done
[10:20:21.417] Created future:
[10:20:21.417] MultisessionFuture:
[10:20:21.417] Label: ‘future_mapply-1’
[10:20:21.417] Expression:
[10:20:21.417] {
[10:20:21.417]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:21.417]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:21.417]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:21.417]         on.exit(options(oopts), add = TRUE)
[10:20:21.417]     }
[10:20:21.417]     {
[10:20:21.417]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:21.417]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:20:21.417]         do.call(mapply, args = args)
[10:20:21.417]     }
[10:20:21.417] }
[10:20:21.417] Lazy evaluation: FALSE
[10:20:21.417] Asynchronous evaluation: TRUE
[10:20:21.417] Local evaluation: TRUE
[10:20:21.417] Environment: R_GlobalEnv
[10:20:21.417] Capture standard output: NA
[10:20:21.417] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:21.417] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:21.417] Packages: <none>
[10:20:21.417] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:21.417] Resolved: FALSE
[10:20:21.417] Value: <not collected>
[10:20:21.417] Conditions captured: <none>
[10:20:21.417] Early signaling: FALSE
[10:20:21.417] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:21.417] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:21.429] Chunk #1 of 2 ... DONE
[10:20:21.429] Chunk #2 of 2 ...
[10:20:21.429]  - Finding globals in '...' for chunk #2 ...
[10:20:21.429] getGlobalsAndPackages() ...
[10:20:21.429] Searching for globals...
[10:20:21.429] 
[10:20:21.430] Searching for globals ... DONE
[10:20:21.430] - globals: [0] <none>
[10:20:21.430] getGlobalsAndPackages() ... DONE
[10:20:21.430]    + additional globals found: [n=0] 
[10:20:21.430]    + additional namespaces needed: [n=0] 
[10:20:21.430]  - Finding globals in '...' for chunk #2 ... DONE
[10:20:21.430]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:20:21.430]  - seeds: <none>
[10:20:21.430]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:21.430] getGlobalsAndPackages() ...
[10:20:21.430] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:21.431] Resolving globals: FALSE
[10:20:21.431] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[10:20:21.431] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[10:20:21.431] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:20:21.432] 
[10:20:21.432] getGlobalsAndPackages() ... DONE
[10:20:21.432] run() for ‘Future’ ...
[10:20:21.432] - state: ‘created’
[10:20:21.432] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:20:21.446] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:21.446] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:20:21.446]   - Field: ‘node’
[10:20:21.446]   - Field: ‘label’
[10:20:21.446]   - Field: ‘local’
[10:20:21.447]   - Field: ‘owner’
[10:20:21.447]   - Field: ‘envir’
[10:20:21.447]   - Field: ‘workers’
[10:20:21.447]   - Field: ‘packages’
[10:20:21.447]   - Field: ‘gc’
[10:20:21.447]   - Field: ‘conditions’
[10:20:21.447]   - Field: ‘persistent’
[10:20:21.447]   - Field: ‘expr’
[10:20:21.447]   - Field: ‘uuid’
[10:20:21.447]   - Field: ‘seed’
[10:20:21.447]   - Field: ‘version’
[10:20:21.447]   - Field: ‘result’
[10:20:21.448]   - Field: ‘asynchronous’
[10:20:21.448]   - Field: ‘calls’
[10:20:21.448]   - Field: ‘globals’
[10:20:21.448]   - Field: ‘stdout’
[10:20:21.448]   - Field: ‘earlySignal’
[10:20:21.448]   - Field: ‘lazy’
[10:20:21.448]   - Field: ‘state’
[10:20:21.448] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:20:21.448] - Launch lazy future ...
[10:20:21.448] Packages needed by the future expression (n = 0): <none>
[10:20:21.449] Packages needed by future strategies (n = 0): <none>
[10:20:21.449] {
[10:20:21.449]     {
[10:20:21.449]         {
[10:20:21.449]             ...future.startTime <- base::Sys.time()
[10:20:21.449]             {
[10:20:21.449]                 {
[10:20:21.449]                   {
[10:20:21.449]                     {
[10:20:21.449]                       base::local({
[10:20:21.449]                         has_future <- base::requireNamespace("future", 
[10:20:21.449]                           quietly = TRUE)
[10:20:21.449]                         if (has_future) {
[10:20:21.449]                           ns <- base::getNamespace("future")
[10:20:21.449]                           version <- ns[[".package"]][["version"]]
[10:20:21.449]                           if (is.null(version)) 
[10:20:21.449]                             version <- utils::packageVersion("future")
[10:20:21.449]                         }
[10:20:21.449]                         else {
[10:20:21.449]                           version <- NULL
[10:20:21.449]                         }
[10:20:21.449]                         if (!has_future || version < "1.8.0") {
[10:20:21.449]                           info <- base::c(r_version = base::gsub("R version ", 
[10:20:21.449]                             "", base::R.version$version.string), 
[10:20:21.449]                             platform = base::sprintf("%s (%s-bit)", 
[10:20:21.449]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:20:21.449]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:20:21.449]                               "release", "version")], collapse = " "), 
[10:20:21.449]                             hostname = base::Sys.info()[["nodename"]])
[10:20:21.449]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:20:21.449]                             info)
[10:20:21.449]                           info <- base::paste(info, collapse = "; ")
[10:20:21.449]                           if (!has_future) {
[10:20:21.449]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:20:21.449]                               info)
[10:20:21.449]                           }
[10:20:21.449]                           else {
[10:20:21.449]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:20:21.449]                               info, version)
[10:20:21.449]                           }
[10:20:21.449]                           base::stop(msg)
[10:20:21.449]                         }
[10:20:21.449]                       })
[10:20:21.449]                     }
[10:20:21.449]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:20:21.449]                     base::options(mc.cores = 1L)
[10:20:21.449]                   }
[10:20:21.449]                   ...future.strategy.old <- future::plan("list")
[10:20:21.449]                   options(future.plan = NULL)
[10:20:21.449]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:20:21.449]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:20:21.449]                 }
[10:20:21.449]                 ...future.workdir <- getwd()
[10:20:21.449]             }
[10:20:21.449]             ...future.oldOptions <- base::as.list(base::.Options)
[10:20:21.449]             ...future.oldEnvVars <- base::Sys.getenv()
[10:20:21.449]         }
[10:20:21.449]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:20:21.449]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:20:21.449]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:20:21.449]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:20:21.449]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:20:21.449]             future.stdout.windows.reencode = NULL, width = 80L)
[10:20:21.449]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:20:21.449]             base::names(...future.oldOptions))
[10:20:21.449]     }
[10:20:21.449]     if (TRUE) {
[10:20:21.449]     }
[10:20:21.449]     else {
[10:20:21.449]         if (NA) {
[10:20:21.449]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:20:21.449]                 open = "w")
[10:20:21.449]         }
[10:20:21.449]         else {
[10:20:21.449]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:20:21.449]                 windows = "NUL", "/dev/null"), open = "w")
[10:20:21.449]         }
[10:20:21.449]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:20:21.449]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:20:21.449]             base::sink(type = "output", split = FALSE)
[10:20:21.449]             base::close(...future.stdout)
[10:20:21.449]         }, add = TRUE)
[10:20:21.449]     }
[10:20:21.449]     ...future.frame <- base::sys.nframe()
[10:20:21.449]     ...future.conditions <- base::list()
[10:20:21.449]     ...future.rng <- base::globalenv()$.Random.seed
[10:20:21.449]     if (FALSE) {
[10:20:21.449]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:20:21.449]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:20:21.449]     }
[10:20:21.449]     ...future.result <- base::tryCatch({
[10:20:21.449]         base::withCallingHandlers({
[10:20:21.449]             ...future.value <- base::withVisible(base::local({
[10:20:21.449]                 ...future.makeSendCondition <- base::local({
[10:20:21.449]                   sendCondition <- NULL
[10:20:21.449]                   function(frame = 1L) {
[10:20:21.449]                     if (is.function(sendCondition)) 
[10:20:21.449]                       return(sendCondition)
[10:20:21.449]                     ns <- getNamespace("parallel")
[10:20:21.449]                     if (exists("sendData", mode = "function", 
[10:20:21.449]                       envir = ns)) {
[10:20:21.449]                       parallel_sendData <- get("sendData", mode = "function", 
[10:20:21.449]                         envir = ns)
[10:20:21.449]                       envir <- sys.frame(frame)
[10:20:21.449]                       master <- NULL
[10:20:21.449]                       while (!identical(envir, .GlobalEnv) && 
[10:20:21.449]                         !identical(envir, emptyenv())) {
[10:20:21.449]                         if (exists("master", mode = "list", envir = envir, 
[10:20:21.449]                           inherits = FALSE)) {
[10:20:21.449]                           master <- get("master", mode = "list", 
[10:20:21.449]                             envir = envir, inherits = FALSE)
[10:20:21.449]                           if (inherits(master, c("SOCKnode", 
[10:20:21.449]                             "SOCK0node"))) {
[10:20:21.449]                             sendCondition <<- function(cond) {
[10:20:21.449]                               data <- list(type = "VALUE", value = cond, 
[10:20:21.449]                                 success = TRUE)
[10:20:21.449]                               parallel_sendData(master, data)
[10:20:21.449]                             }
[10:20:21.449]                             return(sendCondition)
[10:20:21.449]                           }
[10:20:21.449]                         }
[10:20:21.449]                         frame <- frame + 1L
[10:20:21.449]                         envir <- sys.frame(frame)
[10:20:21.449]                       }
[10:20:21.449]                     }
[10:20:21.449]                     sendCondition <<- function(cond) NULL
[10:20:21.449]                   }
[10:20:21.449]                 })
[10:20:21.449]                 withCallingHandlers({
[10:20:21.449]                   {
[10:20:21.449]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:21.449]                     if (!identical(...future.globals.maxSize.org, 
[10:20:21.449]                       ...future.globals.maxSize)) {
[10:20:21.449]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:21.449]                       on.exit(options(oopts), add = TRUE)
[10:20:21.449]                     }
[10:20:21.449]                     {
[10:20:21.449]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:21.449]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:20:21.449]                         USE.NAMES = FALSE)
[10:20:21.449]                       do.call(mapply, args = args)
[10:20:21.449]                     }
[10:20:21.449]                   }
[10:20:21.449]                 }, immediateCondition = function(cond) {
[10:20:21.449]                   sendCondition <- ...future.makeSendCondition()
[10:20:21.449]                   sendCondition(cond)
[10:20:21.449]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:21.449]                   {
[10:20:21.449]                     inherits <- base::inherits
[10:20:21.449]                     invokeRestart <- base::invokeRestart
[10:20:21.449]                     is.null <- base::is.null
[10:20:21.449]                     muffled <- FALSE
[10:20:21.449]                     if (inherits(cond, "message")) {
[10:20:21.449]                       muffled <- grepl(pattern, "muffleMessage")
[10:20:21.449]                       if (muffled) 
[10:20:21.449]                         invokeRestart("muffleMessage")
[10:20:21.449]                     }
[10:20:21.449]                     else if (inherits(cond, "warning")) {
[10:20:21.449]                       muffled <- grepl(pattern, "muffleWarning")
[10:20:21.449]                       if (muffled) 
[10:20:21.449]                         invokeRestart("muffleWarning")
[10:20:21.449]                     }
[10:20:21.449]                     else if (inherits(cond, "condition")) {
[10:20:21.449]                       if (!is.null(pattern)) {
[10:20:21.449]                         computeRestarts <- base::computeRestarts
[10:20:21.449]                         grepl <- base::grepl
[10:20:21.449]                         restarts <- computeRestarts(cond)
[10:20:21.449]                         for (restart in restarts) {
[10:20:21.449]                           name <- restart$name
[10:20:21.449]                           if (is.null(name)) 
[10:20:21.449]                             next
[10:20:21.449]                           if (!grepl(pattern, name)) 
[10:20:21.449]                             next
[10:20:21.449]                           invokeRestart(restart)
[10:20:21.449]                           muffled <- TRUE
[10:20:21.449]                           break
[10:20:21.449]                         }
[10:20:21.449]                       }
[10:20:21.449]                     }
[10:20:21.449]                     invisible(muffled)
[10:20:21.449]                   }
[10:20:21.449]                   muffleCondition(cond)
[10:20:21.449]                 })
[10:20:21.449]             }))
[10:20:21.449]             future::FutureResult(value = ...future.value$value, 
[10:20:21.449]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:21.449]                   ...future.rng), globalenv = if (FALSE) 
[10:20:21.449]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:20:21.449]                     ...future.globalenv.names))
[10:20:21.449]                 else NULL, started = ...future.startTime, version = "1.8")
[10:20:21.449]         }, condition = base::local({
[10:20:21.449]             c <- base::c
[10:20:21.449]             inherits <- base::inherits
[10:20:21.449]             invokeRestart <- base::invokeRestart
[10:20:21.449]             length <- base::length
[10:20:21.449]             list <- base::list
[10:20:21.449]             seq.int <- base::seq.int
[10:20:21.449]             signalCondition <- base::signalCondition
[10:20:21.449]             sys.calls <- base::sys.calls
[10:20:21.449]             `[[` <- base::`[[`
[10:20:21.449]             `+` <- base::`+`
[10:20:21.449]             `<<-` <- base::`<<-`
[10:20:21.449]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:20:21.449]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:20:21.449]                   3L)]
[10:20:21.449]             }
[10:20:21.449]             function(cond) {
[10:20:21.449]                 is_error <- inherits(cond, "error")
[10:20:21.449]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:20:21.449]                   NULL)
[10:20:21.449]                 if (is_error) {
[10:20:21.449]                   sessionInformation <- function() {
[10:20:21.449]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:20:21.449]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:20:21.449]                       search = base::search(), system = base::Sys.info())
[10:20:21.449]                   }
[10:20:21.449]                   ...future.conditions[[length(...future.conditions) + 
[10:20:21.449]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:20:21.449]                     cond$call), session = sessionInformation(), 
[10:20:21.449]                     timestamp = base::Sys.time(), signaled = 0L)
[10:20:21.449]                   signalCondition(cond)
[10:20:21.449]                 }
[10:20:21.449]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:20:21.449]                 "immediateCondition"))) {
[10:20:21.449]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:20:21.449]                   ...future.conditions[[length(...future.conditions) + 
[10:20:21.449]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:20:21.449]                   if (TRUE && !signal) {
[10:20:21.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:21.449]                     {
[10:20:21.449]                       inherits <- base::inherits
[10:20:21.449]                       invokeRestart <- base::invokeRestart
[10:20:21.449]                       is.null <- base::is.null
[10:20:21.449]                       muffled <- FALSE
[10:20:21.449]                       if (inherits(cond, "message")) {
[10:20:21.449]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:21.449]                         if (muffled) 
[10:20:21.449]                           invokeRestart("muffleMessage")
[10:20:21.449]                       }
[10:20:21.449]                       else if (inherits(cond, "warning")) {
[10:20:21.449]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:21.449]                         if (muffled) 
[10:20:21.449]                           invokeRestart("muffleWarning")
[10:20:21.449]                       }
[10:20:21.449]                       else if (inherits(cond, "condition")) {
[10:20:21.449]                         if (!is.null(pattern)) {
[10:20:21.449]                           computeRestarts <- base::computeRestarts
[10:20:21.449]                           grepl <- base::grepl
[10:20:21.449]                           restarts <- computeRestarts(cond)
[10:20:21.449]                           for (restart in restarts) {
[10:20:21.449]                             name <- restart$name
[10:20:21.449]                             if (is.null(name)) 
[10:20:21.449]                               next
[10:20:21.449]                             if (!grepl(pattern, name)) 
[10:20:21.449]                               next
[10:20:21.449]                             invokeRestart(restart)
[10:20:21.449]                             muffled <- TRUE
[10:20:21.449]                             break
[10:20:21.449]                           }
[10:20:21.449]                         }
[10:20:21.449]                       }
[10:20:21.449]                       invisible(muffled)
[10:20:21.449]                     }
[10:20:21.449]                     muffleCondition(cond, pattern = "^muffle")
[10:20:21.449]                   }
[10:20:21.449]                 }
[10:20:21.449]                 else {
[10:20:21.449]                   if (TRUE) {
[10:20:21.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:20:21.449]                     {
[10:20:21.449]                       inherits <- base::inherits
[10:20:21.449]                       invokeRestart <- base::invokeRestart
[10:20:21.449]                       is.null <- base::is.null
[10:20:21.449]                       muffled <- FALSE
[10:20:21.449]                       if (inherits(cond, "message")) {
[10:20:21.449]                         muffled <- grepl(pattern, "muffleMessage")
[10:20:21.449]                         if (muffled) 
[10:20:21.449]                           invokeRestart("muffleMessage")
[10:20:21.449]                       }
[10:20:21.449]                       else if (inherits(cond, "warning")) {
[10:20:21.449]                         muffled <- grepl(pattern, "muffleWarning")
[10:20:21.449]                         if (muffled) 
[10:20:21.449]                           invokeRestart("muffleWarning")
[10:20:21.449]                       }
[10:20:21.449]                       else if (inherits(cond, "condition")) {
[10:20:21.449]                         if (!is.null(pattern)) {
[10:20:21.449]                           computeRestarts <- base::computeRestarts
[10:20:21.449]                           grepl <- base::grepl
[10:20:21.449]                           restarts <- computeRestarts(cond)
[10:20:21.449]                           for (restart in restarts) {
[10:20:21.449]                             name <- restart$name
[10:20:21.449]                             if (is.null(name)) 
[10:20:21.449]                               next
[10:20:21.449]                             if (!grepl(pattern, name)) 
[10:20:21.449]                               next
[10:20:21.449]                             invokeRestart(restart)
[10:20:21.449]                             muffled <- TRUE
[10:20:21.449]                             break
[10:20:21.449]                           }
[10:20:21.449]                         }
[10:20:21.449]                       }
[10:20:21.449]                       invisible(muffled)
[10:20:21.449]                     }
[10:20:21.449]                     muffleCondition(cond, pattern = "^muffle")
[10:20:21.449]                   }
[10:20:21.449]                 }
[10:20:21.449]             }
[10:20:21.449]         }))
[10:20:21.449]     }, error = function(ex) {
[10:20:21.449]         base::structure(base::list(value = NULL, visible = NULL, 
[10:20:21.449]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:20:21.449]                 ...future.rng), started = ...future.startTime, 
[10:20:21.449]             finished = Sys.time(), session_uuid = NA_character_, 
[10:20:21.449]             version = "1.8"), class = "FutureResult")
[10:20:21.449]     }, finally = {
[10:20:21.449]         if (!identical(...future.workdir, getwd())) 
[10:20:21.449]             setwd(...future.workdir)
[10:20:21.449]         {
[10:20:21.449]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:20:21.449]                 ...future.oldOptions$nwarnings <- NULL
[10:20:21.449]             }
[10:20:21.449]             base::options(...future.oldOptions)
[10:20:21.449]             if (.Platform$OS.type == "windows") {
[10:20:21.449]                 old_names <- names(...future.oldEnvVars)
[10:20:21.449]                 envs <- base::Sys.getenv()
[10:20:21.449]                 names <- names(envs)
[10:20:21.449]                 common <- intersect(names, old_names)
[10:20:21.449]                 added <- setdiff(names, old_names)
[10:20:21.449]                 removed <- setdiff(old_names, names)
[10:20:21.449]                 changed <- common[...future.oldEnvVars[common] != 
[10:20:21.449]                   envs[common]]
[10:20:21.449]                 NAMES <- toupper(changed)
[10:20:21.449]                 args <- list()
[10:20:21.449]                 for (kk in seq_along(NAMES)) {
[10:20:21.449]                   name <- changed[[kk]]
[10:20:21.449]                   NAME <- NAMES[[kk]]
[10:20:21.449]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:21.449]                     next
[10:20:21.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:21.449]                 }
[10:20:21.449]                 NAMES <- toupper(added)
[10:20:21.449]                 for (kk in seq_along(NAMES)) {
[10:20:21.449]                   name <- added[[kk]]
[10:20:21.449]                   NAME <- NAMES[[kk]]
[10:20:21.449]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:21.449]                     next
[10:20:21.449]                   args[[name]] <- ""
[10:20:21.449]                 }
[10:20:21.449]                 NAMES <- toupper(removed)
[10:20:21.449]                 for (kk in seq_along(NAMES)) {
[10:20:21.449]                   name <- removed[[kk]]
[10:20:21.449]                   NAME <- NAMES[[kk]]
[10:20:21.449]                   if (name != NAME && is.element(NAME, old_names)) 
[10:20:21.449]                     next
[10:20:21.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:20:21.449]                 }
[10:20:21.449]                 if (length(args) > 0) 
[10:20:21.449]                   base::do.call(base::Sys.setenv, args = args)
[10:20:21.449]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:20:21.449]             }
[10:20:21.449]             else {
[10:20:21.449]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:20:21.449]             }
[10:20:21.449]             {
[10:20:21.449]                 if (base::length(...future.futureOptionsAdded) > 
[10:20:21.449]                   0L) {
[10:20:21.449]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:20:21.449]                   base::names(opts) <- ...future.futureOptionsAdded
[10:20:21.449]                   base::options(opts)
[10:20:21.449]                 }
[10:20:21.449]                 {
[10:20:21.449]                   {
[10:20:21.449]                     base::options(mc.cores = ...future.mc.cores.old)
[10:20:21.449]                     NULL
[10:20:21.449]                   }
[10:20:21.449]                   options(future.plan = NULL)
[10:20:21.449]                   if (is.na(NA_character_)) 
[10:20:21.449]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:20:21.449]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:20:21.449]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:20:21.449]                     .init = FALSE)
[10:20:21.449]                 }
[10:20:21.449]             }
[10:20:21.449]         }
[10:20:21.449]     })
[10:20:21.449]     if (FALSE) {
[10:20:21.449]         base::sink(type = "output", split = FALSE)
[10:20:21.449]         if (NA) {
[10:20:21.449]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:20:21.449]         }
[10:20:21.449]         else {
[10:20:21.449]             ...future.result["stdout"] <- base::list(NULL)
[10:20:21.449]         }
[10:20:21.449]         base::close(...future.stdout)
[10:20:21.449]         ...future.stdout <- NULL
[10:20:21.449]     }
[10:20:21.449]     ...future.result$conditions <- ...future.conditions
[10:20:21.449]     ...future.result$finished <- base::Sys.time()
[10:20:21.449]     ...future.result
[10:20:21.449] }
[10:20:21.452] Exporting 5 global objects (1.63 KiB) to cluster node #2 ...
[10:20:21.452] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[10:20:21.452] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[10:20:21.452] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[10:20:21.453] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[10:20:21.453] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ...
[10:20:21.453] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ... DONE
[10:20:21.453] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:20:21.454] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:20:21.454] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[10:20:21.454] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[10:20:21.454] Exporting 5 global objects (1.63 KiB) to cluster node #2 ... DONE
[10:20:21.455] MultisessionFuture started
[10:20:21.455] - Launch lazy future ... done
[10:20:21.455] run() for ‘MultisessionFuture’ ... done
[10:20:21.455] Created future:
[10:20:21.455] MultisessionFuture:
[10:20:21.455] Label: ‘future_mapply-2’
[10:20:21.455] Expression:
[10:20:21.455] {
[10:20:21.455]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:20:21.455]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:20:21.455]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:20:21.455]         on.exit(options(oopts), add = TRUE)
[10:20:21.455]     }
[10:20:21.455]     {
[10:20:21.455]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:20:21.455]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:20:21.455]         do.call(mapply, args = args)
[10:20:21.455]     }
[10:20:21.455] }
[10:20:21.455] Lazy evaluation: FALSE
[10:20:21.455] Asynchronous evaluation: TRUE
[10:20:21.455] Local evaluation: TRUE
[10:20:21.455] Environment: R_GlobalEnv
[10:20:21.455] Capture standard output: NA
[10:20:21.455] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:20:21.455] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[10:20:21.455] Packages: <none>
[10:20:21.455] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:20:21.455] Resolved: FALSE
[10:20:21.455] Value: <not collected>
[10:20:21.455] Conditions captured: <none>
[10:20:21.455] Early signaling: FALSE
[10:20:21.455] Owner process: 6258a5f1-d913-27ce-2df9-53b011aaaa9f
[10:20:21.455] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:20:21.466] Chunk #2 of 2 ... DONE
[10:20:21.467] Launching 2 futures (chunks) ... DONE
[10:20:21.467] Resolving 2 futures (chunks) ...
[10:20:21.467] resolve() on list ...
[10:20:21.467]  recursive: 0
[10:20:21.467]  length: 2
[10:20:21.467] 
[10:20:21.509] receiveMessageFromWorker() for ClusterFuture ...
[10:20:21.509] - Validating connection of MultisessionFuture
[10:20:21.509] - received message: FutureResult
[10:20:21.509] - Received FutureResult
[10:20:21.510] - Erased future from FutureRegistry
[10:20:21.510] result() for ClusterFuture ...
[10:20:21.510] - result already collected: FutureResult
[10:20:21.510] result() for ClusterFuture ... done
[10:20:21.510] receiveMessageFromWorker() for ClusterFuture ... done
[10:20:21.510] Future #2
[10:20:21.510] result() for ClusterFuture ...
[10:20:21.510] - result already collected: FutureResult
[10:20:21.510] result() for ClusterFuture ... done
[10:20:21.510] result() for ClusterFuture ...
[10:20:21.510] - result already collected: FutureResult
[10:20:21.511] result() for ClusterFuture ... done
[10:20:21.511] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:20:21.511] - nx: 2
[10:20:21.511] - relay: TRUE
[10:20:21.511] - stdout: TRUE
[10:20:21.511] - signal: TRUE
[10:20:21.511] - resignal: FALSE
[10:20:21.511] - force: TRUE
[10:20:21.511] - relayed: [n=2] FALSE, FALSE
[10:20:21.511] - queued futures: [n=2] FALSE, FALSE
[10:20:21.511]  - until=1
[10:20:21.511]  - relaying element #1
[10:20:21.511] - relayed: [n=2] FALSE, FALSE
[10:20:21.512] - queued futures: [n=2] FALSE, TRUE
[10:20:21.512] signalConditionsASAP(NULL, pos=2) ... done
[10:20:21.512]  length: 1 (resolved future 2)
[10:20:21.960] receiveMessageFromWorker() for ClusterFuture ...
[10:20:21.960] - Validating connection of MultisessionFuture
[10:20:21.960] - received message: FutureResult
[10:20:21.960] - Received FutureResult
[10:20:21.960] - Erased future from FutureRegistry
[10:20:21.961] result() for ClusterFuture ...
[10:20:21.961] - result already collected: FutureResult
[10:20:21.961] result() for ClusterFuture ... done
[10:20:21.961] receiveMessageFromWorker() for ClusterFuture ... done
[10:20:21.961] Future #1
[10:20:21.961] result() for ClusterFuture ...
[10:20:21.961] - result already collected: FutureResult
[10:20:21.961] result() for ClusterFuture ... done
[10:20:21.961] result() for ClusterFuture ...
[10:20:21.961] - result already collected: FutureResult
[10:20:21.961] result() for ClusterFuture ... done
[10:20:21.961] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:20:21.962] - nx: 2
[10:20:21.962] - relay: TRUE
[10:20:21.962] - stdout: TRUE
[10:20:21.962] - signal: TRUE
[10:20:21.962] - resignal: FALSE
[10:20:21.962] - force: TRUE
[10:20:21.962] - relayed: [n=2] FALSE, FALSE
[10:20:21.962] - queued futures: [n=2] FALSE, TRUE
[10:20:21.962]  - until=1
[10:20:21.962]  - relaying element #1
[10:20:21.962] result() for ClusterFuture ...
[10:20:21.962] - result already collected: FutureResult
[10:20:21.963] result() for ClusterFuture ... done
[10:20:21.963] result() for ClusterFuture ...
[10:20:21.963] - result already collected: FutureResult
[10:20:21.963] result() for ClusterFuture ... done
[10:20:21.963] result() for ClusterFuture ...
[10:20:21.963] - result already collected: FutureResult
[10:20:21.963] result() for ClusterFuture ... done
[10:20:21.963] result() for ClusterFuture ...
[10:20:21.963] - result already collected: FutureResult
[10:20:21.963] result() for ClusterFuture ... done
[10:20:21.963] - relayed: [n=2] TRUE, FALSE
[10:20:21.963] - queued futures: [n=2] TRUE, TRUE
[10:20:21.963] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:20:21.964]  length: 0 (resolved future 1)
[10:20:21.964] Relaying remaining futures
[10:20:21.964] signalConditionsASAP(NULL, pos=0) ...
[10:20:21.964] - nx: 2
[10:20:21.964] - relay: TRUE
[10:20:21.964] - stdout: TRUE
[10:20:21.964] - signal: TRUE
[10:20:21.964] - resignal: FALSE
[10:20:21.964] - force: TRUE
[10:20:21.964] - relayed: [n=2] TRUE, FALSE
[10:20:21.964] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:20:21.964]  - relaying element #2
[10:20:21.965] result() for ClusterFuture ...
[10:20:21.965] - result already collected: FutureResult
[10:20:21.965] result() for ClusterFuture ... done
[10:20:21.965] result() for ClusterFuture ...
[10:20:21.965] - result already collected: FutureResult
[10:20:21.965] result() for ClusterFuture ... done
[10:20:21.965] result() for ClusterFuture ...
[10:20:21.965] - result already collected: FutureResult
[10:20:21.965] result() for ClusterFuture ... done
[10:20:21.965] result() for ClusterFuture ...
[10:20:21.965] - result already collected: FutureResult
[10:20:21.965] result() for ClusterFuture ... done
[10:20:21.966] - relayed: [n=2] TRUE, TRUE
[10:20:21.966] - queued futures: [n=2] TRUE, TRUE
[10:20:21.966] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[10:20:21.966] resolve() on list ... DONE
[10:20:21.966] result() for ClusterFuture ...
[10:20:21.966] - result already collected: FutureResult
[10:20:21.966] result() for ClusterFuture ... done
[10:20:21.966] result() for ClusterFuture ...
[10:20:21.966] - result already collected: FutureResult
[10:20:21.966] result() for ClusterFuture ... done
[10:20:21.966] result() for ClusterFuture ...
[10:20:21.966] - result already collected: FutureResult
[10:20:21.966] result() for ClusterFuture ... done
[10:20:21.967] result() for ClusterFuture ...
[10:20:21.967] - result already collected: FutureResult
[10:20:21.967] result() for ClusterFuture ... done
[10:20:21.967]  - Number of value chunks collected: 2
[10:20:21.967] Resolving 2 futures (chunks) ... DONE
[10:20:21.967] Reducing values from 2 chunks ...
[10:20:21.967]  - Number of values collected after concatenation: 2
[10:20:21.967]  - Number of values expected: 2
[10:20:21.967] Reducing values from 2 chunks ... DONE
[10:20:21.967] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 2 cores ... DONE
> 
> message("*** future_*apply() and 'future.stdout' ... DONE")
*** future_*apply() and 'future.stdout' ... DONE
> 
> source("incl/end.R")
[10:20:21.968] plan(): Setting new future strategy stack:
[10:20:21.968] List of future strategies:
[10:20:21.968] 1. FutureStrategy:
[10:20:21.968]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:20:21.968]    - tweaked: FALSE
[10:20:21.968]    - call: future::plan(oplan)
[10:20:21.969] plan(): nbrOfWorkers() = 1
> 
